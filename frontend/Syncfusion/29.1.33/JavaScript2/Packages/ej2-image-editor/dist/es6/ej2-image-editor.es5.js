import { isNullOrUndefined, extend, Browser, getComponent, EventHandler, Property, ChildProperty, getUniqueID, setValue, removeClass, addClass, compile, Complex, Event, NotifyPropertyChanges, Component, L10n, detach, select } from '@syncfusion/ej2-base';
import { hideSpinner, showSpinner, Dialog, createSpinner } from '@syncfusion/ej2-popups';
import { Uploader, NumericTextBox, TextBox, Slider, ColorPicker } from '@syncfusion/ej2-inputs';
import { Toolbar } from '@syncfusion/ej2-navigations';
import { Button } from '@syncfusion/ej2-buttons';
import { DropDownButton } from '@syncfusion/ej2-splitbuttons';

var Crop = /** @class */ (function () {
    function Crop(parent) {
        this.croppedDegree = 0; // Specifies the degree when crop is performed
        this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 }; // To redraw old image when navigate to crop tab
        this.tempFlipPanPoint = { x: 0, y: 0 };
        this.isPreventScaling = false;
        this.isInitCrop = false;
        this.isTransformCrop = false;
        this.parent = parent;
        this.addEventListener();
    }
    Crop.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    Crop.prototype.addEventListener = function () {
        this.parent.on('crop', this.cropping, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    Crop.prototype.removeEventListener = function () {
        this.parent.off('crop', this.cropping);
        this.parent.off('destroyed', this.destroy);
    };
    Crop.prototype.cropping = function (args) {
        this.updateCropPvtVar();
        switch (args.prop) {
            case 'cropCircle':
                this.cropCircle(args.value['context'], args.value['isSave'], args.value['isFlip']);
                break;
            case 'setCurrSelPoints':
                this.setCurrSelPoints(args.value['isSetDimension']);
                break;
            case 'updateRotatePan':
                this.updateRotatePan();
                break;
            case 'crop':
                this.crop(args.value['obj']);
                break;
            case 'calcRatio':
                this.calcRatio(args.value['obj'], args.value['dimension']);
                break;
            case 'getCurrFlipState':
                this.getCurrFlipState(args.value['panObj']);
                break;
            case 'getPreviousCropCurrentObj':
                args.value['obj']['prevObj'] = this.prevCropCurrObj;
                break;
            case 'setPreviousCropCurrentObj':
                this.prevCropCurrObj = args.value['obj'];
                break;
            case 'setCropDestPoints':
                this.cropDestPoints = args.value['point'];
                break;
            case 'getTempFlipPanPoint':
                args.value['obj']['point'] = this.tempFlipPanPoint;
                break;
            case 'setTempFlipPanPoint':
                if (isNullOrUndefined(args.value['isAdd'])) {
                    this.tempFlipPanPoint = args.value['point'];
                }
                else {
                    this.tempFlipPanPoint.x += args.value['point'].x;
                    this.tempFlipPanPoint.y += args.value['point'].y;
                }
                break;
            case 'getPreventScaling':
                args.value['obj']['bool'] = this.isPreventScaling;
                break;
            case 'adjustStraightenForShapes':
                this.adjustStraightenForShapes(args.value['type'], args.value['isInitialRotated']);
                break;
            case 'resizeWrapper':
                this.resizeWrapper();
                break;
            case 'setTransformCrop':
                this.isTransformCrop = args.value['bool'];
                break;
            case 'setInitCrop':
                this.isInitCrop = args.value['bool'];
                break;
            case 'resetZoom':
                this.resetZoom();
                break;
            case 'revertTransform':
                this.revertTransform(args.value['type'], args.value['coll']);
                break;
            case 'reset':
                this.reset();
                break;
        }
    };
    Crop.prototype.getModuleName = function () {
        return 'crop';
    };
    Crop.prototype.updateCropPvtVar = function () {
        var parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
    };
    Crop.prototype.reset = function () {
        this.prevCropCurrObj = null;
        this.croppedDegree = 0;
        this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 };
        this.tempFlipPanPoint = { x: 0, y: 0 };
        this.isPreventScaling = false;
        this.isInitCrop = false;
        this.isTransformCrop = false;
    };
    Crop.prototype.cropImg = function (isRotateCrop) {
        var parent = this.parent;
        var isNullCrop = isNullOrUndefined(isRotateCrop);
        var resizeIcon = parent.element.querySelector('#' + parent.element.id + '_nonaspectratio');
        var actPoint = parent.activeObj.activePoint;
        var img = parent.img;
        var isRotated = false;
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
            var currentValue = parent.rotateFlipColl[i];
            if (currentValue === 90 || currentValue === -90) {
                isRotated = true;
            }
        }
        parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        if (isNullCrop || resizeIcon) {
            this.croppedDegree = parent.transform.degree;
        }
        if (isNullCrop && (parent.transform.degree !== 0) || isRotated) {
            this.updateCropObj();
            var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
            parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });
            this.rotateCrop();
        }
        else if (isNullCrop && parent.transform.currFlipState !== '') {
            this.updateCropObj();
            var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
            parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });
            this.flipCrop();
        }
        else {
            this.adjustStraightenForShapes('initial', false);
            parent.notify('draw', { prop: 'setTempZoomFactor', onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
            var ratio = this.calcRatio();
            if (isNullCrop || !isRotateCrop) { // isRotateCrop is NULL or False
                this.updateCropObj();
                parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
                parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
                parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });
                parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
                this.cropDestPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
            }
            var obj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false, value: { width: actPoint.width * ratio.width,
                    height: actPoint.height * ratio.height, obj: obj, isImgShape: null } });
            var maxDimension = obj;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.img = { srcLeft: (actPoint.startX * ratio.width) - (img.destLeft * ratio.width),
                srcTop: (actPoint.startY * ratio.height) - (img.destTop * ratio.height),
                srcWidth: (actPoint.width * ratio.width), srcHeight: (actPoint.height * ratio.height),
                destLeft: (parent.lowerCanvas.clientWidth - maxDimension.width) / 2,
                destTop: (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2,
                destWidth: maxDimension.width, destHeight: maxDimension.height };
            var temp = this.lowerContext.filter;
            parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
            this.lowerContext.filter = 'none';
            var activeObj = extend({}, parent.activeObj, {}, true);
            this.cropObjColl();
            parent.transform.straighten = 0;
            parent.activeObj = activeObj;
            this.cropFreehandDrawColl();
            parent.shapeColl = [];
            parent.notify('shape', { prop: 'updateShapeColl', onPropertyChange: false });
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
            if (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') {
                this.cropCircle(this.lowerContext);
            }
            else {
                parent.isCircleCrop = false;
            }
            this.lowerContext.filter = temp;
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.currObjType.isCustomCrop = false;
            parent.pan(false);
            parent.transform.defaultZoomFactor = 0;
        }
    };
    Crop.prototype.adjustStraightenForShapes = function (type, isInitialRotated) {
        var parent = this.parent;
        var center = {
            x: parent.img.destLeft + parent.img.destWidth / 2,
            y: parent.img.destTop + parent.img.destHeight / 2
        };
        for (var _i = 0, _a = parent.objColl; _i < _a.length; _i++) {
            var obj = _a[_i];
            if (['rectangle', 'ellipse', 'text', 'image', 'redact'].indexOf(obj.shape) !== -1) {
                if (isInitialRotated || obj.rotatedAngle !== 0) {
                    var _b = obj.activePoint, startX = _b.startX, startY = _b.startY, width = _b.width, height = _b.height;
                    var angle = type === 'initial' ? obj.rotatedAngle : -obj.rotatedAngle;
                    var diffX = startX + width / 2 - center.x;
                    var diffY = startY + height / 2 - center.y;
                    var cosAngle = Math.cos(angle);
                    var sinAngle = Math.sin(angle);
                    var centerX = cosAngle * diffX - sinAngle * diffY + center.x;
                    var centerY = sinAngle * diffX + cosAngle * diffY + center.y;
                    var diffXUpdated = centerX - startX - width / 2;
                    var diffYUpdated = centerY - startY - height / 2;
                    obj.activePoint.startX += diffXUpdated;
                    obj.activePoint.startY += diffYUpdated;
                    obj.activePoint.endX += diffXUpdated;
                    obj.activePoint.endY += diffYUpdated;
                }
            }
        }
    };
    Crop.prototype.updateCropObj = function () {
        this.parent.afterCropActions = [];
        var object = { currObj: {} };
        this.parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var obj = object['currObj'];
        obj.straighten = this.parent.transform.straighten;
        this.parent.cropObj = extend({}, obj, {}, true);
    };
    Crop.prototype.rotateCrop = function () {
        var parent = this.parent;
        var flipState = this.getCurrFlipState();
        var shape = parent.activeObj.shape || '';
        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
        parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
        parent.objColl.push(parent.activeObj);
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        var activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        var tempCurrSelObj = extend({}, parent.currSelectionPoint, {}, true);
        var preventSelObj = { bool: null };
        parent.notify('transform', { prop: 'getPreventSelect', onPropertyChange: false, value: { obj: preventSelObj } });
        parent.notify('transform', { prop: 'setPreventSelect', onPropertyChange: false, value: { bool: true } });
        var coll = extend([], parent.rotateFlipColl, [], true);
        this.panToSelRangle(true);
        activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });
        parent.objColl.pop();
        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
        parent.objColl.push(parent.activeObj);
        // For reverse straightening
        var straighten = parent.transform.straighten;
        if (straighten !== 0) {
            parent.transform.straighten = 0;
            parent.straightenBaseImageCanvas();
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
        }
        this.resetZoom();
        var afterCropActions = extend([], parent.afterCropActions, [], true);
        this.revertTransform('initial', coll);
        // Perform straighten
        if (straighten !== 0) {
            parent.transform.straighten = (flipState === 'horizontal' || flipState === 'vertical') ? -straighten : straighten;
            parent.straightenBaseImageCanvas();
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        }
        activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });
        parent.objColl.pop();
        parent.transform.degree = 0;
        // Checking for selection inside image
        var object = { isIntersect: null };
        parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
        parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: object } });
        var count = 0;
        while (straighten !== 0 && object['isIntersect']) {
            count++;
            if (count === 50) {
                break;
            }
            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: 0.025, zoomPoint: null }, isResize: null });
            parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
            parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: object } });
        }
        this.cropImg(true);
        this.revertTransform('reverse', coll);
        parent.afterCropActions = afterCropActions;
        parent.currSelectionPoint = tempCurrSelObj;
        parent.notify('transform', { prop: 'setPreventSelect', onPropertyChange: false, value: { bool: preventSelObj['bool'] } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        if (shape === 'crop-circle') {
            this.cropCircle(this.lowerContext);
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
    };
    Crop.prototype.revertTransform = function (type, coll) {
        var parent = this.parent;
        var obj = { isRotate: false };
        if (type === 'initial') {
            for (var i = coll.length - 1; i >= 0; i--) {
                var value = coll[i];
                switch (value) {
                    case 90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: -90, obj: obj } });
                        break;
                    case -90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: 90, obj: obj } });
                        break;
                    default:
                        parent.notify('transform', { prop: 'flipImage', value: { direction: parent.toPascalCase(value.toString()) } });
                        break;
                }
            }
        }
        else {
            this.updateFlipState();
            for (var i = 0, len = coll.length; i < len; i++) {
                var value = coll[i];
                switch (value) {
                    case 90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: 90, obj: obj } });
                        break;
                    case -90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: -90, obj: obj } });
                        break;
                    default:
                        parent.notify('transform', { prop: 'flipImage', value: { direction: parent.toPascalCase(value.toString()) } });
                        break;
                }
            }
        }
    };
    Crop.prototype.updateFlipState = function () {
        var parent = this.parent;
        var objColl = parent.objColl;
        for (var i = 0, len = objColl.length; i < len; i++) {
            objColl[i].shapeFlip = '';
        }
        // eslint-disable-next-line
        var pointColl = parent.pointColl;
        for (var i = 0; i < parent.freehandCounter; i++) {
            pointColl[i].shapeFlip = '';
        }
    };
    Crop.prototype.resetZoom = function () {
        var parent = this.parent;
        if (parent.transform.zoomFactor > 0) {
            var zoomFactor = parent.transform.zoomFactor;
            var isUndoRedo = parent.isUndoRedo;
            parent.setProperties({ zoomSettings: { zoomFactor: (zoomFactor * 10) } }, true);
            parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
                value: { previousZoomValue: parent.zoomSettings.zoomFactor } });
            for (var i = 0; i < (zoomFactor * 10); i++) {
                parent.isUndoRedo = true;
                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: -0.1, zoomPoint: null }, isResize: null });
            }
            parent.isUndoRedo = isUndoRedo;
            parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
        }
    };
    Crop.prototype.flipCrop = function () {
        var parent = this.parent;
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: true } });
        parent.panPoint.totalPannedPoint.x += this.tempFlipPanPoint.x;
        parent.panPoint.totalPannedPoint.y += this.tempFlipPanPoint.y;
        var tempCurrFlipState = parent.transform.currFlipState;
        var obj = { flipColl: null };
        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });
        var tempFlipColl = obj['flipColl'];
        parent.notify('transform', { prop: 'setFlipColl', onPropertyChange: false, value: { flipColl: [] } });
        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
        parent.objColl.push(parent.activeObj);
        if (parent.transform.degree === 0) {
            var panX = -parent.cropObj.totalPannedPoint.x;
            var panY = -parent.cropObj.totalPannedPoint.y;
            parent.img.destLeft += panX;
            parent.img.destTop += panY;
            parent.notify('transform', { prop: 'drawPannImage', value: { point: { x: panX, y: panY } } });
            parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            parent.objColl.pop();
            parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
            parent.objColl.push(parent.activeObj);
        }
        this.resetZoom();
        parent.currSelectionPoint = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        var temp = this.lowerContext.filter;
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        this.updateFlipState();
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
        parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,
            value: { value: this.getCurrFlipState() } });
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        parent.objColl.pop();
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        this.cropImg(true);
        parent.notify('transform', { prop: 'setReverseRotate', onPropertyChange: false, value: { bool: true } });
        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
        parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        parent.transform.currFlipState = tempCurrFlipState;
        parent.notify('transform', { prop: 'setFlipColl', onPropertyChange: false, value: { flipColl: tempFlipColl } });
        this.lowerContext.filter = 'none';
        this.updateFlipState();
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
        parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,
            value: { value: this.getCurrFlipState() } });
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        this.lowerContext.filter = temp;
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            this.cropCircle(this.lowerContext);
        }
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: false } });
        parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
        this.tempFlipPanPoint = { x: 0, y: 0 };
    };
    Crop.prototype.cropObjColl = function () {
        var parent = this.parent;
        var point;
        var shape;
        var obj;
        if (parent.objColl.length > 0) {
            for (var i = 0, len = parent.objColl.length; i < len; i++) {
                obj = parent.objColl[i];
                point = obj.activePoint;
                var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
                shape = obj.shape;
                obj.imageRatio = { startX: ((point.startX - startX) / width),
                    startY: ((point.startY - startY) / height),
                    endX: ((point.endX - startX) / width), endY: ((point.endY - startY) / height),
                    width: width / point.width, height: height / point.height };
                var degree = void 0;
                var size = void 0;
                switch (shape) {
                    case 'text':
                        degree = (obj.shapeDegree === 0) ? parent.transform.degree : parent.transform.degree - obj.shapeDegree;
                        size = (degree === 0 || Math.abs(degree) === 180) ? point.width : point.height;
                        obj.textSettings.fontRatio = size / obj.textSettings.fontSize;
                        break;
                    case 'line':
                    case 'arrow':
                        this.cropPointCollection(i);
                        if (shape === 'arrow') {
                            parent.notify('shape', { prop: 'updateArrowRatio', onPropertyChange: false, value: { obj: obj } });
                        }
                        break;
                    case 'path':
                        this.cropPointCollection(i);
                        break;
                }
            }
        }
    };
    Crop.prototype.cropPointCollection = function (i) {
        var parent = this.parent;
        var shape = parent.objColl[i].shape;
        var x;
        var y;
        var width;
        var height;
        var point = parent.activeObj.activePoint;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (shape === 'path') {
            x = point.startX;
            y = point.startY;
            width = point.width;
            height = point.height;
        }
        else {
            x = destLeft;
            y = destTop;
            width = destWidth;
            height = destHeight;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var pointColl = parent.objColl[i].pointColl;
        for (var n = 0, len = pointColl.length; n < len; n++) {
            pointColl[n].ratioX = (pointColl[n].x - x) / width;
            pointColl[n].ratioY = (pointColl[n].y - y) / height;
        }
    };
    Crop.prototype.cropFreehandDrawColl = function () {
        var parent = this.parent;
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
        for (var n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });
            var len = parent.points.length;
            for (var l = 0; l < len; l++) {
                parent.points[l].ratioX = (parent.points[l].x - startX) / width;
                parent.points[l].ratioY = (parent.points[l].y - startY) / height;
            }
        }
        parent.notify('freehand-draw', { prop: 'updateCropPtsForSel', onPropertyChange: false });
    };
    Crop.prototype.resetAnnotations = function () {
        var parent = this.parent;
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
    };
    Crop.prototype.setCurrSelPoints = function (isSetDimension) {
        var parent = this.parent;
        parent.allowDownScale = false;
        var destPoint = this.cropDestPoints;
        var filter = this.lowerContext.filter;
        var isCropTab = parent.isCropTab;
        parent.img = { srcLeft: 0, srcTop: 0, srcWidth: parent.baseImgCanvas.width, srcHeight: parent.baseImgCanvas.height,
            destLeft: destPoint.startX, destTop: destPoint.startY, destWidth: destPoint.width, destHeight: destPoint.height };
        var img = parent.img;
        var currSelPoint = parent.currSelectionPoint;
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        if (isSetDimension) {
            parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        }
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        if (this.croppedDegree === 0 && parent.transform.degree === 0 && currSelPoint
            && currSelPoint.shape !== 'crop-circle' && currSelPoint.shape !== 'crop-square') {
            img.destLeft = destPoint.startX;
            img.destTop = destPoint.startY;
            img.destWidth = destPoint.width;
            img.destHeight = destPoint.height;
        }
        if (parent.transform.degree === 0) {
            img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
            img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        }
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        this.lowerContext.filter = filter;
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, context: null, isPreventCircleCrop: true } });
        var cropObjColl = extend([], parent.objColl, null, true);
        var cropPointColl = extend([], parent.pointColl, null, true);
        var straightenObj = { straightenPoint: null };
        parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false,
            value: { obj: straightenObj } });
        this.resetAnnotations();
        if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
            parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
        }
        this.panToSelRangle();
        parent.isCropTab = isCropTab;
        parent.objColl = cropObjColl;
        parent.pointColl = cropPointColl;
        parent.freehandCounter = parent.pointColl.length;
        if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {
            parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false,
                value: { x: straightenObj['straightenPoint']['x'], y: straightenObj['straightenPoint']['y'],
                    ratioX: straightenObj['straightenPoint']['ratioX'], ratioY: straightenObj['straightenPoint']['ratioY'] } });
        }
        if (parent.cropObj.activeObj.shape) {
            var destPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
            if (currSelPoint && currSelPoint.activePoint) {
                var _a = currSelPoint.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
                img.destLeft = startX;
                img.destTop = startY;
                img.destWidth = width;
                img.destHeight = height;
            }
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            img.destLeft = destPoints.startX;
            img.destTop = destPoints.startY;
            img.destWidth = destPoints.width;
            img.destHeight = destPoints.height;
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            cropObjColl = extend([], parent.objColl, null, true);
            cropPointColl = extend([], parent.pointColl, null, true);
            parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false, value: { obj: straightenObj } });
            this.resetAnnotations();
            var object = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: object } });
            var cropSelPointColl = object['selPointColl'];
            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false, value: { obj: { selPointColl: [] } } });
            parent.cropObj.filter = this.lowerContext.filter;
            var actObj = extend({}, parent.currSelectionPoint, null, true);
            parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: null } });
            parent.activeObj = extend({}, actObj, null, true);
            var activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.currSelectionPoint = null;
            parent.isCircleCrop = false;
            if (parent.transform.degree !== 0) {
                if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
                    parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
                }
                parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: 0, yDiff: 0 } });
                parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
            }
            parent.objColl = cropObjColl;
            parent.pointColl = cropPointColl;
            parent.freehandCounter = parent.pointColl.length;
            if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {
                parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false,
                    value: { x: straightenObj['straightenPoint']['x'], y: straightenObj['straightenPoint']['y'],
                        ratioX: straightenObj['straightenPoint']['ratioX'], ratioY: straightenObj['straightenPoint']['ratioY'] } });
            }
            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                value: { obj: { selPointColl: cropSelPointColl } } });
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
            this.adjustStraightenForShapes('reverse', false);
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false, value: { isPreventApply: true } });
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            if (parent.transform.degree === 0) {
                parent.notify('transform', { prop: 'drawPannImage', onPropertyChange: false,
                    value: { point: { x: 0, y: 0 } } });
            }
            else {
                if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
                    parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
                }
                parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: 0, yDiff: 0 } });
                parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
            }
            parent.activeObj = activeObj;
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
            parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
                value: { point: null } });
            if (!this.isInitCrop && parent.transform.degree === 0 && parent.cropObj.currFlipState !== '' &&
                parent.cropObj.cropZoom !== 0) {
                this.isInitCrop = true;
                var obj = { activeObj: null };
                parent.notify('draw', { prop: 'getStraightenActObj', onPropertyChange: false, value: { obj: obj } });
                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
                parent.notify('draw', { prop: 'setStraightenActObj', onPropertyChange: false, value: { activeObj: obj['activeObj'] } });
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'croptransform',
                        isApplyBtn: false, isCropping: null, isZooming: null, cType: null } });
            }
            else {
                this.isInitCrop = false;
            }
        }
        else {
            this.adjustStraightenForShapes('reverse', true);
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false, value: { isPreventApply: true } });
            var temp = this.lowerContext.filter;
            this.lowerContext.filter = 'none';
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
            this.lowerContext.filter = temp;
            parent.currSelectionPoint = null;
        }
        if (document.querySelector('.e-ie-straighten-value-span')) {
            document.querySelector('.e-ie-straighten-value-span').innerHTML = parent.transform.straighten.toString() + '&#176';
        }
    };
    Crop.prototype.panToSelRangle = function (isReverse) {
        var parent = this.parent;
        var pannedPoint = parent.cropObj.totalPannedClientPoint;
        var panX = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.x : pannedPoint.x : 0;
        var panY = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.y : pannedPoint.y : 0;
        if (parent.transform.degree !== 0) {
            parent.panPoint.currentPannedPoint = { x: panX, y: panY };
            parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: panX, yDiff: panY } });
            parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
        }
    };
    Crop.prototype.cropCircle = function (context, isSave, isFlip) {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (isFlip && parent.transform.currFlipState !== '') {
            parent.notify('draw', { prop: 'setTransform', onPropertyChange: false,
                value: { context: context, value: parent.transform.currFlipState, isReverse: null } });
        }
        var temp = context.filter;
        context.filter = 'none';
        context.globalCompositeOperation = 'destination-in';
        context.beginPath();
        var centerX = isNullOrUndefined(isSave) ? destLeft + (destWidth / 2) : context.canvas.width / 2;
        var centerY = isNullOrUndefined(isSave) ? destTop + (destHeight / 2) : context.canvas.height / 2;
        var radius = isSave ? context.canvas.width / 2 : destWidth / 2;
        context.arc(centerX, centerY, radius, 0, Math.PI * 2);
        context.closePath();
        context.fill();
        context.restore();
        context.globalCompositeOperation = 'source-over';
        parent.currObjType.isActiveObj = parent.isCircleCrop = true;
        context.filter = temp;
        if (isFlip && parent.transform.currFlipState !== '') {
            parent.notify('draw', { prop: 'setTransform', onPropertyChange: false,
                value: { context: context, value: parent.transform.currFlipState, isReverse: null } });
        }
    };
    Crop.prototype.getCurrCropState = function () {
        var parent = this.parent;
        var flipState = '';
        var obj = { flipColl: null };
        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });
        flipState = this.getCurrFlipState();
        if (parent.transform.degree === -90 || parent.transform.degree === -270) {
            if (flipState === 'horizontal') {
                flipState = 'vertical';
            }
            else if (flipState === 'vertical') {
                flipState = 'horizontal';
            }
        }
        if (flipState === '') {
            flipState = obj['flipColl'].length > 1 ? this.getCurrFlipState() : parent.transform.currFlipState;
        }
        return flipState;
    };
    Crop.prototype.updateRotatePan = function () {
        var parent = this.parent;
        if (isNullOrUndefined(parent.panPoint.currentPannedPoint)) {
            return;
        }
        var panRegion = '';
        var degree = parent.transform.degree;
        var _a = parent.panPoint.currentPannedPoint, x = _a.x, y = _a.y;
        if (parent.rotateFlipColl.length > 0 && typeof (parent.rotateFlipColl[0]) === 'number'
            && degree < 0) {
            panRegion = this.getCurrCropState();
        }
        else {
            panRegion = this.getCurrFlipState();
        }
        if (degree % 90 === 0 && degree % 180 !== 0) {
            if (degree === 90 || (degree === -90 && (panRegion === 'horizontal' || panRegion === 'vertical'))
                || (degree === -270 && (panRegion === '' || panRegion === 'verticalHorizontal'
                    || panRegion === 'horizontalVertical'))) {
                if (panRegion === 'horizontal' || panRegion === '') {
                    parent.img.destLeft += y;
                }
                else {
                    parent.img.destLeft -= y;
                }
                if (panRegion === '' || panRegion === 'vertical') {
                    parent.img.destTop -= x;
                }
                else {
                    parent.img.destTop += x;
                }
            }
            else if (degree === 270 || (degree === -270 && (panRegion === 'horizontal' || panRegion === 'vertical'))
                || (degree === -90 && (panRegion === '' || panRegion === 'verticalHorizontal'
                    || panRegion === 'horizontalVertical'))) {
                if (panRegion === '' || panRegion === 'horizontal') {
                    parent.img.destLeft -= y;
                }
                else {
                    parent.img.destLeft += y;
                }
                if (panRegion === '' || panRegion === 'vertical') {
                    parent.img.destTop += x;
                }
                else {
                    parent.img.destTop -= x;
                }
            }
        }
        else {
            if (degree === 180 || degree === -180) {
                if (panRegion === '' || panRegion === 'vertical') {
                    parent.img.destLeft -= x;
                }
                else {
                    parent.img.destLeft += x;
                }
                if (panRegion === '' || panRegion === 'horizontal') {
                    parent.img.destTop -= y;
                }
                else {
                    parent.img.destTop += y;
                }
            }
        }
    };
    Crop.prototype.crop = function (obj) {
        var parent = this.parent;
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        if (!parent.disabled && parent.isImageLoaded) {
            var object = { isCropToolbar: parent.isCropToolbar };
            if (parent.currObjType.isUndoAction && !object['isCropToolbar']) {
                parent.notify('undo-redo', { prop: 'refreshUrc', value: { bool: null } });
            }
            var transitionArgs = { cancel: false, startPoint: { x: startX, y: startY },
                endPoint: { x: endX, y: endY }, preventScaling: false };
            if (!object['isCropToolbar']) {
                parent.trigger('cropping', transitionArgs);
                parent.editCompleteArgs = transitionArgs;
            }
            this.cropEvent(transitionArgs, obj, object);
        }
    };
    Crop.prototype.cropEvent = function (transitionArgs, obj, object) {
        var parent = this.parent;
        var splitWords;
        if (!transitionArgs.cancel) {
            splitWords = parent.activeObj.shape ? parent.activeObj.shape.split('-') : [];
            if (!parent.disabled && parent.activeObj.horTopLine && (parent.currObjType.isCustomCrop || (splitWords.length > 0 &&
                splitWords[0] === 'crop'))) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                obj.isCrop = true;
                var prevCropObj = extend({}, parent.cropObj, {}, true);
                var prevObj = extend({}, this.prevCropCurrObj, {}, true);
                if (transitionArgs.preventScaling) {
                    this.isPreventScaling = true;
                }
                else {
                    this.isPreventScaling = false;
                }
                this.cropImg();
                if (this.isPreventScaling) {
                    parent.aspectWidth = parent.img.destWidth;
                    parent.aspectHeight = parent.img.destHeight;
                }
                parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
                parent.isCropTab = false;
                parent.transform.zoomFactor = 0;
                parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
                parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
                    value: { previousZoomValue: parent.zoomSettings.zoomFactor } });
                if (!Browser.isDevice) {
                    this.updateUndoRedoColl(prevObj, prevCropObj, object);
                }
                parent.notify('transform', { prop: 'setCropDimension', onPropertyChange: false,
                    value: { width: parent.cropObj.destPoints.width, height: parent.cropObj.destPoints.height } });
                var aspectIcon = parent.element.querySelector('#' + parent.element.id + '_aspectratio');
                var nonAspectIcon = parent.element.querySelector('#' + parent.element.id + '_nonaspectratio');
                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
                if (!object['isCropToolbar'] && (isNullOrUndefined(aspectIcon) && isNullOrUndefined(nonAspectIcon))) {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                            isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });
                }
                this.resizeWrapper();
                if (Browser.isDevice) {
                    this.updateUndoRedoColl(prevObj, prevCropObj, object);
                }
            }
        }
    };
    Crop.prototype.updateUndoRedoColl = function (prevObj, prevCropObj, object) {
        var parent = this.parent;
        var currSelPtObj = { prevCurrSelectionPoint: parent.prevCurrSelectionPoint };
        prevObj.currSelectionPoint = extend({}, currSelPtObj['prevCurrSelectionPoint'], {}, true);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'crop', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: parent.isCircleCrop } });
        if (!object['isCropToolbar']) {
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
    };
    Crop.prototype.resizeWrapper = function () {
        var parent = this.parent;
        if (Browser.isDevice) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var elem = parent.element;
            var ctxToolbar = elem.querySelector('#' + elem.id + '_contextualToolbarArea');
            if (ctxToolbar && ctxToolbar.style.position === '' && !this.isTransformCrop) {
                ctxToolbar.style.position = 'absolute';
                parent.isStraightening = false;
                parent.update();
                parent.notify('filter', { prop: 'setAdjustmentValue', value: { adjustmentValue: parent.canvasFilter } });
            }
        }
    };
    Crop.prototype.calcRatio = function (obj, dimension) {
        var parent = this.parent;
        var degree = parent.transform.degree;
        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var _b = dimension || parent.baseImgCanvas, width = _b.width, height = _b.height;
        var widthRatio = (degree === 0 || degree % 180 === 0) ? width / destWidth : height / destWidth;
        var heightRatio = (degree === 0 || degree % 180 === 0) ? height / destHeight : width / destHeight;
        if (obj) {
            obj['width'] = widthRatio;
            obj['height'] = heightRatio;
        }
        return { width: widthRatio, height: heightRatio };
    };
    Crop.prototype.getCurrFlipState = function (panObj) {
        var parent = this.parent;
        var obj = { panRegion: '' };
        var object = { collection: parent.rotateFlipColl };
        parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
            value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: object } });
        parent.rotateFlipColl = object['collection'];
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
            parent.notify('transform', { prop: 'setCurrPanRegion', onPropertyChange: false,
                value: { region: obj['panRegion'], type: parent.rotateFlipColl[i], obj: obj } });
        }
        if (panObj) {
            panObj['panRegion'] = obj['panRegion'];
        }
        return obj['panRegion'];
    };
    return Crop;
}());

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Draw = /** @class */ (function () {
    function Draw(parent) {
        this.isInitialLoading = false; // Specifies whether image is loaded for the first time or not (for applying initial filter)
        this.fileName = '';
        this.isErrorImage = false;
        this.isShapeTextInserted = false;
        this.isRotateZoom = false; // To restore zoomed image on selection crop selection
        this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, outlineColor: '', radius: null, outlineWidth: null }; // restore stroke settings on cancel
        this.tempTextSettings = { text: 'Enter Text', fontFamily: '', fontSize: null, fontRatio: null, bold: false, italic: false, underline: false }; // restore text settings on cancel
        this.tempAdjValue = ''; // for temp internal slider value
        this.tempFilter = ''; // restore filter style on cancel
        this.tempUndoRedoStep = 0;
        this.tempFreehandCounter = 0;
        this.tempCurrFhdIndex = 0;
        this.tempZoomFactor = null; // Restore zoom factor on cancel
        this.isCancelAction = false;
        this.rotatedFlipCropSel = false;
        this.zoomCrop = { width: 0, height: 0 };
        this.isImageEdited = false;
        this.isFileChanged = false;
        this.isNewPath = false;
        this.isResizeSelect = false;
        this.arrowDimension = { bar: { width: 10, height: 32, ratioX: null, ratioY: null },
            arrow: { width: 24, height: 24, ratioX: null, ratioY: null }, arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
            circle: { width: 10, height: 10, ratioX: null, ratioY: null }, square: { width: 20, height: 20, ratioX: null, ratioY: null } };
        this.origDim = { width: 0, height: 0 };
        this.isImageApply = false;
        this.imgCanvasPoints = [];
        this.isCropSelect = false;
        this.isDownScale = false;
        this.preventStraightening = false;
        this.tempObjColl = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.tempPointColl = {};
        this.imageBackgroundColor = '';
        this.allowRedactStraighten = true;
        this.isNullExtension = true;
        this.parent = parent;
        this.addEventListener();
    }
    Draw.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    Draw.prototype.addEventListener = function () {
        this.parent.on('draw', this.draw, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    Draw.prototype.removeEventListener = function () {
        this.parent.off('draw', this.draw);
        this.parent.off('destroyed', this.destroy);
    };
    Draw.prototype.draw = function (args) {
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'drawObject':
                this.drawObject(args.value['canvas'], args.value['obj'], args.value['isCropRatio'], args.value['points'], args.value['isPreventDrag'], args.value['saveContext'], args.value['isPreventSelection']);
                break;
            case 'updateActiveObject':
                this.updateActiveObject(args.value['actPoint'], args.value['obj'], args.value['isMouseMove'], args.value['x'], args.value['y']);
                break;
            case 'clearOuterCanvas':
                this.clearOuterCanvas(args.value['context']);
                break;
            case 'setDestPoints':
                this.setDestPoints();
                break;
            case 'updateCurrTransState':
                this.updateCurrTransState(args.value['type'], args.value['isPreventDestination'], args.value['isRotatePan']);
                break;
            case 'currTransState':
                this.currTransState(args.value['type'], args.value['isPreventDestination'], args.value['context'], args.value['isPreventCircleCrop']);
                break;
            case 'setTransform':
                this.setTransform(args.value['context'], args.value['value'], args.value['isReverse']);
                break;
            case 'render-image':
                this.renderImage(args.value['isMouseWheel'], args.value['isPreventClearRect'], args.value['isFrame'], args.value['isStraighten']);
                break;
            case 'draw-image-to-canvas':
                this.drawImgToCanvas(args.value['dimension']);
                break;
            case 'update-canvas':
                this.updateCanvas();
                break;
            case 'performCancel':
                this.performCancel(args.value['isContextualToolbar'], args.value['isUndoRedo'], args.value['isFinalCancel']);
                break;
            case 'updateFlipPan':
                this.updateFlipPan(args.value['tempSelectionObj']);
                break;
            case 'select':
                this.select(args.value['type'], args.value['startX'], args.value['startY'], args.value['width'], args.value['height']);
                break;
            case 'callUpdateCurrTransState':
                this.callUpdateCurrTransState();
                break;
            case 'resetPanPoints':
                this.resetPanPoints();
                break;
            case 'setClientTransDim':
                this.setClientTransDim(args.value['isPreventDimension']);
                break;
            case 'redrawImgWithObj':
                this.redrawImgWithObj();
                break;
            case 'setCurrentObj':
                this.setCurrentObj(args.value['obj'], args.value['isUndoRedo'], args.value['isCircleCrop']);
                break;
            case 'performPointZoom':
                this.performPointZoom(args.value['x'], args.value['y'], args.value['type'], args.value['isResize']);
                break;
            case 'open':
                this.open(args.value['data']);
                break;
            case 'isInitialLoading':
                this.isInitialLoading = args.value['isInitialLoading'];
                break;
            case 'isInitialLoaded':
                this.getInitialLoaded(args.value['object']);
                break;
            case 'fileSelect':
                this.fileSelect(args.value['inputElement'], args.value['args']);
                break;
            case 'getFileName':
                args.value['obj']['fileName'] = this.fileName;
                args.value['obj']['fileType'] = this.fileType;
                break;
            case 'getErrorImage':
                args.value['obj']['isErrorImage'] = this.isErrorImage;
                break;
            case 'getInitialZoomValue':
                args.value['obj']['initialZoomValue'] = this.initZoomValue;
                break;
            case 'setShapeTextInsert':
                this.isShapeTextInserted = args.value['bool'];
                break;
            case 'resetCurrentSelectionPoint':
                this.currSelPoint = null;
                break;
            case 'setRotateZoom':
                this.isRotateZoom = args.value['isRotateZoom'];
                break;
            case 'setTempStrokeSettings':
                this.tempStrokeSettings = args.value['tempStrokeSettings'];
                break;
            case 'setTempTextSettings':
                this.tempTextSettings = args.value['tempTextSettings'];
                break;
            case 'setTempAdjustmentValue':
                this.tempAdjValue = args.value['tempAdjustmentValue'];
                break;
            case 'getTempAdjustmentValue':
                args.value['obj']['value'] = this.tempAdjValue;
                break;
            case 'setTempFilter':
                this.tempFilter = args.value['tempFilter'];
                break;
            case 'setTempUndoRedoStep':
                this.tempUndoRedoStep = args.value['tempUndoRedoStep'];
                break;
            case 'setTempFreehandCounter':
                this.tempFreehandCounter = args.value['tempFreehandCounter'];
                break;
            case 'setTempCurrentFreehandDrawIndex':
                this.tempCurrFhdIndex = args.value['tempCurrentFreehandDrawIndex'];
                break;
            case 'setTempZoomFactor':
                this.tempZoomFactor = args.value['tempZoomFactor'];
                break;
            case 'setCancelAction':
                this.isCancelAction = args.value['bool'];
                break;
            case 'getRotatedFlipCropSelection':
                args.value['bool']['isSelected'] = this.rotatedFlipCropSel;
                break;
            case 'getPrevActObj':
                args.value['obj']['prevActObj'] = this.prevActObj;
                break;
            case 'setPrevActObj':
                this.prevActObj = args.value['prevActObj'];
                break;
            case 'setZoomCropWidth':
                this.zoomCrop.width = args.value['width'];
                this.zoomCrop.height = args.value['height'];
                break;
            case 'setImageEdited':
                this.isImageEdited = true;
                break;
            case 'reset':
                this.reset();
                break;
            case 'setNewPath':
                this.isNewPath = args.value['bool'];
                break;
            case 'getNewPath':
                args.value['obj']['isNewPath'] = this.isNewPath;
                break;
            case 'getArrowDimension':
                args.value['obj']['arrowDimension'] = extend({}, this.arrowDimension, {}, true);
                break;
            case 'setArrowDimension':
                this.arrowDimension = args.value['arrowDimension'];
                break;
            case 'moveToSelectionRange':
                this.moveToSelectionRange(args.value['type'], args.value['activeObj']);
                break;
            case 'setResizeSelect':
                this.isResizeSelect = args.value['bool'];
                break;
            case 'applyFrame':
                this.applyFrame(args.value['ctx'], args.value['frame'], args.value['preventImg']);
                break;
            case 'drawImage':
                this.drawImage();
                break;
            case 'downScaleImgCanvas':
                this.downScaleImgCanvas(args.value['ctx'], args.value['isImgAnnotation'], args.value['isHFlip'], args.value['isVFlip']);
                break;
            case 'downScale':
                this.downScale(args.value['canvas'], args.value['width'], args.value['height']);
                break;
            case 'resetFrameZoom':
                this.resetFrameZoom(args.value['isOk']);
                break;
            case 'triggerFrameChange':
                args.value['obj']['frameChangeEventArgs'] = this.triggerFrameChange(args.value['prevFrameSettings']);
                break;
            case 'setImageApply':
                this.isImageApply = args.value['bool'];
                break;
            case 'zoomToSel':
                this.zoomToSel(args.value['activeObj'], args.value['isToolbar']);
                break;
            case 'getStraightenActObj':
                args.value['obj']['activeObj'] = this.straightenActObj;
                break;
            case 'setStraightenActObj':
                this.straightenActObj = args.value['activeObj'];
                break;
            case 'updateImgCanvasPoints':
                this.updateImgCanvasPoints();
                break;
            case 'isLinesIntersect':
                args.value['obj']['isIntersect'] = this.isLinesIntersect(args.value['obj']);
                break;
            case 'getImageCanvasPoints':
                args.value['obj']['points'] = this.imgCanvasPoints;
                break;
            case 'setDestForStraighten':
                this.setDestForStraighten();
                break;
            case 'setTempDestForStraighten':
                this.tempStraightenDestPoints = extend({}, this.straightenDestPoints, {}, true);
                break;
            case 'getStraightenInitZoom':
                args.value['obj']['zoomFactor'] = this.straightenInitZoom;
                break;
            case 'setStraightenInitZoom':
                this.straightenInitZoom = args.value['zoomFactor'];
                break;
            case 'isPointsInsideImg':
                args.value['obj']['bool'] = this.checkPointPosition(args.value['x'], args.value['y'], this.imgCanvasPoints[0].x, this.imgCanvasPoints[0].y, this.imgCanvasPoints[1].x, this.imgCanvasPoints[1].y, this.imgCanvasPoints[2].x, this.imgCanvasPoints[2].y, this.imgCanvasPoints[3].x, this.imgCanvasPoints[3].y) !== 'inside';
                break;
            case 'setIsCropSelect':
                this.isCropSelect = args.value['bool'];
                break;
            case 'updateCropSelection':
                this.updateCropSelection();
                break;
            case 'updateCropSelObj':
                this.updateCropSelObj();
                break;
            case 'redrawDownScale':
                this.redrawDownScale();
                break;
            case 'updateFinetune':
                this.updateFinetune();
                break;
            case 'isSelOutsideImg':
                args.value['obj']['bool'] = this.isSelOutsideImg();
                break;
            case 'resetStraightenDestPoints':
                this.straightenDestPoints = null;
                break;
            case 'checkPointPosition':
                args.value['obj']['position'] = this.checkPointPosition(args.value['obj']['x'], args.value['obj']['y'], args.value['obj']['x1'], args.value['obj']['y1'], args.value['obj']['x2'], args.value['obj']['y2'], args.value['obj']['x3'], args.value['obj']['y3'], args.value['obj']['x4'], args.value['obj']['y4']);
                break;
            case 'updateTempObjColl':
                this.tempObjColl = extend([], this.parent.objColl, [], true);
                break;
            case 'resetTempObjColl':
                this.tempObjColl = null;
                break;
            case 'updateTempPointColl':
                this.tempPointColl = extend({}, this.parent.pointColl, {}, true);
                break;
            case 'resetTempPointColl':
                this.tempPointColl = {};
                break;
            case 'showDialogPopup':
                this.showDialogPopup();
                break;
            case 'imageBackgroundColor':
                this.imageBackgroundColor = args.value['color'];
                break;
            case 'getImageBackgroundColor':
                args.value['obj']['color'] = this.imageBackgroundColor;
                break;
            case 'setTempStrokeWidth':
                this.tempStrokeWidth = args.value['strokeWidth'];
                break;
            case 'setNullExtension':
                this.isNullExtension = args.value['extension'];
                break;
        }
    };
    Draw.prototype.getModuleName = function () {
        return 'draw';
    };
    Draw.prototype.updatePrivateVariables = function () {
        var parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
        if (isNullOrUndefined(this.tempZoomFactor)) {
            this.tempZoomFactor = parent.transform.zoomFactor;
        }
        if (this.tempTextSettings.fontFamily === '') {
            this.tempTextSettings.fontFamily = parent.fontFamily.default;
        }
    };
    Draw.prototype.reset = function () {
        this.isInitialLoading = this.isErrorImage = this.isNewPath = this.isResizeSelect = false;
        this.isShapeTextInserted = false;
        this.isImageApply = false;
        this.isNullExtension = true;
        this.initZoomValue = null;
        this.tempFilter = '';
        this.origDim = { width: 0, height: 0 };
        this.currSelPoint = null;
        this.isRotateZoom = false;
        this.tempAdjValue = '';
        this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, radius: null, outlineColor: '', outlineWidth: null };
        this.tempTextSettings =
            { text: 'Enter Text', fontFamily: this.parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
        this.tempUndoRedoStep = this.tempFreehandCounter = this.tempCurrFhdIndex = 0;
        this.tempZoomFactor = null;
        this.isCancelAction = false;
        this.rotatedFlipCropSel = false;
        this.prevActObj = null;
        this.tempStraightenDestPoints = null;
        this.arrowDimension = { bar: { width: 10, height: 32, ratioX: null, ratioY: null },
            arrow: { width: 24, height: 24, ratioX: null, ratioY: null }, arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
            circle: { width: 10, height: 10, ratioX: null, ratioY: null }, square: { width: 20, height: 20, ratioX: null, ratioY: null } };
        this.straightenActObj = null;
        this.imgCanvasPoints = [];
        this.straightenInitZoom = null;
        this.allowRedactStraighten = true;
        this.tempObjColl = [];
        this.tempPointColl = {};
        this.imageBackgroundColor = '';
        this.tempStrokeWidth = null;
        this.straightenDestPoints = null;
        this.isCropSelect = this.isDownScale = this.preventStraightening = false;
    };
    Draw.prototype.redrawDownScale = function () {
        var parent = this.parent;
        if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
            var activeObj = extend({}, parent.activeObj, {}, true);
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.isDownScale = true;
            this.renderImage();
            this.isDownScale = false;
            if (activeObj.shape) {
                this.drawObject('duplicate', activeObj);
            }
        }
    };
    Draw.prototype.updateFinetune = function () {
        var parent = this.parent;
        if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
            var filter = this.lowerContext.filter;
            this.lowerContext.filter = 'none';
            parent.notify('draw', { prop: 'redrawDownScale' });
            var inMemoryContext = parent.inMemoryCanvas.getContext('2d');
            var ctx = this.lowerContext;
            var imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
            parent.inMemoryCanvas.width = imageData.width;
            parent.inMemoryCanvas.height = imageData.height;
            inMemoryContext.putImageData(imageData, 0, 0);
            this.lowerContext.filter = filter;
            parent.notify('draw', { prop: 'redrawDownScale' });
        }
    };
    Draw.prototype.drawImage = function () {
        this.applyFrame(this.lowerContext, this.parent.frameObj.type);
    };
    Draw.prototype.drawObject = function (canvas, obj, isCropRatio, points, isPreventDrag, saveContext, isPreventSelection) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var actPoint = parent.activeObj.activePoint;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        var canvasDraw;
        canvas = canvas.toLowerCase();
        if (canvas === 'original') {
            canvasDraw = this.lowerContext;
        }
        else if (canvas === 'duplicate') {
            canvasDraw = this.upperContext;
        }
        else if (saveContext) {
            canvasDraw = saveContext;
        }
        if (!isPreventDrag && actObj.shape) {
            this.setDragLimit();
        }
        if (parent.currObjType.shape) {
            var splitWords = parent.currObjType.shape.split('-');
            if (splitWords[0].toLowerCase() === 'crop' && isCropRatio) {
                this.drawCropRatio();
            }
        }
        actObj = parent.activeObj;
        actPoint = parent.activeObj.activePoint;
        if (isNullOrUndefined(actObj.strokeSettings)) {
            var obj_1 = { strokeSettings: {} };
            parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false, value: { obj: obj_1 } });
            actObj.strokeSettings = obj_1['strokeSettings'];
        }
        if (isNullOrUndefined(actObj.strokeSettings.strokeWidth)) {
            actObj.strokeSettings.strokeWidth = 2;
        }
        if (obj) {
            parent.activeObj = extend({}, obj, {}, true);
        }
        if (points && points.startX && points.startY && points.endX && points.endY && points.width && points.height) {
            actPoint.startX = points.startX;
            actPoint.startY = points.startY;
            actPoint.endX = points.endX;
            actPoint.endY = points.endY;
            actPoint.width = points.width;
            actPoint.height = points.height;
        }
        this.updateActiveObject();
        actObj = parent.activeObj;
        actPoint = parent.activeObj.activePoint;
        if (isNullOrUndefined(actPoint.startX) && isNullOrUndefined(actPoint.startY)) {
            return;
        }
        if (parent.currObjType.isText) {
            var obj_2 = { keyHistory: '' };
            parent.notify('shape', { prop: 'getKeyHistory', onPropertyChange: false, value: { obj: obj_2 } });
            actObj.keyHistory = obj_2['keyHistory'];
        }
        var isCrop = false;
        if (canvas !== 'original') {
            var splitWords = void 0;
            if (actObj.shape) {
                splitWords = actObj.shape.split('-');
                if (splitWords[0] === 'crop') {
                    isCrop = true;
                }
            }
            if (isCrop) {
                if (points && points.startX && points.startY && points.endX && points.endY && points.width && points.height) {
                    actPoint.startX = points.startX;
                    actPoint.startY = points.startY;
                    actPoint.endX = points.endX;
                    actPoint.endY = points.endY;
                    actPoint.width = points.width;
                    actPoint.height = points.height;
                }
                else {
                    actPoint = actObj.activePoint;
                }
                this.upperContext.fillStyle = 'rgb(0, 0, 0, 0.25)';
                this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
            }
            if (isNullOrUndefined(isPreventSelection) && (canvasDraw === this.lowerContext || canvasDraw === this.upperContext)) {
                this.rotateContext('initial', canvasDraw);
                this.drawOuterSelection(canvasDraw);
                this.rotateContext('reverse', canvasDraw);
            }
        }
        parent.currObjType.isActiveObj = true;
        var object = { keyHistory: '' };
        parent.notify('shape', { prop: 'getKeyHistory', onPropertyChange: false, value: { obj: object } });
        if (obj) {
            this.drawShapeObj(canvas, obj.shape, saveContext, isPreventSelection);
        }
        else if (object['keyHistory'] !== '' && parent.currObjType.isText) {
            this.drawShapeObj(canvas, 'text', saveContext, isPreventSelection);
        }
        else if (actObj.shape) {
            this.drawShapeObj(canvas, actObj.shape, saveContext, isPreventSelection);
        }
        else {
            this.drawShapeObj(canvas, undefined, saveContext, isPreventSelection);
        }
        if (canvas === 'duplicate' && isCrop && actObj.shape !== 'crop-circle' && parent.frameObj.type !== 'none') {
            this.applyFrame(this.upperContext, parent.frameObj.type);
            this.drawCornerCircles(this.upperContext);
        }
    };
    Draw.prototype.rotateContext = function (type, ctx) {
        var parent = this.parent;
        var _a = parent.activeObj, shape = _a.shape, rotatedAngle = _a.rotatedAngle;
        var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
        var _c = parent.activeObj.activePoint, startX = _c.startX, startY = _c.startY, width = _c.width, height = _c.height;
        if (shape === 'line' || shape === 'arrow') {
            return;
        }
        var rotationAngle = (type === 'initial') ? rotatedAngle : -rotatedAngle;
        var translateX;
        var translateY;
        if (parent.transform.straighten === 0 && !parent.isCropTab) {
            translateX = startX + (width / 2);
            translateY = startY + (height / 2);
        }
        else {
            translateX = destLeft + (destWidth / 2);
            translateY = destTop + (destHeight / 2);
        }
        ctx.translate(translateX, translateY);
        ctx.rotate(rotationAngle);
        ctx.translate(-translateX, -translateY);
    };
    Draw.prototype.setDragLimit = function () {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var _a = parent.activeObj, shape = _a.shape, rotatedAngle = _a.rotatedAngle;
        if (actPoint && shape !== 'image' && shape !== 'line' && rotatedAngle === 0 && parent.activeObj.preventShapeDragOut) {
            var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
            if (actPoint.startX < destLeft) {
                actPoint.startX = destLeft;
                actPoint.endX = Math.min(actPoint.startX + actPoint.width, destLeft + destWidth);
            }
            else if (actPoint.endX > destLeft + destWidth) {
                actPoint.endX = destLeft + destWidth;
                actPoint.startX = Math.max(actPoint.endX - actPoint.width, destLeft);
            }
            if (actPoint.startY < destTop) {
                actPoint.startY = destTop;
            }
            else if (actPoint.endY > destTop + destHeight) {
                actPoint.endY = destTop + destHeight;
                actPoint.startY = Math.max(actPoint.endY - actPoint.height, destTop);
            }
            parent.activeObj = this.updateWidthHeight(parent.activeObj);
        }
    };
    Draw.prototype.drawCropRatio = function () {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var x;
        var y;
        var width;
        var height;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (parent.transform.zoomFactor > 0 && this.currSelPoint) {
            var activeObj = extend({}, parent.activeObj, {}, true);
            this.drawCustomSelection('crop-custom', null, null, null, null);
            if (parent.transform.straighten !== 0) {
                actPoint = parent.activeObj.activePoint;
            }
            if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
                width = actPoint.width < actPoint.height ? actPoint.width : actPoint.height;
                height = width;
            }
            else {
                width = actPoint.width;
                height = actPoint.height;
            }
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.activeObj = activeObj;
            parent.currObjType.shape = activeObj.shape;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.currObjType.isCustomCrop = false;
        }
        else {
            width = destWidth;
            height = destHeight;
            if (destLeft < 0) {
                width += destLeft;
            }
            if (destTop < 0) {
                height += destTop;
            }
            if (destLeft + destWidth > parent.lowerCanvas.width) {
                width -= (destLeft + destWidth - parent.lowerCanvas.width);
            }
            if (destTop + destHeight > parent.lowerCanvas.height) {
                height -= (destTop + destHeight - parent.lowerCanvas.height);
            }
        }
        switch (parent.currObjType.shape.toLowerCase()) {
            case 'crop-square':
            case 'crop-circle':
                parent.notify('selection', { prop: 'setDragDirection', onPropertyChange: false, value: { width: width, height: height } });
                actPoint = parent.activeObj.activePoint;
                if (parent.lowerCanvas.width < (actPoint.endX - actPoint.startX)) {
                    actPoint.startX = 7.5;
                    actPoint.endX = parent.lowerCanvas.width - 7.5;
                }
                if (parent.lowerCanvas.height < (actPoint.endY - actPoint.startY)) {
                    actPoint.startY = 7.5;
                    actPoint.endY = parent.lowerCanvas.height - 7.5;
                }
                if (width === destWidth && height === destHeight) {
                    actPoint.startX += destLeft;
                    actPoint.startY += destTop;
                    actPoint.endX += destLeft;
                    actPoint.endY += destTop;
                }
                if (parent.lowerCanvas.width > parent.lowerCanvas.height) {
                    actPoint.height = actPoint.endY - actPoint.startY;
                    actPoint.width = actPoint.height;
                    actPoint.endX = actPoint.startX + actPoint.width;
                }
                else {
                    actPoint.width = actPoint.endX - actPoint.startX;
                    actPoint.height = actPoint.width;
                    actPoint.endY = actPoint.startY + actPoint.height;
                }
                break;
            case 'crop-3:2':
                x = 3;
                y = 2;
                break;
            case 'crop-4:3':
                x = 4;
                y = 3;
                break;
            case 'crop-5:4':
                x = 5;
                y = 4;
                break;
            case 'crop-7:5':
                x = 7;
                y = 5;
                break;
            case 'crop-16:9':
                x = 16;
                y = 9;
                break;
            case 'crop-2:3':
                x = 2;
                y = 3;
                break;
            case 'crop-3:4':
                x = 3;
                y = 4;
                break;
            case 'crop-4:5':
                x = 4;
                y = 5;
                break;
            case 'crop-5:7':
                x = 5;
                y = 7;
                break;
            case 'crop-9:16':
                x = 9;
                y = 16;
                break;
            default:
                x = parseInt(parent.currObjType.shape.toLowerCase().split('crop-')[1].split(':')[0]);
                y = parseInt(parent.currObjType.shape.toLowerCase().split('crop-')[1].split(':')[1]);
                break;
        }
        if (x !== undefined && y !== undefined) {
            parent.notify('selection', { prop: 'calcShapeRatio', onPropertyChange: false,
                value: { x: x, y: y, imgWidth: width, imgHeight: height } });
            if (width === destWidth && height === destHeight) {
                this.updatePoints();
            }
            actPoint = parent.activeObj.activePoint;
        }
        if (actPoint.startX < destLeft) {
            var diff = (destLeft - actPoint.startX) + 7.5;
            actPoint.startX += diff;
            actPoint.endX += diff;
        }
        if (actPoint.startY < destTop) {
            var diff = (destTop - actPoint.startY) + 7.5;
            actPoint.startY += diff;
            actPoint.endY += diff;
        }
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
        this.adjToCenter();
        this.enlargeToImg();
        if (parent.transform.straighten !== 0) {
            this.adjToStraighten();
            this.updateActiveObject(parent.activeObj.activePoint, parent.activeObj);
        }
        var object = { isIntersect: null, arr: null };
        var count = 0;
        actPoint = parent.activeObj.activePoint;
        if (parent.transform.straighten !== 0) {
            while (this.isLinesIntersect(object) && count < 100) {
                count++;
                var diff = (actPoint.width * 1) / 100;
                actPoint.startX += diff;
                actPoint.endX -= diff;
                diff = (actPoint.height * 1) / 100;
                actPoint.startY += diff;
                actPoint.endY -= diff;
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.updateActiveObject(actPoint, parent.activeObj);
            }
        }
        this.straightenInitZoom = parent.transform.zoomFactor;
        this.straightenActObj = extend({}, parent.activeObj, {}, true);
        parent.notify('draw', { prop: 'resetStraightenDestPoints' });
        parent.notify('draw', { prop: 'setDestForStraighten' });
    };
    Draw.prototype.adjToCenter = function () {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var diffX = ((parent.lowerCanvas.width) / 2) - (actPoint.endX - actPoint.width / 2);
        var diffY = ((parent.lowerCanvas.height) / 2) - (actPoint.endY - actPoint.height / 2);
        actPoint.startX += diffX;
        actPoint.endX += diffX;
        actPoint.startY += diffY;
        actPoint.endY += diffY;
        if (actPoint.startX < (destLeft >= 7.5 ? destLeft : 7.5)) {
            var diff = ((destLeft >= 7.5 ? destLeft : 0) - actPoint.startX);
            actPoint.startX += diff;
            actPoint.endX += diff;
        }
        else if (actPoint.endX > destLeft + destWidth) {
            var diff = (actPoint.endX - (destLeft + destWidth));
            actPoint.startX -= diff;
            actPoint.endX -= diff;
        }
        if (actPoint.startY < (destTop >= 7.5 ? destTop : 7.5)) {
            var diff = ((destTop >= 7.5 ? destTop : 0) - actPoint.startY);
            actPoint.startY += diff;
            actPoint.endY += diff;
        }
        else if (actPoint.endY > destTop + destHeight) {
            var diff = (actPoint.endY - (destTop + destHeight));
            actPoint.startY -= diff;
            actPoint.endY -= diff;
        }
    };
    Draw.prototype.enlargeToImg = function () {
        var parent = this.parent;
        if (parent.transform.straighten === 0) {
            return;
        }
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            var actPoint = parent.activeObj.activePoint;
            var tempActPoint = extend({}, actPoint, {}, true);
            var count = 0;
            while (true) {
                // Increase width and height by 5% from center to enlarge the crop selection
                count++;
                var diff = (actPoint.width * 5) / 100;
                actPoint.startX -= diff;
                actPoint.endX += diff;
                diff = (actPoint.height * 5) / 100;
                actPoint.startY -= diff;
                actPoint.endY += diff;
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.updateActiveObject(actPoint, parent.activeObj);
                var object = { isIntersect: null, arr: null };
                this.updateImgCanvasPoints();
                this.isLinesIntersect(object);
                if (object['arr'][0] || object['arr'][1] || object['arr'][2] || object['arr'][3] ||
                    actPoint.startX < 7.5 || actPoint.startY < 7.5 || count === 100) {
                    actPoint = extend({}, tempActPoint, {}, true);
                    diff = (actPoint.width * 1) / 100;
                    actPoint.startX += diff;
                    actPoint.endX -= diff;
                    diff = (actPoint.height * 1) / 100;
                    actPoint.startY += diff;
                    actPoint.endY -= diff;
                    actPoint.width = actPoint.endX - actPoint.startX;
                    actPoint.height = actPoint.endY - actPoint.startY;
                    this.updateActiveObject(actPoint, parent.activeObj);
                    break;
                }
                tempActPoint = extend({}, actPoint, {}, true);
            }
        }
    };
    Draw.prototype.updateActiveObject = function (actPoint, obj, isMouseMove, x, y) {
        var parent = this.parent;
        actPoint = actPoint ? actPoint : extend({}, parent.activeObj.activePoint, {}, true);
        obj = obj ? obj : extend({}, parent.activeObj, {}, true);
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        var startX = actPoint.startX, startY = actPoint.startY, endX = actPoint.endX, endY = actPoint.endY, width = actPoint.width, height = actPoint.height;
        x = x ? x : 0;
        y = y ? y : 0;
        var horCircleWidth = width / 2;
        var verCircleHeight = height / 2;
        var radius = 7.5;
        obj.horTopLine = { startX: startX + x, startY: startY - y,
            endX: endX + x, endY: endY + y };
        obj.horBottomLine = { startX: startX - x, startY: endY - y,
            endX: endX - x, endY: endY + y };
        obj.verLeftLine = { startX: startX + x, startY: startY - y,
            endX: startX - y, endY: endY - y };
        obj.verRightLine = { startX: endX + x, startY: startY + y,
            endX: endX - x, endY: endY + y };
        obj.topLeftCircle = { startX: startX, startY: startY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.topCenterCircle = { startX: startX + horCircleWidth, startY: startY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.topRightCircle = { startX: endX, startY: startY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.centerLeftCircle = { startX: startX, startY: startY + verCircleHeight,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.centerRightCircle = { startX: endX, startY: startY + verCircleHeight,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.bottomLeftCircle = { startX: startX, startY: endY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.bottomCenterCircle = { startX: startX + horCircleWidth, startY: endY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.bottomRightCircle = { startX: endX, startY: endY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        if (obj.rotatedAngle === 0) {
            obj.rotationCirclePoint = { x: obj.bottomCenterCircle.startX,
                y: obj.bottomCenterCircle.startY + 25 };
            obj.rotationCirclePoint.ratioX = (obj.rotationCirclePoint.x - parent.img.destLeft) / parent.img.destWidth;
            obj.rotationCirclePoint.ratioY = (obj.rotationCirclePoint.y - parent.img.destTop) / parent.img.destHeight;
        }
        obj.activePoint = actPoint;
        if (isNullOrUndefined(isMouseMove)) {
            parent.activeObj = extend({}, obj, {}, true);
        }
    };
    Draw.prototype.drawOuterSelection = function (canvasDraw, isCropCircle) {
        var splitWords;
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var actObj = parent.activeObj;
        canvasDraw.lineWidth = (0.5);
        var tempObj = extend({}, actObj, {}, true);
        if (actObj.shape) {
            splitWords = actObj.shape.split('-');
        }
        if (((splitWords && splitWords[0] === 'crop') || actObj.shape === undefined) && !isCropCircle) {
            this.upperContext.fillStyle = 'rgb(0, 0, 0, 0.25)';
            this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
        }
        canvasDraw.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        canvasDraw.fillStyle = parent.themeColl[parent.theme]['secondaryColor'];
        var degree;
        if (tempObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - tempObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (actObj.shape === 'arrow' || actObj.shape === 'line') {
            canvasDraw.beginPath();
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.lineTo(actPoint.endX, actPoint.endY);
            canvasDraw.stroke();
        }
        else if (actObj.shape === 'path') {
            canvasDraw.beginPath();
            var activeObj = extend({}, parent.activeObj, {}, true);
            if (activeObj.pointColl[0]) {
                canvasDraw.moveTo(activeObj.pointColl[0].x, activeObj.pointColl[0].y);
                if (activeObj.pointColl.length > 1) {
                    for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
                        actPoint.endX = activeObj.pointColl[i].x;
                        actPoint.endY = activeObj.pointColl[i].y;
                        canvasDraw.lineTo(actPoint.endX, actPoint.endY);
                    }
                }
            }
            var obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] === 'path') {
                parent.activeObj = actObj = activeObj;
            }
            canvasDraw.lineTo(actPoint.endX, actPoint.endY);
            canvasDraw.stroke();
        }
        else {
            this.drawCornerCircles(canvasDraw);
        }
        if (parent.selectionSettings.showCircle && (splitWords === undefined || splitWords[0] !== 'crop')) {
            var strokeColor = canvasDraw.strokeStyle;
            var fillColor = canvasDraw.fillStyle;
            canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
            canvasDraw.fillStyle = parent.selectionSettings.fillColor;
            if (actObj.shape === 'text') {
                canvasDraw.lineWidth *= 2;
                canvasDraw.beginPath();
                this.drawRotationArcLine(canvasDraw);
                canvasDraw.lineTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
                canvasDraw.stroke();
                canvasDraw.fill();
                canvasDraw.closePath();
                canvasDraw.beginPath();
                canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
                canvasDraw.arc(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
                canvasDraw.stroke();
                canvasDraw.fill();
                canvasDraw.closePath();
                canvasDraw.lineWidth /= 2;
            }
            else {
                if (parent.activeObj.shape !== 'redact') {
                    this.drawCenterCircles(canvasDraw);
                }
            }
            canvasDraw.strokeStyle = strokeColor;
            canvasDraw.fillStyle = fillColor;
        }
        tempObj.rotationCircleLine = actObj.rotationCircleLine;
        parent.activeObj = extend({}, tempObj, {}, true);
    };
    Draw.prototype.drawArrowHead = function (canvasDraw, isStartHead) {
        var headType = isStartHead ? this.parent.activeObj.start : this.parent.activeObj.end;
        switch (headType) {
            case 'arrowSolid':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowSolid(canvasDraw, true) : this.arrowSolid(canvasDraw, false);
                break;
            case 'arrow':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrow(canvasDraw, true) : this.arrow(canvasDraw, false);
                break;
            case 'circleSolid':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowCircleSolid(canvasDraw, true) : this.arrowCircleSolid(canvasDraw, false);
                break;
            case 'circle':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowCircle(canvasDraw, true) : this.arrowCircle(canvasDraw, false);
                break;
            case 'bar':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowBar(canvasDraw, true) : this.arrowBar(canvasDraw, false);
                break;
            case 'square':
            case 'squareSolid':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowSquareStart(canvasDraw) : this.arrowSquareEnd(canvasDraw);
                break;
        }
    };
    Draw.prototype.drawShapeObj = function (canvas, shape, saveContext, isPreventSelection) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var actObj = parent.activeObj;
        var _a = actObj.strokeSettings, strokeColor = _a.strokeColor, fillColor = _a.fillColor, strokeWidth = _a.strokeWidth;
        var currentShape = shape !== undefined ? shape : parent.currObjType.shape;
        parent.currObjType.shape = currentShape;
        var canvasDraw;
        if (canvas.toLowerCase() === 'original') {
            canvasDraw = this.lowerContext;
        }
        else if (canvas.toLowerCase() === 'duplicate') {
            canvasDraw = this.upperContext;
        }
        else if (saveContext) {
            canvasDraw = saveContext;
        }
        var shapeType = parent.currObjType.shape.toLowerCase();
        var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'image', 'redact'];
        if (shapeColl.indexOf(shapeType) !== -1) {
            actObj.shape = parent.currObjType.shape;
        }
        canvasDraw.strokeStyle = strokeColor;
        if (shape === 'text' || shape === 'freehanddraw') {
            canvasDraw.fillStyle = strokeColor;
        }
        else {
            canvasDraw.fillStyle = fillColor;
        }
        var horLineWidth = actPoint.width / 3;
        var verLineHeight = actPoint.height / 3;
        var selectionWidth = actPoint.endX - actPoint.startX;
        var selectionHeight = actPoint.endY - actPoint.startY;
        this.rotateContext('initial', canvasDraw);
        var degree;
        var tempFillStyle = canvasDraw.fillStyle;
        var activeObj;
        switch (parent.currObjType.shape.toLowerCase()) {
            case 'rectangle':
                this.drawSquareLines(canvasDraw);
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'redact':
                this.drawRedact(canvasDraw, actObj);
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                parent.currObjType.isRedact = true;
                break;
            case 'ellipse':
                selectionWidth = Math.abs(selectionWidth);
                selectionHeight = Math.abs(selectionHeight);
                canvasDraw.beginPath();
                canvasDraw.ellipse(actPoint.startX + (selectionWidth / 2), actPoint.startY + (selectionHeight / 2), selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
                if (fillColor !== '') {
                    canvasDraw.fillStyle = fillColor;
                    canvasDraw.fill();
                }
                canvasDraw.ellipse(actPoint.startX + (selectionWidth / 2), actPoint.startY + (selectionHeight / 2), Math.abs((selectionWidth / 2) - (strokeWidth)), Math.abs((selectionHeight / 2) - (strokeWidth)), 0, 0, 2 * Math.PI, false);
                canvasDraw.fillStyle = strokeColor;
                canvasDraw.fill('evenodd');
                canvasDraw.closePath();
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'crop-circle':
                this.shapeCircle(canvasDraw, selectionWidth, selectionHeight);
                break;
            case 'line':
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'arrow':
                if (actObj.shapeDegree === 0) {
                    degree = parent.transform.degree;
                }
                else {
                    degree = parent.transform.degree - actObj.shapeDegree;
                }
                if (degree < 0) {
                    degree = 360 + degree;
                }
                canvasDraw.fillStyle = canvasDraw.strokeStyle;
                if (isNullOrUndefined(actObj.triangleDirection)) {
                    actObj.triangleDirection = 'right';
                }
                if (isNullOrUndefined(actObj.start)) {
                    actObj.start = 'none';
                }
                if (isNullOrUndefined(actObj.end)) {
                    actObj.end = 'arrowSolid';
                }
                this.drawArrowHead(canvasDraw, true);
                this.drawArrowHead(canvasDraw, false);
                if (actObj.end === 'none' && actObj.start !== 'circle' && actObj.start !== 'square') {
                    this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                }
                canvasDraw.fillStyle = tempFillStyle;
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'path':
                activeObj = extend({}, parent.activeObj, {}, true);
                if (activeObj.pointColl.length > 1) {
                    var obj = { shape: null };
                    parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
                    if (obj['shape'] === 'path' && parent.isShapeDrawing) {
                        var nextPoint = { x: 0, y: 0 };
                        for (var i = 0, len = activeObj.pointColl.length; i < len; i++) {
                            if (isNullOrUndefined(activeObj.pointColl[i + 1])) {
                                nextPoint.x = activeObj.activePoint.endX;
                                nextPoint.y = activeObj.activePoint.endY;
                            }
                            else {
                                nextPoint.x = activeObj.pointColl[i + 1].x;
                                nextPoint.y = activeObj.pointColl[i + 1].y;
                            }
                            actPoint.startX = activeObj.pointColl[i].x;
                            actPoint.startY = activeObj.pointColl[i].y;
                            actPoint.endX = nextPoint.x;
                            actPoint.endY = nextPoint.y;
                            parent.activeObj = this.updateWidthHeight(parent.activeObj);
                            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                            if (Browser.isDevice) {
                                activeObj.activePoint.endX = nextPoint.x;
                                activeObj.activePoint.endY = nextPoint.y;
                            }
                        }
                    }
                    else {
                        for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
                            actPoint.startX = activeObj.pointColl[i - 1].x;
                            actPoint.startY = activeObj.pointColl[i - 1].y;
                            actPoint.endX = activeObj.pointColl[i].x;
                            actPoint.endY = activeObj.pointColl[i].y;
                            parent.activeObj = this.updateWidthHeight(parent.activeObj);
                            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                        }
                    }
                    parent.activeObj = actObj = activeObj;
                }
                else {
                    this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                }
                if (canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'text':
                this.shapeText(canvasDraw);
                break;
            case 'image':
                this.shapeImage(canvasDraw);
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'crop-square':
            case 'crop-3:4':
            case 'crop-4:3':
            case 'crop-6:9':
            case 'crop-9:6':
            case 'crop-9:16':
            case 'crop-16:9':
                if (canvasDraw === this.lowerContext) {
                    canvasDraw = this.upperContext;
                }
                this.drawSelection(horLineWidth, verLineHeight);
                parent.currObjType.shape = '';
                break;
            default:
                this.drawSelection(horLineWidth, verLineHeight);
                break;
        }
        this.rotateContext('reverse', canvasDraw);
    };
    Draw.prototype.updatePoints = function () {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop;
        actPoint.startX += destLeft;
        actPoint.startY += destTop;
        actPoint.endX += destLeft;
        actPoint.endY += destTop;
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
    };
    Draw.prototype.updateWidthHeight = function (obj) {
        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        obj.activePoint.width = endX - startX;
        obj.activePoint.height = endY - startY;
        return obj;
    };
    Draw.prototype.drawCornerCircles = function (canvasDraw) {
        var parent = this.parent;
        var tempObj = parent.activeObj;
        canvasDraw.beginPath();
        canvasDraw.rect(tempObj.activePoint.startX, tempObj.activePoint.startY, tempObj.activePoint.width, tempObj.activePoint.height);
        canvasDraw.stroke();
        canvasDraw.closePath();
        if (parent.selectionSettings.showCircle) {
            var strokeColor = canvasDraw.strokeStyle;
            var fillColor = canvasDraw.fillStyle;
            canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
            canvasDraw.fillStyle = parent.selectionSettings.fillColor;
            canvasDraw.lineWidth *= 2;
            canvasDraw.beginPath();
            canvasDraw.moveTo(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY);
            canvasDraw.arc(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY, tempObj.topLeftCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY);
            canvasDraw.arc(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY, tempObj.topRightCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY);
            canvasDraw.arc(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY, tempObj.bottomLeftCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY);
            canvasDraw.arc(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY, tempObj.bottomRightCircle.radius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.fill();
            canvasDraw.closePath();
            canvasDraw.lineWidth /= 2;
            canvasDraw.strokeStyle = strokeColor;
            canvasDraw.fillStyle = fillColor;
        }
    };
    Draw.prototype.drawCenterCircles = function (canvasDraw) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var actObj = parent.activeObj;
        canvasDraw.lineWidth *= 2;
        canvasDraw.beginPath();
        if (actObj.shape === 'arrow' || actObj.shape === 'line') {
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(actPoint.endX, actPoint.endY);
            canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
        }
        else if (actObj.shape === 'path') {
            var activeObj = extend({}, parent.activeObj, {}, true);
            if (activeObj.pointColl.length > 1) {
                for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
                    actPoint.startX = activeObj.pointColl[i - 1].x;
                    actPoint.startY = activeObj.pointColl[i - 1].y;
                    actPoint.endX = activeObj.pointColl[i].x;
                    actPoint.endY = activeObj.pointColl[i].y;
                    canvasDraw.moveTo(actPoint.startX, actPoint.startY);
                    canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
                    canvasDraw.moveTo(actPoint.endX, actPoint.endY);
                    canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
                }
            }
            var obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] === 'path') {
                parent.activeObj = actObj = activeObj;
            }
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(actPoint.endX, actPoint.endY);
            canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
        }
        else {
            this.drawRotationArcLine(canvasDraw);
            canvasDraw.lineTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
        }
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        if (actObj.shape !== 'arrow' && actObj.shape !== 'line' && actObj.shape !== 'path') {
            canvasDraw.beginPath();
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
            canvasDraw.arc(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.fill();
            canvasDraw.closePath();
        }
        canvasDraw.lineWidth /= 2;
    };
    Draw.prototype.drawRotationArcLine = function (canvasDraw) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        if (isNullOrUndefined(actObj.rotationCircleLine)) {
            actObj.rotationCircleLine = 22.5;
        }
        var degree;
        var isHorizontalflip = false;
        var isVerticalflip = false;
        if (actObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - actObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (actObj.flipObjColl) {
            for (var i = 0, len = actObj.flipObjColl.length; i < len; i++) {
                var flipStr = actObj.flipObjColl[i].toLowerCase();
                if (flipStr === 'horizontal') {
                    isHorizontalflip = true;
                }
                else if (flipStr === 'vertical') {
                    isVerticalflip = true;
                }
            }
        }
        switch (degree) {
            case 0:
            case 360:
                if (isVerticalflip) {
                    actObj.rotationCirclePoint = { x: actObj.topCenterCircle.startX,
                        y: actObj.topCenterCircle.startY - actObj.rotationCircleLine };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y + actObj.rotationCircleLine);
                }
                else {
                    actObj.rotationCirclePoint = { x: actObj.bottomCenterCircle.startX,
                        y: actObj.bottomCenterCircle.startY + actObj.rotationCircleLine };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y - actObj.rotationCircleLine);
                }
                break;
            case 90:
            case -270:
                if (isHorizontalflip) {
                    actObj.rotationCirclePoint = { x: actObj.centerRightCircle.startX +
                            actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x - actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
                }
                else {
                    actObj.rotationCirclePoint = { x: actObj.centerLeftCircle.startX -
                            actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x + actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
                }
                break;
            case 180:
            case -180:
                if (isVerticalflip) {
                    actObj.rotationCirclePoint = { x: actObj.bottomCenterCircle.startX,
                        y: actObj.bottomCenterCircle.startY + actObj.rotationCircleLine };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y - actObj.rotationCircleLine);
                }
                else {
                    actObj.rotationCirclePoint = { x: actObj.topCenterCircle.startX,
                        y: actObj.topCenterCircle.startY - actObj.rotationCircleLine };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y + actObj.rotationCircleLine);
                }
                break;
            case 270:
            case -90:
                if (isHorizontalflip) {
                    actObj.rotationCirclePoint = { x: actObj.centerLeftCircle.startX -
                            actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x + actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
                }
                else {
                    actObj.rotationCirclePoint = { x: actObj.centerRightCircle.startX +
                            actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(actObj.rotationCirclePoint.x - actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
                }
                break;
        }
    };
    Draw.prototype.drawSquareLines = function (canvasDraw) {
        var splitWords;
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
        var _b = actObj.strokeSettings, fillColor = _b.fillColor, strokeColor = _b.strokeColor, strokeWidth = _b.strokeWidth, radius = _b.radius;
        if (actObj.shape) {
            splitWords = actObj.shape.split('-');
        }
        if (splitWords[0] === 'crop') {
            canvasDraw.strokeStyle = '#fff';
        }
        else {
            canvasDraw.strokeStyle = strokeColor;
        }
        canvasDraw.beginPath();
        var obj = { width: 0, height: 0 };
        var ratio = { width: 1, height: 1 };
        parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
            value: { obj: obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } } });
        ratio = obj;
        var isTempCanvas = canvasDraw.canvas.id === parent.element.id + '_tempCanvas';
        var zoomFactor = parent.transform.zoomFactor;
        var baseRadius = isTempCanvas ? radius * 10 * ((ratio.width + ratio.height) / 2) : radius * 10;
        var adjustedRadius = baseRadius + (baseRadius * zoomFactor);
        if (radius !== null) {
            if (parent.isSafari) {
                this.drawRoundedRect(canvasDraw, startX, startY, width, height, adjustedRadius);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                canvasDraw.roundRect(startX, startY, width, height, adjustedRadius);
            }
        }
        else {
            canvasDraw.rect(startX, startY, width, height);
        }
        if (fillColor !== '') {
            canvasDraw.fillStyle = fillColor;
            canvasDraw.fill();
        }
        if (radius !== null) {
            if (parent.isSafari) {
                this.drawRoundedRect(canvasDraw, startX + strokeWidth, startY + strokeWidth, width - (2 * strokeWidth), height - (2 * strokeWidth), adjustedRadius);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                canvasDraw.roundRect(startX + strokeWidth, startY + strokeWidth, width - (2 * strokeWidth), height - (2 * strokeWidth), adjustedRadius);
            }
        }
        else {
            canvasDraw.rect(startX + strokeWidth, startY + strokeWidth, width - (2 * strokeWidth), height - (2 * strokeWidth));
        }
        canvasDraw.fillStyle = strokeColor;
        canvasDraw.fill('evenodd');
        canvasDraw.closePath();
    };
    Draw.prototype.drawRoundedRect = function (canvasDraw, startX, startY, width, height, radius) {
        var rectRadius = Math.max(0, Math.min(radius, width / 2, height / 2));
        canvasDraw.moveTo(startX + rectRadius, startY);
        canvasDraw.arcTo(startX + width, startY, startX + width, startY + height, rectRadius);
        canvasDraw.arcTo(startX + width, startY + height, startY, startY + height, rectRadius);
        canvasDraw.arcTo(startX, startY + height, startX, startY, rectRadius);
        canvasDraw.arcTo(startX, startY, startX + width, startY, rectRadius);
        canvasDraw.closePath();
    };
    Draw.prototype.drawSelection = function (horLineWidth, verLineHeight) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        this.upperContext.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        this.upperContext.beginPath();
        actObj.horTopInnerLine = { startX: startX, startY: startY +
                verLineHeight, endX: endX, endY: endY + verLineHeight };
        actObj.horBottomInnerLine = { startX: startX, startY: startY + (2 * verLineHeight), endX: endX, endY: endY + (2 * verLineHeight) };
        actObj.verLeftInnerLine = { startX: startX + horLineWidth,
            startY: startY, endX: startX + horLineWidth, endY: endY };
        actObj.verRightInnerLine = { startX: startX + (2 * horLineWidth),
            startY: startY, endX: startX + (2 * horLineWidth), endY: endY };
        this.upperContext.moveTo(actObj.horTopInnerLine.startX, actObj.horTopInnerLine.startY);
        this.upperContext.lineTo(actObj.horTopInnerLine.endX, actObj.horTopInnerLine.startY);
        this.upperContext.moveTo(actObj.horBottomInnerLine.startX, actObj.horBottomInnerLine.startY);
        this.upperContext.lineTo(actObj.horBottomInnerLine.endX, actObj.horBottomInnerLine.startY);
        this.upperContext.moveTo(actObj.verLeftInnerLine.startX, actObj.verLeftInnerLine.startY);
        this.upperContext.lineTo(actObj.verLeftInnerLine.endX, actObj.verLeftInnerLine.endY);
        this.upperContext.moveTo(actObj.verRightInnerLine.startX, actObj.verRightInnerLine.startY);
        this.upperContext.lineTo(actObj.verRightInnerLine.endX, actObj.verRightInnerLine.endY);
        this.upperContext.stroke();
        this.upperContext.closePath();
    };
    Draw.prototype.shapeCircle = function (canvasDraw, selectionWidth, selectionHeight) {
        var parent = this.parent;
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width;
        canvasDraw.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        canvasDraw.fillStyle = 'rgb(0, 0, 0, 0.25)';
        canvasDraw.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        var tempWidth = canvasDraw.lineWidth;
        canvasDraw.lineWidth = (2);
        canvasDraw.beginPath();
        canvasDraw.ellipse(parent.activeObj.horTopLine.startX + (selectionWidth / 2), parent.activeObj.horTopLine.startY
            + (selectionHeight / 2), selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
        canvasDraw.stroke();
        canvasDraw.closePath();
        canvasDraw.save();
        canvasDraw.beginPath();
        canvasDraw.arc(((endX - startX) / 2) + startX, ((endY - startY) / 2) + startY, (width / 2), 0, Math.PI * 2);
        canvasDraw.closePath();
        canvasDraw.clip();
        canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        canvasDraw.restore();
        canvasDraw.lineWidth = tempWidth;
        this.drawOuterSelection(canvasDraw, true);
        parent.currObjType.shape = '';
    };
    Draw.prototype.shapeLine = function (canvasDraw, x1, y1, x2, y2) {
        var tempLineWidth = canvasDraw.lineWidth;
        canvasDraw.lineWidth = (this.parent.activeObj.strokeSettings.strokeWidth);
        canvasDraw.beginPath();
        canvasDraw.moveTo(x1, y1);
        canvasDraw.lineTo(x2, y2);
        canvasDraw.stroke();
        canvasDraw.lineWidth = tempLineWidth;
    };
    Draw.prototype.manipulateSaveCtx = function (canvasDraw, x, y) {
        if (canvasDraw !== this.lowerContext && canvasDraw !== this.upperContext) {
            var obj = { width: 0, height: 0 };
            this.parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
                value: { obj: obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } } });
            var ratio = obj;
            if (x) {
                x *= (ratio.width);
            }
            if (y) {
                y *= (ratio.height);
            }
        }
        return { x: x, y: y };
    };
    Draw.prototype.arrow = function (canvasDraw, start) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var strWidth = actObj.strokeSettings.strokeWidth;
        canvasDraw.lineWidth = strWidth;
        var x = this.arrowDimension['arrow']['width'];
        var y = this.arrowDimension['arrow']['height'];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        var angle = Math.atan2(this.dy, this.dx);
        var isStartArrow = actObj.start === 'arrow';
        var isEndArrow = actObj.end === 'arrow';
        var isEndCircleOrSquare = actObj.end === 'circle' || actObj.end === 'square';
        var isStartCircleOrSquare = actObj.start === 'circle' || actObj.start === 'square';
        if ((start && actObj.triangleDirection === 'left' || actObj.triangleDirection === 'right') &&
            ((isStartArrow && actObj.end === 'none') || (isStartArrow && !isEndCircleOrSquare && !isStartCircleOrSquare)) ||
            (!start && (isEndArrow && actObj.start === 'none' || !isStartArrow && !isEndCircleOrSquare && !isStartCircleOrSquare))) {
            this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        if ((start && actObj.triangleDirection === 'left') || (!start && actObj.triangleDirection === 'right')) {
            canvasDraw.translate(endX, endY);
            canvasDraw.rotate(angle);
            this.shapeLine(canvasDraw, 0, 0, -x, y / 2);
            this.shapeLine(canvasDraw, 0, 0, -x, -y / 2);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-endX, -endY);
        }
        else if ((start && actObj.triangleDirection === 'right') || (!start && actObj.triangleDirection === 'left')) {
            canvasDraw.translate(startX, startY);
            canvasDraw.rotate(angle);
            this.shapeLine(canvasDraw, 0, 0, x, y / 2);
            this.shapeLine(canvasDraw, 0, 0, x, -y / 2);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-startX, -startY);
        }
    };
    Draw.prototype.arrowSolid = function (canvasDraw, start) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var strWidth = actObj.strokeSettings.strokeWidth;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var x = this.arrowDimension['arrowSolid']['width'];
        var y = this.arrowDimension['arrowSolid']['height'];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        var angle = Math.atan2(this.dy, this.dx);
        var isStartArrowSolid = actObj.start === 'arrowSolid';
        var isEndArrowSolid = actObj.end === 'arrowSolid';
        var isEndCircleOrSquare = actObj.end === 'circle' || actObj.end === 'square';
        var isStartCircleOrSquare = actObj.start === 'circle' || actObj.start === 'square';
        if ((start && (isStartArrowSolid && actObj.end === 'none') || (isStartArrowSolid && !isEndCircleOrSquare && !isStartCircleOrSquare)) ||
            (!start && (isEndArrowSolid && actObj.start === 'none' || !isStartArrowSolid && !isEndCircleOrSquare && !isStartCircleOrSquare))) {
            this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        if ((start && actObj.triangleDirection === 'left') || (!start && actObj.triangleDirection === 'right')) {
            canvasDraw.translate(endX, endY);
            canvasDraw.rotate(angle);
            canvasDraw.beginPath();
            canvasDraw.moveTo(strWidth, 0);
            canvasDraw.lineTo(-x + y / 2, y / 2);
            canvasDraw.lineTo(-x + y / 2, -y / 2);
            canvasDraw.closePath();
            canvasDraw.fill();
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-endX, -endY);
            actObj.rotatedAngle = angle;
        }
        else if ((start && actObj.triangleDirection === 'right') || (!start && actObj.triangleDirection === 'left')) {
            canvasDraw.translate(startX, startY);
            canvasDraw.rotate(angle);
            canvasDraw.beginPath();
            canvasDraw.moveTo(0 - strWidth, 0);
            canvasDraw.lineTo(x - y / 2, y / 2);
            canvasDraw.lineTo(x - y / 2, -y / 2);
            canvasDraw.closePath();
            canvasDraw.fill();
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-startX, -startY);
            actObj.rotatedAngle = angle;
        }
    };
    Draw.prototype.arrowSquareStart = function (canvasDraw) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var strWidth = actObj.strokeSettings.strokeWidth;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var isStartSquare = actObj.start === 'square';
        var isEndCircle = actObj.end === 'circle';
        var isStartSquareSolid = actObj.start === 'squareSolid';
        var isEndCircleSolid = actObj.end === 'circleSolid';
        if ((isStartSquare && actObj.end === 'none') || (isStartSquare && !isEndCircle && actObj.start !== 'square') ||
            (isStartSquareSolid && isEndCircleSolid)) {
            this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        canvasDraw.lineWidth = (strWidth);
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        var x = this.arrowDimension['square']['width'];
        var y = this.arrowDimension['square']['height'];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        var angle = Math.atan2(this.dy, this.dx);
        if (actObj.triangleDirection === 'left') {
            canvasDraw.translate(endX, endY);
            canvasDraw.rotate(angle);
            if (actObj.start === 'squareSolid') {
                canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
            }
            canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-endX, -endY);
            this.squareStartIntersectX1 = endX - (y / 2) * Math.cos(angle);
            this.squareStartIntersectY1 = endY - (y / 2) * Math.sin(angle);
            if (actObj.start === 'square' && actObj.end !== 'square' && actObj.end !== 'circle') {
                this.shapeLine(canvasDraw, startX, startY, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
            else if (actObj.start === 'square' && actObj.end === 'circle') {
                this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
            else if (actObj.start === 'squareSolid' && actObj.end === 'squareSolid') {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
        }
        else if (actObj.triangleDirection === 'right') {
            canvasDraw.lineWidth = (strWidth);
            canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
            if (actObj.start === 'squareSolid' && actObj.end === 'squareSolid') {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
            canvasDraw.translate(startX, startY);
            canvasDraw.rotate(angle);
            if (actObj.start === 'squareSolid') {
                canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
            }
            canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-startX, -startY);
            actObj.rotatedAngle = angle;
            this.squareStartIntersectX1 = startX + (y / 2) * Math.cos(angle);
            this.squareStartIntersectY1 = startY + (y / 2) * Math.sin(angle);
            if (actObj.start === 'square' && actObj.end !== 'square' && actObj.end !== 'circle') {
                this.shapeLine(canvasDraw, endX, endY, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
            if (actObj.start === 'square' && actObj.end === 'circle') {
                this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
        }
    };
    Draw.prototype.arrowSquareEnd = function (canvasDraw) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var strWidth = actObj.strokeSettings.strokeWidth;
        var x = this.arrowDimension['square']['width'];
        var y = this.arrowDimension['square']['height'];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        var angle = Math.atan2(this.dy, this.dx);
        canvasDraw.lineWidth = (strWidth);
        if (actObj.triangleDirection === 'right') {
            canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
            if (actObj.end === 'squareSolid' && actObj.start === 'none') {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
            canvasDraw.translate(endX, endY);
            canvasDraw.rotate(angle);
            if (actObj.end === 'squareSolid') {
                canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
            }
            canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-endX, -endY);
            actObj.rotatedAngle = angle;
            this.squareEndIntersectX1 = endX - (y / 2) * Math.cos(angle);
            this.squareEndIntersectY1 = endY - (y / 2) * Math.sin(angle);
            if (actObj.end === 'square' && actObj.start !== 'square' && actObj.start !== 'circle') {
                this.shapeLine(canvasDraw, startX, startY, this.squareEndIntersectX1, this.squareEndIntersectY1);
            }
            else if (actObj.start === 'circle' && actObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
            else if (actObj.start === 'square' && actObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
        }
        else if (actObj.triangleDirection === 'left') {
            canvasDraw.translate(startX, startY);
            canvasDraw.rotate(angle);
            if (actObj.end === 'squareSolid') {
                canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
            }
            canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-startX, -startY);
            actObj.rotatedAngle = angle;
            this.squareEndIntersectX1 = startX + (y / 2) * Math.cos(angle);
            this.squareEndIntersectY1 = startY + (y / 2) * Math.sin(angle);
            if (actObj.end === 'square' && actObj.start !== 'square' && actObj.start !== 'circle') {
                this.shapeLine(canvasDraw, endX, endY, this.squareEndIntersectX1, this.squareEndIntersectY1);
            }
            else if (actObj.start === 'circle' && actObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
            else if (actObj.start === 'square' && actObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
            else if (actObj.end === 'squareSolid' && actObj.start === 'none') {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
        }
    };
    Draw.prototype.arrowCircle = function (canvasDraw, start) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var strWidth = actObj.strokeSettings.strokeWidth;
        if ((start && actObj.triangleDirection === 'left') ||
            (!start && actObj.triangleDirection === 'right')) {
            canvasDraw.lineWidth = strWidth;
            var circleRadius = this.arrowDimension['circle']['width'];
            var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + strWidth;
            canvasDraw.beginPath();
            canvasDraw.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.closePath();
            this.dx = endX - startX;
            this.dy = endY - startY;
            var a = this.dx * this.dx + this.dy * this.dy;
            var b = 2 * (this.dx * (startX - endX) + this.dy * (startY - endY));
            var c = (startX - endX) * (startX - endX) + (startY - endY) *
                (startY - endY) - circleRadius * circleRadius;
            var intersect = b * b - 4 * a * c;
            if (intersect >= 0) {
                canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
                var t2 = (-b - Math.sqrt(intersect)) / (2 * a);
                var intersectionX1 = startX + this.dx * t2;
                var intersectionY1 = startY + this.dy * t2;
                if (start) {
                    this.startCircleIntersectX1 = intersectionX1;
                    this.startCircleIntersectY1 = intersectionY1;
                    this.endCircleIntersectX1 = endX - this.dx * t2;
                    this.endCircleIntersectY1 = endY - this.dy * t2;
                    canvasDraw.beginPath();
                    canvasDraw.fill();
                    canvasDraw.beginPath();
                    if (actObj.start === 'circle' && actObj.end === 'circle') {
                        this.shapeLine(canvasDraw, this.startCircleIntersectX1, this.startCircleIntersectY1, this.endCircleIntersectX1, this.endCircleIntersectY1);
                    }
                    else if (actObj.start === 'circle' && actObj.end !== 'circle' && actObj.end !== 'square') {
                        this.shapeLine(canvasDraw, startX, startY, this.startCircleIntersectX1, this.startCircleIntersectY1);
                    }
                    canvasDraw.stroke();
                    canvasDraw.closePath();
                }
                else {
                    this.endCircleIntersectX1 = intersectionX1;
                    this.endCircleIntersectY1 = intersectionY1;
                    if (actObj.end === 'circle' && (actObj.start !== 'circle' && actObj.start !== 'square')) {
                        this.shapeLine(canvasDraw, startX, startY, this.endCircleIntersectX1, this.endCircleIntersectY1);
                    }
                }
            }
            var angle = Math.atan2(this.dy, this.dx);
            parent.activeObj.rotatedAngle = angle;
        }
        else if ((start && actObj.triangleDirection === 'right') ||
            (!start && actObj.triangleDirection === 'left')) {
            canvasDraw.lineWidth = strWidth;
            var circleRadius = this.arrowDimension['circle']['width'];
            var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + strWidth;
            canvasDraw.beginPath();
            canvasDraw.arc(startX, startY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.closePath();
            this.dx = startX - endX;
            this.dy = startY - endY;
            var a = this.dx * this.dx + this.dy * this.dy;
            var b = 2 * (this.dx * (endX - startX) + this.dy * (endY - startY));
            var c = (endX - startX) * (endX - startX) + (endY - startY) *
                (endY - startY) - circleRadius * circleRadius;
            var intersect = b * b - 4 * a * c;
            if (intersect >= 0) {
                canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
                var t2 = (-b - Math.sqrt(intersect)) / (2 * a);
                var intersectionX1 = endX + this.dx * t2;
                var intersectionY1 = endY + this.dy * t2;
                if (start) {
                    this.startCircleIntersectX1 = intersectionX1;
                    this.startCircleIntersectY1 = intersectionY1;
                    this.endCircleIntersectX1 = startX - this.dx * t2;
                    this.endCircleIntersectY1 = startY - this.dy * t2;
                    if (actObj.start === 'circle' && actObj.end === 'circle') {
                        this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
                    }
                    else if (actObj.start === 'circle' && actObj.end !== 'circle' && actObj.end !== 'square') {
                        this.shapeLine(canvasDraw, endX, endY, this.startCircleIntersectX1, this.startCircleIntersectY1);
                    }
                }
                else {
                    this.endCircleIntersectX1 = intersectionX1;
                    this.endCircleIntersectY1 = intersectionY1;
                    canvasDraw.beginPath();
                    canvasDraw.fill();
                    canvasDraw.beginPath();
                    if (actObj.end === 'circle' && (actObj.start !== 'circle' && actObj.start !== 'square')) {
                        this.shapeLine(canvasDraw, endX, endY, this.endCircleIntersectX1, this.endCircleIntersectY1);
                    }
                }
            }
            var angle = Math.atan2(this.dy, this.dx);
            parent.activeObj.rotatedAngle = angle;
        }
    };
    Draw.prototype.arrowCircleSolid = function (canvasDraw, start) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var isStartCircleSolid = actObj.start === 'circleSolid';
        var strWidth = actObj.strokeSettings.strokeWidth;
        if ((start && actObj.triangleDirection === 'left') || (!start && actObj.triangleDirection === 'right')) {
            canvasDraw.lineWidth = strWidth;
            canvasDraw.beginPath();
            canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
            if ((start && (isStartCircleSolid && actObj.end === 'none') ||
                (isStartCircleSolid && actObj.end !== 'circle' && actObj.end !== 'square')) ||
                (!start && (actObj.end === 'circleSolid' && actObj.start === 'none'))) {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
            var circleRadius = this.arrowDimension['circle']['width'];
            var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + strWidth;
            this.dx = endX - startX;
            this.dy = endY - startY;
            canvasDraw.save();
            canvasDraw.beginPath();
            canvasDraw.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.fill();
            canvasDraw.closePath();
            actObj.rotatedAngle = Math.atan2(this.dy, this.dx);
        }
        else if ((start && actObj.triangleDirection === 'right') || (!start && actObj.triangleDirection === 'left')) {
            canvasDraw.lineWidth = strWidth;
            canvasDraw.beginPath();
            canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
            if ((start && (isStartCircleSolid && actObj.end === 'none') ||
                (isStartCircleSolid && actObj.end !== 'circle' && actObj.end !== 'square')) ||
                !start && (actObj.end === 'circleSolid' && actObj.start === 'none')) {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
            var circleRadius = this.arrowDimension['circle']['width'];
            var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + strWidth;
            this.dx = endX - startX;
            this.dy = endY - startY;
            canvasDraw.save();
            canvasDraw.beginPath();
            canvasDraw.arc(startX, startY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.fill();
            canvasDraw.closePath();
            actObj.rotatedAngle = Math.atan2(this.dy, this.dx);
        }
    };
    Draw.prototype.arrowBar = function (canvasDraw, start) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var strWidth = actObj.strokeSettings.strokeWidth;
        if ((start && actObj.triangleDirection === 'left') || (!start && actObj.triangleDirection === 'right')) {
            canvasDraw.lineWidth = strWidth;
            canvasDraw.beginPath();
            canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
            if ((start && (actObj.start === 'bar' && actObj.end === 'none') ||
                (actObj.start === 'bar' && (actObj.end !== 'circle' && actObj.end !== 'square'))) ||
                (!start && ((actObj.end === 'bar' && actObj.start === 'none') ||
                    (actObj.end === 'bar' && (actObj.start !== 'circle' && actObj.start !== 'square'))))) {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
            var x = this.arrowDimension['bar']['width'];
            var y = this.arrowDimension['bar']['height'];
            var point = this.manipulateSaveCtx(canvasDraw, x, y);
            x = point.x + strWidth;
            y = point.y + strWidth;
            this.dx = endX - startX;
            this.dy = endY - startY;
            var angle = Math.atan2(this.dy, this.dx);
            canvasDraw.translate(endX, endY);
            canvasDraw.rotate(angle);
            canvasDraw.fillRect(-x + y / 4, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-endX, -endY);
            actObj.rotatedAngle = angle;
        }
        else if ((start && actObj.triangleDirection === 'right') || (!start && actObj.triangleDirection === 'left')) {
            canvasDraw.lineWidth = strWidth;
            canvasDraw.beginPath();
            canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
            if ((start && (actObj.start === 'bar' && actObj.end === 'none')
                || (actObj.start === 'bar' && (actObj.end !== 'circle' && actObj.end !== 'square'))) ||
                (!start && (actObj.end === 'bar' && actObj.start === 'none'))) {
                this.shapeLine(canvasDraw, startX, startY, endX, endY);
            }
            var x = this.arrowDimension['bar']['width'];
            var y = this.arrowDimension['bar']['height'];
            var point = this.manipulateSaveCtx(canvasDraw, x, y);
            x = point.x + strWidth;
            y = point.y + strWidth;
            this.dx = endX - startX;
            this.dy = endY - startY;
            var angle = Math.atan2(this.dy, this.dx);
            canvasDraw.translate(startX, startY);
            canvasDraw.rotate(angle);
            canvasDraw.fillRect(y / 4 - x, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-startX, -startY);
            parent.activeObj.rotatedAngle = angle;
        }
    };
    Draw.prototype.shapeImage = function (canvasDraw) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
        var ctx = actObj.imageCanvas.getContext('2d');
        if (canvasDraw === this.lowerContext && this.isImageApply) {
            var dimObj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false, value: { width: actObj
                        .imageElement.width, height: actObj.imageElement.height, obj: dimObj, isImgShape: null } });
            if (width < (dimObj['width'] / 5) || height < (dimObj['height'] / 5)) {
                ctx.clearRect(0, 0, actObj.imageCanvas.width, actObj.imageCanvas.height);
                parent.notify('selection', { prop: 'applyTransformToImg', onPropertyChange: false, value: { ctx: ctx } });
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('selection', { prop: 'setImageClarity', onPropertyChange: false, value: { bool: false } });
                this.isImageApply = false;
            }
        }
        var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
        imgPoint.width = width;
        imgPoint.height = height;
        if (actObj.flipObjColl.length === 4) {
            actObj.flipObjColl = [];
            actObj.shapeFlip = '';
        }
        imgPoint.startX = ((width - imgPoint.width) / 2) + startX;
        imgPoint.startY = ((height - imgPoint.height) / 2) + startY;
        var temp = canvasDraw.globalAlpha;
        canvasDraw.globalAlpha = actObj.opacity;
        if (actObj.rotateFlipColl && actObj.rotateFlipColl.length > 0) {
            this.rotateImage(canvasDraw);
        }
        else {
            canvasDraw.drawImage(actObj.imageCanvas, imgPoint.startX, imgPoint.startY, imgPoint.width, imgPoint.height);
        }
        canvasDraw.globalAlpha = temp;
        parent.currObjType.isText = false;
    };
    Draw.prototype.shapeText = function (canvasDraw) {
        var parent = this.parent;
        var filter = canvasDraw.filter;
        var actObj = parent.activeObj;
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
        var rows = actObj.keyHistory.split('\n');
        var _b = actObj.textSettings, fontFamily = _b.fontFamily, bold = _b.bold, italic = _b.italic;
        var fontSize = actObj.textSettings.fontSize;
        var lHeight = fontSize + fontSize * 0.25;
        var lineHeight = ((lHeight * rows.length) - (fontSize * rows.length)) / rows.length;
        canvasDraw.filter = 'none';
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var tempFill = canvasDraw.fillStyle;
        if (actObj.strokeSettings.fillColor !== '') {
            canvasDraw.fillStyle = actObj.strokeSettings.fillColor;
            canvasDraw.fillRect(actObj.activePoint.startX, actObj.activePoint.startY, actObj.activePoint.width, actObj.activePoint.height);
        }
        canvasDraw.fillStyle = tempFill;
        for (var i = 0; i < rows.length; i++) {
            var text = rows[i];
            var yPoint = ((i + 1) * fontSize * 0.85) + (i * lineHeight);
            if (parent.transform.degree === -360) {
                parent.transform.degree = 0;
            }
            if (parent.transform.degree === 0 || parent.transform.degree === 180) {
                if (fontSize > height) {
                    fontSize = actObj.textSettings.fontSize = height - (height * 0.1);
                }
            }
            else {
                if (fontSize > width) {
                    fontSize = actObj.textSettings.fontSize = width - (width * 0.1);
                }
            }
            canvasDraw.strokeStyle = actObj.strokeSettings.outlineColor;
            canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
            var tempWidth = canvasDraw.lineWidth;
            var obj = { width: 0, height: 0 };
            var ratio = { width: 1, height: 1 };
            parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
                value: { obj: obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } } });
            ratio = obj;
            var isTempCanvas = canvasDraw.canvas.id === parent.element.id + '_tempCanvas';
            var baseWidth = Math.max(1, actObj.strokeSettings.outlineWidth / 2);
            if (/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$|^[a-zA-Z]+$/.test(actObj.strokeSettings.outlineColor)) {
                canvasDraw.lineWidth = baseWidth * ((isTempCanvas ? Math.floor((fontSize - 1) / 60) :
                    Math.floor((fontSize - 1) / 16)) * 0.5 + 0.5);
                if (isTempCanvas) {
                    canvasDraw.lineWidth *= ((ratio.width + ratio.height) / 2);
                    if (parent.transform.degree !== 0) {
                        canvasDraw.lineWidth /= 1.8;
                    }
                }
            }
            else {
                canvasDraw.lineWidth = 1;
            }
            var textStyle = '';
            if (bold) {
                textStyle = 'bold ';
            }
            if (italic) {
                textStyle = 'italic ';
            }
            if (bold && italic) {
                textStyle = 'italic bold ';
            }
            canvasDraw.font = textStyle + fontSize + 'px' + ' ' + fontFamily;
            if (actObj.flipObjColl.length === 4) {
                actObj.flipObjColl = [];
                actObj.shapeFlip = '';
            }
            if (actObj.rotateFlipColl && actObj.rotateFlipColl.length > 0) {
                this.rotateText(canvasDraw);
            }
            else {
                canvasDraw.strokeText(text, startX + fontSize * 0.1, startY + yPoint);
                canvasDraw.fillText(text, startX + fontSize * 0.1, startY + yPoint);
            }
            canvasDraw.lineWidth = tempWidth;
        }
        canvasDraw.filter = filter;
        parent.currObjType.isText = false;
        if (this.upperContext === canvasDraw) {
            this.drawOuterSelection(canvasDraw);
        }
    };
    Draw.prototype.updateActPoint = function (degree, canvasDraw) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var actPoint = actObj.activePoint;
        if (degree.toLowerCase() === 'horizontal') {
            if (actPoint.startX <= canvasDraw.canvas.width / 2) {
                actPoint.startX = canvasDraw.canvas.width / 2 + ((canvasDraw.canvas.width / 2) - actPoint.endX);
                actPoint.endX = actPoint.startX + actPoint.width;
                this.updateActiveObject(actPoint, actObj);
                parent.activeObj = actObj;
            }
            else if (actPoint.startX >= canvasDraw.canvas.width / 2) {
                actPoint.startX = canvasDraw.canvas.width - actPoint.endX;
                actPoint.endX = actPoint.startX + actPoint.width;
                this.updateActiveObject(actPoint, actObj);
                parent.activeObj = actObj;
            }
        }
        else if (degree.toLowerCase() === 'vertical') {
            if (actPoint.startY <= canvasDraw.canvas.height / 2) {
                actPoint.startY = canvasDraw.canvas.height / 2 + ((canvasDraw.canvas.height / 2) - actPoint.endY);
                actPoint.endY = actPoint.startY + actPoint.height;
                this.updateActiveObject(actPoint, actObj);
                parent.activeObj = actObj;
            }
            else if (actPoint.startY >= canvasDraw.canvas.height / 2) {
                actPoint.startY = canvasDraw.canvas.height - actPoint.endY;
                actPoint.endY = actPoint.startY + actPoint.height;
                this.updateActiveObject(actPoint, actObj);
                parent.activeObj = actObj;
            }
        }
        return actPoint;
    };
    Draw.prototype.rotateImage = function (canvasDraw) {
        var parent = this.parent;
        var degree;
        var actObj = parent.activeObj;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (actObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - actObj.shapeDegree;
        }
        if (degree === -450) {
            degree = -90;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
        imgPoint.width = degree % 90 === 0 && degree % 180 !== 0 ? actObj.activePoint.height : actObj.activePoint.width;
        imgPoint.height = degree % 90 === 0 && degree % 180 !== 0 ? actObj.activePoint.width :
            actObj.activePoint.height;
        imgPoint.startX = actObj.activePoint.startX;
        imgPoint.startY = actObj.activePoint.startY;
        var startX = imgPoint.startX;
        var startY = imgPoint.startY;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var tempDegree;
        canvasDraw.save();
        for (var i = 0, len = actObj.rotateFlipColl.length; i < len; i++) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var coll = actObj.rotateFlipColl[i];
            if (typeof (coll) === 'number') {
                tempDegree = coll;
                if (tempDegree === -450) {
                    tempDegree = -90;
                }
                if (tempDegree < 0) {
                    tempDegree = 360 + tempDegree;
                }
                imgPoint.width = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actObj.activePoint.height : actObj.activePoint.width;
                imgPoint.height = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actObj.activePoint.width :
                    actObj.activePoint.height;
                canvasDraw.translate(canvasDraw.canvas.width / 2, canvasDraw.canvas.height / 2);
                canvasDraw.rotate(Math.PI / 180 * coll);
                canvasDraw.translate(-canvasDraw.canvas.height / 2, -canvasDraw.canvas.width / 2);
                if ((tempDegree % 90 === 0 && tempDegree % 270 !== 0) || tempDegree === 0) {
                    startY = canvasDraw.canvas.width - (actObj.activePoint.startX + actObj.activePoint.width);
                    startY += ((actObj.activePoint.width - imgPoint.height) / 2);
                    startX = imgPoint.startY;
                }
                else if (tempDegree % 270 === 0) {
                    startX = canvasDraw.canvas.height - (actObj.activePoint.startY + actObj.activePoint.height);
                    startX += ((actObj.activePoint.height - imgPoint.width) / 2);
                    startY = imgPoint.startX;
                }
                imgPoint.startX = startX;
                imgPoint.startY = startY;
                actObj.activePoint.startX = startX;
                actObj.activePoint.startY = startY;
                actObj.activePoint.endX = actObj.activePoint.startX + imgPoint.width;
                actObj.activePoint.endY = actObj.activePoint.startY + imgPoint.height;
                actObj = this.updateWidthHeight(actObj);
            }
            else {
                if (coll === 'horizontal' && degree % 90 === 0 && degree % 180 !== 0) {
                    coll = 'vertical';
                }
                else if (coll === 'vertical' && degree % 90 === 0 && degree % 180 !== 0) {
                    coll = 'horizontal';
                }
                if (coll === 'horizontal') {
                    canvasDraw.translate(canvasDraw.canvas.width, 0);
                    canvasDraw.scale(-1, 1);
                    actObj.activePoint = this.updateActPoint('horizontal', canvasDraw);
                }
                else if (coll === 'vertical') {
                    canvasDraw.translate(0, canvasDraw.canvas.height);
                    canvasDraw.scale(1, -1);
                    actObj.activePoint = this.updateActPoint('vertical', canvasDraw);
                }
                imgPoint.startX = actObj.activePoint.startX;
                imgPoint.startY = actObj.activePoint.startY;
            }
            imgPoint.startX = actObj.activePoint.startX;
            imgPoint.startY = actObj.activePoint.startY;
            startX = imgPoint.startX;
            startY = imgPoint.startY;
        }
        if (actObj.rotatedAngle !== 0) {
            parent.notify('shape', { prop: 'setPointCollForShapeRotation', onPropertyChange: false, value: { obj: actObj } });
        }
        canvasDraw.drawImage(actObj.imageCanvas, imgPoint.startX, imgPoint.startY, imgPoint.width, imgPoint.height);
        canvasDraw.restore();
        parent.activeObj = tempActiveObj;
        if (parent.transform.degree === 360 || parent.transform.degree === -360) {
            parent.transform.degree = 0;
        }
    };
    Draw.prototype.rotateText = function (canvasDraw) {
        var parent = this.parent;
        var degree;
        var actObj = parent.activeObj;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        var actPoint = parent.activeObj.activePoint;
        if (actObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - actObj.shapeDegree;
        }
        if (degree === -450) {
            degree = -90;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
        imgPoint.width = degree % 90 === 0 && degree % 180 !== 0 ? actPoint.height : actPoint.width;
        imgPoint.height = degree % 90 === 0 && degree % 180 !== 0 ? actPoint.width : actPoint.height;
        imgPoint.startX = actPoint.startX;
        imgPoint.startY = actPoint.startY;
        var startX = imgPoint.startX;
        var startY = imgPoint.startY;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var tempDegree;
        canvasDraw.save();
        for (var i = 0, len = actObj.rotateFlipColl.length; i < len; i++) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var coll = actObj.rotateFlipColl[i];
            if (typeof (coll) === 'number') {
                tempDegree = coll;
                if (tempDegree === -450) {
                    tempDegree = -90;
                }
                if (tempDegree < 0) {
                    tempDegree = 360 + tempDegree;
                }
                imgPoint.width = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actPoint.height : actPoint.width;
                imgPoint.height = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actPoint.width : actPoint.height;
                canvasDraw.translate(canvasDraw.canvas.width / 2, canvasDraw.canvas.height / 2);
                canvasDraw.rotate(Math.PI / 180 * coll);
                canvasDraw.translate(-canvasDraw.canvas.height / 2, -canvasDraw.canvas.width / 2);
                if ((tempDegree % 90 === 0 && tempDegree % 270 !== 0) || tempDegree === 0) {
                    startY = (canvasDraw.canvas.width - actPoint.endX);
                    startX = actPoint.startY;
                }
                else if (tempDegree % 270 === 0) {
                    startX = canvasDraw.canvas.height - actPoint.endY;
                    startY = actPoint.startX;
                }
                imgPoint.startX = startX;
                imgPoint.startY = startY;
                actPoint.startX = startX;
                actPoint.startY = startY;
                actPoint.endX = actPoint.startX + imgPoint.width;
                actPoint.endY = actPoint.startY + imgPoint.height;
                actObj = this.updateWidthHeight(actObj);
            }
            else {
                if (coll === 'horizontal' && degree % 90 === 0 && degree % 180 !== 0) {
                    coll = 'vertical';
                }
                else if (coll === 'vertical' && degree % 90 === 0 && degree % 180 !== 0) {
                    coll = 'horizontal';
                }
                if (coll === 'horizontal') {
                    canvasDraw.translate(canvasDraw.canvas.width, 0);
                    canvasDraw.scale(-1, 1);
                }
                else if (coll === 'vertical') {
                    canvasDraw.translate(0, canvasDraw.canvas.height);
                    canvasDraw.scale(1, -1);
                }
                actObj.activePoint = actPoint = this.updateActPoint(coll, canvasDraw);
                imgPoint.startX = actPoint.startX;
                imgPoint.startY = actPoint.startY;
            }
            imgPoint.startX = actPoint.startX;
            imgPoint.startY = actPoint.startY;
            startX = imgPoint.startX;
            startY = imgPoint.startY;
        }
        if (actObj.rotatedAngle !== 0) {
            parent.notify('shape', { prop: 'setPointCollForShapeRotation', onPropertyChange: false, value: { obj: actObj } });
        }
        startY += actObj.textSettings.fontSize * 0.4;
        this.textFlipDegree(canvasDraw, startX, startY);
        canvasDraw.restore();
        parent.activeObj = tempActiveObj;
        if (parent.transform.degree === 360 || parent.transform.degree === -360) {
            parent.transform.degree = 0;
        }
    };
    Draw.prototype.textFlipDegree = function (canvasDraw, startX, startY) {
        var parent = this.parent;
        var actObj = parent.activeObj;
        var rows = actObj.keyHistory.split('\n');
        var fontSize = actObj.textSettings.fontSize;
        var lineHeight = ((fontSize * rows.length) - (fontSize * rows.length)) / rows.length;
        var yPoint = (fontSize * 0.85) + lineHeight;
        for (var i = 0, len = rows.length; i < len; i++) {
            var text = rows[i];
            if (i > 0) {
                if (i === 1) {
                    yPoint -= (fontSize * 0.85);
                }
                yPoint += fontSize + fontSize * 0.15;
            }
            canvasDraw.strokeText(text, startX + fontSize * 0.15, startY +
                yPoint + (i > 0 ? fontSize * 0.25 : -fontSize * 0.35));
            canvasDraw.fillText(text, startX + fontSize * 0.15, startY +
                yPoint + (i > 0 ? fontSize * 0.25 : -fontSize * 0.35));
        }
    };
    Draw.prototype.clearOuterCanvas = function (context) {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var left = destLeft > 0 ? destLeft : 0;
        var top = destTop > 0 ? destTop : 0;
        context.clearRect(0, 0, left, parent.lowerCanvas.height);
        context.clearRect(destLeft + destWidth, 0, parent.lowerCanvas.width - (destLeft + destWidth), parent.lowerCanvas.height);
        context.clearRect(0, 0, parent.lowerCanvas.width, top);
        context.clearRect(0, destTop + destHeight, parent.lowerCanvas.width, parent.lowerCanvas.height - (destTop + destHeight));
        if (parent.transform.currFlipState !== '') {
            parent.img.destLeft = destLeft;
            parent.img.destTop = destTop;
        }
    };
    Draw.prototype.setDestPoints = function () {
        var maxDimension;
        var parent = this.parent;
        var _a = parent.transform, degree = _a.degree, zoomFactor = _a.zoomFactor;
        if (degree % 90 === 0 && degree % 180 !== 0) {
            var obj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: parent.img.srcHeight, height: parent.img.srcWidth, obj: obj, isImgShape: null } });
            maxDimension = obj;
            if (this.isRotateZoom) {
                maxDimension.width += (maxDimension.width * zoomFactor);
                maxDimension.height += (maxDimension.height * zoomFactor);
                parent.img.destWidth = maxDimension.height;
                parent.img.destHeight = maxDimension.width;
            }
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.height) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.width) / 2;
            parent.img.destWidth = maxDimension.height;
            parent.img.destHeight = maxDimension.width;
        }
        else {
            var obj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj: obj, isImgShape: null } });
            maxDimension = obj;
            if (this.isRotateZoom) {
                maxDimension.width += (maxDimension.width * zoomFactor);
                maxDimension.height += (maxDimension.height * zoomFactor);
                parent.img.destWidth = maxDimension.width;
                parent.img.destHeight = maxDimension.height;
            }
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
            if (degree === 0) {
                parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
            }
            else {
                parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
            }
            parent.img.destWidth = maxDimension.width;
            parent.img.destHeight = maxDimension.height;
        }
    };
    Draw.prototype.updateCurrTransState = function (type, isPreventDestination, isRotatePan, isStraighten) {
        var parent = this.parent;
        var destLeft = parent.img.destLeft;
        var destTop = parent.img.destTop;
        if (type === 'initial') {
            this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
            if (isNullOrUndefined(isPreventDestination)) {
                this.setDestPoints();
            }
        }
        if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
            this.currTransState(type, true, null, isRotatePan);
            if (parent.transform.degree === 0 && parent.transform.currFlipState === '' && parent.transform.straighten === 0 &&
                isNullOrUndefined(isStraighten)) {
                parent.img.destLeft = destLeft;
                parent.img.destTop = destTop;
            }
            if (isRotatePan) {
                parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
                parent.img.destTop +=
                    parent.panPoint.totalPannedClientPoint.y;
            }
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
            if (isRotatePan) {
                parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
                parent.img.destTop -=
                    parent.panPoint.totalPannedClientPoint.y;
            }
        }
        else {
            this.currTransState(type, null, null, isRotatePan);
            if (parent.transform.degree === 0 && parent.transform.currFlipState === '' && parent.transform.straighten === 0 &&
                isNullOrUndefined(isStraighten)) {
                parent.img.destLeft = destLeft;
                parent.img.destTop = destTop;
            }
        }
    };
    Draw.prototype.currTransState = function (type, isPreventDimension, context, isPreventCircleCrop) {
        var parent = this.parent;
        context = context ? context : this.lowerContext;
        if (type === 'initial') {
            this.setTransformColl(context, type);
        }
        else if (type === 'reverse') {
            this.setTransformColl(context, type);
            this.setClientTransDim(isPreventDimension);
            if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle'
                && isNullOrUndefined(isPreventCircleCrop))) {
                if (isPreventCircleCrop) {
                    parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
                    parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
                }
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
                if (isPreventCircleCrop) {
                    parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
                    parent.img.destTop -= parent.panPoint.totalPannedClientPoint.y;
                }
            }
        }
    };
    Draw.prototype.setTransformColl = function (context, type) {
        var parent = this.parent;
        if (type === 'initial') {
            for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
                this.setTransform(context, parent.rotateFlipColl[i]);
            }
        }
        else if (type === 'reverse') {
            for (var i = parent.rotateFlipColl.length - 1; i >= 0; i--) {
                this.setTransform(context, parent.rotateFlipColl[i], true);
            }
        }
    };
    Draw.prototype.setTransform = function (context, value, isReverse) {
        var parent = this.parent;
        if (isReverse && value === 90) {
            value = -90;
        }
        else if (isReverse && value === -90) {
            value = 90;
        }
        if (value === 'horizontal' && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            value = 'vertical';
        }
        else if (value === 'vertical' && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            value = 'horizontal';
        }
        parent.notify('transform', { prop: 'setReverseRotate', onPropertyChange: false, value: { bool: true } });
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: true } });
        if (isNullOrUndefined(isReverse)) {
            context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        }
        switch (value) {
            case 90:
            case -90:
                context.translate(context.canvas.width / 2, context.canvas.height / 2);
                context.rotate(Math.PI / 180 * value);
                context.translate(-context.canvas.width / 2, -context.canvas.height / 2);
                break;
            case 'horizontal':
                context.translate(context.canvas.width, 0);
                context.scale(-1, 1);
                break;
            case 'vertical':
                context.translate(0, context.canvas.height);
                context.scale(1, -1);
                break;
        }
        parent.notify('transform', { prop: 'setReverseRotate', onPropertyChange: false, value: { bool: false } });
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: false } });
    };
    Draw.prototype.drawImgToCanvas = function (maxDimension) {
        var parent = this.parent;
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.img.destWidth = maxDimension.width;
        parent.img.destHeight = maxDimension.height;
        if (this.isInitialLoading) {
            parent.notify('filter', { prop: 'initFilter', onPropertyChange: false });
            this.isInitialLoading = false;
        }
        var temp = this.lowerContext.filter;
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.drawImage();
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        this.lowerContext.filter = temp;
    };
    Draw.prototype.renderImage = function (isMouseWheel, isPreventClearRect, isFrame, isStraighten) {
        var parent = this.parent;
        parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
        if (isNullOrUndefined(isPreventClearRect)) {
            this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        }
        if (isMouseWheel) {
            this.setTransformColl(this.lowerContext, 'initial');
        }
        else {
            if (parent.transform.zoomFactor !== 0) {
                this.isRotateZoom = true;
            }
            this.updateCurrTransState('initial', null, null, isStraighten);
        }
        parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        this.drawImage();
        parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        if (isMouseWheel) {
            this.setTransformColl(this.lowerContext, 'reverse');
        }
        else {
            this.updateCurrTransState('reverse', null, null, isStraighten);
            this.isRotateZoom = false;
        }
        if (isFrame) {
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        }
        else {
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
        }
        this.clearOuterCanvas(this.lowerContext);
        if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
    };
    Draw.prototype.imageOnLoad = function (src) {
        var _this = this;
        var parent = this.parent;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        parent.baseImg.src = src;
        parent.baseImg.onload = function () {
            parent.imgSrc = src;
            if (!parent.isUndoRedo) {
                parent.notify('filter', { prop: 'update-finetunes', onPropertyChange: false });
            }
            proxy.lowerContext.drawImage(parent.baseImg, 0, 0, proxy.parent.lowerCanvas.width, proxy.parent.lowerCanvas.height);
            var isCropped = false;
            var isSameDimension = false;
            if (parent.isImageUpdated) {
                var _a = parent.img, srcWidth = _a.srcWidth, srcHeight = _a.srcHeight;
                var _b = parent.baseImgCanvas, width = _b.width, height = _b.height;
                isCropped = srcWidth !== width || srcHeight !== height;
                isSameDimension = parent.baseImg.width === width && parent.baseImg.height === height;
            }
            hideSpinner(parent.element);
            parent.element.style.opacity = '1';
            proxy.updateBaseImgCanvas();
            var fileOpened = { fileName: _this.fileName, fileType: _this.fileType, isValidImage: true };
            proxy.updateCanvas(isCropped, isSameDimension);
            if (parent.currObjType.isUndoZoom) {
                parent.currObjType.isUndoZoom = false;
                proxy.parent.lowerCanvas.style.display = 'block';
            }
            parent.isUndoRedo = _this.isErrorImage = false;
            if (Browser.isDevice) {
                parent.notify('toolbar', { prop: 'destroy-top-toolbar', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'destroy-bottom-toolbar', onPropertyChange: false });
                var eventargs = { isApplyBtn: false, isDevice: Browser.isDevice, isOkBtn: null,
                    isResize: null, isFrame: null, isMainToolbar: true };
                parent.notify('toolbar', { prop: 'init-main-toolbar', onPropertyChange: false, value: eventargs });
                parent.notify('toolbar', { prop: 'create-bottom-toolbar', onPropertyChange: false });
            }
            else {
                parent.notify('toolbar', { prop: 'destroy-top-toolbar', onPropertyChange: false });
                var eventargs = { isApplyBtn: false, isDevice: false, isOkBtn: null };
                parent.notify('toolbar', { prop: 'init-main-toolbar', onPropertyChange: false, value: eventargs });
            }
            if (parent.isImageLoaded && parent.element.style.opacity !== '0.5') {
                parent.trigger('fileOpened', fileOpened);
                var action = { action: 'file-open', actionEventArgs: fileOpened };
                parent.triggerEditCompleteEvent(action);
            }
        };
        parent.baseImg.onerror = function () {
            hideSpinner(parent.element);
            proxy.isErrorImage = true;
            proxy.errorLoading();
        };
    };
    Draw.prototype.errorLoading = function () {
        var parent = this.parent;
        var fileOpened = { fileName: null, fileType: null, isValidImage: false };
        parent.trigger('fileOpened', fileOpened);
    };
    Draw.prototype.updateBaseImgCanvas = function () {
        var parent = this.parent;
        parent.baseImgCanvas.width = parent.baseImg.width;
        parent.baseImgCanvas.height = parent.baseImg.height;
        parent.baseImgCanvas.getContext('2d').drawImage(parent.baseImg, 0, 0);
    };
    Draw.prototype.updateCanvas = function (isCropped, isSameDimension) {
        var parent = this.parent;
        if (!parent.isImageUpdated || !isCropped) {
            parent.img.srcWidth = parent.baseImgCanvas.width;
            parent.img.srcHeight = parent.baseImgCanvas.height;
        }
        else if (!isSameDimension && isCropped) {
            parent.img.srcLeft = 0;
            parent.img.srcTop = 0;
            parent.img.srcWidth = parent.baseImgCanvas.width;
            parent.img.srcHeight = parent.baseImgCanvas.height;
            parent.currSelectionPoint = null;
            parent.cropObj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
                totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {}, rotateFlipColl: [],
                degree: 0, currFlipState: '', straighten: 0, destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
                srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: false,
                zoomFactor: 0, previousZoomValue: 0, aspectWidth: null, aspectHeight: null, frame: 'none', straightenZoom: 0,
                adjustmentLevel: { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
                    exposure: 0, transparency: 100, sharpen: false, bw: false }, currentFilter: '' };
        }
        var obj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj: obj, isImgShape: null } });
        var maxDimension = obj;
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
        this.drawImgToCanvas(maxDimension);
        this.origDim.width = parent.img.destWidth;
        this.origDim.height = parent.img.destHeight;
        this.zoomCrop.width = parent.img.destWidth;
        this.zoomCrop.height = parent.img.destHeight;
        parent.notify('transform', { prop: 'setCropDimension', onPropertyChange: false,
            value: { width: parent.img.destWidth, height: parent.img.destHeight } });
        var point = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
            height: parent.img.destHeight };
        parent.notify('crop', { prop: 'setCropDestPoints', onPropertyChange: false, value: { point: point } });
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'iterate', pen: 'zoom', isPreventApply: null } });
        this.lowerContext.filter = temp;
        if (parent.img.destWidth > 0 && parent.img.destHeight > 0) {
            parent.isImageLoaded = true;
        }
        if (parent.isUndoRedo) {
            if (parent.transform.currFlipState !== '') {
                parent.notify('transform', { prop: 'flipImage', onPropertyChange: false,
                    value: { direction: parent.toPascalCase(parent.transform.currFlipState) } });
            }
        }
        if (parent.disabled) {
            parent.element.setAttribute('class', 'e-disabled');
        }
        if (parent.zoomSettings.zoomFactor !== 1 || parent.zoomSettings.zoomPoint) {
            parent.zoom(parent.zoomSettings.zoomFactor, parent.zoomSettings.zoomPoint);
        }
        if (isNullOrUndefined(this.initZoomValue)) {
            this.initZoomValue = parent.zoomSettings.zoomFactor;
        }
        this.isImageEdited = false;
    };
    Draw.prototype.resetFrameZoom = function (isOk) {
        var parent = this.parent;
        if (!isNullOrUndefined(parent.tempFrameZoomLevel)) {
            var temp = parent.tempFrameZoomLevel;
            parent.tempFrameZoomLevel = null;
            parent.notify('transform', { prop: 'resetZoom', onPropertyChange: false });
            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: temp, zoomPoint: null, isResize: true } });
            var obj = parent.cancelCropSelection;
            if (isOk && obj) {
                obj.previousObj.frameObj = extend({}, parent.frameObj, null, true);
                obj.currentObj.frameObj = extend({}, parent.frameObj, null, true);
                obj.previousObj.frame = obj.currentObj.frame = parent.frameObj.type;
            }
            this.updateCropSelObj();
            parent.cancelCropSelection = null;
        }
    };
    Draw.prototype.performCancel = function (isContextualToolbar, isUndoRedo, isFinalCancel) {
        var parent = this.parent;
        if (isFinalCancel) {
            parent.noPushUndo = false;
        }
        var straightenObj = { bool: parent.isStraightening };
        isContextualToolbar = isContextualToolbar ? isContextualToolbar : false;
        var obj = { bool: false };
        parent.allowDownScale = true;
        parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (isNullOrUndefined(isUndoRedo) && JSON.stringify(parent.frameObj) !== JSON.stringify(parent.tempFrameObj)) {
            extend(parent.frameObj, parent.tempFrameObj);
            this.renderImage(null, null, true);
        }
        this.resetFrameZoom(false);
        var editCompleteArgs = { action: '' };
        if (obj['bool']) {
            editCompleteArgs['action'] = 'freehand-draw';
            parent.notify('freehand-draw', { prop: 'cancelFhd', onPropertyChange: false });
            parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
        else if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
            editCompleteArgs['action'] = 'text-editing';
            parent.textArea.style.display = 'none';
            parent.textArea.value = '';
            parent.textArea.style.transform = '';
            if (this.prevActObj) {
                parent.activeObj = this.prevActObj;
                this.prevActObj = null;
            }
            else {
                parent.activeObj.strokeSettings = this.tempStrokeSettings;
                parent.activeObj.textSettings = this.tempTextSettings;
            }
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
            if (this.isShapeTextInserted) {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            }
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            parent.notify('selection', { prop: 'setTempActObj', onPropertyChange: false, value: { obj: parent.activeObj } });
            if (parent.drawingShape) {
                parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
            }
        }
        else if ((!parent.activeObj.shape || parent.activeObj.shape !== 'redact') && (((!Browser.isDevice || (Browser.isDevice && !straightenObj['bool'])) &&
            document.querySelector('#' + parent.element.id + '_sliderWrapper')) || parent.currObjType.isFiltered)) {
            editCompleteArgs['action'] = parent.isFinetuneBtnClick ? 'fine-tune' : 'filter';
            this.lowerContext.filter = this.tempAdjValue;
            parent.canvasFilter = this.tempAdjValue;
            parent.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.tempAdjValue } });
            parent.initialAdjustmentValue = this.tempAdjValue;
            if (this.lowerContext.filter.split(' ').length > 1 &&
                this.lowerContext.filter.split(' ')[0].split('(')[1].split(')')[0] === '1') {
                parent.notify('filter', { prop: 'setBrightnessAdjusted', onPropertyChange: false, value: { isBrightnessAdjusted: false } });
            }
            parent.currentFilter = this.tempFilter;
            parent.notify('filter', { prop: 'setBevelFilter', onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.redrawImgWithObj();
            parent.currObjType.isFiltered = false;
            var obj_3 = { tempAdjustmentLevel: null };
            parent.notify('filter', { prop: 'getTempAdjustmentLevel', onPropertyChange: false, value: { obj: obj_3 } });
            parent.notify('filter', { prop: 'setAdjustmentLevel', onPropertyChange: false,
                value: { adjustmentLevel: extend({}, obj_3['tempAdjustmentLevel'], {}, true) } });
            parent.notify('undo-redo', { prop: 'setUndoRedoStep', onPropertyChange: false, value: { step: this.tempUndoRedoStep } });
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            parent.currObjType.isCustomCrop = false;
            this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, radius: null, outlineColor: '', outlineWidth: null };
            this.clearOuterCanvas(this.lowerContext);
            if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            var eventargs = { type: 'main', isApplyBtn: null, isCropping: null, isZooming: null };
            parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
            if (parent.activeObj.shape && parent.activeObj.shape === 'image') {
                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
            }
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (parent.drawingShape) {
                parent.drawingShape = null;
                parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
            }
        }
        else {
            if ((!parent.activeObj.shape || parent.activeObj.shape !== 'redact') && isContextualToolbar && (!Browser.isDevice || (Browser.isDevice && !straightenObj['bool']))) {
                var eventargs = { type: 'main', isApplyBtn: null, isCropping: null, isZooming: null };
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
            }
            else {
                this.cancelItems(editCompleteArgs);
                if (parent.transform.zoomFactor > 0) {
                    parent.togglePan = true;
                    parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
                }
                else {
                    parent.togglePan = false;
                    parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
                }
            }
        }
        this.isShapeTextInserted = false;
        this.isNewPath = false;
        parent.notify('toolbar', { prop: 'refresh-dropdown-btn', value: { isDisabled: false } });
        parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });
        if (isFinalCancel) {
            parent.noPushUndo = false;
        }
        parent.drawingShape = null;
        parent.notify('draw', { prop: 'resetTempObjColl' });
        parent.notify('draw', { prop: 'resetTempPointColl' });
        parent.isMaskImage = parent.isFinetuneBtnClick = false;
        var actionArgs = { action: 'cancel', actionEventArgs: editCompleteArgs };
        parent.triggerEditCompleteEvent(actionArgs);
    };
    Draw.prototype.cancelItems = function (editCompleteArgs) {
        var parent = this.parent;
        var isCropSelection = false;
        var id = parent.element.id;
        var ascpectIcon = parent.element.querySelector('#' + id + '_aspectratio');
        var nonAspectIcon = parent.element.querySelector('#' + id + '_nonaspectratio');
        var splitWords;
        var shapes = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'image', 'redact'];
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords === undefined && parent.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (isCropSelection && parent.isCropTab) {
            parent.isCropTab = false;
            parent.transform.zoomFactor = parent.transform.defaultZoomFactor;
        }
        if (parent.isResize) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            if (ascpectIcon || nonAspectIcon || parent.currentToolbar === 'resize-toolbar') {
                editCompleteArgs['action'] = 'resize';
                var obj = { width: null, height: null };
                parent.notify('selection', { prop: 'getNumTextValue', onPropertyChange: false, value: { obj: obj } });
                var point = { x: obj['width'], y: obj['height'] };
                var aspectRatioElement = parent.element.querySelector('#' + parent.element.id + '_aspectratio');
                var blrAspRatElem = parent.element.querySelector('.e-ie-toolbar-aspect-ratio-btn');
                if (point && point.x && point.y && !isNullOrUndefined(parent.aspectWidth)) {
                    if (aspectRatioElement || (blrAspRatElem && !blrAspRatElem.classList.contains('e-hidden'))) {
                        parent.notify('transform', { prop: 'resizeImage', value: { width: parent.aspectWidth, height: parent.aspectHeight } });
                    }
                    else {
                        var bool = parent.currObjType.isUndoAction;
                        parent.currObjType.isUndoAction = false;
                        parent.notify('transform', { prop: 'resizeCrop', value: { width: parent.aspectWidth, height: parent.aspectHeight } });
                        parent.currObjType.isUndoAction = bool;
                    }
                }
                var obj1 = { prevCropObj: parent.prevCropObj };
                var obj2 = { prevObj: parent.prevObj };
                parent.notify('toolbar', { prop: 'getPrevCropObj', onPropertyChange: false, value: { obj: obj1 } });
                parent.notify('toolbar', { prop: 'getPrevObj', onPropertyChange: false, value: { obj: obj2 } });
                if (obj1['prevCropObj'] && obj2['prevObj']) {
                    parent.objColl = [];
                    parent.pointColl = [];
                    parent.freehandCounter = 0;
                    parent.cropObj = extend({}, obj1['prevCropObj'], {}, true);
                    this.setCurrentObj(obj2['prevObj']);
                    parent.objColl = obj2['prevObj']['objColl'];
                    parent.pointColl = obj2['prevObj']['pointColl'];
                    parent.freehandCounter = parent.pointColl.length;
                    parent.transform.straighten = 0;
                    parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                        value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
                    var currObj = parent.currSelectionPoint ?
                        extend({}, parent.currSelectionPoint, {}, true) : null;
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: -parent.transform.zoomFactor, zoomPoint: null, isResize: true } });
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: obj2['prevObj']['defaultZoom'], zoomPoint: null, isResize: true } });
                    parent.currSelectionPoint = currObj;
                    if (obj2['prevObj'].zoomFactor) {
                        parent.setProperties({ zoomSettings: { zoomFactor: obj2['prevObj'].zoomFactor } }, true);
                    }
                    parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
                        value: { previousZoomValue: parent.zoomSettings.zoomFactor } });
                }
                parent.isResize = false;
                parent.notify('transform', { prop: 'setResizedImgAngle', onPropertyChange: false, value: { angle: null } });
                var temp = parent.isCropTab;
                parent.isCropTab = false;
                this.updateCropSelObj();
                parent.cancelCropSelection = null;
                parent.isCropTab = temp;
            }
        }
        switch (true) {
            case parent.togglePen:
                editCompleteArgs['action'] = 'freehand-draw';
                this.cancelPen();
                break;
            case parent.activeObj.shape === 'text':
                editCompleteArgs['action'] = 'text';
                this.cancelText();
                break;
            case shapes.indexOf(parent.activeObj.shape) !== -1:
                editCompleteArgs['action'] = parent.activeObj.shape;
                this.cancelShape();
                parent.currObjType.isRedact = false;
                break;
            case isCropSelection:
                editCompleteArgs['action'] = 'crop-selection';
                this.cancelSelection();
                break;
            default:
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
                break;
        }
        parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
        parent.upperCanvas.style.cursor = parent.cursor = 'default';
        parent.currObjType.isCustomCrop = false;
        this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, radius: null, outlineColor: '', outlineWidth: null };
        var eventargs = { type: 'main', isApplyBtn: null, isCropping: false, isZooming: null };
        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
    };
    Draw.prototype.cancelPen = function () {
        var parent = this.parent;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.togglePen = false;
        parent.upperCanvas.style.cursor = parent.cursor = 'default';
        // eslint-disable-next-line
        var tempPointsColl = extend([], parent.pointColl, [], true);
        parent.pointColl = {};
        for (var i = 0; i < this.tempFreehandCounter; i++) {
            parent.pointColl[i] = tempPointsColl[i];
        }
        parent.freehandCounter = this.tempFreehandCounter;
        parent.notify('freehand-draw', { prop: 'setCurrentFreehandDrawIndex', value: { value: this.tempCurrFhdIndex } });
        parent.activeObj.strokeSettings = this.tempStrokeSettings;
        parent.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: parent.activeObj.strokeSettings, strokeColor: null,
                fillColor: null, strokeWidth: null, radius: null } });
        parent.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: this.tempStrokeWidth } });
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
        parent.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: false } });
        parent.objColl = extend([], this.tempObjColl, [], true);
        parent.pointColl = extend([], this.tempPointColl, [], true);
        parent.freehandCounter = parent.pointColl.length;
        this.tempPointColl = {};
        this.renderImage();
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok', isCancel: true } });
    };
    Draw.prototype.cancelText = function () {
        var parent = this.parent;
        parent.notify('shape', { prop: 'setTextSettings', onPropertyChange: false,
            value: { textSettings: this.tempTextSettings, fontFamily: null, fontSize: null } });
        parent.notify('shape', { prop: 'setStrokeSettings',
            value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null, radius: null } });
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        else {
            var object = { appliedUndoRedoColl: [] };
            parent.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: object } });
            var len = object['appliedUndoRedoColl'].length;
            var appliedColl = object['appliedUndoRedoColl'][len - 1];
            if (this.prevActObj && appliedColl && appliedColl.currentObjColl.length &&
                appliedColl.currentObjColl[appliedColl.currentObjColl.length - 1].currIndex === this.prevActObj.currIndex) {
                parent.activeObj = this.prevActObj;
                this.prevActObj = null;
            }
            else {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
        }
        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        this.tempTextSettings = { text: 'Enter Text', fontFamily: parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false,
            italic: false, underline: false };
        parent.objColl = extend([], this.tempObjColl, [], true);
        parent.pointColl = extend([], this.tempPointColl, [], true);
        this.renderImage();
        this.tempObjColl = [];
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok', isCancel: true } });
    };
    Draw.prototype.cancelShape = function () {
        var parent = this.parent;
        parent.notify('shape', { prop: 'setStrokeSettings',
            value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null, radius: null } });
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        else if (this.isNewPath) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.renderImage();
        }
        else {
            var object = { appliedUndoRedoColl: [] };
            parent.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: object } });
            var obj = void 0;
            for (var i = 0, iLen = object['appliedUndoRedoColl'].length; i < iLen; i++) {
                var currObjColl = object['appliedUndoRedoColl'][i].currentObjColl;
                for (var j = 0, jLen = currObjColl.length; j < jLen; j++) {
                    if (this.prevActObj && this.prevActObj.currIndex &&
                        currObjColl[j].currIndex === this.prevActObj.currIndex) {
                        obj = currObjColl[0];
                        break;
                    }
                }
            }
            if (this.prevActObj && obj) {
                parent.activeObj = this.prevActObj;
                this.prevActObj = null;
                parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false, value: { obj: parent.activeObj } });
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
                parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
            }
            else {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            var undoRedoObj = { undoRedoStep: null };
            parent.notify('undo-redo', { prop: 'getUndoRedoStep', value: { obj: undoRedoObj } });
            if (object['appliedUndoRedoColl'][(undoRedoObj['undoRedoStep'] - 1)]) {
                parent.objColl =
                    extend([], object['appliedUndoRedoColl'][(undoRedoObj['undoRedoStep'] - 1)].currentObjColl, [], true);
            }
            else {
                parent.objColl = [];
            }
            this.renderImage();
        }
        parent.currObjType.isDragging = false;
        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        parent.objColl = extend([], this.tempObjColl, [], true);
        parent.pointColl = extend([], this.tempPointColl, [], true);
        this.renderImage();
        this.tempObjColl = [];
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok', isCancel: true } });
    };
    Draw.prototype.cancelSelection = function () {
        var parent = this.parent;
        if (parent.cancelCropSelection) {
            var obj = { value: parent.tempStraighten };
            parent.transform.straighten = obj['value'];
            parent.straightenBaseImageCanvas();
            parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
            parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: parent.activeObj } });
            parent.notify('crop', { prop: 'resizeWrapper' });
            this.updateCropSelObj();
            // eslint-disable-next-line max-len
            if (this.tempStraightenDestPoints && JSON.stringify(this.tempStraightenDestPoints) !== JSON.stringify(this.straightenDestPoints)) {
                this.straightenDestPoints = extend({}, this.tempStraightenDestPoints, {}, true);
            }
        }
    };
    Draw.prototype.updateCropSelObj = function () {
        var parent = this.parent;
        if (parent.cancelCropSelection) {
            parent.cropObj = extend({}, parent.cancelCropSelection.previousCropObj, {}, true);
            parent.afterCropActions = parent.cancelCropSelection.previousObj.afterCropActions;
            parent.notify('undo-redo', { prop: 'undoDefault', onPropertyChange: false, value: { obj: parent.cancelCropSelection } });
            parent.currSelectionPoint = extend({}, parent.cancelCropSelection.previousCropObj.activeObj, true);
            if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                parent.currSelectionPoint = null;
            }
            this.clearOuterCanvas(this.lowerContext);
            if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
        }
    };
    Draw.prototype.updateCropSelection = function () {
        var parent = this.parent;
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var currentObj = object['currObj'];
        currentObj.objColl = extend([], parent.objColl, [], true);
        currentObj.pointColl = extend([], parent.pointColl, [], true);
        currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        currentObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        parent.cancelCropSelection = { operation: 'cropTransform', previousObj: currentObj, currentObj: currentObj,
            previousObjColl: currentObj.objColl, currentObjColl: currentObj.objColl,
            previousPointColl: currentObj.pointColl, currentPointColl: currentObj.pointColl,
            previousSelPointColl: currentObj.selPointColl, currentSelPointColl: currentObj.selPointColl,
            previousCropObj: extend({}, parent.cropObj, {}, true),
            currentCropObj: extend({}, parent.cropObj, {}, true),
            previousText: null, currentText: null, filter: null, isCircleCrop: parent.isCircleCrop };
    };
    Draw.prototype.updateFlipPan = function (tempSelectionObj) {
        var parent = this.parent;
        if (parent.transform.currFlipState !== '') {
            var temp = this.lowerContext.filter;
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.notify('transform', { prop: 'rotatedFlip', onPropertyChange: false });
            this.lowerContext.filter = 'none';
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
            this.lowerContext.filter = temp;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (tempSelectionObj) {
                this.drawObject('duplicate', tempSelectionObj);
            }
        }
    };
    Draw.prototype.select = function (type, startX, startY, width, height) {
        var parent = this.parent;
        type = type.toLowerCase();
        if (!parent.disabled && parent.isImageLoaded) {
            parent.allowDownScale = false;
            var object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var previousObj = object['currObj'];
            previousObj.objColl = extend([], parent.objColl, [], true);
            previousObj.pointColl = extend([], parent.pointColl, [], true);
            previousObj.afterCropActions = parent.afterCropActions;
            var selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            previousObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            parent.notify('crop', { prop: 'setPreviousCropCurrentObj', onPropertyChange: false, value: { obj: previousObj } });
            if (parent.transform.zoomFactor > 0 && parent.activeObj.shape &&
                parent.activeObj.shape.split('-')[0] === 'crop' && isNullOrUndefined(this.currSelPoint)) {
                this.currSelPoint = extend({}, parent.activeObj, {}, true);
            }
            var isPrevent = false;
            var splitWords = void 0;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords === undefined && parent.currObjType.isCustomCrop) {
                isPrevent = true;
            }
            else if (splitWords !== undefined && splitWords[0] === 'crop') {
                isPrevent = true;
            }
            var obj = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: obj } });
            var prevObj = obj['currObj'];
            prevObj.objColl = extend([], parent.objColl, [], true);
            prevObj.pointColl = extend([], parent.pointColl, [], true);
            prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.notify('shape', { prop: 'setKeyHistory', onPropertyChange: false, value: { keyHistory: '' } });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.upperCanvas.style.display = 'block';
            if (parent.currSelectionPoint || parent.transform.defaultZoomFactor !== 0 ||
                (parent.transform.degree !== 0 && parent.panPoint.totalPannedInternalPoint.x !== 0 &&
                    parent.panPoint.totalPannedInternalPoint.y !== 0 && !isPrevent)) {
                parent.isCircleCrop = false;
                if (parent.transform.defaultZoomFactor !== 0 && !this.isResizeSelect) {
                    var isCropTab = parent.isCropTab;
                    parent.isCropTab = false;
                    parent.notify('transform', { prop: 'resetZoom', onPropertyChange: false });
                    parent.isCropTab = isCropTab;
                    this.resetPanPoints();
                }
                parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
                parent.isCropTab = true;
                parent.isCircleCrop = false;
                if (!this.isResizeSelect) {
                    parent.notify('crop', { prop: 'setCurrSelPoints', onPropertyChange: false, value: { isSetDimension: true } });
                }
                parent.transform.zoomFactor = parent.transform.cropZoomFactor;
                if (isNullOrUndefined(parent.cropObj.activeObj.shape)) {
                    parent.currObjType.shape = 'crop-' + type;
                    this.drawNewSelection(type, startX, startY, width, height);
                }
            }
            else {
                if (!this.isCropSelect) {
                    parent.notify('crop', { prop: 'adjustStraightenForShapes', onPropertyChange: false,
                        value: { type: 'reverse', isInitialRotated: true } });
                    parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
                    this.renderImage();
                }
                else {
                    this.isCropSelect = false;
                }
                if (type === 'custom') {
                    parent.currObjType.shape = '';
                }
                this.drawNewSelection(type, startX, startY, width, height);
            }
        }
    };
    Draw.prototype.drawNewSelection = function (type, startX, startY, width, height) {
        var parent = this.parent;
        var points;
        var cropShape = 'crop-' + type.toLowerCase();
        if (cropShape === 'crop-custom') {
            if (parent.currObjType.shape === '' || parent.currObjType.shape === 'crop-custom') {
                this.drawCustomSelection('crop-custom', startX, startY, width, height);
                this.adjToStraighten();
                this.updateSelectionInsert();
                if (parent.isStraightening) {
                    this.straightenActObj = extend({}, parent.activeObj, {}, true);
                    this.straightenInitZoom = parent.transform.zoomFactor;
                }
            }
        }
        else if (cropShape === 'crop-canvas') {
            parent.upperCanvas.style.display = 'block';
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
        }
        else {
            parent.currObjType.isCustomCrop = false;
            parent.currObjType.shape = cropShape;
            if (width && height) {
                points = { startX: startX, startY: startY, endX: startX + width, endY: startY + height,
                    width: width, height: height };
            }
            else if (width && cropShape === 'crop-circle') {
                points = { startX: startX, startY: startY, endX: startX + width, endY: startY + width,
                    width: width, height: width };
            }
            parent.activeObj.shape = cropShape;
            this.updateSelectionInsert(points);
        }
    };
    Draw.prototype.updateSelectionInsert = function (points) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var obj = { shapeSettingsObj: {} };
        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
        var selectionSettings = { type: parent.getSelectionType(obj['shapeSettingsObj']['type']), startX: obj['shapeSettingsObj']['startX'],
            startY: obj['shapeSettingsObj']['startY'], width: obj['shapeSettingsObj']['width'], height: obj['shapeSettingsObj']['height'] };
        var selectionChangingArgs = { action: 'insert', previousSelectionSettings: selectionSettings,
            currentSelectionSettings: selectionSettings };
        parent.trigger('selectionChanging', selectionChangingArgs);
        parent.editCompleteArgs = selectionChangingArgs;
        parent.notify('shape', { prop: 'updSelChangeEventArgs', onPropertyChange: false,
            value: { selectionSettings: selectionChangingArgs.currentSelectionSettings } });
        if (selectionChangingArgs.currentSelectionSettings.type === 'Custom') {
            this.drawObject('duplicate', parent.activeObj, null, null, true);
        }
        else {
            if (actPoint.startX !== 0 || actPoint.startY !== 0 ||
                actPoint.width !== 0 || actPoint.height !== 0) {
                points = { startX: actPoint.startX, startY: actPoint.startY,
                    endX: actPoint.endX, endY: actPoint.endY,
                    width: actPoint.width, height: actPoint.height };
            }
            this.drawObject('duplicate', null, true, points);
        }
    };
    Draw.prototype.drawCustomSelection = function (cropShape, startX, startY, width, height) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        parent.currObjType.isCustomCrop = true;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.currObjType.shape = parent.activeObj.shape = cropShape.toLowerCase();
        if (!isNullOrUndefined(startX) && !isNullOrUndefined(startY) && !isNullOrUndefined(width) && !isNullOrUndefined(height)) {
            actPoint.startX = startX;
            actPoint.startY = startY;
            actPoint.endX = startX + width;
            actPoint.endY = startY + height;
            actPoint.width = width;
            actPoint.height = height;
        }
        else if (width && height) {
            var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
            actPoint.width = width;
            actPoint.height = height;
            actPoint.startX = destLeft + ((destWidth / 2) - (width / 2));
            actPoint.startY = destTop + ((destHeight / 2) - (height / 2));
        }
        else {
            if (isNullOrUndefined(parent.transform.zoomFactor) || parent.transform.zoomFactor === 0) {
                var _b = parent.img, destLeft_1 = _b.destLeft, destTop_1 = _b.destTop, destWidth_1 = _b.destWidth, destHeight_1 = _b.destHeight;
                var lowerCanvasWidth_1 = parent.lowerCanvas.width;
                var lowerCanvasHeight_1 = parent.lowerCanvas.height;
                var activePoint_1 = actPoint;
                if (destLeft_1 >= 0 && destTop_1 >= 0) {
                    activePoint_1.startX = destLeft_1;
                    activePoint_1.startY = destTop_1;
                    activePoint_1.endX = destLeft_1 + destWidth_1;
                    activePoint_1.endY = destTop_1 + destHeight_1;
                }
                else if (destLeft_1 >= 0) {
                    activePoint_1.startX = destLeft_1;
                    activePoint_1.startY = 7.5;
                    activePoint_1.endX = destLeft_1 + destWidth_1;
                    activePoint_1.endY = lowerCanvasHeight_1 - 15;
                }
                else if (destTop_1 >= 0) {
                    activePoint_1.startX = 7.5;
                    activePoint_1.startY = destTop_1;
                    activePoint_1.endX = lowerCanvasWidth_1 - 15;
                    activePoint_1.endY = destTop_1 + destHeight_1;
                }
                else {
                    activePoint_1.startX = 7.5;
                    activePoint_1.startY = 7.5;
                    activePoint_1.endX = lowerCanvasWidth_1 - 15;
                    activePoint_1.endY = lowerCanvasHeight_1 - 15;
                }
            }
            else {
                var _c = parent.img, destLeft_2 = _c.destLeft, destTop_2 = _c.destTop, destWidth_2 = _c.destWidth, destHeight_2 = _c.destHeight;
                var lowerCanvasWidth_2 = parent.lowerCanvas.width;
                var lowerCanvasHeight_2 = parent.lowerCanvas.height;
                var activePoint_2 = actPoint;
                activePoint_2.startX = Math.max(destLeft_2 > 0 ? destLeft_2 : 7.5, destLeft_2);
                activePoint_2.startY = Math.max(destTop_2 > 0 ? destTop_2 : 7.5, destTop_2);
                activePoint_2.endX = Math.min(destLeft_2 + destWidth_2 + 15 < lowerCanvasWidth_2 ? destLeft_2 + destWidth_2 - 15 :
                    lowerCanvasWidth_2 - 15, destLeft_2 + destWidth_2);
                activePoint_2.endY = Math.min(destTop_2 + destHeight_2 + 15 < lowerCanvasHeight_2 ? destTop_2 + destHeight_2 - 15 :
                    lowerCanvasHeight_2 - 15, destTop_2 + destHeight_2);
            }
            var _d = parent.img, destLeft = _d.destLeft, destTop = _d.destTop, destWidth = _d.destWidth, destHeight = _d.destHeight;
            var lowerCanvasWidth = parent.lowerCanvas.clientWidth;
            var lowerCanvasHeight = parent.lowerCanvas.clientHeight;
            var activePoint = actPoint;
            activePoint.startX = Math.max(activePoint.startX, destLeft);
            activePoint.startY = Math.max(activePoint.startY, destTop);
            activePoint.endX = Math.min(activePoint.endX, destLeft + destWidth);
            activePoint.endY = Math.min(activePoint.endY, destTop + destHeight);
            if (parent.transform.straighten > 0) {
                if (this.imgCanvasPoints[0].x > activePoint.startX) {
                    activePoint.startX = this.imgCanvasPoints[0].x;
                }
                if (this.imgCanvasPoints[0].y > activePoint.startY) {
                    activePoint.startY = this.imgCanvasPoints[0].y;
                }
                if (this.imgCanvasPoints[2].x < activePoint.endX) {
                    activePoint.endX = this.imgCanvasPoints[2].x;
                }
                if (this.imgCanvasPoints[2].y < activePoint.endY) {
                    activePoint.endY = this.imgCanvasPoints[2].x;
                }
            }
            else if (parent.transform.straighten < 0) {
                if (this.imgCanvasPoints[3].x > activePoint.startX) {
                    activePoint.startX = this.imgCanvasPoints[3].x;
                }
                if (this.imgCanvasPoints[3].y < activePoint.startY) {
                    activePoint.startY = this.imgCanvasPoints[3].y;
                }
                if (this.imgCanvasPoints[1].x < activePoint.endX) {
                    activePoint.endX = this.imgCanvasPoints[1].x;
                }
                if (this.imgCanvasPoints[1].y > activePoint.endY) {
                    activePoint.endY = this.imgCanvasPoints[1].x;
                }
            }
            if (activePoint.startX === destLeft && destLeft + destWidth > lowerCanvasWidth) {
                activePoint.endX = lowerCanvasWidth - 15;
            }
            if (activePoint.startY === destTop && destTop + destHeight > lowerCanvasHeight) {
                activePoint.endY = lowerCanvasHeight - 15;
            }
            if (parent.activeObj.activePoint.startX > parent.activeObj.activePoint.endX) {
                var temp = parent.activeObj.activePoint.startX;
                parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX;
                parent.activeObj.activePoint.endX = temp;
            }
            if (parent.activeObj.activePoint.startY > parent.activeObj.activePoint.endY) {
                var temp = parent.activeObj.activePoint.startY;
                parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY;
                parent.activeObj.activePoint.endY = temp;
            }
            parent.activeObj = this.updateWidthHeight(parent.activeObj);
            this.updateActiveObject(actPoint, parent.activeObj);
            this.adjActObj();
        }
        this.updateSelectionInsert();
    };
    Draw.prototype.adjToStraighten = function () {
        var parent = this.parent;
        if (parent.transform.straighten !== 0 && parent.isStraightening) {
            var actPoint = parent.activeObj.activePoint;
            actPoint.startX += 7.5;
            actPoint.startY += 7.5;
            actPoint.endX -= 7.5;
            actPoint.endY -= 7.5;
            parent.activeObj = this.updateWidthHeight(parent.activeObj);
        }
    };
    Draw.prototype.adjActObj = function () {
        var parent = this.parent;
        if (parent.transform.straighten === 0) {
            return;
        }
        var actPoint = parent.activeObj.activePoint;
        var tempActPoint = extend({}, actPoint, {}, true);
        var count = 0;
        while (true) {
            count++;
            var object = { isIntersect: null, arr: null };
            parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
            parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: object } });
            if (object['arr'][0] || object['arr'][1] || object['arr'][2] || object['arr'][3] || count === 100) {
                actPoint = extend({}, tempActPoint, {}, true);
                break;
            }
            tempActPoint = extend({}, actPoint, {}, true);
            actPoint.startX -= 5;
            actPoint.endX += 5;
            actPoint.width = actPoint.endX - actPoint.startX;
            this.updateActiveObject(actPoint, parent.activeObj);
        }
    };
    Draw.prototype.callUpdateCurrTransState = function () {
        var parent = this.parent;
        var tempObjColl = extend([], parent.objColl, [], true);
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.isRotateZoom = true;
        this.updateCurrTransState('initial');
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
            parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        var temp = this.lowerContext.filter;
        if (parent.transform.degree === 0) {
            parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        }
        this.drawImage();
        this.updateCurrTransState('reverse');
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
            parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        this.isRotateZoom = false;
        parent.objColl = tempObjColl;
        var tempTogglePen = parent.togglePen;
        parent.togglePen = false;
        this.lowerContext.filter = 'none';
        var widthObj = { penStrokeWidth: null };
        parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: widthObj } });
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
        parent.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: widthObj['penStrokeWidth'] } });
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        parent.img.destLeft -= parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop -= parent.panPoint.totalPannedInternalPoint.y;
        parent.togglePen = tempTogglePen;
        this.lowerContext.filter = temp;
        parent.activeObj = tempActiveObj;
    };
    Draw.prototype.resetPanPoints = function () {
        this.parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
        this.parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
        this.parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
    };
    Draw.prototype.setClientTransDim = function (isPreventDimension) {
        var parent = this.parent;
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - parent.img.destHeight) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - parent.img.destWidth + 1) / 2;
            var temp = parent.img.destWidth;
            parent.img.destWidth = parent.img.destHeight;
            parent.img.destHeight = temp;
        }
        else {
            if (isNullOrUndefined(isPreventDimension)) {
                parent.img.destLeft = (parent.lowerCanvas.clientWidth - parent.img.destWidth) / 2;
                parent.img.destTop = (parent.lowerCanvas.clientHeight - parent.img.destHeight + 1) / 2;
            }
        }
    };
    Draw.prototype.redrawImgWithObj = function () {
        var parent = this.parent;
        var obj = { canvasFilter: parent.canvasFilter };
        this.lowerContext.filter = obj['canvasFilter'];
        if (parent.rotateFlipColl.length !== 0) {
            var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
            var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            this.callUpdateCurrTransState();
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
        }
        else {
            this.callUpdateCurrTransState();
        }
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
    };
    Draw.prototype.setCurrentObj = function (obj, isUndoRedo, isCircleCropped) {
        var parent = this.parent;
        var isObj = obj ? true : false;
        if (!isObj) {
            parent.cropObj.aspectWidth = parent.aspectWidth;
            parent.cropObj.aspectHeight = parent.aspectHeight;
            parent.cropObj.frame = parent.frameObj.type;
        }
        obj = obj ? obj : parent.cropObj;
        parent.transform.cropZoomFactor = obj.cropZoom;
        parent.transform.defaultZoomFactor = obj.defaultZoom;
        this.straightenInitZoom = obj.straightenZoom;
        if (!isObj) {
            parent.transform.zoomFactor = obj.cropZoom;
        }
        else {
            if (obj.activeObj.shape && obj.activeObj.shape.split('-')[0] === 'crop') {
                parent.transform.zoomFactor = obj.cropZoom;
            }
            else {
                parent.transform.zoomFactor = obj.defaultZoom;
            }
        }
        parent.setProperties({ zoomSettings: { zoomFactor: obj.zoomFactor } }, true);
        parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false, value: { previousZoomValue: obj.previousZoomValue } });
        parent.panPoint.totalPannedPoint = extend({}, obj.totalPannedPoint, {}, true);
        parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
        parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
        var point = extend({}, obj.tempFlipPanPoint, {}, true);
        parent.notify('crop', { prop: 'setTempFlipPanPoint', onPropertyChange: false, value: { point: point } });
        parent.rotateFlipColl = extend([], obj.rotateFlipColl, [], true);
        parent.transform.degree = obj.degree;
        parent.frameObj.type = obj.frame;
        parent.transform.currFlipState = obj.currFlipState;
        parent.notify('filter', { prop: 'setAdjustmentLevel', onPropertyChange: false, value: { adjustmentLevel: obj.adjustmentLevel } });
        parent.notify('filter', { prop: 'setTempAdjVal' });
        parent.currentFilter = obj.currentFilter;
        parent.notify('filter', { prop: 'setTempFilVal' });
        if (parent.transform.straighten !== obj.straighten || isUndoRedo) {
            parent.transform.straighten = obj.straighten;
            parent.straightenBaseImageCanvas();
        }
        parent.img = { destLeft: obj.destPoints.startX, destTop: obj.destPoints.startY, destWidth: obj.destPoints.width,
            destHeight: obj.destPoints.height, srcLeft: obj.srcPoints.startX, srcTop: obj.srcPoints.startY,
            srcWidth: obj.srcPoints.width, srcHeight: obj.srcPoints.height };
        parent.aspectWidth = obj.aspectWidth;
        parent.aspectHeight = obj.aspectHeight;
        if (obj.afterCropActions) {
            parent.afterCropActions = obj.afterCropActions;
        }
        this.lowerContext.filter = obj.filter;
        parent.notify('filter', { prop: 'setBrightnessAdjusted', onPropertyChange: false, value: { isBrightnessAdjusted: obj.isBrightAdjust } });
        parent.notify('draw', { prop: 'imageBackgroundColor', onPropertyChange: false, value: { color: obj.bgColor } });
        var isCircleCrop = parent.isCircleCrop;
        var currSelectionPoint;
        if (isNullOrUndefined(parent.currSelectionPoint)) {
            currSelectionPoint = null;
        }
        else {
            currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
            parent.currSelectionPoint = null;
        }
        parent.isCircleCrop = false;
        if (isCircleCropped) {
            parent.frameObj.type = 'none';
        }
        this.drawCropSelectionImage(obj, false);
        if (parent.transform.degree !== 0) {
            if (parent.transform.currFlipState === '') {
                parent.notify('transform', { prop: 'rotatePan', onPropertyChange: false,
                    value: { isCropSelection: null, isDefaultZoom: null } });
            }
            else {
                parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: 0, yDiff: 0 } });
            }
            parent.img.destLeft = obj.destPoints.startX;
            parent.img.destTop = obj.destPoints.startY;
            parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
            parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
        }
        parent.activeObj = extend({}, obj.activeObj, {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
            this.drawObject('duplicate', null, null, null, true);
        }
        var activeObj = extend({}, obj.activeObj, {}, true);
        var isAfterCropAction = false;
        if (parent.afterCropActions.length > 0) {
            var object = { collection: parent.afterCropActions };
            parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
                value: { collection: parent.afterCropActions, isRotateFlipCollection: null, obj: object } });
            parent.afterCropActions = object['collection'];
        }
        var afterCropActions = extend([], parent.afterCropActions, [], true);
        if (!isObj && afterCropActions.length > 0) {
            isAfterCropAction = true;
            for (var i = 0, len = afterCropActions.length; i < len; i++) {
                if (afterCropActions[i] === 'horizontalflip' || afterCropActions[i] === 'verticalflip') {
                    parent.activeObj = extend({}, currSelectionPoint, {}, true);
                    this.rotatedFlipCropSel = true;
                }
                parent.notify('transform', { prop: 'updateTransform', onPropertyChange: false, value: { text: afterCropActions[i] } });
            }
            activeObj = extend({}, parent.activeObj, {}, true);
            this.resetPanPoints();
            parent.activeObj = activeObj;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                this.drawObject('duplicate', null, null, null, true);
            }
            if (obj.degree !== parent.transform.degree) {
                parent.transform.cropZoomFactor = null;
                parent.transform.zoomFactor = 0;
            }
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            if (this.rotatedFlipCropSel) {
                this.rotatedFlipCropSel = false;
            }
        }
        parent.afterCropActions = afterCropActions;
        if (!this.isCancelAction && !isAfterCropAction) {
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            parent.img.destLeft = obj.destPoints.startX;
            parent.img.destTop = obj.destPoints.startY;
        }
        parent.activeObj = activeObj;
        parent.isCircleCrop = isCircleCrop;
        if (isNullOrUndefined(currSelectionPoint)) {
            parent.currSelectionPoint = null;
        }
        else {
            parent.currSelectionPoint = extend({}, currSelectionPoint, {}, true);
            if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                parent.currSelectionPoint = null;
            }
        }
    };
    Draw.prototype.drawCropSelectionImage = function (obj, isObj) {
        var parent = this.parent;
        var temp = this.lowerContext.filter;
        parent.clearContext(this.lowerContext);
        parent.clearContext(this.upperContext);
        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
        if (isObj) {
            this.updateCurrTransState('initial');
        }
        else {
            this.setTransformColl(this.lowerContext, 'initial');
        }
        parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        this.drawImage();
        if (isObj) {
            this.updateCurrTransState('reverse');
        }
        else {
            this.setTransformColl(this.lowerContext, 'reverse');
        }
        parent.img.destLeft = parent.cropObj.destPoints.startX;
        parent.img.destTop = parent.cropObj.destPoints.startY;
        var activeObj = extend({}, obj.activeObj, {}, true);
        this.lowerContext.filter = 'none';
        parent.img = { destLeft: obj.destPoints.startX, destTop: obj.destPoints.startY, destWidth: obj.destPoints.width,
            destHeight: obj.destPoints.height, srcLeft: obj.srcPoints.startX, srcTop: obj.srcPoints.startY,
            srcWidth: obj.srcPoints.width, srcHeight: obj.srcPoints.height };
        if (obj.activeObj.activePoint.width !== 0 && obj.activeObj.activePoint.height !== 0) {
            var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.img.destLeft = obj.activeObj.activePoint.startX;
            parent.img.destTop = obj.activeObj.activePoint.startY;
            parent.img.destWidth = obj.activeObj.activePoint.width;
            parent.img.destHeight = obj.activeObj.activePoint.height;
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
        }
        parent.activeObj = activeObj;
        this.lowerContext.filter = temp;
    };
    Draw.prototype.performPointZoom = function (x, y, type, isResize, value) {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var isCropSelection = false;
        if (parent.activeObj.shape && parent.activeObj.shape.indexOf('crop-') > -1) {
            isCropSelection = true;
        }
        if (parent.element.querySelector('.e-contextual-toolbar-wrapper') && !isCropSelection) {
            if (!parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {
                parent.okBtn();
                parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
            }
        }
        var ratioX = (x - destLeft) / destWidth;
        var ratioY = (y - destTop) / destHeight;
        var isUndoRedo = parent.isUndoRedo;
        parent.isUndoRedo = true;
        parent.setProperties({ zoomSettings: { zoomPoint: { x: x, y: y } } }, true);
        var zoomValue = value ? value : (type === 'zoomIn') ? .1 : -.1;
        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
            value: { zoomFactor: zoomValue, zoomPoint: null, isResize: isResize } });
        parent.isUndoRedo = isUndoRedo;
        this.panToPoint(x, y, ratioX, ratioY);
    };
    Draw.prototype.panToPoint = function (x, y, ratioX, ratioY) {
        var parent = this.parent;
        if (parent.transform.zoomFactor > 0) {
            var destLeft = parent.img.destLeft;
            var destTop = parent.img.destTop;
            var activeObj = extend({}, parent.activeObj, {}, true);
            if (parent.transform.degree === 0) {
                parent.img.destLeft = x - (ratioX * parent.img.destWidth);
                parent.img.destTop = y - (ratioY * parent.img.destHeight);
                this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
            }
            else {
                var isCropTab = parent.isCropTab;
                parent.isCropTab = true;
                var objColl = extend([], parent.objColl, [], true);
                var pointColl = extend([], parent.pointColl, [], true);
                var straightenObj = { straightenPoint: null };
                parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false,
                    value: { obj: straightenObj } });
                parent.objColl = [];
                parent.pointColl = [];
                parent.freehandCounter = 0;
                parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false,
                    value: { x: null, y: null, ratioX: null, ratioY: null } });
                var object = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: object } });
                var cropSelPointColl = object['selPointColl'];
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: [] } } });
                parent.panPoint.currentPannedPoint = { x: (x - (ratioX * parent.img.destWidth)) - destLeft,
                    y: (y - (ratioY * parent.img.destHeight)) - destTop };
                parent.notify('transform', { prop: 'rotatePan', onPropertyChange: false,
                    value: { isCropSelection: null, isDefaultZoom: null } });
                parent.isCropTab = isCropTab;
                parent.objColl = objColl;
                parent.pointColl = pointColl;
                parent.freehandCounter = parent.pointColl.length;
                if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {
                    parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false,
                        value: { x: straightenObj['straightenPoint']['x'], y: straightenObj['straightenPoint']['y'],
                            ratioX: straightenObj['straightenPoint']['ratioX'], ratioY: straightenObj['straightenPoint']['ratioY'] } });
                }
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: cropSelPointColl } } });
                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                    value: { ctx: this.lowerContext, shape: 'pan', pen: 'pan', x: parent.panPoint.currentPannedPoint.x,
                        y: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
            }
            this.adjustPanning(activeObj);
            var isActObj = false;
            for (var i = 0; i < parent.objColl.length; i++) {
                if (JSON.stringify(activeObj.activePoint) === JSON.stringify(parent.objColl[i].activePoint)) {
                    isActObj = true;
                    break;
                }
            }
            if (!isActObj) {
                parent.activeObj = activeObj;
            }
            if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                this.drawObject('duplicate', null, null, null, true);
            }
        }
    };
    Draw.prototype.adjustPanning = function (activeObj) {
        var parent = this.parent;
        var _a = activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
        if (width !== 0 && height !== 0) {
            var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
            var point = { x: 0, y: 0 };
            if (destLeft > startX) {
                point.x = destLeft - startX;
            }
            else if (destLeft + destWidth < startX + width) {
                point.x = (destLeft + destWidth) - (startX + width);
            }
            if (destTop > startY) {
                point.y = destTop - startY;
            }
            else if (destTop + destHeight < startY + height) {
                point.y = (destTop + destHeight) - (startY + height);
            }
            if (parent.transform.degree === 0) {
                parent.img.destLeft -= point.x;
                parent.img.destTop -= point.y;
                this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
            }
            else {
                var isCropTab = parent.isCropTab;
                parent.isCropTab = true;
                var objColl = extend([], parent.objColl, [], true);
                var pointColl = extend([], parent.pointColl, [], true);
                parent.objColl = [];
                parent.pointColl = [];
                parent.freehandCounter = 0;
                var object = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: object } });
                var cropSelPointColl = object['selPointColl'];
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: [] } } });
                parent.img.destLeft -= point.x;
                parent.img.destTop -= point.y;
                parent.panPoint.currentPannedPoint = { x: parent.img.destLeft - destLeft, y: parent.img.destTop - destTop };
                parent.notify('transform', { prop: 'rotatePan', onPropertyChange: false,
                    value: { isCropSelection: null, isDefaultZoom: null } });
                parent.isCropTab = isCropTab;
                parent.objColl = objColl;
                parent.pointColl = pointColl;
                parent.freehandCounter = parent.pointColl.length;
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: cropSelPointColl } } });
                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                    value: { ctx: this.lowerContext, shape: 'pan', pen: 'pan', x: parent.panPoint.currentPannedPoint.x,
                        y: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
            }
        }
    };
    Draw.prototype.panToSel = function () {
        var parent = this.parent;
        var activeObj = extend({}, parent.activeObj, {}, true);
        var _a = activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
        this.allowRedactStraighten = true;
        var straightenObj = { straightenPoint: null };
        parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false,
            value: { obj: straightenObj } });
        if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {
            var panX = (startX + (width / 2)) - straightenObj['straightenPoint']['x'];
            var panY = (startY + (height / 2)) - straightenObj['straightenPoint']['y'];
            if (parent.transform.degree === 0) {
                parent.img.destLeft += panX;
                parent.img.destTop += panY;
                parent.notify('transform', { prop: 'drawPannImage', value: { point: { x: panX, y: panY } } });
            }
            else {
                parent.panPoint.currentPannedPoint = { x: panX, y: panY };
                parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: panX, yDiff: panY } });
                parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
                parent.notify('transform', { prop: 'setTempPanMove', value: { point: null } });
            }
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });
            var _b = parent.img, destLeft_3 = _b.destLeft, destTop_3 = _b.destTop, destWidth_3 = _b.destWidth, destHeight_3 = _b.destHeight;
            var points = this.imgCanvasPoints;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            points.forEach(function (point) {
                point.x = (point.ratioX * destWidth_3) + destLeft_3;
                point.y = (point.ratioY * destHeight_3) + destTop_3;
            });
            this.imgCanvasPoints = points;
            var count = 0;
            if (parent.transform.straighten === 3 && !this.preventStraightening) {
                this.preventStraightening = true;
                var temp = parent.prevStraightenedDegree;
                parent.prevStraightenedDegree = parent.transform.straighten;
                parent.setStraighten(0);
                parent.setStraighten(3);
                parent.prevStraightenedDegree = temp;
                this.preventStraightening = false;
            }
            while (this.isLinesIntersect() && parent.transform.straighten !== 0 && parent.transform.straighten !== 360 && count < 100) {
                count++;
                this.performPointZoom(parent.activeObj.activePoint.startX + (parent.activeObj.activePoint.width / 2), parent.activeObj.activePoint.startY + (parent.activeObj.activePoint.height / 2), 'zoomIn', false, 0.025);
                this.updateImgCanvasPoints();
            }
        }
    };
    Draw.prototype.drawZoomPanImage = function (x, y) {
        var parent = this.parent;
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'pan', pen: 'pan', x: x, y: y, panRegion: '' } });
        this.renderImage(true);
        var obj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj: obj, isImgShape: null } });
        var maxDimension = obj;
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.panPoint.totalPannedPoint.x += x;
        parent.panPoint.totalPannedPoint.y += y;
        parent.notify('crop', { prop: 'setTempFlipPanPoint', onPropertyChange: false, value: { point: { x: 0, y: 0 } } });
    };
    Draw.prototype.openNewImage = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var inMemoryContext = parent.inMemoryCanvas.getContext('2d');
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        var toolbar = document.querySelector('#' + id + '_currPos');
        if (toolbar) {
            toolbar.style.display = 'none';
        }
        var obj = { defToolbarItems: null };
        parent.notify('toolbar', { prop: 'getDefToolbarItems', value: { obj: obj } });
        if (obj['defToolbarItems'] && obj['defToolbarItems'].length === 0 &&
            (isNullOrUndefined(document.getElementById(id + '_toolbar'))) &&
            parent.element.querySelector('#' + id + '_toolbarArea')) {
            var height = parent.element.querySelector('#' + id + '_toolbarArea').clientHeight;
            parent.notify('toolbar', { prop: 'setToolbarHeight', value: { height: height } });
        }
        parent.reset();
        parent.update();
        parent.transform.degree = 0;
        parent.transform.zoomFactor = 0;
        parent.isImageLoaded = false;
        parent.currSelectionPoint = null;
        var type = typeof (this.openURL);
        if (type === 'string') {
            var fileName = this.openURL.split('.');
            if (fileName.length > 1) {
                fileName = fileName[fileName.length - 2].split('/');
                this.fileName = fileName[fileName.length - 1];
            }
            else {
                this.fileName = 'ImageEditor';
            }
            this.fileType = this.getFileExtensionFromURL(this.openURL);
            if (this.fileType) {
                this.fileType = parent.toPascalCase(this.fileType);
                var fileType = this.fileType.toLowerCase();
                if (fileType === 'jpg' || fileType === 'jpeg') {
                    this.fileType = 'Jpeg';
                    fileType = 'jpeg';
                }
                if (fileType !== 'jpeg' && fileType !== 'png' && fileType !== 'svg' && fileType !== 'webp') {
                    this.fileType = null;
                }
            }
            this.imageOnLoad(this.openURL);
            if (typeof (this.openURL) !== 'string' || this.openURL.indexOf('localhost') === -1) {
                this.getImageSizeFromURL(this.openURL.toString(), function (imageSizeMB) {
                    if (imageSizeMB !== null) {
                        _this.parent.notify('toolbar', { prop: 'setInitialSize', value: { value: +imageSizeMB } });
                    }
                });
            }
        }
        else {
            this.fileName = 'ImageEditor';
            this.fileType = null;
            parent.lowerCanvas = document.querySelector('#' + id + '_lowerCanvas');
            parent.upperCanvas = document.querySelector('#' + id + '_upperCanvas');
            this.lowerContext = parent.lowerCanvas.getContext('2d');
            this.upperContext = parent.upperCanvas.getContext('2d');
            parent.clearContext(this.lowerContext);
            parent.clearContext(this.upperContext);
            parent.clearContext(inMemoryContext);
            parent.inMemoryCanvas.width = this.openURL.width;
            parent.inMemoryCanvas.height = this.openURL.height;
            inMemoryContext.putImageData(this.openURL, 0, 0);
            parent.baseImg.src = parent.inMemoryCanvas.toDataURL();
        }
    };
    Draw.prototype.getImageSizeFromURL = function (imageUrl, callback) {
        return __awaiter(this, void 0, void 0, function () {
            var response, contentLength, imageSizeMB, ex_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, fetch(imageUrl, { method: 'HEAD' })];
                    case 1:
                        response = _a.sent();
                        contentLength = parseInt(response.headers.get('content-length') || '0', 10);
                        imageSizeMB = contentLength;
                        callback(imageSizeMB);
                        return [3 /*break*/, 3];
                    case 2:
                        ex_1 = _a.sent();
                        // eslint-disable-next-line no-console
                        console.log(ex_1.message);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Draw.prototype.dlgBtnClick = function () {
        this.parent.export();
        this.applyDialogOption();
    };
    Draw.prototype.dlgCloseBtnClick = function () {
        this.applyDialogOption();
    };
    Draw.prototype.applyDialogOption = function () {
        var parent = this.parent;
        if (this.isFileChanged) {
            parent.isImageLoaded = this.isFileChanged = false;
            parent.reset();
            this.checkToolbarTemplate(this.inputElem, this.openURL);
        }
        else {
            this.reset();
            this.openNewImage();
        }
        getComponent(document.getElementById(parent.element.id + '_dialog'), 'dialog').destroy();
        this.isImageEdited = false;
    };
    Draw.prototype.showDialogPopup = function () {
        var parent = this.parent;
        var headerObj = { key: 'ConfirmDialogHeader' };
        parent.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: headerObj } });
        var contentObj = { key: 'ConfirmDialogContent' };
        parent.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: contentObj } });
        var yesObj = { key: 'Yes' };
        parent.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: yesObj } });
        var noObj = { key: 'No' };
        parent.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: noObj } });
        parent.element.querySelector('#' + parent.element.id + '_dialog').style.display = 'block';
        var dialog = new Dialog({
            header: headerObj['value'],
            closeOnEscape: true,
            content: '<span>' + contentObj['value'] + '</span>',
            target: document.getElementById('target'),
            width: '285px',
            isModal: true,
            animationSettings: { effect: 'Zoom' },
            close: this.dlgCloseBtnClick.bind(this),
            buttons: [
                { click: this.dlgCloseBtnClick.bind(this),
                    buttonModel: { content: noObj['value'], iconCss: 'e-icons e-close' }
                },
                { click: this.dlgBtnClick.bind(this),
                    buttonModel: { content: yesObj['value'], isPrimary: true, iconCss: 'e-icons e-check' } }
            ]
        });
        dialog.appendTo('#' + parent.element.id + '_dialog');
    };
    Draw.prototype.restoreOldImage = function () {
        var _this = this;
        var parent = this.parent;
        var dropArea = document.getElementById(this.parent.element.id + '_dropArea');
        var extension = parent.getExtensionArray();
        var openURLType = typeof this.openURL;
        if (openURLType !== 'string') {
            this.openImageData(dropArea);
            return;
        }
        var fileType = this.getFileExtensionFromURL(this.openURL);
        if (fileType) {
            fileType = fileType.toLowerCase();
            fileType = (fileType === 'jpg' || fileType === 'jpeg') ? 'jpeg' : fileType;
        }
        var isAllowedFileType = (fileType ? (extension.indexOf(fileType) > -1 ||
            (fileType === 'jpeg' && (parent.uploadSettings.allowedExtensions.indexOf('jpg') > -1 ||
                parent.uploadSettings.allowedExtensions.indexOf('jpeg') > -1))) : false) || this.isNullExtension;
        if ((this.openURL.indexOf('data:image/') > -1 && this.openURL.indexOf('base64') > -1) ||
            this.openURL.indexOf('blob') > -1) {
            this.openImageData(dropArea, true);
        }
        else if (parent.uploadSettings.minFileSize || parent.uploadSettings.maxFileSize) {
            this.getImageSizeFromURL(this.openURL.toString(), function (imageSizeMB) {
                var isInvalidSize = (parent.uploadSettings.minFileSize && imageSizeMB < parent.uploadSettings.minFileSize) ||
                    (parent.uploadSettings.maxFileSize && imageSizeMB > parent.uploadSettings.maxFileSize);
                _this.handleFileSize(!isAllowedFileType || isInvalidSize, dropArea, !isAllowedFileType);
            });
        }
        else {
            this.handleFileSize(!isAllowedFileType, dropArea, !isAllowedFileType);
        }
    };
    Draw.prototype.handleFileSize = function (isError, dropArea, fileTypeError) {
        var parent = this.parent;
        if (isError) {
            this.errorLoading();
            parent.showDialogPopup('unsupported', fileTypeError);
            if (dropArea && !parent.isImageLoaded) {
                dropArea.style.display = 'block';
            }
        }
        else {
            if (dropArea) {
                dropArea.style.display = 'none';
            }
            if (this.parent.isImageLoaded) {
                this.reset();
            }
            this.openNewImage();
        }
    };
    Draw.prototype.openImageData = function (dropArea, isBase64) {
        var parent = this.parent;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        var canvas = parent.createElement('canvas');
        var ctx = canvas.getContext('2d');
        if (!parent.uploadSettings.minFileSize && !parent.uploadSettings.maxFileSize) {
            this.handleFileSize(false, dropArea, false);
            return;
        }
        if (isBase64) {
            var img_1 = new Image();
            img_1.src = this.openURL;
            img_1.onload = function () {
                ctx.canvas.width = img_1.width;
                ctx.canvas.height = img_1.height;
                ctx.drawImage(img_1, 0, 0);
                proxy.getImageSize(canvas, dropArea);
            };
        }
        else {
            canvas.width = this.openURL.width;
            canvas.height = this.openURL.height;
            ctx.putImageData(this.openURL, 0, 0);
            this.getImageSize(canvas, dropArea);
        }
    };
    Draw.prototype.getImageSize = function (canvas, dropArea) {
        var parent = this.parent;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        canvas.toBlob((function (blob) {
            if ((parent.uploadSettings.minFileSize && blob.size < parent.uploadSettings.minFileSize) ||
                (parent.uploadSettings.maxFileSize && blob.size > parent.uploadSettings.maxFileSize)) {
                this.handleFileSize(true, dropArea, false);
            }
            else {
                this.handleFileSize(false, dropArea, false);
            }
        }).bind(this), 'image/jpeg', 1);
    };
    Draw.prototype.open = function (data) {
        if (!this.parent.disabled) {
            this.openURL = data;
            this.restoreOldImage();
        }
    };
    Draw.prototype.getInitialLoaded = function (object) {
        object['isInitialLoaded'] = this.isInitialLoading;
    };
    Draw.prototype.getFileExtensionFromURL = function (url) {
        var lastDotIndex = url.lastIndexOf('.');
        if (lastDotIndex !== -1) {
            return url.slice(lastDotIndex + 1).toLowerCase();
        }
        else if (url.indexOf('base64') !== -1) {
            return url.slice(url.indexOf('/') + 1, url.indexOf(';')).toLowerCase();
        }
        return null;
    };
    Draw.prototype.fileSelect = function (inputElement, args) {
        var parent = this.parent;
        var dropArea = document.getElementById(parent.element.id + '_dropArea');
        if (dropArea) {
            dropArea.style.display = 'none';
        }
        if (!parent.disabled) {
            var filesData = void 0;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var fileData = void 0;
            if (args.target) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                filesData = args.target.files[0];
                fileData = filesData;
            }
            else {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                filesData = fileData = args.filesData[0].rawFile;
            }
            var fileExtension = void 0;
            if (fileData.name) {
                var fileExtensionArray = fileData.name.split('.');
                fileExtension = fileExtensionArray[fileExtensionArray.length - 1].toLowerCase();
            }
            var extension = parent.getExtensionArray();
            var isJPG = ((fileExtension === 'jpg' || fileExtension === 'jpeg') && (parent.uploadSettings.allowedExtensions.indexOf('jpg') > -1 || parent.uploadSettings.allowedExtensions.indexOf('jpeg') > -1));
            if ((fileExtension && (extension.indexOf(fileExtension) === -1 && !isJPG)) ||
                ((parent.uploadSettings.minFileSize && fileData.size < parent.uploadSettings.minFileSize) ||
                    (parent.uploadSettings.maxFileSize && fileData.size > parent.uploadSettings.maxFileSize))) {
                this.errorLoading();
                return;
            }
            showSpinner(parent.element);
            parent.element.style.opacity = '0.5';
            this.inputElem = inputElement;
            fileExtension = fileData.name && fileData.name.split('.')[1];
            if (fileExtension) {
                var fileType = parent.toPascalCase(fileExtension);
                if (fileType === 'JPG' || fileType === 'Jpg') {
                    this.fileType = 'Jpeg';
                }
                else {
                    this.fileType = fileType;
                }
            }
            else {
                this.fileType = null;
            }
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var URL_1 = window.URL;
            var url = URL_1.createObjectURL(filesData);
            this.openURL = url;
            // eslint-disable-next-line max-len
            if (parent.isImageLoaded && !parent.isChangesSaved && (this.isImageEdited || parent.pointColl.length > 0 || parent.objColl.length > 0)) {
                this.isFileChanged = true;
                this.showDialogPopup();
            }
            else {
                this.checkToolbarTemplate(inputElement, url);
            }
        }
    };
    Draw.prototype.checkToolbarTemplate = function (inputElement, url) {
        var parent = this.parent;
        if (isNullOrUndefined(parent.toolbarTemplate)) {
            parent.reset();
            parent.update();
        }
        this.fileName = inputElement.value.split('\\')[inputElement.value.split('\\').length - 1];
        this.fileName = this.fileName.split('.')[0];
        this.imageOnLoad(url.toString());
        inputElement.value = '';
    };
    Draw.prototype.moveToSelectionRange = function (type, activeObj) {
        var parent = this.parent;
        if (parent.activeObj.shape) {
            var isRotated = false;
            for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
                var degree = parent.rotateFlipColl[i];
                if (degree === 90 || degree === -90) {
                    isRotated = true;
                    break;
                }
            }
            if (isRotated) {
                if (parent.transform.degree === 0) {
                    return;
                }
                var zoomFactor = parent.transform.zoomFactor;
                parent.objColl.push(parent.activeObj);
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                var currObj = parent.objColl[parent.objColl.length - 1];
                if (type === 'rotateleft' || type === 'rotateright') {
                    if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
                        if (currObj.activePoint.width < activeObj.activePoint.height) {
                            for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (currObj.activePoint.width >= activeObj.activePoint.height ||
                                    this.isSelectionBiggerThanCanvas(currObj) ||
                                    this.isSelectionOutsideCanvas(currObj)) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: -0.1, zoomPoint: null }, isResize: null });
                                    }
                                    break;
                                }
                                zoomFactor += 0.1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null }, isResize: null });
                            }
                        }
                        else {
                            for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (currObj.activePoint.width >= activeObj.activePoint.height ||
                                    this.isSelectionBiggerThanCanvas(currObj) ||
                                    this.isSelectionOutsideCanvas(currObj)) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: 0.1, zoomPoint: null, isResize: null } });
                                    }
                                    break;
                                }
                                zoomFactor -= .1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null }, isResize: null });
                            }
                        }
                    }
                    else {
                        if (currObj.activePoint.height < activeObj.activePoint.width) {
                            for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (currObj.activePoint.height >= activeObj.activePoint.width ||
                                    this.isSelectionBiggerThanCanvas(currObj) ||
                                    this.isSelectionOutsideCanvas(currObj)) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: -0.1, zoomPoint: null }, isResize: null });
                                    }
                                    break;
                                }
                                zoomFactor += 0.1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null }, isResize: null });
                            }
                        }
                        else {
                            for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (currObj.activePoint.height >= activeObj.activePoint.width ||
                                    this.isSelectionBiggerThanCanvas(currObj) ||
                                    this.isSelectionOutsideCanvas(currObj)) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: 0.1, zoomPoint: null }, isResize: null });
                                    }
                                    break;
                                }
                                zoomFactor -= .1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null }, isResize: null });
                            }
                        }
                    }
                }
                var panX = (parent.lowerCanvas.clientWidth / 2) - (currObj.activePoint.startX +
                    (currObj.activePoint.width / 2));
                var panY = ((parent.lowerCanvas.clientHeight + 1) / 2) - (currObj.activePoint.startY +
                    (currObj.activePoint.height / 2));
                if (isNullOrUndefined(parent.activeObj.shape)) {
                    parent.activeObj = extend({}, activeObj, {}, true);
                }
                if (parent.transform.degree === 0) {
                    parent.img.destLeft += panX;
                    parent.img.destTop += panY;
                    parent.notify('transform', { prop: 'drawPannImage', value: { point: { x: panX, y: panY } } });
                }
                else {
                    parent.panPoint.currentPannedPoint = { x: panX, y: panY };
                    parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: panX, yDiff: panY } });
                    parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
                }
                parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
                    value: { point: null } });
                parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1]);
                parent.objColl.pop();
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            }
        }
    };
    Draw.prototype.isSelectionBiggerThanCanvas = function (obj) {
        var isBigger = false;
        var parent = this.parent;
        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
        if (startX <= destLeft || startY <= destTop || endX >= destLeft + destWidth || endY >= destTop + destHeight) {
            isBigger = true;
        }
        return isBigger;
    };
    Draw.prototype.isSelectionOutsideCanvas = function (obj) {
        var isOutside = false;
        var parent = this.parent;
        if ((obj.activePoint.height < parent.lowerCanvas.height - parent.toolbarHeight) ||
            (obj.activePoint.width < parent.lowerCanvas.width)) {
            isOutside = true;
        }
        return isOutside;
    };
    Draw.prototype.downScaleImgCanvas = function (ctx, isImgAnnotation, isHFlip, isVFlip) {
        var parent = this.parent;
        var canvas = isImgAnnotation ? parent.activeObj.imageCanvas : parent.baseImgCanvas;
        var img = isImgAnnotation ? parent.activeObj.imageElement : parent.baseImg;
        var width = isImgAnnotation ? parent.activeObj.activePoint.width : parent.img.destWidth;
        var height = isImgAnnotation ? parent.activeObj.activePoint.height : parent.img.destHeight;
        var obj = { width: 0, height: 0 };
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: img.height, height: img.width, obj: obj, isImgShape: isImgAnnotation } });
        }
        else {
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: img.width, height: img.height, obj: obj, isImgShape: isImgAnnotation } });
        }
        if (isImgAnnotation || (parent.allowDownScale && !parent.isCropTab && !parent.isCropToolbar && img.width !== 0 && img.height !== 0
            && obj['width'] * 0.75 > width && obj['height'] * 0.75 > height)) {
            var tempCanvas = parent.createElement('canvas', {
                id: parent.element.id + '_downScaleCanvas', attrs: { name: 'canvasImage' }
            });
            tempCanvas.width = isImgAnnotation ? img.width : parent.img.srcWidth;
            tempCanvas.height = isImgAnnotation ? img.height : parent.img.srcHeight;
            if (isImgAnnotation) {
                tempCanvas.getContext('2d').drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
            }
            else {
                if (this.imageBackgroundColor !== '') {
                    ctx.fillStyle = this.imageBackgroundColor;
                    ctx.fillRect(parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
                }
                tempCanvas.getContext('2d').drawImage(canvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, tempCanvas.width, tempCanvas.height);
            }
            if (isImgAnnotation || this.isDownScale) {
                this.downScale(tempCanvas, width, height, isImgAnnotation);
            }
            if (isImgAnnotation) {
                ctx.canvas.width = tempCanvas.width;
                ctx.canvas.height = tempCanvas.height;
                if (isHFlip && isVFlip) {
                    ctx.translate(parent.activeObj.imageCanvas.width, 0);
                    ctx.scale(-1, 1);
                    ctx.translate(0, parent.activeObj.imageCanvas.height);
                    ctx.scale(1, -1);
                }
                else {
                    if (isHFlip) {
                        if (isNullOrUndefined(parent.activeObj.isHorImageFlip) || !parent.activeObj.isHorImageFlip) {
                            parent.activeObj.isHorImageFlip = true;
                            ctx.translate(parent.activeObj.imageCanvas.width, 0);
                            ctx.scale(-1, 1);
                        }
                        else if (parent.activeObj.isHorImageFlip) {
                            parent.activeObj.isHorImageFlip = false;
                        }
                        if (parent.activeObj.isVerImageFlip) {
                            ctx.translate(0, parent.activeObj.imageCanvas.height);
                            ctx.scale(1, -1);
                        }
                    }
                    else if (isVFlip) {
                        if (isNullOrUndefined(parent.activeObj.isVerImageFlip) || !parent.activeObj.isVerImageFlip) {
                            parent.activeObj.isVerImageFlip = true;
                            ctx.translate(0, parent.activeObj.imageCanvas.height);
                            ctx.scale(1, -1);
                        }
                        else if (parent.activeObj.isVerImageFlip) {
                            parent.activeObj.isVerImageFlip = false;
                        }
                        if (parent.activeObj.isHorImageFlip) {
                            ctx.translate(parent.activeObj.imageCanvas.width, 0);
                            ctx.scale(-1, 1);
                        }
                    }
                }
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            else if (parent.isFinetuning) {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(parent.inMemoryCanvas, 0, 0);
                ctx.restore();
            }
            else {
                ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, parent.img.destLeft, parent.img.destTop, tempCanvas.width, tempCanvas.height);
            }
        }
        else {
            if ((isNullOrUndefined(isImgAnnotation) || !isImgAnnotation) && parent.baseImgCanvas.width !== 0 &&
                parent.baseImgCanvas.height !== 0) {
                if (this.imageBackgroundColor !== '') {
                    ctx.fillStyle = this.imageBackgroundColor;
                    ctx.fillRect(parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
                }
                ctx.drawImage(parent.baseImgCanvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
            }
        }
        if (parent.isSafari) {
            parent.notify('filter', { prop: 'apply-filter', onPropertyChange: false, value: { context: ctx } });
        }
    };
    Draw.prototype.downScale = function (canvas, width, height, isImgAnnotation) {
        var parent = this.parent;
        if (isImgAnnotation && parent.isStraightening) {
            return;
        }
        var widthSource = canvas.width;
        var heightSource = canvas.height;
        width = Math.round(width);
        height = Math.round(height);
        var widthRatio = widthSource / width;
        var heightRatio = heightSource / height;
        var halfWidthRatio = Math.ceil(widthRatio / 2);
        var halfHeightRatio = Math.ceil(heightRatio / 2);
        var ctx = canvas.getContext('2d');
        var img = ctx.getImageData(0, 0, widthSource, heightSource);
        var img2 = ctx.createImageData(width, height);
        var data = img.data;
        var data2 = img2.data;
        for (var j = 0; j < height; j++) {
            for (var i = 0; i < width; i++) {
                var x2 = (i + j * width) * 4;
                var weight = 0;
                var weights = 0;
                var alphaWeights = 0;
                var r = 0;
                var g = 0;
                var b = 0;
                var a = 0;
                var centerY = (j + 0.5) * heightRatio;
                var startY = Math.floor(j * heightRatio);
                var stopY = Math.ceil((j + 1) * heightRatio);
                for (var y = startY; y < stopY; y++) {
                    var dy = Math.abs(centerY - (y + 0.5)) / halfHeightRatio;
                    var centerX = (i + 0.5) * widthRatio;
                    var w0 = dy * dy; //pre-calc part of w
                    var startX = Math.floor(i * widthRatio);
                    var stopX = Math.ceil((i + 1) * widthRatio);
                    for (var x = startX; x < stopX; x++) {
                        var dx = Math.abs(centerX - (x + 0.5)) / halfWidthRatio;
                        var w = Math.sqrt(w0 + dx * dx);
                        if (w >= 1) {
                            continue;
                        }
                        weight = 2 * w * w * w - 3 * w * w + 1;
                        var xPos = 4 * (x + y * widthSource);
                        a += weight * data[xPos + 3];
                        alphaWeights += weight;
                        weight = weight * data[xPos + 3] / 250;
                        r += weight * data[xPos];
                        g += weight * data[xPos + 1];
                        b += weight * data[xPos + 2];
                        weights += weight;
                    }
                }
                data2[x2] = r / weights;
                data2[x2 + 1] = g / weights;
                data2[x2 + 2] = b / weights;
                data2[x2 + 3] = a / alphaWeights;
            }
        }
        canvas.width = isImgAnnotation ? parent.activeObj.activePoint.width : parent.lowerCanvas.width;
        canvas.height = isImgAnnotation ? parent.activeObj.activePoint.height : parent.lowerCanvas.height;
        ctx.putImageData(img2, 0, 0);
    };
    Draw.prototype.drawImgToCtx = function (ctx, preventImg) {
        var parent = this.parent;
        if (ctx.canvas.id !== parent.element.id + '_tempCanvas' && ctx !== this.upperContext && isNullOrUndefined(preventImg)) {
            this.downScaleImgCanvas(ctx, null, null, null);
        }
    };
    Draw.prototype.getFrameColor = function (frameObj, ctx, points) {
        var parent = this.parent;
        var color = parent.frameObj.color;
        if (frameObj.gradientColor) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var gradient = ctx.createLinearGradient(points.startX, points.startY, points.startX + points.width, points.startY + points.height);
            gradient.addColorStop(0, frameObj.color);
            gradient.addColorStop(1, frameObj.gradientColor);
            color = gradient;
        }
        else {
            color = frameObj.color;
        }
        return color;
    };
    Draw.prototype.applyFrame = function (ctx, frame, preventImg) {
        var parent = this.parent;
        parent.frameObj.type = frame;
        var tempLineWidth;
        var ratio = { width: 1, height: 1 };
        var points = { startX: parent.img.destLeft - ctx.lineWidth, startY: parent.img.destTop - ctx.lineWidth,
            width: parent.img.destWidth + (2 * ctx.lineWidth), height: parent.img.destHeight + (2 * ctx.lineWidth) };
        var frameObj = { type: parent.frameObj.type, color: parent.frameObj.color, size: parent.frameObj.size,
            inset: parent.frameObj.inset, offset: parent.frameObj.offset / 2, radius: parent.frameObj.radius,
            amount: parent.frameObj.amount, border: parent.frameObj.border, gradientColor: parent.frameObj.gradientColor };
        var zoomFactor = parent.transform.zoomFactor;
        if (ctx.canvas.id === parent.element.id + '_tempCanvas') {
            var newWidth = ctx.canvas.width;
            var newHeight = ctx.canvas.height;
            var obj = { width: 0, height: 0 };
            parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
                value: { obj: obj, dimension: { width: newWidth, height: newHeight } } });
            ratio = obj;
            frameObj.size *= ((ratio.width + ratio.height) / 2);
            frameObj.inset *= ((ratio.width + ratio.height) / 2);
            frameObj.offset *= ((ratio.width + ratio.height) / 2);
            frameObj.radius *= ((ratio.width + ratio.height) / 2);
            points = { startX: 0, startY: 0, width: ctx.canvas.width, height: ctx.canvas.height };
            parent.notify('export', { prop: 'updateSaveContext', onPropertyChange: false, value: { context: ctx } });
        }
        else if (ctx === this.upperContext && parent.activeObj.shape) {
            points = { startX: parent.activeObj.activePoint.startX - ctx.lineWidth, startY: parent.activeObj.activePoint.startY
                    - ctx.lineWidth, width: parent.activeObj.activePoint.width + (2 * ctx.lineWidth), height: parent.activeObj.activePoint.height + (2 * ctx.lineWidth) };
        }
        else if (isNullOrUndefined(preventImg)) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }
        var valueForty = (40 * ((ratio.width + ratio.height) / 2));
        var valueFifty = (50 * ((ratio.width + ratio.height) / 2));
        if (ctx !== this.upperContext) {
            frameObj.size += (frameObj.size * zoomFactor);
            frameObj.inset += (frameObj.inset * zoomFactor);
            frameObj.offset += (frameObj.offset * zoomFactor);
            frameObj.radius += (frameObj.radius * zoomFactor);
            valueForty += (valueForty * zoomFactor);
            valueFifty += (valueFifty * zoomFactor);
        }
        if (ctx === this.upperContext && parent.activeObj.shape) {
            if ((frame === 'mat' && ((points.width - (2 * frameObj.size) < 0) || (points.height - (2 * frameObj.size) < 0))) ||
                (frame === 'bevel' && (points.width - (2 * frameObj.size) < 40 || points.height - (2 * frameObj.size) < 40)) ||
                ((frame === 'inset') && (points.startX + points.width - frameObj.offset - (points.startX + frameObj.offset) < 0 ||
                    points.startY + points.height - frameObj.offset - (points.startY + frameObj.offset) < 0)) ||
                (frame === 'hook' && (points.width - (2 * frameObj.size) < 50 || points.height - (2 * frameObj.size) < 50))) {
                return;
            }
        }
        var bevelObj = { bevelFilter: ctx.filter };
        var filter = ctx.filter;
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop ||
            (ctx === this.lowerContext && parent.isCropTab)) {
            this.drawImgToCtx(ctx, preventImg);
        }
        else {
            switch (frame) {
                case 'none':
                    this.drawImgToCtx(ctx, preventImg);
                    break;
                case 'mat':
                    this.drawImgToCtx(ctx, preventImg);
                    while (((points.width - (2 * frameObj.size) < 0) ||
                        (points.height - (2 * frameObj.size) < 0)) && frameObj.size > 0) {
                        frameObj.size -= 20;
                    }
                    ctx.filter = 'none';
                    ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
                    ctx.beginPath();
                    ctx.rect(points.startX, points.startY, points.width, points.height);
                    ctx.rect(points.startX + frameObj.size, points.startY + frameObj.size, points.width -
                        (2 * frameObj.size), points.height - (2 * frameObj.size));
                    ctx.fill('evenodd');
                    ctx.closePath();
                    break;
                case 'bevel':
                    ctx.filter = 'none';
                    ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
                    ctx.beginPath();
                    ctx.fillRect(points.startX, points.startY, points.width, points.height);
                    ctx.closePath();
                    points.startX += frameObj.size;
                    points.startY += frameObj.size;
                    points.width -= (2 * frameObj.size);
                    points.height -= (2 * frameObj.size);
                    while ((points.width - (2 * frameObj.size) < 40 ||
                        points.height - (2 * frameObj.size) < 40) && frameObj.size > 0) {
                        points.startX -= frameObj.size;
                        points.startY -= frameObj.size;
                        points.width += (2 * frameObj.size);
                        points.height += (2 * frameObj.size);
                        frameObj.size -= 20;
                        points.startX += frameObj.size;
                        points.startY += frameObj.size;
                        points.width -= (2 * frameObj.size);
                        points.height -= (2 * frameObj.size);
                    }
                    ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(points.startX + valueForty, points.startY);
                    ctx.lineTo(points.startX + points.width - valueForty, points.startY);
                    ctx.quadraticCurveTo(points.startX + points.width, points.startY, points.startX + points.width, points.startY + valueForty);
                    ctx.lineTo(points.startX + points.width, points.startY + points.height - valueForty);
                    ctx.quadraticCurveTo(points.startX + points.width, points.startY + points.height, points.startX + points.width - valueForty, points.startY + points.height);
                    ctx.lineTo(points.startX + valueForty, points.startY + points.height);
                    ctx.quadraticCurveTo(points.startX, points.startY + points.height, points.startX, points.startY + points.height
                        - valueForty);
                    ctx.lineTo(points.startX, points.startY + valueForty);
                    ctx.quadraticCurveTo(points.startX, points.startY, points.startX + valueForty, points.startY);
                    ctx.closePath();
                    ctx.clip();
                    ctx.filter = filter === 'none' ? parent.canvasFilter : filter;
                    if (ctx.canvas.id === parent.element.id + '_tempCanvas') {
                        preventImg = null;
                        ctx.filter = 'none';
                        ctx.drawImage(parent.inMemoryCanvas, 0, 0);
                        ctx.filter = filter === 'none' ? parent.canvasFilter : filter;
                    }
                    else {
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                        if (preventImg) {
                            preventImg = null;
                            if (parent.transform.zoomFactor !== 0) {
                                this.isRotateZoom = true;
                            }
                            parent.notify('filter', { prop: 'getBevelFilter', onPropertyChange: false, value: { obj: bevelObj } });
                            ctx.filter = bevelObj['bevelFilter'];
                            this.updateCurrTransState('initial');
                            this.drawImgToCtx(ctx, preventImg);
                            this.updateCurrTransState('reverse');
                            this.isRotateZoom = false;
                            parent.frameObj.type = 'none';
                            ctx.filter = 'none';
                            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                                value: { ctx: ctx, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
                            parent.frameObj.type = 'bevel';
                            ctx.filter = filter === 'none' ? parent.canvasFilter : filter;
                        }
                        else {
                            parent.notify('filter', { prop: 'getBevelFilter', onPropertyChange: false, value: { obj: bevelObj } });
                            ctx.filter = bevelObj['bevelFilter'];
                            this.drawImgToCtx(ctx, preventImg);
                        }
                    }
                    ctx.restore();
                    break;
                case 'line':
                    this.drawImgToCtx(ctx, preventImg);
                    tempLineWidth = ctx.lineWidth;
                    ctx.lineWidth = frameObj.size / 10;
                    for (var i = 0; i < parent.frameObj.amount; i++) {
                        if (i > 0) {
                            points.startX += frameObj.offset;
                            points.startY += frameObj.offset;
                            points.width -= (2 * frameObj.offset);
                            points.height -= (2 * frameObj.offset);
                        }
                        var arcY2 = points.startY + points.height - frameObj.inset - frameObj.radius;
                        var lineY = points.startY + frameObj.inset + frameObj.radius;
                        var arcX2 = points.startX + points.width - frameObj.inset - frameObj.radius;
                        var lineX = points.startX + frameObj.inset + frameObj.radius;
                        var arcX1 = points.startX + frameObj.inset + frameObj.radius;
                        var lineX2 = points.startX + points.width - frameObj.inset - frameObj.radius;
                        var arcY1 = points.startY + frameObj.inset + frameObj.radius;
                        var lineY2 = points.startY + points.height - frameObj.inset - frameObj.radius;
                        if (arcY2 >= lineY && arcX2 >= lineX && arcX1 <= lineX2 && arcY1 <= lineY2) {
                            ctx.filter = 'none';
                            ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
                            if (frameObj.border === 'dashed') {
                                ctx.setLineDash([ctx.lineWidth * 2.5, ctx.lineWidth * 1.5]);
                            }
                            else if (frameObj.border === 'dotted') {
                                ctx.setLineDash([ctx.lineWidth, ctx.lineWidth]);
                            }
                            ctx.beginPath();
                            ctx.moveTo(points.startX + frameObj.inset + frameObj.radius, points.startY + frameObj.inset);
                            ctx.lineTo(points.startX + points.width - frameObj.inset - frameObj.radius, points.startY + frameObj.inset);
                            ctx.arcTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset, points.startX + points.width - frameObj.inset, points.startY + frameObj.inset + frameObj.radius, frameObj.radius);
                            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset -
                                frameObj.radius);
                            ctx.arcTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset, points.startX + points.width - frameObj.inset - frameObj.radius, points.startY + points.height
                                - frameObj.inset, frameObj.radius);
                            ctx.lineTo(points.startX + frameObj.inset + frameObj.radius, points.startY + points.height - frameObj.inset);
                            ctx.arcTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset, points.startX + frameObj.inset, points.startY + points.height - frameObj.inset - frameObj.radius, frameObj.radius);
                            ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset + frameObj.radius);
                            ctx.arcTo(points.startX + frameObj.inset, points.startY + frameObj.inset, points.startX + frameObj.inset + frameObj.radius, points.startY + frameObj.inset, frameObj.radius);
                            ctx.closePath();
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                    }
                    ctx.lineWidth = tempLineWidth;
                    break;
                case 'inset':
                    this.drawImgToCtx(ctx, preventImg);
                    ctx.filter = 'none';
                    ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
                    tempLineWidth = ctx.lineWidth;
                    ctx.lineWidth = frameObj.size / 10;
                    ctx.beginPath();
                    ctx.moveTo(points.startX + frameObj.offset, points.startY + frameObj.inset);
                    ctx.lineTo(points.startX + points.width - frameObj.offset, points.startY + frameObj.inset);
                    ctx.moveTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.offset);
                    ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.offset);
                    ctx.moveTo(points.startX + points.width - frameObj.offset, points.startY + points.height - frameObj.inset);
                    ctx.lineTo(points.startX + frameObj.offset, points.startY + points.height - frameObj.inset);
                    ctx.moveTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.offset);
                    ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.offset);
                    ctx.stroke();
                    ctx.closePath();
                    ctx.lineWidth = tempLineWidth;
                    break;
                case 'hook':
                    this.drawImgToCtx(ctx, preventImg);
                    ctx.filter = 'none';
                    ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
                    tempLineWidth = ctx.lineWidth;
                    ctx.lineWidth = frameObj.size / 10;
                    ctx.beginPath();
                    ctx.moveTo(points.startX + frameObj.inset + valueFifty, points.startY + frameObj.inset);
                    ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset);
                    ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset + valueFifty);
                    ctx.moveTo(points.startX + points.width - frameObj.inset - valueFifty, points.startY + frameObj.inset);
                    ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset);
                    ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset + valueFifty);
                    ctx.moveTo(points.startX + points.width - frameObj.inset - valueFifty, points.startY + points.height - frameObj.inset);
                    ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset);
                    ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset - valueFifty);
                    ctx.moveTo(points.startX + frameObj.inset + valueFifty, points.startY + points.height - frameObj.inset);
                    ctx.lineTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset);
                    ctx.lineTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset - valueFifty);
                    ctx.stroke();
                    ctx.lineWidth = tempLineWidth;
                    break;
            }
            if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: ctx, isSave: ctx.canvas.id === parent.element.id + '_tempCanvas' ? true : null, isFlip: null } });
            }
            ctx.filter = filter;
        }
    };
    Draw.prototype.triggerFrameChange = function (prevFrameSettings) {
        var parent = this.parent;
        var currFrameSettings = { type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color, gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size,
            inset: parent.frameObj.inset, offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border), lineCount: parent.frameObj.amount };
        var frameChange = { cancel: false, previousFrameSetting: prevFrameSettings,
            currentFrameSetting: currFrameSettings };
        parent.trigger('frameChange', frameChange);
        parent.editCompleteArgs = frameChange;
        if (!frameChange.cancel) {
            this.setFrameObj(frameChange.currentFrameSetting);
        }
        return frameChange;
    };
    Draw.prototype.setFrameObj = function (currFrameSettings) {
        var parent = this.parent;
        parent.frameObj.type = currFrameSettings.type.toLowerCase();
        parent.frameObj.color = currFrameSettings.color;
        parent.frameObj.gradientColor = currFrameSettings.gradientColor;
        parent.frameObj.size = currFrameSettings.size;
        parent.frameObj.inset = currFrameSettings.inset;
        parent.frameObj.offset = currFrameSettings.offset;
        parent.frameObj.radius = currFrameSettings.borderRadius;
        parent.frameObj.border = currFrameSettings.frameLineStyle.toLowerCase();
        parent.frameObj.amount = currFrameSettings.lineCount;
    };
    Draw.prototype.zoomToSel = function (activeObj, isToolbar) {
        var parent = this.parent;
        if (this.straightenActObj && JSON.stringify(this.straightenActObj.activePoint) === JSON.stringify(activeObj.activePoint)) {
            parent.activeObj = extend({}, this.straightenActObj, null, true);
            this.allowRedactStraighten = false;
            if (parent.transform.straighten === 0) {
                var destWidth = parent.img.destWidth;
                var destHeight = parent.img.destHeight;
                parent.transform.straighten = 360;
                while (true) {
                    if (!isNullOrUndefined(this.straightenInitZoom) &&
                        (Math.round(parent.transform.zoomFactor * Math.pow(10, 3)) / Math.pow(10, 3)) >
                            (Math.round(this.straightenInitZoom * Math.pow(10, 3)) / Math.pow(10, 3))) {
                        this.setZoomPan('out');
                        if (destWidth === parent.img.destWidth && destHeight === parent.img.destHeight) {
                            this.performDummyZoom();
                            break;
                        }
                        if (parent.transform.degree === 0) {
                            parent.transform.zoomFactor -= 0.025;
                            parent.transform.cropZoomFactor -= 0.025;
                        }
                    }
                    else {
                        this.performDummyZoom();
                        break;
                    }
                }
                parent.transform.straighten = 0;
                parent.img = { destLeft: parent.img.destLeft, destTop: parent.img.destTop, destWidth: parent.img.destWidth,
                    destHeight: parent.img.destHeight, srcLeft: parent.img.srcLeft, srcTop: parent.img.srcTop,
                    srcWidth: parent.img.srcWidth, srcHeight: parent.img.srcHeight };
            }
            else {
                if (isNullOrUndefined(this.straightenInitZoom)) {
                    this.straightenInitZoom = parent.transform.zoomFactor;
                }
                if (this.straightenInitZoom - parent.transform.zoomFactor > 0) {
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: -(this.straightenInitZoom - parent.transform.zoomFactor), zoomPoint: null, isResize: true } });
                }
                else if (this.straightenInitZoom - parent.transform.zoomFactor < 0) {
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: (this.straightenInitZoom - parent.transform.zoomFactor), zoomPoint: null, isResize: true } });
                }
                parent.activeObj = extend({}, activeObj, null, true);
                parent.transform.zoomFactor += 0.001;
                this.calcStraightenedPoints(isToolbar);
            }
        }
        else {
            this.straightenActObj = extend({}, activeObj, null, true);
            parent.activeObj = extend({}, this.straightenActObj, null, true);
            this.straightenInitZoom = parent.transform.zoomFactor;
            this.calcStraightenedPoints(isToolbar);
        }
    };
    Draw.prototype.isDestPointSmall = function () {
        var parent = this.parent;
        var img = parent.img;
        var destPoints = { startX: img.destLeft, startY: img.destTop,
            width: img.destWidth, height: img.destHeight };
        parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });
        var isSmall = false;
        if (this.straightenDestPoints.destWidth && this.straightenDestPoints.destHeight &&
            (img.destWidth < this.straightenDestPoints.destWidth || img.destHeight < this.straightenDestPoints.destHeight)) {
            isSmall = true;
        }
        img.destLeft = destPoints.startX;
        img.destTop = destPoints.startY;
        img.destWidth = destPoints.width;
        img.destHeight = destPoints.height;
        parent.img = img;
        return isSmall;
    };
    Draw.prototype.calcStraightenedPoints = function (isToolbar) {
        var parent = this.parent;
        var destWidth = parent.img.destWidth;
        var destHeight = parent.img.destHeight;
        if (isNullOrUndefined(parent.transform.zoomFactor)) {
            parent.transform.zoomFactor += 0.025;
        }
        this.updateImgCanvasPoints();
        var _loop_1 = function () {
            if (this_1.isLinesIntersect() || this_1.isSelOutsideImg() || (isToolbar && this_1.isDestPointSmall())) {
                parent.activeObj = extend({}, this_1.straightenActObj, null, true);
                this_1.setZoomPan('in');
                if (destWidth === parent.img.destWidth && destHeight === parent.img.destHeight) {
                    this_1.performDummyZoom();
                    return "break";
                }
                if (parent.transform.degree === 0) {
                    parent.transform.zoomFactor += 0.025;
                    parent.transform.cropZoomFactor += 0.025;
                }
                var points = this_1.imgCanvasPoints;
                var left_1 = parent.img.destLeft;
                var top_1 = parent.img.destTop;
                var width_1 = parent.img.destWidth;
                var height_1 = parent.img.destHeight;
                points.forEach(function (point) {
                    point.x = (point.ratioX * width_1) + left_1;
                    point.y = (point.ratioY * height_1) + top_1;
                });
                this_1.imgCanvasPoints = points;
            }
            else {
                this_1.performDummyZoom();
                return "break";
            }
        };
        var this_1 = this;
        while (true) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
    };
    Draw.prototype.performDummyZoom = function () {
        var parent = this.parent;
        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
            value: { zoomFactor: 0.025, zoomPoint: null, isResize: true } });
        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
            value: { zoomFactor: -0.025, zoomPoint: null, isResize: true } });
        var zoom = parent.transform.zoomFactor * 10;
        if (zoom < 1) {
            zoom = 1 + (zoom / 10);
        }
        parent.setProperties({ zoomSettings: { zoomFactor: zoom } }, true);
        parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
            value: { previousZoomValue: zoom } });
        this.panToSel();
    };
    Draw.prototype.setZoomPan = function (type) {
        var parent = this.parent;
        var obj = { maxDimension: null };
        if (parent.transform.degree === 0) {
            parent.notify('transform', { prop: 'cropZoom', onPropertyChange: false,
                value: { value: type === 'in' ? 0.025 : -0.025, selectionObj: parent.activeObj, obj: obj } });
            parent.img.destWidth = obj['maxDimension']['width'];
            parent.img.destHeight = obj['maxDimension']['height'];
        }
        else {
            parent.transform.zoomFactor += (type === 'in' ? 0.025 : -0.025);
            parent.transform.cropZoomFactor += (type === 'in' ? 0.025 : -0.025);
            this.updateCurrTransState('initial');
            this.isRotateZoom = true;
            this.setDestPoints();
            this.isRotateZoom = false;
            this.updateCurrTransState('reverse');
        }
    };
    Draw.prototype.updateImgCanvasPoints = function () {
        var parent = this.parent;
        var points = this.getImagePoints();
        var obj = { width: 0, height: 0 };
        var width = parent.baseImgCanvas.width;
        var height = parent.baseImgCanvas.height;
        parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
            value: { obj: obj, dimension: { width: width, height: height } } });
        var ratio = obj;
        width = parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0 ?
            ratio.height : ratio.width;
        height = parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0 ?
            ratio.width : ratio.height;
        var p1;
        var p2;
        var p3;
        var p4;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (parent.transform.straighten > 0) {
            p1 = { x: destLeft + (points[0].x / width), y: destTop };
            p2 = { x: destLeft + destWidth, y: destTop + (points[1].y / height) };
            p3 = { x: destLeft + destWidth - (points[0].x / width), y: destTop + destHeight };
            p4 = { x: destLeft, y: destTop + destHeight - (points[1].y / height) };
        }
        else if (parent.transform.straighten < 0) {
            p1 = { x: destLeft, y: destTop + (points[0].y / height) };
            p2 = { x: destLeft + (points[1].x / width), y: destTop };
            p3 = { x: destLeft + destWidth, y: destTop + destHeight - (points[0].y / height) };
            p4 = { x: destLeft + destWidth - (points[1].x / width), y: destTop + destHeight };
        }
        else if (parent.transform.straighten === 0) {
            p1 = { x: destLeft, y: destTop };
            p2 = { x: destLeft + destWidth, y: destTop };
            p3 = { x: destLeft + destWidth, y: destTop + destHeight };
            p4 = { x: destLeft, y: destTop + destHeight };
        }
        p1.ratioX = (p1.x - destLeft) / destWidth;
        p1.ratioY = (p1.y - destTop) / destHeight;
        p2.ratioX = (p2.x - destLeft) / destWidth;
        p2.ratioY = (p2.y - destTop) / destHeight;
        p3.ratioX = (p3.x - destLeft) / destWidth;
        p3.ratioY = (p3.y - destTop) / destHeight;
        p4.ratioX = (p4.x - destLeft) / destWidth;
        p4.ratioY = (p4.y - destTop) / destHeight;
        this.imgCanvasPoints = [p1, p2, p3, p4];
    };
    Draw.prototype.isLinesIntersect = function (obj) {
        var parent = this.parent;
        var point = parent.activeObj.activePoint;
        if (parent.activeObj.rotatedAngle !== 0) {
            var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
            var center = { x: startX + (width / 2), y: startY +
                    (height / 2) };
            var cosAngle = Math.cos(parent.activeObj.rotatedAngle);
            var sinAngle = Math.sin(parent.activeObj.rotatedAngle);
            var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
                y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };
            var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
                y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };
            var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
                y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };
            var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
                y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };
            var imgPoints_1 = this.imgCanvasPoints;
            var isTopIntersect_1 = this.doIntersect(p1, p2, imgPoints_1[0], imgPoints_1[1]);
            var isRightIntersect_1 = this.doIntersect(p2, p4, imgPoints_1[1], imgPoints_1[2]);
            var isBottomIntersect_1 = this.doIntersect(p3, p4, imgPoints_1[2], imgPoints_1[3]);
            var isLeftIntersect_1 = this.doIntersect(p1, p3, imgPoints_1[3], imgPoints_1[0]);
            if (obj) {
                obj['arr'] = [isTopIntersect_1, isRightIntersect_1, isBottomIntersect_1, isLeftIntersect_1];
            }
            return isTopIntersect_1 || isRightIntersect_1 || isBottomIntersect_1 || isLeftIntersect_1;
        }
        var imgPoints = this.imgCanvasPoints;
        var isTopIntersect = this.doIntersect({ x: point.startX, y: point.startY }, { x: point.endX, y: point.startY }, imgPoints[0], imgPoints[1]);
        var isRightIntersect = this.doIntersect({ x: point.endX, y: point.startY }, { x: point.endX, y: point.endY }, imgPoints[1], imgPoints[2]);
        var isBottomIntersect = this.doIntersect({ x: point.startX, y: point.endY }, { x: point.endX, y: point.endY }, imgPoints[2], imgPoints[3]);
        var isLeftIntersect = this.doIntersect({ x: point.startX, y: point.startY }, { x: point.startX, y: point.endY }, imgPoints[3], imgPoints[0]);
        var isTopLeftInsideRect = this.isInsideRect(imgPoints[0]);
        var isTopRightInsideRect = this.isInsideRect(imgPoints[1]);
        var isBottomRightInsideRect = this.isInsideRect(imgPoints[2]);
        var isBottomLeftInsideRect = this.isInsideRect(imgPoints[3]);
        if (obj) {
            obj['arr'] = [isTopIntersect, isRightIntersect, isBottomIntersect, isLeftIntersect];
        }
        return isTopIntersect || isRightIntersect || isBottomIntersect || isLeftIntersect ||
            isTopLeftInsideRect || isTopRightInsideRect || isBottomRightInsideRect || isBottomLeftInsideRect ||
            (imgPoints[0].x > point.startX && imgPoints[1].x < point.endX &&
                imgPoints[2].x < point.endX && imgPoints[3].x > point.startX &&
                imgPoints[0].y < point.startY && imgPoints[1].y < point.startY &&
                imgPoints[2].y > point.endY && imgPoints[3].y > point.endY) ||
            (imgPoints[0].x < point.startX && imgPoints[1].x > point.endX &&
                imgPoints[2].x > point.endX && imgPoints[3].x < point.startX &&
                imgPoints[0].y > point.startY && imgPoints[1].y > point.startY &&
                imgPoints[2].y < point.endY && imgPoints[3].y < point.endY);
    };
    Draw.prototype.isSelOutsideImg = function () {
        var parent = this.parent;
        var points = this.imgCanvasPoints;
        var actPoint = parent.activeObj.activePoint;
        return (this.checkPointPosition(actPoint.startX, actPoint.startY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== 'inside' ||
            this.checkPointPosition(actPoint.endX, actPoint.startY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== 'inside' ||
            this.checkPointPosition(actPoint.startX, actPoint.endY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== 'inside' ||
            this.checkPointPosition(actPoint.endX, actPoint.endY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== 'inside');
    };
    Draw.prototype.calcTriangleArea = function (x1, y1, x2, y2, x3, y3) {
        return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);
    };
    Draw.prototype.checkPointPosition = function (x, y, x1, y1, x2, y2, x3, y3, x4, y4) {
        var area1 = this.calcTriangleArea(x, y, x1, y1, x4, y4);
        var area2 = this.calcTriangleArea(x, y, x4, y4, x3, y3);
        var area3 = this.calcTriangleArea(x, y, x3, y3, x2, y2);
        var area4 = this.calcTriangleArea(x, y, x2, y2, x1, y1);
        var areaRectangle = this.calcTriangleArea(x1, y1, x2, y2, x3, y3) + this.calcTriangleArea(x3, y3, x4, y4, x1, y1);
        if (area1 + area2 + area3 + area4 > areaRectangle) {
            return 'outside';
        }
        else if (area1 + area2 + area3 + area4 === areaRectangle && (area1 === 0 || area2 === 0 || area3 === 0 || area4 === 0)) {
            return 'on';
        }
        else {
            return 'inside';
        }
    };
    Draw.prototype.getImagePoints = function () {
        var point = [];
        var parent = this.parent;
        var degree = parent.transform.degree;
        var width = parent.baseImg.width;
        var height = parent.baseImg.height;
        var obj = { dim: null, width: height, height: width, angle: parent.transform.straighten };
        obj['dim'] = parent.getRotatedCanvasDim(obj['width'], obj['height'], obj['angle']);
        var baseImgCanvasWidth = degree % 90 === 0 && degree % 180 !== 0 ? obj['dim']['width'] : parent.baseImgCanvas.width;
        var baseImgCanvasHeight = degree % 90 === 0 && degree % 180 !== 0 ? obj['dim']['height'] : parent.baseImgCanvas.height;
        var baseImgWidth = degree % 90 === 0 && degree % 180 !== 0 ? height : width;
        var baseImgHeight = degree % 90 === 0 && degree % 180 !== 0 ? width : height;
        var centerX = baseImgCanvasWidth / 2;
        var centerY = baseImgCanvasHeight / 2;
        var startX = centerX - (baseImgWidth / 2);
        var startY = centerY - (baseImgHeight / 2);
        var endX = centerX + (baseImgWidth / 2);
        var endY = centerY + (baseImgHeight / 2);
        var center = { x: centerX, y: centerY };
        var radians = parent.transform.straighten * (Math.PI / 180);
        var p1 = { x: Math.cos(radians) * (startX - center.x) - Math.sin(radians) * (startY - center.y) + center.x,
            y: Math.sin(radians) * (startX - center.x) + Math.cos(radians) * (startY - center.y) + center.y };
        var p2 = { x: Math.cos(radians) * (endX - center.x) - Math.sin(radians) * (startY - center.y) + center.x,
            y: Math.sin(radians) * (endX - center.x) + Math.cos(radians) * (startY - center.y) + center.y };
        var p3 = { x: Math.cos(radians) * (endX - center.x) - Math.sin(radians) * (endY - center.y) + center.x,
            y: Math.sin(radians) * (endX - center.x) + Math.cos(radians) * (endY - center.y) + center.y };
        var p4 = { x: Math.cos(radians) * (startX - center.x) - Math.sin(radians) * (endY - center.y) + center.x,
            y: Math.sin(radians) * (startX - center.x) + Math.cos(radians) * (endY - center.y) + center.y };
        point.push(p1);
        point.push(p2);
        point.push(p3);
        point.push(p4);
        return point;
    };
    Draw.prototype.doIntersect = function (a, b, c, d) {
        var point1 = this.initiation(a, b, c);
        var point2 = this.initiation(a, b, d);
        var point3 = this.initiation(c, d, a);
        var point4 = this.initiation(c, d, b);
        if (point1 !== point2 && point3 !== point4) {
            return true;
        }
        if (point1 === 0 && this.onSegment(a, c, b)) {
            return true;
        }
        if (point2 === 0 && this.onSegment(a, d, b)) {
            return true;
        }
        if (point3 === 0 && this.onSegment(c, a, d)) {
            return true;
        }
        if (point4 === 0 && this.onSegment(c, b, d)) {
            return true;
        }
        return false;
    };
    Draw.prototype.initiation = function (a, b, c) {
        var value = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
        if (value === 0) {
            return 0;
        }
        return (value > 0) ? 1 : 2;
    };
    Draw.prototype.onSegment = function (a, b, c) {
        if (b.x <= Math.max(a.x, c.x) && b.x >= Math.min(a.x, c.x) &&
            b.y <= Math.max(a.y, c.y) && b.y >= Math.min(a.y, c.y)) {
            return true;
        }
        return false;
    };
    Draw.prototype.isInsideRect = function (point) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var isInside = false;
        if (point.x >= actPoint.startX && point.x <= actPoint.endX &&
            point.y >= actPoint.startY && point.y <= actPoint.endY) {
            isInside = true;
        }
        return isInside;
    };
    Draw.prototype.setDestForStraighten = function () {
        var parent = this.parent;
        if (isNullOrUndefined(this.straightenDestPoints)) {
            var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
            // If straightening performed, then destination points are set in non-straightened state
            parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });
            this.straightenDestPoints = extend({}, parent.img, {}, true);
            parent.img.destLeft = destLeft;
            parent.img.destTop = destTop;
            parent.img.destWidth = destWidth;
            parent.img.destHeight = destHeight;
        }
    };
    Draw.prototype.drawRedact = function (canvasDraw, obj) {
        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var _b = obj.activePoint, width = _b.width, height = _b.height;
        var isSaveCtx = false;
        var canvas = canvasDraw.canvas;
        if (canvas.id.indexOf('_tempCanvas') !== -1) {
            isSaveCtx = true;
        }
        var img = this.parent.img;
        if (width <= 0 || height <= 0) {
            return;
        }
        else if (this.parent.isCropTab) {
            canvasDraw.drawImage(obj.redactImage, 0, 0, obj.redactImage.width, obj.redactImage.height, startX, startY, width, height);
        }
        else {
            var offscreenCanvas = document.createElement('canvas');
            var offscreenCtx = offscreenCanvas.getContext('2d');
            var imageWidth = canvas.width;
            var imageHeight = canvas.height;
            var tempRatio = Math.min(imageWidth, imageHeight) / 1000;
            var straighten = this.parent.transform.straighten !== 0 ? this.parent.transform.straighten :
                this.parent.cropObj.straighten;
            if (this.allowRedactStraighten && straighten !== 0) {
                var tempCanvas = document.createElement('canvas');
                var tempCtx = tempCanvas.getContext('2d');
                if (isSaveCtx) {
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    tempCtx.drawImage(canvas, 0, 0);
                }
                else {
                    tempCanvas.width = img.destWidth;
                    tempCanvas.height = img.destHeight;
                    tempCtx.drawImage(this.lowerContext.canvas, img.destLeft, img.destTop, img.destWidth, img.destHeight, 0, 0, img.destWidth, img.destHeight);
                }
                var radians = -straighten * Math.PI / 180;
                var straightenCanvas = document.createElement('canvas');
                var straightenCtx = straightenCanvas.getContext('2d');
                straightenCanvas.width = tempCanvas.width;
                straightenCanvas.height = tempCanvas.height;
                if (img.destWidth > canvas.width && !isSaveCtx) {
                    straightenCanvas.width = canvas.width;
                }
                if (img.destHeight > canvas.height && !isSaveCtx) {
                    straightenCanvas.height = canvas.height;
                }
                straightenCtx.save();
                straightenCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                straightenCtx.rotate(radians);
                straightenCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
                straightenCtx.restore();
                if (img.destLeft > 0 && !isSaveCtx) {
                    startX -= img.destLeft;
                    endX -= img.destLeft;
                }
                if (img.destTop > 0 && !isSaveCtx) {
                    startY -= img.destTop;
                    endY -= img.destTop;
                }
                var center = { x: startX + (width / 2), y: startY + (height / 2) };
                var cosAngle = Math.cos(straighten * Math.PI / 180);
                var sinAngle = Math.sin(straighten * Math.PI / 180);
                var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
                    y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };
                var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
                    y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };
                var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
                    y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };
                if (!isSaveCtx) {
                    center = { x: img.destWidth / 2, y: img.destHeight / 2 };
                    if (img.destWidth > canvas.width) {
                        center.x = canvas.width / 2;
                    }
                    if (img.destHeight > canvas.height) {
                        center.y = canvas.height / 2;
                    }
                }
                else {
                    center = { x: canvas.width / 2, y: canvas.height / 2 };
                }
                cosAngle = Math.cos(radians);
                sinAngle = Math.sin(radians);
                var newP1 = { x: cosAngle * (p1.x - center.x) - sinAngle * (p1.y - center.y) + center.x,
                    y: sinAngle * (p1.x - center.x) + cosAngle * (p1.y - center.y) + center.y };
                var newP2 = { x: cosAngle * (p2.x - center.x) - sinAngle * (p2.y - center.y) + center.x,
                    y: sinAngle * (p2.x - center.x) + cosAngle * (p2.y - center.y) + center.y };
                var newP3 = { x: cosAngle * (p3.x - center.x) - sinAngle * (p3.y - center.y) + center.x,
                    y: sinAngle * (p3.x - center.x) + cosAngle * (p3.y - center.y) + center.y };
                var tempWidth = isSaveCtx ? canvasDraw.canvas.width : img.destWidth;
                var tempHeight = isSaveCtx ? canvasDraw.canvas.height : img.destHeight;
                var rotatedWidth = Math.abs(tempWidth * Math.cos(radians)) + Math.abs(tempHeight * Math.sin(radians));
                var rotatedHeight = Math.abs(tempWidth * Math.sin(radians)) + Math.abs(tempHeight * Math.cos(radians));
                straightenCanvas.width = rotatedWidth;
                straightenCanvas.height = rotatedHeight;
                straightenCtx.save();
                straightenCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
                straightenCtx.rotate(radians);
                straightenCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
                straightenCtx.restore();
                if (this.parent.activeObj.redactType === 'blur') {
                    offscreenCanvas.width = width;
                    offscreenCanvas.height = height;
                    offscreenCtx.drawImage(straightenCanvas, newP1.x + ((rotatedWidth - tempCanvas.width) / 2), newP1.y + ((rotatedHeight - tempCanvas.height) / 2), newP2.x - newP1.x, newP3.y - newP2.y, 0, 0, width, height);
                }
                else {
                    var pixelSize = (obj.redactPixelate / 100) * 20;
                    if (isSaveCtx) {
                        pixelSize = tempRatio * (obj.redactPixelate / 100) * 35;
                    }
                    offscreenCanvas.width = Math.ceil(width / pixelSize);
                    offscreenCanvas.height = Math.ceil(height / pixelSize);
                    offscreenCtx.drawImage(straightenCanvas, newP1.x + ((rotatedWidth - tempCanvas.width) / 2), newP1.y + ((rotatedHeight - tempCanvas.height) / 2), newP2.x - newP1.x, newP3.y - newP2.y, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
                }
            }
            if (this.parent.activeObj.redactType === 'blur') {
                if (straighten === 0) {
                    offscreenCanvas.width = width;
                    offscreenCanvas.height = height;
                    offscreenCtx.drawImage((isSaveCtx) ? canvas : this.lowerContext.canvas, startX, startY, width, height, 0, 0, width, height);
                }
                if (isSaveCtx) {
                    var blur_1 = tempRatio * ((obj.redactBlur / 100) * 34);
                    offscreenCtx.filter = "blur(" + blur_1 + "px)";
                }
                else {
                    offscreenCtx.filter = "blur(" + (obj.redactBlur / 100) * 17 + "px)";
                }
                offscreenCtx.drawImage(offscreenCanvas, 0, 0);
                if (straighten === 0) {
                    offscreenCtx.drawImage((isSaveCtx) ? canvas : this.lowerContext.canvas, startX, startY, width, height, 0, 0, width, height);
                }
                else {
                    if (img.destLeft > 0 && !isSaveCtx) {
                        startX += img.destLeft;
                        endX += img.destLeft;
                    }
                    if (img.destTop > 0 && !isSaveCtx) {
                        startY += img.destTop;
                        endY += img.destTop;
                    }
                }
                if (this.parent.isSafari) {
                    this.parent.notify('filter', { prop: 'apply-filter', onPropertyChange: false, value: { context: offscreenCtx } });
                }
                canvasDraw.drawImage(offscreenCanvas, 0, 0, width, height, startX, startY, width, height);
            }
            else {
                var pixelSize = (obj.redactPixelate / 100) * 20;
                if (isSaveCtx) {
                    pixelSize = tempRatio * (obj.redactPixelate / 100) * 35;
                }
                if (straighten === 0) {
                    offscreenCanvas.width = Math.ceil(width / pixelSize);
                    offscreenCanvas.height = Math.ceil(height / pixelSize);
                    offscreenCtx.drawImage((isSaveCtx) ? canvas : this.lowerContext.canvas, startX, startY, width, height, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
                }
                else {
                    if (img.destLeft > 0 && !isSaveCtx) {
                        startX += img.destLeft;
                        endX += img.destLeft;
                    }
                    if (img.destTop > 0 && !isSaveCtx) {
                        startY += img.destTop;
                        endY += img.destTop;
                    }
                }
                canvasDraw.imageSmoothingEnabled = false;
                canvasDraw.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, startX, startY, width, height);
            }
            obj.redactImage = this.parent.createElement('canvas');
            obj.redactImage.width = offscreenCanvas.width;
            obj.redactImage.height = offscreenCanvas.height;
            obj.redactImage.getContext('2d').drawImage(offscreenCanvas, 0, 0);
            canvasDraw.beginPath();
            canvasDraw.rect(startX, startY, width, height);
            canvasDraw.rect(startX, startY, width, height);
            canvasDraw.fill('evenodd');
            canvasDraw.closePath();
        }
    };
    return Draw;
}());

/* eslint-disable max-len */
var Export = /** @class */ (function () {
    function Export(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    Export.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    Export.prototype.addEventListener = function () {
        this.parent.on('export', this.export, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    Export.prototype.removeEventListener = function () {
        this.parent.off('export', this.export);
        this.parent.off('destroyed', this.destroy);
    };
    Export.prototype.export = function (args) {
        this.parent.notify('toolbar', { prop: 'refreshShapeDrawing', onPropertyChange: false });
        this.updatePvtVar();
        switch (args.prop) {
            case 'export':
                this.exportImg(args.value['type'], args.value['fileName'], args.value['imgQuality']);
                break;
            case 'exportToCanvas':
                this.exportToCanvas(args.value['object']);
                break;
            case 'updateSaveContext':
                this.updateSaveContext(args.value['context']);
                break;
            case 'setImageQuality':
                this.imageQuality = args.value['value'];
                break;
            case 'drawAnnotation':
                this.drawAnnotation(args.value['context'], args.value['ratio']);
                break;
        }
    };
    Export.prototype.getModuleName = function () {
        return 'export';
    };
    Export.prototype.updatePvtVar = function () {
        var parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
    };
    Export.prototype.exportImg = function (type, fileName, imgQuality) {
        var parent = this.parent;
        var obj = { fileName: '' };
        parent.notify('draw', { prop: 'getFileName', onPropertyChange: false, value: { obj: obj } });
        var imageName = obj['fileName'];
        if (!parent.disabled && parent.isImageLoaded) {
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
            var obj_1 = { canvasFilter: this.parent.canvasFilter };
            this.lowerContext.filter = obj_1['canvasFilter'];
            type = type ? type : 'Png';
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            var beforeSave = { cancel: false, fileName: fileName ? fileName : imageName,
                fileType: type, imageQuality: imgQuality };
            parent.trigger('beforeSave', beforeSave);
            this.beforeSaveEvent(beforeSave, type, fileName, imageName, imgQuality);
        }
    };
    Export.prototype.beforeSaveEvent = function (observableSaveArgs, type, fileName, imageName, imgQuality) {
        var parent = this.parent;
        if (!observableSaveArgs.cancel) {
            parent.currObjType.isSave = true;
            fileName = observableSaveArgs.fileName ? observableSaveArgs.fileName : fileName;
            var lowerCaseType = type.toLowerCase();
            fileName = fileName || imageName;
            if (lowerCaseType === 'svg') {
                this.toSVGImg(fileName);
            }
            else {
                this.toBlobFn(fileName, lowerCaseType, imgQuality);
            }
            var saved = { fileName: fileName ? fileName : imageName, fileType: type };
            parent.trigger('saved', saved);
            var actionArgs = { action: 'save', actionEventArgs: saved };
            parent.triggerEditCompleteEvent(actionArgs);
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            parent.lowerCanvas.style.left = parent.upperCanvas.style.left = '';
            parent.lowerCanvas.style.top = parent.upperCanvas.style.top = '';
            parent.lowerCanvas.style.maxWidth = parent.upperCanvas.style.maxWidth = '';
            parent.lowerCanvas.style.maxHeight = parent.upperCanvas.style.maxHeight = '';
        }
    };
    Export.prototype.toSVGImg = function (fileName) {
        var parent = this.parent;
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        var tempCanvas = this.exportToCanvas();
        var dataUrl = tempCanvas.toDataURL();
        hideSpinner(parent.element);
        parent.element.style.opacity = '1';
        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', tempCanvas.style.maxWidth);
        svg.setAttribute('height', tempCanvas.style.maxHeight);
        var XLinkNS = 'http://www.w3.org/1999/xlink';
        var img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        img.setAttributeNS(null, 'height', tempCanvas.height.toString());
        img.setAttributeNS(null, 'width', tempCanvas.width.toString());
        img.setAttributeNS(XLinkNS, 'xlink:href', dataUrl);
        svg.appendChild(img);
        var prefix = 'data:image/svg+xml;base64,';
        var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"'
            + (" width=\"" + tempCanvas.width + "\"") + (" height=\"" + tempCanvas.height + "\"") + '>';
        var footer = '</svg>';
        var body = svg.innerHTML;
        var data = header + body + footer;
        var svgDataUrl = prefix + btoa(data);
        if (fileName === null) {
            return svgDataUrl;
        }
        else {
            this.downloadImg(svgDataUrl, fileName + '.' + 'svg');
            return null;
        }
    };
    Export.prototype.toBlobFn = function (fileName, type, imgQuality) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        var parent = this.parent;
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        if (!isNullOrUndefined(imgQuality)) {
            imgQuality = imgQuality > 1 ? 1 : (imgQuality <= 0 ? 0.01 : imgQuality);
            this.imageQuality = imgQuality ? imgQuality : null;
        }
        var tempCanvas = this.exportToCanvas();
        var imagetype = (type === 'jpeg' ? 'image/jpeg' : (type === 'webp' ? 'image/webp' : 'image/png'));
        // eslint-disable-next-line @typescript-eslint/tslint/config
        tempCanvas.toBlob(function (blob) {
            var blobUrl = URL.createObjectURL(blob);
            proxy.downloadImg(blobUrl, fileName + '.' + type);
            hideSpinner(parent.element);
            parent.element.style.opacity = '1';
        }, imagetype, this.imageQuality ? this.imageQuality : null);
    };
    Export.prototype.exportToCanvas = function (object) {
        var parent = this.parent;
        var width;
        var height;
        var tempCropObj = extend({}, parent.cropObj, {}, true);
        var tempObj = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: tempObj } });
        var prevObj = tempObj['currObj'];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        if (this.parent.aspectWidth) {
            parent.notify('undo-redo', { prop: 'setPreventUR', value: { bool: true } });
            parent.notify('toolbar', { prop: 'resizeClick', value: { bool: false } });
            parent.okBtn();
            if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
                width = this.parent.aspectHeight;
                height = this.parent.aspectWidth;
            }
            else {
                width = this.parent.aspectWidth;
                height = this.parent.aspectHeight;
            }
            parent.notify('undo-redo', { prop: 'setPreventUR', value: { bool: false } });
        }
        else if (parent.currSelectionPoint) {
            width = parent.img.srcWidth;
            height = parent.img.srcHeight;
        }
        else {
            width = parent.baseImgCanvas.width;
            height = parent.baseImgCanvas.height;
        }
        var obj = { width: 0, height: 0 };
        parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
            value: { obj: obj, dimension: { width: width, height: height } } });
        var ratio = obj;
        var tempContextFilter = this.lowerContext.filter;
        // Manipulating blur value
        if (this.lowerContext.filter !== 'none') {
            var splitWords = this.lowerContext.filter.split(' ');
            var value = parseFloat(splitWords[5].split('(')[1]);
            value *= ((ratio.width + ratio.height) / 2);
            splitWords[5] = 'blur(' + value + 'px)';
            this.lowerContext.filter = splitWords.join(' ');
        }
        var tempCanvas = parent.createElement('canvas', {
            id: parent.element.id + '_tempCanvas', attrs: { name: 'canvasImage' }
        });
        var tempContext = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        var dimObj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: width, height: height, obj: dimObj } });
        var maxDimension = dimObj;
        tempCanvas.style.maxWidth = maxDimension.width + 'px';
        tempCanvas.style.maxHeight = maxDimension.height + 'px';
        var temp = this.lowerContext.filter;
        tempContext.filter = this.lowerContext.filter;
        this.downScaleImgCanvas(tempContext, width, height);
        this.lowerContext.filter = temp;
        if (parent.transform.degree !== 0 || parent.transform.currFlipState !== '' || parent.transform.straighten !== 0) {
            this.updateSaveContext(tempContext);
            this.exportTransformedImage(tempContext);
        }
        if (parent.isSafari) {
            parent.notify('filter', { prop: 'apply-filter', onPropertyChange: false, value: { context: tempContext } });
        }
        this.drawAnnotation(tempContext, ratio);
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: tempContext, isSave: true, isFlip: null } });
        }
        this.updateFrame(tempContext, true);
        this.lowerContext.filter = tempContextFilter;
        parent.canvasFilter = tempContextFilter;
        if (object) {
            object['canvas'] = tempCanvas;
        }
        if (parent.aspectWidth) {
            parent.objColl = [];
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                value: { obj: { selPointColl: [] } } });
            parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: prevObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                value: { obj: { selPointColl: prevObj.selPointColl } } });
            parent.cropObj = tempCropObj;
            parent.objColl = extend([], prevObj.objColl, [], true);
            parent.pointColl = extend([], prevObj.pointColl, [], true);
            parent.freehandCounter = parent.pointColl.length;
            parent.transform.straighten = 0;
            this.lowerContext.filter = 'none';
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            this.lowerContext.filter = prevObj.filter;
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
        }
        return tempCanvas;
    };
    Export.prototype.drawAnnotation = function (tempContext, ratio) {
        var parent = this.parent;
        var tempObjColl = extend([], parent.objColl, [], true);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var tempPointColl = extend([], parent.pointColl, [], true);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var nonRedact = parent.shapeColl.filter(function (item) { return item.shape !== 'redact'; });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var redact = parent.shapeColl.filter(function (item) { return item.shape === 'redact'; });
        parent.shapeColl = redact.concat(nonRedact);
        for (var i = 0; i < parent.shapeColl.length; i++) {
            if (parent.shapeColl[i].order) {
                if (parent.shapeColl[i].currIndex && parent.shapeColl[i].currIndex.indexOf('shape') > -1) {
                    parent.objColl = [];
                    parent.objColl.push(extend({}, parent.shapeColl[i], {}, true));
                    this.drawShape(tempContext, ratio);
                }
                else if (parent.shapeColl[i].id && parent.shapeColl[i].id.indexOf('pen') > -1) {
                    parent.pointColl = [];
                    parent.freehandCounter = 0;
                    parent.pointColl.push(extend({}, parent.shapeColl[i], {}, true));
                    parent.freehandCounter = parent.pointColl.length;
                    this.drawPen(tempContext, ratio);
                }
            }
        }
        parent.objColl = tempObjColl;
        parent.pointColl = tempPointColl;
        parent.freehandCounter = parent.pointColl.length;
    };
    Export.prototype.drawShape = function (tempContext, ratio) {
        var parent = this.parent;
        if (parent.objColl.length > 0) {
            var temp = tempContext.filter;
            tempContext.filter = 'none';
            var indexObj = { index: null };
            parent.notify('shape', { prop: 'getSmallestIndex', onPropertyChange: false, value: { obj: indexObj } });
            var index = indexObj['index'];
            var objColl = extend([], parent.objColl, [], true);
            var tempObjColl = extend([], parent.objColl, [], true);
            while (objColl.length > 0) {
                var found = false;
                for (var i = 0; i < objColl.length; i++) {
                    var currentObj = objColl[i];
                    if (isNullOrUndefined(currentObj.order)) {
                        objColl.splice(i, 1);
                        i--;
                        continue;
                    }
                    if (currentObj.order === index) {
                        var temp_1 = tempContext.filter;
                        tempContext.filter = 'none';
                        var currObj = objColl[i];
                        var activePoint = currObj.activePoint;
                        // Subtracting destination left and top points
                        activePoint.startX -= parent.img.destLeft;
                        activePoint.startY -= parent.img.destTop;
                        activePoint.endX -= parent.img.destLeft;
                        activePoint.endY -= parent.img.destTop;
                        activePoint.width = activePoint.endX - activePoint.startX;
                        activePoint.height = activePoint.endY - activePoint.startY;
                        // Manipulating points
                        activePoint.startX *= ratio.width;
                        activePoint.startY *= ratio.height;
                        activePoint.endX *= ratio.width;
                        activePoint.endY *= ratio.height;
                        activePoint.width = activePoint.endX - activePoint.startX;
                        activePoint.height = activePoint.endY - activePoint.startY;
                        currObj.strokeSettings.strokeWidth *= ((ratio.width + ratio.height) / 2);
                        if (currObj.shape === 'text') {
                            currObj.textSettings.fontSize *= ((ratio.width + ratio.height) / 2);
                        }
                        else if (currObj.shape === 'path') {
                            for (var l = 0; l < currObj.pointColl.length; l++) {
                                currObj.pointColl[l].x =
                                    (currObj.pointColl[l].x - parent.img.destLeft) * ratio.width;
                                currObj.pointColl[l].y =
                                    (currObj.pointColl[l].y - parent.img.destTop) * ratio.height;
                            }
                        }
                        else if (currObj.shape === 'image') {
                            parent.activeObj = extend({}, objColl[i], {}, true);
                            parent.notify('selection', { prop: 'upgradeImageQuality', onPropertyChange: false });
                            objColl[i] = extend({}, parent.activeObj, {}, true);
                        }
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'saveContext', obj: objColl[i], isCropRatio: null,
                                points: null, isPreventDrag: true, saveContext: tempContext, isPreventSelection: null } });
                        tempContext.filter = temp_1;
                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                        index++;
                        var indexBool = { bool: false };
                        parent.notify('shape', { prop: 'isIndexInObjColl', onPropertyChange: false, value: { obj: indexBool, index: index } });
                        if (!indexBool['bool']) {
                            index++;
                        }
                        objColl.splice(i, 1);
                        found = true;
                        break; // Exit the loop to start from the beginning
                    }
                }
                if (!found) {
                    break; // If no matching order was found, exit the loop
                }
            }
            tempContext.filter = temp;
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.objColl = tempObjColl;
        }
    };
    Export.prototype.drawPen = function (tempContext, ratio) {
        var parent = this.parent;
        if (parent.freehandCounter > 0) {
            var widthObj = { penStrokeWidth: null };
            parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: widthObj } });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var tempPointColl = extend({}, parent.pointColl, {}, true);
            for (var n = 0; n < parent.freehandCounter; n++) {
                parent.points = extend([], parent.pointColl[n].points, []);
                parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });
                var len = parent.points.length;
                parent.pointColl[n].strokeWidth *= ((ratio.width + ratio.height) / 2);
                for (var l = 0; l < len; l++) {
                    parent.points[l].x = (parent.points[l].x - parent.img.destLeft) * ratio.width;
                    parent.points[l].y = (parent.points[l].y - parent.img.destTop) * ratio.height;
                }
            }
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: tempContext, points: null } });
            parent.pointColl = tempPointColl;
            parent.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: widthObj['penStrokeWidth'] } });
        }
    };
    Export.prototype.downScaleImgCanvas = function (ctx, width, height) {
        var parent = this.parent;
        var canvas = parent.baseImgCanvas;
        var img = parent.baseImg;
        var obj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: img.width, height: img.height, obj: obj, isImgShape: null } });
        var bgObj = { color: null };
        parent.notify('draw', { prop: 'getImageBackgroundColor', value: { obj: bgObj } });
        if (bgObj['color'] !== '') {
            ctx.fillStyle = bgObj['color'];
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }
        if (obj['width'] > width && obj['height'] > height) {
            var tempCanvas = parent.createElement('canvas', {
                id: parent.element.id + '_downScaleCanvas', attrs: { name: 'canvasImage' }
            });
            tempCanvas.width = this.parent.img.srcWidth;
            tempCanvas.height = this.parent.img.srcHeight;
            tempCanvas.getContext('2d').drawImage(canvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, tempCanvas.width, tempCanvas.height);
            parent.notify('draw', { prop: 'downScale', value: { canvas: tempCanvas, width: width, height: height } });
            ctx.drawImage(tempCanvas, 0, 0);
        }
        else {
            ctx.drawImage(parent.baseImgCanvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, width, height);
        }
    };
    Export.prototype.updateFrame = function (tempContext, isAnnotation) {
        if (this.parent.frameObj.type !== 'none') {
            var temp = tempContext.filter;
            tempContext.filter = 'none';
            this.parent.notify('draw', { prop: 'applyFrame', value: { ctx: tempContext, frame: this.parent.frameObj.type, preventImg: isAnnotation } });
            tempContext.filter = temp;
        }
    };
    Export.prototype.downloadImg = function (blob, fileName) {
        var a = document.createElement('a');
        a.href = blob;
        a.target = '_parent';
        a.download = fileName;
        (document.body || document.documentElement).appendChild(a);
        a.click();
        a.parentNode.removeChild(a);
    };
    Export.prototype.exportTransformedImage = function (tempContext) {
        var parent = this.parent;
        var degree = parent.transform.degree;
        if (parent.rotateFlipColl.length > 0) {
            for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var flip = parent.rotateFlipColl[i];
                if (typeof flip === 'number') {
                    this.exportRotate(tempContext, flip);
                }
                else if (flip === 'horizontal') {
                    this.exportFlip(tempContext, true, false);
                }
                else if (flip === 'vertical') {
                    this.exportFlip(tempContext, false, true);
                }
            }
        }
        parent.transform.degree = degree;
    };
    Export.prototype.exportRotate = function (tempContext, degree) {
        var parent = this.parent;
        tempContext.clearRect(0, 0, tempContext.canvas.width, tempContext.canvas.height);
        this.setMaxDim(parent.transform.degree, tempContext.canvas);
        tempContext.translate(tempContext.canvas.width / 2, tempContext.canvas.height / 2);
        tempContext.rotate(Math.PI / 180 * degree);
        tempContext.drawImage(parent.inMemoryCanvas, -tempContext.canvas.height / 2, -tempContext.canvas.width / 2, tempContext.canvas.height, tempContext.canvas.width);
        this.updateSaveContext(tempContext);
    };
    Export.prototype.exportFlip = function (tempContext, flipHorizontal, flipVertical) {
        tempContext.clearRect(0, 0, tempContext.canvas.width, tempContext.canvas.height);
        if (flipHorizontal) {
            tempContext.translate(tempContext.canvas.width, 0);
            tempContext.scale(-1, 1);
        }
        if (flipVertical) {
            tempContext.translate(0, tempContext.canvas.height);
            tempContext.scale(1, -1);
        }
        tempContext.drawImage(this.parent.inMemoryCanvas, 0, 0);
        this.updateSaveContext(tempContext);
    };
    Export.prototype.updateSaveContext = function (tempContext) {
        var inMemoryContext = this.parent.inMemoryCanvas.getContext('2d');
        tempContext.setTransform(1, 0, 0, 1, 0, 0);
        var imageData = tempContext.getImageData(0, 0, tempContext.canvas.width, tempContext.canvas.height);
        this.parent.inMemoryCanvas.width = imageData.width;
        this.parent.inMemoryCanvas.height = imageData.height;
        inMemoryContext.putImageData(imageData, 0, 0);
    };
    Export.prototype.setMaxDim = function (degree, tempCanvas) {
        var newWidth;
        var newHeight;
        if (degree % 90 === 0 && degree % 180 !== 0) {
            if (isNullOrUndefined(this.parent.currSelectionPoint)) {
                newWidth = this.parent.baseImgCanvas.height;
                newHeight = this.parent.baseImgCanvas.width;
            }
            else {
                newWidth = this.parent.img.srcHeight;
                newHeight = this.parent.img.srcWidth;
            }
        }
        else if (degree % 180 === 0 || degree === 0) {
            if (isNullOrUndefined(this.parent.currSelectionPoint)) {
                newWidth = this.parent.baseImgCanvas.width;
                newHeight = this.parent.baseImgCanvas.height;
            }
            else {
                newWidth = this.parent.img.srcWidth;
                newHeight = this.parent.img.srcHeight;
            }
        }
        if (!isNullOrUndefined(this.parent.aspectWidth)) {
            newWidth = this.parent.aspectWidth;
            newHeight = this.parent.aspectHeight;
        }
        tempCanvas.width = newWidth;
        tempCanvas.height = newHeight;
        var obj = { width: 0, height: 0 };
        this.parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: newWidth, height: newHeight, obj: obj, isImgShape: null } });
        var maxDimension = obj;
        tempCanvas.style.maxWidth = maxDimension.width + 'px';
        tempCanvas.style.maxHeight = maxDimension.height + 'px';
    };
    return Export;
}());

var Filter = /** @class */ (function () {
    function Filter(parent) {
        this.adjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
            exposure: 0, transparency: 100, sharpen: false, bw: false }; // for toolbar slider value
        this.tempAdjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
            exposure: 0, transparency: 100, sharpen: false, bw: false }; // for temp toolbar slider value
        this.adjustmentValue = ''; // for internal slider value
        this.isBrightnessAdjusted = false;
        this.bevelFilter = 'none';
        this.tempAdjVal = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
            exposure: 0, transparency: 100, sharpen: false, bw: false };
        this.tempFilVal = '';
        this.parent = parent;
        this.addEventListener();
    }
    Filter.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    Filter.prototype.addEventListener = function () {
        this.parent.on('filter', this.filter, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    Filter.prototype.removeEventListener = function () {
        this.parent.off('filter', this.filter);
        this.parent.off('destroyed', this.destroy);
    };
    Filter.prototype.filter = function (args) {
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'finetuneImage':
                this.finetuneImage(args.value['option'], args.value['value']);
                break;
            case 'applyImageFilter':
                this.setFilter(args.value['option']);
                break;
            case 'update-finetunes':
                this.updateFinetunes();
                break;
            case 'set-adjustment':
                this.setAdjustment(args.value['operation']);
                break;
            case 'initFilter':
                this.initFilter();
                break;
            case 'setCurrAdjValue':
                this.setCurrAdjValue(args.value['type'], args.value['value']);
                break;
            case 'updateAdj':
                this.updateAdj(args.value['type'], args.value['value'], args.value['isPreview'], args.value['ctx']);
                break;
            case 'getCurrentObj':
                this.getCurrentObj(args.value['object']);
                break;
            case 'getAdjustmentLevel':
                if (isNullOrUndefined(this.parent.activeObj.opacity)) {
                    this.adjustmentLevel.transparency = 100;
                }
                else {
                    this.adjustmentLevel.transparency = this.parent.activeObj.opacity * 100;
                }
                args.value['obj']['adjustmentLevel'] = this.adjustmentLevel;
                break;
            case 'setAdjustmentLevel':
                this.adjustmentLevel = args.value['adjustmentLevel'];
                break;
            case 'getTempAdjustmentLevel':
                args.value['obj']['tempAdjustmentLevel'] = this.tempAdjustmentLevel;
                break;
            case 'setTempAdjustmentLevel':
                this.tempAdjustmentLevel = args.value['tempAdjustmentLevel'];
                break;
            case 'setAdjustmentValue':
                this.adjustmentValue = args.value['adjustmentValue'];
                break;
            case 'setBrightnessAdjusted':
                this.isBrightnessAdjusted = args.value['isBrightnessAdjusted'];
                if (this.parent.currentFilter.split('_') && this.parent.currentFilter.split('_')[1] === 'cold') {
                    this.isBrightnessAdjusted = false;
                }
                break;
            case 'getBevelFilter':
                args.value['obj']['bevelFilter'] = this.bevelFilter;
                break;
            case 'setBevelFilter':
                this.bevelFilter = args.value['bevelFilter'];
                break;
            case 'setTempAdjVal':
                this.tempAdjVal = extend({}, this.adjustmentLevel, {}, true);
                break;
            case 'setTempFilVal':
                this.tempFilVal = this.parent.currentFilter;
                break;
            case 'reset':
                this.reset();
                break;
            case 'apply-filter':
                this.applyFilter(args.value['context']);
                break;
        }
    };
    Filter.prototype.updatePrivateVariables = function () {
        var parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
    };
    Filter.prototype.getModuleName = function () {
        return 'filter';
    };
    Filter.prototype.reset = function () {
        this.adjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0,
            blur: 0, exposure: 0, transparency: 100, sharpen: false, bw: false };
        this.tempAdjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0,
            blur: 0, exposure: 0, transparency: 100, sharpen: false, bw: false };
        this.adjustmentValue = this.parent.getDefaultFilter();
        this.isBrightnessAdjusted = false;
        this.bevelFilter = 'none';
        this.tempFilVal = '';
        this.tempAdjVal = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0,
            blur: 0, exposure: 0, transparency: 100, sharpen: false, bw: false };
    };
    Filter.prototype.updateFinetunes = function () {
        var _this = this;
        var parent = this.parent;
        var fs = parent.finetuneSettings;
        if (fs) {
            var propertiesToSet = ['brightness', 'contrast', 'hue', 'saturation', 'exposure', 'opacity', 'blur'];
            propertiesToSet.forEach(function (property) {
                if (fs[property]) {
                    _this.adjustmentLevel[property] = fs[property].defaultValue;
                    _this.tempAdjustmentLevel[property] = fs[property].defaultValue;
                }
            });
            parent.notify('draw', { prop: 'isInitialLoading', onPropertyChange: false, value: { isInitialLoading: true } });
        }
    };
    Filter.prototype.initFilter = function () {
        this.setFilterAdj('brightness', this.adjustmentLevel.brightness);
        this.setFilterAdj('contrast', this.adjustmentLevel.contrast);
        this.setFilterAdj('hue', this.adjustmentLevel.hue);
        this.setFilterAdj('saturation', this.adjustmentLevel.saturation);
        this.setFilterAdj('exposure', this.adjustmentLevel.exposure);
        this.setFilterAdj('opacity', this.adjustmentLevel.opacity);
        this.setFilterAdj('blur', this.adjustmentLevel.blur);
    };
    Filter.prototype.updateAdj = function (type, value, isPreview, ctx) {
        var parent = this.parent;
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        var splitWords = this.lowerContext.filter.split(' ');
        var values = [];
        var brightness = this.getFilterValue(this.adjustmentLevel.brightness);
        var saturate;
        var bright;
        var saturatePercent;
        var contrast;
        var saturatePercentage;
        switch (type) {
            case 'brightness':
                value = this.getFilterValue(this.adjustmentLevel.exposure) + (value * 0.005);
                splitWords[0] = 'brightness(' + value + ')';
                if (this.adjustmentLevel.brightness !== 0) {
                    value = (this.adjustmentLevel.opacity / 100) - (this.adjustmentLevel.opacity * 0.3) / 100;
                    splitWords[4] = 'opacity(' + value + ')';
                }
                else {
                    value = this.adjustmentLevel.opacity / 100;
                    splitWords[4] = 'opacity(' + value + ')';
                }
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'contrast':
                splitWords[1] = 'contrast(' + value + '%)';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'hue':
                splitWords[2] = 'hue-rotate(' + value + 'deg)';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'saturation':
                splitWords[3] = 'saturate(' + value + '%)';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'opacity':
                if (parseFloat(splitWords[0].split('(')[1]) !== 1) {
                    value -= 0.2;
                }
                if (value < 0) {
                    value = 0;
                }
                splitWords[4] = 'opacity(' + value + ')';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'blur':
                splitWords[5] = 'blur(' + value + 'px)';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'exposure':
                if (value > 1) {
                    value -= 1;
                    value += brightness;
                }
                else if (value < 1) {
                    value = 1 - value;
                    value = brightness - value;
                }
                splitWords[0] = 'brightness(' + value + ')';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'chrome':
                saturate = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
                saturate *= 100;
                value = saturate + (saturate * 0.4);
                splitWords[3] = 'saturate(' + value + '%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'cold':
                // Adjusting Brightness
                bright = this.getFilterValue(this.adjustmentLevel.brightness);
                bright *= 100;
                value = bright * 0.9;
                value *= 0.01;
                splitWords[0] = 'brightness(' + value + ')';
                // Adjusting Contrast
                contrast = this.getFilterValue(this.adjustmentLevel.contrast);
                contrast *= 100;
                value = contrast + (contrast * 0.5);
                splitWords[1] = 'contrast(' + value + '%)';
                // Adjusting Saturation
                saturatePercentage = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
                saturatePercentage *= 100;
                value = saturatePercentage;
                splitWords[3] = 'saturate(' + value + '%)';
                values = this.adjustmentValue.split(' ');
                splitWords[2] = values[2];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'warm':
                saturatePercent = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
                saturatePercent *= 100;
                value = saturatePercent + (saturatePercent * 0.4);
                splitWords[3] = 'saturate(' + value + '%)';
                splitWords[6] = 'sepia(25%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'grayscale':
                splitWords[7] = 'grayscale(100%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[3] = values[3];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'sepia':
                splitWords[6] = 'sepia(100%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[3] = values[3];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'invert':
                splitWords[8] = 'invert(100%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[3] = values[3];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[7] = 'grayscale(0%)';
                break;
        }
        if (type !== 'sharpen' && type !== 'blackandwhite') {
            if (isNullOrUndefined(isPreview)) {
                if (type === 'default') {
                    splitWords = this.getDefaultCurrentFilter(splitWords);
                }
                this.lowerContext.filter = splitWords.join(' ');
            }
            splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
            parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: true } });
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
            var tempFilter = void 0;
            if (parent.frameObj.type === 'bevel') {
                tempFilter = this.lowerContext.filter;
                this.bevelFilter = tempFilter;
            }
            if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
                parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
                parent.img.destTop += parent.panPoint.totalPannedPoint.y;
            }
            parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
            if (parent.transform.degree === 0) {
                parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
            }
            parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
            if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
                parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
                parent.img.destTop += parent.panPoint.totalPannedPoint.y;
            }
            splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
            if (isNullOrUndefined(isPreview)) {
                this.lowerContext.filter = splitWords.join(' ');
            }
            parent.initialAdjustmentValue = splitWords.join(' ');
            tempFilter = this.lowerContext.filter;
            this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
            this.bevelFilter = tempFilter;
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
            this.lowerContext.filter = tempFilter;
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            this.isBrightnessAdjusted = brightness !== 1;
        }
        var filter = splitWords.join(' ');
        if (ctx) {
            ctx.filter = filter;
        }
    };
    Filter.prototype.setTempFilterValue = function (brightness, isPreview, splitWords, type) {
        if (isPreview) {
            if (type === 'default') {
                splitWords = this.getDefaultCurrentFilter(splitWords);
            }
            else if (brightness !== 1) {
                var tempSplitWords = this.lowerContext.filter.split(' ');
                tempSplitWords[4] = splitWords[4];
                this.lowerContext.filter = tempSplitWords.join(' ');
            }
        }
        return splitWords;
    };
    Filter.prototype.getDefaultCurrentFilter = function (splitWords) {
        var values = this.adjustmentValue.split(' ');
        splitWords = [values[0], values[1], values[2], values[3], values[4], values[5], 'sepia(0%)', 'grayscale(0%)', 'invert(0%)'];
        return splitWords;
    };
    Filter.prototype.getFilterValue = function (value) {
        return (value === 0) ? 1 : 1 + ((value * 0.5) / 100);
    };
    Filter.prototype.getSaturationFilterValue = function (value) {
        return value === 0 ? 1 : 1 + (value / 100);
    };
    Filter.prototype.setFilterAdj = function (type, value) {
        var parent = this.parent;
        parent.notify('freehand-draw', { prop: 'apply-pen-draw', onPropertyChange: false });
        this.adjustmentLevel["" + type] = value;
        switch (type) {
            case 'contrast':
            case 'exposure':
                value = this.getFilterValue(value);
                if (type === 'contrast') {
                    value *= 100;
                }
                break;
            case 'hue':
                value *= 3;
                break;
            case 'saturation':
                value = this.getSaturationFilterValue(value) * 100;
                break;
            case 'opacity':
                if (value < 10) {
                    value += 1;
                }
                value /= 100;
                break;
            case 'blur':
                if (value !== 0) {
                    value /= 20;
                    // Since 0.5 is not working in blur we consider from 1
                    value += 0.5;
                }
                break;
        }
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var prevObj = this.getCurrentObj();
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.updateAdj(type, value);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: { operation: type, previousObj: prevObj,
                previousObjColl: prevObj.objColl, previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null, currentText: null, previousFilter: null, isCircleCrop: null
            } });
    };
    Filter.prototype.setFilter = function (type) {
        var parent = this.parent;
        type = type.toLowerCase();
        parent.notify('freehand-draw', { prop: 'apply-pen-draw', onPropertyChange: false });
        var obj = { currentFilter: this.parent.currentFilter };
        var prevFilter = obj['currentFilter'];
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var prevObj = this.getCurrentObj();
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.updateAdj(type, null);
        parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: type, previousObj: prevObj, previousObjColl: prevObj.objColl, previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl, previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: prevFilter, isCircleCrop: null } });
    };
    Filter.prototype.setAdjustment = function (type) {
        var splitWords = this.lowerContext.filter.split(' ');
        var value;
        var valueArr;
        switch (type) {
            case 'brightness':
                valueArr = splitWords[0].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                this.adjustmentLevel.brightness = this.setFilterValue(value);
                break;
            case 'contrast':
                valueArr = splitWords[1].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value /= 100;
                this.adjustmentLevel.contrast = this.setFilterValue(value);
                break;
            case 'hue':
                valueArr = splitWords[2].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value /= 3;
                this.adjustmentLevel.hue = value;
                break;
            case 'saturation':
                valueArr = splitWords[3].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value /= 100;
                this.adjustmentLevel.saturation = this.setSaturationFilterValue(value);
                break;
            case 'opacity':
                valueArr = splitWords[4].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                if (value === 0.45) {
                    value = 40;
                }
                else if (value === 0.40) {
                    value = 30;
                }
                else if (value === 0.35) {
                    value = 20;
                }
                else if (value === 0.30) {
                    value = 10;
                }
                else if (value === 0.25) {
                    value = 0;
                }
                else {
                    value *= 100;
                }
                this.adjustmentLevel.opacity = value;
                break;
            case 'blur':
                valueArr = splitWords[5].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value *= 20;
                this.adjustmentLevel.blur = value;
                break;
            case 'exposure':
                valueArr = splitWords[0].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                this.adjustmentLevel.exposure = this.setFilterValue(value);
                break;
        }
    };
    Filter.prototype.setFilterValue = function (value) {
        return Math.round((value === 1) ? 0 : ((value - 1) * 100) / 0.5);
    };
    Filter.prototype.setSaturationFilterValue = function (value) {
        return Math.round((value === 1) ? 0 : (value - 1) * 100);
    };
    Filter.prototype.finetuneImage = function (finetuneOption, value) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            switch (finetuneOption.toLowerCase()) {
                case 'brightness':
                    this.setFilterAdj('brightness', value);
                    break;
                case 'contrast':
                    this.setFilterAdj('contrast', value);
                    break;
                case 'hue':
                    this.setFilterAdj('hue', value);
                    break;
                case 'saturation':
                    this.setFilterAdj('saturation', value);
                    break;
                case 'opacity':
                    this.setFilterAdj('opacity', value);
                    break;
                case 'blur':
                    this.setFilterAdj('blur', value);
                    break;
                case 'exposure':
                    this.setFilterAdj('exposure', value);
                    break;
            }
            this.parent.canvasFilter = this.lowerContext.filter;
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
    };
    Filter.prototype.setCurrAdjValue = function (type, value) {
        var parent = this.parent;
        this.parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        switch (type) {
            case 'brightness':
                this.setFilterAdj('brightness', value);
                break;
            case 'contrast':
                this.setFilterAdj('contrast', value);
                break;
            case 'hue':
                this.setFilterAdj('hue', value);
                break;
            case 'saturation':
                this.setFilterAdj('saturation', value);
                break;
            case 'opacity':
                this.setFilterAdj('opacity', value);
                break;
            case 'blur':
                this.setFilterAdj('blur', value);
                break;
            case 'exposure':
                this.setFilterAdj('exposure', value);
                break;
        }
        parent.isFinetuneBtnClick = true;
        parent.curFinetuneObjEvent = { finetune: parent.toPascalCase(type), value: value };
    };
    Filter.prototype.getCurrentObj = function (dummyObj) {
        var parent = this.parent;
        var tempFlipPanPointObj = { point: null };
        parent.notify('crop', { prop: 'getTempFlipPanPoint', value: { obj: tempFlipPanPointObj } });
        var zoomObj = { previousZoomValue: null };
        parent.notify('transform', { prop: 'getPreviousZoomValue', value: { obj: zoomObj } });
        var straightenObj = { zoomFactor: null };
        parent.notify('draw', { prop: 'getStraightenInitZoom', value: { obj: straightenObj } });
        var bgObj = { color: null };
        parent.notify('draw', { prop: 'getImageBackgroundColor', value: { obj: bgObj } });
        var obj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
            totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {},
            rotateFlipColl: [], degree: 0, currFlipState: '', zoomFactor: 0, previousZoomValue: 0, straighten: 0,
            destPoints: { startX: 0, startY: 0, width: 0, height: 0 }, frame: 'none',
            srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: this.isBrightnessAdjusted,
            aspectWidth: null, aspectHeight: null, straightenZoom: 0, adjustmentLevel: extend({}, this.tempAdjVal, {}, true),
            currentFilter: this.tempFilVal, imageSource: '', bgColor: '' };
        obj.cropZoom = parent.transform.cropZoomFactor;
        obj.defaultZoom = parent.transform.defaultZoomFactor;
        obj.zoomFactor = parent.zoomSettings.zoomFactor;
        obj.previousZoomValue = zoomObj['previousZoomValue'];
        obj.straightenZoom = straightenObj['zoomFactor'];
        obj.totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, {}, true);
        obj.totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
        obj.totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
        obj.tempFlipPanPoint = extend({}, tempFlipPanPointObj['point'], {}, true);
        obj.activeObj = extend({}, parent.activeObj, {}, true);
        obj.rotateFlipColl = extend([], parent.rotateFlipColl, [], true);
        obj.degree = parent.transform.degree;
        obj.straighten = parent.cropObj.straighten;
        obj.currFlipState = parent.transform.currFlipState;
        obj.destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, endX: 0, endY: 0,
            width: parent.img.destWidth, height: parent.img.destHeight };
        obj.srcPoints = { startX: parent.img.srcLeft, startY: parent.img.srcTop, endX: 0, endY: 0,
            width: parent.img.srcWidth, height: parent.img.srcHeight };
        obj.filter = this.lowerContext.filter;
        obj.aspectWidth = parent.aspectWidth;
        obj.aspectHeight = parent.aspectHeight;
        obj.frame = parent.frameObj.type;
        obj.frameObj = extend({}, parent.frameObj);
        obj.imageSource = parent.baseImg.src;
        obj.bgColor = bgObj['color'];
        if (dummyObj) {
            dummyObj['currObj'] = obj;
        }
        return obj;
    };
    /* Filter safari related codes */
    Filter.prototype.getValFromPercentage = function (percentage) {
        var val = parseFloat(percentage);
        // check for percentages and divide by a hundred
        if (/%\s*?$/i.test(percentage)) {
            val /= 100;
        }
        return val;
    };
    Filter.prototype.getValFromLength = function (length) {
        return parseFloat(length);
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.parseFilterString = function (filterString) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var filterArray = [];
        if (filterString && filterString !== 'none') {
            filterArray = filterString.split(' ').map(function (filter) {
                var _a = filter.match(/([a-z-]+)\(([^)]+)\)/).slice(1, 3), name = _a[0], value = _a[1];
                return { filter: name, value: value };
            });
        }
        return filterArray;
    };
    Filter.prototype.applyFilter = function (context) {
        var _a = context.canvas, height = _a.height, width = _a.width;
        var imageData = context.getImageData(0, 0, width, height);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var filterArray = this.parseFilterString(context.filter);
        for (var i = 0, len = filterArray.length; i < len; i++) {
            switch (filterArray[i].filter) {
                case 'blur':
                    imageData = this.blur(context, imageData, filterArray[i].value);
                    break;
                case 'brightness':
                    imageData = this.brightness(imageData, filterArray[i].value);
                    break;
                case 'contrast':
                    imageData = this.contrast(imageData, filterArray[i].value);
                    break;
                case 'grayscale':
                    imageData = this.grayscale(imageData, filterArray[i].value);
                    break;
                case 'hue-rotate':
                    imageData = this.hueRotate(imageData, filterArray[i].value);
                    break;
                case 'invert':
                    imageData = this.invert(imageData, filterArray[i].value);
                    break;
                case 'opacity':
                    imageData = this.opacity(imageData, filterArray[i].value);
                    break;
                case 'saturate':
                    imageData = this.saturate(context, imageData, filterArray[i].value);
                    break;
                case 'sepia':
                    imageData = this.sepia(imageData, filterArray[i].value);
                    break;
            }
        }
        context.putImageData(imageData, 0, 0);
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.blur = function (context, imageData, radius) {
        if (radius === void 0) { radius = '0'; }
        var blurRadius = this.getValFromLength(radius);
        blurRadius = Math.floor(blurRadius);
        if (blurRadius <= 0) {
            return imageData;
        }
        var _a = context.canvas, height = _a.height, width = _a.width;
        var data = imageData.data;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var blurredData = new Uint8ClampedArray(data.length);
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var r = 0;
                var g = 0;
                var b = 0;
                var a = 0;
                var count = 0;
                for (var dy = -blurRadius; dy <= blurRadius; dy++) {
                    for (var dx = -blurRadius; dx <= blurRadius; dx++) {
                        var nx = x + dx;
                        var ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            var offset = (ny * width + nx) * 4;
                            r += data[offset];
                            g += data[offset + 1];
                            b += data[offset + 2];
                            a += data[offset + 3];
                            count++;
                        }
                    }
                }
                var i = (y * width + x) * 4;
                blurredData[i] = r / count;
                blurredData[i + 1] = g / count;
                blurredData[i + 2] = b / count;
                blurredData[i + 3] = a / count;
            }
        }
        for (var i = 0; i < data.length; i++) {
            data[i] = blurredData[i];
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.brightness = function (imageData, percentage) {
        if (percentage === void 0) { percentage = '1'; }
        var factor = this.getValFromPercentage(percentage);
        if (factor !== 1) {
            var data = imageData.data;
            var length_1 = data.length;
            for (var i = 0; i < length_1; i += 4) {
                data[i + 0] *= factor;
                data[i + 1] *= factor;
                data[i + 2] *= factor;
            }
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.contrast = function (imageData, percentage) {
        if (percentage === void 0) { percentage = '1'; }
        var factor = this.getValFromPercentage(percentage);
        if (factor !== 1) {
            var data = imageData.data;
            var length_2 = data.length;
            for (var i = 0; i < length_2; i += 4) {
                data[i + 0] = ((data[i + 0] / 255 - 0.5) * factor + 0.5) * 255;
                data[i + 1] = ((data[i + 1] / 255 - 0.5) * factor + 0.5) * 255;
                data[i + 2] = ((data[i + 2] / 255 - 0.5) * factor + 0.5) * 255;
            }
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.grayscale = function (imageData, percentage) {
        if (percentage === void 0) { percentage = '0'; }
        var factor = this.getValFromPercentage(percentage);
        if (factor > 0) {
            var data = imageData.data;
            var length_3 = data.length;
            for (var i = 0; i < length_3; i += 4) {
                var r = data[i];
                var g = data[i + 1];
                var b = data[i + 2];
                // Calculate the grayscale value using the luminosity method
                var gray = 0.299 * r + 0.587 * g + 0.114 * b;
                // Blend the original color with the grayscale value based on the percentage
                data[i] = r * (1 - factor) + gray * factor;
                data[i + 1] = g * (1 - factor) + gray * factor;
                data[i + 2] = b * (1 - factor) + gray * factor;
            }
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.hueRotate = function (imageData, rotation) {
        if (rotation === void 0) { rotation = '0deg'; }
        var data = imageData.data;
        var angle = parseFloat(rotation) * (Math.PI / 180);
        if (angle > 0) {
            var cosA = Math.cos(angle);
            var sinA = Math.sin(angle);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var matrix = [
                0.213 + cosA * 0.787 - sinA * 0.213, 0.715 - cosA * 0.715 - sinA * 0.715, 0.072 - cosA * 0.072 + sinA * 0.928,
                0.213 - cosA * 0.213 + sinA * 0.143, 0.715 + cosA * 0.285 + sinA * 0.140, 0.072 - cosA * 0.072 - sinA * 0.283,
                0.213 - cosA * 0.213 - sinA * 0.787, 0.715 - cosA * 0.715 + sinA * 0.715, 0.072 + cosA * 0.928 + sinA * 0.072
            ];
            for (var i = 0; i < data.length; i += 4) {
                var r = data[i];
                var g = data[i + 1];
                var b = data[i + 2];
                // Apply the hue rotation matrix
                data[i] = matrix[0] * r + matrix[1] * g + matrix[2] * b;
                data[i + 1] = matrix[3] * r + matrix[4] * g + matrix[5] * b;
                data[i + 2] = matrix[6] * r + matrix[7] * g + matrix[8] * b;
            }
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.invert = function (imageData, percentage) {
        if (percentage === void 0) { percentage = '0'; }
        var factor = this.getValFromPercentage(percentage);
        if (factor > 0) {
            var data = imageData.data;
            var length_4 = data.length;
            for (var i = 0; i < length_4; i += 4) {
                data[i + 0] = Math.abs(data[i + 0] - 255 * factor);
                data[i + 1] = Math.abs(data[i + 1] - 255 * factor);
                data[i + 2] = Math.abs(data[i + 2] - 255 * factor);
            }
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.opacity = function (imageData, percentage) {
        if (percentage === void 0) { percentage = '0'; }
        var factor = this.getValFromPercentage(percentage);
        if (factor >= 0) {
            var data = imageData.data;
            var length_5 = data.length;
            for (var i = 3; i < length_5; i += 4) {
                data[i] *= factor;
            }
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.saturate = function (context, imageData, percentage) {
        if (percentage === void 0) { percentage = '0'; }
        var factor = this.getValFromPercentage(percentage);
        if (factor !== 1) {
            var _a = context.canvas, width = _a.width, height = _a.height;
            var data = imageData.data;
            var lumR = (1 - factor) * 0.3086;
            var lumG = (1 - factor) * 0.6094;
            var lumB = (1 - factor) * 0.082;
            // tslint:disable-next-line no-bitwise
            var shiftW = width << 2;
            for (var j = 0; j < height; j++) {
                var offset = j * shiftW;
                for (var i = 0; i < width; i++) {
                    // tslint:disable-next-line no-bitwise
                    var pos = offset + (i << 2);
                    var r = data[pos + 0];
                    var g = data[pos + 1];
                    var b = data[pos + 2];
                    data[pos + 0] = (lumR + factor) * r + lumG * g + lumB * b;
                    data[pos + 1] = lumR * r + (lumG + factor) * g + lumB * b;
                    data[pos + 2] = lumR * r + lumG * g + (lumB + factor) * b;
                }
            }
        }
        return imageData;
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    Filter.prototype.sepia = function (imageData, percentage) {
        if (percentage === void 0) { percentage = '0'; }
        var factor = this.getValFromPercentage(percentage);
        if (factor > 1) {
            factor = 1;
        }
        if (factor > 0) {
            var data = imageData.data;
            var length_6 = data.length;
            for (var i = 0; i < length_6; i += 4) {
                var r = data[i + 0];
                var g = data[i + 1];
                var b = data[i + 2];
                data[i + 0] =
                    (0.393 * r + 0.769 * g + 0.189 * b) * factor + r * (1 - factor);
                data[i + 1] =
                    (0.349 * r + 0.686 * g + 0.168 * b) * factor + g * (1 - factor);
                data[i + 2] =
                    (0.272 * r + 0.534 * g + 0.131 * b) * factor + b * (1 - factor);
            }
        }
        return imageData;
    };
    return Filter;
}());

var FreehandDrawing = /** @class */ (function () {
    function FreehandDrawing(parent) {
        this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
        this.isFreehandDrawing = false;
        this.freehandDownPoint = { x: 0, y: 0 };
        this.isFreehandPointMoved = false;
        this.pointCounter = 0;
        // eslint-disable-next-line
        this.selPointColl = {};
        this.currFHDIdx = 0; // Specifies id for every freehand drawing - uses while deleting
        this.selPoints = [];
        this.dummyPoints = [];
        this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
        this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
        this.straightenPointAngle = 0;
        this.isMasking = false;
        this.parent = parent;
        this.addEventListener();
    }
    FreehandDrawing.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    FreehandDrawing.prototype.addEventListener = function () {
        this.parent.on('freehand-draw', this.draw, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    FreehandDrawing.prototype.removeEventListener = function () {
        this.parent.off('freehand-draw', this.draw);
        this.parent.off('destroyed', this.destroy);
    };
    FreehandDrawing.prototype.draw = function (args) {
        this.updateFhdPvtVar();
        switch (args.prop) {
            case 'hoverFhd': {
                this.hoverFhd(args.value['strokeColor'], args.value['strokeWidth']);
                break;
            }
            case 'freehandDownHandler':
                this.freehandDownHandler(args.value['e'], args.value['canvas']);
                break;
            case 'freehandUpHandler':
                this.freehandUpHandler(args.value['e'], args.value['canvas'], args.value['context']);
                break;
            case 'handle-freehand-draw': {
                var id = parseInt(args.value['id'].split('_')[1], 10) - 1;
                if (this.isFHDIdx(id)) {
                    this.deleteFhd(id, true);
                }
                break;
            }
            case 'freehandRedraw':
                this.freehandRedraw(args.value['context'], args.value['points']);
                break;
            case 'deleteFhd': {
                var id = parseInt(args.value['id'].split('_')[1], 10) - 1;
                this.deleteFhd(id, true);
                break;
            }
            case 'selectFhd': {
                var id = null;
                if (args.value['id']) {
                    id = parseInt(args.value['id'].split('_')[1], 10) - 1;
                }
                this.selectFhd(id);
                break;
            }
            case 'applyFhd':
                this.applyFhd();
                break;
            case 'cancelFhd':
                this.cancelFhd();
                break;
            case 'updateFHDCurPts':
                this.updateFHDCurPts();
                break;
            case 'rotateFhdColl':
                this.rotateFhdColl();
                break;
            case 'flipFHDColl':
                this.flipFHDColl(args.value['value']);
                break;
            case 'panFHDColl':
                this.panFHDColl(args.value['xDiff'], args.value['yDiff'], args.value['panRegion']);
                break;
            case 'updateFHDColl':
                if (args.value && args.value['isPreventApply']) {
                    this.updateFHDColl(args.value['isPreventApply']);
                }
                else {
                    this.updateFHDColl();
                }
                break;
            case 'zoomFHDColl':
                this.zoomFHDColl(args.value['isPreventApply']);
                break;
            case 'apply-pen-draw':
                this.applyPenDraw();
                break;
            case 'freeHandDraw':
                this.freeHandDraw(args.value['value']);
                break;
            case 'isFHDIdx':
                this.isFHDIdx(args.value['index'], args.value['obj']);
                break;
            case 'getSqPtFD':
                this.getSqPtFD(args.value['idx'], args.value['obj']);
                break;
            case 'getSelPointColl':
                args.value['obj']['selPointColl'] = extend([], this.selPointColl);
                break;
            case 'setSelPointColl':
                this.selPointColl = extend([], args.value['obj']['selPointColl']);
                break;
            case 'pushSelPointColl':
                this.selPointColl.push(extend([], args.value['obj']['selPointColl']));
                break;
            case 'setFreehandDrawHoveredIndex':
                this.fhdHovIdx = args.value['index'];
                break;
            case 'getFreehandDrawHoveredIndex':
                args.value['obj']['index'] = this.fhdHovIdx;
                break;
            case 'setPointCounter':
                this.pointCounter = args.value['value'];
                break;
            case 'getPenStrokeWidth':
                args.value['obj']['penStrokeWidth'] = this.penStrokeWidth;
                break;
            case 'setPenStrokeWidth':
                this.penStrokeWidth = args.value['value'];
                break;
            case 'getCurrentFreehandDrawIndex':
                args.value['obj']['currentFreehandDrawIndex'] = this.currFHDIdx;
                break;
            case 'setCurrentFreehandDrawIndex':
                this.currFHDIdx = args.value['value'];
                break;
            case 'updateCropPtsForSel':
                this.updateCropPtsForSel();
                break;
            case 'getFreehandDrawSelectedId':
                args.value['obj']['freehandDrawSelectedId'] = this.fhdSelID;
                break;
            case 'resetFreehandDrawSelectedId':
                this.fhdSelID = null;
                break;
            case 'getTempFreeHandDrawEditingStyles':
                args.value['obj']['tempFreeHandDrawEditingStyles'] = this.tempFHDStyles;
                break;
            case 'setFreehandSelectedIndex':
                this.fhdSelIdx = args.value['index'];
                break;
            case 'getFreehandSelectedIndex':
                args.value['obj']['freehandSelectedIndex'] = this.fhdSelIdx;
                break;
            case 'setCenterSelPoints':
                this.setCenterSelPoints();
                break;
            case 'getStraightenPoint':
                args.value['obj']['straightenPoint'] = extend({}, this.straightenPoint, {}, true);
                break;
            case 'setStraightenPoint':
                this.straightenPoint.x = args.value['x'];
                this.straightenPoint.y = args.value['y'];
                if (args.value['ratioX'] && args.value['ratioY']) {
                    this.straightenPoint.ratioX = args.value['ratioX'];
                    this.straightenPoint.ratioY = args.value['ratioY'];
                }
                break;
            case 'resetStraightenPoint':
                this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
                this.prevStraightenObj = null;
                this.straightenPointAngle = 0;
                break;
            case 'getStraightenPointAngle':
                args.value['obj']['angle'] = this.straightenPointAngle;
                break;
            case 'reset':
                this.reset();
                break;
            case 'triggerShapeChanging':
                this.triggerShapeChanging(args.value['shapeChangingArgs']);
                break;
            case 'setMasking':
                this.isMasking = args.value['value'];
                break;
            case 'resetSelPoints':
                this.selPoints = [];
                break;
        }
    };
    FreehandDrawing.prototype.updateFhdPvtVar = function () {
        var parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
    };
    FreehandDrawing.prototype.reset = function () {
        this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
        this.isFreehandDrawing = this.isFreehandPointMoved = false;
        this.selPoints = [];
        this.dummyPoints = [];
        this.freehandDownPoint = { x: 0, y: 0 };
        this.selPointColl = {};
        this.straightenPointAngle = 0;
        this.fhdHovIdx = null;
        this.pointCounter = 0;
        this.fhdSelID = null;
        this.isMasking = false;
        this.penStrokeWidth = undefined;
        this.currFHDIdx = 0;
        this.fhdSelIdx = null;
        this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
        this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
        this.prevStraightenObj = null;
    };
    FreehandDrawing.prototype.getModuleName = function () {
        return 'freehand-draw';
    };
    FreehandDrawing.prototype.hoverFhd = function (fillStyle, strokeWidth) {
        var parent = this.parent;
        var context = this.upperContext;
        var idx = -1;
        if (this.fhdHovIdx > -1) {
            idx = this.fhdHovIdx;
        }
        else {
            idx = this.fhdSelIdx;
        }
        parent.points = extend([], parent.pointColl[idx].points);
        this.pointCounter = 0;
        var len = parent.points.length;
        var controlPoint1;
        var controlPoint2;
        var startPoint;
        var endPoint;
        var minStrokeWidth = 0;
        var maxStrokeWidth = 0;
        context.fillStyle = fillStyle ? fillStyle : parent.pointColl[idx].strokeColor;
        context.strokeStyle = context.fillStyle;
        minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = strokeWidth ?
            strokeWidth : parent.pointColl[idx].strokeWidth;
        if (len === 1) {
            controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
            this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
        }
        for (var l = 0; l < len - 3; l++) {
            if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
                controlPoint1 = (this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2])).controlPoint2;
                controlPoint2 = (this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3])).controlPoint1;
                if (l === 0) {
                    startPoint = parent.points[l];
                }
                else {
                    startPoint = parent.points[l + 1];
                }
                endPoint = parent.points[l + 2];
                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
            }
        }
        context.closePath();
        // Outer selection
        var point = this.getSqPtFD(idx);
        var tempLineWidth = context.lineWidth;
        context.lineWidth = 2;
        context.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        context.beginPath();
        context.rect(point.startX, point.startY, point.width, point.height);
        context.stroke();
        context.closePath();
        context.lineWidth = tempLineWidth;
    };
    FreehandDrawing.prototype.freehandDownHandler = function (e, canvas) {
        var parent = this.parent;
        parent.lowerCanvas = document.querySelector('#' + parent.element.id + '_lowerCanvas');
        this.lowerContext = parent.lowerCanvas.getContext('2d');
        parent.upperCanvas = document.querySelector('#' + parent.element.id + '_upperCanvas');
        this.upperContext = parent.upperCanvas.getContext('2d');
        this.fhdObj.time = new Date().getTime();
        this.isFreehandDrawing = true;
        if (e.type === 'mousedown') {
            this.freehandDownPoint = { x: e.clientX, y: e.clientY };
        }
        else {
            this.freehandDownPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        this.isFreehandPointMoved = false;
        EventHandler.add(canvas, 'mousemove touchmove', this.freehandMoveHandler, this);
        var shapeSettings = { id: 'pen_' + (this.currFHDIdx + 1), type: ShapeType.FreehandDraw,
            startX: this.freehandDownPoint.x, startY: this.freehandDownPoint.y,
            strokeColor: parent.activeObj.strokeSettings.strokeColor, strokeWidth: this.penStrokeWidth,
            points: null, index: parent.objColl.length + parent.freehandCounter + 1 };
        var shapeChangingArgs = { cancel: false, action: 'draw-start', previousShapeSettings: shapeSettings,
            currentShapeSettings: shapeSettings };
        this.triggerShapeChanging(shapeChangingArgs);
    };
    FreehandDrawing.prototype.freehandUpHandler = function (e, canvas, context) {
        var rect = canvas.getBoundingClientRect();
        var parent = this.parent;
        EventHandler.remove(canvas, 'mousemove touchmove', this.freehandMoveHandler);
        if (parent.points.length === 0) {
            if (e.type === 'mouseup') {
                this.processPoint(e.clientX - rect.left, e.clientY - rect.top, true, context);
            }
            else if (e.type === 'touchend' && e.changedTouches) {
                this.processPoint(e.changedTouches[0].clientX - rect.left, e.changedTouches[0].clientY - rect.top, true, context);
            }
            else {
                if (!this.isFreehandPointMoved) {
                    this.processPoint(this.freehandDownPoint.x - rect.left, this.freehandDownPoint.y - rect.top, true, context);
                }
            }
        }
        context.closePath();
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        var fhCnt = parent.freehandCounter;
        var order = parent.objColl.length + parent.freehandCounter + 1;
        parent.pointColl[fhCnt] = { points: extend([], parent.points), strokeColor: parent.activeObj.strokeSettings.strokeColor,
            strokeWidth: this.penStrokeWidth, flipState: parent.transform.currFlipState,
            id: 'pen_' + (this.currFHDIdx + 1), order: order };
        parent.points = [];
        this.dummyPoints = [];
        this.selPointColl[fhCnt] = { points: extend([], this.selPoints) };
        this.selPoints = [];
        this.pointCounter = 0;
        parent.freehandCounter++;
        this.isFreehandDrawing = false;
        if (!parent.isMaskImage) {
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'freehand-draw', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
        }
        var shapeSettings = { id: 'pen_' + (this.currFHDIdx + 1), type: ShapeType.FreehandDraw,
            startX: this.freehandDownPoint.x, startY: this.freehandDownPoint.y,
            strokeColor: parent.activeObj.strokeSettings.strokeColor, strokeWidth: this.penStrokeWidth,
            points: parent.pointColl[this.currFHDIdx].points, index: order };
        var shapeChangingArgs = { cancel: false, action: 'draw-end', previousShapeSettings: shapeSettings,
            currentShapeSettings: shapeSettings };
        this.triggerShapeChanging(shapeChangingArgs);
        this.currFHDIdx++;
    };
    FreehandDrawing.prototype.freehandMoveHandler = function (e) {
        this.isFreehandPointMoved = true;
        var rect = this.parent.upperCanvas.getBoundingClientRect();
        var x;
        var y;
        if (e.type === 'mousemove') {
            x = e.clientX - rect.left;
            y = e.clientY - rect.top;
        }
        else {
            x = e.touches[0].clientX - rect.left;
            y = e.touches[0].clientY - rect.top;
        }
        if (this.isFreehandDrawing) {
            this.upperContext.fillStyle = this.parent.activeObj.strokeSettings.strokeColor;
            if (this.parent.isMaskImage) {
                this.upperContext.globalCompositeOperation = 'xor';
            }
            this.processPoint(x, y, false, this.upperContext);
        }
    };
    FreehandDrawing.prototype.processPoint = function (x, y, mouseDown, context) {
        var parent = this.parent;
        var lastPoint = this.point(x, y, new Date().getTime());
        lastPoint = parent.points.length > 0 && parent.points[parent.points.length - 1];
        var isLastPointTooClose = lastPoint ? this.distanceTo(lastPoint) <= 5 : false;
        var controlPoint1;
        var controlPoint2;
        var startPoint;
        var endPoint;
        this.selPoints.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
            ratioY: (y - parent.img.destTop) / parent.img.destHeight, time: this.fhdObj.time });
        if (!lastPoint || !(lastPoint && isLastPointTooClose) || mouseDown) {
            this.fhdObj.time = new Date().getTime();
            parent.points.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
                ratioY: (y - parent.img.destTop) / parent.img.destHeight,
                time: this.fhdObj.time });
            this.dummyPoints.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
                ratioY: (y - parent.img.destTop) / parent.img.destHeight,
                time: this.fhdObj.time });
            if (this.dummyPoints.length > 2) {
                if (this.dummyPoints.length === 3) {
                    this.dummyPoints.unshift(this.dummyPoints[0]);
                }
                var p0 = this.dummyPoints[0];
                var p1 = this.dummyPoints[1];
                var p2 = this.dummyPoints[2];
                var p3 = this.dummyPoints[3];
                controlPoint1 = this.calcCurveCP(p0, p1, p2).controlPoint2;
                controlPoint2 = this.calcCurveCP(p1, p2, p3).controlPoint1;
                startPoint = this.dummyPoints[1];
                endPoint = this.dummyPoints[2];
                var minStrokeWidth = 0.5;
                var maxStrokeWidth = 5;
                if (!isNullOrUndefined(this.penStrokeWidth)) {
                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
                }
                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
                this.pointCounter++;
                this.dummyPoints.shift();
            }
            if (mouseDown) {
                controlPoint1 = controlPoint2 = startPoint = endPoint = { x: x, y: y, time: new Date().getTime() };
                var minStrokeWidth = 0.5;
                var maxStrokeWidth = 5;
                if (!isNullOrUndefined(this.penStrokeWidth)) {
                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
                }
                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
            }
        }
    };
    FreehandDrawing.prototype.calcCurveCP = function (p1, p2, p3) {
        if (!p2) {
            p2 = p1;
        }
        if (!p3) {
            p3 = p2;
        }
        var dx1 = p1.x - p2.x;
        var dy1 = p1.y - p2.y;
        var dx2 = p2.x - p3.x;
        var dy2 = p2.y - p3.y;
        var m1 = { x: (p1.x + p2.x) / 2.0, y: (p1.y + p2.y) / 2.0 };
        var m2 = { x: (p2.x + p3.x) / 2.0, y: (p2.y + p3.y) / 2.0 };
        var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        var dxm = (m1.x - m2.x);
        var dym = (m1.y - m2.y);
        var k = l2 / (l1 + l2);
        var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
        var tx = p2.x - cm.x;
        var ty = p2.y - cm.y;
        return {
            controlPoint1: this.point(m1.x + tx, m1.y + ty, 0),
            controlPoint2: this.point(m2.x + tx, m2.y + ty, 0)
        };
    };
    FreehandDrawing.prototype.point = function (x, y, time) {
        this.fhdObj.pointX = x;
        this.fhdObj.pointY = y;
        return { x: this.fhdObj.pointX, y: this.fhdObj.pointY, time: time };
    };
    FreehandDrawing.prototype.startDraw = function (context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth) {
        var tempVelocity;
        tempVelocity = this.pointVelocity(startPoint);
        tempVelocity = 0.7 * tempVelocity + (1 - 0.7) * this.fhdObj.lastVelocity;
        var newWidth = Math.max(maxStrokeWidth / (0.7 + 1), minStrokeWidth);
        this.drawCurve(this.fhdObj.time, newWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth);
        this.fhdObj.lastVelocity = tempVelocity;
        this.fhdObj.time = newWidth;
    };
    FreehandDrawing.prototype.pointVelocity = function (startPoint) {
        return (this.fhdObj.time !== startPoint.time) ? this.distanceTo(startPoint) /
            (this.fhdObj.time - startPoint.time) : 0;
    };
    FreehandDrawing.prototype.distanceTo = function (start) {
        return Math.sqrt(Math.pow(this.fhdObj.pointX - start.x, 2) + Math.pow(this.fhdObj.pointY - start.y, 2));
    };
    FreehandDrawing.prototype.drawCurve = function (startWidth, endWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth) {
        var width;
        var i;
        var t1;
        var t2;
        var t3;
        var u1;
        var u2;
        var u3;
        var x;
        var y;
        var widthValue = endWidth - startWidth;
        var bezierLength = this.bezierLength(controlPoint1, controlPoint2, startPoint, endPoint);
        var drawSteps = Math.ceil(bezierLength) * 2;
        context.beginPath();
        for (i = 0; i < drawSteps; i++) {
            t1 = i / drawSteps;
            t2 = t1 * t1;
            t3 = t2 * t1;
            u1 = 1 - t1;
            u2 = u1 * u1;
            u3 = u2 * u1;
            x = u3 * startPoint.x;
            x += 3 * u2 * t1 * controlPoint1.x;
            x += 3 * u1 * t2 * controlPoint2.x;
            x += t3 * endPoint.x;
            y = u3 * startPoint.y;
            y += 3 * u2 * t1 * controlPoint1.y;
            y += 3 * u1 * t2 * controlPoint2.y;
            y += t3 * endPoint.y;
            width = Math.min(startWidth + t3 * widthValue, maxStrokeWidth);
            this.drawArc(x, y, width, context);
        }
        context.closePath();
        context.fill();
    };
    FreehandDrawing.prototype.bezierLength = function (controlPoint1, controlPoint2, startPoint, endPoint) {
        var steps = 10;
        var length = 0;
        var i;
        var t;
        var pointX1;
        var pointY1;
        var pointX2;
        var pointY2;
        var pointX3;
        var pointY3;
        for (i = 0; i <= steps; i++) {
            t = i / steps;
            pointX1 = this.bezierPoint(t, startPoint.x, controlPoint1.x, controlPoint2.x, endPoint.x);
            pointY1 = this.bezierPoint(t, startPoint.y, controlPoint1.y, controlPoint2.y, endPoint.y);
            if (i > 0) {
                pointX3 = pointX1 - pointX2;
                pointY3 = pointY1 - pointY2;
                length += Math.sqrt(pointX3 * pointX3 + pointY3 * pointY3);
            }
            pointX2 = pointX1;
            pointY2 = pointY1;
        }
        return length;
    };
    FreehandDrawing.prototype.bezierPoint = function (t, startPoint, cp1, cp2, endPoint) {
        return startPoint * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * cp1 * (1.0 - t) * (1.0 - t) * t + 3.0 *
            cp2 * (1.0 - t) * t * t + endPoint * t * t * t;
    };
    FreehandDrawing.prototype.drawArc = function (x, y, size, context) {
        var img = this.parent.img;
        if ((x > img.destLeft && y > img.destTop && x < (img.destLeft + img.destWidth) &&
            y < (img.destTop + img.destHeight) ||
            (context !== this.lowerContext && context !== this.upperContext))) {
            context.moveTo(x, y);
            context.arc(x, y, size, 0, 2 * Math.PI, false);
        }
    };
    FreehandDrawing.prototype.freehandRedraw = function (context, points) {
        var parent = this.parent;
        var temp = context.filter;
        context.filter = 'none';
        if (points) {
            parent.pointColl[parent.freehandCounter] = { points: points, strokeColor: parent.activeObj.strokeSettings.strokeColor,
                strokeWidth: this.penStrokeWidth, flipState: parent.transform.currFlipState,
                id: 'pen_' + (parent.freehandCounter + 1), order: parent.objColl.length + parent.freehandCounter + 1 };
            this.selPointColl[parent.freehandCounter] = extend({}, parent.pointColl[parent.freehandCounter], {}, true);
            parent.freehandCounter++;
        }
        if (parent.freehandCounter > 0) {
            for (var n = 0; n < parent.freehandCounter; n++) {
                parent.points = extend([], parent.pointColl[n].points);
                this.pointCounter = 0;
                var len = parent.points.length;
                var controlPoint1 = void 0;
                var controlPoint2 = void 0;
                var startPoint = void 0;
                var endPoint = void 0;
                var minStrokeWidth = void 0;
                var maxStrokeWidth = void 0;
                if (len > 0) {
                    context.fillStyle = parent.pointColl[n].strokeColor;
                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = parent.pointColl[n].strokeWidth;
                }
                if (len === 1) {
                    controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
                    this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
                }
                for (var l = 0; l < len - 3; l++) {
                    if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
                        controlPoint1 = (this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2])).controlPoint2;
                        controlPoint2 = (this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3])).controlPoint1;
                        if (l === 0) {
                            startPoint = parent.points[l];
                        }
                        else {
                            startPoint = parent.points[l + 1];
                        }
                        endPoint = parent.points[l + 2];
                        this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
                    }
                }
                context.closePath();
            }
            if (context === this.lowerContext) {
                parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
        }
        context.filter = temp;
    };
    FreehandDrawing.prototype.getSqPtFD = function (idx, obj) {
        var activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        var sPoints = extend([], this.selPointColl[idx].points, []);
        this.parent.points = extend([], this.parent.pointColl[idx].points);
        this.pointCounter = 0;
        var len = sPoints.length;
        for (var l = 0; l < len; l++) {
            if (activePoint.startX === 0 && activePoint.startY === 0 && activePoint.endX === 0 && activePoint.endY === 0) {
                activePoint.startX = sPoints[l].x;
                activePoint.startY = sPoints[l].y;
                activePoint.endX = sPoints[l].x;
                activePoint.endY = sPoints[l].y;
            }
            else {
                activePoint.startX = Math.min(activePoint.startX, sPoints[l].x);
                activePoint.startY = Math.min(activePoint.startY, sPoints[l].y);
                activePoint.endX = Math.max(activePoint.endX, sPoints[l].x);
                activePoint.endY = Math.max(activePoint.endY, sPoints[l].y);
            }
        }
        activePoint.startX -= this.penStrokeWidth;
        activePoint.startY -= this.penStrokeWidth;
        activePoint.endX += this.penStrokeWidth;
        activePoint.endY += this.penStrokeWidth;
        activePoint.width = activePoint.endX - activePoint.startX;
        activePoint.height = activePoint.endY - activePoint.startY;
        if (obj) {
            obj['activePoint'] = activePoint;
        }
        return activePoint;
    };
    FreehandDrawing.prototype.applyPenDraw = function () {
        var parent = this.parent;
        if (parent.currObjType.shape === 'freehanddraw') {
            parent.notify('shape', { prop: 'apply', onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            parent.currObjType.shape = '';
        }
        parent.notify('shape', { prop: 'clearActObj' });
    };
    FreehandDrawing.prototype.applyFhd = function () {
        var parent = this.parent;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var selectedPoint = parent.pointColl[this.fhdSelIdx];
        if (selectedPoint.strokeColor === '#42a5f5') {
            selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;
        }
        parent.notify('toolbar', { prop: 'setSelectedFreehandColor', value: { color: '#42a5f5' } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
        parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        if (selectedPoint) {
            selectedPoint.isSelected = false;
        }
        parent.notify('selection', { prop: 'resetFreehandDrawVariables' });
        this.fhdHovIdx = this.fhdSelIdx = null;
    };
    FreehandDrawing.prototype.cancelFhd = function () {
        var parent = this.parent;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var selectedPoint = parent.pointColl[this.fhdSelIdx];
        parent.notify('toolbar', { prop: 'setSelectedFreehandColor', value: { color: '#42a5f5' } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.pointCounter = 0;
        if (selectedPoint) {
            selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;
            selectedPoint.strokeWidth = this.tempFHDStyles.strokeWidth;
            selectedPoint.isSelected = false;
        }
        this.fhdHovIdx = this.fhdSelIdx = this.fhdSelID = null;
        parent.notify('selection', { prop: 'resetFreehandDrawVariables' });
        parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor;
        parent.activeObj.strokeSettings.strokeWidth = this.penStrokeWidth = this.tempFHDStyles.strokeWidth;
        this.tempFHDStyles = { strokeColor: null, strokeWidth: null, fillColor: null };
        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
        parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
    };
    FreehandDrawing.prototype.selectFhd = function (index) {
        var parent = this.parent;
        var tempFHDStyles = extend({}, this.tempFHDStyles, {}, true);
        parent.notify('selection', { prop: 'setFreehandDrawEditing', onPropertyChange: false, value: { bool: true } });
        if (index || index === 0) {
            if (this.isFHDIdx(index)) {
                this.fhdSelIdx = this.fhdHovIdx = index;
                this.hoverFhd();
                parent.upperCanvas.style.cursor = parent.cursor = 'pointer';
            }
            else {
                return;
            }
        }
        this.fhdSelIdx = this.fhdHovIdx;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var point = parent.pointColl[this.fhdSelIdx];
        point.isSelected = true;
        this.fhdSelID = point.id;
        if (point.strokeColor !== '#42a5f5') {
            parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor = point.strokeColor;
        }
        parent.activeObj.strokeSettings.strokeWidth = this.tempFHDStyles.strokeWidth =
            parent.pointColl[this.fhdHovIdx].strokeWidth;
        var obj = { bool: false };
        parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (obj['bool']) {
            var shapeSettings = { id: 'pen_' + (this.fhdSelIdx + 1), type: ShapeType.FreehandDraw,
                startX: point.points[0].x, startY: point.points[0].y, strokeColor: point.strokeColor,
                strokeWidth: point.strokeWidth, points: point.points, opacity: point.opacity,
                index: point.order };
            var shapeChangingArgs = { cancel: false, action: 'select', previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings };
            this.triggerShapeChanging(shapeChangingArgs);
        }
        else {
            parent.okBtn(null, true);
        }
        if (parent.isUndoRedoStack) {
            this.tempFHDStyles = tempFHDStyles;
        }
    };
    // eslint-disable-next-line  @typescript-eslint/no-unused-vars
    FreehandDrawing.prototype.deleteFhd = function (index, isId) {
        var parent = this.parent;
        if (this.isFHDIdx(index)) {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var tempPointColl = extend({}, parent.pointColl, {}, true);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var tempSelPointColl = extend({}, this.selPointColl, {}, true);
            parent.pointColl = {};
            this.selPointColl = {};
            var count = 0;
            for (var i = 0; i < parent.freehandCounter; i++) {
                if (parseInt(tempPointColl[i].id.split('_')[1], 10) - 1 !== index) {
                    parent.pointColl[count] = tempPointColl[i];
                    this.selPointColl[count] = tempSelPointColl[i];
                    count++;
                }
            }
            parent.freehandCounter -= 1;
            this.fhdHovIdx = this.fhdSelIdx = null;
            parent.notify('selection', { prop: 'resetFreehandDrawVariables' });
            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        }
    };
    FreehandDrawing.prototype.zoomX = function (x) {
        return (x * this.parent.img.destWidth) + this.parent.img.destLeft;
    };
    FreehandDrawing.prototype.zoomY = function (y) {
        return (y * this.parent.img.destHeight) + this.parent.img.destTop;
    };
    FreehandDrawing.prototype.zoomFHDColl = function (isPreventApply) {
        var parent = this.parent;
        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,
            width: parent.img.destWidth, height: parent.img.destHeight };
        parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });
        for (var n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            var len = parent.points.length;
            for (var l = 0; l < len; l++) {
                var point = parent.points[l];
                point.x = this.zoomX(point.ratioX);
                point.y = this.zoomY(point.ratioY);
            }
        }
        this.updateFHDCurPts();
        if (this.straightenPoint.x && this.straightenPoint.y) {
            this.straightenPoint.x = this.zoomX(this.straightenPoint.ratioX);
            this.straightenPoint.y = this.zoomY(this.straightenPoint.ratioY);
        }
        if (parent.transform.straighten !== 0) {
            parent.notify('shape', { prop: 'straightenFHD', onPropertyChange: false });
        }
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
        if (isNullOrUndefined(isPreventApply)) {
            this.freehandRedraw(this.lowerContext, null);
        }
    };
    FreehandDrawing.prototype.updateFHDCurPts = function () {
        var parent = this.parent;
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                var len = this.selPoints.length;
                for (var l = 0; l < len; l++) {
                    var point = this.selPoints[l];
                    point.x = this.zoomX(point.ratioX);
                    point.y = this.zoomY(point.ratioY);
                }
            }
        }
    };
    FreehandDrawing.prototype.rotateFhdColl = function () {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        for (var n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            var len = parent.points.length;
            for (var l = 0; l < len; l++) {
                var point = parent.points[l];
                point.y = destTop + (destHeight * point.ratioX);
                point.x = (destLeft + destWidth) - (destWidth * point.ratioY);
                point.ratioX = (point.x - destLeft) / destWidth;
                point.ratioY = (point.y - destTop) / destHeight;
            }
        }
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                var len = this.selPoints.length;
                for (var l = 0; l < len; l++) {
                    var point = this.selPoints[l];
                    point.y = destTop + (destHeight * point.ratioX);
                    point.x = (destLeft + destWidth) - (destWidth * point.ratioY);
                    point.ratioX = (point.x - destLeft) / destWidth;
                    point.ratioY = (point.y - destTop) / destHeight;
                }
            }
        }
        this.updateFHDCurPts();
    };
    FreehandDrawing.prototype.flipFHDColl = function (value) {
        var lowercaseValue = value.toLowerCase();
        if (lowercaseValue === 'horizontal') {
            this.pointsHorizontalFlip();
        }
        else if (lowercaseValue === 'vertical') {
            this.pointsVerticalFlip();
        }
        else {
            this.pointsHorizontalFlip();
            for (var i = 0; i < this.parent.freehandCounter; i++) {
                this.parent.pointColl[i].shapeFlip = '';
            }
            this.pointsVerticalFlip();
        }
    };
    FreehandDrawing.prototype.pointsHorizontalFlip = function () {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
                parent.points = extend([], parent.pointColl[n].points, []);
                this.pointCounter = 0;
                var len = parent.points.length;
                for (var l = 0; l < len; l++) {
                    var point = parent.points[l];
                    if (point.x <= destLeft + (destWidth / 2)) {
                        point.x = (destLeft + destWidth) - (point.x - destLeft);
                    }
                    else if (point.x >= destLeft + (destWidth / 2)) {
                        point.x = destLeft + (destLeft + destWidth - point.x);
                    }
                    point.ratioX = (point.x - destLeft) / destWidth;
                    point.ratioY = (point.y - destTop) / destHeight;
                }
                parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
            }
        }
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
                    this.selPoints = extend([], this.selPointColl[n].points, []);
                    this.pointCounter = 0;
                    var len = this.selPoints.length;
                    for (var l = 0; l < len; l++) {
                        var point = this.selPoints[l];
                        if (point.x <= destLeft + (destWidth / 2)) {
                            point.x = (destLeft + destWidth) - (point.x - destLeft);
                        }
                        else if (point.x >= destLeft + (destWidth / 2)) {
                            point.x = destLeft + (destLeft + destWidth - point.x);
                        }
                        point.ratioX = (point.x - destLeft) / destWidth;
                        point.ratioY = (point.y - destTop) / destHeight;
                    }
                }
            }
        }
        this.updateFHDCurPts();
    };
    FreehandDrawing.prototype.pointsVerticalFlip = function () {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
                parent.points = extend([], parent.pointColl[n].points, []);
                this.pointCounter = 0;
                var len = parent.points.length;
                for (var l = 0; l < len; l++) {
                    var point = parent.points[l];
                    if (point.y <= destTop + (destHeight / 2)) {
                        point.y = (destTop + destHeight) - (point.y - destTop);
                    }
                    else if (point.y >= destTop + (destHeight / 2)) {
                        point.y = destTop + (destTop + destHeight - point.y);
                    }
                    point.ratioX = (point.x - destLeft) / destWidth;
                    point.ratioY = (point.y - destTop) / destHeight;
                }
                parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
            }
        }
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
                    this.selPoints = extend([], this.selPointColl[n].points, []);
                    this.pointCounter = 0;
                    var len = this.selPoints.length;
                    for (var l = 0; l < len; l++) {
                        var point = this.selPoints[l];
                        if (point.y <= destTop + (destHeight / 2)) {
                            point.y = (destTop + destHeight) - (point.y - destTop);
                        }
                        else if (point.y >= destTop + (destHeight / 2)) {
                            point.y = destTop + (destTop + destHeight - point.y);
                        }
                        point.ratioX = (point.x - destLeft) / destWidth;
                        point.ratioY = (point.y - destTop) / destHeight;
                    }
                }
            }
        }
        this.updateFHDCurPts();
    };
    FreehandDrawing.prototype.updateFHDColl = function (isPreventApply) {
        var parent = this.parent;
        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,
            width: parent.img.destWidth, height: parent.img.destHeight };
        parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        for (var i = 0, iLen = parent.objColl.length; i < iLen; i++) {
            var currObj = parent.objColl[i];
            if (currObj.shape === 'line' || currObj.shape === 'arrow') {
                parent.notify('shape', { prop: 'straightenShapePoints', value: { obj: currObj, isReverse: true } });
            }
            else if (currObj.shape === 'path') {
                var temp = parent.transform.straighten;
                parent.transform.straighten = -parent.transform.straighten;
                parent.notify('shape', { prop: 'straightenPath', onPropertyChange: false, value: { obj: currObj } });
                parent.transform.straighten = temp;
            }
            currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) /
                    destWidth), startY: ((currObj.activePoint.startY - destTop) / destHeight),
                endX: ((currObj.activePoint.endX - destLeft) / destWidth),
                endY: ((currObj.activePoint.endY - destTop) / destHeight),
                width: destWidth / currObj.activePoint.width, height: destHeight /
                    currObj.activePoint.height };
            if (currObj.shape === 'path') {
                for (var j = 0, jLen = currObj.pointColl.length; j < jLen; j++) {
                    currObj.pointColl[j].ratioX =
                        (currObj.pointColl[j].x - destLeft) / destWidth;
                    currObj.pointColl[j].ratioY =
                        (currObj.pointColl[j].y - destTop) / destHeight;
                }
            }
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        }
        if (parent.freehandCounter > 0 && parent.transform.straighten !== 0) {
            var temp = parent.transform.straighten;
            parent.transform.straighten = -parent.transform.straighten;
            parent.notify('shape', { prop: 'straightenFHD', onPropertyChange: false });
            parent.transform.straighten = temp;
        }
        for (var n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            var len = parent.points.length;
            for (var l = 0; l < len; l++) {
                var point = parent.points[l];
                point.ratioX = (point.x - destLeft) / destWidth;
                point.ratioY = (point.y - destTop) / destHeight;
            }
        }
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                var len = this.selPoints.length;
                for (var l = 0; l < len; l++) {
                    var point = this.selPoints[l];
                    point.ratioX = (point.x - destLeft) / destWidth;
                    point.ratioY = (point.y - destTop) / destHeight;
                }
            }
        }
        if (this.straightenPoint.x && this.straightenPoint.y) {
            this.straightenPoint.ratioX = (this.straightenPoint.x - destLeft) / destWidth;
            this.straightenPoint.ratioY = (this.straightenPoint.y - destTop) / destHeight;
        }
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: isPreventApply } });
    };
    FreehandDrawing.prototype.panFHDColl = function (xDiff, yDiff, panRegion) {
        var parent = this.parent;
        for (var n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            var len = parent.points.length;
            for (var l = 0; l < len; l++) {
                var point = parent.points[l];
                if (panRegion === '' || panRegion === 'vertical') {
                    point.x += xDiff;
                }
                else {
                    point.x -= xDiff;
                }
                if (panRegion === '' || panRegion === 'horizontal') {
                    point.y += yDiff;
                }
                else {
                    point.y -= yDiff;
                }
            }
        }
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                var len = this.selPoints.length;
                for (var l = 0; l < len; l++) {
                    var point = this.selPoints[l];
                    if (panRegion === '' || panRegion === 'vertical') {
                        point.x += xDiff;
                    }
                    else {
                        point.x -= xDiff;
                    }
                    if (panRegion === '' || panRegion === 'horizontal') {
                        point.y += yDiff;
                    }
                    else {
                        point.y -= yDiff;
                    }
                }
            }
        }
        if (this.straightenPoint.x && this.straightenPoint.y) {
            if (panRegion === '' || panRegion === 'vertical') {
                this.straightenPoint.x += xDiff;
            }
            else {
                this.straightenPoint.x -= xDiff;
            }
            if (panRegion === '' || panRegion === 'horizontal') {
                this.straightenPoint.y += yDiff;
            }
            else {
                this.straightenPoint.y -= yDiff;
            }
        }
        this.freehandRedraw(this.lowerContext, null);
    };
    FreehandDrawing.prototype.freeHandDraw = function (value) {
        var parent = this.parent;
        if (value) {
            parent.points = [];
            this.dummyPoints = [];
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.togglePen = true;
            parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';
            parent.upperCanvas.style.display = 'block';
            if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
                var obj = { strokeSettings: {} };
                parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false,
                    value: { obj: obj } });
                parent.activeObj.strokeSettings = obj['strokeSettings'];
            }
            if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
                parent.activeObj.strokeSettings.strokeWidth = 2;
            }
            if (parent.isMaskImage) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
            else {
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            }
        }
        else {
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            var strokeWidth = this.penStrokeWidth;
            parent.notify('shape', { prop: 'apply', onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });
            parent.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: false } });
            this.penStrokeWidth = strokeWidth;
        }
    };
    FreehandDrawing.prototype.isFHDIdx = function (index, obj) {
        var isIndex = false;
        for (var i = 0; i < this.parent.freehandCounter; i++) {
            if (this.parent.pointColl[i].id &&
                parseInt(this.parent.pointColl[i].id.split('_')[1], 10) - 1 === index) {
                isIndex = true;
                break;
            }
        }
        if (obj) {
            obj['isIndex'] = isIndex;
        }
        return isIndex;
    };
    FreehandDrawing.prototype.updateCropPtsForSel = function () {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        for (var n = 0; n < parent.freehandCounter; n++) {
            var obj = { selPointColl: extend([], this.selPointColl) };
            if (obj['selPointColl'][n]) {
                this.selPoints = extend([], obj['selPointColl'][n].points, []);
                this.pointCounter = 0;
                var len = this.selPoints.length;
                for (var l = 0; l < len; l++) {
                    var point = this.selPoints[l];
                    point.ratioX = (point.x - actPoint.startX) / actPoint.width;
                    point.ratioY = (point.y - actPoint.startY) / actPoint.height;
                }
            }
        }
    };
    FreehandDrawing.prototype.triggerShapeChanging = function (shapeChangingArgs) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var parent = this.parent;
        var point = parent.pointColl[this.fhdSelIdx];
        parent.trigger('shapeChanging', shapeChangingArgs);
        if (parent.element.getAttribute('data-value') === 'mask-drawing' && !this.isMasking) {
            this.isMasking = true;
            parent.upperCanvas.style.cursor = 'crosshair';
            parent.notify('draw', { prop: 'updateTempObjColl' });
            parent.notify('draw', { prop: 'updateTempPointColl' });
            parent.discard();
            parent.selectMaskImage();
            return;
        }
        parent.editCompleteArgs = shapeChangingArgs;
        if (shapeChangingArgs.currentShapeSettings.id.indexOf('pen_') === -1 &&
            (shapeChangingArgs.action === 'draw-end' || shapeChangingArgs.action === 'select')) {
            var id = 'pen_' + shapeChangingArgs.currentShapeSettings.id;
            if (this.fhdSelIdx) {
                parent.pointColl[this.fhdSelIdx].id = id;
            }
            else {
                parent.pointColl[parent.freehandCounter - 1].id = id;
            }
        }
        this.penStrokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;
        if (parent.activeObj.strokeSettings.strokeColor !== shapeChangingArgs.currentShapeSettings.strokeColor) {
            parent.activeObj.strokeSettings.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;
            parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
        }
        if (this.fhdSelID && point && shapeChangingArgs.currentShapeSettings) {
            point.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;
            point.strokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;
            point.points = shapeChangingArgs.currentShapeSettings.points;
            point.opacity = shapeChangingArgs.currentShapeSettings.opacity;
        }
        if (shapeChangingArgs.action === 'select') {
            this.freehandRedraw(this.upperContext);
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
        }
    };
    FreehandDrawing.prototype.setCenterSelPoints = function () {
        var parent = this.parent;
        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,
            width: parent.img.destWidth, height: parent.img.destHeight };
        parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var actPoint = parent.activeObj.activePoint;
        if (isNullOrUndefined(this.prevStraightenObj) ||
            (JSON.stringify(this.prevStraightenObj.activePoint) !== JSON.stringify(actPoint))) {
            this.straightenPoint = { x: actPoint.startX + (actPoint.width / 2),
                y: actPoint.startY + (actPoint.height / 2),
                ratioX: (actPoint.startX + (actPoint.width / 2) - destLeft) / destWidth,
                ratioY: (actPoint.startY + (actPoint.height / 2) - destTop) / destHeight };
            this.prevStraightenObj = extend({}, parent.activeObj, {}, true);
            this.straightenPointAngle = parent.transform.straighten;
        }
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
    };
    return FreehandDrawing;
}());

/* eslint-disable prefer-const */
var Selection = /** @class */ (function () {
    function Selection(parent) {
        this.diffPoint = { x: 0, y: 0 }; // updates resize points
        this.oldPoint = {};
        this.isTouch = false;
        this.isObjSelected = false;
        this.isFhdPoint = false; // Specifies whether mouse cursor is on freehand drawing point or not
        this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 }; // updates drag start and end points in mousedown and mousemove
        this.isShapeInserted = false;
        this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [], triangle: [], triangleRatio: [], order: null }; // for undo redo
        this.isFirstMove = false; // for pinch zoom
        this.startTouches = []; // for pinch zoom
        this.tempTouches = []; // for pinch zoom
        this.currMousePoint = { x: 0, y: 0 }; // To prevent mouse move event on pinch zoom
        this.cursorTargetId = '';
        this.isPreventDragging = false; // Shapes dragging is prevented when crop region is inside shape points
        this.dragElement = '';
        this.textRow = 1; // text area row count
        this.mouseDownPoint = { x: 0, y: 0 };
        this.previousPoint = { x: 0, y: 0 }; // updates prev x and y points in mouseMove
        this.zoomType = 'Toolbar';
        this.isInitialTextEdited = false;
        this.dragCanvas = false;
        this.isFhdCustomized = false;
        this.touchEndPoint = {};
        this.isFhdEditing = false; // Specifies whether freehand drawing is in editing mode or not
        this.currentDrawingShape = '';
        this.initialPrevObj = {};
        this.touchTime = 0;
        this.resizedElement = '';
        this.isImageClarity = true;
        this.isPinching = false;
        this.isSliding = false;
        this.mouseDown = '';
        this.isSliderActive = false;
        this.arrowShape = [ArrowheadType.None, ArrowheadType.SolidArrow];
        this.isTouchDblClick = false;
        this.isMouseDown = false;
        this.isMouseUp = false;
        this.mouseWheel = 0;
        this.isTransformedShape = false;
        this.parent = parent;
        this.addEventListener();
    }
    Selection.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    Selection.prototype.addEventListener = function () {
        this.parent.on('selection', this.selection, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    Selection.prototype.removeEventListener = function () {
        this.parent.off('selection', this.selection);
        this.parent.off('destroyed', this.destroy);
    };
    Selection.prototype.selection = function (args) {
        var parent = this.parent;
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'setCursor':
                this.setCursor(args.value['x'], args.value['y']);
                break;
            case 'updateActivePoint':
                this.updateActivePoint(args.value['x'], args.value['y'], args.value['isCropSelection']);
                break;
            case 'updateCursorStyles':
                this.updateCursorStyles(args.value['x'], args.value['y'], args.value['type']);
                break;
            case 'setTextSelection':
                this.setTextSelection(args.value['width'], args.value['height']);
                break;
            case 'setActivePoint':
                this.setActivePoint(args.value['startX'], args.value['startY']);
                break;
            case 'clearSelection':
                this.clearSelection(args.value['resetCrop']);
                break;
            case 'calcShapeRatio':
                this.calcShapeRatio(args.value['x'], args.value['y'], args.value['imgWidth'], args.value['imgHeight']);
                break;
            case 'tab':
                this.performTabAction();
                break;
            case 'setDragDirection':
                this.setDragDirection(args.value['width'], args.value['height']);
                break;
            case 'clearUpperCanvas':
                if (this.isTouch) {
                    setTimeout(function () {
                        parent.upperCanvas.getContext('2d').clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    }, 550);
                }
                break;
            case 'resetFreehandDrawVariables':
                this.isFhdEditing = this.isFhdPoint = false;
                break;
            case 'isShapeInserted':
                this.isShapeInserted = args.value['bool'];
                break;
            case 'redrawShape':
                this.redrawShape(args.value['obj']);
                break;
            case 'setTextBoxStylesToActObj':
                this.setTextBoxStylesToActObj();
                break;
            case 'mouseDownEventHandler':
                this.mouseDownEventHandler(args.value['e']);
                break;
            case 'mouseMoveEventHandler':
                this.mouseMoveEventHandler(args.value['e']);
                break;
            case 'mouseUpEventHandler':
                this.mouseUpEventHandler(args.value['e']);
                break;
            case 'canvasMouseDownHandler':
                this.canvasMouseDownHandler(args.value['e']);
                break;
            case 'canvasMouseMoveHandler':
                this.canvasMouseMoveHandler(args.value['e']);
                break;
            case 'canvasMouseUpHandler':
                this.canvasMouseUpHandler(args.value['e']);
                break;
            case 'touchStartHandler':
                this.touchStartHandler(args.value['e']);
                break;
            case 'keyDownEventHandler':
                this.keyDownEventHandler(args.value['e']);
                break;
            case 'handleScroll':
                this.handleScroll(args.value['e']);
                break;
            case 'textKeyDown':
                setTimeout(this.textKeyDown.bind(this), 1, args.value['e']);
                break;
            case 'deleteItem':
                this.deleteItem();
                break;
            case 'updatePrevShapeSettings':
                this.updatePrevShapeSettings(args.value['obj']);
                break;
            case 'getZoomType':
                args.value['obj']['zoomType'] = this.zoomType;
                break;
            case 'setZoomType':
                this.zoomType = args.value['zoomType'];
                break;
            case 'setInitialTextEdit':
                this.isInitialTextEdited = args.value['bool'];
                break;
            case 'setDragCanvas':
                this.dragCanvas = args.value['bool'];
                break;
            case 'setFreehandDrawCustomized':
                this.isFhdCustomized = args.value['isFreehandDrawCustomized'];
                break;
            case 'setTouchEndPoint':
                this.touchEndPoint.x = args.value['x'];
                this.touchEndPoint.y = args.value['y'];
                break;
            case 'getPanDown':
                args.value['obj']['panDown'] = this.panDown;
                break;
            case 'setPanDown':
                this.panDown = args.value['panDown'];
                break;
            case 'getFreehandDrawEditing':
                args.value['obj']['bool'] = this.isFhdEditing;
                break;
            case 'setFreehandDrawEditing':
                this.isFhdEditing = args.value['bool'];
                break;
            case 'getTempActObj':
                args.value['obj']['tempObj'] = this.tempActiveObj;
                break;
            case 'setTempActObj':
                this.tempActiveObj = args.value['obj'];
                break;
            case 'isInside':
                this.isInside(args.value['x'], args.value['y'], args.value['z1'], args.value['z2'], args.value['z3'], args.value['z4']);
                break;
            case 'setDragElement':
                this.dragElement = args.value['value'];
                break;
            case 'setObjSelected':
                this.isObjSelected = args.value['bool'];
                break;
            case 'adjustActObjForLineArrow':
                this.adjustActObjForLineArrow(args.value['obj']);
                break;
            case 'findTarget':
                this.findTarget(args.value['x'], args.value['y'], args.value['type']);
                break;
            case 'getCurrentFlipState':
                this.getCurrentFlipState();
                break;
            case 'setDragWidth':
                this.setDragWidth(args.value['width']);
                break;
            case 'setDragHeight':
                this.setDragHeight(args.value['setDragHeight']);
                break;
            case 'annotate':
                this.currentDrawingShape = args.value['shape'];
                if (args.value['shape'] === 'text') {
                    parent.activeObj.textSettings.fontSize = 11;
                    parent.activeObj.keyHistory = 'Enter Text';
                    parent.notify('shape', { prop: 'initializeTextShape', onPropertyChange: false,
                        value: { text: null, fontFamily: null, fontSize: null, bold: null, italic: null, strokeColor: null } });
                }
                else if (args.value['shape'] === 'path') {
                    parent.activeObj.pointColl = [];
                }
                break;
            case 'getCurrentDrawingShape':
                args.value['obj']['shape'] = this.currentDrawingShape;
                break;
            case 'setCurrentDrawingShape':
                this.currentDrawingShape = args.value['value'];
                break;
            case 'getTransRotationPoint':
                this.getTransRotationPoint(args.value['obj'], args.value['object']);
                break;
            case 'adjustNEPoints':
                this.adjustNEPoints(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle']);
                break;
            case 'adjustRotationPoints':
                this.adjustRotationPoints(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle'], args.value['type'], args.value['elem']);
                break;
            case 'getResizeDirection':
                this.getResizeDirection(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle']);
                break;
            case 'setResizedElement':
                this.resizedElement = args.value['value'];
                break;
            case 'reset':
                this.reset();
                break;
            case 'unWireEvent':
                this.unwireEvent();
                break;
            case 'updPtCollForShpRot':
                this.updPtCollForShpRot(args.value['obj']);
                break;
            case 'findImageRatio':
                this.findImageRatio(args.value['width'], args.value['height'], args.value['obj']);
                break;
            case 'getNumTextValue':
                this.getNumTextValue(args.value['obj']);
                break;
            case 'setImageClarity':
                this.isImageClarity = args.value['bool'];
                break;
            case 'upgradeImageQuality':
                this.upgradeImageQuality();
                break;
            case 'triggerShapeChange':
                this.triggerShapeChange(args.value['shapeResizingArgs'], args.value['shapeMovingArgs'], args.value['type']);
                break;
            case 'applyTransformToImg':
                this.applyTransformToImg(args.value['ctx']);
                break;
            case 'findTargetObj':
                args.value['obj']['bool'] = this.findTargetObj(args.value['x'], args.value['y'], args.value['isCrop']);
                break;
            case 'setSliding':
                this.isSliding = args.value['bool'];
                break;
            case 'setSliderActive':
                this.isSliderActive = args.value['bool'];
                break;
            case 'getArrowType':
                args.value['obj']['type'] = this.getArrowType(args.value['type']);
                break;
            case 'setArrowShape':
                if (args.value['type'] === 'initial') {
                    this.arrowShape[0] = args.value['shape'];
                }
                else {
                    this.arrowShape[1] = args.value['shape'];
                }
                break;
            case 'updateNWPoints':
                this.updateNWPoints(args.value['x'], args.value['y']);
                break;
            case 'updateNPoints':
                this.updateNPoints(args.value['x'], args.value['y']);
                break;
            case 'updateNEPoints':
                this.updateNEPoints(args.value['x'], args.value['y']);
                break;
            case 'updateWPoints':
                this.updateWPoints(args.value['x'], args.value['y']);
                break;
            case 'updateEPoints':
                this.updateEPoints(args.value['x'], args.value['y']);
                break;
            case 'updateSWPoints':
                this.updateSWPoints(args.value['x'], args.value['y']);
                break;
            case 'updateSPoints':
                this.updateSPoints(args.value['x'], args.value['y']);
                break;
            case 'updateSEPoints':
                this.updateSEPoints(args.value['x'], args.value['y']);
                break;
            case 'drawMaskCircle':
                this.drawMaskCircle(args.value['x'], args.value['y']);
                break;
            case 'isValueUpdated':
                this.isValueUpdated();
                break;
            case 'getDistance':
                this.getDistance(args.value['x'], args.value['y']);
                break;
            case 'redact':
                this.currentDrawingShape = args.value['shape'];
                break;
            case 'updateTransColl':
                args.value['obj']['coll'] = this.updateTransColl(args.value['object']);
                break;
            case 'getTransformedShape':
                args.value['obj']['bool'] = this.isTransformedShape;
                break;
            case 'setTransformedShape':
                this.isTransformedShape = args.value['bool'];
                break;
            case 'rgbToHex':
                this.rgbToHex(args.value['r'], args.value['g'], args.value['b'], args.value['a']);
                break;
            case 'padLeft':
                this.padLeft(args.value['value'], args.value['length'], args.value['padChar']);
                break;
            case 'setTimer':
                this.setTimer(args.value['e']);
                break;
            case 'targetTouches':
                args.value['output'] = this.targetTouches(args.value['touches']);
                break;
            case 'calculateScale':
                args.value['output'] = this.calculateScale(args.value['startTouches'], args.value['endTouches']);
                break;
            case 'beforeSaveEvent':
                this.beforeSaveEvent(args.value['args'], args.value['e']);
                break;
            case 'isKeyBoardCrop':
                args.value['output'] = this.isKeyBoardCrop(args.value['e']);
                break;
            case 'focusRatioBtn':
                this.focusRatioBtn();
                break;
            case 'performEnterAction':
                this.performEnterAction(args.value['e']);
                break;
            case 'getImagePoints':
                args.value['output'] = this.getImagePoints(args.value['x'], args.value['y']);
                break;
            case 'revertPoints':
                this.revertPoints(args.value['actPoint'], args.value['tempActiveObj']);
                break;
            case 'performNWResize':
                this.performNWResize(args.value['x'], args.value['y'], args.value['tempActiveObj'], args.value['actPoint']);
                break;
            case 'performSEResize':
                this.performSEResize(args.value['x'], args.value['y'], args.value['tempActiveObj'], args.value['actPoint']);
                break;
            case 'isMouseOutsideImg':
                args.value['output'] = this.isMouseOutsideImg(args.value['x'], args.value['y']);
                break;
        }
    };
    Selection.prototype.getModuleName = function () {
        return 'selection';
    };
    Selection.prototype.updatePrivateVariables = function () {
        var parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
    };
    Selection.prototype.reset = function () {
        this.diffPoint = { x: 0, y: 0 };
        this.oldPoint = {};
        this.isTouch = this.isObjSelected = this.isFhdPoint = this.isShapeInserted = false;
        this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 };
        this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [], triangle: [], triangleRatio: [], order: null };
        this.isFirstMove = false;
        this.cursorTargetId = this.dragElement = '';
        this.isTouchDblClick = false;
        this.startTouches = [];
        this.tempTouches = [];
        this.currMousePoint = { x: 0, y: 0 };
        this.isPreventDragging = false;
        this.timer = undefined;
        this.tempObjColl = undefined;
        this.mouseWheel = 0;
        this.textRow = 1;
        this.mouseDownPoint = { x: 0, y: 0 };
        this.previousPoint = { x: 0, y: 0 };
        this.zoomType = 'Toolbar';
        this.isInitialTextEdited = false;
        this.dragCanvas = this.isPinching = false;
        this.isFhdCustomized = false;
        this.touchEndPoint = {};
        this.panDown = null;
        this.isSliding = false;
        this.isFhdEditing = false;
        this.pathAdjustedIndex = null;
        this.touchTime = 0;
        this.isImageClarity = true;
        this.currentDrawingShape = '';
        this.initialPrevObj = {};
        this.resizedElement = '';
        this.mouseDown = '';
        this.isSliderActive = false;
        this.arrowShape = [ArrowheadType.None, ArrowheadType.SolidArrow];
        this.isMouseDown = this.isMouseUp = this.isTransformedShape = false;
    };
    Selection.prototype.performTabAction = function () {
        var parent = this.parent;
        if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
            var allowUndoRedoPush = this.applyCurrShape(false);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            if (allowUndoRedoPush) {
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
        }
        parent.isKBDNavigation = true;
    };
    Selection.prototype.selMouseUpEvent = function () {
        this.oldPoint.x = undefined;
        this.oldPoint.y = undefined;
    };
    Selection.prototype.getMouseCursor = function (actObj, x, y, isCropSelection, isApply) {
        var rotationCirclePoint = this.getTransRotationPoint(actObj);
        var radius = actObj.bottomCenterCircle.radius;
        var cursor = 'default';
        var ratio = isApply ? 0 : ((actObj.topLeftCircle.radius * 2));
        if (x >= (actObj.topLeftCircle.startX - ratio) &&
            x <= (actObj.topLeftCircle.startX + ratio) &&
            y >= (actObj.topLeftCircle.startY - ratio) &&
            y <= (actObj.topLeftCircle.startY + ratio)) {
            cursor = 'nw-resize';
        }
        else if (x >= (actObj.topLeftCircle.startX - ratio) &&
            x <= (actObj.topRightCircle.startX - ratio) &&
            y >= (actObj.topCenterCircle.startY - ratio) &&
            y <= (actObj.topCenterCircle.startY + ratio)) {
            cursor = 'n-resize';
        }
        else if (x >= (actObj.topRightCircle.startX - ratio) &&
            x <= (actObj.topRightCircle.startX + ratio) &&
            y >= (actObj.topRightCircle.startY - ratio) &&
            y <= (actObj.topRightCircle.startY + ratio)) {
            cursor = 'ne-resize';
        }
        else if (x >= (actObj.centerLeftCircle.startX - ratio) &&
            x <= (actObj.centerLeftCircle.startX + ratio) &&
            y >= (actObj.topLeftCircle.startY - ratio) &&
            y <= (actObj.bottomLeftCircle.startY - ratio)) {
            cursor = 'w-resize';
        }
        else if (x >= (actObj.centerRightCircle.startX - ratio) &&
            x <= (actObj.centerRightCircle.startX + ratio) &&
            y >= (actObj.topRightCircle.startY - ratio) &&
            y <= (actObj.bottomRightCircle.startY - ratio)) {
            cursor = 'e-resize';
        }
        else if (x >= (actObj.bottomLeftCircle.startX - ratio) &&
            x <= (actObj.bottomLeftCircle.startX + ratio) &&
            y >= (actObj.bottomLeftCircle.startY - ratio) &&
            y <= (actObj.bottomLeftCircle.startY + ratio)) {
            cursor = 'sw-resize';
        }
        else if (x >= (actObj.bottomLeftCircle.startX - ratio) &&
            x <= (actObj.bottomRightCircle.startX - ratio) &&
            y >= (actObj.bottomCenterCircle.startY - ratio) &&
            y <= (actObj.bottomCenterCircle.startY + ratio)) {
            cursor = 's-resize';
        }
        else if (x >= (actObj.bottomRightCircle.startX - ratio) &&
            x <= (actObj.bottomRightCircle.startX + ratio) &&
            y >= (actObj.bottomRightCircle.startY - ratio) &&
            y <= (actObj.bottomRightCircle.startY + ratio)) {
            cursor = 'se-resize';
        }
        else if ((x >= actObj.activePoint.startX &&
            x <= actObj.activePoint.endX) && (y >= actObj.activePoint.startY &&
            y <= actObj.activePoint.endY)) {
            if (isCropSelection) {
                cursor = 'grab';
            }
            else {
                cursor = 'move';
            }
        }
        else if (rotationCirclePoint && !isApply &&
            x >= (rotationCirclePoint.x - (radius + 2)) &&
            x <= rotationCirclePoint.x + (radius + 2) &&
            y >= rotationCirclePoint.y - (radius + 2) &&
            y <= rotationCirclePoint.y + (radius + 2)) {
            cursor = 'grabbing';
        }
        else {
            cursor = 'default';
        }
        return cursor;
    };
    Selection.prototype.setCursor = function (x, y) {
        var parent = this.parent;
        parent.upperCanvas.style.cursor = parent.cursor = 'default';
        var frameObject = { bool: null };
        parent.notify('toolbar', { prop: 'getFrameToolbar', onPropertyChange: false, value: { obj: frameObject } });
        if (parent.isResize || this.isSliding || frameObject['bool']) {
            parent.upperCanvas.style.cursor = 'default';
            return;
        }
        var isCropSelection = false;
        var splitWords;
        if (parent.activeObj.shape) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if ((!splitWords && parent.currObjType.isCustomCrop) || (splitWords && splitWords[0] === 'crop')) {
            isCropSelection = true;
        }
        if (parent.currObjType.isDragging) {
            if (this.dragElement === '') {
                parent.upperCanvas.style.cursor = parent.cursor = 'move';
            }
            else {
                parent.upperCanvas.style.cursor = parent.cursor = this.dragElement;
            }
            return;
        }
        if (parent.togglePen) {
            parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';
            if (parent.isMaskImage) {
                this.drawMaskCircle(x, y);
                parent.upperCanvas.style.cursor = 'none';
            }
            return;
        }
        if (parent.activeObj.shape) {
            this.setCursorForActObj(splitWords, isCropSelection, x, y);
        }
        if (parent.cursor === 'default' || parent.cursor === 'grab') {
            var highestOrder = this.getHighestOrder();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var tempShapeColl = extend([], parent.shapeColl, [], true);
            var objColl = extend([], parent.objColl, [], true);
            var isShape = false;
            while (highestOrder > 0) {
                isShape = false;
                for (var i = tempShapeColl.length - 1; i >= 0; i--) {
                    if (tempShapeColl[i].order === highestOrder) {
                        isShape = true;
                        if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf('pen') > -1) {
                            if (parent.pointColl[0] && (parent.cursor !== 'grab' || !isCropSelection)
                                && !parent.currObjType.isDragging && !parent.currObjType.isResize) {
                                var points = extend([], parent.points, [], true);
                                if (!isCropSelection) {
                                    this.setCursorForFreehandDrawing(x, y, parent.upperCanvas, tempShapeColl[i].id);
                                }
                                parent.points = points;
                            }
                        }
                        else {
                            parent.objColl = [];
                            parent.objColl.push(extend({}, tempShapeColl[i], null, true));
                            var cursor = parent.upperCanvas.style.cursor;
                            if (parent.objColl.length > 0 && (parent.cursor !== 'grab' || !isCropSelection)) {
                                this.setCursorFromObj(x, y, parent.objColl, parent.upperCanvas, isCropSelection);
                            }
                            if (cursor === 'grab' && parent.cursor === 'default') {
                                parent.upperCanvas.style.cursor = parent.cursor = 'grab';
                            }
                        }
                    }
                    else if (isNullOrUndefined(tempShapeColl[i].order)) {
                        isShape = true;
                    }
                }
                if (parent.cursor !== 'default' && parent.cursor !== 'grab') {
                    break;
                }
                else if (isShape) {
                    var isBreak = false;
                    while (!isBreak && highestOrder > 0) {
                        for (var a = 0; a < tempShapeColl.length; a++) {
                            if (tempShapeColl[a].order === highestOrder - 1) {
                                isBreak = true;
                                break;
                            }
                        }
                        highestOrder--;
                        if (!isBreak) {
                            highestOrder--;
                        }
                    }
                }
            }
            parent.objColl = objColl;
            if (parent.cursor === 'default' || parent.cursor === 'grab') {
                if (parent.togglePan) {
                    parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';
                }
            }
        }
        if (this.currentDrawingShape !== '' && (parent.cursor === 'default' || parent.cursor === 'grab')) {
            parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';
        }
    };
    Selection.prototype.getHighestOrder = function () {
        var highestOrder = 0;
        for (var i = 0; i < this.parent.shapeColl.length; i++) {
            if (this.parent.shapeColl[i].order > highestOrder) {
                highestOrder = this.parent.shapeColl[i].order;
            }
        }
        return highestOrder;
    };
    Selection.prototype.drawMaskCircle = function (x, y) {
        var parent = this.parent;
        if (parent.isMaskImage) {
            var radius = parent.activeObj.strokeSettings.strokeWidth * 2;
            var canvasDraw = parent.maskCanvas.getContext('2d');
            canvasDraw.clearRect(0, 0, parent.maskCanvas.width, parent.maskCanvas.height);
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            canvasDraw.strokeStyle = '#fff';
            canvasDraw.beginPath();
            canvasDraw.ellipse(x, y, radius / 2, radius / 2, 0, 0, 2 * Math.PI, false);
            canvasDraw.fill();
            canvasDraw.stroke();
            canvasDraw.closePath();
            parent.maskCanvas.style.cursor = 'none';
        }
    };
    Selection.prototype.setCursorForActObj = function (splitWords, isCropSelection, x, y) {
        var parent = this.parent;
        if (parent.activeObj.horTopLine !== undefined) {
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords === undefined && parent.currObjType.isCustomCrop) {
                isCropSelection = true;
            }
            else if (splitWords !== undefined && splitWords[0] === 'crop') {
                isCropSelection = true;
            }
            if (!isCropSelection && parent.togglePan) {
                parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';
            }
            var cursor = parent.upperCanvas.style.cursor;
            var actObj = extend({}, parent.activeObj, {}, true);
            this.cursorTargetId = actObj.currIndex;
            var degree = void 0;
            if (actObj.shapeDegree === 0) {
                degree = parent.transform.degree;
            }
            else {
                degree = parent.transform.degree - actObj.shapeDegree;
            }
            if (degree < 0) {
                degree = 360 + degree;
            }
            if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
            }
            else if (actObj.shape === 'path') {
                this.setCursorForPath(actObj, x, y, parent.upperCanvas);
            }
            else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
                this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
            }
            else {
                parent.upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, false);
                var cursorColl = ['n-resize', 's-resize', 'e-resize', 'w-resize'];
                if ((actObj.shape === 'text') && cursorColl.indexOf(parent.cursor) > -1) {
                    parent.upperCanvas.style.cursor = parent.cursor = 'move';
                }
            }
            if (cursor === 'default' && parent.cursor === 'default' && isCropSelection) {
                parent.upperCanvas.style.cursor = parent.cursor = 'grab';
            }
            if (cursor === 'grab' && parent.cursor === 'default') {
                parent.upperCanvas.style.cursor = parent.cursor = 'grab';
            }
        }
        else if (parent.togglePan && !parent.togglePen) {
            parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';
        }
        else {
            if (parent.currObjType.isCustomCrop || parent.togglePen) {
                parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';
            }
            else {
                parent.upperCanvas.style.cursor = parent.cursor = 'default';
            }
        }
    };
    Selection.prototype.setCursorForPath = function (actObj, x, y, upperCanvas) {
        this.setCursorForLineArrow(actObj, x, y, upperCanvas);
        var parent = this.parent;
        if (parent.cursor === 'default') {
            var obj = extend({}, actObj, null, true);
            var isMove = false;
            for (var i = 1, len = actObj.pointColl.length; i < len; i++) {
                if (isMove) {
                    break;
                }
                obj.activePoint.startX = actObj.pointColl[i - 1].x;
                obj.activePoint.startY = actObj.pointColl[i - 1].y;
                obj.activePoint.endX = actObj.pointColl[i].x;
                obj.activePoint.endY = actObj.pointColl[i].y;
                parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,
                    value: { obj: obj } });
                var radius = actObj.topLeftCircle.radius;
                for (var j = 0, jLen = obj.pointColl.length; j < jLen; j++) {
                    var point = obj.pointColl[j];
                    if (!isNullOrUndefined(point.x - (radius * 2)) &&
                        !isNullOrUndefined(point.x + (radius * 2)) &&
                        !isNullOrUndefined(point.y - (radius * 2)) &&
                        !isNullOrUndefined(point.y + (radius * 2)) &&
                        x >= (point.x - (radius * 2)) &&
                        x <= (point.x + (radius * 2)) &&
                        y >= (point.y - (radius * 2)) &&
                        y <= (point.y + (radius * 2))) {
                        upperCanvas.style.cursor = parent.cursor = 'move';
                        isMove = true;
                        break;
                    }
                    else {
                        upperCanvas.style.cursor = parent.cursor = 'default';
                    }
                }
            }
        }
        return parent.cursor;
    };
    Selection.prototype.setCursorForLineArrow = function (actObj, x, y, upperCanvas) {
        var index;
        var radius = actObj.topLeftCircle.radius;
        if (isNullOrUndefined(actObj.pointColl)) {
            return index;
        }
        for (var i = 0, len = actObj.pointColl.length; i < len; i++) {
            var point = actObj.pointColl[i];
            if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&
                y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {
                upperCanvas.style.cursor = this.parent.cursor = 'move';
                index = i;
                break;
            }
            else {
                upperCanvas.style.cursor = this.parent.cursor = 'default';
            }
        }
        return index;
    };
    Selection.prototype.setCursorForRotatedObject = function (actObj, x, y, upperCanvas) {
        this.resizedElement = '';
        var parent = this.parent;
        var radius = actObj.bottomCenterCircle.radius;
        var horTP = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)];
        var horTP1 = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)];
        var verLP = actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)];
        var verRP = actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)];
        var horBP = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)];
        var horBP1 = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)];
        var rotCP = actObj.rotationCirclePointColl;
        var horTP0 = actObj.horTopLinePointColl[0];
        var horBP0 = actObj.horBottomLinePointColl[0];
        if (x >= (horTP0.x - (radius + 2)) && x <= (horTP0.x + (radius + 2)) && y >= (horTP0.y - (radius + 2)) &&
            y <= (horTP0.y + (radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'nw-resize';
        }
        else if (x >= (horTP.x - 5) && x <= (horTP.x + 5) && y >= (horTP.y - 5) && y <= (horTP.y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'n-resize';
        }
        else if (x >= (horTP1.x - (radius + 2)) && x <= (horTP1.x + (radius + 2)) && y >= (horTP1.y - (radius + 2)) &&
            y <= (horTP1.y + (radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'ne-resize';
        }
        else if (x >= (verLP.x - 5) && x <= (verLP.x + 5) && y >= (verLP.y - 5) && y <= (verLP.y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'w-resize';
        }
        else if (x >= (verRP.x - 5) && x <= (verRP.x + 5) && y >= (verRP.y - 5) && y <= (verRP.y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'e-resize';
        }
        else if (x >= (horBP0.x - (radius + 2)) && x <= (horBP0.x + (radius + 2)) && y >= (horBP0.y - (radius + 2)) &&
            y <= (horBP0.y + (radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'sw-resize';
        }
        else if (x >= (horBP.x - 5) && x <= (horBP.x + 5) && y >= (horBP.y - 5) && y <= (horBP.y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 's-resize';
        }
        else if (x >= (horBP1.x - (radius + 2)) && x <= (horBP1.x + (radius + 2)) && y >= (horBP1.y - (radius + 2)) &&
            y <= (horBP1.y + (radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'se-resize';
        }
        else if (rotCP && x >= (rotCP.x - (radius + 2)) && x <= rotCP.x + (radius + 2) && y >= rotCP.y - (radius + 2) &&
            y <= rotCP.y + (radius + 2)) {
            upperCanvas.style.cursor = parent.cursor = 'grabbing';
        }
        else {
            upperCanvas.style.cursor = parent.cursor = 'default';
            var isPointsInsideRectangle = this.getRectanglePoints(actObj.activePoint.startX, actObj.activePoint.startY, actObj.activePoint.width, actObj.activePoint.height, actObj.rotatedAngle * (180 / Math.PI), x, y);
            if (isPointsInsideRectangle) {
                upperCanvas.style.cursor = parent.cursor = 'move';
            }
        }
        if (parent.cursor === 'default') {
            for (var i = 0, len = actObj.horTopLinePointColl.length; i < len; i++) {
                var horTP_1 = actObj.horTopLinePointColl[i];
                if (x >= (horTP_1.x - 5) && x <= (horTP_1.x + 5) && y >= (horTP_1.y - 5) && y <= (horTP_1.y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'n-resize';
                    break;
                }
            }
        }
        if (parent.cursor === 'default') {
            for (var i = 0, len = actObj.horBottomLinePointColl.length; i < len; i++) {
                var horBP_1 = actObj.horBottomLinePointColl[i];
                if (x >= (horBP_1.x - 5) && x <= (horBP_1.x + 5) && y >= (horBP_1.y - 5) && y <= (horBP_1.y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 's-resize';
                    break;
                }
            }
        }
        if (parent.cursor === 'default') {
            for (var i = 0, len = actObj.verLeftLinePointColl.length; i < len; i++) {
                var verLP_1 = actObj.verLeftLinePointColl[i];
                if (x >= (verLP_1.x - 5) && x <= (verLP_1.x + 5) && y >= (verLP_1.y - 5) && y <= (verLP_1.y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'w-resize';
                    break;
                }
            }
        }
        if (parent.cursor === 'default') {
            for (var i = 0, len = actObj.verRightLinePointColl.length; i < len; i++) {
                var verRP_1 = actObj.verRightLinePointColl[i];
                if (x >= (verRP_1.x - 5) && x <= (verRP_1.x + 5) && y >= (verRP_1.y - 5) && y <= (verRP_1.y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'e-resize';
                    break;
                }
            }
        }
        this.adjustCursorStylesForRotatedState(actObj);
        return parent.cursor;
    };
    Selection.prototype.adjustCursorStylesForRotatedState = function (actObj) {
        var parent = this.parent;
        var length = actObj.rotatedAngle * (180 / Math.PI);
        length = length > 0 ? Math.floor(length) : Math.ceil(length);
        if ((length >= 92 && length <= 182) || (length >= -178 && length <= -88)) {
            var cursorMap = { 'nw-resize': 'ne-resize', 'n-resize': 's-resize',
                'ne-resize': 'nw-resize', 'w-resize': 'e-resize', 'e-resize': 'w-resize',
                'sw-resize': 'se-resize', 's-resize': 'n-resize', 'se-resize': 'sw-resize'
            };
            if (parent.cursor in cursorMap) {
                parent.cursor = cursorMap[parent.cursor];
            }
        }
        parent.upperCanvas.style.cursor = this.getResizeElement((actObj.rotatedAngle * (180 / Math.PI)), parent.cursor);
        return parent.cursor;
    };
    Selection.prototype.getResizeElement = function (degree, element) {
        var resizeMappings = [];
        switch (element) {
            case 'nw-resize':
                resizeMappings = [
                    [337.5, 22.5, 'nw-resize'], [22.5, 67.5, 'n-resize'], [67.5, 112.5, 'ne-resize'],
                    [112.5, 157.5, 'e-resize'], [157.5, 202.5, 'se-resize'],
                    [202.5, 247.5, 's-resize'], [247.5, 292.5, 'sw-resize'],
                    [292.5, 337.5, 'w-resize']
                ];
                break;
            case 'n-resize':
                resizeMappings = [
                    [337.5, 22.5, 'n-resize'], [22.5, 67.5, 'ne-resize'], [67.5, 112.5, 'e-resize'],
                    [112.5, 157.5, 'se-resize'], [157.5, 202.5, 's-resize'], [202.5, 247.5, 'sw-resize'],
                    [247.5, 292.5, 'w-resize'], [292.5, 337.5, 'nw-resize']
                ];
                break;
            case 'ne-resize':
                resizeMappings = [
                    [337.5, 22.5, 'ne-resize'], [22.5, 67.5, 'e-resize'],
                    [67.5, 112.5, 'se-resize'], [112.5, 157.5, 's-resize'], [157.5, 202.5, 'sw-resize'],
                    [202.5, 247.5, 'w-resize'], [247.5, 292.5, 'nw-resize'], [292.5, 337.5, 'n-resize']
                ];
                break;
            case 'e-resize':
                resizeMappings = [
                    [337.5, 22.5, 'e-resize'], [22.5, 67.5, 'se-resize'], [67.5, 112.5, 's-resize'],
                    [112.5, 157.5, 'sw-resize'], [157.5, 202.5, 'w-resize'], [202.5, 247.5, 'nw-resize'],
                    [247.5, 292.5, 'n-resize'], [292.5, 337.5, 'ne-resize']
                ];
                break;
            case 'se-resize':
                resizeMappings = [
                    [337.5, 22.5, 'se-resize'], [22.5, 67.5, 's-resize'], [67.5, 112.5, 'sw-resize'],
                    [112.5, 157.5, 'w-resize'], [157.5, 202.5, 'nw-resize'], [202.5, 247.5, 'n-resize'],
                    [247.5, 292.5, 'ne-resize'], [292.5, 337.5, 'e-resize']
                ];
                break;
            case 's-resize':
                resizeMappings = [
                    [337.5, 22.5, 's-resize'], [22.5, 67.5, 'sw-resize'], [67.5, 112.5, 'w-resize'],
                    [112.5, 157.5, 'nw-resize'], [157.5, 202.5, 'n-resize'], [202.5, 247.5, 'ne-resize'],
                    [247.5, 292.5, 'e-resize'], [292.5, 337.5, 'se-resize']
                ];
                break;
            case 'sw-resize':
                resizeMappings = [
                    [337.5, 22.5, 'sw-resize'], [22.5, 67.5, 'w-resize'], [67.5, 112.5, 'nw-resize'],
                    [112.5, 157.5, 'n-resize'], [157.5, 202.5, 'ne-resize'], [202.5, 247.5, 'e-resize'],
                    [247.5, 292.5, 'se-resize'], [292.5, 337.5, 's-resize']
                ];
                break;
            case 'w-resize':
                resizeMappings = [
                    [337.5, 22.5, 'w-resize'], [22.5, 67.5, 'nw-resize'], [67.5, 112.5, 'n-resize'],
                    [112.5, 157.5, 'ne-resize'], [157.5, 202.5, 'e-resize'], [202.5, 247.5, 'se-resize'],
                    [247.5, 292.5, 's-resize'], [292.5, 337.5, 'sw-resize']
                ];
                break;
        }
        var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
        for (var _i = 0, resizeMappings_1 = resizeMappings; _i < resizeMappings_1.length; _i++) {
            var _a = resizeMappings_1[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];
            if ((positiveDegree > startDegree && positiveDegree <= endDegree) ||
                (positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree)) {
                return resizeElement;
            }
        }
        return element;
    };
    Selection.prototype.setCursorForFreehandDrawing = function (x, y, upperCanvas, id) {
        var upperContext = upperCanvas.getContext('2d');
        var parent = this.parent;
        var textArea = document.querySelector('#' + parent.element.id + '_textArea');
        var isEntered = false;
        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
            value: { index: -1 } });
        var sPoints;
        for (var n = 0; n < parent.freehandCounter; n++) {
            if (id && id !== parent.pointColl[n].id) {
                continue;
            }
            var obj = { selPointColl: {} };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: obj } });
            sPoints = extend([], obj['selPointColl'][n].points, []);
            parent.points = extend([], parent.pointColl[n].points, []);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var ptc = parent.pointColl[n];
            parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });
            var len = sPoints.length;
            for (var l = 0; l < len; l++) {
                if (l !== 0) {
                    var isInside = false;
                    if (sPoints[l - 1] && sPoints[l]) {
                        isInside = this.isInside(x, y, sPoints[l - 1].x, sPoints[l - 1].y, sPoints[l].x, sPoints[l].y);
                    }
                    if (isInside) {
                        this.isFhdPoint = true;
                        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
                            value: { index: n } });
                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                            value: { strokeColor: null, strokeWidth: null } });
                        upperCanvas.style.cursor = parent.cursor = 'pointer';
                        isEntered = true;
                        break;
                    }
                    else if (!this.isFhdEditing || ptc.isSelected) {
                        if (this.isFhdPoint || this.isFhdEditing) {
                            upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                            if (parent.activeObj.shape && textArea.style.display === 'none') {
                                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
                            }
                        }
                        if (this.isFhdEditing) {
                            var indexObj = { freehandSelectedIndex: -1 };
                            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                            var strokeColor = parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;
                            var strokeWidth = parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth;
                            parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                                value: { strokeColor: strokeColor, strokeWidth: strokeWidth } });
                        }
                        else {
                            parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
                                value: { index: null } });
                        }
                        this.isFhdPoint = false;
                    }
                }
                else {
                    var pt = parent.points[l];
                    if (x > pt.x - ptc.strokeWidth && x < pt.x + ptc.strokeWidth && y > pt.y - ptc.strokeWidth &&
                        y < pt.y + ptc.strokeWidth) {
                        this.isFhdPoint = true;
                        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false, value: { index: n } });
                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false, value: { strokeColor: null, strokeWidth: null } });
                        upperCanvas.style.cursor = parent.cursor = 'pointer';
                        isEntered = true;
                        break;
                    }
                    else if (!this.isFhdEditing || ptc.isSelected) {
                        if (this.isFhdPoint || this.isFhdEditing) {
                            upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                            if (parent.activeObj.shape && textArea.style.display === 'none') {
                                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
                            }
                        }
                        if (this.isFhdEditing) {
                            var indexObj = { freehandSelectedIndex: -1 };
                            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                            var strokeColor = parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;
                            var strokeWidth = parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth;
                            parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                                value: { strokeColor: strokeColor, strokeWidth: strokeWidth } });
                        }
                        this.isFhdPoint = false;
                    }
                }
            }
            if (isEntered) {
                break;
            }
        }
    };
    Selection.prototype.setCursorFromObj = function (x, y, obj, upperCanvas, isCropSelection) {
        var parent = this.parent;
        for (var i = 0, len = obj.length; i < len; i++) {
            if (parent.cursor === 'move') {
                return;
            }
            var actObj = extend({}, obj[i], {}, true);
            if (actObj.activePoint.width === 0 && actObj.activePoint.height === 0) {
                obj.splice(i, 1);
                return;
            }
            this.cursorTargetId = actObj.currIndex;
            if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                this.setCursorForLineArrow(actObj, x, y, upperCanvas);
            }
            else if (actObj.shape === 'path') {
                this.setCursorForPath(actObj, x, y, upperCanvas);
            }
            else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
                this.setCursorForRotatedObject(actObj, x, y, upperCanvas);
            }
            else {
                upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, true);
            }
        }
    };
    Selection.prototype.isInside = function (x, y, z1, z2, z3, z4) {
        var x1 = Math.min(z1, z3);
        var x2 = Math.max(z1, z3);
        var y1 = Math.min(z2, z4);
        var y2 = Math.max(z2, z4);
        if ((x1 <= x && x <= x2) && (y1 <= y && y <= y2)) {
            return true;
        }
        else {
            return false;
        }
    };
    Selection.prototype.preventResizing = function (tempActiveObj) {
        var parent = this.parent;
        if (parent.activeObj.preventShapeDragOut && this.isShapeDragOut()) {
            var actPoint = parent.activeObj.activePoint;
            actPoint.startX = tempActiveObj.activePoint.startX;
            actPoint.startY = tempActiveObj.activePoint.startY;
            actPoint.endX = tempActiveObj.activePoint.endX;
            actPoint.endY = tempActiveObj.activePoint.endY;
            actPoint.width = tempActiveObj.activePoint.width;
            actPoint.height = tempActiveObj.activePoint.height;
            parent.activeObj.rotatedAngle = tempActiveObj.rotatedAngle;
            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false,
                value: { actPoint: actPoint, obj: parent.activeObj, isMouseMove: null, x: null, y: null } });
        }
    };
    Selection.prototype.updateActivePoint = function (x, y, isCropSelection) {
        var parent = this.parent;
        var obj = { width: 0, height: 0 };
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY;
        var _b = parent.activeObj.activePoint, width = _b.width, height = _b.height;
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: width, height: height, obj: obj, isImgShape: null } });
        var previousShapeSettings = this.updatePrevShapeSettings();
        var shapeResizingArgs = { cancel: false, action: 'resize', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
        var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
        this.shapeResizingArgs = shapeResizingArgs;
        this.shapeMovingArgs = shapeMovingArgs;
        if (parent.activeObj.shape === 'text' && this.dragElement !== '') {
            parent.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: parent.activeObj, isTextArea: null } });
        }
        if (this.currentDrawingShape !== '' && (this.dragElement === '' || this.dragElement === 'move') && parent.isShapeDrawing) {
            var shapeColl = ['line', 'arrow', 'path'];
            if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
                this.dragElement = 'e-resize';
            }
            else {
                if (x > startX && y > startY) {
                    this.dragElement = 'se-resize';
                }
                else if (x < startX && y > startY) {
                    this.dragElement = 'sw-resize';
                }
                else if (x > startX && y < startY) {
                    this.dragElement = 'ne-resize';
                }
                else if (x < startX && y < startY) {
                    this.dragElement = 'nw-resize';
                }
            }
        }
        if (parent.activeObj.shape === 'arrow') {
            if (Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2) > 0) {
                parent.activeObj.rotatedAngle = -Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2);
            }
            else {
                parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2));
            }
        }
        var degree;
        var isHorizontalflip = false;
        var isVerticalflip = false;
        if (isCropSelection && parent.transform.straighten !== 0 && this.isMouseOutsideImg(x, y)) {
            return;
        }
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        var splitWords;
        var cropResize;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            cropResize = true;
        }
        switch (this.dragElement.toLowerCase()) {
            case 'nw-resize':
                this.updateNWPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'n-resize':
                this.updateNPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'ne-resize':
                this.updateNEPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'w-resize':
                this.updateWPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'e-resize':
                this.updateEPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'sw-resize':
                this.updateSWPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 's-resize':
                this.updateSPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'se-resize':
                this.updateSEPoints(x, y);
                this.preventResizing(tempActiveObj);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'grabbing':
                if (Math.atan2(x - (startX + (width / 2)), y - (startY + (height / 2))) > 0) {
                    parent.activeObj.rotatedAngle = -Math.atan2(x - (startX + (width / 2)), y - (startY + (height / 2)));
                }
                else {
                    parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - (startX + (width / 2)), y - (startY + (height / 2))));
                }
                if (parent.activeObj.shapeDegree === 0) {
                    degree = parent.transform.degree;
                }
                else {
                    degree = parent.transform.degree - parent.activeObj.shapeDegree;
                }
                if (degree < 0) {
                    degree = 360 + degree;
                }
                for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
                    if (parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                        isHorizontalflip = true;
                    }
                    else if (parent.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                        isVerticalflip = true;
                    }
                }
                parent.activeObj.rotatedAngle -= (degree * (Math.PI / 180));
                if (degree === 0 || degree === 360) {
                    if (isVerticalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                else if (degree === 90 || degree === -270) {
                    if (isHorizontalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                else if (degree === 180 || degree === -180) {
                    if (isVerticalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                else if (degree === 270 || degree === -90) {
                    if (isHorizontalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                this.preventResizing(tempActiveObj);
                break;
            case 'pathdrag':
                if (!isNullOrUndefined(this.pathAdjustedIndex)) {
                    parent.activeObj.pointColl[this.pathAdjustedIndex].x = x;
                    parent.activeObj.pointColl[this.pathAdjustedIndex].y = y;
                }
                break;
            default:
                if (!isCropSelection && !parent.currObjType.isCustomCrop) {
                    var activePoint = parent.activeObj.activePoint;
                    if (this.dragPoint.startX) {
                        var width_1 = (this.dragPoint.endX - this.previousPoint.x);
                        var height_1 = (this.dragPoint.endY - this.previousPoint.y);
                        activePoint.startX += width_1;
                        activePoint.endX += width_1;
                        activePoint.startY += height_1;
                        activePoint.endY += height_1;
                        startX = activePoint.startX;
                        startY = activePoint.startY;
                        if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' &&
                            parent.activeObj.rotationCirclePointColl) {
                            parent.activeObj.rotationCirclePointColl.x += width_1;
                            parent.activeObj.rotationCirclePointColl.y += height_1;
                            parent.activeObj.rotationCirclePoint.x += width_1;
                            parent.activeObj.rotationCirclePoint.y += height_1;
                        }
                        if (parent.activeObj.shape === 'path') {
                            for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
                                parent.activeObj.pointColl[i].x += width_1;
                                parent.activeObj.pointColl[i].y += height_1;
                            }
                        }
                        if ((!this.isPreventDragging && this.isShapeDragOut()) && (parent.activeObj.preventShapeDragOut || parent.activeObj.shape === 'redact' || cropResize)) {
                            activePoint.startX -= width_1;
                            activePoint.endX -= width_1;
                            activePoint.startY -= height_1;
                            activePoint.endY -= height_1;
                            if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' &&
                                parent.activeObj.rotationCirclePointColl) {
                                parent.activeObj.rotationCirclePointColl.x -= width_1;
                                parent.activeObj.rotationCirclePointColl.y -= height_1;
                                parent.activeObj.rotationCirclePoint.x -= width_1;
                                parent.activeObj.rotationCirclePoint.y -= height_1;
                            }
                            else if (parent.activeObj.shape === 'path') {
                                for (var l = 0, len = parent.activeObj.pointColl.length; l < len; l++) {
                                    parent.activeObj.pointColl[l].x -= width_1;
                                    parent.activeObj.pointColl[l].y -= height_1;
                                }
                            }
                            if (parent.activeObj.rotatedAngle === 0) {
                                var tempEndX = parent.activeObj.activePoint.endX;
                                var tempEndY = parent.activeObj.activePoint.endY;
                                if (parent.activeObj.shape === 'path') {
                                    parent.activeObj.activePoint = parent.getSquarePointForPath(parent.activeObj);
                                }
                                this.setDragWidth(width_1);
                                this.setDragHeight(height_1);
                                var currObj = parent.activeObj;
                                var xDiff = currObj.activePoint.endX - tempEndX;
                                var yDiff = currObj.activePoint.endY - tempEndY;
                                if (currObj.shape === 'path') {
                                    for (var l = 0, len = currObj.pointColl.length; l < len; l++) {
                                        currObj.pointColl[l].x += xDiff;
                                        currObj.pointColl[l].y += yDiff;
                                    }
                                }
                            }
                            else {
                                parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });
                            }
                        }
                    }
                    else {
                        activePoint.startX = x < this.mouseDownPoint.x ? x : this.mouseDownPoint.x;
                        activePoint.startY = y < this.mouseDownPoint.y ? y : this.mouseDownPoint.y;
                        x = x < this.mouseDownPoint.x ? this.mouseDownPoint.x : x;
                        y = y < this.mouseDownPoint.y ? this.mouseDownPoint.y : y;
                        activePoint.endX = x;
                        activePoint.endY = y;
                    }
                    this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'move');
                }
                break;
        }
    };
    Selection.prototype.isShapeDragOut = function () {
        var parent = this.parent;
        var isShapeDragOut = false;
        var allowPreventing = false;
        var shape = parent.activeObj.shape;
        if (parent.activeObj.preventShapeDragOut) {
            allowPreventing = true;
        }
        else if (parent.activeObj.rotatedAngle === 0 &&
            (shape !== 'line' && shape !== 'arrow' && shape !== 'path')) {
            allowPreventing = true;
        }
        if (allowPreventing) {
            var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
            if (shape === 'path') {
                var path = parent.getSquarePointForPath(parent.activeObj);
                startX = path.startX;
                startY = path.startY;
                endX = path.endX;
                endY = path.endY;
            }
            if (parent.activeObj.rotatedAngle === 0 || shape === 'arrow') {
                isShapeDragOut = this.isObjOutsideImg(startX, startY, endX, endY, shape);
            }
            else {
                var obj = { isIntersect: null, arr: null };
                parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
                parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: obj } });
                if (obj['arr'][0] || obj['arr'][1] || obj['arr'][2] || obj['arr'][3]) {
                    isShapeDragOut = true;
                }
                else {
                    isShapeDragOut = this.isObjOutsideImg(startX, startY, endX, endY, shape);
                }
            }
        }
        return isShapeDragOut;
    };
    Selection.prototype.isObjOutsideImg = function (startX, startY, endX, endY, shape) {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (startX < destLeft || startY < destTop || endX > destLeft + destWidth ||
            endY > destTop + destHeight || ((shape === 'line' || shape === 'arrow') &&
            (startX > destLeft + destWidth || startY > destTop + destHeight ||
                endX < destLeft || endY < destTop))) {
            return true;
        }
        return false;
    };
    Selection.prototype.triggerShapeChange = function (shapeResizingArgs, shapeMovingArgs, type) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        var currentShapeSettings = this.updatePrevShapeSettings();
        if (!isNullOrUndefined(this.shapeResizingArgs) && !isNullOrUndefined(this.shapeMovingArgs)) {
            shapeResizingArgs.currentShapeSettings = this.shapeResizingArgs.currentShapeSettings = currentShapeSettings;
            shapeMovingArgs.currentShapeSettings = this.shapeMovingArgs.currentShapeSettings = currentShapeSettings;
        }
        else {
            shapeResizingArgs.currentShapeSettings = currentShapeSettings;
            shapeMovingArgs.currentShapeSettings = currentShapeSettings;
        }
        if (type === 'resize') {
            this.isCropSelection = false;
            var splitWords = void 0;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords !== undefined && splitWords[0] === 'crop') {
                this.isCropSelection = true;
            }
            if (!this.isCropSelection) {
                if (this.currentDrawingShape !== '' && parent.upperCanvas.style.cursor === 'crosshair') {
                    shapeResizingArgs.action = 'drawing';
                }
                if (!parent.currObjType.isRedact || parent.activeObj.shape !== 'redact') {
                    parent.trigger('shapeChanging', shapeResizingArgs);
                }
                parent.editCompleteArgs = shapeResizingArgs;
                this.isPreventShaping = shapeResizingArgs.cancel;
                parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false, value: { shapeSettings: shapeResizingArgs.currentShapeSettings, allowShapeOverflow: shapeResizingArgs.allowShapeOverflow } });
            }
            else {
                if (this.isMouseDown) {
                    shapeResizingArgs.action = 'resize-start';
                }
                else if (this.isMouseUp) {
                    shapeResizingArgs.action = 'resize-end';
                }
                var selectionResizingArgs = { action: shapeResizingArgs.action,
                    previousSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                        startX: shapeResizingArgs.previousShapeSettings.startX,
                        startY: shapeResizingArgs.previousShapeSettings.startY,
                        width: shapeResizingArgs.previousShapeSettings.width,
                        height: shapeResizingArgs.previousShapeSettings.height },
                    currentSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                        startX: shapeResizingArgs.currentShapeSettings.startX,
                        startY: shapeResizingArgs.currentShapeSettings.startY,
                        width: shapeResizingArgs.currentShapeSettings.width,
                        height: shapeResizingArgs.currentShapeSettings.height } };
                this.selectionResizingArgs = selectionResizingArgs;
                parent.trigger('selectionChanging', selectionResizingArgs);
                parent.editCompleteArgs = selectionResizingArgs;
                parent.notify('shape', { prop: 'updSelChangeEventArgs', onPropertyChange: false,
                    value: { selectionSettings: selectionResizingArgs.currentSelectionSettings } });
            }
        }
        else if (type === 'mouse-down' || type === 'mouse-up') {
            if (parent.activeObj.shape !== 'redact') {
                parent.trigger('shapeChanging', shapeResizingArgs);
            }
            parent.editCompleteArgs = shapeResizingArgs;
            this.isPreventShaping = shapeResizingArgs.cancel;
            parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                value: { shapeSettings: shapeResizingArgs.currentShapeSettings, allowShapeOverflow: shapeResizingArgs.allowShapeOverflow } });
        }
        else {
            if (parent.activeObj.shape !== 'redact') {
                parent.trigger('shapeChanging', shapeMovingArgs);
            }
            parent.editCompleteArgs = shapeMovingArgs;
            this.isPreventShaping = shapeMovingArgs.cancel;
            parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                value: { shapeSettings: shapeMovingArgs.currentShapeSettings, allowShapeOverflow: shapeMovingArgs.allowShapeOverflow } });
        }
        parent.eventType = type;
    };
    Selection.prototype.setDragWidth = function (width) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var _a = parent.img, destLeft = _a.destLeft, destWidth = _a.destWidth;
        var tempWidth = width;
        var shape = parent.activeObj.shape;
        var preventDragOut = false;
        if (parent.activeObj.preventShapeDragOut && (shape === 'line' || shape === 'arrow')) {
            preventDragOut = true;
        }
        if (tempWidth >= 0) {
            for (var i = 0; i < tempWidth; i++) {
                width = tempWidth - i;
                actPoint.startX += width;
                actPoint.endX += width;
                if ((actPoint.startX >= destLeft &&
                    actPoint.endX <= destLeft + destWidth && !preventDragOut) ||
                    (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth &&
                        actPoint.endX >= destLeft && actPoint.startX <= destLeft + destWidth && preventDragOut)) {
                    break;
                }
                else {
                    actPoint.startX -= width;
                    actPoint.endX -= width;
                }
            }
        }
        else {
            for (var i = 1; i < Math.abs(tempWidth); i++) {
                width = tempWidth + i;
                actPoint.startX += width;
                actPoint.endX += width;
                if ((actPoint.startX >= destLeft &&
                    actPoint.endX <= destLeft + destWidth && !preventDragOut) ||
                    (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth &&
                        actPoint.endX >= destLeft && actPoint.startX <= destLeft + destWidth && preventDragOut)) {
                    break;
                }
                else {
                    actPoint.startX -= width;
                    actPoint.endX -= width;
                }
            }
        }
    };
    Selection.prototype.setDragHeight = function (height) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var _a = parent.img, destTop = _a.destTop, destHeight = _a.destHeight;
        var tempHeight = height;
        var shape = parent.activeObj.shape;
        var preventDragOut = false;
        if (parent.activeObj.preventShapeDragOut && (shape === 'line' || shape === 'arrow')) {
            preventDragOut = true;
        }
        if (tempHeight >= 0) {
            for (var i = 1; i < tempHeight; i++) {
                height = tempHeight - i;
                actPoint.startY += height;
                actPoint.endY += height;
                if ((actPoint.startY >= destTop &&
                    actPoint.endY <= destTop + destHeight && !preventDragOut) ||
                    (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight &&
                        actPoint.endY >= destTop && actPoint.startY <= destTop + destHeight && preventDragOut)) {
                    break;
                }
                else {
                    actPoint.startY -= height;
                    actPoint.endY -= height;
                }
            }
        }
        else {
            for (var i = 0; i < Math.abs(tempHeight); i++) {
                height = tempHeight + i;
                actPoint.startY += height;
                actPoint.endY += height;
                if ((actPoint.startY >= destTop &&
                    actPoint.endY <= destTop + destHeight && !preventDragOut) ||
                    (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight &&
                        actPoint.endY >= destTop && actPoint.startY <= destTop + destHeight && preventDragOut)) {
                    break;
                }
                else {
                    actPoint.startY -= height;
                    actPoint.endY -= height;
                }
            }
        }
    };
    Selection.prototype.limitDrag = function (isStart) {
        var isLimiting = false;
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var actPoint = parent.activeObj.activePoint;
        var startX = isStart ? actPoint.startX : actPoint.endX;
        var startY = isStart ? actPoint.startY : actPoint.endY;
        var endX = isStart ? actPoint.endX : actPoint.startX;
        var endY = isStart ? actPoint.endY : actPoint.startY;
        var wrapperWidth = parent.upperCanvas.width;
        var wrapperHeight = parent.upperCanvas.height;
        if (Browser.isDevice) {
            if (startX < 0 && destLeft < 0) {
                startX = 0;
            }
            if (startY < 0 && destTop < 0) {
                startY = 0;
            }
            if (endX > wrapperWidth && destLeft + destWidth > wrapperWidth) {
                endX = wrapperWidth;
            }
            if (endY > wrapperHeight && destTop + destHeight > wrapperHeight) {
                endY = wrapperHeight;
            }
        }
        else {
            if (startX < destLeft) {
                startX = destLeft;
            }
            if (startY < destTop) {
                startY = destTop;
            }
            if (endX > destLeft + destWidth) {
                endX = destLeft + destWidth;
            }
            if (endY > destTop + destHeight) {
                endY = destTop + destHeight;
            }
        }
        if (parent.transform.straighten !== 0) {
            var obj = { isIntersect: null, arr: null };
            parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
            parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: obj } });
            if (obj['arr'][0] || obj['arr'][1] || obj['arr'][2] || obj['arr'][3]) {
                isLimiting = true;
            }
        }
        if (isStart) {
            actPoint.startX = startX;
            actPoint.startY = startY;
            actPoint.endX = endX;
            actPoint.endY = endY;
        }
        else {
            actPoint.startX = endX;
            actPoint.startY = endY;
            actPoint.endX = startX;
            actPoint.endY = startY;
        }
        return isLimiting;
    };
    Selection.prototype.isMouseOutsideImg = function (x, y) {
        var obj = { bool: false };
        this.parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
        this.parent.notify('draw', { prop: 'isPointsInsideImg', value: { obj: obj, x: x, y: y } });
        return obj['bool'];
    };
    Selection.prototype.preventDraggingInvertly = function () {
        var isLimiting = false;
        var parent = this.parent;
        if (parent.activeObj.shape === 'image') {
            return isLimiting;
        }
        var splitWords;
        var cropResize;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            cropResize = true;
        }
        if ((!this.isPreventDragging && parent.activeObj.rotatedAngle === 0) && (parent.activeObj.preventShapeDragOut || parent.activeObj.shape === 'redact' || cropResize)) {
            isLimiting = this.limitDrag(true);
            var shapeColl = ['line', 'arrow', 'path'];
            if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
                isLimiting = this.limitDrag(false);
            }
        }
        return isLimiting;
    };
    Selection.prototype.preventTextDraggingInvertly = function () {
        var parent = this.parent;
        var isLimiting = false;
        var actPoint = parent.activeObj.activePoint;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (!this.isPreventDragging) {
            if (actPoint.startX < destLeft ||
                actPoint.startY < destTop ||
                actPoint.endX > destLeft + destWidth ||
                actPoint.endY > destTop + destHeight) {
                isLimiting = true;
            }
        }
        return isLimiting;
    };
    Selection.prototype.preventInverseResize = function (tempActiveObj) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        if (actPoint.width < 0) {
            actPoint.width = 0;
            actPoint.startX = tempActiveObj.activePoint.startX;
            actPoint.endX = tempActiveObj.activePoint.endX;
        }
        if (actPoint.height < 0) {
            actPoint.height = 0;
            actPoint.startY = tempActiveObj.activePoint.startY;
            actPoint.endY = tempActiveObj.activePoint.endY;
        }
    };
    Selection.prototype.getScaleRatio = function (scale) {
        var parent = this.parent;
        var point = { x: scale, y: scale };
        if (parent.activeObj.shape && parent.activeObj.shape !== 'crop-custom' &&
            parent.activeObj.shape !== 'crop-circle' && parent.activeObj.shape !== 'crop-square') {
            var ratio = parent.activeObj.shape === 'image' || parent.activeObj.shape === 'text' ?
                this.findImageRatio(parent.activeObj.activePoint.width, parent.activeObj.activePoint.height).split('-') :
                parent.activeObj.shape.split('-');
            if (ratio.length > 1 || parent.activeObj.shape === 'image' || parent.activeObj.shape === 'text') {
                ratio = parent.activeObj.shape === 'image' || parent.activeObj.shape === 'text' ? ratio[0].split(':') : ratio[1].split(':');
                var newScale = scale / (parseInt(ratio[1], 10));
                point.x = newScale * (parseInt(ratio[0], 10));
                point.y = newScale * (parseInt(ratio[1], 10));
            }
        }
        return point;
    };
    Selection.prototype.findImageRatio = function (width, height, obj) {
        // eslint-disable-next-line @typescript-eslint/tslint/config
        var gcd = function (a, b) {
            if (b === 0) {
                return a;
            }
            return gcd(b, a % b);
        };
        var divisor = gcd(width, height);
        var ratio = width / divisor + ":" + height / divisor;
        if (obj) {
            obj['ratio'] = ratio;
        }
        return ratio;
    };
    Selection.prototype.revertResizing = function (tempActiveObj) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        if (this.preventDraggingInvertly()) {
            actPoint.startX = tempActiveObj.activePoint.startX;
            actPoint.startY = tempActiveObj.activePoint.startY;
            actPoint.endX = tempActiveObj.activePoint.endX;
            actPoint.endY = tempActiveObj.activePoint.endY;
        }
    };
    Selection.prototype.performSEResize = function (x, y, tempActiveObj, actPoint) {
        var parent = this.parent;
        this.resizeImg(x, y, 'se-resize', tempActiveObj);
        if (actPoint.endX < actPoint.startX) {
            var temp = actPoint.endX;
            actPoint.endX = actPoint.startX;
            actPoint.startX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
        }
        if (actPoint.endY < actPoint.startY) {
            var temp = actPoint.endY;
            actPoint.endY = actPoint.startY;
            actPoint.startY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
        }
        this.revertCustomSelection(actPoint, tempActiveObj, 'se-resize');
        this.revertResizing(tempActiveObj);
    };
    Selection.prototype.performNWResize = function (x, y, tempActiveObj, actPoint) {
        var parent = this.parent;
        this.resizeImg(x, y, 'nw-resize', tempActiveObj);
        if (actPoint.startX > actPoint.endX) {
            var temp = actPoint.startX;
            actPoint.startX = actPoint.endX;
            actPoint.endX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
        }
        if (actPoint.startY > actPoint.endY) {
            var temp = actPoint.startY;
            actPoint.startY = actPoint.endY;
            actPoint.endY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
        }
        this.revertCustomSelection(actPoint, tempActiveObj, 'nw-resize');
        this.revertResizing(tempActiveObj);
    };
    Selection.prototype.isCustomSelection = function () {
        if (this.parent.activeObj.shape) {
            var shapeColl = ['custom', 'circle', 'square', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '5:7', '7:5', '9:16', '16:9'];
            return this.parent.activeObj.shape.indexOf('crop-') > -1 && shapeColl.indexOf(this.parent.activeObj.shape.split('-')[1]) === -1;
        }
        return false;
    };
    Selection.prototype.revertCustomSelection = function (actPoint, tempActiveObj, type) {
        var parent = this.parent;
        if (this.isCustomSelection()) {
            var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ?
                destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop + destHeight < parent.lowerCanvas.height ?
                destTop + destHeight : parent.lowerCanvas.height;
            var left = destLeft > 0 ? destLeft : 0;
            var top_1 = destTop > 0 ? destTop : 0;
            var endY1 = destTop > 0 ? destTop : 0;
            var endX1 = destLeft > 0 ? destLeft : 0;
            if ((type === 'se-resize' && (actPoint.endX > endX || actPoint.endY > endY)) ||
                (type === 'nw-resize' && (actPoint.startX < left || actPoint.startY < top_1)) ||
                (type === 'ne-resize' && (actPoint.endX > endX || actPoint.startY < endY1)) ||
                (type === 'sw-resize' && (actPoint.startX < endX1 || actPoint.endY > endY))) {
                this.revertPoints(actPoint, tempActiveObj);
            }
        }
    };
    Selection.prototype.revertPoints = function (actPoint, tempActiveObj) {
        actPoint.startX = tempActiveObj.activePoint.startX;
        actPoint.startY = tempActiveObj.activePoint.startY;
        actPoint.endX = tempActiveObj.activePoint.endX;
        actPoint.endY = tempActiveObj.activePoint.endY;
        actPoint.width = tempActiveObj.activePoint.width;
        actPoint.height = tempActiveObj.activePoint.height;
    };
    Selection.prototype.updateNWPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            this.resizeImg(x, y, 'nw-resize', tempActiveObj);
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            var splitWords = void 0;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')
                || this.isCustomSelection()) {
                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {
                    this.resizeImg(x, y, 'nw-resize', tempActiveObj);
                }
                else {
                    this.adjustNWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
                }
                if (actPoint.startX > actPoint.endX) {
                    var temp = actPoint.startX;
                    actPoint.startX = actPoint.endX;
                    actPoint.endX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
                }
                if (actPoint.startY > actPoint.endY) {
                    var temp = actPoint.startY;
                    actPoint.startY = actPoint.endY;
                    actPoint.endY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
                }
                this.revertCustomSelection(actPoint, tempActiveObj, 'nw-resize');
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop;
                if (actPoint.startX < x && actPoint.startY < y) {
                    width = x - actPoint.startX;
                    height = y - actPoint.startY;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.startX += newScale.x;
                    actPoint.startY += newScale.y;
                    var left = destLeft > 0 ? destLeft : 0;
                    var top_2 = destTop > 0 ? destTop : 0;
                    if (actPoint.startX < left || actPoint.startY < top_2) {
                        actPoint.startX -= newScale.x;
                        actPoint.startY -= newScale.y;
                    }
                }
                else {
                    width = actPoint.startX - x;
                    height = y - actPoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.startX -= newScale.x;
                    actPoint.startY -= newScale.y;
                    var left = destLeft > 0 ? destLeft : 0;
                    var top_3 = destTop > 0 ? destTop : 0;
                    if (actPoint.startX < left || actPoint.startY < top_3) {
                        actPoint.startX += newScale.x;
                        actPoint.startY += newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            this.preventInverseResize(tempActiveObj);
        }
    };
    Selection.prototype.updateNPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    actPoint.startY = y;
                    actPoint.height = actPoint.endY - actPoint.startY;
                }
                if (actPoint.startY > actPoint.endY) {
                    var temp = actPoint.startY;
                    actPoint.startY = actPoint.endY;
                    actPoint.endY = temp;
                    this.dragElement = this.resizedElement = 's-resize';
                }
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;
                if (this.isCustomSelection()) {
                    this.performNWResize(x, y, tempActiveObj, actPoint);
                }
                else if (actPoint.endX > x && actPoint.startY < y) {
                    width = actPoint.endX - x;
                    height = y - actPoint.startY;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX -= newScale.x;
                    actPoint.startY += newScale.y;
                    if (actPoint.endX > (destLeft + destWidth) ||
                        actPoint.startY < destTop) {
                        actPoint.endX += newScale.x;
                        actPoint.startY -= newScale.y;
                    }
                }
                else {
                    width = x - actPoint.endX;
                    height = actPoint.startY - y;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX += newScale.x;
                    actPoint.startY -= newScale.y;
                    if (actPoint.endX > (destLeft + destWidth) ||
                        actPoint.startY < destTop) {
                        actPoint.endX -= newScale.x;
                        actPoint.startY += newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
        }
    };
    Selection.prototype.updateNEPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            this.resizeImg(x, y, 'ne-resize', tempActiveObj);
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            var splitWords = void 0;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')
                || this.isCustomSelection()) {
                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {
                    this.resizeImg(x, y, 'ne-resize', tempActiveObj);
                }
                else {
                    this.adjustNEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
                }
                if (actPoint.endX < actPoint.startX) {
                    var temp = actPoint.endX;
                    actPoint.endX = actPoint.startX;
                    actPoint.startX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';
                }
                if (actPoint.startY > actPoint.endY) {
                    var temp = actPoint.startY;
                    actPoint.startY = actPoint.endY;
                    actPoint.endY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';
                }
                this.revertCustomSelection(actPoint, tempActiveObj, 'ne-resize');
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;
                if (actPoint.endX > x && actPoint.startY < y) {
                    width = actPoint.endX - x;
                    height = y - actPoint.startY;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX -= newScale.x;
                    actPoint.startY += newScale.y;
                    var endX = destLeft + destWidth < parent.lowerCanvas.width ?
                        destLeft + destWidth : parent.lowerCanvas.width;
                    var endY = destTop > 0 ? destTop : 0;
                    if (actPoint.endX > endX || actPoint.startY < endY) {
                        actPoint.endX += newScale.x;
                        actPoint.startY -= newScale.y;
                    }
                }
                else {
                    width = x - actPoint.endX;
                    height = actPoint.startY - y;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX += newScale.x;
                    actPoint.startY -= newScale.y;
                    var endX = destLeft + destWidth < parent.lowerCanvas.width ?
                        destLeft + destWidth : parent.lowerCanvas.width;
                    var endY = destTop > 0 ? destTop : 0;
                    if (actPoint.endX > endX || actPoint.startY < endY) {
                        actPoint.endX -= newScale.x;
                        actPoint.startY += newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            this.preventInverseResize(tempActiveObj);
        }
    };
    Selection.prototype.updateWPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    actPoint.startX = x;
                    actPoint.width = actPoint.endX - actPoint.startX;
                }
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path') {
                    actPoint.startY = y;
                    actPoint.height = actPoint.endY - actPoint.startY;
                    if (this.adjustActObjForLineArrow()) {
                        this.dragElement = 'e-resize';
                        if (parent.activeObj.triangleDirection === 'right') {
                            parent.activeObj.triangleDirection = 'left';
                        }
                        else if (parent.activeObj.triangleDirection === 'left') {
                            parent.activeObj.triangleDirection = 'right';
                        }
                    }
                }
                else if (actPoint.startX > actPoint.endX) {
                    var temp = actPoint.startX;
                    actPoint.startX = actPoint.endX;
                    actPoint.endX = temp;
                    this.dragElement = this.resizedElement = 'e-resize';
                }
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;
                if (this.isCustomSelection()) {
                    this.performNWResize(x, y, tempActiveObj, actPoint);
                }
                else if (actPoint.startX < x && actPoint.endY > y) {
                    width = x - actPoint.startX;
                    height = actPoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.startX += newScale.x;
                    actPoint.endY -= newScale.y;
                    if (actPoint.startX < destLeft || actPoint.endY >
                        (destTop + destHeight)) {
                        actPoint.startX -= newScale.x;
                        actPoint.endY += newScale.y;
                    }
                }
                else {
                    width = actPoint.startX - x;
                    height = y - actPoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.startX -= newScale.x;
                    actPoint.endY += newScale.y;
                    if (actPoint.startX < destLeft || actPoint.endY >
                        (destTop + destHeight)) {
                        actPoint.startX += newScale.x;
                        actPoint.endY -= newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
        }
    };
    Selection.prototype.updateEPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    actPoint.endX = x;
                    actPoint.width = actPoint.endX - actPoint.startX;
                }
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path') {
                    actPoint.endY = y;
                    actPoint.height = actPoint.endY - actPoint.startY;
                    if (this.adjustActObjForLineArrow()) {
                        this.dragElement = 'w-resize';
                        if (parent.activeObj.triangleDirection === 'right') {
                            parent.activeObj.triangleDirection = 'left';
                        }
                        else if (parent.activeObj.triangleDirection === 'left') {
                            parent.activeObj.triangleDirection = 'right';
                        }
                    }
                }
                else if (actPoint.endX < actPoint.startX) {
                    var temp = actPoint.endX;
                    actPoint.endX = actPoint.startX;
                    actPoint.startX = temp;
                    this.dragElement = this.resizedElement = 'w-resize';
                }
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
                if (this.isCustomSelection()) {
                    this.performSEResize(x, y, tempActiveObj, actPoint);
                }
                else if (actPoint.endX > x && actPoint.endY > y) {
                    width = actPoint.endX - x;
                    height = actPoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX -= newScale.x;
                    actPoint.endY -= newScale.y;
                    if (actPoint.endX > (destLeft + destWidth) ||
                        actPoint.endY > (destTop + destHeight)) {
                        actPoint.endX += newScale.x;
                        actPoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - actPoint.endX;
                    height = y - actPoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX += newScale.x;
                    actPoint.endY += newScale.y;
                    if (actPoint.endX > (destLeft + destWidth) ||
                        actPoint.endY > (destTop + destHeight)) {
                        actPoint.endX -= newScale.x;
                        actPoint.endY -= newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
        }
    };
    Selection.prototype.updateSWPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            this.resizeImg(x, y, 'sw-resize', tempActiveObj);
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            var splitWords = void 0;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')
                || this.isCustomSelection()) {
                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {
                    this.resizeImg(x, y, 'sw-resize', tempActiveObj);
                }
                else {
                    this.adjustSWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
                }
                if (actPoint.startX > actPoint.endX) {
                    var temp = actPoint.startX;
                    actPoint.startX = actPoint.endX;
                    actPoint.endX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';
                }
                if (actPoint.endY < actPoint.startY) {
                    var temp = actPoint.endY;
                    actPoint.endY = actPoint.startY;
                    actPoint.startY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';
                }
                this.revertCustomSelection(actPoint, tempActiveObj, 'sw-resize');
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;
                if (actPoint.startX < x && actPoint.endY > y) {
                    width = x - actPoint.startX;
                    height = actPoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.startX += newScale.x;
                    actPoint.endY -= newScale.y;
                    var endX = destLeft > 0 ? destLeft : 0;
                    var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop +
                        destHeight : parent.lowerCanvas.height;
                    if (actPoint.startX < endX || actPoint.endY > endY) {
                        actPoint.startX -= newScale.x;
                        actPoint.endY += newScale.y;
                    }
                }
                else {
                    width = actPoint.startX - x;
                    height = y - actPoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.startX -= newScale.x;
                    actPoint.endY += newScale.y;
                    var endX = destLeft > 0 ? destLeft : 0;
                    var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop +
                        destHeight : parent.lowerCanvas.height;
                    if (actPoint.startX < endX || actPoint.endY > endY) {
                        actPoint.startX += newScale.x;
                        actPoint.endY -= newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            this.preventInverseResize(tempActiveObj);
        }
    };
    Selection.prototype.updateSPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape !== 'text') {
            var splitWords = void 0;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    actPoint.endY = y;
                    actPoint.height = actPoint.endY - actPoint.startY;
                }
                if (actPoint.endY < actPoint.startY) {
                    var temp = actPoint.endY;
                    actPoint.endY = actPoint.startY;
                    actPoint.startY = temp;
                    this.dragElement = this.resizedElement = 'n-resize';
                }
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
                if (this.isCustomSelection()) {
                    this.performSEResize(x, y, tempActiveObj, actPoint);
                }
                else if (actPoint.endX > x && actPoint.endY > y) {
                    width = actPoint.endX - x;
                    height = actPoint.endY - y;
                    scale = Math.min(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX -= newScale.x;
                    actPoint.endY -= newScale.y;
                    if (actPoint.endX > (destLeft + destWidth) ||
                        actPoint.endY > (destTop + destHeight)) {
                        actPoint.endX += newScale.x;
                        actPoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - actPoint.endX;
                    height = y - actPoint.endY;
                    scale = Math.max(width, height);
                    var newScale = this.getScaleRatio(scale);
                    actPoint.endX += newScale.x;
                    actPoint.endY += newScale.x;
                    if (actPoint.endX > (destLeft + destWidth) ||
                        actPoint.endY > (destTop + destHeight)) {
                        actPoint.endX -= newScale.x;
                        actPoint.endY -= newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
        }
    };
    Selection.prototype.updateSEPoints = function (x, y) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            this.resizeImg(x, y, 'se-resize', tempActiveObj);
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            var splitWords = void 0;
            var newScale = void 0;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')
                || this.isCustomSelection()) {
                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {
                    this.resizeImg(x, y, 'se-resize', tempActiveObj);
                }
                else {
                    this.adjustSEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
                }
                if (actPoint.endX < actPoint.startX) {
                    var temp = actPoint.endX;
                    actPoint.endX = actPoint.startX;
                    actPoint.startX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
                }
                if (actPoint.endY < actPoint.startY) {
                    var temp = actPoint.endY;
                    actPoint.endY = actPoint.startY;
                    actPoint.startY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
                }
                this.revertCustomSelection(actPoint, tempActiveObj, 'se-resize');
                this.revertResizing(tempActiveObj);
            }
            else {
                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
                if (actPoint.endX > x && actPoint.endY > y) {
                    width = actPoint.endX - x;
                    height = actPoint.endY - y;
                    scale = Math.min(width, height);
                    newScale = this.getScaleRatio(scale);
                    actPoint.endX -= newScale.x;
                    actPoint.endY -= newScale.y;
                    var endX = destLeft + destWidth < parent.lowerCanvas.width ?
                        destLeft + destWidth : parent.lowerCanvas.width;
                    var endY = destTop + destHeight < parent.lowerCanvas.height ?
                        destTop + destHeight : parent.lowerCanvas.height;
                    if (actPoint.endX > endX || actPoint.endY > endY) {
                        actPoint.endX += newScale.x;
                        actPoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - actPoint.endX;
                    height = y - actPoint.endY;
                    scale = Math.max(width, height);
                    newScale = this.getScaleRatio(scale);
                    actPoint.endX += newScale.x;
                    actPoint.endY += newScale.y;
                    var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft +
                        destWidth : parent.lowerCanvas.width;
                    var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop +
                        destHeight : parent.lowerCanvas.height;
                    if (actPoint.endX > endX || actPoint.endY > endY) {
                        actPoint.endX -= newScale.x;
                        actPoint.endY -= newScale.y;
                    }
                }
                actPoint.width = actPoint.endX - actPoint.startX;
                actPoint.height = actPoint.endY - actPoint.startY;
                this.revertResizing(tempActiveObj);
            }
            this.preventInverseResize(tempActiveObj);
        }
    };
    Selection.prototype.resizeImg = function (x, y, elem, tempActiveObj) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var width;
        var height;
        var scale;
        var newScale;
        if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
            if (this.currentDrawingShape === 'text') {
                this.setCursor(x, y);
                if (parent.activeObj.textSettings.fontSize === 0) {
                    parent.activeObj.textSettings.fontSize = 11;
                    parent.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                        value: { obj: parent.activeObj, isTextArea: null } });
                    parent.activeObj.textSettings.text = parent.activeObj.keyHistory = 'Enter Text';
                    parent.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,
                        value: { isTextBox: null } });
                    var width_2 = this.upperContext.measureText(parent.activeObj.textSettings.text).width +
                        parent.activeObj.textSettings.fontSize * 0.5;
                    actPoint.endX = actPoint.startX + width_2;
                    actPoint.endY = actPoint.startY + parent.activeObj.textSettings.fontSize;
                    actPoint.width = actPoint.endX - actPoint.startX;
                    actPoint.height = actPoint.endY - actPoint.startY;
                    tempActiveObj = extend({}, parent.activeObj, null, true);
                    parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,
                            isMouseMove: null, x: null, y: null } });
                }
            }
            switch (parent.upperCanvas.style.cursor) {
                case 'se-resize':
                case 's-resize':
                    if (this.previousPoint.x > x || this.previousPoint.y > y) {
                        width = (this.previousPoint.x - x);
                        height = (this.previousPoint.y - y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
                        width = (x - this.previousPoint.x);
                        height = (y - this.previousPoint.y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    break;
                case 'sw-resize':
                    if (this.previousPoint.x < x || this.previousPoint.y > y) {
                        width = (x - this.previousPoint.x);
                        height = (this.previousPoint.y - y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
                        width = (this.previousPoint.x - x);
                        height = (y - this.previousPoint.y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    break;
                case 'w-resize':
                case 'nw-resize':
                    if (this.previousPoint.x < x || this.previousPoint.y < y) {
                        width = (x - this.previousPoint.x);
                        height = (y - this.previousPoint.y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
                        width = (this.previousPoint.x - x);
                        height = (this.previousPoint.y - y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    break;
                case 'n-resize':
                case 'ne-resize':
                    if (this.previousPoint.x > x || this.previousPoint.y < y) {
                        width = (this.previousPoint.x - x);
                        height = (y - this.previousPoint.y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
                        width = (x - this.previousPoint.x);
                        height = (this.previousPoint.y - y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    break;
                case 'e-resize':
                    if (this.previousPoint.x > x || this.previousPoint.y > y) {
                        width = (this.previousPoint.x - x);
                        height = (this.previousPoint.y - y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
                        width = (x - this.previousPoint.x);
                        height = (y - this.previousPoint.y);
                        scale = (width + height) / 2;
                        newScale = this.getScaleRatio(scale);
                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);
                    }
                    break;
            }
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            if ((actPoint.width < 10 || actPoint.height < 10) ||
                (parent.activeObj.shape === 'text' && parent.activeObj.rotatedAngle === 0 && this.preventTextDraggingInvertly())) {
                parent.activeObj = extend({}, tempActiveObj, null, true);
            }
        }
        this.previousPoint = { x: x, y: y };
    };
    Selection.prototype.adjustNWPoints = function (rectangle, x, y, angle) {
        var cx = rectangle.startX + rectangle.width / 2;
        var cy = rectangle.startY + rectangle.height / 2;
        var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
        var newCenter = [(rotatedC[0] + x) / 2, (rotatedC[1] + y) / 2];
        var newBottomRight = this.rotatePoints(rotatedC[0], rotatedC[1], newCenter[0], newCenter[1], -angle);
        var newTopLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.endX = newBottomRight[0];
        rectangle.endY = newBottomRight[1];
        rectangle.startY = newTopLeft[1];
        rectangle.startX = newTopLeft[0];
        rectangle.width = rectangle.endX - rectangle.startX;
        rectangle.height = rectangle.endY - rectangle.startY;
        return rectangle;
    };
    Selection.prototype.adjustNEPoints = function (rectangle, x, y, angle) {
        var cx = rectangle.startX + rectangle.width / 2;
        var cy = rectangle.startY + rectangle.height / 2;
        var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
        var newCenter = [(rotatedD[0] + x) / 2, (rotatedD[1] + y) / 2];
        var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
        var newTopRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.startX = newBottomLeft[0];
        rectangle.endY = newBottomLeft[1];
        rectangle.width = newTopRight[0] - newBottomLeft[0];
        rectangle.height = newBottomLeft[1] - newTopRight[1];
        rectangle.endX = rectangle.startX + rectangle.width;
        rectangle.startY = rectangle.endY - rectangle.height;
        return rectangle;
    };
    Selection.prototype.adjustSWPoints = function (rectangle, x, y, angle) {
        var cx = rectangle.startX + rectangle.width / 2;
        var cy = rectangle.startY + rectangle.height / 2;
        var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
        var newCenter = [(rotatedB[0] + x) / 2, (rotatedB[1] + y) / 2];
        var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
        var newBottomLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.endX = newTopRight[0];
        rectangle.startY = newTopRight[1];
        rectangle.startX = newBottomLeft[0];
        rectangle.endY = newBottomLeft[1];
        rectangle.width = rectangle.endX - rectangle.startX;
        rectangle.height = rectangle.endY - rectangle.startY;
        return rectangle;
    };
    Selection.prototype.adjustSEPoints = function (rectangle, x, y, angle) {
        var cx = rectangle.startX + rectangle.width / 2;
        var cy = rectangle.startY + rectangle.height / 2;
        var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
        var newCenter = [(rotatedA[0] + x) / 2, (rotatedA[1] + y) / 2];
        var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
        var newBottomRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.startX = newTopLeft[0];
        rectangle.startY = newTopLeft[1];
        rectangle.width = newBottomRight[0] - newTopLeft[0];
        rectangle.height = newBottomRight[1] - newTopLeft[1];
        rectangle.endX = rectangle.startX + rectangle.width;
        rectangle.endY = rectangle.startY + rectangle.height;
        return rectangle;
    };
    Selection.prototype.adjustRotationPoints = function (rectangle, x, y, angle, type, elem) {
        var cx = rectangle.startX + rectangle.width / 2;
        var cy = rectangle.startY + rectangle.height / 2;
        this.getResizeDirection(rectangle, x, y, angle, type, elem);
        var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
        var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
        var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
        var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
        var newCenter = [(rotatedA[0] + rotatedC[0]) / 2, (rotatedA[1] + rotatedC[1]) / 2];
        var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
        var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
        var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
        rectangle.startX = newTopLeft[0];
        rectangle.startY = newTopLeft[1];
        rectangle.endX = newTopRight[0];
        rectangle.endY = newBottomLeft[1];
        rectangle.width = rectangle.endX - rectangle.startX;
        rectangle.height = rectangle.endY - rectangle.startY;
        return rectangle;
    };
    Selection.prototype.rotatePoints = function (x, y, cx, cy, angle) {
        return [
            (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,
            (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy
        ];
    };
    Selection.prototype.setResizedValue = function (element, value, x, y) {
        switch (element) {
            case 'x':
                value += x;
                break;
            case 'y':
                value += y;
                break;
            case 'abs-x':
                value += (x > 0 ? -x : Math.abs(x));
                break;
            case 'abs-y':
                value += (y > 0 ? -y : Math.abs(y));
                break;
            case 'y-abs-x':
                value += (y + ((x > 0 ? -x : Math.abs(x)) / 2));
                break;
            case 'abs-x-abs-y':
                value += ((x > 0 ? -x : Math.abs(x)) + ((y > 0 ? -y : Math.abs(y)) / 2));
                break;
            case 'abs-y-x':
                value += ((y > 0 ? -y : Math.abs(y)) + (x / 2));
                break;
            case 'x-y':
                value += (x + (y / 2));
                break;
            case 'y-x':
                value += (y + (x / 2));
                break;
            case 'img-resize-x':
                value += x;
                break;
            case 'img-resize-y':
                value += y;
                break;
        }
        return value;
    };
    Selection.prototype.getResizeDirection = function (rectangle, x, y, angle, type, elem) {
        var rotatedAngle = angle * (180 / Math.PI);
        var element = this.getResizedElement(rotatedAngle, this.resizedElement);
        if (this.resizedElement === 'e-resize') {
            rectangle.width = this.setResizedValue(element, rectangle.width, x, y);
            rectangle.endX = rectangle.width + rectangle.startX;
        }
        else if (this.resizedElement === 'n-resize') {
            rectangle.startY = this.setResizedValue(element, rectangle.startY, x, y);
            rectangle.height = rectangle.endY - rectangle.startY;
        }
        else if (this.resizedElement === 'w-resize') {
            rectangle.startX = this.setResizedValue(element, rectangle.startX, x, y);
            rectangle.width = rectangle.startX + rectangle.endX;
        }
        else if (this.resizedElement === 's-resize') {
            rectangle.height = this.setResizedValue(element, rectangle.height, x, y);
            rectangle.endY = rectangle.height + rectangle.startY;
        }
        else if (type && type === 'img-resize') {
            rectangle.width = this.setResizedValue('img-resize-x', rectangle.width, x, y);
            rectangle.height = this.setResizedValue('img-resize-y', rectangle.height, x, y);
            if (elem === 'se-resize') {
                rectangle.endX = rectangle.width + rectangle.startX;
                rectangle.endY = rectangle.height + rectangle.startY;
            }
            else if (elem === 'sw-resize') {
                rectangle.startX = rectangle.endX - rectangle.width;
                rectangle.endY = rectangle.height + rectangle.startY;
            }
            else if (elem === 'ne-resize') {
                rectangle.endX = rectangle.width + rectangle.startX;
                rectangle.startY = rectangle.endY - rectangle.height;
            }
            else if (elem === 'nw-resize') {
                rectangle.startX = rectangle.endX - rectangle.width;
                rectangle.startY = rectangle.endY - rectangle.height;
            }
        }
        else if (type && type === 'text') {
            if (elem === 'widthHeight') {
                rectangle.width = this.setResizedValue('x-y', rectangle.width, x, y);
                rectangle.endX = rectangle.width + rectangle.startX;
                rectangle.height = this.setResizedValue('y-x', rectangle.height, x, y);
                rectangle.endY = rectangle.height + rectangle.startY;
            }
            else if (elem === 'width') {
                rectangle.width = this.setResizedValue('x-y', rectangle.width, x, y);
                rectangle.endX = rectangle.width + rectangle.startX;
            }
            else if (elem === 'height') {
                rectangle.height = this.setResizedValue('y-abs-x', rectangle.height, x, y);
                rectangle.endY = rectangle.height + rectangle.startY;
            }
        }
    };
    Selection.prototype.getResizedElement = function (degree, element) {
        var resizeMappings = [];
        if (element === 'n-resize') {
            resizeMappings = [
                [337.5, 360, 'y'],
                [0, 22.5, 'y'],
                [22.5, 67.5, 'y-abs-x'],
                [67.5, 112.5, 'abs-x'],
                [112.5, 157.5, 'abs-x-abs-y'],
                [157.5, 202.5, 'abs-y'],
                [202.5, 247.5, 'abs-y-x'],
                [247.5, 292.5, 'x'],
                [292.5, 337.5, 'x-y']
            ];
        }
        else if (element === 'e-resize') {
            resizeMappings = [
                [337.5, 360, 'x'],
                [0, 22.5, 'x'],
                [22.5, 67.5, 'x-y'],
                [67.5, 112.5, 'y'],
                [112.5, 157.5, 'y-abs-x'],
                [157.5, 202.5, 'abs-x'],
                [202.5, 247.5, 'abs-x-abs-y'],
                [247.5, 292.5, 'abs-y'],
                [292.5, 337.5, 'abs-y-x']
            ];
        }
        else if (element === 's-resize') {
            resizeMappings = [
                [337.5, 360, 'y'],
                [0, 22.5, 'y'],
                [22.5, 67.5, 'y-abs-x'],
                [67.5, 112.5, 'abs-x'],
                [112.5, 157.5, 'abs-x-abs-y'],
                [157.5, 202.5, 'abs-y'],
                [202.5, 247.5, 'abs-y-x'],
                [247.5, 292.5, 'x'],
                [292.5, 337.5, 'x-y']
            ];
        }
        else if (element === 'w-resize') {
            resizeMappings = [
                [337.5, 360, 'x'],
                [0, 22.5, 'x'],
                [22.5, 67.5, 'x-y'],
                [67.5, 112.5, 'y'],
                [112.5, 157.5, 'y-abs-x'],
                [157.5, 202.5, 'abs-x'],
                [202.5, 247.5, 'abs-x-abs-y'],
                [247.5, 292.5, 'abs-y'],
                [292.5, 337.5, 'abs-y-x']
            ];
        }
        var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
        for (var _i = 0, resizeMappings_2 = resizeMappings; _i < resizeMappings_2.length; _i++) {
            var _a = resizeMappings_2[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];
            if ((positiveDegree > startDegree && positiveDegree <= endDegree) ||
                (positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree)) {
                return resizeElement;
            }
        }
        return element;
    };
    Selection.prototype.updateCursorStyles = function (x, y, type) {
        var parent = this.parent;
        var isResize = false;
        if (parent.activeObj.keyHistory !== '' && parent.activeObj.shape === undefined && !parent.currObjType.isCustomCrop &&
            !parent.currObjType.isLine && parent.currObjType.isText) {
            parent.activeObj.shape = 'text';
        }
        var actObj = extend({}, parent.activeObj, {}, true);
        if (isNullOrUndefined(actObj.topLeftCircle)) {
            return;
        }
        var degree;
        if (actObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - actObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (this.isObjSelected) {
            if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                isResize = this.updateCursorStylesForLineArrow(x, y, actObj);
            }
            else if (actObj.shape === 'path') {
                isResize = this.updateCursorStylesForPath(x, y, actObj);
            }
            else if (actObj.rotatedAngle) {
                this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
                if (parent.cursor === 'grabbing') {
                    parent.upperCanvas.style.cursor = parent.cursor = 'grabbing';
                    this.dragElement = parent.cursor;
                }
                else if (parent.cursor === 'move') {
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                }
                else if (parent.cursor !== 'default') {
                    isResize = true;
                    this.dragElement = parent.cursor;
                    parent.currObjType.isResize = true;
                }
            }
            else {
                var rotationCirclePoint = this.getTransRotationPoint(actObj);
                var radius = actObj.topLeftCircle.radius;
                if (rotationCirclePoint &&
                    x >= rotationCirclePoint.x - (radius * 2) &&
                    x <= rotationCirclePoint.x + (radius * 2) &&
                    y >= rotationCirclePoint.y - (radius * 2) &&
                    y <= rotationCirclePoint.y + (radius * 2) && this.dragElement !== 'grabbing') {
                    parent.upperCanvas.style.cursor = parent.cursor = 'grabbing';
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.topLeftCircle.startX - (radius * 2)) &&
                    x <= (actObj.topLeftCircle.startX + (radius * 2)) &&
                    y >= (actObj.topLeftCircle.startY - (radius * 2)) &&
                    y <= (actObj.topLeftCircle.startY + (radius * 2)) && this.dragElement !== 'nw-resize') {
                    actObj.topLeftCircle.startX = actObj.topLeftCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.topLeftCircle.startX - (radius * 2)) &&
                    x <= (actObj.topRightCircle.startX - (radius * 2)) &&
                    y >= (actObj.topCenterCircle.startY - (radius * 2)) &&
                    y <= (actObj.topCenterCircle.startY + (radius * 2)) && this.dragElement !== 'n-resize') {
                    actObj.topCenterCircle.startX = actObj.topCenterCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'n-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.topRightCircle.startX - (radius * 2)) &&
                    x <= (actObj.topRightCircle.startX + (radius * 2)) &&
                    y >= (actObj.topRightCircle.startY - (radius * 2)) &&
                    y <= (actObj.topRightCircle.startY + (radius * 2)) && this.dragElement !== 'ne-resize') {
                    actObj.topRightCircle.startX = actObj.topRightCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.centerLeftCircle.startX - (radius * 2)) &&
                    x <= (actObj.centerLeftCircle.startX + (radius * 2)) &&
                    y >= (actObj.topLeftCircle.startY - (radius * 2)) &&
                    y <= (actObj.bottomLeftCircle.startY - (radius * 2)) && this.dragElement !== 'w-resize') {
                    actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'w-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.centerRightCircle.startX - (radius * 2)) &&
                    x <= (actObj.centerRightCircle.startX + (radius * 2)) &&
                    y >= (actObj.topRightCircle.startY - (radius * 2)) &&
                    y <= (actObj.bottomRightCircle.startY - (radius * 2)) && this.dragElement !== 'e-resize') {
                    actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'e-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.bottomLeftCircle.startX - (radius * 2)) &&
                    x <= (actObj.bottomLeftCircle.startX + (radius * 2)) &&
                    y >= (actObj.bottomLeftCircle.startY - (radius * 2)) &&
                    y <= (actObj.bottomLeftCircle.startY + (radius * 2)) && this.dragElement !== 'sw-resize') {
                    actObj.bottomLeftCircle.startX = actObj.bottomLeftCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.bottomLeftCircle.startX - (radius * 2)) &&
                    x <= (actObj.bottomRightCircle.startX - (radius * 2)) &&
                    y >= (actObj.bottomCenterCircle.startY - (radius * 2)) &&
                    y <= (actObj.bottomCenterCircle.startY + (radius * 2)) && this.dragElement !== 's-resize') {
                    actObj.bottomCenterCircle.startX = actObj.bottomCenterCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 's-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.bottomRightCircle.startX - (radius * 2)) &&
                    x <= (actObj.bottomRightCircle.startX + (radius * 2)) &&
                    y >= (actObj.bottomRightCircle.startY - (radius * 2)) &&
                    y <= (actObj.bottomRightCircle.startY + (radius * 2)) && this.dragElement !== 'se-resize') {
                    actObj.bottomRightCircle.startX = actObj.bottomRightCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else {
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                }
                if ((actObj.shape === 'text') && (parent.cursor === 'n-resize' ||
                    parent.cursor === 's-resize' || parent.cursor === 'e-resize' ||
                    parent.cursor === 'w-resize')) {
                    parent.upperCanvas.style.cursor = parent.cursor = 'move';
                    this.dragElement = '';
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                }
            }
        }
        else {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
        }
        this.previousPoint.x = this.previousPoint.y = this.diffPoint.x = this.diffPoint.y = 0;
        if (type === 'touchstart') {
            if (isResize || (x >= actObj.activePoint.startX && x <= actObj.activePoint.endX
                && y >= actObj.activePoint.startY && y <= actObj.activePoint.endY) || this.dragElement === 'grabbing') {
                parent.currObjType.isDragging = true;
            }
            else if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
                if (parent.cursor === 'move') {
                    parent.currObjType.isDragging = true;
                }
            }
            else if (actObj.shape === 'path') {
                this.setCursorForPath(actObj, x, y, parent.upperCanvas);
                if (parent.cursor === 'move') {
                    parent.currObjType.isDragging = true;
                }
            }
        }
        else {
            parent.currObjType.isDragging = true;
        }
        if (actObj.rotatedAngle !== 0 && (this.dragElement === 'e-resize' ||
            this.dragElement === 'w-resize' || this.dragElement === 'n-resize' ||
            this.dragElement === 's-resize')) {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
        }
    };
    Selection.prototype.updateCursorStylesForLineArrow = function (x, y, actObj) {
        var isResize = false;
        var parent = this.parent;
        var point;
        var radius = actObj.topLeftCircle.radius;
        for (var i = 0; i < 5; i++) {
            point = actObj.pointColl[i];
            if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&
                y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {
                actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
                this.dragElement = 'w-resize';
                isResize = true;
                break;
            }
        }
        if (!isResize) {
            for (var i = 1; i < 6; i++) {
                point = actObj.pointColl[actObj.pointColl.length - i];
                if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&
                    y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {
                    actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
                    this.dragElement = 'e-resize';
                    isResize = true;
                    break;
                }
            }
        }
        if (!isResize) {
            for (var i = 0; i < actObj.pointColl.length; i++) {
                point = actObj.pointColl[i];
                if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&
                    y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {
                    parent.upperCanvas.style.cursor = parent.cursor = 'move';
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                    break;
                }
                else {
                    parent.upperCanvas.style.cursor = parent.cursor = 'default';
                }
            }
        }
        return isResize;
    };
    Selection.prototype.updateCursorStylesForPath = function (x, y, actObj) {
        var isResize = false;
        var parent = this.parent;
        this.pathAdjustedIndex = this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
        if (parent.cursor === 'move') {
            isResize = true;
            this.dragElement = 'pathDrag';
        }
        if (!isResize) {
            parent.upperCanvas.style.cursor = parent.cursor = 'move';
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
        }
        return isResize;
    };
    Selection.prototype.setTextSelection = function (width, height) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var degree = parent.transform.degree;
        if (parent.activeObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - parent.activeObj.shapeDegree;
        }
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var coll = parent.activeObj.rotateFlipColl;
        if (this.isTransformedShape && coll) {
            degree = 0;
            for (var i = 0; i < coll.length; i++) {
                if (typeof (coll[i]) === 'number') {
                    degree += (coll[i]);
                }
            }
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
            var flip = parent.activeObj.flipObjColl[i].toLowerCase();
            switch (degree) {
                case 0:
                    switch (flip) {
                        case 'horizontal':
                            actPoint = { startX: actPoint.endX - width, startY: actPoint.startY, endX: (actPoint.endX),
                                endY: actPoint.startY + (height ? height : 0) };
                            break;
                        case 'vertical':
                            actPoint.startY = actPoint.endY - height;
                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + (width ? width : 0)),
                                endY: actPoint.endY };
                            break;
                        default:
                            actPoint = { startX: actPoint.startX,
                                startY: actPoint.startY, endX: (actPoint.startX + (width ? width : 0)), endY: actPoint.startY +
                                    (height ? height : 0) };
                            break;
                    }
                    break;
                case 90:
                    switch (flip) {
                        case 'horizontal':
                            actPoint.endX = actPoint.startX + height;
                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.endX),
                                endY: actPoint.startY + (width ? width : 0) };
                            break;
                        case 'vertical':
                            actPoint.startX = actPoint.endX - height;
                            actPoint = { startX: actPoint.startX, startY: actPoint.endY - width, endX: (actPoint.endX), endY: actPoint.endY };
                            break;
                        default:
                            actPoint.startX = actPoint.endX - height;
                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.endX),
                                endY: actPoint.startY + (width ? width : 0) };
                            break;
                    }
                    break;
                case 180:
                    switch (flip) {
                        case 'horizontal':
                            actPoint.startY = actPoint.endY - height;
                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + width),
                                endY: actPoint.endY };
                            break;
                        case 'vertical':
                            actPoint.endY = actPoint.startY + height;
                            actPoint = { endX: actPoint.endX, endY: actPoint.endY, startX: (actPoint.endX - (width ? width : 0)),
                                startY: actPoint.startY };
                            break;
                        default:
                            actPoint = { endX: actPoint.endX, endY: actPoint.endY, startX: (actPoint.endX - (width ? width : 0)),
                                startY: actPoint.endY - (height ? height : 0) };
                            break;
                    }
                    break;
                case 270:
                    switch (flip) {
                        case 'horizontal':
                            actPoint.startX = actPoint.endX - height;
                            actPoint = { startX: actPoint.startX, startY: actPoint.endY - (width ? width : 0), endX: actPoint.endX,
                                endY: actPoint.endY };
                            break;
                        case 'vertical':
                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + height),
                                endY: actPoint.startY + (width ? width : 0) };
                            break;
                        default:
                            actPoint.endX = actPoint.startX + height;
                            actPoint = { startX: actPoint.startX, startY: actPoint.endY - (width ? width : 0), endX: actPoint.endX,
                                endY: actPoint.endY };
                            break;
                    }
                    break;
            }
        }
        if (parent.activeObj.flipObjColl.length === 0) {
            switch (degree) {
                case 0:
                    actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + (width ? width : 0)),
                        endY: actPoint.startY + (height ? height : 0) };
                    break;
                case 90:
                    actPoint.startX = actPoint.endX - height;
                    actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.endX),
                        endY: actPoint.startY + (width ? width : 0) };
                    break;
                case 180:
                    actPoint = { endX: actPoint.endX, endY: actPoint.endY, startX: (actPoint.endX - (width ? width : 0)),
                        startY: actPoint.endY - (height ? height : 0) };
                    break;
                case 270:
                    actPoint.endX = actPoint.startX + height;
                    actPoint = { startX: actPoint.startX, startY: actPoint.endY - (width ? width : 0), endX: actPoint.endX,
                        endY: actPoint.endY };
                    break;
            }
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        parent.activeObj.activePoint = actPoint;
        if (parent.transform.degree === 360 || parent.transform.degree === -360) {
            parent.transform.degree = 0;
        }
    };
    Selection.prototype.setActivePoint = function (startX, startY) {
        var parent = this.parent;
        var activePoint = parent.activeObj.activePoint;
        if (isNullOrUndefined(activePoint)) {
            return;
        }
        if (parent.currObjType.isText) {
            var textWidth = startX ? startX : 0;
            var textHeight = startY ? startY : parent.activeObj.textSettings.fontSize;
            if (parent.activeObj.textSettings.fontSize === undefined) {
                parent.activeObj.textSettings.fontSize = (Math.abs(parent.baseImgCanvas.width - parent.baseImgCanvas.height)) * 0.1;
            }
            this.setTextSelection(textWidth, textHeight);
            this.mouseDownPoint.x = activePoint.endX;
            this.mouseDownPoint.y = activePoint.endY;
            if (parent.activeObj.horTopLine !== undefined) {
                parent.activeObj.activePoint = extend({}, activePoint, {}, true);
            }
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        }
        else if (startX && startY) {
            activePoint.startX = this.mouseDownPoint.x = startX;
            activePoint.startY = this.mouseDownPoint.y = startY;
            parent.currObjType.isDragging = true;
        }
        else {
            var selectInfo = parent.activeObj;
            activePoint = { startX: selectInfo.horTopLine.startX, startY: selectInfo.horTopLine.startY,
                endX: selectInfo.horTopLine.endX, endY: selectInfo.horTopLine.endY };
            activePoint.width = activePoint.endX - activePoint.startX;
            activePoint.height = activePoint.endY - activePoint.startY;
        }
    };
    Selection.prototype.mouseDownEventHandler = function (e) {
        var parent = this.parent;
        parent.isKBDNavigation = false;
        this.mouseDown = e.currentTarget === parent.lowerCanvas || e.currentTarget === parent.upperCanvas ?
            'canvas' : '';
        if (e.type === 'touchstart') {
            this.isTouch = true;
        }
        else {
            this.isTouch = false;
        }
        if (e.type === 'touchstart' && e.currentTarget === parent.lowerCanvas && !parent.isImageLoaded) {
            return;
        }
        this.isCropSelection = false;
        this.isPan = true;
        var splitWords;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            this.isCropSelection = true;
        }
        if (this.isCropSelection) {
            this.dragCanvas = parent.togglePan = true;
        }
        if (parent.cursor === 'grabbing') {
            var obj = { shapeSettingsObj: {} };
            this.isGrabbing = true;
            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
            var shapeSettings = obj['shapeSettingsObj'];
            var shapeResizingArgs = { cancel: false, action: 'rotate-start', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
            var shapeMovingArgs = { cancel: false, action: 'rotate-start', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-down');
        }
        var imageEditorClickEventArgs = { point: this.setXYPoints(e) };
        parent.trigger('click', imageEditorClickEventArgs);
        this.isMouseDown = true;
        this.isMouseUp = false;
        this.clickEvent(imageEditorClickEventArgs, e);
    };
    Selection.prototype.getImagePoints = function (x, y) {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (x < destLeft) {
            x = destLeft;
        }
        else if (x > destLeft + destWidth) {
            x = destLeft + destWidth;
        }
        if (y < destTop) {
            y = destTop;
        }
        else if (y > destTop + destHeight) {
            y = destTop + destHeight;
        }
        return { x: x, y: y };
    };
    Selection.prototype.clickEvent = function (imageEditorClickEventArgs, e) {
        var parent = this.parent;
        var activePoint = parent.activeObj.activePoint;
        var x = imageEditorClickEventArgs.point.x;
        var y = imageEditorClickEventArgs.point.y;
        var cursor = parent.activeObj.shape && parent.activeObj.shape === 'text' ?
            parent.cursor : 'default';
        var tempCursor = parent.upperCanvas.style.cursor;
        if (parent.isResize) {
            this.performEnterAction(e);
            parent.upperCanvas.style.cursor = 'default';
            return;
        }
        else if (JSON.stringify(parent.frameObj) !== JSON.stringify(parent.tempFrameObj)) {
            parent.okBtn();
        }
        else if (this.currentDrawingShape !== '' && (!this.isShapeTouch(e, this.isCropSelection) &&
            ((this.isTouch) || tempCursor === 'crosshair' || parent.isShapeDrawing))) {
            if (parent.drawingShape && !parent.isShapeDrawing) {
                parent.okBtn();
                parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
            }
            activePoint = parent.activeObj.activePoint;
            var object_1 = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object_1 } });
            this.initialPrevObj = object_1['currObj'];
            this.initialPrevObj.objColl = extend([], parent.objColl, [], true);
            this.initialPrevObj.pointColl = extend([], parent.pointColl, [], true);
            this.initialPrevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            this.initialPrevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            this.setActivePoint(x, y);
            activePoint = parent.activeObj.activePoint;
            if (this.currentDrawingShape === 'path') {
                var point = this.getImagePoints(x, y);
                parent.activeObj.pointColl.push({ x: point.x, y: point.y });
                if (activePoint.width !== 0 && activePoint.height !== 0) {
                    activePoint.width = 0;
                    activePoint.height = 0;
                    activePoint.startX = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].x;
                    activePoint.startY = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].y;
                }
            }
            activePoint.endX = activePoint.startX;
            activePoint.endY = activePoint.startY;
            if (this.currentDrawingShape === 'text') {
                parent.activeObj.textSettings.fontSize = 11;
                this.previousPoint.x = activePoint.startX;
                this.previousPoint.y = activePoint.startY;
                parent.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,
                    value: { isTextBox: null } });
                var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;
                activePoint.endX = activePoint.startX + width;
                activePoint.endY = activePoint.startY + parent.activeObj.textSettings.fontSize;
                activePoint.width = activePoint.endX - activePoint.startX;
                activePoint.height = activePoint.endY - activePoint.startY;
            }
            else if (this.currentDrawingShape === 'arrow') {
                parent.activeObj.start = this.arrowShape[0];
                parent.activeObj.end = this.arrowShape[1];
            }
            parent.currObjType.isDragging = true;
            var previousShapeSettings = this.updatePrevShapeSettings();
            var shapeResizingArgs = { cancel: false, action: 'draw-start', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
            var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
            this.shapeResizingArgs = shapeResizingArgs;
            this.shapeMovingArgs = shapeMovingArgs;
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-down');
            parent.activeObj.activePoint = activePoint;
            parent.isShapeDrawing = true;
            this.tempActiveObj = extend({}, parent.activeObj, {}, true);
            return;
        }
        parent.notify('draw', { prop: 'resetFrameZoom', onPropertyChange: false, value: { isOk: true } });
        if (this.isCropSelection && this.dragCanvas) {
            this.setCursor(x, y);
            if (parent.cursor !== 'move' && parent.cursor !== 'crosshair' &&
                parent.cursor !== 'default' && parent.cursor !== 'grab') {
                this.isPan = false;
            }
        }
        if (parent.activeObj.shape) {
            this.isObjSelected = true;
        }
        else {
            this.isObjSelected = false;
        }
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        var activeObj = extend({}, parent.activeObj, null, true);
        var isShape = this.isShapeTouch(e, this.isCropSelection);
        var isFreehandDraw = this.isFreehandDrawTouch(e, this.isCropSelection);
        var isShapeClick = isShape ? isShape : this.isShapeClick(e, this.isCropSelection);
        var allowUndoRedoPush = this.applyCurrShape(isShapeClick);
        var isTextArea = parent.textArea.style.display !== 'none' ? true : false;
        if (this.isTouch && !isShape && activeObj.shape && !this.isCropSelection) {
            if (this.applyObj(x, y)) {
                parent.okBtn(true);
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
            }
            var prevCropObj = extend({}, parent.cropObj, {}, true);
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: parent.isCircleCrop } });
            if (allowUndoRedoPush) {
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
        }
        if (!isShape && !parent.togglePen && !this.isCropSelection && parent.activeObj.redactType !== 'blur' && parent.activeObj.redactType !== 'pixelate') {
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
        }
        if (this.dragCanvas && this.isPan && (parent.cursor === 'grab' || this.isTouch)
            && !isShape && !isFreehandDraw && !parent.togglePen) {
            if (this.applyObj(x, y)) {
                parent.okBtn(true);
                if (allowUndoRedoPush) {
                    var cursor_1 = parent.cursor;
                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                    parent.cursor = cursor_1;
                }
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
            }
            if (this.isFhdEditing) {
                parent.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
                this.isFhdCustomized = false;
                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
            }
            var shape = parent.activeObj.shape;
            var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'text', 'image', 'redact'];
            if (shape && shapeColl.indexOf(shape) > -1) {
                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                    value: { x: null, y: null, isMouseDown: null } });
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
            var isCropSelection = false;
            if (parent.activeObj.shape && parent.activeObj.shape.indexOf('crop-') > -1) {
                isCropSelection = true;
            }
            if (parent.element.querySelector('.e-contextual-toolbar-wrapper') && !isCropSelection) {
                if (!parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {
                    parent.okBtn();
                    parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                }
            }
            this.canvasMouseDownHandler(e);
        }
        else {
            var isLineArrow = false;
            if (parent.activeObj.shape && (parent.activeObj.shape === 'line' ||
                parent.activeObj.shape === 'arrow')) {
                isLineArrow = true;
            }
            var points = this.setXYPoints(e);
            var x_1 = points.x;
            var y_1 = points.y;
            if (this.applyObj(x_1, y_1)) {
                parent.okBtn(true);
                if (allowUndoRedoPush) {
                    var cursor_2 = parent.cursor;
                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                    parent.cursor = cursor_2;
                }
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
            }
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: x_1, y: y_1, isMouseDown: true } });
            var obj = { index: null };
            parent.notify('freehand-draw', { prop: 'getFreehandDrawHoveredIndex', onPropertyChange: false, value: { obj: obj } });
            var indexObj = { freehandSelectedIndex: null };
            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            if (this.isFhdPoint || (this.isFhdCustomized && !parent.togglePen)) {
                if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) &&
                    indexObj['freehandSelectedIndex'] !== obj['index']) {
                    var tempHoveredIndex = obj['index'];
                    parent.okBtn();
                    this.isFhdCustomized = false;
                    parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
                        value: { index: tempHoveredIndex } });
                    if (obj['index'] > -1) {
                        var strokeColor = parent.pointColl[obj['index']].strokeColor;
                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                            value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[obj['index']].strokeWidth } });
                    }
                }
                indexObj['freehandSelectedIndex'] = null;
                parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                var objColl = extend([], parent.objColl, [], true);
                if (!isNullOrUndefined(obj['index']) && obj['index'] > -1) {
                    parent.notify('freehand-draw', { prop: 'selectFhd', value: { type: 'ok' } });
                    parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                        value: { strokeColor: null, strokeWidth: null } });
                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });
                }
                else if (indexObj['freehandSelectedIndex']) {
                    parent.okBtn();
                    var strokeColor = parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;
                    parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                        value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth } });
                }
                else if (this.findTargetObj(x_1, y_1, false)) {
                    parent.objColl = objColl;
                    this.findTarget(x_1, y_1, e.type);
                    parent.notify('draw', { prop: 'redrawDownScale' });
                }
            }
            else {
                if (this.isFhdEditing) {
                    parent.apply();
                    var qbArea = document.getElementById(parent.element.id + '_quickAccessToolbarArea');
                    if (qbArea) {
                        qbArea.style.display = 'none';
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var point = parent.pointColl[indexObj['freehandSelectedIndex']];
                    var shapeSettings = { id: 'pen_' + (indexObj['freehandSelectedIndex'] + 1), type: ShapeType.FreehandDraw,
                        startX: point.points[0].x, startY: point.points[0].y, strokeColor: point.strokeColor,
                        strokeWidth: point.strokeWidth, points: point.points, opacity: point.opacity,
                        index: point.order };
                    var shapeChangedArgs = { action: 'apply', currentShapeSettings: extend({}, shapeSettings, {}, true) };
                    parent.trigger('shapeChange', shapeChangedArgs);
                    parent.editCompleteArgs = shapeChangedArgs;
                }
                var isPenDraw = parent.togglePen;
                parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
                if (isPenDraw) {
                    parent.freeHandDraw(true);
                }
                this.isFhdEditing = false;
                if (isLineArrow) {
                    this.setCursor(x_1, y_1);
                }
                else if (cursor !== 'default') {
                    parent.upperCanvas.style.cursor = parent.cursor = cursor;
                }
                if (parent.cursor === 'crosshair' || (Browser.isDevice && parent.togglePen)) {
                    if (parent.togglePen) {
                        if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
                            var obj_1 = { strokeSettings: {} };
                            parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false, value: { obj: obj_1 } });
                            parent.activeObj.strokeSettings = obj_1['strokeSettings'];
                        }
                        var obj_2 = { penStrokeWidth: null };
                        parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: obj_2 } });
                        if (isNullOrUndefined(obj_2['penStrokeWidth'])) {
                            parent.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: 2 } });
                        }
                        this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
                        this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
                        parent.notify('freehand-draw', { prop: 'resetSelPoints', onPropertyChange: false });
                        parent.notify('freehand-draw', { prop: 'freehandDownHandler', onPropertyChange: false,
                            value: { e: e, canvas: parent.upperCanvas } });
                    }
                    else {
                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    }
                    parent.currObjType.isActiveObj = false;
                    this.dragElement = '';
                    this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
                }
                if (((this.isTouch && tempCursor !== 'crosshair' || parent.cursor !== 'crosshair') &&
                    e.type.toLowerCase() === 'touchstart') ||
                    (parent.currObjType.isActiveObj && parent.cursor !== 'default' && !parent.togglePen)) {
                    parent.notify('draw', { prop: 'updateTempObjColl' });
                    parent.notify('draw', { prop: 'updateTempPointColl' });
                    this.findTarget(x_1, y_1, e.type);
                    parent.notify('draw', { prop: 'redrawDownScale' });
                }
                else if ((parent.currObjType.shape === '' || parent.currObjType.isCustomCrop) && !parent.togglePen && parent.cursor !== 'default') {
                    this.setActivePoint(x_1, y_1);
                }
                if (isTextArea) {
                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                }
            }
        }
        this.isShapeInserted = false;
        this.tempActiveObj = extend({}, parent.activeObj, {}, true);
    };
    Selection.prototype.mouseMoveEventHandler = function (e) {
        var parent = this.parent;
        var cursor = parent.cursor;
        var canvasCursor = parent.upperCanvas.style.cursor;
        e.preventDefault();
        if (this.isPreventShaping || (parent.isShapeDrawing && parent.currObjType.isDragging && this.isTouch &&
            parent.activeObj.shape && parent.activeObj.shape === 'path')) {
            return;
        }
        if (parent.cursor === 'grabbing' && this.isGrabbing) {
            var obj = { shapeSettingsObj: {} };
            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
            var shapeSettings = obj['shapeSettingsObj'];
            var shapeResizingArgs = { cancel: false, action: 'rotating', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
            var shapeMovingArgs = { cancel: false, action: 'rotating', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-down');
        }
        if (this.timer && this.timer > 0 && this.dragPoint.startX && this.dragPoint.startY) {
            var width = Math.abs(this.dragPoint.startX - e.touches[0].clientX);
            var height = Math.abs(this.dragPoint.startY - e.touches[0].clientY);
            if (width > 10 || height > 10) {
                this.timer = 0;
            }
        }
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        if (e.type === 'touchmove' && e.touches.length === 2) {
            if (this.isFirstMove) {
                this.startTouches = this.targetTouches(e.touches);
                this.tempTouches = [];
                this.tempTouches.push({ x: (e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft) - bbox.left),
                    y: (e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop)) - bbox.top });
                this.tempTouches.push({ x: (e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left,
                    y: (e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop)) - bbox.top });
            }
            else {
                var firstFingerX = (e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left;
                var firstFingerY = (e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop)) - bbox.top;
                var secondFingerX = (e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left;
                var secondFingerY = (e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop)) - bbox.top;
                var center = { x: firstFingerX < secondFingerX ? secondFingerX - ((secondFingerX - firstFingerX) / 2) :
                        firstFingerX - ((firstFingerX - secondFingerX) / 2), y: firstFingerY < secondFingerY ?
                        secondFingerY - ((secondFingerY - firstFingerY) / 2) : firstFingerY - ((firstFingerY - secondFingerY) / 2) };
                if (this.currMousePoint.x !== center.x && this.currMousePoint.y !== center.y) {
                    var type = '';
                    if (e.type === 'touchmove' && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Pinch) === ZoomTrigger.Pinch) {
                        this.zoomType = 'Pinch';
                        var scale = this.calculateScale(this.startTouches, this.targetTouches(e.touches));
                        this.startTouches = this.targetTouches(e.touches);
                        if (scale > 1) {
                            type = 'zoomIn';
                        }
                        else if (scale < 1) {
                            type = 'zoomOut';
                        }
                    }
                    if (type !== '') {
                        parent.isZoomBtnClick = true;
                        parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                            value: { x: center.x, y: center.y, type: type, isResize: null } });
                    }
                    this.tempTouches = [];
                    this.tempTouches.push({ x: e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft),
                        y: e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop) });
                    this.tempTouches.push({ x: e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft),
                        y: e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop) });
                    this.currMousePoint.x = center.x;
                    this.currMousePoint.y = center.y;
                    this.isPinching = true;
                }
            }
            this.isFirstMove = false;
            return;
        }
        var x;
        var y;
        if (e.type === 'mousemove') {
            x = e.clientX;
            y = e.clientY;
        }
        else {
            this.touchEndPoint.x = x = e.touches[0].clientX;
            this.touchEndPoint.y = y = e.touches[0].clientY;
        }
        x -= bbox.left;
        y -= bbox.top;
        this.canvasMouseMoveHandler(e);
        var isCropSelection = false;
        var splitWords;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (isCropSelection) {
            parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
        }
        parent.upperCanvas.style.cursor = canvasCursor;
        parent.cursor = cursor;
        if (parent.currObjType.isActiveObj && (parent.activeObj.activePoint !== undefined || parent.objColl.length > 0) &&
            !this.dragCanvas || parent.activeObj.activePoint !== undefined) {
            if (this.dragElement === '') {
                this.setCursor(x, y);
                if ((parent.activeObj.activePoint &&
                    (parent.activeObj.activePoint.width === 0 || (!isNullOrUndefined(parent.activeObj.currIndex) &&
                        this.cursorTargetId !== parent.activeObj.currIndex)))
                    && parent.cursor !== 'default' &&
                    parent.cursor !== 'move' && parent.cursor !== 'crosshair'
                    && parent.cursor !== 'grab' && parent.cursor !== 'pointer') {
                    parent.upperCanvas.style.cursor = parent.cursor = 'move';
                }
                this.findTarget(x, y, e.type);
            }
        }
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        if (parent.currObjType.isDragging) {
            if (parent.activeObj.shape && parent.activeObj.preventShapeDragOut) {
                if (x < destLeft || x > destLeft + destWidth || y < destTop || y > destTop + destHeight) {
                    return;
                }
            }
            this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.updateActivePoint(x, y, isCropSelection);
            parent.notify('shape', { prop: 'updateTrianglePoints', onPropertyChange: false, value: { obj: parent.activeObj } });
            if (this.isPreventDragging) {
                if (!this.isShapeDragOut()) {
                    this.isPreventDragging = false;
                }
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
            else {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: null, saveContext: null, isPreventSelection: null } });
            }
            if (isCropSelection) {
                this.dragCanvas = parent.togglePan = true;
            }
        }
        this.isMouseDown = false;
        this.isMouseUp = false;
    };
    Selection.prototype.mouseUpEventHandler = function (e) {
        var parent = this.parent;
        var id = parent.element.id;
        parent.isKBDNavigation = this.isMouseDown = false;
        this.isMouseUp = true;
        if (!Browser.isDevice && ((parent.element.querySelector('#' + id + '_contextualToolbar') &&
            !parent.element.querySelector('#' + id + '_contextualToolbar').parentElement.classList.contains('e-hide')) ||
            (parent.element.querySelector('#' + id + '_headWrapper')
                && !parent.element.querySelector('#' + id + '_headWrapper').parentElement.classList.contains('e-hide')))) {
            if (!(parent.activeObj.shape && parent.activeObj.shape === 'redact' && parent.isShapeDrawing)) {
                return;
            }
        }
        if (parent.cursor === 'grabbing' && this.isGrabbing) {
            var obj = { shapeSettingsObj: {} };
            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
            var shapeSettings = obj['shapeSettingsObj'];
            var shapeResizingArgs = { cancel: false, action: 'rotate-end', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
            var shapeMovingArgs = { cancel: false, action: 'rotate-end', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-up');
        }
        this.isGrabbing = false;
        if (this.isPreventShaping) {
            this.isPreventShaping = false;
        }
        if (this.mouseDown === 'canvas' || this.isSliderActive ||
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            e.target.closest('.e-image-editor') || e.target.closest('.e-ie-ddb-popup')) {
            if (e.type === 'touchstart') {
                this.isTouch = false;
            }
            else if (e.type === 'touchend') {
                e.stopImmediatePropagation();
            }
            e.preventDefault();
            if (parent.togglePan) {
                this.canvasMouseUpHandler(e);
            }
            var x = void 0;
            var y = void 0;
            if (e.type === 'mouseup') {
                x = e.clientX;
                y = e.clientY;
            }
            else if (!this.isTouchDblClick) {
                x = this.touchEndPoint.x;
                y = this.touchEndPoint.y;
            }
            var bbox = parent.lowerCanvas.getBoundingClientRect();
            x -= bbox.left;
            y -= bbox.top;
            var activeObjShape = void 0;
            var currentDrawingShape = this.currentDrawingShape;
            var dummyClick = false;
            if (e.type === 'touchend') {
                this.startTouches = this.tempTouches = [];
                this.isFirstMove = false;
                if (parent.textArea.style.display === 'none') {
                    this.timer = 0;
                }
                if (this.isPinching) {
                    this.isPinching = false;
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    if (parent.isCropTab || parent.activeObj.shape) {
                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
                    }
                    if (parent.isStraightening) {
                        parent.notify('draw', { prop: 'resetStraightenDestPoints' });
                        parent.notify('draw', { prop: 'setDestForStraighten' });
                    }
                    return;
                }
            }
            var isCropSelection = false;
            var splitWords = void 0;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords !== undefined && splitWords[0] === 'crop') {
                isCropSelection = true;
            }
            if (this.currentDrawingShape === 'path' && parent.isShapeDrawing) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var elem = e.srcElement;
                var elemId = elem.parentElement.id;
                var id_1 = parent.element.id;
                // eslint-disable-next-line max-len
                if (e.currentTarget !== parent.upperCanvas && e.currentTarget !== parent.lowerCanvas && parent.activeObj.pointColl.length > 0 &&
                    (elem.classList.contains('e-upload-icon') || elemId === id_1 + '_zoomIn' ||
                        elemId === id_1 + '_zoomOut' || elemId === id_1 + '_annotationBtn' ||
                        elemId === id_1 + '_borderColorBtn' || elemId === id_1 + '_borderWidthBtn')) {
                    parent.notify('shape', { prop: 'stopPathDrawing', onPropertyChange: false, value: { e: e, isApply: true } });
                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                            points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });
                }
                if (parent.currObjType.isDragging && this.isTouch &&
                    parent.activeObj.shape && parent.activeObj.shape === 'path') {
                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                            points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });
                }
                return;
            }
            if (e.currentTarget === parent.upperCanvas && !parent.isResize) {
                this.pathAdjustedIndex = null;
                if (this.currentDrawingShape !== '') {
                    if (this.currentDrawingShape === 'text') {
                        var prevCropObj_1 = extend({}, parent.cropObj, {}, true);
                        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                            value: { operation: 'shapeInsert', previousObj: this.initialPrevObj, previousObjColl: this.initialPrevObj.objColl,
                                previousPointColl: this.initialPrevObj.pointColl, previousSelPointColl: this.initialPrevObj.selPointColl,
                                previousCropObj: prevCropObj_1, previousText: null,
                                currentText: null, previousFilter: null, isCircleCrop: null } });
                    }
                    else {
                        parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: this.initialPrevObj.objColl, operation: 'shapeInsert' } });
                    }
                    this.isShapeInserted = true;
                    this.currentDrawingShape = '';
                    if ((parent.activeObj.shape && parent.activeObj.shape === 'path' && parent.activeObj.pointColl.length === 0) ||
                        ((!parent.activeObj.shape || parent.activeObj.shape !== 'path') && parent.activeObj.activePoint.width === 0 &&
                            parent.activeObj.activePoint.height === 0)) {
                        dummyClick = true;
                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    }
                    var previousShapeSettings = this.updatePrevShapeSettings();
                    var shapeResizingArgs = { cancel: false, action: 'draw-end', previousShapeSettings: previousShapeSettings };
                    var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: previousShapeSettings };
                    this.shapeResizingArgs = shapeResizingArgs;
                    this.shapeMovingArgs = shapeMovingArgs;
                    this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-up');
                }
                if (parent.activeObj.shape && parent.activeObj.shape === 'path' && parent.activeObj.pointColl.length > 0) {
                    parent.activeObj.activePoint = parent.getSquarePointForPath(parent.activeObj);
                }
                this.adjustActObjForLineArrow();
                this.updPtCollForShpRot();
                parent.currObjType.shape = parent.currObjType.shape.toLowerCase();
                var prevCropObj = extend({}, parent.cropObj, {}, true);
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                var prevObj = object['currObj'];
                prevObj.objColl = extend([], parent.objColl, [], true);
                prevObj.pointColl = extend([], parent.pointColl, [], true);
                prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
                var selPointCollObj = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: selPointCollObj } });
                prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
                if (!parent.togglePen && !isCropSelection) {
                    if (this.tempObjColl && parent.activeObj.activePoint.width !== 0) {
                        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                        parent.objColl.push(parent.activeObj);
                        if (JSON.stringify(parent.activeObj.activePoint) !== JSON.stringify(this.tempActiveObj.activePoint)) {
                            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: this.tempObjColl,
                                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                                    previousCropObj: prevCropObj, previousText: null,
                                    currentText: null, previousFilter: null, isCircleCrop: null } });
                        }
                        var tempObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
                        parent.objColl.pop();
                        this.redrawShape(tempObj);
                        this.tempObjColl = undefined;
                    }
                    if (!this.isFhdEditing) {
                        this.applyCurrActObj(x, y);
                        parent.currObjType.isResize = false;
                        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                    }
                }
                else if (isCropSelection && this.isMouseUp && parent.cursor.indexOf('resize') > -1) {
                    var previousShapeSettings = this.updatePrevShapeSettings();
                    var shapeResizingArgs = { cancel: false, action: 'resize-end', previousShapeSettings: previousShapeSettings };
                    this.triggerShapeChange(shapeResizingArgs, shapeResizingArgs, 'resize');
                }
                if (parent.activeObj) {
                    var isCropSelection_1 = false;
                    var splitWords_1;
                    if (parent.activeObj.shape !== undefined) {
                        splitWords_1 = parent.activeObj.shape.split('-');
                    }
                    if (splitWords_1 === undefined && (parent.currObjType.isCustomCrop || parent.togglePen)) {
                        isCropSelection_1 = true;
                    }
                    else if (splitWords_1 !== undefined && splitWords_1[0] === 'crop') {
                        isCropSelection_1 = true;
                    }
                    var shape = parent.activeObj.shape;
                    activeObjShape = shape;
                    var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path'];
                    if (shapeColl.indexOf(shape) > -1) {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (shape === 'text') {
                        if (parent.textArea.style.display === 'none') {
                            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        }
                    }
                    else if (shape === 'redact') {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (this.isFhdEditing) {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (!isCropSelection_1) {
                        var eventargs = { type: 'main', isApplyBtn: null, isCropping: false, isZooming: null };
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
                    }
                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                    if (!this.isFhdEditing) {
                        var width = Math.floor(parent.activeObj.activePoint.width);
                        if (parent.activeObj.shape && parent.activeObj.shape === 'text' &&
                            parent.activeObj.textSettings.fontSize === 11 && Math.floor(parent.activeObj.activePoint.height) === 11 &&
                            (width === 55 || (parent.activeObj.textSettings.bold && width === 58))) {
                            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                            if (parent.drawingShape === 'text' && !parent.activeObj.keyHistory) {
                                parent.activeObj.keyHistory = 'Enter Text';
                            }
                        }
                        if (!isCropSelection_1) {
                            this.adjustActObjForLineArrow();
                            if (parent.isShapeDrawing) {
                                var temp = this.currentDrawingShape;
                                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                                this.currentDrawingShape = temp;
                            }
                            else {
                                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                            }
                        }
                    }
                }
            }
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords !== undefined && splitWords[0] === 'crop') {
                isCropSelection = true;
            }
            if (parent.activeObj.shape && !isCropSelection && e.currentTarget === parent.upperCanvas &&
                parent.textArea.style.display === 'none') {
                if (parent.activeObj.shape === 'text') {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                }
                else if (parent.activeObj.shape === 'redact') {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                }
                else {
                    var temp = this.currentDrawingShape;
                    this.currentDrawingShape = '';
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    this.currentDrawingShape = temp;
                }
                parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
            }
            var obj = { freehandDrawSelectedId: null };
            parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });
            if (parent.togglePen && e.currentTarget === parent.upperCanvas && !obj['freehandDrawSelectedId']) {
                parent.notify('freehand-draw', { prop: 'freehandUpHandler', onPropertyChange: false,
                    value: { e: e, canvas: parent.upperCanvas, context: this.upperContext } });
                if (parent.togglePen && !parent.isMaskImage && (isNullOrUndefined(parent.toolbar) ||
                    (parent.toolbar && parent.toolbar.length > 0) || !isNullOrUndefined(parent.toolbarTemplate))) {
                    parent.okBtn();
                    parent.freeHandDraw(true);
                }
            }
            else {
                parent.currObjType.shape = '';
            }
            this.dragElement = '';
            this.mouseDown = '';
            this.isSliderActive = false;
            parent.currObjType.isInitialLine = parent.currObjType.isDragging = false;
            this.selMouseUpEvent();
            if (isNullOrUndefined(parent.drawingShape) && activeObjShape && currentDrawingShape !== '') {
                parent.drawingShape = activeObjShape;
            }
            if (parent.drawingShape) {
                this.currentDrawingShape = parent.drawingShape.toLowerCase();
                if (dummyClick) {
                    parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
                    parent.upperCanvas.style.cursor = 'crosshair';
                }
            }
            parent.isShapeDrawing = false;
            parent.notify('freehand-draw', { prop: 'resetSelPoints', onPropertyChange: false });
        }
        this.isMouseUp = false;
    };
    Selection.prototype.adjustActObjForLineArrow = function (obj) {
        var isAdjusted = false;
        var parent = this.parent;
        obj = obj ? obj : parent.activeObj;
        if (obj.shape && (obj.shape === 'line' || parent.activeObj.shape === 'arrow')) {
            var temp = void 0;
            if ((this.dragElement === 'e-resize' && obj.activePoint.endX < obj.activePoint.startX) ||
                (this.dragElement === 'w-resize' && obj.activePoint.startX > obj.activePoint.endX)) {
                isAdjusted = true;
                temp = obj.activePoint.startX;
                obj.activePoint.startX = obj.activePoint.endX;
                obj.activePoint.endX = temp;
                temp = obj.activePoint.startY;
                obj.activePoint.startY = obj.activePoint.endY;
                obj.activePoint.endY = temp;
            }
            obj.activePoint.width = Math.abs(obj.activePoint.endX - obj.activePoint.startX);
            obj.activePoint.height = Math.abs(obj.activePoint.endY - obj.activePoint.startY);
            if (parent.activeObj.shape !== 'path') {
                parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,
                    value: { obj: obj } });
                for (var i = 0; i < obj.pointColl.length; i++) {
                    obj.pointColl[i].ratioX = (obj.pointColl[i].x -
                        parent.img.destLeft) / parent.img.destWidth;
                    obj.pointColl[i].ratioY = (obj.pointColl[i].y -
                        parent.img.destTop) / parent.img.destHeight;
                }
            }
        }
        return isAdjusted;
    };
    Selection.prototype.updPtCollForShpRot = function (obj) {
        var parent = this.parent;
        obj = obj ? obj : parent.activeObj;
        if (obj.shape && obj.rotatedAngle !== 0) {
            parent.notify('shape', { prop: 'setPointCollForShapeRotation', onPropertyChange: false, value: { obj: obj } });
            var _a = parent.img, destLeft_1 = _a.destLeft, destTop_1 = _a.destTop, destWidth_1 = _a.destWidth, destHeight_1 = _a.destHeight;
            var horTopLinePointColl = obj.horTopLinePointColl, horBottomLinePointColl = obj.horBottomLinePointColl, verLeftLinePointColl = obj.verLeftLinePointColl, verRightLinePointColl = obj.verRightLinePointColl;
            // eslint-disable-next-line @typescript-eslint/tslint/config
            var setRatio = function (point) {
                point.ratioX = (point.x - destLeft_1) / destWidth_1;
                point.ratioY = (point.y - destTop_1) / destHeight_1;
            };
            horTopLinePointColl.forEach(setRatio);
            horBottomLinePointColl.forEach(setRatio);
            verLeftLinePointColl.forEach(setRatio);
            verRightLinePointColl.forEach(setRatio);
        }
    };
    Selection.prototype.setXYPoints = function (e) {
        e.preventDefault();
        var x;
        var y;
        if (e.type === 'mousedown') {
            x = e.clientX;
            y = e.clientY;
        }
        else {
            this.touchEndPoint.x = x = e.touches[0].clientX;
            this.touchEndPoint.y = y = e.touches[0].clientY;
        }
        var bbox = this.parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        return { x: x, y: y };
    };
    Selection.prototype.getCurrentIndex = function () {
        var index;
        var parent = this.parent;
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.activeObj.currIndex === parent.objColl[i].currIndex) {
                index = i;
                break;
            }
        }
        return index;
    };
    Selection.prototype.isShapeClick = function (e, isCropSelection) {
        var parent = this.parent;
        var isShape = false;
        if (parent.togglePen) {
            return isShape;
        }
        if (parent.activeObj.shape && parent.activeObj.shape === 'text' && this.isShapeInserted) {
            var isTextArea = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')
                ? true : false;
            var activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            var points = this.setXYPoints(e);
            var x = points.x;
            var y = points.y;
            isShape = this.findTargetObj(x, y, isCropSelection);
            if (!isCropSelection) {
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                if (isShape) {
                    parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                        value: { x: null, y: null, isMouseDown: true } });
                }
            }
            if (isTextArea) {
                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
                parent.textArea.style.display = 'block';
                parent.activeObj = activeObj;
                var index = this.getCurrentIndex();
                if (isNullOrUndefined(index)) {
                    parent.objColl.pop();
                }
                else {
                    parent.objColl.splice(index, 1);
                }
            }
            else if (!isShape && activeObj.shape) {
                parent.activeObj = activeObj;
                var index = this.getCurrentIndex();
                if ((!isNullOrUndefined(index) &&
                    JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint))) {
                    parent.objColl.splice(index, 1);
                }
                else if (isNullOrUndefined(parent.activeObj.currIndex)) {
                    parent.objColl.pop();
                }
            }
        }
        return isShape;
    };
    Selection.prototype.isShapeTouch = function (e, isCropSelection) {
        var parent = this.parent;
        var isShape = false;
        if (e.type === 'touchstart' && !parent.togglePen) {
            if (parent.activeObj && parent.activeObj.shape === 'text') {
                this.timer = setTimeout(this.setTimer.bind(this), 1000, e);
            }
            var isTextArea = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')
                ? true : false;
            var activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            var points = this.setXYPoints(e);
            var x = points.x;
            var y = points.y;
            isShape = this.findTargetObj(x, y, isCropSelection);
            if (!isCropSelection) {
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            if (isTextArea) {
                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
                parent.textArea.style.display = 'block';
                parent.activeObj = activeObj;
                var index = this.getCurrentIndex();
                if (isNullOrUndefined(index)) {
                    parent.objColl.pop();
                }
                else {
                    parent.objColl.splice(index, 1);
                }
            }
            else if (!isShape && activeObj.shape && (activeObj.activePoint.width !== 0 || activeObj.activePoint.height !== 0 ||
                (activeObj.shape === 'path' && activeObj.pointColl.length > 0))) {
                parent.activeObj = activeObj;
                var index = this.getCurrentIndex();
                if (!isCropSelection) {
                    if ((!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) ===
                        JSON.stringify(parent.objColl[index].activePoint))) {
                        parent.objColl.splice(index, 1);
                    }
                    else if (isNullOrUndefined(parent.activeObj.currIndex)) {
                        parent.objColl.pop();
                    }
                }
            }
        }
        return isShape;
    };
    Selection.prototype.isFreehandDrawTouch = function (e, isCropSelection) {
        var parent = this.parent;
        var isFreehandDraw = false;
        if (e.type === 'touchstart' && !isCropSelection && !parent.togglePen) {
            var isTextArea = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')
                ? true : false;
            var activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            var points = this.setXYPoints(e);
            var x = points.x;
            var y = points.y;
            this.setCursor(x, y);
            if (this.isFhdPoint) {
                isFreehandDraw = true;
            }
            if (isTextArea) {
                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
                parent.textArea.style.display = 'block';
                parent.activeObj = activeObj;
                var index = this.getCurrentIndex();
                if (isNullOrUndefined(index)) {
                    parent.objColl.pop();
                }
                else {
                    parent.objColl.splice(index, 1);
                }
            }
            else if (activeObj.shape) {
                parent.activeObj = activeObj;
                var index = this.getCurrentIndex();
                if (!isCropSelection) {
                    if ((!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) ===
                        JSON.stringify(parent.objColl[index].activePoint))) {
                        parent.objColl.splice(index, 1);
                    }
                    else if (isNullOrUndefined(parent.activeObj.currIndex)) {
                        parent.objColl.pop();
                    }
                }
            }
        }
        return isFreehandDraw;
    };
    Selection.prototype.applyObj = function (x, y) {
        var parent = this.parent;
        var isApply = false;
        if (parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) {
            return false;
        }
        var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'image', 'text'];
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        if (parent.activeObj.shape && shapeColl.indexOf(parent.activeObj.shape) > -1) {
            var radius = parent.activeObj.topLeftCircle.radius;
            if (x >= (startX - (radius * 2)) && x <= (endX + (radius * 2)) && y >= (startY - (radius * 2)) &&
                y <= (endY + (radius * 2))) {
                isApply = false;
            }
            else if (parent.upperCanvas.style.cursor !== 'default' && parent.upperCanvas.style.cursor !== 'grab' &&
                parent.upperCanvas.style.cursor !== 'crosshair' && parent.upperCanvas.style.cursor !== 'pointer' &&
                parent.upperCanvas.style.cursor !== 'move') {
                isApply = false;
            }
            else {
                isApply = true;
            }
        }
        return isApply;
    };
    Selection.prototype.applyCurrShape = function (isShapeClick) {
        var parent = this.parent;
        var isApply = false;
        if (parent.togglePen) {
            return isApply;
        }
        var obj = extend({}, parent.activeObj, null, true);
        if (this.isShapeInserted && parent.activeObj.shape === 'text' && isShapeClick) {
            this.isInitialTextEdited = true;
            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: true } });
        }
        if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
            var activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            obj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
            parent.objColl.pop();
            parent.activeObj = extend({}, activeObj, null, true);
            parent.textArea.value = obj.keyHistory;
            parent.textArea.style.display = 'block';
            var strokeColor = obj.strokeSettings && obj.strokeSettings.strokeColor ? obj.strokeSettings.strokeColor.split('(')[0] === 'rgb' ?
                this.rgbToHex(parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[0]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[1]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[2]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[3])) :
                obj.strokeSettings.strokeColor : null;
            if (strokeColor && strokeColor === '#ffffff') {
                strokeColor = '#fff';
            }
            if (this.tempActiveObj.strokeSettings && this.tempActiveObj.strokeSettings.strokeColor &&
                this.tempActiveObj.strokeSettings.strokeColor === '#ffffff') {
                this.tempActiveObj.strokeSettings.strokeColor = '#fff';
            }
            if (obj.keyHistory !== this.tempActiveObj.keyHistory ||
                (strokeColor && (strokeColor !== this.tempActiveObj.strokeSettings.strokeColor)) ||
                (obj.textSettings && obj.textSettings.fontFamily !== this.tempActiveObj.textSettings.fontFamily) ||
                (obj.textSettings && Math.round(obj.textSettings.fontSize) !== Math.round(this.tempActiveObj.textSettings.fontSize)) ||
                (obj.textSettings && Math.round(obj.textSettings.fontRatio) !== Math.round(this.tempActiveObj.textSettings.fontRatio)) ||
                (obj.textSettings && obj.textSettings.bold !== this.tempActiveObj.textSettings.bold) ||
                (obj.textSettings && obj.textSettings.italic !== this.tempActiveObj.textSettings.italic) ||
                (obj.textSettings && obj.textSettings.underline !== this.tempActiveObj.textSettings.underline)) {
                isApply = true;
            }
            if (this.isInitialTextEdited && !isApply) {
                isApply = true;
                this.isInitialTextEdited = false;
            }
        }
        else {
            this.tempActiveObj.activePoint.height = Math.abs(this.tempActiveObj.activePoint.height);
            isApply = JSON.stringify(obj) !== JSON.stringify(this.tempActiveObj);
        }
        return isApply;
    };
    Selection.prototype.canvasMouseDownHandler = function (e) {
        var parent = this.parent;
        e.preventDefault();
        var x;
        var y;
        if (e.type === 'mousedown') {
            x = e.offsetX || (e.pageX - parent.lowerCanvas.offsetLeft);
            y = e.offsetY || (e.pageY - parent.lowerCanvas.offsetTop);
        }
        else {
            x = e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft);
            y = e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop);
        }
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        this.panDown = { x: x, y: y };
        var tempPanMoveObj = { tempPanMove: null };
        parent.notify('transform', { prop: 'getTempPanMove', onPropertyChange: false,
            value: { obj: tempPanMoveObj } });
        if (isNullOrUndefined(tempPanMoveObj['tempPanMove'])) {
            parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
                value: { point: { x: x, y: y } } });
        }
    };
    Selection.prototype.canvasMouseMoveHandler = function (e) {
        var parent = this.parent;
        var frameObject = { bool: null };
        parent.notify('toolbar', { prop: 'getFrameToolbar', onPropertyChange: false, value: { obj: frameObject } });
        if (parent.isResize || frameObject['bool']) {
            parent.upperCanvas.style.cursor = 'default';
            return;
        }
        if (this.dragCanvas) {
            parent.lowerCanvas.style.cursor = 'grab';
        }
        else {
            this.dragCanvas = parent.togglePan = false;
            parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'default';
        }
        var x;
        var y;
        if (e.type === 'mousemove') {
            x = e.offsetX;
            y = e.offsetY;
        }
        else {
            x = e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft);
            y = e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop);
        }
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        var panMove = { x: x, y: y };
        parent.notify('transform', { prop: 'setPanMove', onPropertyChange: false,
            value: { point: { x: x, y: y } } });
        if (this.panDown && panMove && parent.togglePan && this.dragCanvas) {
            if (parent.isCropTab || parent.activeObj.shape) {
                parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
            }
            parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,
                value: { xDiff: null, yDiff: null } });
        }
    };
    Selection.prototype.canvasMouseUpHandler = function (e) {
        var parent = this.parent;
        e.preventDefault();
        var panMoveObj = { panMove: null };
        parent.notify('transform', { prop: 'getPanMove', onPropertyChange: false,
            value: { obj: panMoveObj } });
        if (parent.togglePan) {
            if (this.panDown && panMoveObj['panMove'] && parent.togglePan && this.dragCanvas) {
                this.panDown = null;
                parent.notify('transform', { prop: 'setPanMove', onPropertyChange: false,
                    value: { point: null } });
            }
        }
        parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
            value: { point: null } });
        if (this.currentDrawingShape !== 'path') {
            parent.currObjType.isDragging = false;
        }
    };
    Selection.prototype.touchStartHandler = function (e) {
        e.preventDefault();
        var parent = this.parent;
        if (this.touchTime === 0) {
            this.touchTime = new Date().getTime();
        }
        else {
            if (((new Date().getTime()) - this.touchTime) < 400) {
                this.isTouchDblClick = true;
                var temp = parent.isShapeDrawing;
                parent.notify('shape', { prop: 'stopPathDrawing', onPropertyChange: false, value: { e: e, isApply: null } });
                this.isTouchDblClick = false;
                this.touchTime = 0;
                if (temp !== parent.isShapeDrawing && parent.activeObj.shape &&
                    parent.activeObj.shape === 'path') {
                    return;
                }
            }
            else {
                this.touchTime = new Date().getTime();
            }
        }
        if (e.touches.length === 2) {
            this.isFirstMove = true;
        }
        else {
            this.mouseDownEventHandler(e);
        }
        EventHandler.add(parent.lowerCanvas, 'touchend', this.mouseUpEventHandler, this);
        EventHandler.add(parent.lowerCanvas, 'touchmove', this.mouseMoveEventHandler, this);
        EventHandler.add(parent.upperCanvas, 'touchend', this.mouseUpEventHandler, this);
        EventHandler.add(parent.upperCanvas, 'touchmove', this.mouseMoveEventHandler, this);
    };
    Selection.prototype.unwireEvent = function () {
        var parent = this.parent;
        EventHandler.remove(parent.lowerCanvas, 'touchend', this.mouseUpEventHandler);
        EventHandler.remove(parent.lowerCanvas, 'touchmove', this.mouseMoveEventHandler);
        EventHandler.remove(parent.upperCanvas, 'touchend', this.mouseUpEventHandler);
        EventHandler.remove(parent.upperCanvas, 'touchmove', this.mouseMoveEventHandler);
    };
    Selection.prototype.keyDownEventHandler = function (e) {
        var parent = this.parent;
        if (e.ctrlKey && (e.key === '+' || e.key === '-')) {
            e.preventDefault();
        }
        var obj = { fileName: '', fileType: null };
        parent.notify('draw', { prop: 'getFileName', onPropertyChange: false, value: { obj: obj } });
        var beforeSave = { fileName: obj['fileName'], fileType: obj['fileType'], cancel: false };
        switch (e.key) {
            case (e.ctrlKey && 's'):
                parent.trigger('beforeSave', beforeSave);
                this.beforeSaveEvent(beforeSave, e);
                break;
            case (e.ctrlKey && 'z'):
                if (parent.allowUndoRedo) {
                    parent.noPushUndo = false;
                    if (parent.togglePen || parent.drawingShape) {
                        parent.okBtn();
                        parent.drawingShape = null;
                    }
                    parent.notify('undo-redo', { prop: 'call-undo' });
                }
                break;
            case (e.ctrlKey && 'y'):
                if (parent.allowUndoRedo) {
                    parent.noPushUndo = false;
                    if (parent.togglePen || parent.drawingShape) {
                        parent.okBtn();
                        parent.drawingShape = null;
                    }
                    parent.notify('undo-redo', { prop: 'call-redo' });
                }
                break;
            case (e.ctrlKey && '+'):
                if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
                    this.zoomType = 'Commands';
                    parent.isZoomBtnClick = true;
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: .1, zoomPoint: null }, isResize: null });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    if (parent.isCropTab || parent.activeObj.shape) {
                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
                    }
                    if (parent.isStraightening) {
                        parent.notify('draw', { prop: 'resetStraightenDestPoints' });
                        parent.notify('draw', { prop: 'setDestForStraighten' });
                    }
                }
                break;
            case (e.ctrlKey && '-'):
                if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
                    this.zoomType = 'Commands';
                    parent.isZoomBtnClick = true;
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: -.1, zoomPoint: null }, isResize: null });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    if (parent.isCropTab || parent.activeObj.shape) {
                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
                    }
                    if (parent.isStraightening) {
                        parent.notify('draw', { prop: 'resetStraightenDestPoints' });
                        parent.notify('draw', { prop: 'setDestForStraighten' });
                    }
                }
                break;
            case 'Delete':
                this.deleteItem();
                break;
            case 'Escape':
                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null, isFinalCancel: true } });
                break;
            case 'Enter':
                this.performEnterAction(e);
                break;
            case 'Tab':
                this.performTabAction();
                break;
            default:
                if (Browser.isDevice && (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')) {
                    setTimeout(this.textKeyDown.bind(this), 1, e);
                }
                break;
        }
    };
    Selection.prototype.performEnterAction = function (e) {
        var parent = this.parent;
        if (parent.isResize) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var target = e.target;
            var isIcon = target.id.indexOf('aspectratio') ||
                target.id.indexOf('non-aspectratio') > -1 ? true : false;
            var isValue = this.isValueUpdated();
            if (!isValue) {
                if (isIcon) {
                    this.focusRatioBtn();
                }
                return;
            }
            var point = this.getNumTextValue();
            var aspectRatioElement = parent.element.querySelector('#' + parent.element.id + '_aspectratio');
            var blrAspRatElem = parent.element.querySelector('.e-ie-toolbar-aspect-ratio-btn');
            if (point && point.x && point.y) {
                if (aspectRatioElement || (blrAspRatElem && !blrAspRatElem.classList.contains('e-hidden'))) {
                    parent.notify('transform', { prop: 'resize', value: { width: point.x, height: null, isAspectRatio: true } });
                }
                else {
                    parent.notify('transform', { prop: 'resize', value: { width: point.x, height: point.y, isAspectRatio: false } });
                }
            }
            var aspectRatioHeight = parent.element.querySelector('#' + parent.element.id + '_resizeHeight');
            var aspectRatioWidth = parent.element.querySelector('#' + parent.element.id + '_resizeWidth');
            if (isNullOrUndefined(aspectRatioElement)) {
                if (aspectRatioHeight) {
                    var elem = getComponent(aspectRatioHeight, 'numerictextbox');
                    if (aspectRatioHeight && aspectRatioHeight.value === '') {
                        elem.value = parseFloat(elem.placeholder);
                        aspectRatioHeight.value = elem.placeholder + 'px';
                    }
                }
                if (aspectRatioWidth) {
                    var elem = getComponent(aspectRatioWidth, 'numerictextbox');
                    if (aspectRatioWidth && aspectRatioWidth.value === '') {
                        elem.value = parseFloat(elem.placeholder);
                        aspectRatioWidth.value = elem.placeholder + 'px';
                    }
                }
            }
            parent.notify('draw', { prop: 'redrawDownScale' });
            if (isIcon) {
                this.focusRatioBtn();
            }
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        }
        else if (e.target.classList.contains('e-upload')) {
            var upload = parent.element.querySelector('.e-image-upload');
            if (upload && upload.querySelector('.e-tbar-btn')) {
                upload.querySelector('.e-tbar-btn').click();
            }
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        }
        else if (e.target.classList.contains('filter-wrapper')) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            e.target.parentElement.click();
        }
        else {
            var splitWords = void 0;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (e && this.isKeyBoardCrop(e) &&
                parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] === 'crop')) {
                parent.crop();
            }
        }
    };
    Selection.prototype.focusRatioBtn = function () {
        var id = this.parent.element.id;
        if (this.parent.isKBDNavigation) {
            // eslint-disable-next-line @typescript-eslint/tslint/config
            setTimeout(function () {
                if (document.getElementById(id + '_aspectratio')) {
                    document.getElementById(id + '_aspectratio').focus();
                }
                else if (document.getElementById(id + '_nonaspectratio')) {
                    document.getElementById(id + '_nonaspectratio').focus();
                }
            }, 50);
        }
    };
    Selection.prototype.isKeyBoardCrop = function (e) {
        var bool = false;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var target = e.target;
        if (target.id === this.parent.element.id + '_ok' || target.id === '') {
            bool = true;
        }
        return bool;
    };
    Selection.prototype.beforeSaveEvent = function (observableSaveArgs, e) {
        var parent = this.parent;
        if (!observableSaveArgs.cancel) {
            parent.notify('export', { prop: 'export', onPropertyChange: false,
                value: { type: observableSaveArgs.fileType, fileName: observableSaveArgs.fileName } });
        }
        e.preventDefault();
        e.stopImmediatePropagation();
    };
    Selection.prototype.handleScroll = function (e) {
        this.mouseWheel++;
        var parent = this.parent;
        var x;
        var y;
        var isInsideCanvas = false;
        if (e.type === 'mousewheel') {
            // eslint-disable-next-line
            x = e.clientX;
            y = e.clientY;
        }
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        if (x > parent.img.destLeft && x < parent.img.destLeft + parent.img.destWidth && y > parent.img.destTop &&
            y < parent.img.destTop + parent.img.destHeight) {
            isInsideCanvas = true;
        }
        if (this.mouseWheel === 2) {
            this.mouseWheel = 0;
            if (e.ctrlKey === true && isInsideCanvas) {
                e.preventDefault();
            }
            return;
        }
        e.stopPropagation();
        if (e.ctrlKey === true && isInsideCanvas) {
            e.preventDefault();
            if (!parent.isCropTab && (parent.activeObj.shape && parent.activeObj.shape.split('-')[0] !== 'crop')) {
                parent.okBtn(null, true);
                parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
            }
            var type = '';
            if (e.type === 'mousewheel' && (parent.zoomSettings.zoomTrigger & ZoomTrigger.MouseWheel) === ZoomTrigger.MouseWheel) {
                this.zoomType = 'MouseWheel';
                // eslint-disable-next-line
                if (e.wheelDelta > 0) {
                    type = 'zoomIn';
                }
                else {
                    type = 'zoomOut';
                }
            }
            if (type !== '') {
                parent.isZoomBtnClick = true;
                parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                    value: { x: x, y: y, type: type, isResize: null } });
                parent.notify('draw', { prop: 'redrawDownScale' });
                if (parent.isCropTab || parent.activeObj.shape) {
                    parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                    parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });
                }
                if (parent.isStraightening) {
                    parent.notify('draw', { prop: 'resetStraightenDestPoints' });
                    parent.notify('draw', { prop: 'setDestForStraighten' });
                }
            }
        }
    };
    Selection.prototype.textKeyDown = function (e) {
        var parent = this.parent;
        if (parent.activeObj.rotatedAngle !== 0) {
            return;
        }
        if (String.fromCharCode(e.which) === '\r') {
            this.textRow += 1;
        }
        parent.textArea.setAttribute('rows', this.textRow.toString());
        parent.textArea.style.height = 'auto';
        parent.textArea.style.height = parent.textArea.scrollHeight + 'px';
        parent.notify('shape', { prop: 'setTextBoxWidth', onPropertyChange: false, value: { e: e } });
        if (Browser.isDevice) {
            parent.textArea.style.width = parseFloat(parent.textArea.style.width) + parent.textArea.style.fontSize + 'px';
        }
        var rows = parent.textArea.value.split('\n');
        this.textRow = rows.length;
        parent.textArea.setAttribute('rows', this.textRow.toString());
        this.isInitialTextEdited = false;
    };
    Selection.prototype.clearSelection = function (resetCrop) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (resetCrop) {
                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
            }
            else {
                parent.togglePen = false;
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.dragElement = '';
                this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
                parent.currObjType.shape = '';
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.currObjType.isActiveObj = true;
                parent.currObjType.isCustomCrop = false;
                parent.upperCanvas.style.cursor = parent.cursor = 'default';
            }
        }
    };
    Selection.prototype.setDragDirection = function (width, height) {
        var arcRadius = (7.5);
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        if (parent.img.destWidth > parent.img.destHeight) {
            actPoint.startX = this.dragPoint.startX = ((width / 2) - (height / 2)) + arcRadius;
            actPoint.startY = this.dragPoint.startY = ((height / 2) - (height / 2)) + arcRadius;
            actPoint.endX = ((width / 2) + (height / 2)) - arcRadius;
            actPoint.endY = ((height / 2) + (height / 2)) - arcRadius;
        }
        else {
            actPoint.startY = this.dragPoint.startX = ((height / 2) - (width) / 2) + arcRadius;
            actPoint.endY = ((height / 2) + (width) / 2) - arcRadius;
            actPoint.startX = this.dragPoint.startX = arcRadius;
            actPoint.endX = width - arcRadius;
        }
    };
    Selection.prototype.calcShapeRatio = function (x, y, imgWidth, imgHeight) {
        var parent = this.parent;
        var actPoint = parent.activeObj.activePoint;
        var arcRadius = (7.5);
        var presetRatio = x / y;
        var originalWidth = imgWidth;
        var originalHeight = imgHeight;
        var standardSize = originalWidth >= originalHeight ? originalWidth : originalHeight;
        var width = standardSize * presetRatio;
        var height = standardSize;
        var scaleWidth = this.getScale(width, originalWidth);
        var snippetArray = [];
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        for (var i = 0; i < 2; i++) {
            if (i === 0) {
                snippetArray.push(width * scaleWidth);
            }
            else {
                snippetArray.push(height * scaleWidth);
            }
        }
        width = snippetArray[0];
        height = snippetArray[1];
        var scaleHeight = this.getScale(height, originalHeight);
        var snippetArray1 = [];
        for (var i = 0; i < 2; i++) {
            if (i === 0) {
                snippetArray1.push(width * scaleHeight);
            }
            else {
                snippetArray1.push(height * scaleHeight);
            }
        }
        width = snippetArray1[0];
        height = snippetArray1[1];
        actPoint.width = width;
        actPoint.height = height;
        actPoint.startX = (this.dragPoint.startX = (originalWidth - width) / 2) + arcRadius;
        actPoint.startY = (this.dragPoint.startY = (originalHeight - height) / 2) + arcRadius;
        actPoint.endX = actPoint.startX + actPoint.width;
        actPoint.endY = actPoint.startY + actPoint.height;
        if (actPoint.startX < destLeft && destLeft + destWidth > parent.lowerCanvas.clientWidth) {
            actPoint.startX = destLeft;
            actPoint.endX = actPoint.startX + width - arcRadius;
        }
        if (actPoint.startY < destTop && destTop + destHeight > parent.lowerCanvas.clientHeight) {
            actPoint.startY = destTop;
            actPoint.endY = actPoint.startY + height - arcRadius;
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
    };
    Selection.prototype.getScale = function (value, originalValue) {
        return value > originalValue ? originalValue / value : 1;
    };
    Selection.prototype.findTarget = function (x, y, type) {
        var parent = this.parent;
        if (type.toLowerCase() === 'mousedown' || type.toLowerCase() === 'touchstart') {
            var splitWords = void 0;
            var isCrop = false;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
                if (splitWords[0] === 'crop') {
                    isCrop = true;
                }
            }
            this.findTargetObj(x, y, isCrop);
            this.updateCursorStyles(x, y, type);
        }
        else {
            var _a = parent.activeObj, topLeftCircle = _a.topLeftCircle, topCenterCircle = _a.topCenterCircle, topRightCircle = _a.topRightCircle, centerLeftCircle = _a.centerLeftCircle, centerRightCircle = _a.centerRightCircle, bottomLeftCircle = _a.bottomLeftCircle, bottomCenterCircle = _a.bottomCenterCircle, bottomRightCircle = _a.bottomRightCircle;
            switch (this.dragElement.toLowerCase()) {
                case 'nw-resize':
                    topLeftCircle.startX = x;
                    topLeftCircle.startY = y;
                    break;
                case 'n-resize':
                    topCenterCircle.startX = x;
                    topCenterCircle.startY = y;
                    break;
                case 'ne-resize':
                    topRightCircle.startX = x;
                    topRightCircle.startY = y;
                    break;
                case 'w-resize':
                    centerLeftCircle.startX = x;
                    centerLeftCircle.startY = y;
                    break;
                case 'e-resize':
                    centerRightCircle.startX = x;
                    centerRightCircle.startY = y;
                    break;
                case 'sw-resize':
                    bottomLeftCircle.startX = x;
                    bottomLeftCircle.startY = y;
                    break;
                case 's-resize':
                    bottomCenterCircle.startX = x;
                    bottomCenterCircle.startY = y;
                    break;
                case 'se-resize':
                    bottomRightCircle.startX = x;
                    bottomRightCircle.startY = y;
                    break;
                default:
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    break;
            }
        }
    };
    Selection.prototype.findTargetObj = function (x, y, isCrop) {
        var parent = this.parent;
        var isShape = false;
        if (parent.objColl.length !== 0 && !parent.currObjType.isCustomCrop && !isCrop) {
            var prevIndex = 0;
            var i = void 0;
            for (var index = 0; index < parent.objColl.length; index++) {
                var cursor = parent.upperCanvas.style.cursor;
                this.setCursor(x, y);
                var actObj = extend({}, parent.objColl[index], {}, true);
                var radius = actObj.topLeftCircle.radius;
                if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                    for (var j = 0; j < actObj.pointColl.length; j++) {
                        if (x >= actObj.pointColl[j].x - (radius * 2) &&
                            x <= actObj.pointColl[j].x + (radius * 2) &&
                            y >= actObj.pointColl[j].y - (radius * 2) &&
                            y <= actObj.pointColl[j].y + (radius * 2)) {
                            if (this.tempActiveObj && this.tempActiveObj.activePoint &&
                                JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                                i = index;
                                break;
                            }
                            else {
                                if (this.isTouch || parent.cursor === 'move' ||
                                    parent.cursor === 'grab' || this.isShapeInserted) {
                                    if (prevIndex === 0 || prevIndex < actObj.order) {
                                        prevIndex = actObj.order;
                                        i = index;
                                    }
                                }
                                else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                                    i = index;
                                }
                            }
                            break;
                        }
                    }
                }
                else if (actObj.shape === 'path') {
                    var cursor_3 = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
                    if (cursor_3 !== 'default' && cursor_3 !== 'grab') {
                        if (this.tempActiveObj && this.tempActiveObj.activePoint &&
                            JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                            i = index;
                            break;
                        }
                        else {
                            if (this.isTouch || parent.cursor === 'move' || parent.cursor === 'grab' || this.isShapeInserted) {
                                if (prevIndex === 0 || prevIndex < actObj.order) {
                                    prevIndex = actObj.order;
                                    i = index;
                                }
                            }
                            else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                                i = index;
                            }
                        }
                    }
                }
                else if (actObj.rotatedAngle !== 0) {
                    var cursor_4 = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
                    if (cursor_4 !== 'default' && cursor_4 !== 'grab') {
                        if (this.tempActiveObj && this.tempActiveObj.activePoint &&
                            JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                            i = index;
                            break;
                        }
                        else {
                            if (this.isTouch || parent.cursor === 'move' || parent.cursor === 'grab' || this.isShapeInserted) {
                                if (prevIndex === 0 || (prevIndex < actObj.order && (actObj.shape !== 'redact' || parent.drawingShape === 'redact'))) {
                                    prevIndex = actObj.order;
                                    i = index;
                                }
                            }
                            else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                                i = index;
                            }
                        }
                    }
                }
                else {
                    var rotationCirclePoint = this.getTransRotationPoint(actObj);
                    if ((x >= (actObj.activePoint.startX - (radius * 2)) &&
                        x <= (actObj.activePoint.endX + (radius * 2)) &&
                        y >= (actObj.activePoint.startY - (radius * 2)) &&
                        y <= (actObj.activePoint.endY + (radius * 2))) ||
                        (rotationCirclePoint &&
                            x >= (rotationCirclePoint.x - (radius * 2)) &&
                            x <= (rotationCirclePoint.x + (radius * 2)) &&
                            y >= (rotationCirclePoint.y - (radius * 2)) &&
                            y <= (rotationCirclePoint.y + (radius * 2)))) {
                        if (this.tempActiveObj && this.tempActiveObj.activePoint &&
                            JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                            i = index;
                            break;
                        }
                        else {
                            if (this.isTouch || cursor === 'move' || cursor === 'grabbing' || this.isShapeInserted
                                || parent.cursor === 'move' || parent.cursor === 'grabbing') {
                                if (prevIndex === 0 || (prevIndex < actObj.order && (actObj.shape !== 'redact' || parent.drawingShape === 'redact'))) {
                                    prevIndex = actObj.order;
                                    i = index;
                                }
                            }
                            else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                                i = index;
                            }
                        }
                    }
                }
            }
            if (isNullOrUndefined(i)) {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                isShape = false;
            }
            else {
                this.tempObjColl = extend([], parent.objColl, [], true);
                parent.currObjType.isCustomCrop = false;
                parent.activeObj = extend({}, parent.objColl[i], {}, true);
                var temp = extend({}, parent.objColl[i], {}, true);
                parent.objColl.splice(i, 1);
                if (parent.transform.degree === 0) {
                    var temp_1 = this.lowerContext.filter;
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
                    this.lowerContext.filter = 'none';
                    parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                        value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
                    parent.activeObj = extend({}, temp_1, {}, true);
                    this.lowerContext.filter = temp_1;
                    this.getCurrentFlipState();
                }
                else {
                    var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
                    var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                        height: parent.img.destHeight };
                    parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
                    parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
                    parent.img.destLeft = destPoints.startX;
                    parent.img.destTop = destPoints.startY;
                    parent.img.destWidth = destPoints.width;
                    parent.img.destHeight = destPoints.height;
                    parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                        value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
                }
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                parent.activeObj = extend({}, temp, {}, true);
                this.setActivePoint();
                parent.activeObj = extend({}, temp, {}, true);
                var tempStrokeSettings = extend({}, parent.activeObj.strokeSettings, {}, true);
                parent.notify('draw', { prop: 'setTempStrokeSettings', onPropertyChange: false,
                    value: { tempStrokeSettings: tempStrokeSettings } });
                var tempTextSettings = extend({}, parent.activeObj.textSettings, {}, true);
                parent.notify('draw', { prop: 'setTempTextSettings', onPropertyChange: false, value: { tempTextSettings: tempTextSettings } });
                var shapeSettings = this.updatePrevShapeSettings();
                var shapeChangingArgs = { cancel: false, action: 'select', previousShapeSettings: shapeSettings,
                    currentShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow') {
                    shapeChangingArgs.currentShapeSettings.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                    shapeChangingArgs.currentShapeSettings.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
                }
                this.isCropSelection = false;
                var splitWords = void 0;
                if (parent.activeObj.shape !== undefined) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (splitWords !== undefined && splitWords[0] === 'crop') {
                    this.isCropSelection = true;
                }
                if (!this.isCropSelection && parent.activeObj.shape !== 'redact') {
                    parent.trigger('shapeChanging', shapeChangingArgs);
                    this.shapeEvent(shapeChangingArgs);
                    parent.editCompleteArgs = shapeChangingArgs;
                }
                else {
                    if (this.isMouseDown) {
                        shapeChangingArgs.action = 'resize-start';
                    }
                    else if (this.isMouseUp) {
                        shapeChangingArgs.action = 'resize-end';
                    }
                    var selectionChangingArgs = { action: shapeChangingArgs.action,
                        previousSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                            startX: shapeChangingArgs.previousShapeSettings.startX,
                            startY: shapeChangingArgs.previousShapeSettings.startY,
                            width: shapeChangingArgs.previousShapeSettings.width,
                            height: shapeChangingArgs.previousShapeSettings.height },
                        currentSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                            startX: shapeChangingArgs.currentShapeSettings.startX,
                            startY: shapeChangingArgs.currentShapeSettings.startY,
                            width: shapeChangingArgs.currentShapeSettings.width,
                            height: shapeChangingArgs.currentShapeSettings.height } };
                    parent.trigger('selectionChanging', selectionChangingArgs);
                    parent.editCompleteArgs = selectionChangingArgs;
                    shapeChangingArgs.currentShapeSettings.startX = selectionChangingArgs.currentSelectionSettings.startX;
                    shapeChangingArgs.currentShapeSettings.startY = selectionChangingArgs.currentSelectionSettings.startY;
                    shapeChangingArgs.currentShapeSettings.width = selectionChangingArgs.currentSelectionSettings.width;
                    shapeChangingArgs.currentShapeSettings.height = selectionChangingArgs.currentSelectionSettings.height;
                    this.shapeEvent(shapeChangingArgs);
                }
                isShape = true;
            }
        }
        return isShape;
    };
    Selection.prototype.shapeEvent = function (shapeChangingArgs) {
        var parent = this.parent;
        parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
            value: { shapeSettings: shapeChangingArgs.currentShapeSettings, allowShapeOverflow: shapeChangingArgs.allowShapeOverflow } });
        if (parent.activeObj.activePoint) {
            var obj = { prevActObj: null };
            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });
            if (isNullOrUndefined(obj['prevActObj'])) {
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false,
                    value: { prevActObj: extend({}, parent.activeObj, {}, true) } });
            }
            if (parent.activeObj.shape === 'image' && !this.isImageClarity) {
                this.upgradeImageQuality();
                this.isImageClarity = true;
            }
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                    points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });
            if (!this.isShapeInserted) {
                this.isPreventDragging = this.isShapeDragOut();
            }
        }
    };
    Selection.prototype.upgradeImageQuality = function () {
        var parent = this.parent;
        if (!parent.activeObj.imageCanvas) {
            return;
        }
        var activeObj = extend({}, parent.activeObj, null, true);
        var ctx = parent.activeObj.imageCanvas.getContext('2d');
        var dimObj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false, value: { width: parent.activeObj.imageElement.width,
                height: parent.activeObj.imageElement.height, obj: dimObj, isImgShape: null } });
        parent.notify('shape', { prop: 'updateObj', onPropertyChange: false, value: { dimObj: dimObj, x: null, y: null } });
        ctx.clearRect(0, 0, parent.activeObj.imageCanvas.width, parent.activeObj.imageCanvas.height);
        this.applyTransformToImg(ctx);
        parent.activeObj = activeObj;
    };
    Selection.prototype.applyTransformToImg = function (ctx) {
        var parent = this.parent;
        if (parent.activeObj.isHorImageFlip && parent.activeObj.isVerImageFlip) {
            parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = false;
            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                value: { ctx: ctx, isImgAnnotation: true, isHFlip: true, isVFlip: true } });
        }
        else if (parent.activeObj.isHorImageFlip) {
            parent.activeObj.isHorImageFlip = false;
            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                value: { ctx: ctx, isImgAnnotation: true, isHFlip: true, isVFlip: false } });
        }
        else if (parent.activeObj.isVerImageFlip) {
            parent.activeObj.isVerImageFlip = false;
            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                value: { ctx: ctx, isImgAnnotation: true, isHFlip: false, isVFlip: true } });
        }
        else {
            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                value: { ctx: ctx, isImgAnnotation: true, isHFlip: false, isVFlip: false } });
        }
    };
    // eslint-disable-next-line
    Selection.prototype.targetTouches = function (touches) {
        var bbox = this.parent.lowerCanvas.getBoundingClientRect();
        var p1 = { x: touches[0].pageX - bbox.left, y: touches[0].pageY - bbox.top };
        var p2 = { x: touches[1].pageX - bbox.left, y: touches[1].pageY - bbox.top };
        var points = [p1, p2];
        return points;
    };
    Selection.prototype.calculateScale = function (startTouches, endTouches) {
        var startDistance = this.getDistance(startTouches[0], startTouches[1]);
        var endDistance = this.getDistance(endTouches[0], endTouches[1]);
        return endDistance / startDistance;
    };
    Selection.prototype.getDistance = function (a, b) {
        var x = 0;
        var y = 0;
        if (a && b) {
            x = a.x - b.x;
            y = a.y - b.y;
        }
        return Math.sqrt(x * x + y * y);
    };
    Selection.prototype.redrawShape = function (obj, isMouseUp) {
        var parent = this.parent;
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (JSON.stringify(obj) === JSON.stringify(parent.objColl[i])) {
                parent.objColl.splice(i, 1);
                if (obj.shape && parent.textArea.style.display === 'none') {
                    var actObj = extend({}, obj, {}, true);
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                    if (parent.rotateFlipColl.length > 0 && (parent.panPoint.totalPannedClientPoint.x !== 0 ||
                        parent.panPoint.totalPannedClientPoint.y !== 0)) {
                        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
                    }
                    obj = parent.activeObj = actObj;
                }
                break;
            }
        }
        if ((obj.shape === 'path' && obj.pointColl.length === 0) ||
            (obj.shape !== 'path' && (obj.activePoint.width === 0 && obj.activePoint.height === 0))) {
            return;
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (this.isPreventDragging) {
            if (parent.activeObj.activePoint.startX > parent.img.destLeft) {
                this.isPreventDragging = false;
            }
            if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
            else {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
        }
        else {
            if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
            else {
                if (parent.activeObj.shape === 'redact') {
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                }
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
        }
    };
    Selection.prototype.setTimer = function (e) {
        var parent = this.parent;
        if (this.timer > 10) {
            clearTimeout(this.timer);
            this.timer = 0;
            parent.notify('shape', { prop: 'findTextTarget', onPropertyChange: false, value: { e: e } });
            if (Browser.isDevice) {
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
        }
    };
    Selection.prototype.applyCurrActObj = function (x, y) {
        var parent = this.parent;
        var isInside = false;
        var actObj = extend({}, parent.activeObj, {}, true);
        if (isNullOrUndefined(actObj.activePoint)) {
            return;
        }
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var radius = actObj.topLeftCircle ? actObj.topLeftCircle.radius : 0;
        if ((x >= Math.floor(startX) && x <= Math.ceil(endX) && y >= Math.floor(startY) && y <= Math.ceil(endY))) {
            isInside = true;
        }
        else if (radius !== 0 && (x >= Math.floor(startX) - radius && x <= Math.ceil(endX) + radius &&
            y >= Math.floor(startY) - radius && y <= Math.ceil(endY) + radius)) {
            isInside = true;
            this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
                flipObjColl: [], triangle: [], triangleRatio: [] };
        }
        else if ((actObj.shape === 'text' || actObj.shape === 'image') && this.dragElement !== '') {
            isInside = true;
        }
        else if (actObj.shape === 'line' || actObj.shape === 'arrow') {
            var smallPoint = { x: startX < endX ? startX : endX, y: startY < endY ? startY : endY };
            var largePoint = { x: startX > endX ? startX : endX, y: startY > endY ? startY : endY };
            if ((x >= (Math.floor(smallPoint.x) - 5) && x <= (Math.ceil(largePoint.x) + 5) &&
                y >= (Math.floor(smallPoint.y) - 5) && y <= (Math.ceil(largePoint.y) + 5)) ||
                parent.activeObj.preventShapeDragOut) {
                isInside = true;
            }
        }
        else if (actObj.shape === 'path') {
            var cursor = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
            if (cursor === 'move') {
                isInside = true;
            }
        }
        else if (this.dragElement === 'grabbing') {
            isInside = true;
        }
        else if (actObj.rotatedAngle !== 0) {
            var cursor = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
            if ((cursor !== 'default' && cursor !== 'grab') || this.dragElement === 'n-resize' || this.dragElement === 'e-resize' ||
                this.dragElement === 's-resize' || this.dragElement === 'w-resize') {
                isInside = true;
            }
        }
        else if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
            isInside = true;
        }
        if (!isInside) {
            if (isNullOrUndefined(parent.activeObj.currIndex)) {
                var shapeIDObj = { id: 'shape_' + (parent.objColl.length + 1) };
                parent.notify('shape', { prop: 'getNewShapeId', onPropertyChange: false, value: { obj: shapeIDObj } });
                parent.activeObj.currIndex = shapeIDObj['id'];
            }
            parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
            if (parent.activeObj.horTopLine !== undefined && parent.activeObj.horTopLine.startX !== 0 && parent.activeObj.horTopLine.endX
                !== 0 && !parent.currObjType.isCustomCrop && parent.currObjType.shape !== '') {
                if (parent.objColl.length > 0 &&
                    JSON.stringify(parent.objColl[parent.objColl.length - 1].activePoint) !==
                        JSON.stringify(parent.activeObj.activePoint)) {
                    parent.objColl.push(extend({}, parent.activeObj, {}, true));
                }
            }
            var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'text', 'image'];
            if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
                var tempFilter = this.lowerContext.filter;
                this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                    'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' +
                    'invert(0%)';
                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                    value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
                this.lowerContext.filter = tempFilter;
                if (parent.activeObj.shape) {
                    parent.notify('shape', { prop: 'apply', onPropertyChange: false,
                        value: { shape: null, obj: null, canvas: null } });
                }
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
                if (parent.isCircleCrop) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
            }
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        }
    };
    Selection.prototype.getCurrentFlipState = function () {
        var parent = this.parent;
        if (parent.rotateFlipColl.length !== 0) {
            var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
            parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
        }
        else {
            parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
        }
    };
    Selection.prototype.setTextBoxStylesToActObj = function () {
        var parent = this.parent;
        parent.activeObj.textSettings.fontFamily = parent.textArea.style.fontFamily;
        parent.activeObj.strokeSettings.strokeColor = parent.textArea.style.color !== '' &&
            parent.textArea.style.color.split('(')[1] && parent.textArea.style.color.split('(')[1].split(',')[0] &&
            parent.textArea.style.color.split('(')[1].split(',')[1] && parent.textArea.style.color.split('(')[1].split(',')[2]
            && parent.textArea.style.color.split('(')[1].split(',')[3] ?
            this.rgbToHex(parseFloat(parent.textArea.style.color.split('(')[1].split(',')[0]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[1]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[2]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[3])) :
            parent.textArea.style.color;
        parent.activeObj.strokeSettings.fillColor = parent.textArea.style.backgroundColor !== '' &&
            parent.textArea.style.backgroundColor.split('(')[1] && parent.textArea.style.backgroundColor.split('(')[1].split(',')[0] &&
            parent.textArea.style.backgroundColor.split('(')[1].split(',')[1] && parent.textArea.style.backgroundColor.split('(')[1].split(',')[2]
            && parent.textArea.style.backgroundColor.split('(')[1].split(',')[3] ?
            this.rgbToHex(parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[0]), parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[1]), parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[2]), parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[3])) :
            parent.textArea.style.backgroundColor;
        parent.activeObj.strokeSettings.outlineColor = parent.textArea.style.textShadow !== '' &&
            parent.textArea.style.textShadow.split('(')[1] && parent.textArea.style.textShadow.split('(')[1].split(',')[0] &&
            parent.textArea.style.textShadow.split('(')[1].split(',')[1] && parent.textArea.style.textShadow.split('(')[1].split(',')[2]
            && parent.textArea.style.textShadow.split('(')[1].split(',')[3] ?
            this.rgbToHex(parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[0]), parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[1]), parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[2]), parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[3])) :
            (parent.textArea.style.textShadow.match(/^(\s*[\w#]+)\s/) ?
                parent.textArea.style.textShadow.match(/^(\s*[\w#]+)\s/)[1].trim() :
                parent.textArea.style.textShadow);
        if (parent.textArea.style.fontWeight === 'bold') {
            parent.activeObj.textSettings.bold = true;
        }
        else {
            parent.activeObj.textSettings.bold = false;
        }
        if (parent.textArea.style.fontStyle === 'italic') {
            parent.activeObj.textSettings.italic = true;
        }
        else {
            parent.activeObj.textSettings.italic = false;
        }
        parent.activeObj.textSettings.fontSize = (parseFloat(parent.textArea.style.fontSize));
    };
    Selection.prototype.rgbToHex = function (r, g, b, a) {
        r = Math.max(0, Math.min(255, Math.round(r)));
        g = Math.max(0, Math.min(255, Math.round(g)));
        b = Math.max(0, Math.min(255, Math.round(b)));
        a = Math.max(0, Math.min(1, a));
        var hexR = this.padLeft(r.toString(16), 2, '0');
        var hexG = this.padLeft(g.toString(16), 2, '0');
        var hexB = this.padLeft(b.toString(16), 2, '0');
        var hexA = this.padLeft(Math.round(a * 255).toString(16), 2, '0');
        var hex;
        if (isNaN(Number(hexA))) {
            hex = "#" + hexR + hexG + hexB;
        }
        else {
            hex = "#" + hexR + hexG + hexB + hexA;
        }
        return hex;
    };
    Selection.prototype.padLeft = function (value, length, padChar) {
        while (value.length < length) {
            value = padChar + value;
        }
        return value;
    };
    Selection.prototype.deleteItem = function () {
        var parent = this.parent;
        var shapeChangingArgs = { cancel: false };
        var previousShapeSettings = {};
        if (this.isFhdEditing) {
            this.updateFreehandDrawColorChange();
            var prevCropObj = extend({}, parent.cropObj, {}, true);
            var object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var prevObj = object['currObj'];
            prevObj.objColl = extend([], parent.objColl, [], true);
            prevObj.pointColl = extend([], parent.pointColl, [], true);
            prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            var obj = { freehandDrawSelectedId: null };
            parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });
            parent.notify('freehand-draw', { prop: 'deleteFhd', value: { id: obj['freehandDrawSelectedId'] } });
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'deleteFreehandDrawing', previousObj: prevObj, previousObjColl: this.tempObjColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            parent.notify('freehand-draw', { prop: 'resetFreehandDrawSelectedId' });
        }
        else if (parent.textArea.style.display === 'none') {
            var obj = { prevActObj: null };
            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });
            if (obj['prevActObj']) {
                obj['prevActObj']['activePoint']['width'] = Math.abs(obj['prevActObj']['activePoint']['width']);
                obj['prevActObj']['activePoint']['height'] = Math.abs(obj['prevActObj']['activePoint']['height']);
            }
            if (obj['prevActObj'] && JSON.stringify(obj['prevActObj']) !== JSON.stringify(parent.activeObj)) {
                var index = parent.activeObj.currIndex;
                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null, isFinalCancel: true } });
                for (var i = 0, len = parent.objColl.length; i < len; i++) {
                    if (parent.objColl[i].currIndex === index) {
                        parent.objColl.splice(i, 1);
                        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                        break;
                    }
                }
            }
            var object = { isNewPath: null };
            parent.notify('draw', { prop: 'getNewPath', value: { obj: object } });
            if (object['isNewPath']) {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
            else if (parent.activeObj.shape) {
                parent.objColl.push(parent.activeObj);
                var prevCropObj = extend({}, parent.cropObj, {}, true);
                var object_2 = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object_2 } });
                var prevObj = object_2['currObj'];
                prevObj.objColl = extend([], parent.objColl, [], true);
                prevObj.pointColl = extend([], parent.pointColl, [], true);
                prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
                var selPointCollObj = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: selPointCollObj } });
                prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
                parent.objColl.pop();
                previousShapeSettings = this.updatePrevShapeSettings();
                shapeChangingArgs = { cancel: false, action: 'delete', previousShapeSettings: previousShapeSettings, currentShapeSettings: null };
                parent.notify('shape', { prop: 'setKeyHistory', onPropertyChange: false, value: { keyHistory: '' } });
                parent.clearSelection();
                parent.trigger('shapeChanging', shapeChangingArgs);
                parent.editCompleteArgs = shapeChangingArgs;
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                if (!isNullOrUndefined(prevObj.objColl[prevObj.objColl.length - 1].currIndex)) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                        value: { operation: 'deleteObj', previousObj: prevObj, previousObjColl: this.tempObjColl,
                            previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                            previousCropObj: prevCropObj, previousText: null,
                            currentText: null, previousFilter: null, isCircleCrop: null } });
                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
            }
            parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
            if (parent.drawingShape) {
                this.currentDrawingShape = parent.drawingShape.toLowerCase();
                parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
                parent.upperCanvas.style.cursor = 'crosshair';
            }
        }
        if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {
            document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';
        }
    };
    Selection.prototype.updateFreehandDrawColorChange = function () {
        var parent = this.parent;
        var indexObj = { freehandSelectedIndex: null };
        parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
        if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) && !isNullOrUndefined(parent.pointColl[indexObj['freehandSelectedIndex']])
            && parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor === '#42a5f5') {
            var obj = { tempFreeHandDrawEditingStyles: null };
            parent.notify('freehand-draw', { prop: 'getTempFreeHandDrawEditingStyles', value: { obj: obj } });
            parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor = obj['tempFreeHandDrawEditingStyles'].strokeColor;
        }
    };
    Selection.prototype.updatePrevShapeSettings = function (obj) {
        var parent = this.parent;
        var fontStyle = [];
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
            var shapeIDObj = { id: 'shape_' + (parent.objColl.length + 1) };
            parent.notify('shape', { prop: 'getNewShapeId', onPropertyChange: false, value: { obj: shapeIDObj } });
            parent.activeObj.currIndex = shapeIDObj['id'];
        }
        if (parent.activeObj.shape === 'text' && parent.activeObj.textSettings) {
            if (parent.activeObj.textSettings.bold) {
                fontStyle.push('bold');
            }
            if (parent.activeObj.textSettings.italic) {
                fontStyle.push('italic');
            }
            if (parent.activeObj.textSettings.underline) {
                fontStyle.push('underline');
            }
        }
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
        var _b = parent.activeObj, keyHistory = _b.keyHistory, currIndex = _b.currIndex, shape = _b.shape, textSettings = _b.textSettings, strokeSettings = _b.strokeSettings, rotatedAngle = _b.rotatedAngle, imageElement = _b.imageElement, opacity = _b.opacity;
        var shapeSettingsObj = {
            id: !isNullOrUndefined(currIndex) ? currIndex : null,
            type: parent.toPascalCase(shape),
            startX: startX, startY: startY, width: width, height: height,
            strokeColor: strokeSettings ? (shape === 'text' ? strokeSettings.outlineColor : strokeSettings.strokeColor) : null,
            strokeWidth: strokeSettings ? (shape === 'text' ? strokeSettings.outlineWidth : strokeSettings.strokeWidth) : null,
            fillColor: strokeSettings ? strokeSettings.fillColor : null,
            radius: shape === 'ellipse' ? width / 2 : null,
            length: shape === 'line' || shape === 'arrow' ? width : null,
            text: shape === 'text' ? (keyHistory ? keyHistory : (textSettings.text ? textSettings.text : null)) : null,
            fontSize: shape === 'text' ? (textSettings ? textSettings.fontSize : null) : null,
            fontFamily: shape === 'text' ? (textSettings ? textSettings.fontFamily : null) : null,
            fontStyle: shape === 'text' ? fontStyle : null,
            color: shape === 'text' ? (strokeSettings ? strokeSettings.strokeColor : null) : null,
            degree: shape === 'ellipse' || shape === 'rectangle' || shape === 'image' || shape === 'text' ? rotatedAngle * (180 / Math.PI) : null,
            imageData: shape === 'image' ? imageElement.src : null,
            opacity: shape === 'image' ? opacity : null,
            radiusX: shape === 'ellipse' ? width / 2 : null,
            radiusY: shape === 'ellipse' ? height / 2 : null,
            endX: shape === 'line' || shape === 'arrow' ? endX : null,
            endY: shape === 'line' || shape === 'arrow' ? endY : null,
            arrowHead: shape === 'arrow' ? this.getArrowType(parent.activeObj.start) : null,
            arrowTail: shape === 'arrow' ? this.getArrowType(parent.activeObj.end) : null,
            points: shape === 'path' ? parent.activeObj.pointColl : null,
            index: parent.activeObj.order,
            transformCollection: shape === 'text' ? this.updateTransColl(parent.activeObj) : null
        };
        if (obj) {
            obj['shapeSettingsObj'] = shapeSettingsObj;
        }
        return shapeSettingsObj;
    };
    Selection.prototype.updateTransColl = function (object) {
        var parent = this.parent;
        var coll;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var tempColl = object.rotateFlipColl;
        if (tempColl && tempColl.length > 0) {
            var value = void 0;
            coll = [];
            for (var i = 0; i < tempColl.length; i++) {
                value = tempColl[i];
                if (typeof (value) === 'number') {
                    coll.push({ degree: value });
                }
                else {
                    coll.push({ flip: parent.toPascalCase(value) });
                }
            }
        }
        return coll;
    };
    Selection.prototype.getArrowType = function (type) {
        var typeToArrowType = { 'none': 'None', 'arrow': 'Arrow', 'arrowSolid': 'SolidArrow',
            'circle': 'Circle', 'circleSolid': 'SolidCircle', 'square': 'Square', 'squareSolid': 'SolidSquare', 'bar': 'Bar' };
        return typeToArrowType["" + type];
    };
    Selection.prototype.getRectanglePoints = function (rectX, rectY, rectWidth, rectHeight, rectAngle, pointX, pointY) {
        var centerX = rectX + rectWidth / 2;
        var centerY = rectY + rectHeight / 2;
        var angleRad = rectAngle * (Math.PI / 180);
        var cosAngle = Math.cos(angleRad);
        var sinAngle = Math.sin(angleRad);
        var localX = pointX - centerX;
        var localY = pointY - centerY;
        var rotatedX = localX * cosAngle + localY * sinAngle;
        var rotatedY = -localX * sinAngle + localY * cosAngle;
        var halfWidth = rectWidth / 2;
        var halfHeight = rectHeight / 2;
        if (rotatedX >= -halfWidth && rotatedX <= halfWidth && rotatedY >= -halfHeight &&
            rotatedY <= halfHeight) {
            return true;
        }
        else {
            return false;
        }
    };
    Selection.prototype.getTransRotationPoint = function (obj, object) {
        var rotationCirclePoint;
        var degree;
        var isHorizontalflip = false;
        var isVerticalflip = false;
        degree = (obj.shapeDegree === 0) ? this.parent.transform.degree : this.parent.transform.degree - obj.shapeDegree;
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (obj.flipObjColl) {
            for (var i = 0, iLen = obj.flipObjColl.length; i < iLen; i++) {
                if (obj.flipObjColl[i].toLowerCase() === 'horizontal') {
                    isHorizontalflip = true;
                }
                else if (obj.flipObjColl[i].toLowerCase() === 'vertical') {
                    isVerticalflip = true;
                }
            }
        }
        if (degree === 0 || degree === 360) {
            if (isVerticalflip) {
                rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };
            }
            else {
                rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
            }
        }
        else if (degree === 90 || degree === -270) {
            if (isHorizontalflip) {
                rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
            else {
                rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
        }
        else if (degree === 180 || degree === -180) {
            if (isVerticalflip) {
                rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
            }
            else {
                rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };
            }
        }
        else if (degree === 270 || degree === -90) {
            if (isHorizontalflip) {
                rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
            else {
                rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
        }
        if (object) {
            object['rotationCirclePoint'] = rotationCirclePoint;
        }
        return rotationCirclePoint;
    };
    Selection.prototype.getNumTextValue = function (obj) {
        var parent = this.parent;
        var elem = parent.element;
        var height;
        var width;
        var widthElement;
        var heightElement;
        widthElement = elem.querySelector('#' + elem.id + '_resizeWidth');
        heightElement = elem.querySelector('#' + elem.id + '_resizeHeight');
        if (widthElement && heightElement) {
            var heightString = heightElement.value.replace(/,/g, '');
            var widthString = widthElement.value.replace(/,/g, '');
            if (heightString === '') {
                heightString = heightElement.placeholder.replace(/,/g, '');
            }
            if (widthString === '') {
                widthString = widthElement.placeholder.replace(/,/g, '');
            }
            height = parseFloat(heightString);
            width = parseFloat(widthString);
        }
        if (obj) {
            obj['width'] = width;
            obj['height'] = height;
        }
        return { x: width, y: height };
    };
    Selection.prototype.isValueUpdated = function () {
        var isValue = true;
        var widthElement;
        var heightElement;
        widthElement = this.parent.element.querySelector('#' + this.parent.element.id + '_resizeWidth');
        heightElement = this.parent.element.querySelector('#' + this.parent.element.id + '_resizeHeight');
        if (widthElement && heightElement) {
            if (heightElement.value.replace(/,/g, '') === '' && widthElement.value.replace(/,/g, '') === '') {
                isValue = false;
            }
        }
        return isValue;
    };
    Selection.prototype.allowOutofBound = function () {
        var shapes = ['ellipse', 'rectangle', 'text', 'image', 'redact'];
        // eslint-disable-next-line max-len
        var allowOutofBound = (shapes.indexOf(this.parent.activeObj.shape) !== -1 && this.parent.activeObj.rotatedAngle === 0) ? false : true;
        return allowOutofBound;
    };
    return Selection;
}());

/* eslint-disable no-constant-condition */
var Shape = /** @class */ (function () {
    function Shape(parent) {
        this.textSettings = { text: 'Enter Text', fontFamily: '', fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
        this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, radius: null, outlineColor: '', outlineWidth: null };
        this.keyHistory = ''; // text history
        this.preventFrameAnnotation = false;
        this.redactType = 'blur';
        this.parent = parent;
        this.addEventListener();
    }
    Shape.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    Shape.prototype.addEventListener = function () {
        this.parent.on('shape', this.shape, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    Shape.prototype.removeEventListener = function () {
        this.parent.off('shape', this.shape);
        this.parent.off('destroyed', this.destroy);
    };
    Shape.prototype.shape = function (args) {
        var parent = this.parent;
        this.initShapePvtProps();
        var uploader;
        switch (args.prop) {
            case 'drawEllipse':
                this.drawEllipse(args.value['x'], args.value['y'], args.value['radiusX'], args.value['radiusY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor'], args.value['degree'], args.value['isSelected']);
                break;
            case 'drawLine':
                this.drawLine(args.value['startX'], args.value['startY'], args.value['endX'], args.value['endY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['isSelected']);
                break;
            case 'drawArrow':
                this.drawArrow(args.value['startX'], args.value['startY'], args.value['endX'], args.value['endY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['arrowStart'], args.value['arrowEnd'], args.value['isSelected']);
                break;
            case 'drawPath':
                this.drawPath(args.value['pointColl'], args.value['strokeWidth'], args.value['strokeColor'], args.value['isSelected']);
                break;
            case 'drawRectangle':
                this.drawRectangle(args.value['x'], args.value['y'], args.value['width'], args.value['height'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor'], args.value['degree'], args.value['isSelected'], args.value['radius']);
                break;
            case 'drawText':
                this.drawText(args.value['x'], args.value['y'], args.value['text'], args.value['fontFamily'], args.value['fontSize'], args.value['bold'], args.value['italic'], args.value['color'], args.value['isSelected'], args.value['degree'], args.value['fillColor'], args.value['outlineColor'], args.value['outlineWidth'], args.value['transformCollection']);
                break;
            case 'redrawActObj':
                this.redrawActObj(args.value['x'], args.value['y'], args.value['isMouseDown']);
                break;
            case 'apply':
                this.apply(args.value['shape'], args.value['obj'], args.value['canvas']);
                break;
            case 'updateShapeChangeEventArgs':
                this.updateShapeChangeEventArgs(args.value['shapeSettings'], args.value['allowShapeOverflow']);
                break;
            case 'updSelChangeEventArgs':
                this.updSelChangeEventArgs(args.value['selectionSettings']);
                break;
            case 'iterateObjColl':
                this.iterateObjColl();
                break;
            case 'updImgRatioForActObj':
                this.updImgRatioForActObj();
                break;
            case 'redrawObj':
                this.redrawObj(args.value['degree']);
                break;
            case 'redraw-text':
                this.redrawText();
                break;
            case 'draw-shape':
                this.drawShape(args.value['obj'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor'], args.value['start'], args.value['width'], args.value['height']);
                break;
            case 'renderTextArea':
                this.renderTextArea(args.value['x'], args.value['y'], args.value['actObj']);
                break;
            case 'setTextBoxWidth':
                this.setTextBoxWidth(args.value['e']);
                break;
            case 'findTextTarget':
                this.findTextTarget(args.value['e']);
                break;
            case 'updateFontStyles':
                this.updateFontStyles(args.value['isTextBox']);
                break;
            case 'applyFontStyle':
                this.applyFontStyle(args.value['item']);
                break;
            case 'updateFontRatio':
                this.updateFontRatio(args.value['obj'], args.value['isTextArea']);
                break;
            case 'updateFontSize':
                this.updateFontSize(args.value['obj']);
                break;
            case 'pushActItemIntoObj':
                this.pushActItemIntoObj();
                break;
            case 'clearActObj':
                this.clearActObj();
                break;
            case 'refreshActiveObj':
                this.refreshActiveObj();
                break;
            case 'applyActObj':
                this.applyActObj(args.value['isMouseDown']);
                break;
            case 'wireEvent':
                EventHandler.add(parent.upperCanvas, 'dblclick', this.findTextTarget, this);
                EventHandler.add(parent.textArea, 'mousedown', this.findTextTarget, this);
                uploader = document.getElementById(parent.element.id + '_fileUpload');
                if (uploader) {
                    EventHandler.add(uploader, 'change', this.fileChanged, this);
                }
                break;
            case 'unWireEvent':
                EventHandler.remove(parent.upperCanvas, 'dblclick', this.findTextTarget);
                EventHandler.remove(parent.textArea, 'mousedown', this.findTextTarget);
                uploader = document.getElementById(parent.element.id + '_fileUpload');
                if (uploader) {
                    EventHandler.remove(uploader, 'change', this.fileChanged);
                }
                break;
            case 'getShapeSetting':
                this.getShapeSetting(args.value['id'], args.value['obj']);
                break;
            case 'getShapeSettings':
                this.getShapeSettings(args.value['obj']);
                break;
            case 'getRedactSettings':
                this.getRedactSettings(args.value['obj']);
                break;
            case 'isPointsInRange':
                this.isPointsInRange(args.value['x'], args.value['y'], args.value['obj']);
                break;
            case 'alignRotateFlipColl':
                this.alignRotateFlipColl(args.value['collection'], args.value['isRotateFlipCollection'], args.value['obj']);
                break;
            case 'selectShape':
                this.selectShape(args.value['id'], args.value['obj']);
                break;
            case 'deleteShape':
                this.deleteShape(args.value['id']);
                break;
            case 'getMaxText':
                this.getMaxText(args.value['isTextBox'], args.value['text'], args.value['obj']);
                break;
            case 'setPointCollForLineArrow':
                args.value['obj'].pointColl = this.getLinePoints(args.value['obj'].activePoint.startX, args.value['obj'].activePoint.startY, args.value['obj'].activePoint.endX, args.value['obj'].activePoint.endY);
                break;
            case 'setPointCollForShapeRotation':
                this.setPointCollForShapeRotation(args.value['obj']);
                break;
            case 'setTextSettings':
                if (args.value['textSettings']) {
                    this.textSettings = args.value['textSettings'];
                }
                else if (args.value['fontFamily']) {
                    this.textSettings.fontFamily = args.value['fontFamily'];
                }
                else if (args.value['fontSize']) {
                    this.textSettings.fontSize = args.value['fontSize'];
                }
                else if (args.value['radius']) {
                    this.strokeSettings.radius = args.value['radius'];
                }
                break;
            case 'setStrokeSettings':
                if (args.value['strokeSettings']) {
                    this.strokeSettings = args.value['strokeSettings'];
                }
                else if (args.value['strokeColor']) {
                    this.strokeSettings.strokeColor = args.value['strokeColor'];
                }
                else if (args.value['fillColor']) {
                    this.strokeSettings.fillColor = args.value['fillColor'];
                }
                else if (args.value['strokeWidth']) {
                    this.strokeSettings.strokeWidth = args.value['strokeWidth'];
                }
                else if (args.value['outlineColor']) {
                    this.strokeSettings.outlineColor = args.value['outlineColor'];
                }
                else if (args.value['radius']) {
                    this.strokeSettings.radius = args.value['radius'];
                }
                else if (args.value['outlineWidth']) {
                    this.strokeSettings.outlineWidth = args.value['outlineWidth'];
                }
                break;
            case 'getStrokeSettings':
                args.value['obj']['strokeSettings'] = this.strokeSettings;
                break;
            case 'setKeyHistory':
                this.keyHistory = args.value['keyHistory'];
                break;
            case 'getKeyHistory':
                args.value['obj']['keyHistory'] = this.keyHistory;
                break;
            case 'setTextBoxPos':
                this.setTextBoxPos(args.value['actObj'], args.value['degree'], args.value['flip'], args.value['x'], args.value['y']);
                break;
            case 'setTextBoxPoints':
                this.setTextBoxPoints(args.value['actObj'], args.value['degree'], args.value['flip'], args.value['x'], args.value['y']);
                break;
            case 'alignTextAreaIntoCanvas':
                this.alignTextAreaIntoCanvas();
                break;
            case 'initializeTextShape':
                this.initializeTextShape(args.value['text'], args.value['fontFamily'], args.value['fontSize'], args.value['bold'], args.value['italic'], args.value['strokeColor'], args.value['fillColor'], args.value['outlineColor'], args.value['outlineWidth']);
                break;
            case 'stopPathDrawing':
                this.stopPathDrawing(args.value['e'], args.value['isApply']);
                break;
            case 'updateArrowRatio':
                this.updateArrowRatio(args.value['obj']);
                break;
            case 'getSquarePointForRotatedShape':
                this.getSquarePointForRotatedShape(args.value['obj'], args.value['object']);
                break;
            case 'drawImage':
                this.drawImage(args.value['x'], args.value['y'], args.value['width'], args.value['height'], args.value['src'], args.value['degree'], args.value['isAspectRatio'], args.value['opacity'], args.value['isSelected']);
                break;
            case 'reset':
                this.reset();
                break;
            case 'updateObj':
                this.updateObj(args.value['dimObj'], args.value['x'], args.value['y']);
                break;
            case 'straightenShapes':
                this.straightenShapes();
                break;
            case 'straightenShapePoints':
                this.straightenShapePoints(args.value['obj'], args.value['isReverse']);
                break;
            case 'straightenPath':
                this.straightenPath(args.value['obj']);
                break;
            case 'straightenFHD':
                this.straightenFHD();
                break;
            case 'getTextBoxPosition':
                this.getTextBoxPosition(args.value['obj'], args.value['object']);
                break;
            case 'setFlipState':
                this.setFlipState(args.value['x'], args.value['y'], args.value['obj'], args.value['object']);
                break;
            case 'getNewShapeId':
                args.value['obj']['id'] = this.getNewShapeId();
                break;
            case 'z-order':
                this.updateZOrder(args.value['obj'], args.value['value']);
                break;
            case 'getSmallestIndex':
                args.value['obj']['index'] = this.getSmallestIndex();
                break;
            case 'isIndexInObjColl':
                args.value['obj']['bool'] = this.isIndexInObjColl(args.value['index']);
                break;
            case 'drawAnnotations':
                this.drawAnnotations(args.value['ctx'], args.value['shape'], args.value['pen'], args.value['isPreventApply'], args.value['x'], args.value['y'], args.value['panRegion']);
                break;
            case 'updateShapeColl':
                this.updateShapeColl();
                break;
            case 'getNewOrder':
                args.value['obj']['order'] = this.getNewOrder();
                break;
            case 'getHighestOrder':
                args.value['obj']['order'] = this.getHighestOrder();
                break;
            case 'getLowestOrder':
                args.value['obj']['order'] = this.getLowestOrder();
                break;
            case 'drawRedact':
                this.drawRedact(args.value['x'], args.value['y'], args.value['width'], args.value['height'], args.value['type'], args.value['value']);
                break;
            case 'setRedactType':
                this.redactType = args.value['redactType'];
                break;
        }
    };
    Shape.prototype.getModuleName = function () {
        return 'shape';
    };
    Shape.prototype.initShapePvtProps = function () {
        var parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
        if (isNullOrUndefined(this.shapeImg)) {
            this.shapeImg = parent.createElement('img', {
                id: parent.element.id + '_shapeImg', attrs: { name: 'Image', crossorigin: 'anonymous' }
            });
        }
        if (this.textSettings.fontFamily === '') {
            this.textSettings.fontFamily = parent.fontFamily.default;
        }
    };
    Shape.prototype.reset = function () {
        this.textSettings =
            { text: 'Enter Text', fontFamily: this.parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
        this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, radius: null, outlineColor: '', outlineWidth: null };
        this.preventFrameAnnotation = false;
    };
    Shape.prototype.drawEllipse = function (x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {
        this.initializeShape('ellipse');
        var start = x && y ? { x: x, y: y } : null;
        this.drawShape('ellipse', strokeWidth, strokeColor, fillColor, start, radiusX, radiusY, null, null, null, degree, null, isSelected);
    };
    Shape.prototype.drawLine = function (startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {
        this.initializeShape('line');
        var start = startX && startY ? { x: startX, y: startY } : null;
        var width = endX - startX;
        var height = endY - startY;
        this.drawShape('line', strokeWidth, strokeColor, null, start, width, height, null, null, null, null, null, isSelected);
    };
    Shape.prototype.drawPath = function (pointColl, strokeWidth, strokeColor, isSelected) {
        this.initializeShape('path');
        if (pointColl) {
            this.drawShape('path', strokeWidth, strokeColor, null, null, null, null, pointColl, null, null, null, null, isSelected);
        }
    };
    Shape.prototype.drawArrow = function (startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {
        this.initializeShape('arrow');
        var start = startX && startY ? { x: startX, y: startY } : null;
        var width = endX - startX;
        var height = endY - startY;
        this.drawShape('arrow', strokeWidth, strokeColor, null, start, width, height, null, arrowStart, arrowEnd, null, null, isSelected);
    };
    Shape.prototype.drawRectangle = function (x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected, radius) {
        this.initializeShape('rectangle');
        var start = x && y ? { x: x, y: y } : null;
        this.drawShape('rectangle', strokeWidth, strokeColor, fillColor, start, width, height, null, null, null, degree, null, isSelected, radius);
    };
    // eslint-disable-next-line @typescript-eslint/tslint/config
    Shape.prototype.drawRedact = function (x, y, width, height, type, value) {
        this.initializeShape('redact');
        var start = x && y ? { x: x, y: y } : null;
        this.drawShape('redact', null, null, null, start, width, height, null, null, null, null, null, null, null, type, value);
    };
    Shape.prototype.drawText = function (x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection) {
        this.drawShapeText(text, fontFamily, fontSize, bold, italic, color, x, y, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection);
    };
    Shape.prototype.initializeShape = function (type) {
        var parent = this.parent;
        this.redrawActObj();
        parent.activeObj.shape = type;
        parent.currObjType.isCustomCrop = false;
    };
    Shape.prototype.updateWidthHeight = function (obj) {
        obj.activePoint.width = obj.activePoint.endX - obj.activePoint.startX;
        obj.activePoint.height = obj.activePoint.endY - obj.activePoint.startY;
        return obj;
    };
    Shape.prototype.setDimension = function (width, height) {
        var parent = this.parent;
        var shape = parent.activeObj.shape;
        if ((width && height) || ((shape === 'line' || shape === 'arrow') && (width || height))) {
            parent.activeObj.activePoint.width = width;
            parent.activeObj.activePoint.height = height;
            if (parent.currObjType.shape.toLowerCase() === 'ellipse') {
                parent.activeObj.activePoint.width = 2 * width;
                parent.activeObj.activePoint.height = 2 * height;
            }
        }
    };
    Shape.prototype.getArrowType = function (type) {
        var arrowType = type;
        if (type) {
            var typeToArrowType = { 'None': 'none', 'Arrow': 'arrow', 'SolidArrow': 'arrowSolid',
                'Circle': 'circle', 'SolidCircle': 'circleSolid', 'Square': 'square', 'SolidSquare': 'squareSolid', 'Bar': 'bar' };
            arrowType = typeToArrowType["" + type];
        }
        return arrowType;
    };
    Shape.prototype.drawShape = function (type, strokeWidth, strokeColor, fillColor, start, width, height, pointColl, arrowStart, arrowEnd, degree, opacity, isSelected, radius, redactType, value) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            this.redrawActObj();
            var objColl = extend([], parent.objColl, [], true);
            parent.togglePen = false;
            this.keyHistory = '';
            parent.upperCanvas.style.display = 'block';
            this.refreshActiveObj();
            parent.currObjType.shape = type = type.toLowerCase();
            if (type !== 'freehanddraw' && type !== '') {
                parent.activeObj.shape = type;
                var strokeSettings = parent.activeObj.strokeSettings;
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                if (isNullOrUndefined(strokeSettings)) {
                    strokeSettings = this.strokeSettings;
                }
                if (type === 'path' && pointColl) {
                    parent.activeObj.pointColl = pointColl;
                }
                if (opacity !== null && opacity !== undefined) {
                    parent.activeObj.opacity = opacity;
                }
                strokeSettings.strokeWidth = strokeWidth ? strokeWidth : strokeSettings.strokeWidth;
                var shape = parent.activeObj.shape;
                if ((shape === 'rectangle' || shape === 'ellipse') && strokeWidth === 0) {
                    strokeSettings.strokeWidth = 0;
                }
                strokeSettings.strokeColor = strokeColor ? strokeColor : strokeSettings.strokeColor;
                strokeSettings.fillColor = fillColor || fillColor === '' ? fillColor : strokeSettings.fillColor;
                strokeSettings.radius = radius ? radius : strokeSettings.radius;
                var tempWidth = parent.img.destWidth > 100 ? 100 : parent.img.destWidth / 2;
                var tempHeight = parent.img.destHeight > 100 ? 100 : parent.img.destHeight / 2;
                parent.activeObj.activePoint.width = tempWidth;
                parent.activeObj.activePoint.height = tempHeight;
                if (type === 'line' || type === 'arrow') {
                    parent.activeObj.lineDraw = 'horizontal';
                    parent.activeObj.activePoint.height = 0;
                    if (type === 'arrow') {
                        parent.activeObj.activePoint.width += 50;
                        parent.activeObj.start = this.getArrowType(arrowStart);
                        parent.activeObj.end = this.getArrowType(arrowEnd);
                    }
                }
                else if (type === 'rectangle') {
                    parent.activeObj.activePoint.width += parent.activeObj.activePoint.width / 2;
                }
                else if (type === 'redact') {
                    if (redactType) {
                        parent.activeObj.redactType = redactType.toLowerCase();
                        if (redactType === RedactType.Blur) {
                            if (value) {
                                parent.activeObj.redactBlur = value;
                            }
                        }
                        else {
                            if (value) {
                                parent.activeObj.redactPixelate = value;
                            }
                        }
                        parent.activeObj.redactImage = parent.createElement('canvas');
                    }
                }
                this.setDimension(width, height);
                if (start) {
                    parent.activeObj.activePoint.startX = start.x;
                    parent.activeObj.activePoint.startY = start.y;
                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX +
                        parent.activeObj.activePoint.width;
                    parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY +
                        parent.activeObj.activePoint.height;
                }
                else {
                    this.setCenterPoints();
                }
                this.setPointCollForLineAndArrow();
                if (type === 'arrow') {
                    parent.activeObj.triangleDirection = 'right';
                }
                parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
                this.initShapeProps();
                var obj = { shapeSettingsObj: {} };
                parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
                var shapeSettings = obj['shapeSettingsObj'];
                var shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,
                    currentShapeSettings: shapeSettings };
                parent.trigger('shapeChanging', shapeChangingArgs);
                parent.editCompleteArgs = shapeChangingArgs;
                this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
                this.setDimension(width, height);
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
                if (degree) {
                    parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
                    parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });
                }
                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });
                parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
                if (type === 'redact') {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                }
                else {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                }
                parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                if (parent.isPublicMethod && !isSelected) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedo', value: { operation: 'shapeInsert' }, onPropertyChange: false });
                }
                parent.isPublicMethod = false;
            }
        }
    };
    Shape.prototype.initShapeProps = function () {
        var parent = this.parent;
        parent.activeObj.shapeDegree = parent.transform.degree;
        parent.activeObj.shapeFlip = parent.transform.currFlipState;
        parent.activeObj.textFlip = parent.transform.currFlipState;
        parent.activeObj.flipObjColl = [];
        parent.activeObj.order = this.getNewOrder();
    };
    Shape.prototype.setPointCollForLineAndArrow = function () {
        var parent = this.parent;
        var shape = parent.activeObj.shape;
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        if (shape === 'line' || shape === 'arrow') {
            parent.activeObj.pointColl = this.getLinePoints(startX, startY, endX, endY);
            if (parent.activeObj.pointColl) {
                for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
                    parent.activeObj.pointColl[i].ratioX = (parent.activeObj.pointColl[i].x -
                        parent.img.destLeft) / parent.img.destWidth;
                    parent.activeObj.pointColl[i].ratioY = (parent.activeObj.pointColl[i].y -
                        parent.img.destTop) / parent.img.destHeight;
                }
            }
        }
    };
    Shape.prototype.prevObjColl = function () {
        var parent = this.parent;
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        this.prevObj = object['currObj'];
        this.prevObj.objColl = extend([], parent.objColl, [], true);
        this.prevObj.pointColl = extend([], parent.pointColl, [], true);
        this.prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        this.prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
    };
    Shape.prototype.drawShapeText = function (text, fontFamily, fontSize, bold, italic, strokeColor, x, y, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (parent.currObjType.shape === 'freehanddraw') {
                this.apply();
                parent.upperCanvas.style.cursor = parent.cursor = 'default';
                parent.currObjType.shape = '';
            }
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            parent.togglePen = false;
            this.redrawActObj();
            this.prevObjColl();
            this.refreshActiveObj();
            parent.activeObj.shape = parent.currObjType.shape = 'text';
            parent.currObjType.isCustomCrop = false;
            this.initializeTextShape(text, fontFamily, fontSize, bold, italic, strokeColor, fillColor, outlineColor, outlineWidth);
            parent.currObjType.isText = parent.currObjType.isInitialText = true;
            if (isNullOrUndefined(parent.activeObj.textSettings.fontSize)) {
                parent.getFontSizes();
                parent.activeObj.textSettings.fontSize = parseInt(parent.fontSizeColl[(parseInt('3', 10) - 1)].text, 10);
            }
            if (parent.img.destWidth < 100) {
                parent.activeObj.textSettings.fontSize = Math.floor((parent.img.destWidth / 20));
            }
            else if (parent.img.destHeight < 100) {
                parent.activeObj.textSettings.fontSize = Math.floor((parent.img.destHeight / 20));
            }
            parent.activeObj.shapeDegree = parent.transform.degree;
            parent.activeObj.shapeFlip = parent.transform.currFlipState;
            parent.activeObj.flipObjColl = [];
            this.updateFontStyles();
            parent.activeObj.order = this.getNewOrder();
            var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width +
                parent.activeObj.textSettings.fontSize * 0.5;
            var height = parent.activeObj.textSettings.fontSize;
            if (text) {
                parent.activeObj.keyHistory = text;
                var maxText = this.getMaxText();
                maxText = maxText ? maxText : parent.activeObj.textSettings.text;
                width = this.upperContext.measureText(maxText).width + parent.activeObj.textSettings.fontSize * 0.5;
                var rows = text.split('\n');
                if (rows.length > 1) {
                    height = rows.length * parent.activeObj.textSettings.fontSize;
                    height += (fontSize * 0.25);
                }
            }
            if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
                parent.activeObj.activePoint.startX = x;
                parent.activeObj.activePoint.startY = y;
                parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + width;
                parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + height;
            }
            else {
                this.setCenterPoints(true, width, height);
            }
            if (transformCollection) {
                parent.notify('selection', { prop: 'setTransformedShape', onPropertyChange: false, value: { bool: true } });
                this.setTransformColl(transformCollection);
                var actObj = parent.activeObj;
                actObj.shapeDegree = 0;
                actObj.shapeFlip = '';
                var tempDegree = 0;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var coll = actObj.rotateFlipColl;
                for (var i = 0; i < coll.length; i++) {
                    if (typeof (coll[i]) === 'number') {
                        tempDegree += coll[i];
                    }
                }
                if (tempDegree % 90 === 0 && Math.abs(tempDegree) % 180 === 90) {
                    actObj.activePoint.endX = actObj.activePoint.startX + height;
                    actObj.activePoint.endY = actObj.activePoint.startY + width;
                    actObj.activePoint.width = actObj.activePoint.endX - actObj.activePoint.startX;
                    actObj.activePoint.height = actObj.activePoint.endY - actObj.activePoint.startY;
                }
            }
            var obj = { shapeSettingsObj: {} };
            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
            var shapeSettings = obj['shapeSettingsObj'];
            var shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings };
            parent.trigger('shapeChanging', shapeChangingArgs);
            parent.editCompleteArgs = shapeChangingArgs;
            this.drawShapeTextEvent(shapeChangingArgs);
            if (degree) {
                parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
                parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
            }
            if (text && text.indexOf('\n') > -1 && parent.isPublicMethod) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var fontSizeInd = String(parent.fontSizeColl.findIndex(function (item) { return item.text === String(parent.activeObj.textSettings.fontSize); }) + 1);
                parent.noPushUndo = true;
                parent.updateFontSize('5');
                if (parseInt(fontSizeInd, 10) > 0) {
                    parent.updateFontSize(fontSizeInd);
                }
                parent.noPushUndo = false;
            }
            if (parent.isPublicMethod && !isSelected) {
                parent.notify('undo-redo', { prop: 'updateUndoRedo', value: { operation: 'shapeInsert' }, onPropertyChange: false });
            }
            parent.isPublicMethod = false;
        }
    };
    Shape.prototype.drawShapeImageEvent = function (shapeChangingArgs, isSelect) {
        var parent = this.parent;
        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        parent.objColl.push(parent.activeObj);
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'shapeInsert', previousObj: this.prevObj, previousObjColl: this.prevObj.objColl,
                previousPointColl: this.prevObj.pointColl, previousSelPointColl: this.prevObj.selPointColl, previousCropObj: prevCropObj,
                previousText: null, currentText: null, previousFilter: null, isCircleCrop: null } });
        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
            value: { obj: parent.objColl[parent.objColl.length - 1] } });
        if (isSelect) {
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
            parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
        }
        else {
            parent.okBtn(null, true);
        }
        parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });
    };
    Shape.prototype.setTransformColl = function (transformCollection) {
        var parent = this.parent;
        parent.activeObj.rotateFlipColl = [];
        if (transformCollection) {
            for (var i = 0; i < transformCollection.length; i++) {
                if (transformCollection[i].degree) {
                    parent.activeObj.rotateFlipColl.push(transformCollection[i].degree);
                }
                else {
                    parent.activeObj.rotateFlipColl.push(transformCollection[i].flip.toLowerCase());
                }
            }
        }
    };
    Shape.prototype.drawShapeTextEvent = function (shapeChangingArgs) {
        var parent = this.parent;
        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
        this.addLetter(parent.activeObj.textSettings.text);
        parent.activeObj.textFlip = parent.transform.currFlipState;
        this.updateFontRatio(parent.activeObj);
        parent.objColl.push(parent.activeObj);
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'shapeInsert', previousObj: this.prevObj, previousObjColl: this.prevObj.objColl,
                previousPointColl: this.prevObj.pointColl, previousSelPointColl: this.prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null, currentText: null, previousFilter: null, isCircleCrop: null } });
        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
            value: { obj: parent.objColl[parent.objColl.length - 1] } });
        parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
        parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });
        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
    };
    Shape.prototype.initializeTextShape = function (text, fontFamily, fontSize, bold, italic, strokeColor, fillColor, outlineColor, outlineWidth) {
        var parent = this.parent;
        this.keyHistory = '';
        parent.upperCanvas.style.display = 'block';
        parent.activeObj.strokeSettings.strokeColor = strokeColor || parent.activeObj.strokeSettings.strokeColor;
        parent.activeObj.strokeSettings.fillColor = fillColor || parent.activeObj.strokeSettings.fillColor;
        parent.activeObj.textSettings.text = text || parent.activeObj.textSettings.text;
        parent.activeObj.textSettings.fontFamily = fontFamily || parent.activeObj.textSettings.fontFamily;
        parent.activeObj.textSettings.fontSize = fontSize || parent.activeObj.textSettings.fontSize;
        parent.activeObj.textSettings.bold = bold || parent.activeObj.textSettings.bold;
        parent.activeObj.textSettings.italic = italic || parent.activeObj.textSettings.italic;
        parent.activeObj.strokeSettings.outlineColor = outlineColor || parent.activeObj.strokeSettings.outlineColor;
        parent.activeObj.strokeSettings.outlineWidth = outlineWidth || parent.activeObj.strokeSettings.outlineWidth;
    };
    Shape.prototype.drawImage = function (x, y, width, height, src, degree, isAspectRatio, opacity, isSelected) {
        this.initializeShape('image');
        this.onLoadImgShape(x, y, width, height, src, null, degree, isAspectRatio, opacity, isSelected);
    };
    Shape.prototype.redrawActObj = function (x, y, isMouseDown) {
        var splitWords;
        var parent = this.parent;
        if (parent.activeObj.shape) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] !== 'crop')) {
            if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
                parent.notify('selection', { prop: 'setTextBoxStylesToActObj', onPropertyChange: false });
                this.updateFontRatio(parent.activeObj, true);
                if (x && y) {
                    if ((x !== parent.activeObj.activePoint.startX) && (y !== parent.activeObj.activePoint.startY)) {
                        this.updateTextFromTextArea();
                    }
                }
                else {
                    this.updateTextFromTextArea();
                    parent.textArea.style.transform = '';
                    parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                }
                this.refreshActiveObj();
            }
            else {
                this.applyActObj(isMouseDown);
            }
        }
    };
    Shape.prototype.apply = function (shape, obj, canvas) {
        var parent = this.parent;
        if (!parent.disabled) {
            if (parent.togglePen && !parent.currObjType.isCustomCrop) {
                var destLeft = parent.img.destLeft;
                var destTop = parent.img.destTop;
                var destWidth = parent.img.destWidth;
                var destHeight = parent.img.destHeight;
                parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
                var temp = this.lowerContext.filter;
                this.lowerContext.filter = 'none';
                parent.togglePen = false;
                if (parent.isCircleCrop || (parent.currSelectionPoint &&
                    parent.currSelectionPoint.shape === 'crop-circle')) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                parent.img.destLeft = destLeft;
                parent.img.destTop = destTop;
                parent.img.destWidth = destWidth;
                parent.img.destHeight = destHeight;
                this.lowerContext.filter = temp;
            }
            else {
                canvas = canvas ? canvas : 'original';
                if (isNullOrUndefined(parent.activeObj.shape) && isNullOrUndefined(shape)) {
                    parent.currObjType.shape = '';
                }
                else {
                    parent.currObjType.shape = shape || parent.currObjType.shape;
                }
                if (parent.currObjType.shape !== '') {
                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    if (parent.activeObj.shape === 'text') {
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: canvas, obj: obj, isCropRatio: null,
                                points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
                    }
                    else {
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: canvas, obj: obj } });
                    }
                    parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
                    if (!shape && parent.currObjType.shape !== '' && !parent.currObjType.isCustomCrop) {
                        parent.objColl.push(extend({}, parent.activeObj, {}, true));
                    }
                    this.keyHistory = '';
                }
            }
        }
    };
    Shape.prototype.setCenterPoints = function (text, width, height) {
        var parent = this.parent;
        var renderWidth;
        var renderHeight;
        if (text && width && height) {
            renderWidth = width;
            renderHeight = height;
        }
        else {
            renderWidth = parent.activeObj.activePoint.width;
            renderHeight = parent.activeObj.activePoint.height;
        }
        parent.activeObj.activePoint.startX = (parent.lowerCanvas.width / 2) - renderWidth / 2;
        parent.activeObj.activePoint.startY = (parent.lowerCanvas.height / 2) - renderHeight / 2;
        parent.activeObj.activePoint.endX = (parent.lowerCanvas.width / 2) + renderWidth / 2;
        parent.activeObj.activePoint.endY = (parent.lowerCanvas.height / 2) + renderHeight / 2;
    };
    Shape.prototype.updSelChangeEventArgs = function (selectionSettings) {
        var parent = this.parent;
        parent.activeObj.activePoint = { startX: selectionSettings.startX, startY: selectionSettings.startY,
            endX: parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width,
            endY: parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height,
            width: selectionSettings.width, height: selectionSettings.height };
        parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
        parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
    };
    Shape.prototype.updateShapeChangeEventArgs = function (shapeSettings, allowShapeOverflow) {
        var parent = this.parent;
        var shapeId;
        if (shapeSettings.id && shapeSettings.id.indexOf('shape_') === -1 &&
            shapeSettings.id.indexOf('pen_') === -1) {
            if (parent.activeObj.currIndex) {
                parent.activeObj.currIndex = 'shape_' + shapeSettings.id;
            }
            else {
                parent.pointColl[shapeId].id = 'pen_' + shapeSettings.id;
            }
        }
        if (shapeSettings.id && shapeSettings.id.split('_')[0] && shapeSettings.id.split('_')[0] === 'pen') {
            shapeId = parseInt(shapeSettings.id.split('_')[1], 10) - 1;
            parent.pointColl[shapeId].points = shapeSettings.points;
            parent.pointColl[shapeId].strokeColor = shapeSettings.strokeColor;
            parent.pointColl[shapeId].strokeWidth = shapeSettings.strokeWidth;
            parent.pointColl[shapeId].opacity = shapeSettings.opacity;
            parent.pointColl[shapeId].order = shapeSettings.index;
        }
        else {
            parent.activeObj.activePoint.startX = shapeSettings.startX;
            parent.activeObj.activePoint.startY = shapeSettings.startY;
            if (shapeSettings.width && shapeSettings.height) {
                parent.activeObj.activePoint.width = shapeSettings.width;
                parent.activeObj.activePoint.height = shapeSettings.height;
                parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
                parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
            }
            if (parent.activeObj.shape !== 'text') {
                parent.activeObj.strokeSettings.strokeColor = shapeSettings.strokeColor;
                parent.activeObj.strokeSettings.strokeWidth = shapeSettings.strokeWidth;
            }
            parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;
            parent.activeObj.opacity = shapeSettings.opacity;
            parent.activeObj.order = shapeSettings.index;
            parent.activeObj.preventShapeDragOut = !allowShapeOverflow;
            if (isNullOrUndefined(shapeSettings.degree)) {
                shapeSettings.degree = 0;
            }
            switch (parent.activeObj.shape) {
                case 'ellipse':
                    parent.activeObj.activePoint.width = shapeSettings.radiusX * 2;
                    parent.activeObj.activePoint.height = shapeSettings.radiusY * 2;
                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
                    parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
                    if (shapeSettings.degree) {
                        parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
                    }
                    break;
                case 'line':
                case 'arrow':
                    parent.activeObj.activePoint.width = shapeSettings.length;
                    parent.activeObj.activePoint.endX = shapeSettings.endX;
                    parent.activeObj.activePoint.endY = shapeSettings.endY;
                    parent.activeObj.activePoint.width = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
                    parent.activeObj.activePoint.height = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
                    if (parent.activeObj.shape === 'arrow') {
                        parent.activeObj.start = this.getArrowType(shapeSettings.arrowHead);
                        parent.activeObj.end = this.getArrowType(shapeSettings.arrowTail);
                    }
                    break;
                case 'text':
                    parent.activeObj.keyHistory = parent.activeObj.textSettings.text = shapeSettings.text;
                    parent.activeObj.textSettings.fontSize = shapeSettings.fontSize;
                    parent.activeObj.strokeSettings.strokeColor = shapeSettings.color;
                    parent.activeObj.strokeSettings.outlineColor = shapeSettings.strokeColor;
                    parent.activeObj.strokeSettings.outlineWidth = shapeSettings.strokeWidth;
                    parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;
                    parent.activeObj.textSettings.fontFamily = shapeSettings.fontFamily;
                    this.setTransformColl(shapeSettings.transformCollection);
                    if (shapeSettings.degree) {
                        parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
                    }
                    this.updateFontRatio(parent.activeObj);
                    break;
                case 'rectangle':
                case 'image':
                    if (shapeSettings.degree) {
                        parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
                    }
                    // Prevented setting image src as it cannot be set in canvas
                    break;
                case 'path':
                    parent.activeObj.pointColl = shapeSettings.points;
                    break;
            }
            if (parent.activeObj.shape === 'text' && parent.activeObj.textSettings) {
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = false;
                parent.activeObj.textSettings.underline = false;
                for (var i = 0; i < shapeSettings.fontStyle.length; i++) {
                    switch (shapeSettings.fontStyle[i]) {
                        case 'bold':
                            parent.activeObj.textSettings.bold = true;
                            break;
                        case 'italic':
                            parent.activeObj.textSettings.italic = true;
                            break;
                    }
                }
            }
        }
    };
    Shape.prototype.addLetter = function (letter) {
        var parent = this.parent;
        if (parent.textArea.style.display === 'none' && (parent.currObjType.isText || parent.activeObj.shape === 'text')) {
            var fontSize = parent.activeObj.textSettings.fontSize;
            if (letter === 'Backspace') {
                this.keyHistory = this.keyHistory.slice(0, -1);
            }
            else {
                this.keyHistory += letter;
            }
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.updateFontStyles();
            var width = this.upperContext.measureText(this.keyHistory).width + fontSize * 0.5;
            var height = fontSize;
            this.upperContext.fillText(this.keyHistory, parent.activeObj.activePoint.startX, parent.activeObj.activePoint.startY + fontSize);
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.currObjType.isText = true;
            parent.notify('selection', { prop: 'setActivePoint', onPropertyChange: false,
                value: { startX: width, startY: height } });
        }
    };
    Shape.prototype.redrawText = function () {
        var parent = this.parent;
        var _a = parent.activeObj.textSettings, fontSize = _a.fontSize, fontFamily = _a.fontFamily, bold = _a.bold, italic = _a.italic;
        var fontStyle = '';
        if (bold) {
            fontStyle += 'bold ';
        }
        if (italic) {
            fontStyle += 'italic ';
        }
        this.upperContext.font = fontStyle + fontSize + 'px ' + fontFamily;
        var rows = parent.activeObj.keyHistory.split('\n');
        var text = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') ?
            this.getMaxText(true) : this.getMaxText();
        var width = this.upperContext.measureText(text).width + fontSize * 0.5;
        var height = rows.length * fontSize;
        if (rows.length > 1) {
            height += (fontSize * 0.50);
        }
        parent.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,
            value: { width: width, height: height } });
        parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,
                isMouseMove: null, x: null, y: null } });
        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
            value: { obj: parent.activeObj } });
    };
    Shape.prototype.updateTextFromTextArea = function () {
        var parent = this.parent;
        var allowUndoRedo = false;
        var fontSize = parent.activeObj.textSettings.fontSize;
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (parent.activeObj.keyHistory !== parent.textArea.value) {
            allowUndoRedo = true;
        }
        parent.activeObj.keyHistory = parent.textArea.value;
        parent.textArea.style.display = 'none';
        parent.textArea.value = '';
        this.updateFontStyles();
        var width = this.upperContext.measureText(parent.activeObj.keyHistory).width + fontSize * 0.5;
        var height = fontSize;
        var rows = parent.activeObj.keyHistory.split('\n');
        if (rows.length > 1) {
            height *= rows.length;
            height += (fontSize * 0.1 * rows.length);
            var widthColl = [];
            for (var i = 0, len = rows.length; i < len; i++) {
                widthColl.push(this.upperContext.measureText(rows[i]).width + fontSize * 0.5);
            }
            width = Math.max.apply(Math, widthColl);
        }
        parent.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,
            value: { width: width, height: height } });
        if (parent.activeObj.rotatedAngle !== 0) {
            var width_1 = parent.activeObj.activePoint.width - tempActiveObj.activePoint.width;
            var height_1 = parent.activeObj.activePoint.height - tempActiveObj.activePoint.height;
            var value = '';
            if (width_1 > 0 && height_1 > 0) {
                value = 'widthHeight';
            }
            else if (width_1 !== 0) {
                value = 'width';
            }
            else if (height_1 !== 0) {
                value = 'height';
            }
            parent.activeObj.activePoint = extend({}, tempActiveObj.activePoint, {}, true);
            parent.notify('selection', { prop: 'adjustRotationPoints', onPropertyChange: false, value: { rectangle: parent.activeObj.activePoint,
                    x: width_1, y: height_1, angle: parent.activeObj.rotatedAngle, type: 'text', elem: value } });
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,
                isMouseMove: null, x: null, y: null } });
        this.updImgRatioForActObj();
        if (parent.activeObj.rotatedAngle !== 0) {
            parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });
        }
        if (allowUndoRedo) {
            this.apply(parent.activeObj.shape, parent.activeObj);
            parent.objColl.push(extend({}, parent.activeObj, {}, true));
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'text', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: parent.activeObj.keyHistory,
                    currentText: parent.textArea.value, previousFilter: null, isCircleCrop: null } });
        }
        else {
            this.apply(parent.activeObj.shape, parent.activeObj);
            parent.objColl.push(extend({}, parent.activeObj, {}, true));
        }
    };
    Shape.prototype.iterateObjColl = function () {
        var parent = this.parent;
        if (parent.objColl.length > 0) {
            var index = this.getSmallestIndex();
            var objColl = extend([], parent.objColl, [], true);
            while (objColl.length > 0) {
                var found = false;
                for (var i = 0; i < objColl.length; i++) {
                    var currentObj = objColl[i];
                    if (isNullOrUndefined(currentObj.order)) {
                        objColl.splice(i, 1);
                        i--;
                        continue;
                    }
                    if (currentObj.order === index) {
                        this.apply(currentObj.shape, currentObj);
                        if (currentObj.shape === 'redact' && JSON.stringify(currentObj.activePoint) === JSON.stringify(parent.activeObj.activePoint) &&
                            currentObj.redactImage !== parent.activeObj.redactImage) {
                            currentObj.redactImage = parent.activeObj.redactImage;
                            if (parent.objColl[i] && JSON.stringify(parent.objColl[i].activePoint) ===
                                JSON.stringify(currentObj.activePoint)) {
                                parent.objColl[i].redactImage = parent.activeObj.redactImage;
                            }
                        }
                        this.refreshActiveObj();
                        index++;
                        if (!this.isIndexInObjColl(index)) {
                            index++;
                        }
                        objColl.splice(i, 1);
                        found = true;
                        break; // Exit the loop to start from the beginning
                    }
                }
                if (!found) {
                    break; // If no matching order was found, exit the loop
                }
            }
        }
    };
    Shape.prototype.getSmallestIndex = function () {
        var parent = this.parent;
        var smallestIndex;
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currentObj = parent.objColl[i];
            if (isNullOrUndefined(currentObj.order)) {
                continue;
            }
            if (isNullOrUndefined(smallestIndex) || currentObj.order < smallestIndex) {
                smallestIndex = currentObj.order;
            }
        }
        return smallestIndex;
    };
    Shape.prototype.isIndexInObjColl = function (index) {
        var parent = this.parent;
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currentObj = parent.objColl[i];
            if (isNullOrUndefined(currentObj.order)) {
                continue;
            }
            if (currentObj.order === index) {
                return true;
            }
        }
        return false;
    };
    Shape.prototype.updImgRatioForActObj = function () {
        var parent = this.parent;
        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,
            width: parent.img.destWidth, height: parent.img.destHeight };
        this.straightenShapes();
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var activePoint = parent.activeObj.activePoint;
        parent.activeObj.imageRatio = { startX: ((activePoint.startX - destLeft) /
                destWidth), startY: ((activePoint.startY - destTop) / destHeight),
            endX: ((activePoint.endX - destLeft) / destWidth),
            endY: ((activePoint.endY - destTop) / destHeight),
            width: destWidth / activePoint.width, height: destHeight / activePoint.height };
        if (parent.activeObj.rotationCirclePointColl) {
            parent.activeObj.rotationCirclePointColl.ratioX = (parent.activeObj.rotationCirclePointColl.x -
                destLeft) / destWidth;
            parent.activeObj.rotationCirclePointColl.ratioY = (parent.activeObj.rotationCirclePointColl.y -
                destTop) / destHeight;
        }
        if (parent.activeObj.shape === 'path') {
            this.updatePathRatio(parent.activeObj);
        }
        else if (parent.activeObj.shape === 'arrow') {
            this.updateArrowRatio(parent.activeObj);
        }
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
    };
    Shape.prototype.zoomObjColl = function (preventApply) {
        var parent = this.parent;
        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,
            width: parent.img.destWidth, height: parent.img.destHeight };
        this.straightenShapes();
        if (parent.objColl.length > 0) {
            for (var i = 0, len = parent.objColl.length; i < len; i++) {
                var currObj = parent.objColl[i];
                if (currObj.imageRatio) {
                    currObj.activePoint.startX = (currObj.imageRatio.startX * parent.img.destWidth) + parent.img.destLeft;
                    currObj.activePoint.startY = (currObj.imageRatio.startY * parent.img.destHeight) + parent.img.destTop;
                    currObj.activePoint.endX = (currObj.imageRatio.endX * parent.img.destWidth) + parent.img.destLeft;
                    currObj.activePoint.endY = (currObj.imageRatio.endY * parent.img.destHeight) + parent.img.destTop;
                }
                currObj = this.updateWidthHeight(currObj);
                if (currObj.shape === 'text') {
                    this.updateFontSize(currObj);
                }
                else if (currObj.shape === 'line' || currObj.shape === 'arrow') {
                    currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
                    for (var n = 0, len_1 = currObj.pointColl.length; n < len_1; n++) {
                        currObj.pointColl[n].ratioX =
                            (currObj.pointColl[n].x - parent.img.destLeft) / parent.img.destWidth;
                        currObj.pointColl[n].ratioY =
                            (currObj.pointColl[n].y - parent.img.destTop) / parent.img.destHeight;
                    }
                    if (currObj.shape === 'arrow') {
                        this.updateArrowSize(currObj);
                    }
                    if (parent.transform.straighten !== 0 && (currObj.shape === 'line' || currObj.shape === 'arrow')) {
                        this.straightenShapePoints(currObj);
                    }
                }
                else if (currObj.shape === 'path') {
                    for (var l = 0, len_2 = currObj.pointColl.length; l < len_2; l++) {
                        currObj.pointColl[l].x = (currObj.pointColl[l].ratioX * parent.img.destWidth) +
                            parent.img.destLeft;
                        currObj.pointColl[l].y = (currObj.pointColl[l].ratioY * parent.img.destHeight) +
                            parent.img.destTop;
                    }
                    this.updatePathRatio(currObj);
                    if (parent.transform.straighten !== 0) {
                        this.straightenPath(currObj);
                    }
                }
                parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                        obj: currObj } });
                if (currObj.shape !== 'line' && currObj.shape !== 'arrow' && currObj.shape !== 'path' && currObj.rotatedAngle !== 0) {
                    this.setPointCollForShapeRotation(currObj);
                    currObj.rotationCirclePoint.x =
                        (currObj.rotationCirclePoint.ratioX * parent.img.destWidth) + parent.img.destLeft;
                    currObj.rotationCirclePoint.y =
                        (currObj.rotationCirclePoint.ratioY * parent.img.destHeight) + parent.img.destTop;
                    if (currObj.rotationCirclePointColl) {
                        currObj.rotationCirclePointColl.x =
                            (currObj.rotationCirclePointColl.ratioX * parent.img.destWidth) + parent.img.destLeft;
                        currObj.rotationCirclePointColl.y =
                            (currObj.rotationCirclePointColl.ratioY * parent.img.destHeight) + parent.img.destTop;
                    }
                }
            }
            if (isNullOrUndefined(preventApply)) {
                var temp = this.lowerContext.filter;
                this.lowerContext.filter = 'none';
                this.iterateObjColl();
                this.lowerContext.filter = temp;
            }
        }
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
    };
    Shape.prototype.straightenPath = function (obj) {
        var point;
        for (var j = 0, len = obj.pointColl.length; j < len; j++) {
            point = this.straightenPoints(obj.pointColl[j].x, obj.pointColl[j].y);
            obj.pointColl[j].x = point.x;
            obj.pointColl[j].y = point.y;
        }
    };
    Shape.prototype.straightenFHD = function () {
        var parent = this.parent;
        for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {
            parent.points = extend([], parent.pointColl[i].points, []);
            var len = parent.points.length;
            var point = void 0;
            for (var l = 0; l < len; l++) {
                point = this.straightenPoints(parent.points[l].x, parent.points[l].y);
                parent.points[l].x = point.x;
                parent.points[l].y = point.y;
            }
        }
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });
        for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {
            if (selPointCollObj['selPointColl'][i] && selPointCollObj['selPointColl'][i].points) {
                var len = selPointCollObj['selPointColl'][i].points.length;
                var point = void 0;
                for (var l = 0; l < len; l++) {
                    point = this.straightenPoints(selPointCollObj['selPointColl'][i].points[l].x, selPointCollObj['selPointColl'][i].points[l].y);
                    selPointCollObj['selPointColl'][i].points[l].x = point.x;
                    selPointCollObj['selPointColl'][i].points[l].y = point.y;
                }
            }
        }
        var straightenObj = { straightenPoint: null };
        parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false, value: { obj: straightenObj } });
        if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {
            var obj = { angle: 0 };
            parent.notify('freehand-draw', { prop: 'getStraightenPointAngle', onPropertyChange: false, value: { obj: obj } });
            var angle = (((parent.transform.straighten === 360 ? 0 : parent.transform.straighten) - obj['angle']) * (Math.PI / 180));
            var point = this.straightenPoints(straightenObj['straightenPoint']['x'], straightenObj['straightenPoint']['y'], angle);
            if (angle === 0) {
                point.x = straightenObj['straightenPoint']['x'];
                point.y = straightenObj['straightenPoint']['y'];
            }
            parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false, value: { x: point.x, y: point.y } });
        }
    };
    Shape.prototype.straightenPoints = function (x, y, angle) {
        var parent = this.parent;
        var center = { x: parent.img.destLeft + (parent.img.destWidth / 2), y: parent.img.destTop + (parent.img.destHeight / 2) };
        angle = angle ? angle : ((parent.transform.straighten) * (Math.PI / 180));
        var point = { x: Math.cos(angle) * (x - center.x) - Math.sin(angle) * (y - center.y) + center.x,
            y: Math.sin(angle) * (x - center.x) + Math.cos(angle) * (y - center.y) + center.y };
        return point;
    };
    Shape.prototype.straightenShapes = function () {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var straightenObj = { bool: parent.isStraightening };
        if (!straightenObj['bool'] || parent.transform.straighten === 0) {
            return;
        }
        parent.notify('draw', { prop: 'updateImgCanvasPoints' });
        var object = { points: null };
        parent.notify('draw', { prop: 'getImageCanvasPoints', value: { obj: object } });
        var center = { x: destLeft + (destWidth / 2), y: destTop + (destHeight / 2) };
        var angle = -((parent.transform.straighten) * (Math.PI / 180));
        var p1 = { x: Math.cos(angle) * (object['points'][0]['x'] - center.x) - Math.sin(angle) *
                (object['points'][0]['y'] - center.y) + center.x,
            y: Math.sin(angle) * (object['points'][0]['x'] - center.x) + Math.cos(angle) *
                (object['points'][0]['y'] - center.y) + center.y };
        var p2 = { x: Math.cos(angle) * (object['points'][1]['x'] - center.x) - Math.sin(angle) *
                (object['points'][1]['y'] - center.y) + center.x,
            y: Math.sin(angle) * (object['points'][1]['x'] - center.x) + Math.cos(angle) * (object['points'][1]['y']
                - center.y) + center.y };
        var p3 = { x: Math.cos(angle) * (object['points'][2]['x'] - center.x) - Math.sin(angle) *
                (object['points'][2]['y'] - center.y) + center.x,
            y: Math.sin(angle) * (object['points'][2]['x'] - center.x) + Math.cos(angle) * (object['points'][2]['y']
                - center.y) + center.y };
        parent.img.destWidth = p2.x - p1.x;
        parent.img.destHeight = p3.y - p2.y;
        parent.img.destLeft = p1.x;
        parent.img.destTop = p1.y;
    };
    Shape.prototype.straightenShapePoints = function (obj, isReverse) {
        var parent = this.parent;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var straightenObj = { bool: parent.isStraightening };
        if (!straightenObj['bool']) {
            return;
        }
        if (obj.shape === 'line' || obj.shape === 'arrow') {
            obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX -
                obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;
            obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY -
                obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;
            var center = { x: destLeft + (destWidth / 2), y: destTop + (destHeight / 2) };
            var angle = (isReverse ? -parent.transform.straighten : parent.transform.straighten) * (Math.PI / 180);
            var start = { x: Math.cos(angle) * (obj.activePoint.startX - center.x) - Math.sin(angle) *
                    (obj.activePoint.startY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.startX - center.x) + Math.cos(angle)
                    * (obj.activePoint.startY - center.y) + center.y };
            var end = { x: Math.cos(angle) * (obj.activePoint.endX - center.x) -
                    Math.sin(angle) * (obj.activePoint.endY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.endX - center.x) +
                    Math.cos(angle) * (obj.activePoint.endY - center.y) + center.y };
            obj.activePoint.startX = start.x;
            obj.activePoint.startY = start.y;
            obj.activePoint.endX = end.x;
            obj.activePoint.endY = end.y;
            obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX -
                obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;
            obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY -
                obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;
            parent.notify('selection', { prop: 'adjustActObjForLineArrow', onPropertyChange: false, value: { obj: obj } });
        }
    };
    Shape.prototype.redrawObj = function (degree) {
        var parent = this.parent;
        var isShape = false;
        if (parent.objColl.length > 0) {
            if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical' ||
                degree === 'horizontalVertical' || degree === 'verticalHorizontal') {
                this.updateCurrentActiveObjPoint(degree.toLowerCase());
            }
            else if (typeof (degree) === 'number') {
                this.updateCurrentActiveObjPoint(degree);
                var tempFilter = this.lowerContext.filter;
                this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                    'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
                for (var i = 0, len = parent.objColl.length; i < len; i++) {
                    var splitWords = parent.objColl[i].shape.split('-');
                    if (splitWords[0] !== 'crop') {
                        this.apply(parent.objColl[i].shape, parent.objColl[i]);
                        isShape = true;
                    }
                }
                if (isShape) {
                    parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
                }
                this.lowerContext.filter = tempFilter;
            }
        }
    };
    Shape.prototype.updateCurrentActiveObjPoint = function (degree) {
        var parent = this.parent;
        var currActObjIndex;
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        for (var index = 0, len = parent.objColl.length; index < len; index++) {
            var currObj = parent.objColl[index];
            if (parent.activeObj.shape === currObj.shape &&
                parent.activeObj.activePoint.startX === currObj.activePoint.startX &&
                parent.activeObj.activePoint.startY === currObj.activePoint.startY &&
                parent.activeObj.activePoint.endX === currObj.activePoint.endX &&
                parent.activeObj.activePoint.endY === currObj.activePoint.endY &&
                parent.activeObj.currIndex === currObj.currIndex) {
                currActObjIndex = index;
                break;
            }
        }
        if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical' ||
            degree === 'horizontalvertical' || degree === 'verticalhorizontal') {
            if (degree === 'horizontal' || degree === 'Horizontal') {
                for (var i = 0, len = parent.objColl.length; i < len; i++) {
                    var currObj = parent.objColl[i];
                    if (currObj.shapeFlip !== parent.transform.currFlipState) {
                        if (currObj.activePoint.startX <= destLeft + (destWidth / 2)) {
                            currObj.activePoint.endX = (destLeft + destWidth) - (currObj.activePoint.startX - destLeft);
                            currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        else if (currObj.activePoint.startX >= destLeft + (destWidth / 2)) {
                            currObj.activePoint.startX = destLeft + (destLeft + destWidth - currObj.activePoint.endX);
                            currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        if (currObj.shape === 'line' || currObj.shape === 'arrow' || currObj.shape === 'path') {
                            this.flipLineArrowObj(currObj, 'horizontal');
                        }
                        else if (currObj.rotatedAngle !== 0) {
                            currObj.rotatedAngle = currObj.rotatedAngle + (Math.PI - currObj.rotatedAngle) * 2;
                            if (currObj.rotationCirclePointColl.x <= destLeft + (destWidth / 2)) {
                                currObj.rotationCirclePointColl.x = (destLeft + destWidth) -
                                    (currObj.rotationCirclePointColl.x - destLeft);
                            }
                            else if (currObj.rotationCirclePointColl.x >= destLeft + (destWidth / 2)) {
                                currObj.rotationCirclePointColl.x = destLeft +
                                    (destLeft + destWidth - currObj.rotationCirclePointColl.x);
                            }
                            currObj.rotationCirclePointColl.ratioX =
                                (currObj.rotationCirclePointColl.x - destLeft) / destWidth;
                        }
                        currObj.shapeFlip = parent.transform.currFlipState;
                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),
                            startY: ((currObj.activePoint.startY - destTop) / destHeight),
                            endX: ((currObj.activePoint.endX - destLeft) / destWidth),
                            endY: ((currObj.activePoint.endY - destTop) / destHeight),
                            width: destWidth / currObj.activePoint.width,
                            height: destHeight / currObj.activePoint.height };
                    }
                }
            }
            else if (degree === 'vertical' || degree === 'Vertical') {
                for (var i = 0; i < parent.objColl.length; i++) {
                    var currObj = parent.objColl[i];
                    if (currObj.shapeFlip !== parent.transform.currFlipState) {
                        if (currObj.activePoint.startY <= destTop + (destHeight / 2)) {
                            currObj.activePoint.endY = (destTop + destHeight) - (currObj.activePoint.startY - destTop);
                            currObj.activePoint.startY = currObj.activePoint.endY - currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                                    obj: currObj } });
                        }
                        else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {
                            currObj.activePoint.startY = destTop + (destTop + destHeight - currObj.activePoint.endY);
                            currObj.activePoint.endY = currObj.activePoint.startY + currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                                    obj: currObj } });
                        }
                        if (currObj.shape === 'line' || currObj.shape === 'arrow' ||
                            currObj.shape === 'path') {
                            this.flipLineArrowObj(currObj, 'vertical');
                        }
                        else if (currObj.rotatedAngle !== 0) {
                            currObj.rotatedAngle = -currObj.rotatedAngle;
                            if (currObj.rotationCirclePointColl.y <= destTop + (destHeight / 2)) {
                                currObj.rotationCirclePointColl.y = (destTop + destHeight) - (currObj.rotationCirclePointColl.y - destTop);
                            }
                            else if (currObj.rotationCirclePointColl.y >= destTop +
                                (destHeight / 2)) {
                                currObj.rotationCirclePointColl.y = destTop + (destTop + destHeight - currObj.rotationCirclePointColl.y);
                            }
                            currObj.rotationCirclePointColl.ratioY =
                                (currObj.rotationCirclePointColl.y - destTop) / destHeight;
                        }
                        currObj.shapeFlip = parent.transform.currFlipState;
                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),
                            startY: ((currObj.activePoint.startY - destTop) / destHeight),
                            endX: ((currObj.activePoint.endX - destLeft) / destWidth),
                            endY: ((currObj.activePoint.endY - destTop) / destHeight),
                            width: destWidth / currObj.activePoint.width,
                            height: destHeight / currObj.activePoint.height };
                    }
                }
            }
            else if (degree === 'verticalhorizontal' || degree === 'horizontalvertical') {
                for (var i = 0, len = parent.objColl.length; i < len; i++) {
                    var currObj = parent.objColl[i];
                    if (currObj.shapeFlip !== parent.transform.currFlipState) {
                        if (currObj.activePoint.startX <= destLeft + (destWidth / 2)) {
                            currObj.activePoint.endX = (destLeft + destWidth) - (currObj.activePoint.startX -
                                destLeft);
                            currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        else if (currObj.activePoint.startX >= destLeft + (destWidth / 2)) {
                            currObj.activePoint.startX = destLeft + (destLeft +
                                destWidth - currObj.activePoint.endX);
                            currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        if (currObj.activePoint.startY <= destTop + (destHeight / 2)) {
                            currObj.activePoint.endY = (destTop + destHeight) -
                                (currObj.activePoint.startY - destTop);
                            currObj.activePoint.startY = currObj.activePoint.endY -
                                currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {
                            currObj.activePoint.startY = destTop + (destTop +
                                destHeight - currObj.activePoint.endY);
                            currObj.activePoint.endY = currObj.activePoint.startY +
                                currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        if (currObj.shape === 'line' || currObj.shape === 'arrow' || currObj.shape === 'path') {
                            this.flipLineArrowObj(currObj, degree);
                        }
                        currObj.shapeFlip = parent.transform.currFlipState;
                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),
                            startY: ((currObj.activePoint.startY - destTop) / destHeight),
                            endX: ((currObj.activePoint.endX - destLeft) / destWidth),
                            endY: ((currObj.activePoint.endY - destTop) / destHeight),
                            width: destWidth / currObj.activePoint.width,
                            height: destHeight / currObj.activePoint.height };
                    }
                }
            }
            if (currActObjIndex !== undefined) {
                parent.activeObj = extend({}, parent.objColl[currActObjIndex], {}, true);
            }
        }
        else if (degree === 90) {
            this.rotateObjColl();
        }
        else if (degree === -90) {
            for (var i = 0; i < 3; i++) {
                this.rotateObjColl();
            }
        }
        else if (typeof (degree) === 'number') {
            if (degree > 0) {
                this.rotateObjColl();
            }
            else {
                for (var i = 0; i < 3; i++) {
                    this.rotateObjColl();
                }
            }
        }
    };
    Shape.prototype.rotateObjColl = function () {
        var parent = this.parent;
        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currObj = parent.objColl[i];
            var shape = currObj.shape;
            currObj.activePoint.startY = destTop + (destHeight * currObj.imageRatio.startX);
            currObj.activePoint.endY = destTop + (destHeight * currObj.imageRatio.endX);
            currObj.activePoint.startX = (destLeft + destWidth) - (destWidth * currObj.imageRatio.endY);
            currObj.activePoint.endX = (destLeft + destWidth) - (destWidth * currObj.imageRatio.startY);
            currObj = this.updateWidthHeight(parent.objColl[i]);
            this.updateFontSize(currObj);
            if (shape === 'line' || shape === 'arrow' || shape === 'path') {
                this.rotateLineArrowObj(currObj);
                if (shape === 'arrow') {
                    this.updateArrowSize(currObj);
                }
            }
            else if (currObj.rotatedAngle !== 0) {
                currObj.rotationCirclePointColl.y = destTop + (destHeight * currObj.rotationCirclePointColl.ratioX);
                currObj.rotationCirclePointColl.x = (destLeft + destWidth) -
                    (destWidth * currObj.rotationCirclePointColl.ratioY);
                currObj.rotationCirclePointColl.ratioX = (currObj.rotationCirclePointColl.x - destLeft) / destWidth;
                currObj.rotationCirclePointColl.ratioY = (currObj.rotationCirclePointColl.y - destTop) / destHeight;
            }
        }
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.objColl[i].activePoint, obj: parent.objColl[i] } });
        }
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currObj = parent.objColl[i];
            currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),
                startY: ((currObj.activePoint.startY - destTop) / destHeight),
                endX: ((currObj.activePoint.endX - destLeft) / destWidth),
                endY: ((currObj.activePoint.endY - destTop) / destHeight),
                width: destWidth / currObj.activePoint.width,
                height: destHeight / currObj.activePoint.height };
        }
    };
    Shape.prototype.rotateLineArrowObj = function (obj) {
        if (isNullOrUndefined(obj.pointColl)) {
            return;
        }
        var parent = this.parent;
        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
        if (obj.pointColl.length > 0) {
            for (var n = 0; n < obj.pointColl.length; n++) {
                obj.pointColl[n].y = destTop + (destHeight * obj.pointColl[n].ratioX);
                obj.pointColl[n].x = (destLeft + destWidth) - (destWidth *
                    obj.pointColl[n].ratioY);
            }
            for (var n = 0; n < obj.pointColl.length; n++) {
                obj.pointColl[n].ratioX = (obj.pointColl[n].x - destLeft) / destWidth;
                obj.pointColl[n].ratioY = (obj.pointColl[n].y - destTop) / destHeight;
            }
            var prevPoint = void 0;
            if (isNullOrUndefined(obj.pointColl[obj.pointColl.length - 2])) {
                prevPoint = { x: 0, y: 0 };
            }
            else {
                prevPoint = { x: obj.pointColl[obj.pointColl.length - 2].x, y: obj.pointColl[obj.pointColl.length - 2].y };
            }
            var diffX = obj.pointColl[obj.pointColl.length - 1].x - prevPoint.x;
            var diffY = obj.pointColl[obj.pointColl.length - 1].y - prevPoint.y;
            obj.activePoint.startX = obj.pointColl[0].x;
            obj.activePoint.startY = obj.pointColl[0].y;
            obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x + (diffX / 2);
            obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y + (diffY / 2);
            obj = this.updateWidthHeight(obj);
        }
    };
    Shape.prototype.flipLineArrowObj = function (obj, value) {
        value = value.toLowerCase();
        if (isNullOrUndefined(obj.pointColl)) {
            return;
        }
        if (value === 'horizontal') {
            this.lineArrowHorizontalFlip(obj);
        }
        else if (value === 'vertical') {
            this.lineArrowVerticalFlip(obj);
        }
        else {
            this.lineArrowHorizontalFlip(obj);
            obj.shapeFlip = '';
            this.lineArrowVerticalFlip(obj);
        }
        obj.activePoint.startX = obj.pointColl[0].x;
        obj.activePoint.startY = obj.pointColl[0].y;
        obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x;
        obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y;
        if (obj.activePoint.startX > obj.activePoint.endX) {
            var temp = obj.activePoint.startX;
            obj.activePoint.startX = obj.activePoint.endX;
            obj.activePoint.endX = temp;
            temp = obj.activePoint.startY;
            obj.activePoint.startY = obj.activePoint.endY;
            obj.activePoint.endY = temp;
        }
    };
    Shape.prototype.lineArrowHorizontalFlip = function (obj) {
        var parent = this.parent;
        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
        if (obj.shapeFlip !== parent.transform.currFlipState) {
            for (var l = 0, len = obj.pointColl.length; l < len; l++) {
                var currPoint = obj.pointColl[l];
                if (currPoint.x <= destLeft + (destWidth / 2)) {
                    currPoint.x = (destLeft + destWidth) - (currPoint.x - destLeft);
                }
                else if (currPoint.x >= destLeft + (destWidth / 2)) {
                    currPoint.x = destLeft + (destLeft + destWidth - currPoint.x);
                }
                currPoint.ratioX = (currPoint.x - destLeft) / destWidth;
                currPoint.ratioY = (currPoint.y - destTop) / destHeight;
            }
            if (obj.shape === 'arrow') {
                var value = obj.start;
                obj.start = obj.end;
                obj.end = value;
            }
            obj.shapeFlip = parent.transform.currFlipState;
        }
    };
    Shape.prototype.lineArrowVerticalFlip = function (obj) {
        var parent = this.parent;
        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
        if (obj.shapeFlip !== parent.transform.currFlipState) {
            for (var l = 0, len = obj.pointColl.length; l < len; l++) {
                var currPoint = obj.pointColl[l];
                if (currPoint.y <= destTop + (destHeight / 2)) {
                    currPoint.y = (destTop + destHeight) - (currPoint.y - destTop);
                }
                else if (currPoint.y >= destTop + (destHeight / 2)) {
                    currPoint.y = destTop + (destTop + destHeight - currPoint.y);
                }
                currPoint.ratioX = (currPoint.x - destLeft) / destWidth;
                currPoint.ratioY = (currPoint.y - destTop) / destHeight;
            }
            obj.shapeFlip = parent.transform.currFlipState;
        }
    };
    Shape.prototype.getRotDegOfShape = function (obj, value) {
        var parent = this.parent;
        var degree;
        if (obj.shapeDegree === 0) {
            degree = this.parent.transform.degree;
        }
        else {
            degree = this.parent.transform.degree - obj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        var transformObj = { bool: false };
        parent.notify('selection', { prop: 'getTransformedShape', onPropertyChange: false, value: { obj: transformObj } });
        if (transformObj['bool'] && !value && parent.activeObj.rotateFlipColl) {
            degree = 0;
            for (var i = 0; i < parent.activeObj.rotateFlipColl.length; i++) {
                if (typeof (parent.activeObj.rotateFlipColl[i]) === 'number') {
                    degree += (parent.activeObj.rotateFlipColl[i]);
                }
            }
        }
        return degree;
    };
    Shape.prototype.renderTextArea = function (x, y, actObj) {
        var parent = this.parent;
        var shapeObj = { shapeSettingsObj: {} };
        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: shapeObj } });
        var shapeSettings = shapeObj['shapeSettingsObj'];
        var shapeChangingArgs = { cancel: false, action: 'text-edit', previousShapeSettings: shapeSettings,
            currentShapeSettings: shapeSettings };
        parent.trigger('shapeChanging', shapeChangingArgs);
        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
        var degree = this.getRotDegOfShape(parent.activeObj);
        this.transformTextArea();
        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        var zOrderElem = parent.element.querySelector('#' + parent.element.id + '_zOrderBtn');
        var dupElem = parent.element.querySelector('#' + parent.element.id + '_duplicate');
        var removeElem = parent.element.querySelector('#' + parent.element.id + '_remove');
        var editTextElem = parent.element.querySelector('#' + parent.element.id + '_editText');
        var shadowColor = actObj.strokeSettings.outlineColor;
        var outlineWidth = actObj.strokeSettings.outlineWidth;
        var shadows = [];
        if (zOrderElem) {
            zOrderElem.classList.add('e-overlay');
        }
        if (dupElem) {
            dupElem.classList.add('e-overlay');
        }
        if (removeElem) {
            removeElem.classList.add('e-overlay');
        }
        if (editTextElem) {
            editTextElem.classList.add('e-overlay');
        }
        if (actObj.strokeSettings.fillColor !== '') {
            parent.textArea.style.backgroundColor = actObj.strokeSettings.fillColor;
        }
        else {
            parent.textArea.style.backgroundColor = 'transparent';
        }
        parent.textArea.style.display = 'block';
        parent.textArea.style.left = x + 'px';
        parent.textArea.style.top = y + 'px';
        parent.textArea.style.fontFamily = actObj.textSettings.fontFamily;
        parent.textArea.style.fontSize = actObj.textSettings.fontSize + 'px';
        parent.textArea.style.color = actObj.strokeSettings.strokeColor;
        var fontSize = actObj.textSettings.fontSize;
        var baseWidth = Math.max(1, outlineWidth / 2);
        var adjustedOutlineWidth = baseWidth * (Math.floor((fontSize - 1) / 16) * 0.5 + 0.5);
        if (/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$|^[a-zA-Z]+$/.test(actObj.strokeSettings.outlineColor)) {
            for (var x_1 = -adjustedOutlineWidth; x_1 <= adjustedOutlineWidth; x_1++) {
                for (var y_1 = -adjustedOutlineWidth; y_1 <= adjustedOutlineWidth; y_1++) {
                    if (x_1 !== 0 || y_1 !== 0) {
                        shadows.push(x_1 / 2 + "px " + y_1 / 2 + "px 0 " + shadowColor);
                    }
                }
            }
            parent.textArea.style.textShadow = shadows.join(', ');
        }
        else {
            parent.textArea.style.textShadow = null;
        }
        parent.textArea.style.fontWeight = actObj.textSettings.bold ? 'bold' : 'normal';
        parent.textArea.style.fontStyle = actObj.textSettings.italic ? 'italic' : 'normal';
        parent.textArea.style.border = '2px solid ' + parent.themeColl[parent.theme]['primaryColor'];
        parent.textArea.value = actObj.keyHistory;
        parent.textArea.style.overflow = 'hidden';
        parent.textArea.style.width = 'auto';
        parent.textArea.style.height = 'auto';
        parent.textArea.focus();
        var _a = actObj.activePoint, width = _a.width, height = _a.height;
        if (degree % 90 === 0 && degree % 180 !== 0 && degree !== 0) {
            parent.textArea.style.width = height + (height * 0.25) + 'px';
            parent.textArea.style.height = width + (width * 0.25) + 'px';
        }
        else {
            parent.textArea.style.width = width + (width * 0.25) + 'px';
            parent.textArea.style.height = height + (height * 0.25) + 'px';
        }
        this.setTextBoxWidth();
        var obj = { flipColl: null };
        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });
        if (obj['flipColl'].length <= 1) {
            this.setTextBoxHeight();
        }
        if (parseFloat(parent.textArea.style.maxHeight) < parent.activeObj.textSettings.fontSize) {
            parent.textArea.style.maxHeight = parent.activeObj.textSettings.fontSize + 'px';
        }
        if (degree % 90 === 0 && degree % 180 !== 0) {
            if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destTop +
                parent.img.destHeight) {
                this.alignTextAreaIntoCanvas();
            }
        }
        else {
            if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destLeft +
                parent.img.destWidth) {
                this.alignTextAreaIntoCanvas();
            }
        }
        // Limit text area
        if (actObj.rotatedAngle !== 0) {
            var tempLeft = parseFloat(parent.textArea.style.left);
            var tempTop = parseFloat(parent.textArea.style.top);
            if (actObj.flipObjColl.length > 0) {
                var panObj = { panRegion: '' };
                var _b = parent.lowerCanvas, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;
                var center_1 = { x: 0, y: 0 };
                parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
                    value: { panObj: panObj } });
                if (panObj['panRegion'] !== '') {
                    if (panObj['panRegion'] === 'horizontal') {
                        center_1.x = clientWidth - (clientWidth / 2);
                        tempLeft = (center_1.x - tempLeft) + center_1.x;
                    }
                    else if (panObj['panRegion'] === 'vertical') {
                        center_1.y = clientHeight - (clientHeight / 2);
                        tempTop = (center_1.y - tempTop) + center_1.y;
                    }
                    else {
                        center_1 = { x: clientWidth - (clientWidth / 2), y: clientHeight - (clientHeight / 2) };
                        tempLeft = (center_1.x - tempLeft) + center_1.x;
                        tempTop = (center_1.y - tempTop) + center_1.y;
                    }
                }
            }
            var left = tempLeft + parseFloat(parent.textArea.style.width);
            var top_1 = tempTop + parseFloat(parent.textArea.style.height);
            var width1 = parseFloat(parent.textArea.style.width);
            var height1 = parseFloat(parent.textArea.style.height);
            var center = { x: left - (width1 / 2), y: top_1 - (height1 / 2) };
            var cosAngle = Math.cos(actObj.rotatedAngle);
            var sinAngle = Math.sin(actObj.rotatedAngle);
            var p1 = { x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,
                y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y };
            if (p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth &&
                // eslint-disable-next-line max-len
                p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight) {
                // eslint-disable-next-line no-self-assign
                parent.textArea.style.width = parent.textArea.style.width;
            }
            else {
                var count = 0;
                var width2 = parseFloat(parent.textArea.style.width);
                while (true) {
                    count++;
                    width1 -= 1;
                    left = tempLeft + width1;
                    center = { x: left - (width1 / 2), y: top_1 - (height1 / 2) };
                    p1 = { x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,
                        y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y };
                    if ((p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth &&
                        // eslint-disable-next-line max-len
                        p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight) ||
                        count === width2) {
                        parent.textArea.style.width = width1 + 'px';
                        break;
                    }
                }
            }
        }
        parent.notify('selection', { prop: 'clearUpperCanvas', onPropertyChange: false });
    };
    Shape.prototype.setTextBoxWidth = function (e) {
        var parent = this.parent;
        if (parent.activeObj.rotatedAngle !== 0) {
            parent.textArea.style.whiteSpace = 'nowrap';
            parent.textArea.style.textOverflow = 'ellipsis';
            parent.textArea.style.display = 'inline-block';
            return;
        }
        else {
            parent.textArea.style.whiteSpace = '';
            parent.textArea.style.textOverflow = '';
            if (parent.textArea.style.display === 'inline-block') {
                parent.textArea.style.display = 'block';
            }
        }
        var text = this.getMaxText(true);
        if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
            this.updateFontStyles(true);
        }
        else {
            this.updateFontStyles();
        }
        var textAreaWidth = (this.upperContext.measureText(text).width + (parseFloat(parent.textArea.style.fontSize) / 2));
        var letterWidth = e ? this.upperContext.measureText(String.fromCharCode(e.which)).width : 0;
        var actObj = extend({}, parent.activeObj, {}, true);
        var flip = '';
        var degree = this.getRotDegOfShape(actObj);
        if (actObj.shapeFlip !== parent.transform.currFlipState) {
            flip = '';
        }
        else {
            flip = parent.transform.currFlipState;
        }
        if ((e && parseFloat(parent.textArea.style.width) < (textAreaWidth + letterWidth)) || isNullOrUndefined(e)) {
            if (degree === 0) {
                if (flip.toLowerCase() === 'horizontal') {
                    if ((parseFloat(parent.textArea.style.left) - parent.img.destLeft) - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else if ((parent.img.destWidth - (parseFloat(parent.textArea.style.left) -
                    parent.img.destLeft)) > (textAreaWidth + letterWidth)) {
                    parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                }
            }
            else if (degree === 90) {
                if (flip.toLowerCase() === 'vertical') {
                    if ((parseFloat(parent.textArea.style.top) - parent.img.destTop) - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else if ((parent.img.destHeight - (parseFloat(parent.textArea.style.top) -
                    parent.img.destTop)) > (textAreaWidth + letterWidth)) {
                    parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                }
            }
            else if (degree === 180) {
                var textAreaLeft = parseFloat(parent.textArea.style.left);
                var destLeft = parent.img.destLeft;
                if (flip.toLowerCase() === 'horizontal') {
                    var remainingWidth = parent.img.destWidth - (textAreaLeft - destLeft);
                    if (remainingWidth > textAreaWidth + letterWidth) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else {
                    var distanceToLeft = textAreaLeft - destLeft;
                    if (distanceToLeft - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
            }
            else if (degree === 270) {
                var textAreaTop = parseFloat(parent.textArea.style.top);
                var destTop = parent.img.destTop;
                if (flip.toLowerCase() === 'vertical') {
                    var remainingHeight = parent.img.destHeight - (textAreaTop - destTop);
                    if (remainingHeight > textAreaWidth + letterWidth) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else {
                    var distanceToTop = textAreaTop - destTop;
                    if (distanceToTop - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
            }
        }
    };
    Shape.prototype.setTextBoxHeight = function () {
        var parent = this.parent;
        var textAreaTop;
        var actObj = extend({}, parent.activeObj, {}, true);
        var flip = '';
        var degree = this.getRotDegOfShape(actObj);
        if (actObj.textFlip === parent.transform.currFlipState) {
            flip = '';
        }
        else if (actObj.textFlip === '') {
            flip = parent.transform.currFlipState;
        }
        else {
            flip = actObj.textFlip;
        }
        switch (degree) {
            case 0:
                if (flip.toLowerCase() === 'vertical') {
                    parent.textArea.style.maxHeight = (parent.img.destHeight - (parent.img.destHeight -
                        parseFloat(parent.textArea.style.top))) + 'px';
                }
                else {
                    textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
                    parent.textArea.style.maxHeight = (parent.img.destHeight - textAreaTop) + 'px';
                }
                break;
            case 90:
                if (flip.toLowerCase() === 'horizontal') {
                    parent.textArea.style.maxHeight = (parent.img.destWidth - (parseFloat(parent.textArea.style.left) -
                        parent.img.destLeft)) + 'px';
                }
                else {
                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + 'px';
                }
                break;
            case 180:
                if (flip.toLowerCase() === 'vertical') {
                    textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
                    parent.textArea.style.maxHeight = (parent.img.destHeight - textAreaTop) + 'px';
                }
                else {
                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.top) - parent.img.destTop) + 'px';
                }
                break;
            case 270:
                if (flip.toLowerCase() === 'horizontal') {
                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + 'px';
                }
                else {
                    parent.textArea.style.maxHeight = parent.img.destWidth - (parseFloat(parent.textArea.style.left)
                        - parent.img.destLeft) + 'px';
                }
                break;
        }
    };
    Shape.prototype.updatePathRatio = function (obj) {
        var parent = this.parent;
        for (var i = 0, len = obj.pointColl.length; i < len; i++) {
            var currPoint = obj.pointColl[i];
            currPoint.ratioX = (currPoint.x - parent.img.destLeft) / parent.img.destWidth;
            currPoint.ratioY = (currPoint.y - parent.img.destTop) / parent.img.destHeight;
        }
    };
    Shape.prototype.stopPathDrawing = function (e, isApply) {
        var parent = this.parent;
        if (parent.activeObj.shape === 'path') {
            var obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] === 'path') {
                var prevCropObj = extend({}, parent.cropObj, {}, true);
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                var prevObj = object['currObj'];
                prevObj.objColl = extend([], parent.objColl, [], true);
                prevObj.pointColl = extend([], parent.pointColl, [], true);
                prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
                var selPointCollObj = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: selPointCollObj } });
                prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
                parent.notify('selection', { prop: 'setCurrentDrawingShape', value: { value: '' } });
                parent.currObjType.isDragging = false;
                if (e && e.type !== 'touchstart' && isNullOrUndefined(isApply)) {
                    parent.activeObj.pointColl.pop();
                }
                this.updatePathRatio(parent.activeObj);
                if (isNullOrUndefined(parent.activeObj.imageRatio)) {
                    parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                }
                parent.objColl.push(parent.activeObj);
                parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
                parent.objColl.pop();
                if (e) {
                    parent.notify('selection', { prop: 'mouseUpEventHandler', value: { e: e } });
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
                    if (parent.objColl.length > 0) {
                        var obj1 = parent.activeObj.activePoint;
                        var obj2 = parent.objColl[parent.objColl.length - 1].activePoint;
                        if (Math.floor(obj1.startX) === Math.floor(obj2.startX) &&
                            Math.floor(obj1.startY) === Math.floor(obj2.startY) &&
                            Math.floor(obj1.endX) === Math.floor(obj2.endX) &&
                            Math.floor(obj1.endY) === Math.floor(obj2.endY)) {
                            this.refreshActiveObj();
                        }
                    }
                }
                parent.notify('draw', { prop: 'setNewPath', value: { bool: true } });
                if (parent.objColl[parent.objColl.length - 1]) {
                    var shape = parent.drawingShape;
                    parent.notify('selection', { prop: 'setCurrentDrawingShape', value: { value: '' } });
                    parent.noRedact = true;
                    parent.selectShape(parent.objColl[parent.objColl.length - 1].currIndex);
                    parent.notify('selection', { prop: 'setCurrentDrawingShape', value: { value: 'path' } });
                    parent.drawingShape = shape;
                }
                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                var obj_1 = { shapeSettingsObj: {} };
                parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj_1 } });
                var shapeSettings = obj_1['shapeSettingsObj'];
                var shapeResizingArgs = { cancel: false, action: 'draw-end', previousShapeSettings: shapeSettings };
                var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: shapeSettings };
                parent.notify('selection', { prop: 'triggerShapeChange', onPropertyChange: false,
                    value: { shapeResizingArgs: shapeResizingArgs, shapeMovingArgs: shapeMovingArgs, type: 'mouse-up' } });
                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
            }
        }
    };
    Shape.prototype.findTextTarget = function (e) {
        var parent = this.parent;
        if (!e) {
            return;
        }
        if (parent.activeObj.shape !== 'text') {
            if (parent.activeObj.shape === 'path') {
                this.stopPathDrawing(e, null);
                return;
            }
            else if (e.type === 'dblclick') {
                parent.notify('selection', { prop: 'setPanDown', onPropertyChange: false, value: { panDown: null } });
                var activeObj = extend({}, parent.activeObj, {}, true);
                var objColl = extend([], parent.objColl, [], true);
                var obj = { bool: null };
                parent.notify('selection', { prop: 'findTargetObj', onPropertyChange: false,
                    value: { x: e.clientX, y: e.clientY, isCrop: false, obj: obj } });
                parent.objColl = objColl;
                if (!obj['bool'] || parent.activeObj.shape !== 'text') {
                    parent.activeObj = extend({}, activeObj, {}, true);
                    return;
                }
            }
            else {
                return;
            }
        }
        var x;
        var y;
        if (e.type === 'dblclick') {
            x = e.clientX;
            y = e.clientY;
        }
        else if (e.type === 'touchstart') {
            x = e.touches[0].clientX;
            y = e.touches[0].clientY;
            parent.notify('selection', { prop: 'setTouchEndPoint', onPropertyChange: false,
                value: { x: e.touches[0].clientX, y: e.touches[0].clientY } });
        }
        parent.notify('toolbar', { prop: 'setPreventZoomBtn', onPropertyChange: false, value: { isPrevent: true } });
        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
        parent.notify('toolbar', { prop: 'setPreventZoomBtn', onPropertyChange: false, value: { isPrevent: false } });
        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
        if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
            var bbox = parent.lowerCanvas.getBoundingClientRect();
            x -= bbox.left;
            y -= bbox.top;
            var flip = '';
            var degree = this.getRotDegOfShape(parent.activeObj);
            if (parent.activeObj.textFlip === '') {
                if (parent.activeObj.textFlip === parent.transform.currFlipState) {
                    flip = '';
                }
                else {
                    flip = parent.transform.currFlipState;
                }
            }
            else {
                if (parent.activeObj.textFlip === parent.transform.currFlipState) {
                    flip = '';
                }
                else if (parent.transform.currFlipState === '') {
                    flip = parent.activeObj.textFlip;
                }
                else {
                    flip = parent.transform.currFlipState;
                }
            }
            var temp = void 0;
            if (parent.textArea.style.display === 'none') {
                temp = extend({}, parent.activeObj, {}, true);
                for (var i = 0; i < parent.objColl.length; i++) {
                    if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {
                        parent.objColl.splice(i, 1);
                    }
                }
                this.refreshActiveObj();
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
                parent.notify('draw', { prop: 'redrawDownScale' });
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
                if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                parent.activeObj = temp;
                this.updateFontStyles();
                var actObj = extend({}, parent.activeObj, {}, true);
                var radius = actObj.topLeftCircle.radius;
                var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
                var center = { x: startX + (width / 2), y: startY +
                        (height / 2) };
                var cosAngle = Math.cos(actObj.rotatedAngle);
                var sinAngle = Math.sin(actObj.rotatedAngle);
                var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
                    y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };
                var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
                    y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };
                var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
                    y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };
                var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
                    y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };
                var obj = { position: null, x: x, y: y, x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
                    x3: p3.x, y3: p3.y, x4: p4.x, y4: p4.y };
                parent.notify('draw', { prop: 'checkPointPosition', onPropertyChange: false, value: { obj: obj } });
                if ((actObj.rotatedAngle !== 0 && (obj['position'] === 'inside' || obj['position'] === 'on')) ||
                    (actObj.rotatedAngle === 0 && x >= (actObj.activePoint.startX - (radius * 2)) &&
                        x <= (actObj.activePoint.endX + (radius * 2)) &&
                        y >= (actObj.activePoint.startY - (radius * 2)) &&
                        y <= (actObj.activePoint.endY + (radius * 2)))) {
                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    if (actObj.flipObjColl.length === 4) {
                        actObj.flipObjColl = [];
                        flip = '';
                        actObj.shapeFlip = '';
                    }
                    if (flip === '' && actObj.flipObjColl.length > 1) {
                        flip = actObj.flipObjColl[actObj.flipObjColl.length - 1];
                    }
                    if (actObj.flipObjColl.length <= 1) {
                        var points = this.setTextBoxPos(actObj, degree, flip, x, y);
                        x = points.x;
                        y = points.y;
                    }
                    else {
                        var points = this.setTextBoxPoints(actObj, degree, flip, x, y);
                        x = points.x;
                        y = points.y;
                    }
                    if (parent.activeObj.rotatedAngle !== 0) {
                        var point = this.getTextBoxPosition(parent.activeObj);
                        x = point.x;
                        y = point.y;
                        point = this.setFlipState(x, y, parent.activeObj);
                        x = point.x;
                        y = point.y;
                    }
                    this.renderTextArea(x, y, actObj);
                }
                else {
                    this.applyActObj();
                }
            }
        }
        else if ((parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')
            && this.selectedText() !== '' && e.type === 'mousedown') {
            var temp = parent.textArea.value;
            parent.textArea.value += 'a';
            parent.textArea.value = temp;
        }
        else if (parent.textArea.style.display === 'none') {
            parent.textArea.style.display = 'block';
        }
    };
    Shape.prototype.getTextBoxPosition = function (obj, object) {
        var point = { x: 0, y: 0 };
        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
        var center = { x: startX + (width / 2), y: startY + (height / 2) };
        var cosAngle = Math.cos(obj.rotatedAngle);
        var sinAngle = Math.sin(obj.rotatedAngle);
        var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };
        var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };
        var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };
        var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };
        var degree = this.getRotDegOfShape(obj);
        if (degree === 0 || degree === 360) {
            point = { x: p1.x, y: p1.y };
        }
        else if (degree === 90 || degree === -270) {
            point = { x: p2.x, y: p2.y };
        }
        else if (degree === 180 || degree === -180) {
            point = { x: p4.x, y: p4.y };
        }
        else if (degree === 270 || degree === -90) {
            point = { x: p3.x, y: p3.y };
        }
        if (object) {
            object['x'] = point.x;
            object['y'] = point.y;
        }
        return point;
    };
    Shape.prototype.setFlipState = function (x, y, obj, object) {
        var parent = this.parent;
        var panObj = { panRegion: '' };
        var _a = parent.lowerCanvas, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight;
        var center = { x: 0, y: 0 };
        parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
            value: { panObj: panObj } });
        if (panObj['panRegion'] !== '') {
            if (panObj['panRegion'] === 'horizontal') {
                center.x = clientWidth - (clientWidth / 2);
                x = (center.x - x) + center.x;
            }
            else if (panObj['panRegion'] === 'vertical') {
                center.y = clientHeight - (clientHeight / 2);
                y = (center.y - y) + center.y;
            }
            else {
                center = { x: clientWidth - (clientWidth / 2), y: clientHeight - (clientHeight / 2) };
                x = (center.x - x) + center.x;
                y = (center.y - y) + center.y;
            }
        }
        if (object) {
            object['x'] = x;
            object['y'] = y;
        }
        return { x: x, y: y };
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Shape.prototype.fileChanged = function (e) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var filesData = e.target.files[0];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var fileData = filesData;
        var fileExtension = fileData.name && fileData.name.split('.').pop().toLowerCase();
        if (fileExtension && ['jpg', 'jpeg', 'png', 'svg', 'webp'].indexOf(fileExtension) === -1) {
            this.refreshActiveObj();
            return;
        }
        // eslint-disable-next-line @typescript-eslint/tslint/config, @typescript-eslint/no-explicit-any
        var URL = window.URL;
        var url = URL.createObjectURL(e.target.files[0]);
        this.onLoadImgShape(null, null, null, null, url.toString(), true);
        document.getElementById(this.parent.element.id + '_fileUpload').value = '';
    };
    Shape.prototype.onLoadImgShape = function (x, y, width, height, url, isSelect, degree, isAspectRatio, opacity, isSelected) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        var parent = this.parent;
        if (typeof (url) === 'string') {
            this.shapeImg.src = url;
        }
        else {
            parent.inMemoryCanvas.width = url.width;
            parent.inMemoryCanvas.height = url.height;
            parent.inMemoryCanvas.getContext('2d').putImageData(url, 0, 0);
            this.shapeImg.src = parent.inMemoryCanvas.toDataURL();
        }
        this.prevObjColl();
        parent.activeObj.shape = 'image';
        this.initShapeProps();
        this.shapeImg.onload = function () {
            proxy.upperContext.drawImage(proxy.shapeImg, 0, 0, proxy.shapeImg.width, proxy.shapeImg.height);
            proxy.updateImgCanvas(isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected);
        };
    };
    Shape.prototype.updateImgCanvas = function (isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected) {
        var parent = this.parent;
        parent.activeObj.imageElement = this.shapeImg;
        parent.activeObj.imageCanvas = parent.createElement('canvas');
        var dimObj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: null } });
        if (width && height) {
            if (isAspectRatio) {
                var obj_2 = { ratio: null };
                parent.notify('selection', { prop: 'findImageRatio', onPropertyChange: false,
                    value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_2 } });
                dimObj = this.resizeImage(width, obj_2['ratio']);
            }
            else {
                dimObj = { width: width, height: height };
            }
        }
        this.updateObj(dimObj, x, y);
        parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
            value: { ctx: parent.activeObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: null, isVFlip: null } });
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: true } });
        if (width && height) {
            if (isAspectRatio) {
                var obj_3 = { ratio: null };
                parent.notify('selection', { prop: 'findImageRatio', onPropertyChange: false,
                    value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_3 } });
                dimObj = this.resizeImage(width, obj_3['ratio']);
            }
            else {
                dimObj = { width: width, height: height };
            }
        }
        if (opacity !== null && opacity !== undefined) {
            parent.activeObj.opacity = opacity;
        }
        this.updateObj(dimObj, x, y);
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        this.shapeImg = null;
        if (degree) {
            parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
            parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });
        }
        var obj = { shapeSettingsObj: {} };
        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
        var shapeSettings = obj['shapeSettingsObj'];
        var shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,
            currentShapeSettings: shapeSettings };
        parent.trigger('shapeChanging', shapeChangingArgs);
        parent.editCompleteArgs = shapeChangingArgs;
        isSelect = isSelect ? isSelect : isSelected;
        this.drawShapeImageEvent(shapeChangingArgs, isSelect);
        if (parent.isPublicMethod && !isSelected) {
            parent.notify('undo-redo', { prop: 'updateUndoRedo', onPropertyChange: false });
        }
        else if (!parent.isPublicMethod) {
            parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
        }
        parent.isPublicMethod = false;
    };
    Shape.prototype.updateObj = function (dimObj, x, y) {
        var parent = this.parent;
        parent.activeObj.activePoint.width = dimObj['width'];
        parent.activeObj.activePoint.height = dimObj['height'];
        parent.activeObj.activePoint.startX = x ? x : (parent.lowerCanvas.width / 2) - (dimObj['width'] / 2);
        parent.activeObj.activePoint.startY = y ? y : (parent.lowerCanvas.height / 2) - (dimObj['height'] / 2);
        parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + dimObj['width'];
        parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + dimObj['height'];
    };
    Shape.prototype.resizeImage = function (newWidth, aspectRatio) {
        var aspectRatioArray = aspectRatio.split(':');
        var aspectRatioWidth = parseInt(aspectRatioArray[0], 10);
        var aspectRatioHeight = parseInt(aspectRatioArray[1], 10);
        var newHeight = Math.round((newWidth * aspectRatioHeight) / aspectRatioWidth);
        return { width: newWidth, height: newHeight };
    };
    Shape.prototype.setTextBoxPos = function (actObj, degree, flip, x, y) {
        var point = { x: x, y: y };
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        flip = flip.toLowerCase();
        switch (degree) {
            case 0:
                if (flip === 'horizontal') {
                    point.x = endX;
                    point.y = startY;
                }
                else if (flip === 'vertical') {
                    point.x = startX;
                    point.y = endY;
                }
                else {
                    point.x = startX;
                    point.y = startY;
                }
                break;
            case 90:
                if (flip === 'horizontal') {
                    point.x = startX;
                    point.y = startY;
                }
                else if (flip === 'vertical') {
                    point.x = endX;
                    point.y = endY;
                }
                else {
                    point.x = endX;
                    point.y = startY;
                }
                break;
            case 180:
                if (flip === 'horizontal') {
                    point.x = startX;
                    point.y = endY;
                }
                else if (flip === 'vertical') {
                    point.x = endX;
                    point.y = startY;
                }
                else {
                    point.x = endX;
                    point.y = endY;
                }
                break;
            case 270:
                if (flip === 'horizontal') {
                    point.x = endX;
                    point.y = endY;
                }
                else if (flip === 'vertical') {
                    point.x = startX;
                    point.y = startY;
                }
                else {
                    point.x = startX;
                    point.y = endY;
                }
                break;
        }
        return point;
    };
    Shape.prototype.setTextBoxPoints = function (actObj, degree, flip, x, y) {
        var point = { x: x, y: y };
        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        flip = flip.toLowerCase();
        switch (degree) {
            case 0:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip === 'horizontal') {
                        point.x = startX;
                        point.y = startY;
                    }
                    else if (flip === 'vertical') {
                        point.x = endX;
                        point.y = endY;
                    }
                }
                else {
                    if (flip === 'horizontal') {
                        point.x = endX;
                        point.y = endY;
                    }
                    else if (flip === 'vertical') {
                        point.x = endX;
                        point.y = startY;
                    }
                }
                break;
            case 90:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip === 'horizontal') {
                        point.x = endX;
                        point.y = endY;
                    }
                    else if (flip === 'vertical') {
                        point.x = startX;
                        point.y = endY;
                    }
                }
                else {
                    if (flip === 'horizontal') {
                        point.x = startX;
                        point.y = endY;
                    }
                    else if (flip === 'vertical') {
                        point.x = startX;
                        point.y = startY;
                    }
                }
                break;
            case 180:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip === 'horizontal') {
                        point.x = startX;
                        point.y = startY;
                    }
                    else if (flip === 'vertical') {
                        point.x = startX;
                        point.y = startY;
                    }
                }
                else {
                    if (flip === 'horizontal') {
                        point.x = startX;
                        point.y = startY;
                    }
                    else if (flip === 'vertical') {
                        point.x = startX;
                        point.y = endY;
                    }
                }
                break;
            case 270:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip === 'horizontal') {
                        point.x = startX;
                        point.y = startY;
                    }
                    else if (flip === 'vertical') {
                        point.x = endX;
                        point.y = startY;
                    }
                }
                else {
                    if (flip === 'horizontal') {
                        point.x = endX;
                        point.y = startY;
                    }
                    else if (flip === 'vertical') {
                        point.x = endX;
                        point.y = endY;
                    }
                }
                break;
        }
        return point;
    };
    Shape.prototype.selectedText = function () {
        var parent = this.parent;
        var start = parent.textArea.selectionStart;
        var finish = parent.textArea.selectionEnd;
        return parent.textArea.value.substring(start, finish);
    };
    Shape.prototype.panObjColl = function (xDiff, yDiff, panRegion) {
        var parent = this.parent;
        if (parent.objColl.length > 0) {
            for (var i = 0, len = parent.objColl.length; i < len; i++) {
                var currObj = parent.objColl[i];
                if (panRegion === '') {
                    currObj.activePoint.startX += xDiff;
                    currObj.activePoint.endX += xDiff;
                    if (currObj.rotationCirclePointColl) {
                        currObj.rotationCirclePointColl.x += xDiff;
                    }
                    if (currObj.shape === 'path') {
                        for (var l = 0, len_3 = currObj.pointColl.length; l < len_3; l++) {
                            currObj.pointColl[l].x += xDiff;
                        }
                    }
                    currObj.activePoint.startY += yDiff;
                    currObj.activePoint.endY += yDiff;
                    if (currObj.rotationCirclePointColl) {
                        currObj.rotationCirclePointColl.y += yDiff;
                    }
                    if (currObj.shape === 'path') {
                        for (var l = 0; l < currObj.pointColl.length; l++) {
                            currObj.pointColl[l].y += yDiff;
                        }
                    }
                }
                currObj = this.updateWidthHeight(currObj);
                parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                        obj: currObj } });
                if (currObj.shape === 'line' || currObj.shape === 'arrow') {
                    currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
                    for (var j = 0, len_4 = currObj.pointColl.length; j < len_4; j++) {
                        currObj.pointColl[j].ratioX =
                            (currObj.pointColl[j].x - parent.img.destLeft) / parent.img.destWidth;
                        currObj.pointColl[j].ratioY =
                            (currObj.pointColl[j].y - parent.img.destTop) / parent.img.destHeight;
                    }
                }
                this.refreshActiveObj();
            }
            var temp = this.lowerContext.filter;
            this.lowerContext.filter = 'none';
            this.iterateObjColl();
            this.lowerContext.filter = temp;
            this.refreshActiveObj();
            parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
        }
    };
    Shape.prototype.updateFontStyles = function (isTextBox) {
        var parent = this.parent;
        this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
        this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
        var textStyle = '';
        if (parent.activeObj.textSettings.bold) {
            textStyle = 'bold ';
        }
        if (parent.activeObj.textSettings.italic) {
            textStyle = 'italic ';
        }
        if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
            textStyle = 'italic bold ';
        }
        var fontSize = isTextBox ? parseFloat(parent.textArea.style.fontSize) : parent.activeObj.textSettings.fontSize;
        var fontFamily = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') ?
            parent.textArea.style.fontFamily : parent.activeObj.textSettings.fontFamily;
        this.upperContext.font = textStyle + fontSize + 'px' + ' ' + fontFamily;
    };
    Shape.prototype.applyFontStyle = function (item) {
        var parent = this.parent;
        var obj = { shapeSettingsObj: {} };
        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
        var shapeSettings = obj['shapeSettingsObj'];
        this.pushActItemIntoObj();
        var objColl = extend([], parent.objColl, [], true);
        parent.objColl.pop();
        if (parent.textArea.style.display === 'none') {
            this.updateFontRatio(parent.activeObj);
        }
        else {
            this.updateFontRatio(parent.activeObj, true);
        }
        switch (item) {
            case 'default':
                this.updateFontStyle(item, objColl, 'normal', 'normal');
                break;
            case 'bold':
                this.updateFontStyle(item, objColl, 'bold', 'normal');
                break;
            case 'italic':
                this.updateFontStyle(item, objColl, 'normal', 'italic');
                break;
            case 'bolditalic':
                this.updateFontStyle(item, objColl, 'bold', 'italic');
                break;
        }
        var shapeChangedArgs = { action: 'font-style', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.fontStyle = [item];
        parent.trigger('shapeChange', shapeChangedArgs);
        parent.editCompleteArgs = shapeChangedArgs;
    };
    Shape.prototype.updateFontStyle = function (item, objColl, fontWeight, fontStyle) {
        var parent = this.parent;
        var style = parent.textArea.style;
        if (style.display === 'block' || style.display === 'inline-block') {
            if (style.fontWeight === 'normal' && fontWeight === 'bold') {
                style.fontWeight = 'bold';
            }
            else if (style.fontWeight === 'bold' && fontWeight === 'bold') {
                style.fontWeight = 'normal';
            }
            if (style.fontStyle === 'normal' && fontStyle === 'italic') {
                style.fontStyle = 'italic';
            }
            else if (style.fontStyle === 'italic' && fontStyle === 'italic') {
                style.fontStyle = 'normal';
            }
            var value = (style.fontWeight === 'normal' && style.fontStyle === 'normal' ? 'default' :
                (style.fontWeight === 'bold' && style.fontStyle === 'normal' ? 'bold' :
                    (style.fontWeight === 'normal' && style.fontStyle === 'italic' ? 'italic' : 'bolditalic')));
            var width = this.getTextAreaWidth(value);
            style.width = width + 'px';
            this.updateObjColl(item, objColl);
        }
        else {
            this.textSettings.bold = parent.activeObj.textSettings.bold = fontWeight === 'normal' ? false : true;
            this.textSettings.italic = parent.activeObj.textSettings.italic = fontStyle === 'normal' ? false : true;
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                this.redrawText();
            }
            parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
        }
    };
    Shape.prototype.updateArrowRatio = function (obj) {
        var parent = this.parent;
        var object = { arrowDimension: null };
        parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: object } });
        var length;
        if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
            length = Math.abs(obj.activePoint.width);
        }
        else {
            length = Math.abs(obj.activePoint.height);
        }
        var dimension;
        var dimensions = ['bar', 'arrow', 'arrowSolid', 'circle', 'square'];
        for (var _i = 0, dimensions_1 = dimensions; _i < dimensions_1.length; _i++) {
            dimension = dimensions_1[_i];
            var ratioX = length / object['arrowDimension'][dimension]['width'];
            var ratioY = length / object['arrowDimension'][dimension]['height'];
            object['arrowDimension'][dimension]['ratioX'] = ratioX;
            object['arrowDimension'][dimension]['ratioY'] = ratioY;
        }
    };
    Shape.prototype.updateArrowSize = function (obj) {
        var object = { arrowDimension: null };
        this.parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: object } });
        var length;
        if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
            length = Math.abs(obj.activePoint.width);
        }
        else {
            length = Math.abs(obj.activePoint.height);
        }
        var dimension;
        var dimensions = ['bar', 'arrow', 'arrowSolid', 'circle', 'square'];
        for (var _i = 0, dimensions_2 = dimensions; _i < dimensions_2.length; _i++) {
            dimension = dimensions_2[_i];
            var ratioX = object['arrowDimension'][dimension]['ratioX'];
            var ratioY = object['arrowDimension'][dimension]['ratioY'];
            object['arrowDimension'][dimension]['width'] = length / ratioX;
            object['arrowDimension'][dimension]['height'] = length / ratioY;
        }
    };
    Shape.prototype.updateFontRatio = function (obj, isTextArea) {
        var parent = this.parent;
        var text = this.getMaxText(isTextArea);
        var width = this.upperContext.measureText(text).width +
            parent.activeObj.textSettings.fontSize * 0.5;
        var height = parent.activeObj.textSettings.fontSize;
        var degree = this.getRotDegOfShape(obj);
        if (isNullOrUndefined(isTextArea)) {
            if (degree === 0 || Math.abs(degree) === 180) {
                obj.textSettings.fontRatio = width / obj.textSettings.fontSize;
            }
            else {
                obj.textSettings.fontRatio = height / obj.textSettings.fontSize;
            }
        }
        else if (isTextArea) {
            var transformObj = { bool: false };
            parent.notify('selection', { prop: 'getTransformedShape', onPropertyChange: false, value: { obj: transformObj } });
            if (!transformObj['bool'] || degree === 0 || Math.abs(degree) === 180) {
                obj.textSettings.fontRatio = width / parseFloat(parent.textArea.style.fontSize);
            }
            else {
                obj.textSettings.fontRatio = height / parseFloat(parent.textArea.style.fontSize);
            }
        }
    };
    Shape.prototype.updateFontSize = function (obj) {
        var degree = this.getRotDegOfShape(obj, true);
        if (degree === 0 || Math.abs(degree) === 180) {
            obj.textSettings.fontSize = (obj.activePoint.width / obj.textSettings.fontRatio);
        }
        else {
            obj.textSettings.fontSize = (obj.activePoint.height / obj.textSettings.fontRatio);
        }
    };
    Shape.prototype.updateObjColl = function (item, objColl) {
        var parent = this.parent;
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = objColl;
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        var tempBold = parent.activeObj.textSettings.bold;
        var tempItalic = parent.activeObj.textSettings.italic;
        switch (item) {
            case 'default':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'bold':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'italic':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = true;
                break;
            case 'bolditalic':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = true;
                break;
        }
        parent.objColl.push(parent.activeObj);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
        parent.objColl.pop();
        parent.activeObj.textSettings.bold = tempBold;
        parent.activeObj.textSettings.italic = tempItalic;
    };
    Shape.prototype.pushActItemIntoObj = function () {
        var parent = this.parent;
        if (parent.textArea.style.display === 'none') {
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                parent.objColl.push(parent.activeObj);
            }
        }
        else {
            var temp = extend({}, parent.activeObj, {}, true);
            parent.notify('selection', { prop: 'setTextBoxStylesToActObj', onPropertyChange: false });
            parent.objColl.push(parent.activeObj);
            parent.activeObj = temp;
        }
    };
    Shape.prototype.clearActObj = function () {
        var parent = this.parent;
        if (parent.textArea.style.display === 'none') {
            this.refreshActiveObj();
            this.applyActObj();
            this.refreshActiveObj();
            parent.currObjType.isCustomCrop = false;
        }
    };
    Shape.prototype.refreshActiveObj = function () {
        var parent = this.parent;
        parent.activeObj = {};
        parent.activeObj.activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        parent.activeObj.triangle = [];
        parent.activeObj.triangleRatio = [];
        parent.activeObj.order = null;
        parent.activeObj.flipObjColl = [];
        parent.activeObj.strokeSettings = this.strokeSettings;
        parent.activeObj.textSettings = this.textSettings;
        parent.activeObj.rotatedAngle = 0;
        parent.activeObj.opacity = 1;
        parent.activeObj.redactType = this.redactType;
        parent.activeObj.redactBlur = parent.tempRedactBlur;
        parent.activeObj.redactPixelate = parent.tempRedactPixel;
    };
    Shape.prototype.applyActObj = function (isMouseDown) {
        var parent = this.parent;
        var isActObj = false;
        if (parent.activeObj.shape !== undefined && parent.activeObj.shape === 'text' && parent.activeObj.keyHistory === '') {
            this.refreshActiveObj();
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        else {
            var splitWords = void 0;
            var isCropSelection = false;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords === undefined && parent.currObjType.isCustomCrop) {
                isCropSelection = true;
            }
            else if (splitWords !== undefined && splitWords[0] === 'crop') {
                isCropSelection = true;
            }
            if (parent.activeObj.shape && !isCropSelection && parent.activeObj.shape !== 'shape') {
                for (var i = 0; i < parent.objColl.length; i++) {
                    if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {
                        isActObj = true;
                        break;
                    }
                }
                if (!isActObj) {
                    if (isNullOrUndefined(parent.activeObj.currIndex)) {
                        parent.activeObj.currIndex = this.getNewShapeId();
                    }
                    if (isNullOrUndefined(parent.activeObj.order)) {
                        parent.activeObj.order = this.getNewOrder();
                    }
                    this.updImgRatioForActObj();
                    var splitWords_1 = parent.activeObj.currIndex.split('_');
                    var tempObjColl = parent.objColl.splice(0, parseInt(splitWords_1[1], 10) - 1);
                    tempObjColl.push(extend({}, parent.activeObj, {}, true));
                    for (var i = 0; i < parent.objColl.length; i++) {
                        tempObjColl.push(parent.objColl[i]);
                    }
                    parent.objColl = tempObjColl;
                    tempObjColl = [];
                    this.refreshActiveObj();
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
                    parent.currObjType.shape = '';
                    this.refreshActiveObj();
                    if (parent.isCircleCrop) {
                        parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                            value: { context: this.lowerContext, isSave: null, isFlip: null } });
                    }
                    parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                    if (isNullOrUndefined(isMouseDown)) {
                        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                        parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
                    }
                }
            }
        }
    };
    Shape.prototype.getNewShapeId = function () {
        var parent = this.parent;
        var value = parent.objColl.length + 1;
        for (var i = 0; i < parent.objColl.length; i++) {
            if (parent.objColl[i].currIndex === 'shape_' + value) {
                value++;
                i = -1;
            }
        }
        return 'shape_' + value;
    };
    Shape.prototype.getNewOrder = function () {
        var parent = this.parent;
        this.updateShapeColl();
        var value = parent.shapeColl.length + 1;
        for (var i = 0; i < parent.shapeColl.length; i++) {
            if (parent.shapeColl[i].order === value) {
                value++;
                i = -1;
            }
        }
        return value;
    };
    Shape.prototype.getHighestOrder = function () {
        var parent = this.parent;
        this.updateShapeColl();
        var value = 0;
        for (var i = 0; i < parent.shapeColl.length; i++) {
            if (parent.shapeColl[i].order > value) {
                value = parent.shapeColl[i].order;
            }
        }
        return value;
    };
    Shape.prototype.getLowestOrder = function () {
        var parent = this.parent;
        this.updateShapeColl();
        var value = 1;
        for (var i = 0; i < parent.shapeColl.length; i++) {
            if (parent.shapeColl[i].order < value) {
                value = parent.shapeColl[i].order;
            }
        }
        return value;
    };
    Shape.prototype.alignTextAreaIntoCanvas = function () {
        var parent = this.parent;
        var letters = parent.textArea.value;
        parent.textArea.value = '';
        for (var i = 0, len = letters.length; i < len; i++) {
            parent.textArea.value += letters[i];
            parent.textArea.style.height = 'auto';
            parent.textArea.style.height = parent.textArea.scrollHeight + 'px';
            this.setTextBoxWidth();
        }
    };
    Shape.prototype.transformTextArea = function () {
        var parent = this.parent;
        if (parent.activeObj.shape === 'text') {
            parent.textArea.style.transformOrigin = '0 0';
            var rotatedDegree = parent.activeObj.rotatedAngle * (180 / Math.PI);
            var scale = '';
            var degree = this.getRotDegOfShape(parent.activeObj);
            if (parent.activeObj.flipObjColl.length > 0) {
                for (var i = 0; i < parent.activeObj.flipObjColl.length; i++) {
                    if (degree !== 0 && degree % 90 === 0 && degree !== 180) {
                        scale += parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(1, -1)' :
                            'scale(-1, 1)';
                    }
                    else {
                        scale += parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(-1, 1)' :
                            'scale(1, -1)';
                    }
                    degree += rotatedDegree;
                    if (parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                        parent.textArea.style.transform = 'rotate(' + degree + 'deg)' + scale;
                    }
                    else if (parent.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                        parent.textArea.style.transform = 'rotate(' + degree + 'deg)' + scale;
                    }
                }
            }
            else {
                degree += rotatedDegree;
                parent.textArea.style.transform = 'rotate(' + degree + 'deg)';
            }
        }
    };
    Shape.prototype.getTextAreaWidth = function (item) {
        var parent = this.parent;
        var tempBold = parent.activeObj.textSettings.bold;
        var tempItalic = parent.activeObj.textSettings.italic;
        switch (item) {
            case 'default':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'bold':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'italic':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = true;
                break;
            case 'bolditalic':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = true;
                break;
        }
        var isTextArea = parent.textArea.style.display === 'none' ? false : true;
        this.updateFontStyles(isTextArea);
        var width;
        if (!isTextArea) {
            width = this.upperContext.measureText(parent.activeObj.keyHistory).width +
                parent.activeObj.textSettings.fontSize * 0.5;
        }
        else {
            width = this.upperContext.measureText(parent.textArea.value).width +
                parent.activeObj.textSettings.fontSize * 0.5;
        }
        parent.activeObj.textSettings.bold = tempBold;
        parent.activeObj.textSettings.italic = tempItalic;
        return width;
    };
    Shape.prototype.getRedactObjDetails = function (obj) {
        var parent = this.parent;
        var redactDetails = {};
        redactDetails.id = obj.currIndex;
        redactDetails.type = parent.toPascalCase(obj.redactType);
        redactDetails.startX = obj.activePoint.startX;
        redactDetails.startY = obj.activePoint.startY;
        redactDetails.width = obj.activePoint.width;
        redactDetails.height = obj.activePoint.height;
        switch (obj.redactType) {
            case 'blur':
                redactDetails.blurIntensity = obj.redactBlur;
                break;
            case 'pixelate':
                redactDetails.pixelSize = obj.redactPixelate;
                break;
        }
        return redactDetails;
    };
    Shape.prototype.getObjDetails = function (obj) {
        var parent = this.parent;
        var shapeDetails = {};
        shapeDetails.id = obj.currIndex;
        shapeDetails.type = parent.toPascalCase(obj.shape);
        shapeDetails.startX = obj.activePoint.startX;
        shapeDetails.startY = obj.activePoint.startY;
        shapeDetails.index = obj.order;
        var transformObj = { coll: null };
        switch (obj.shape) {
            case 'rectangle':
                shapeDetails.width = obj.activePoint.width;
                shapeDetails.height = obj.activePoint.height;
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.fillColor = obj.strokeSettings.fillColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
                break;
            case 'ellipse':
                shapeDetails.radius = obj.activePoint.width / 2;
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.fillColor = obj.strokeSettings.fillColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                shapeDetails.radiusX = obj.activePoint.width / 2;
                shapeDetails.radiusY = obj.activePoint.height / 2;
                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
                break;
            case 'line':
            case 'arrow':
                shapeDetails.length = obj.activePoint.width;
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                shapeDetails.endX = obj.activePoint.endX;
                shapeDetails.endY = obj.activePoint.endY;
                if (obj.shape === 'arrow') {
                    var arrowObj = { type: null };
                    parent.notify('selection', { prop: 'getArrowType', onPropertyChange: false, value: { type: obj.start, obj: arrowObj } });
                    shapeDetails.arrowHead = arrowObj['type'];
                    parent.notify('selection', { prop: 'getArrowType', onPropertyChange: false, value: { type: obj.end, obj: arrowObj } });
                    shapeDetails.arrowTail = arrowObj['type'];
                }
                break;
            case 'text':
                shapeDetails.text = obj.keyHistory;
                shapeDetails.fontSize = obj.textSettings.fontSize;
                shapeDetails.fontFamily = obj.textSettings.fontFamily;
                shapeDetails.color = obj.strokeSettings.strokeColor;
                shapeDetails.strokeColor = obj.strokeSettings.outlineColor;
                shapeDetails.fillColor = obj.strokeSettings.fillColor;
                shapeDetails.strokeWidth = obj.strokeSettings.outlineWidth;
                shapeDetails.fontStyle = [];
                if (obj.textSettings.bold) {
                    shapeDetails.fontStyle.push('bold');
                }
                if (obj.textSettings.italic) {
                    shapeDetails.fontStyle.push('italic');
                }
                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
                parent.notify('selection', { prop: 'updateTransColl', onPropertyChange: false, value: { obj: transformObj, object: obj } });
                shapeDetails.transformCollection = transformObj['coll'];
                break;
            case 'path':
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                shapeDetails.points = obj.pointColl;
                break;
            case 'image':
                shapeDetails.imageData = obj.imageCanvas.toDataURL();
                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
                shapeDetails.width = obj.activePoint.width;
                shapeDetails.height = obj.activePoint.height;
                shapeDetails.opacity = obj.opacity;
                break;
        }
        return shapeDetails;
    };
    Shape.prototype.getFreehandDrawDetails = function (index) {
        var parent = this.parent;
        var shapeDetails = {};
        shapeDetails.id = parent.pointColl[index].id;
        shapeDetails.type = ShapeType.FreehandDraw;
        shapeDetails.points = extend([], parent.pointColl[index].points);
        shapeDetails.strokeColor = parent.pointColl[index].strokeColor;
        shapeDetails.strokeWidth = parent.pointColl[index].strokeWidth;
        shapeDetails.index = parent.pointColl[index].order;
        return shapeDetails;
    };
    Shape.prototype.getShapeSetting = function (id, obj) {
        var parent = this.parent;
        var shapeDetails;
        if (!parent.disabled && parent.isImageLoaded) {
            if (parent.textArea.style.display !== 'none') {
                parent.okBtn(null, true);
            }
            else {
                this.applyActObj(true);
            }
            if (id.split('_')[0] === 'shape') {
                var obj_4;
                for (var i = 0, len = parent.objColl.length; i < len; i++) {
                    if (parent.objColl[i].currIndex === id) {
                        obj_4 = extend({}, parent.objColl[i], {}, true);
                        break;
                    }
                }
                shapeDetails = this.getObjDetails(obj_4);
            }
            else if (id.split('_')[0] === 'pen') {
                shapeDetails = this.getFreehandDrawDetails(parseInt(id.split('_')[1], 10) - 1);
            }
        }
        obj['shapeDetails'] = shapeDetails;
    };
    Shape.prototype.getShapeSettings = function (obj) {
        var parent = this.parent;
        var shapeDetailsColl = [];
        if (!parent.disabled && parent.isImageLoaded) {
            if (parent.textArea.style.display !== 'none') {
                parent.okBtn(null, true);
            }
            else {
                this.applyActObj(true);
            }
            for (var i = 0, len = parent.objColl.length; i < len; i++) {
                var shapeDetails = this.getObjDetails(parent.objColl[i]);
                shapeDetailsColl.push(shapeDetails);
            }
            for (var i = 0; i < parent.freehandCounter; i++) {
                var shapeDetails = this.getFreehandDrawDetails(i);
                shapeDetailsColl.push(shapeDetails);
            }
        }
        obj['shapeDetailsColl'] = shapeDetailsColl;
    };
    Shape.prototype.getRedactSettings = function (obj) {
        var parent = this.parent;
        var RedactDetailsColl = [];
        if (!parent.disabled && parent.isImageLoaded) {
            if (parent.textArea.style.display !== 'none') {
                parent.okBtn(null, true);
            }
            else {
                this.applyActObj(true);
            }
            for (var i = 0, len = parent.objColl.length; i < len; i++) {
                var redactDetails = this.getRedactObjDetails(parent.objColl[i]);
                RedactDetailsColl.push(redactDetails);
            }
        }
        obj['shapeDetailsColl'] = RedactDetailsColl;
    };
    Shape.prototype.isPointsInRange = function (x, y, obj) {
        var inRange = false;
        var parent = this.parent;
        if (!isNullOrUndefined(x) && !isNullOrUndefined(y) && x >= parent.img.destLeft && y >= parent.img.destTop &&
            x <= parent.img.destLeft + parent.img.destWidth && y <= parent.img.destTop + parent.img.destHeight) {
            inRange = true;
        }
        obj['inRange'] = inRange;
    };
    Shape.prototype.alignRotateFlipColl = function (collection, isRotateFlipCollection, obj) {
        collection = this.popForDefaultTransformedState(collection);
        collection = this.popForDefaultFlipState(collection);
        collection = this.popForDefaultRotateState(collection);
        if (collection.length === 0 && isRotateFlipCollection) {
            this.parent.transform.degree = 0;
            this.parent.transform.currFlipState = '';
        }
        obj['collection'] = collection;
        return collection;
    };
    Shape.prototype.popForDefaultTransformedState = function (collection) {
        var rotateRight = 0;
        var rotateleft = 0;
        var horizontal = 0;
        var vertical = 0;
        for (var i = 0; i < collection.length; i++) {
            if (collection[i] === 90 || collection[i] === 'rotateRight') {
                rotateRight++;
                rotateleft = 0;
                horizontal = 0;
                vertical = 0;
                if (rotateRight === 4) {
                    collection.pop();
                    collection.pop();
                    collection.pop();
                    collection.pop();
                }
            }
            else if (collection[i] === -90 || collection[i] === 'rotateLeft') {
                rotateleft++;
                rotateRight = 0;
                horizontal = 0;
                vertical = 0;
                if (rotateleft === 4) {
                    collection.pop();
                    collection.pop();
                    collection.pop();
                    collection.pop();
                }
            }
            else if (collection[i] === 'horizontal' || collection[i] === 'Horizontal'
                || collection[i] === 'horizontalflip') {
                horizontal++;
                rotateleft = 0;
                rotateRight = 0;
                vertical = 0;
                if (horizontal === 2) {
                    collection.pop();
                    collection.pop();
                }
            }
            else if (collection[i] === 'vertical' || collection[i] === 'Vertical'
                || collection[i] === 'verticalflip') {
                vertical++;
                horizontal = 0;
                rotateleft = 0;
                rotateRight = 0;
                if (vertical === 2) {
                    collection.pop();
                    collection.pop();
                }
            }
        }
        return collection;
    };
    Shape.prototype.popForDefaultFlipState = function (collection) {
        for (var i = 0, iLen = collection.length - 3; i < iLen; i++) {
            var isHorizontal = collection[i] === 'horizontal' || collection[i] === 'Horizontal'
                || collection[i] === 'horizontalFlip';
            var isVertical = collection[i] === 'vertical' || collection[i] === 'Vertical' ||
                collection[i] === 'verticalFlip';
            var isNextHorizontal = collection[i + 1] === 'horizontal' || collection[i + 1] === 'Horizontal' ||
                collection[i + 1] === 'horizontalFlip';
            var isNextVertical = collection[i + 1] === 'vertical' || collection[i + 1] === 'Vertical' ||
                collection[i + 1] === 'verticalFlip';
            var isNextToNextHorizontal = collection[i + 2] === 'horizontal' || collection[i + 2] === 'Horizontal' ||
                collection[i + 2] === 'horizontalFlip';
            var isNextToNextVertical = collection[i + 2] === 'vertical' || collection[i + 2] === 'Vertical' ||
                collection[i + 2] === 'verticalFlip';
            var isNextToNextToNextHorizontal = collection[i + 3] === 'horizontal' || collection[i + 3] === 'Horizontal' ||
                collection[i + 3] === 'horizontalFlip';
            if ((isHorizontal && isNextVertical && isNextToNextHorizontal && isNextToNextVertical) ||
                (isVertical && isNextHorizontal && isNextToNextVertical && isNextToNextToNextHorizontal)) {
                collection.splice(i, 4);
                i -= 4;
            }
        }
        return collection;
    };
    Shape.prototype.popForDefaultRotateState = function (collection) {
        for (var i = 0; i < collection.length - 1; i++) {
            var curr = collection[i];
            var next = collection[i + 1];
            if ((curr === 90 || curr === 'rotateRight') && (next === -90 || next === 'rotateLeft')) {
                collection.splice(i, 2);
                i -= 2;
            }
            else if ((curr === -90 || curr === 'rotateLeft') && (next === 90 || next === 'rotateRight')) {
                collection.splice(i, 2);
                i -= 2;
            }
        }
        return collection;
    };
    Shape.prototype.selectShape = function (id, obj) {
        var parent = this.parent;
        var isSelected = false;
        if (!parent.disabled && parent.isImageLoaded) {
            this.applyActObj();
            if (id.split('_')[0] === 'shape') {
                var obj_5;
                for (var i = 0, len = parent.objColl.length; i < len; i++) {
                    if (parent.objColl[i].currIndex === id) {
                        obj_5 = extend({}, parent.objColl[i], {}, true);
                        break;
                    }
                }
                if (isNullOrUndefined(obj_5)) {
                    isSelected = false;
                }
                else {
                    isSelected = true;
                    parent.activeObj = obj_5;
                    var object = { canvasFilter: null };
                    parent.notify('toolbar', { prop: 'getCanvasFilter', onPropertyChange: false, value: { obj: object } });
                    this.lowerContext.filter = object['canvasFilter'];
                    parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
                        value: { obj: parent.activeObj } });
                    if (parent.activeObj.shape === 'text') {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (parent.activeObj.shape === 'pen') {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (parent.activeObj.shape === 'redact') {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                }
            }
            else if (id.split('_')[0] === 'pen') {
                var object = { bool: false };
                parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: object } });
                if (object['bool']) {
                    parent.okBtn(null, true);
                }
                var obj_6 = { isIndex: false };
                parent.notify('freehand-draw', { prop: 'isFHDIdx', value: { index: parseInt(id.split('_')[1], 10) - 1, obj: obj_6 } });
                if (obj_6['isIndex']) {
                    isSelected = true;
                    parent.notify('freehand-draw', { prop: 'selectFhd', value: { id: id } });
                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });
                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                }
                else {
                    isSelected = false;
                }
            }
        }
        obj['isSelected'] = isSelected;
    };
    Shape.prototype.deleteShape = function (id) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (parent.activeObj.currIndex && parent.activeObj.currIndex === id) {
                parent.notify('selection', { prop: 'deleteItem', onPropertyChange: false });
            }
            else {
                this.applyActObj();
                if (id.split('_')[0] === 'shape') {
                    for (var i = 0, len = parent.objColl.length; i < len; i++) {
                        if (parent.objColl[i].currIndex === id) {
                            parent.objColl.splice(i, 1);
                            break;
                        }
                    }
                }
                else if (id.split('_')[0] === 'pen') {
                    parent.notify('freehand-draw', { prop: 'handle-freehand-draw', value: { id: id } });
                }
            }
            var object = { canvasFilter: null };
            parent.notify('toolbar', { prop: 'getCanvasFilter', onPropertyChange: false, value: { obj: object } });
            this.lowerContext.filter = object['canvasFilter'];
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        }
    };
    Shape.prototype.getMaxText = function (isTextBox, text, obj) {
        if (isNullOrUndefined(text)) {
            text = isTextBox ? this.parent.textArea.value : this.parent.activeObj.keyHistory;
            if (!text) {
                return text;
            }
        }
        var maxi;
        var rows = text.split('\n');
        var maxStr = rows[0].length;
        var maxText = rows[0];
        for (var i = 1; i < rows.length; i++) {
            maxi = rows[i].length;
            if (maxi > maxStr) {
                maxText = rows[i];
                maxStr = maxi;
            }
        }
        if (obj) {
            obj['maxText'] = maxText;
        }
        return maxText;
    };
    Shape.prototype.getLinePoints = function (x1, y1, x2, y2) {
        var points = [];
        var i;
        var j;
        if (x1 === x2) {
            if (y1 < y2) {
                i = [x1, y1];
                j = [x2, y2];
            }
            else {
                j = [x1, y1];
                i = [x2, y2];
            }
            var m = this.getSlope(i, j, true);
            var b = this.getIntercept(i, m);
            for (var y = i[1]; y <= j[1]; y++) {
                var x = m * y + b;
                points.push({ x: x, y: y });
            }
        }
        else {
            if (x1 < x2) {
                i = [x1, y1];
                j = [x2, y2];
            }
            else {
                j = [x1, y1];
                i = [x2, y2];
            }
            var m = this.getSlope(i, j, false);
            var b = this.getIntercept(i, m);
            for (var x = i[0]; x <= j[0]; x++) {
                var y = m * x + b;
                points.push({ x: x, y: y });
            }
        }
        if (Math.floor(x1) === Math.floor(x2) || (points.length < 10 && (y2 - y1 > 10 || y1 - y2 > 10))) {
            points = [];
            var lesserY = Math.min(y1, y2);
            for (var i_1 = 0; i_1 < Math.abs(Math.floor(y2) - Math.floor(y1)); i_1++) {
                points.push({ x: x1, y: lesserY + i_1 });
            }
            if (points.length > 1) {
                var prev = void 0;
                if (isNullOrUndefined(points[points.length - 2])) {
                    prev = { x: 0, y: 0 };
                }
                else {
                    prev = points[points.length - 2];
                }
                var diffX = points[points.length - 1]['x'] - prev.x;
                var diffY = points[points.length - 1]['y'] - prev.y;
                points.push({ x: points[points.length - 1]['x'] + (diffX / 2), y: points[points.length - 1]['y'] + (diffY / 2) });
            }
        }
        else if (Math.floor(y1) === Math.floor(y2) || (points.length < 10 && (x2 - x1 > 10 || x1 - x2 > 10))) {
            points = [];
            var lesserX = Math.min(x1, x2);
            for (var i_2 = 0; i_2 < Math.abs(Math.floor(x2) - Math.floor(x1)); i_2++) {
                points.push({ x: lesserX + i_2, y: y1 });
            }
            if (points.length > 1) {
                var prev = void 0;
                if (isNullOrUndefined(points[points.length - 2])) {
                    prev = { x: 0, y: 0 };
                }
                else {
                    prev = points[points.length - 2];
                }
                var diffX = points[points.length - 1]['x'] - prev.x;
                var diffY = points[points.length - 1]['y'] - prev.y;
                points.push({ x: points[points.length - 1]['x'] + (diffX / 2), y: points[points.length - 1]['y'] + (diffY / 2) });
            }
        }
        return points;
    };
    Shape.prototype.getSlope = function (a, b, isSameAxis) {
        var slope;
        if (isSameAxis) {
            if (a[1] === b[1]) {
                return null;
            }
            slope = (b[0] - a[0]) / (b[1] - a[1]);
        }
        else {
            if (a[0] === b[0]) {
                return null;
            }
            slope = (b[1] - a[1]) / (b[0] - a[0]);
        }
        return slope;
    };
    Shape.prototype.getIntercept = function (point, getSlope) {
        if (getSlope === null) {
            return point[0];
        }
        return point[1] - getSlope * point[0];
    };
    Shape.prototype.setPointCollForShapeRotation = function (obj) {
        var parent = this.parent;
        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
        var center = { x: startX + (width / 2), y: startY +
                (height / 2) };
        var cosAngle = Math.cos(obj.rotatedAngle);
        var sinAngle = Math.sin(obj.rotatedAngle);
        var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };
        var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };
        var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };
        var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };
        obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);
        obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);
        obj.horBottomLinePointColl = this.getLinePoints(p3.x, p3.y, p4.x, p4.y);
        obj.verLeftLinePointColl = this.getLinePoints(p1.x, p1.y, p3.x, p3.y);
        obj.verRightLinePointColl = this.getLinePoints(p2.x, p2.y, p4.x, p4.y);
        obj.verLeftLinePointColl.reverse();
        obj.verRightLinePointColl.reverse();
        for (var i = 0; i < obj.horTopLinePointColl.length; i++) {
            obj.horTopLinePointColl[i].ratioX = (obj.horTopLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.horTopLinePointColl[i].ratioY = (obj.horTopLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        for (var i = 0; i < obj.horBottomLinePointColl.length; i++) {
            obj.horBottomLinePointColl[i].ratioX = (obj.horBottomLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.horBottomLinePointColl[i].ratioY = (obj.horBottomLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        for (var i = 0; i < obj.verLeftLinePointColl.length; i++) {
            obj.verLeftLinePointColl[i].ratioX = (obj.verLeftLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.verLeftLinePointColl[i].ratioY = (obj.verLeftLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        for (var i = 0; i < obj.verRightLinePointColl.length; i++) {
            obj.verRightLinePointColl[i].ratioX = (obj.verRightLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.verRightLinePointColl[i].ratioY = (obj.verRightLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        if (parent.upperCanvas.style.cursor !== 'move') {
            var object = { rotationCirclePoint: null };
            parent.notify('selection', { prop: 'getTransRotationPoint', value: { obj: obj, object: object } });
            var rotationCirclePoint = object['rotationCirclePoint'];
            if (rotationCirclePoint) {
                obj.rotationCirclePointColl = { x: cosAngle * (rotationCirclePoint.x - center.x) -
                        sinAngle * (rotationCirclePoint.y - center.y) + center.x,
                    y: sinAngle * (rotationCirclePoint.x - center.x) + cosAngle
                        * (rotationCirclePoint.y - center.y) + center.y };
                obj.rotationCirclePointColl.ratioX = (obj.rotationCirclePointColl.x - parent.img.destLeft) /
                    parent.img.destWidth;
                obj.rotationCirclePointColl.ratioY = (obj.rotationCirclePointColl.y - parent.img.destTop) /
                    parent.img.destHeight;
            }
        }
    };
    Shape.prototype.getSquarePointForRotatedShape = function (obj, object) {
        var point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
        var center = { x: startX + (width / 2), y: startY + (height / 2) };
        var cosAngle = Math.cos(obj.rotatedAngle);
        var sinAngle = Math.sin(obj.rotatedAngle);
        var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };
        var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };
        var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };
        var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };
        point.startX = p1.x;
        point.startY = p1.y;
        point.endX = p1.x;
        point.endY = p1.y;
        if (point.startX > p2.x) {
            point.startX = p2.x;
        }
        if (point.startX > p3.x) {
            point.startX = p3.x;
        }
        if (point.startX > p4.x) {
            point.startX = p4.x;
        }
        if (point.startY > p2.y) {
            point.startY = p2.y;
        }
        if (point.startY > p3.y) {
            point.startY = p3.y;
        }
        if (point.startY > p4.y) {
            point.startY = p4.y;
        }
        if (point.endX < p2.x) {
            point.endX = p2.x;
        }
        if (point.endX < p3.x) {
            point.endX = p3.x;
        }
        if (point.endX < p4.x) {
            point.endX = p4.x;
        }
        if (point.endY < p2.y) {
            point.endY = p2.y;
        }
        if (point.endY < p3.y) {
            point.endY = p3.y;
        }
        if (point.endY < p4.y) {
            point.endY = p4.y;
        }
        point.width = point.endX - point.startX;
        point.height = point.endY - point.startY;
        if (object) {
            object['activePoint'] = point;
        }
        return point;
    };
    Shape.prototype.updateZOrder = function (obj, value) {
        var parent = this.parent;
        value = value.toLowerCase();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var object = obj;
        if (isNullOrUndefined(object.order)) {
            return;
        }
        var index;
        var prevIndex;
        var highestOrder = this.getHighestOrder();
        this.updateShapeColl();
        if (parent.shapeColl.length === 0) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var coll;
        for (var i = 0; i < parent.shapeColl.length; i++) {
            coll = parent.shapeColl[i];
            if (object.id && object.id.indexOf('pen') > -1) {
                if (coll.id && coll.id === object.id) {
                    parent.shapeColl.splice(i, 1);
                }
            }
            else if (coll.shape && coll.shape.indexOf('crop-') > -1) {
                parent.shapeColl.splice(i, 1);
            }
        }
        switch (value) {
            case 'sendtoback':
                prevIndex = object.order;
                index = object.order;
                object.order = 1;
                break;
            case 'sendbackward':
                object.order -= 1;
                index = object.order;
                break;
            case 'bringtofront':
                prevIndex = object.order;
                index = highestOrder;
                object.order = index;
                break;
            case 'bringforward':
                object.order += 1;
                index = object.order;
                break;
        }
        this.reArrangeObjColl(index, value, prevIndex);
        if (object.id && object.id.indexOf('pen') > -1) {
            this.reUpdateShapeColl(object);
        }
    };
    Shape.prototype.reArrangeObjColl = function (index, value, prevIndex) {
        var parent = this.parent;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var obj;
        switch (value) {
            case 'sendtoback':
                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
                    obj = parent.shapeColl[i];
                    if (obj.order < prevIndex && obj.order <= index) {
                        obj.order += 1;
                        this.reUpdateShapeColl(obj);
                    }
                }
                break;
            case 'sendbackward':
                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
                    obj = parent.shapeColl[i];
                    if (obj.order === index) {
                        obj.order += 1;
                        this.reUpdateShapeColl(obj);
                        break;
                    }
                }
                break;
            case 'bringtofront':
                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
                    obj = parent.shapeColl[i];
                    if (obj.order > prevIndex && obj.order <= index) {
                        obj.order -= 1;
                        this.reUpdateShapeColl(obj);
                    }
                }
                break;
            case 'bringforward':
                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
                    obj = parent.shapeColl[i];
                    if (obj.order === index) {
                        obj.order -= 1;
                        this.reUpdateShapeColl(obj);
                        break;
                    }
                }
                break;
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Shape.prototype.reorderRedact = function (tempObjColl) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var nonRedact = tempObjColl.filter(function (item) { return item.shape !== 'redact'; });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var redact = tempObjColl.filter(function (item) { return item.shape === 'redact'; });
        return redact.concat(nonRedact);
    };
    Shape.prototype.updateShapeColl = function () {
        var parent = this.parent;
        var isOrdered = false;
        var tempOrder = 1;
        var tempObjColl = extend([], parent.objColl, [], true);
        tempObjColl = this.reorderRedact(tempObjColl);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var tempPointColl = extend([], parent.pointColl, [], true);
        if (parent.shapeColl.length > 0 &&
            parent.shapeColl.length === parent.objColl.length + parent.pointColl.length) {
            for (var i = 0; i < parent.shapeColl.length; i++) {
                if (parent.shapeColl[i].order === tempOrder) {
                    isOrdered = true;
                    tempOrder++;
                }
                else {
                    isOrdered = false;
                    break;
                }
            }
            if (isOrdered) {
                for (var i = 0; i < parent.shapeColl.length; i++) {
                    if (parent.shapeColl[i].currIndex &&
                        parent.shapeColl[i].currIndex.indexOf('shape') > -1) {
                        for (var j = 0; j < tempObjColl.length; j++) {
                            if (parent.shapeColl[i].currIndex === tempObjColl[j].currIndex) {
                                parent.shapeColl[i] = extend({}, tempObjColl[j], {}, true);
                                tempObjColl.splice(j, 1);
                                break;
                            }
                        }
                    }
                    else if (parent.shapeColl[i].id && parent.shapeColl[i].id.indexOf('pen') > -1) {
                        for (var j = 0; j < tempPointColl.length; j++) {
                            if (parent.shapeColl[i].id === tempPointColl[j].id) {
                                parent.shapeColl[i] = extend([], tempPointColl[j], [], true);
                                tempPointColl.splice(j, 1);
                                break;
                            }
                        }
                    }
                }
                return;
            }
        }
        tempObjColl = extend([], parent.objColl, [], true);
        tempPointColl = extend([], parent.pointColl, [], true);
        parent.shapeColl = [];
        var order = 1;
        var isBreak;
        var isCrop = false;
        while (tempObjColl.length !== 0 || tempPointColl.length !== 0) {
            isBreak = isCrop = false;
            for (var i = 0; i < tempObjColl.length; i++) {
                if (tempObjColl[i].order === order ||
                    (!tempObjColl[i].order && tempObjColl[i].shape &&
                        tempObjColl[i].shape.indexOf('crop-') > -1)) {
                    parent.shapeColl.push(extend({}, tempObjColl[i], {}, true));
                    if (tempObjColl[i].shape && tempObjColl[i].shape.indexOf('crop-') > -1) {
                        isCrop = true;
                    }
                    tempObjColl.splice(i, 1);
                    isBreak = true;
                    break;
                }
            }
            if (!isBreak) {
                for (var i = 0; i < tempPointColl.length; i++) {
                    if (tempPointColl[i].order === order) {
                        parent.shapeColl.push(extend([], tempPointColl[i], [], true));
                        tempPointColl.splice(i, 1);
                        isBreak = true;
                        break;
                    }
                }
            }
            if (!isCrop) {
                order++;
            }
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Shape.prototype.reUpdateShapeColl = function (obj) {
        var parent = this.parent;
        if (obj.id && obj.id.indexOf('pen') > -1) {
            if (parent.freehandCounter > 0) {
                for (var i = 0; i < parent.freehandCounter; i++) {
                    if (parent.pointColl[i].id === obj.id) {
                        parent.pointColl[i].order = obj.order;
                    }
                }
            }
        }
        else if (obj.currIndex && obj.currIndex.indexOf('shape') > -1) {
            for (var i = 0; i < parent.objColl.length; i++) {
                if (parent.objColl[i].currIndex === obj.currIndex) {
                    parent.objColl[i].order = obj.order;
                }
            }
        }
    };
    Shape.prototype.drawAnnotations = function (ctx, shape, pen, isPreventApply, x, y, panRegion) {
        var parent = this.parent;
        var activeObj = extend({}, parent.activeObj, {}, true);
        var tempObjColl = extend([], parent.objColl, [], true);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var tempPointColl = extend([], parent.pointColl, [], true);
        var tempSelPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: tempSelPointCollObj } });
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        this.updateShapeColl();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var tempShapeColl = extend([], parent.shapeColl, [], true);
        tempShapeColl = this.reorderRedact(tempShapeColl);
        var isPrevented = false;
        if (!this.preventFrameAnnotation) {
            this.preventFrameAnnotation = isPrevented = true;
        }
        for (var i = 0; i < tempShapeColl.length; i++) {
            var isPenId = tempShapeColl[i].id;
            if ((tempShapeColl[i].order) ||
                (!tempShapeColl[i].order && tempShapeColl[i].shape && tempShapeColl[i].shape.indexOf('crop-') > -1) ||
                (!tempShapeColl[i].order && tempShapeColl[i].shape === 'path' && parent.drawingShape === 'path')) {
                if (tempShapeColl[i].currIndex && tempShapeColl[i].currIndex.indexOf('shape') > -1) {
                    parent.objColl = [];
                    parent.objColl.push(extend({}, tempShapeColl[i], {}, true));
                    if (shape === 'iterate') {
                        var temp = this.lowerContext.filter;
                        this.lowerContext.filter = 'none';
                        this.iterateObjColl();
                        this.lowerContext.filter = temp;
                    }
                    else if (shape === 'zoom' || shape === 'pan') {
                        var tempObjCollIndex = -1;
                        for (var i_3 = 0; i_3 < tempObjColl.length; i_3++) {
                            if (JSON.stringify(tempObjColl[i_3]) === JSON.stringify(parent.objColl[0])) {
                                tempObjCollIndex = i_3;
                                break;
                            }
                        }
                        if (shape === 'zoom') {
                            this.zoomObjColl(isPreventApply);
                        }
                        else {
                            this.panObjColl(x, y, panRegion);
                        }
                        if (tempObjCollIndex > -1) {
                            tempObjColl[tempObjCollIndex] = extend({}, parent.objColl[0], {}, true);
                        }
                    }
                }
                else if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf('pen') > -1) {
                    parent.pointColl = [];
                    parent.freehandCounter = 0;
                    parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false, value: { obj: { selPointColl: [] } } });
                    parent.pointColl.push(extend({}, tempShapeColl[i], {}, true));
                    parent.notify('freehand-draw', { prop: 'pushSelPointColl', onPropertyChange: false,
                        value: { obj: { selPointColl: selPointCollObj['selPointColl'][i] } } });
                    parent.freehandCounter = parent.pointColl.length;
                    if (pen === 'iterate') {
                        parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                            value: { context: ctx, points: null } });
                    }
                    else if (pen === 'zoom' || pen === 'pan') {
                        if (pen === 'zoom') {
                            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false,
                                value: { isPreventApply: isPreventApply } });
                        }
                        else {
                            parent.notify('freehand-draw', { prop: 'panFHDColl', onPropertyChange: false,
                                value: { xDiff: x, yDiff: y, panRegion: panRegion } });
                        }
                        for (var i_4 = 0; i_4 < tempPointColl.length; i_4++) {
                            if (tempPointColl[i_4].id === parent.pointColl[0].id) {
                                tempPointColl[i_4] = extend({}, parent.pointColl[0], {}, true);
                                break;
                            }
                        }
                        for (var i_5 = 0, len = tempSelPointCollObj['selPointColl'].length; i_5 < len; i_5++) {
                            if (tempSelPointCollObj['selPointColl'][i_5].id === selPointCollObj['selPointColl'][i_5].id) {
                                tempSelPointCollObj['selPointColl'][i_5] = extend({}, selPointCollObj['selPointColl'][i_5], {}, true);
                                break;
                            }
                        }
                    }
                }
            }
            else if ((!tempShapeColl[i].shape && !isPenId) ||
                (!tempShapeColl[i].currIndex && !isPenId)) {
                tempShapeColl.splice(i, 1);
            }
        }
        if (pen && pen === 'zoom') {
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: isPreventApply } });
        }
        parent.objColl = tempObjColl;
        parent.pointColl = tempPointColl;
        parent.freehandCounter = parent.pointColl.length;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false, value: { obj: { selPointColl: tempSelPointCollObj['selPointColl'] } } });
        if (isPrevented && this.preventFrameAnnotation) {
            parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
            this.preventFrameAnnotation = false;
        }
        parent.activeObj = activeObj;
    };
    return Shape;
}());

/* eslint-disable prefer-const */
var Transform = /** @class */ (function () {
    function Transform(parent) {
        this.isReverseFlip = false; // True when rotate method is called from iteration
        this.disablePan = false; // auto enable / disable pan while zooming
        this.isReverseRotate = false; // True when rotate method is called from iteration
        this.flipColl = []; // To store flip order
        this.prevZoomValue = 1;
        this.cropDimension = { width: 0, height: 0 };
        this.isPreventSelect = false;
        this.preventDownScale = false;
        this.resizedImgAngle = null;
        this.parent = parent;
        this.addEventListener();
    }
    Transform.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    Transform.prototype.addEventListener = function () {
        this.parent.on('transform', this.transform, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    Transform.prototype.removeEventListener = function () {
        this.parent.off('transform', this.transform);
        this.parent.off('destroyed', this.destroy);
    };
    Transform.prototype.transform = function (args) {
        this.initTransformPvtVar();
        switch (args.prop) {
            case 'flipImage':
                this.flipImage(args.value['direction']);
                break;
            case 'setDestPointsForFlipState':
                this.setDestPointsForFlipState();
                break;
            case 'zoomAction':
                this.zoomAction(args.value['zoomFactor'], args.value['zoomPoint'], args.value['isResize']);
                break;
            case 'disableZoomOutBtn':
                this.disableZoomOutBtn(args.value['isZoomOut']);
                break;
            case 'rotatedFlip':
                this.rotatedFlip();
                break;
            case 'drawPannedImage':
                this.drawPannedImage(args.value['xDiff'], args.value['yDiff']);
                break;
            case 'drawPannImage':
                this.drawPannImage(args.value['point']);
                break;
            case 'performTransformation':
                this.performTransformation(args.value['text']);
                break;
            case 'updateTransform':
                this.updateTransform(args.value['text']);
                break;
            case 'rotatePan':
                this.rotatePan(args.value['isCropSelection'], args.value['isDefaultZoom']);
                break;
            case 'resetZoom':
                this.resetZoom();
                break;
            case 'pan':
                this.pan(args.value['value'], args.value['x'], args.value['y']);
                break;
            case 'zoom':
                this.zoom(args.value['zoomFactor'], args.value['zoomPoint']);
                break;
            case 'setCurrPanRegion':
                this.setCurrPanRegion(args.value['region'], args.value['type'], args.value['obj']);
                break;
            case 'rotate':
                this.rotate(args.value['degree'], args.value['obj']);
                break;
            case 'flip':
                this.flip(args.value['direction']);
                break;
            case 'update':
                this.update();
                break;
            case 'calcMaxDimension':
                this.calcMaxDimension(args.value['width'], args.value['height'], args.value['obj'], args.value['isImgShape']);
                break;
            case 'getPanMove':
                args.value['obj']['panMove'] = this.panMove;
                break;
            case 'setPanMove':
                this.panMove = args.value['point'];
                break;
            case 'getTempPanMove':
                args.value['obj']['tempPanMove'] = this.tempPanMove;
                break;
            case 'setTempPanMove':
                this.tempPanMove = args.value['point'];
                break;
            case 'setReverseFlip':
                this.isReverseFlip = args.value['isReverseFlip'];
                break;
            case 'setDisablePan':
                this.disablePan = args.value['bool'];
                break;
            case 'setCurrDestinationPoint':
                this.currDestPoint = args.value['point'];
                this.currDestPoint.startX -= this.parent.cropObj.totalPannedPoint.x;
                this.currDestPoint.startY -= this.parent.cropObj.totalPannedPoint.y;
                break;
            case 'setReverseRotate':
                this.isReverseRotate = args.value['bool'];
                break;
            case 'getFlipColl':
                args.value['obj']['flipColl'] = this.flipColl;
                break;
            case 'setFlipColl':
                this.flipColl = args.value['flipColl'];
                break;
            case 'getPreviousZoomValue':
                args.value['obj']['previousZoomValue'] = this.prevZoomValue;
                break;
            case 'setPreviousZoomValue':
                this.prevZoomValue = args.value['previousZoomValue'];
                break;
            case 'getCropDimension':
                args.value['obj']['cropDimension'] = this.cropDimension;
                break;
            case 'setCropDimension':
                this.cropDimension.width = args.value['width'];
                this.cropDimension.height = args.value['height'];
                break;
            case 'getPreventSelect':
                args.value['obj']['bool'] = this.isPreventSelect;
                break;
            case 'setPreventSelect':
                this.isPreventSelect = args.value['bool'];
                break;
            case 'resizeImage':
                this.resizeImage(args.value['width'], args.value['height']);
                break;
            case 'resizeCrop':
                this.resizeCrop(args.value['width'], args.value['height']);
                break;
            case 'updateResize':
                this.updateResize();
                break;
            case 'resize':
                this.resize(args.value['width'], args.value['height'], args.value['isAspectRatio']);
                break;
            case 'straightenImage':
                this.straightenImage(args.value['degree']);
                break;
            case 'reset':
                this.reset();
                break;
            case 'cropZoom':
                args.value['obj']['maxDimension'] = this.cropZoom(args.value['value'], args.value['selectionObj']);
                break;
            case 'setResizedImgAngle':
                this.resizedImgAngle = args.value['angle'];
                break;
        }
    };
    Transform.prototype.getModuleName = function () {
        return 'transform';
    };
    Transform.prototype.initTransformPvtVar = function () {
        if (this.parent.lowerCanvas) {
            this.lowerContext = this.parent.lowerCanvas.getContext('2d');
        }
        if (this.parent.upperCanvas) {
            this.upperContext = this.parent.upperCanvas.getContext('2d');
        }
    };
    Transform.prototype.reset = function () {
        this.zoomBtnHold = null;
        this.tempPanMove = null;
        this.panMove = null;
        this.disablePan = false;
        this.currDestPoint = null;
        this.isReverseRotate = false;
        this.flipColl = [];
        this.resizedImgAngle = null;
        this.transCurrObj = null;
        this.prevZoomValue = 1;
        this.isPreventSelect = this.preventDownScale = false;
    };
    Transform.prototype.rotateImage = function (degree) {
        var parent = this.parent;
        var transitionArgs = { cancel: false, previousDegree: parent.transform.degree,
            currentDegree: Math.abs(parent.transform.degree + degree) === 360 ? 0 : parent.transform.degree + degree };
        if (!this.isPreventSelect) {
            parent.trigger('rotating', transitionArgs);
            parent.editCompleteArgs = transitionArgs;
        }
        this.rotateEvent(transitionArgs, degree);
    };
    Transform.prototype.rotateEvent = function (transitionArgs, degree) {
        var parent = this.parent;
        if (!transitionArgs.cancel) {
            var prevObj = void 0;
            if (isNullOrUndefined(this.transCurrObj)) {
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                prevObj = object['currObj'];
                prevObj.objColl = extend([], parent.objColl, null, true);
                prevObj.pointColl = extend({}, parent.pointColl, null, true);
                prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
                var selPointCollObj = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });
                prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            }
            parent.afterCropActions.push(degree === 90 ? 'rotateRight' : 'rotateLeft');
            var splitWords = [];
            var activeObjShape = void 0;
            if (parent.activeObj.activePoint && parent.activeObj.shape) {
                if (parent.activeObj.shape !== undefined) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (parent.currObjType.isCustomCrop || splitWords[0] === 'crop') {
                    activeObjShape = parent.currObjType.isCustomCrop ? 'custom' : splitWords[1];
                    parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                    parent.objColl.push(parent.activeObj);
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                }
            }
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.drawRotatedImage(degree);
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
            if (parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            if (activeObjShape) {
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
                parent.objColl.pop();
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            }
            parent.isUndoRedo = false;
            var obj = { collection: parent.rotateFlipColl };
            parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
                value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: obj } });
            parent.rotateFlipColl = obj['collection'];
            if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
                parent.notify('draw', { prop: 'setIsCropSelect', value: { bool: true } });
                this.isPreventSelect = true;
                parent.notify('draw', { prop: 'select', onPropertyChange: false,
                    value: { type: 'custom', startX: null, startY: null, width: null, height: null } });
                this.isPreventSelect = false;
                parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
                this.prevZoomValue = parent.zoomSettings.zoomFactor;
            }
        }
        else {
            parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: parent.prevEventObjPoint } });
            parent.activeObj = parent.prevEventSelectionPoint;
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
        }
    };
    Transform.prototype.drawRotatedImage = function (degree) {
        var parent = this.parent;
        if (degree === 0) {
            parent.transform.degree = 0;
        }
        else {
            parent.transform.degree += degree;
        }
        if (Math.abs(parent.transform.degree) === 360) {
            parent.transform.degree = 0;
        }
        parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        var tempObjColl = extend([], parent.objColl, [], true);
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (!this.isReverseRotate) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        }
        this.rotateDegree(degree);
        if (!this.isReverseRotate) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            parent.rotateFlipColl.push(degree);
        }
        parent.objColl = extend([], tempObjColl, [], true);
        parent.activeObj = extend({}, tempActiveObj, {}, true);
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: degree } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (degree > 0) {
            parent.notify('freehand-draw', { prop: 'rotateFhdColl', onPropertyChange: false });
        }
        else {
            for (var i = 0; i < 3; i++) {
                parent.notify('freehand-draw', { prop: 'rotateFhdColl', onPropertyChange: false });
            }
        }
        parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
            value: { context: this.lowerContext, points: null } });
        this.updateCurrSelectionPoint(degree);
    };
    Transform.prototype.rotateDegree = function (degree) {
        var parent = this.parent;
        this.lowerContext.save();
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
        this.lowerContext.rotate(Math.PI / 180 * degree);
        this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
        var temp = this.lowerContext.filter;
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        this.lowerContext.filter = temp;
        this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
        this.lowerContext.rotate(Math.PI / 180 * -degree);
        this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
        this.lowerContext.restore();
    };
    Transform.prototype.updateCurrSelectionPoint = function (degree) {
        var parent = this.parent;
        if (parent.currSelectionPoint && this.currDestPoint) {
            var activeObj = extend({}, parent.activeObj, {}, true);
            var objColl = extend([], parent.objColl, [], true);
            var srcPoints = { startX: parent.img.srcLeft, startY: parent.img.srcTop, width: parent.img.srcWidth,
                height: parent.img.srcHeight };
            var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.objColl = [];
            parent.objColl.push(extend({}, parent.currSelectionPoint, {}, true));
            parent.img = { srcLeft: 0, srcTop: 0, srcWidth: parent.baseImgCanvas.width, srcHeight: parent.baseImgCanvas.height,
                destLeft: this.currDestPoint.startX, destTop: this.currDestPoint.startY, destWidth: this.currDestPoint.width,
                destHeight: this.currDestPoint.height };
            if (typeof (degree) === 'number') {
                parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
                parent.notify('draw', { prop: 'setClientTransDim', onPropertyChange: false,
                    value: { isPreventDimension: null } });
            }
            parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: degree } });
            parent.currSelectionPoint = extend({}, parent.objColl[0], {}, true);
            this.currDestPoint = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.objColl = objColl;
            parent.activeObj = activeObj;
            parent.img = { srcLeft: srcPoints.startX, srcTop: srcPoints.startY, srcWidth: srcPoints.width, srcHeight: srcPoints.height,
                destLeft: destPoints.startX, destTop: destPoints.startY, destWidth: destPoints.width, destHeight: destPoints.height };
        }
    };
    Transform.prototype.flipImage = function (direction) {
        var parent = this.parent;
        var transitionArgs = { direction: direction, cancel: false,
            previousDirection: parent.toPascalCase(parent.transform.currFlipState || direction) };
        if (!this.isPreventSelect) {
            parent.trigger('flipping', transitionArgs);
            parent.editCompleteArgs = transitionArgs;
        }
        this.flipEvent(transitionArgs, direction);
    };
    Transform.prototype.flipEvent = function (transitionArgs, direction) {
        var parent = this.parent;
        if (transitionArgs.cancel) {
            parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: parent.prevEventObjPoint } });
            parent.activeObj = parent.prevEventSelectionPoint;
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            return;
        }
        var prevObj;
        if (isNullOrUndefined(this.transCurrObj)) {
            var object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            prevObj = object['currObj'];
            prevObj.objColl = extend([], parent.objColl, null, true);
            prevObj.pointColl = extend({}, parent.pointColl, null, true);
            prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        }
        parent.afterCropActions.push(direction.toLowerCase() === 'horizontal' ? 'horizontalflip' : 'verticalflip');
        var splitWords = [];
        var activeObjShape;
        if (parent.activeObj.activePoint) {
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.currObjType.isCustomCrop || splitWords[0] === 'crop') {
                activeObjShape = parent.currObjType.isCustomCrop ? 'custom' : splitWords[1];
                parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                parent.objColl.push(parent.activeObj);
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            }
        }
        parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: true } });
        parent.clearContext(this.lowerContext);
        parent.clearContext(this.upperContext);
        var tempObjColl = extend([], parent.objColl, [], true);
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (!this.isReverseFlip) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        }
        var lowercaseDirection = direction.toLowerCase();
        this.updateFlipState(lowercaseDirection);
        var flipState = parent.transform.currFlipState.toLowerCase();
        parent.transform.currFlipState = (lowercaseDirection === 'horizontal' && flipState === 'horizontal') ||
            (lowercaseDirection === 'vertical' && flipState === 'vertical') ? '' : lowercaseDirection;
        var selObj = { isSelected: null };
        parent.notify('draw', { prop: 'getRotatedFlipCropSelection', onPropertyChange: false, value: { bool: selObj } });
        if (selObj['isSelected']) {
            parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        }
        var temp = this.lowerContext.filter;
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        this.updateFlipState(direction.toLowerCase());
        if (!this.isReverseFlip) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            this.updateFlipColl(direction.toLocaleLowerCase());
            parent.rotateFlipColl.push(direction.toLowerCase());
        }
        if (parent.rotateFlipColl.length === 1) {
            var panObj = { panRegion: '' };
            parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
                value: { panObj: panObj } });
            if (panObj['panRegion'] === '') {
                parent.notify('draw', { prop: 'setClientTransDim', onPropertyChange: false,
                    value: { isPreventDimension: null } });
            }
            else {
                this.setDestPointsForFlipState();
            }
        }
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        parent.objColl = extend([], tempObjColl, [], true);
        parent.activeObj = extend({}, tempActiveObj, {}, true);
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var flipObjColl = parent.objColl[i].flipObjColl;
            if (flipObjColl.length === 0) {
                flipObjColl.push(direction);
            }
            else if (flipObjColl[flipObjColl.length - 1] === direction) {
                flipObjColl.pop();
            }
            else {
                flipObjColl.push(direction);
            }
        }
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: direction.toLowerCase() } });
        var tempFilter = this.lowerContext.filter;
        this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
            'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        var dir = direction.toLowerCase();
        if (dir === 'horizontal' || dir === 'vertical') {
            parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,
                value: { value: dir } });
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
        }
        else {
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
        }
        this.lowerContext.filter = tempFilter;
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.updateCurrSelectionPoint(dir);
        parent.isUndoRedo = false;
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        if (activeObjShape) {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
            parent.objColl.pop();
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
        }
        var obj = { collection: parent.rotateFlipColl };
        parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
            value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: obj } });
        parent.rotateFlipColl = obj['collection'];
        if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
            parent.notify('draw', { prop: 'setIsCropSelect', value: { bool: true } });
            this.isPreventSelect = true;
            parent.notify('draw', { prop: 'select', onPropertyChange: false,
                value: { type: 'custom', startX: null, startY: null, width: null, height: null } });
            this.isPreventSelect = false;
            parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
            this.prevZoomValue = parent.zoomSettings.zoomFactor;
        }
    };
    Transform.prototype.updateFlipState = function (direction) {
        var degree = this.parent.transform.degree;
        if (direction === 'horizontal') {
            if (degree % 90 === 0 && degree % 180 !== 0) {
                this.verticalFlip();
            }
            else {
                this.horizontalFlip();
            }
        }
        else if (direction === 'vertical') {
            if (degree % 90 === 0 && degree % 180 !== 0) {
                this.horizontalFlip();
            }
            else {
                this.verticalFlip();
            }
        }
    };
    Transform.prototype.horizontalFlip = function () {
        this.lowerContext.translate(this.lowerContext.canvas.width, 0);
        this.lowerContext.scale(-1, 1);
        this.upperContext.translate(this.upperContext.canvas.width, 0);
        this.upperContext.scale(-1, 1);
    };
    Transform.prototype.verticalFlip = function () {
        this.lowerContext.translate(0, this.lowerContext.canvas.height);
        this.lowerContext.scale(1, -1);
        this.upperContext.translate(0, this.upperContext.canvas.height);
        this.upperContext.scale(1, -1);
    };
    Transform.prototype.updateFlipColl = function (direction) {
        if (this.isPreventSelect) {
            return;
        }
        if (this.flipColl.length === 0 || this.flipColl[this.flipColl.length - 1] !== direction) {
            this.flipColl.push(direction);
        }
        else {
            this.flipColl.pop();
        }
        if (this.flipColl.length >= 4) {
            var lastFourItems = this.flipColl.slice(-4);
            if ((lastFourItems[0] === 'horizontal' && lastFourItems[1] === 'vertical' &&
                lastFourItems[2] === 'horizontal' && lastFourItems[3] === 'vertical') ||
                (lastFourItems[0] === 'vertical' && lastFourItems[1] === 'horizontal' &&
                    lastFourItems[2] === 'vertical' && lastFourItems[3] === 'horizontal')) {
                this.flipColl.splice(-4);
            }
        }
    };
    Transform.prototype.setDestPointsForFlipState = function () {
        var parent = this.parent;
        var panObj = { panRegion: '' };
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var _b = parent.lowerCanvas, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;
        parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
            value: { panObj: panObj } });
        if (panObj['panRegion'] !== '') {
            if (panObj['panRegion'] === 'horizontal') {
                parent.img.destLeft = clientWidth - (destWidth + destLeft);
            }
            else if (panObj['panRegion'] === 'vertical') {
                parent.img.destTop = clientHeight - (destHeight + destTop);
            }
            else {
                parent.img.destLeft = clientWidth - (destWidth + destLeft);
                parent.img.destTop = clientHeight - (destHeight + destTop);
            }
        }
    };
    Transform.prototype.zoomAction = function (zoomFactor, zoomPoint, isResize, isPreventApply) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (isNullOrUndefined(isResize) && (parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor && zoomFactor > 0 ||
                (parent.zoomSettings.zoomFactor > parent.zoomSettings.minZoomFactor && zoomFactor < 0 && this.disableZoomOutBtn(true)) ||
                (parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor && zoomFactor < 0))) {
                parent.notify('toolbar', { prop: 'zoom-up-handler', onPropertyChange: false });
                return;
            }
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            var tempZoomFactor = zoomFactor;
            zoomFactor = tempZoomFactor > 0 ? 0.1 : -0.1;
            for (var i = 0; i < Math.round(Math.abs(tempZoomFactor / 0.1)); i++) {
                if (this.prevZoomValue === 1) {
                    this.prevZoomValue += zoomFactor > 0 ? zoomFactor * 10 : (zoomFactor * 10) / 10;
                }
                else if (this.prevZoomValue > 1) {
                    this.prevZoomValue += (zoomFactor * 10);
                }
                else if (this.prevZoomValue < 1) {
                    this.prevZoomValue += (zoomFactor * 10) / 10;
                    var powerOften = Math.pow(10, 1);
                    this.prevZoomValue = (Math.round(this.prevZoomValue * powerOften) / powerOften);
                }
            }
            zoomFactor = tempZoomFactor;
            parent.setProperties({ zoomSettings: { zoomFactor: this.prevZoomValue } }, true);
            var splitWords = void 0;
            this.tempActiveObj = null;
            this.isShape = false;
            if (parent.activeObj.shape !== undefined) {
                if (parent.activeObj.shape === 'shape') {
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                }
                else {
                    splitWords = parent.activeObj.shape.split('-');
                }
            }
            if (splitWords !== undefined && splitWords[0] === 'crop') {
                this.tempActiveObj = extend({}, parent.activeObj, {}, true);
                parent.isCropTab = true;
            }
            else if (parent.activeObj.shape && splitWords[0] !== 'crop' &&
                (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) ||
                (parent.activeObj.shape === 'path' && parent.activeObj.pointColl.length > 0)) {
                this.isShape = true;
            }
            var obj = { zoomType: null };
            parent.notify('selection', { prop: 'getZoomType', onPropertyChange: false, value: { obj: obj } });
            if (isNullOrUndefined(zoomPoint)) {
                if (parent.isCropTab && this.tempActiveObj) {
                    zoomPoint = { x: parent.activeObj.activePoint.startX + (parent.activeObj.activePoint.width / 2),
                        y: parent.activeObj.activePoint.startY + (parent.activeObj.activePoint.height / 2) };
                }
                else {
                    zoomPoint = { x: parent.lowerCanvas.clientWidth / 2, y: parent.lowerCanvas.clientHeight / 2 };
                }
                if (obj['zoomType'] === 'MouseWheel' || obj['zoomType'] === 'Pinch') {
                    zoomPoint = { x: parent.zoomSettings.zoomPoint.x, y: parent.zoomSettings.zoomPoint.y };
                }
            }
            var previousZoomFactor = parent.zoomSettings.zoomFactor - (zoomFactor * 10);
            var zoomEventArgs = { zoomPoint: zoomPoint, cancel: false, previousZoomFactor: previousZoomFactor,
                currentZoomFactor: parent.zoomSettings.zoomFactor, zoomTrigger: obj['zoomType'] };
            if (!parent.isCropToolbar && parent.isZoomBtnClick) {
                parent.trigger('zooming', zoomEventArgs);
                parent.editCompleteArgs = zoomEventArgs;
            }
            this.zoomEvent(zoomEventArgs, zoomFactor, isPreventApply);
        }
    };
    Transform.prototype.zoomEvent = function (zoomEventArgs, zoomFact, isPreventApply) {
        var parent = this.parent;
        var shapeId;
        var _a = parent.zoomSettings, zoomFactor = _a.zoomFactor, minZoomFactor = _a.minZoomFactor;
        if (zoomEventArgs.cancel) {
            parent.isZoomBtnClick = false;
            return;
        }
        if (this.parent.activeObj.redactType !== 'blur' && this.parent.activeObj.redactType !== 'pixelate') {
            parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
        }
        if (!parent.isCropTab && parent.activeObj.shape) {
            shapeId = parent.activeObj.currIndex;
        }
        parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: true } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        var object = { canvasFilter: parent.canvasFilter };
        this.lowerContext.filter = object['canvasFilter'];
        parent.upperCanvas.style.cursor = parent.cursor = 'default';
        var objColl = extend([], parent.objColl, [], true);
        if (!parent.isCropTab) {
            if (parent.transform.degree !== 0) {
                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false, value: { x: null, y: null, isMouseDown: null } });
                parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
                var temp = parent.allowDownScale;
                parent.allowDownScale = false;
                this.rotatePan(true, true);
                parent.allowDownScale = temp;
            }
            else if (parent.transform.currFlipState !== '') {
                parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
            }
            if (parent.transform.straighten === 0 && !this.isPreventSelect) {
                parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false, value: { isPreventApply: isPreventApply } });
            }
        }
        if (parent.transform.degree === 0) {
            this.drawZoomImgToCanvas(zoomFact, this.tempActiveObj);
            var panObj_1 = { panRegion: '' };
            parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false, value: { panObj: panObj_1 } });
            if (panObj_1['panRegion'] !== '') {
                parent.notify('crop', { prop: 'setTempFlipPanPoint', onPropertyChange: false, value: { point: parent.panPoint.totalPannedPoint, isAdd: true } });
                objColl = extend([], parent.objColl, [], true);
                parent.objColl = [];
                var destLeft = parent.img.destLeft;
                var destTop = parent.img.destTop;
                this.setDestPointsForFlipState();
                this.rotatedFlip();
                parent.img.destLeft = destLeft;
                parent.img.destTop = destTop;
                parent.objColl = objColl;
                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                    value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: isPreventApply } });
                if (parent.transform.straighten === 0 && !this.isPreventSelect) {
                    parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false, value: { isPreventApply: isPreventApply } });
                }
            }
            if (zoomFactor <= minZoomFactor && !parent.isCropTab) {
                parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
            }
        }
        else {
            if (parent.transform.straighten === 0 && !this.isPreventSelect) {
                parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false, value: { isPreventApply: isPreventApply } });
            }
            parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
            parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
            this.rotateZoom(zoomFact);
            var panObj_2 = { panRegion: '' };
            parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false, value: { panObj: panObj_2 } });
            if (panObj_2['panRegion'] !== '') {
                var temp = this.lowerContext.filter;
                this.lowerContext.filter = 'none';
                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                    value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: isPreventApply } });
                this.lowerContext.filter = temp;
            }
        }
        var powerOften = Math.pow(10, 1);
        if (zoomFactor <= minZoomFactor ||
            (Math.round(parent.transform.zoomFactor * powerOften) / powerOften) === 2) {
            clearInterval(this.zoomBtnHold);
            this.zoomBtnHold = 0;
        }
        var panObj = { panRegion: '' };
        parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false, value: { panObj: panObj } });
        if (panObj['panRegion'] === '') {
            var temp = this.lowerContext.filter;
            this.lowerContext.filter = 'none';
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: isPreventApply } });
            this.lowerContext.filter = temp;
        }
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (this.tempActiveObj) {
            parent.activeObj = extend({}, this.tempActiveObj, {}, true);
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            if (zoomFactor <= minZoomFactor) {
                parent.currSelectionPoint = null;
            }
        }
        parent.isUndoRedo = false;
        var zoomOut;
        zoomOut = document.querySelector('#' + parent.element.id + '_zoomOut');
        if (zoomOut && zoomFactor <= minZoomFactor) {
            zoomOut.classList.add('e-disabled');
            zoomOut.parentElement.classList.add('e-overlay');
        }
        else if (zoomOut) {
            zoomOut.classList.remove('e-disabled');
            zoomOut.parentElement.classList.remove('e-overlay');
        }
        var drawingShape = parent.drawingShape;
        this.autoEnablePan();
        parent.drawingShape = drawingShape;
        if (this.tempActiveObj) {
            parent.activeObj = extend({}, this.tempActiveObj, {}, true);
        }
        if (parent.activeObj.shape === 'crop-custom') {
            parent.currObjType.isCustomCrop = true;
        }
        if (this.isShape) {
            if (shapeId) {
                for (var i = 0, len = parent.objColl.length; i < len; i++) {
                    if (parent.objColl[i].currIndex === shapeId) {
                        parent.activeObj = extend({}, parent.objColl[i], {}, true);
                        parent.objColl.splice(i, 1);
                        break;
                    }
                }
            }
            else {
                parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
                parent.objColl.pop();
            }
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                    points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
            parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
        }
        parent.notify('toolbar', { prop: 'enable-disable-btns', onPropertyChange: false });
        parent.notify('selection', { prop: 'setZoomType', onPropertyChange: false, value: { zoomType: 'Toolbar' } });
        // eslint-disable-next-line max-len
        zoomEventArgs = { zoomPoint: zoomEventArgs.zoomPoint, previousZoomFactor: zoomEventArgs.previousZoomFactor, currentZoomFactor: zoomEventArgs.currentZoomFactor, zoomTrigger: zoomEventArgs.zoomTrigger };
        if (!parent.isCropToolbar && parent.isZoomBtnClick) {
            parent.isZoomBtnClick = false;
        }
        if (parent.drawingShape) {
            var activeObj = extend({}, parent.activeObj, {}, true);
            parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
            parent.activeObj = activeObj;
            if (activeObj.activePoint.width > 0 || activeObj.activePoint.height > 0 ||
                (activeObj.pointColl && activeObj.pointColl.length > 0)) {
                if (activeObj.shape === 'redact') {
                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                }
                var zOrderElem = parent.element.querySelector('#' + parent.element.id + '_zOrderBtn');
                var dupElem = parent.element.querySelector('#' + parent.element.id + '_duplicate');
                var removeElem = parent.element.querySelector('#' + parent.element.id + '_remove');
                var editTextElem = parent.element.querySelector('#' + parent.element.id + '_editText');
                if (zOrderElem) {
                    zOrderElem.classList.remove('e-overlay');
                }
                if (dupElem) {
                    dupElem.classList.remove('e-overlay');
                }
                if (removeElem) {
                    removeElem.classList.remove('e-overlay');
                }
                if (editTextElem) {
                    editTextElem.classList.remove('e-overlay');
                }
            }
        }
        else if (parent.activeObj.shape && parent.activeObj.shape === 'redact') {
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',
                    isApplyBtn: false, isCropping: false } });
            parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
        }
    };
    Transform.prototype.disableZoomOutBtn = function (isZoomOut) {
        var parent = this.parent;
        var _a = parent.zoomSettings, zoomFactor = _a.zoomFactor, minZoomFactor = _a.minZoomFactor;
        var isDisabled = false;
        var zoomOut;
        if (!isNullOrUndefined(isZoomOut)) {
            parent.transform.zoomFactor -= 0.1;
        }
        zoomOut = parent.element.querySelector('#' + parent.element.id + '_zoomOut');
        var destPoints = { destLeft: parent.img.destLeft, destTop: parent.img.destTop,
            destWidth: parent.img.destWidth, destHeight: parent.img.destHeight };
        if (parent.activeObj.shape) {
            var maxDimension = this.setZoomDimension(-0.1, parent.activeObj);
            if (!isNullOrUndefined(zoomOut)) {
                var actPoint = parent.activeObj.activePoint;
                if (parent.transform.straighten === 0) {
                    if (parent.img.destLeft > actPoint.startX || parent.img.destTop >
                        actPoint.startY || parent.img.destLeft + parent.img.destWidth <
                        actPoint.endX || parent.img.destTop + parent.img.destHeight < actPoint.endY
                        || zoomFactor === minZoomFactor) {
                        zoomOut.classList.add('e-disabled');
                        zoomOut.parentElement.classList.add('e-overlay');
                        isDisabled = true;
                    }
                    else {
                        zoomOut.classList.remove('e-disabled');
                        zoomOut.parentElement.classList.remove('e-overlay');
                        isDisabled = false;
                    }
                }
                else {
                    parent.img.destWidth = maxDimension.width;
                    parent.img.destHeight = maxDimension.height;
                    var obj = { isIntersect: null };
                    parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
                    parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: obj } });
                    if (obj['isIntersect'] ||
                        zoomFactor === minZoomFactor) {
                        zoomOut.classList.add('e-disabled');
                        zoomOut.parentElement.classList.add('e-overlay');
                        isDisabled = true;
                    }
                    else {
                        zoomOut.classList.remove('e-disabled');
                        zoomOut.parentElement.classList.remove('e-overlay');
                        isDisabled = false;
                    }
                }
            }
        }
        else {
            this.setZoomDimension(-0.1, null);
        }
        if (!isNullOrUndefined(isZoomOut)) {
            parent.transform.zoomFactor += 0.1;
        }
        parent.img.destLeft = destPoints['destLeft'];
        parent.img.destTop = destPoints['destTop'];
        parent.img.destWidth = destPoints['destWidth'];
        parent.img.destHeight = destPoints['destHeight'];
        return isDisabled;
    };
    Transform.prototype.drawZoomImgToCanvas = function (value, selectionObj) {
        var parent = this.parent;
        var powerOften = Math.pow(10, 1);
        var zmFactor = Math.round(parent.transform.zoomFactor * powerOften) / powerOften;
        if ((zmFactor === 0.1 && value === -0.1) || zmFactor === 0 && value === -0.025) {
            parent.transform.zoomFactor = 0;
        }
        else {
            parent.transform.zoomFactor += value;
        }
        parent.transform[parent.isCropTab ? 'cropZoomFactor' : 'defaultZoomFactor'] = parent.transform.zoomFactor;
        var maxDimension = { width: 0, height: 0 };
        if (parent.isCropTab) {
            maxDimension = this.cropZoom(value, selectionObj);
        }
        else {
            maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
            maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
            maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
        }
        parent.notify('draw', { prop: 'draw-image-to-canvas', value: { dimension: maxDimension } });
        maxDimension.width = this.cropDimension.width;
        maxDimension.height = this.cropDimension.height;
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.notify('draw', { prop: 'setZoomCropWidth', value: { width: maxDimension.width, height: maxDimension.height } });
    };
    Transform.prototype.rotatedFlip = function () {
        var parent = this.parent;
        this.isReverseFlip = true;
        var tempCurrFlipState = parent.transform.currFlipState;
        var tempFlipColl = this.flipColl;
        var tempObjColl = extend([], parent.objColl, [], true);
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        this.flipColl = [];
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        var temp = this.lowerContext.filter;
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: true, context: null, isPreventCircleCrop: null } });
        if (tempCurrFlipState === '' && parent.transform.currFlipState !== '') {
            tempCurrFlipState = parent.transform.currFlipState;
        }
        parent.transform.currFlipState = tempCurrFlipState;
        this.flipColl = tempFlipColl;
        parent.objColl = extend([], tempObjColl, [], true);
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        this.lowerContext.filter = temp;
        if (tempActiveObj.activePoint.width !== 0) {
            parent.activeObj = extend({}, tempActiveObj, {}, true);
        }
        this.isReverseFlip = false;
    };
    Transform.prototype.rotateZoom = function (value) {
        var parent = this.parent;
        var powerOften = Math.pow(10, 1);
        var zmFactor = Math.round(parent.transform.zoomFactor * powerOften) / powerOften;
        if ((zmFactor === 0.1 && value === -0.1) || zmFactor === 0 && value === -0.025) {
            parent.transform.zoomFactor = 0;
        }
        else {
            parent.transform.zoomFactor += value;
        }
        if (parent.isCropTab) {
            parent.transform.cropZoomFactor = parent.transform.zoomFactor;
        }
        else {
            parent.transform.defaultZoomFactor = parent.transform.zoomFactor;
        }
        var tempObjColl = extend([], parent.objColl, [], true);
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: true } });
        parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        var temp = this.lowerContext.filter;
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
        parent.objColl = tempObjColl;
        parent.activeObj = tempActiveObj;
        var maxDimension = { width: this.cropDimension.width, height: this.cropDimension.height };
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.notify('draw', { prop: 'setZoomCropWidth', value: { width: maxDimension.width, height: maxDimension.height } });
    };
    Transform.prototype.autoEnablePan = function () {
        var parent = this.parent;
        if (parent.transform.zoomFactor <= 0) {
            parent.togglePan = false;
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
            parent.pan(false);
            this.disablePan = false;
        }
        else {
            parent.pan(!this.disablePan);
        }
    };
    Transform.prototype.cropZoom = function (value, selectionObj) {
        var parent = this.parent;
        var destLeft = parent.img.destLeft;
        var destTop = parent.img.destTop;
        var maxDimension = { width: 0, height: 0 };
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
        }
        else {
            maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
        }
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.img.destLeft = destLeft - ((maxDimension.width - parent.img.destWidth) / 2);
        parent.img.destTop = destTop - ((maxDimension.height - parent.img.destHeight) / 2);
        destLeft = parent.img.destLeft;
        destTop = parent.img.destTop;
        if (selectionObj && parent.transform.straighten === 0) {
            if (parent.img.destLeft > selectionObj.activePoint.startX) {
                parent.img.destLeft = selectionObj.activePoint.startX;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.x -= (destLeft - parent.img.destLeft);
                }
            }
            if (parent.img.destTop > selectionObj.activePoint.startY) {
                parent.img.destTop = selectionObj.activePoint.startY;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.y -= (destTop - parent.img.destTop);
                }
            }
            if (parent.img.destLeft + maxDimension.width < selectionObj.activePoint.endX) {
                parent.img.destLeft = selectionObj.activePoint.endX - maxDimension.width;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.x -= (destLeft - parent.img.destLeft);
                }
            }
            if (parent.img.destTop + maxDimension.height < selectionObj.activePoint.endY) {
                parent.img.destTop = selectionObj.activePoint.endY - maxDimension.height;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.y -= (destTop - parent.img.destTop);
                }
            }
        }
        return maxDimension;
    };
    Transform.prototype.setZoomDimension = function (value, selectionObj) {
        var parent = this.parent;
        var degree = parent.transform.degree;
        var maxDimension = { width: 0, height: 0 };
        if (degree % 90 === 0 && degree % 180 !== 0) {
            maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
        }
        else {
            maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
        }
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.img.destLeft += ((parent.img.destWidth - maxDimension.width) / 2);
        parent.img.destTop += ((parent.img.destHeight - maxDimension.height) / 2);
        // While zoom out limit image to draw inside the selection range
        if (value < 0 && selectionObj) {
            var startX = selectionObj.activePoint.startX;
            var startY = selectionObj.activePoint.startY;
            var width = selectionObj.activePoint.width;
            var height = selectionObj.activePoint.height;
            var maxDestLeft = parent.img.destLeft + maxDimension.width;
            var maxDestTop = parent.img.destTop + maxDimension.height;
            if (parent.img.destLeft > startX) {
                parent.img.destLeft = startX;
            }
            if (parent.img.destTop > startY) {
                parent.img.destTop = startY;
            }
            if (maxDestLeft < startX + width) {
                parent.img.destLeft = startX + width - maxDimension.width;
            }
            if (maxDestTop < startY + height) {
                parent.img.destTop = startY + height - maxDimension.height;
            }
        }
        else if (value < 0 && isNullOrUndefined(selectionObj)) {
            if (parent.img.destLeft > 0) {
                parent.img.destLeft = 0;
            }
            if (parent.img.destTop > 0) {
                parent.img.destTop = 0;
            }
            if (parent.img.destLeft + maxDimension.width < parent.lowerCanvas.clientWidth) {
                parent.img.destLeft = parent.lowerCanvas.clientWidth - parent.img.destWidth;
            }
            if (parent.img.destTop + maxDimension.height < parent.lowerCanvas.clientHeight) {
                parent.img.destTop = parent.lowerCanvas.clientHeight - parent.img.destHeight;
            }
        }
        return maxDimension;
    };
    Transform.prototype.drawPannedImage = function (xDiff, yDiff) {
        var parent = this.parent;
        var obj = { panDown: null };
        parent.notify('selection', { prop: 'getPanDown', onPropertyChange: false, value: { obj: obj } });
        var panEventArgs = { startPoint: obj['panDown'], endPoint: this.panMove, cancel: false };
        parent.trigger('panning', panEventArgs);
        if (panEventArgs.cancel) {
            return;
        }
        this.panEvent(xDiff, yDiff);
    };
    Transform.prototype.panEvent = function (xDiff, yDiff, isPanMethod) {
        var parent = this.parent;
        var isObjCreated = false;
        if (parent.activeObj.shape && parent.activeObj.shape === 'shape') {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        }
        if (isNullOrUndefined(parent.activeObj.shape)) {
            isObjCreated = true;
            var actPoint = parent.activeObj.activePoint = { startX: parent.img.destLeft, startY: parent.img.destTop,
                endX: parent.img.destLeft + parent.img.destWidth, endY: parent.img.destTop + parent.img.destHeight };
            var startX = actPoint.startX;
            var startY = actPoint.startY;
            var endX = actPoint.endX;
            var endY = actPoint.endY;
            if (startX < 0) {
                actPoint.startX = 0;
            }
            if (startY < 0) {
                actPoint.startY = 0;
            }
            if (endX > parent.lowerCanvas.width) {
                actPoint.endX = parent.lowerCanvas.width;
            }
            if (endY > parent.lowerCanvas.height) {
                actPoint.endY = parent.lowerCanvas.height;
            }
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            parent.activeObj.shape = 'crop-custom';
            var obj = { strokeSettings: {} };
            parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false, value: { obj: obj } });
            parent.activeObj.strokeSettings = obj['strokeSettings'];
            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: actPoint, obj: parent.activeObj,
                    isMouseMove: null, x: null, y: null } });
            parent.isCropTab = true;
        }
        if (parent.transform.degree === 0) {
            var point = void 0;
            if ((isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff)) || isPanMethod) {
                if (isPanMethod) {
                    point = this.updatePanPoints(xDiff, yDiff);
                }
                else {
                    point = this.updatePanPoints();
                }
            }
            else {
                point = { x: xDiff, y: yDiff };
            }
            parent.panPoint.totalPannedPoint.x += point.x;
            parent.panPoint.totalPannedPoint.y += point.y;
            var tempSelectionObj = extend({}, parent.activeObj, {}, true);
            var temp = this.lowerContext.filter;
            this.drawPannImage(point, isObjCreated);
            this.lowerContext.filter = temp;
            this.tempPanMove = extend({}, this.panMove, {}, true);
            parent.activeObj = extend({}, tempSelectionObj, {}, true);
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (parent.activeObj.shape) {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            }
        }
        else {
            var tempFlipState = parent.transform.currFlipState;
            parent.isCropTab = true;
            if ((isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff)) || isPanMethod) {
                if (isPanMethod) {
                    parent.panPoint.currentPannedPoint = this.updatePanPoints(xDiff, yDiff);
                }
                else {
                    parent.panPoint.currentPannedPoint = this.updatePanPoints();
                }
            }
            else {
                parent.panPoint.currentPannedPoint = { x: xDiff, y: yDiff };
            }
            parent.transform.currFlipState = tempFlipState;
            this.rotatePan(null, null, isObjCreated);
            parent.isCropTab = false;
            this.tempPanMove = extend({}, this.panMove, {}, true);
        }
        if (isObjCreated) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.isCropTab = false;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
    };
    Transform.prototype.drawPannImage = function (point, isObjCreated) {
        var parent = this.parent;
        var filter = this.lowerContext.filter;
        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
            height: parent.img.destHeight };
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
        this.setDestPointsForFlipState();
        if (isObjCreated) {
            parent.isCropTab = false;
        }
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        if (isObjCreated) {
            parent.isCropTab = true;
        }
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: true } });
        }
        this.lowerContext.filter = filter;
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = 'none';
        if (isObjCreated) {
            parent.isCropTab = false;
        }
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'pan', pen: 'pan', x: point.x,
                y: point.y, panRegion: '' } });
        if (isObjCreated) {
            parent.isCropTab = true;
        }
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: true } });
        }
    };
    Transform.prototype.resetZoom = function () {
        var parent = this.parent;
        if (parent.transform.defaultZoomFactor !== 0) {
            var isUndoRedo = parent.isUndoRedo;
            var object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            this.transCurrObj = object['currObj'];
            this.transCurrObj.objColl = extend([], parent.objColl, null, true);
            this.transCurrObj.pointColl = extend({}, parent.pointColl, null, true);
            this.transCurrObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            this.transCurrObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            parent.isUndoRedo = parent.isCropToolbar = true;
            var zmFactor = parent.transform.defaultZoomFactor;
            if (zmFactor > 0) {
                this.zoomAction(-zmFactor);
            }
            else {
                this.zoomAction(Math.abs(zmFactor));
            }
            parent.isCropToolbar = false;
            parent.isUndoRedo = isUndoRedo;
        }
    };
    Transform.prototype.performTransformation = function (text) {
        var parent = this.parent;
        this.resetZoom();
        this.updateTransform(text);
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].flipObjColl.length > 0) {
                var flipObjColl = { collection: parent.objColl[i].flipObjColl };
                parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
                    value: { collection: flipObjColl['collection'], isRotateFlipCollection: null, obj: flipObjColl } });
                parent.objColl[i].flipObjColl = flipObjColl['collection'];
                if (parent.objColl[i].flipObjColl.length === 0) {
                    parent.objColl[i].shapeFlip = '';
                }
            }
        }
    };
    Transform.prototype.updateTransform = function (text) {
        switch (text.toLowerCase()) {
            case 'rotateleft':
                this.rotateImage(-90);
                break;
            case 'rotateright':
                this.rotateImage(90);
                break;
            case 'horizontalflip':
                this.flipImage(Direction.Horizontal);
                break;
            case 'verticalflip':
                this.flipImage(Direction.Vertical);
                break;
        }
    };
    Transform.prototype.rotatePan = function (isCropSelection, isDefaultZoom, isObjCreated) {
        var parent = this.parent;
        this.isReverseRotate = true;
        var tempDegree = parent.transform.degree;
        var rotatePanActiveObj;
        var object = { selPointColl: null };
        if (parent.activeObj.activePoint && parent.activeObj.shape) {
            rotatePanActiveObj = extend({}, parent.activeObj, {}, true);
        }
        var tempObjColl = extend([], parent.objColl, [], true);
        var tempPointColl = extend([], parent.pointColl, [], true);
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: object } });
        var cropSelPointColl = object['selPointColl'];
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false, value: { obj: { selPointColl: [] } } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: true } });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        var initialDestLeft = parent.img.destLeft;
        var initialDestTop = parent.img.destTop;
        var intPan = parent.panPoint.totalPannedInternalPoint;
        if (parent.isCropTab) {
            parent.img.destLeft += intPan.x;
            parent.img.destTop += intPan.y;
        }
        parent.notify('crop', { prop: 'updateRotatePan', onPropertyChange: false });
        if (parent.isCropTab) {
            parent.panPoint.totalPannedInternalPoint.x = parent.img.destLeft - initialDestLeft;
            parent.panPoint.totalPannedInternalPoint.y = parent.img.destTop - initialDestTop;
        }
        var temp = this.lowerContext.filter;
        if (isObjCreated) {
            parent.isCropTab = false;
        }
        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
        if (isObjCreated) {
            parent.isCropTab = true;
        }
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: true, isRotatePan: true } });
        var destLeft = parent.img.destLeft;
        var destTop = parent.img.destTop;
        parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
        parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
        parent.img.destTop += parent.panPoint.currentPannedPoint.y;
        parent.panPoint.totalPannedClientPoint.x = parent.img.destLeft - destLeft;
        parent.panPoint.totalPannedClientPoint.y = parent.img.destTop - destTop;
        parent.objColl = tempObjColl;
        parent.pointColl = tempPointColl;
        parent.freehandCounter = parent.pointColl.length;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: cropSelPointColl } } });
        parent.transform.degree = tempDegree;
        this.lowerContext.filter = 'none';
        if (isCropSelection) {
            if (isDefaultZoom) {
                parent.panPoint.totalPannedClientPoint.x = -parent.panPoint.totalPannedClientPoint.x;
                parent.panPoint.totalPannedClientPoint.y = -parent.panPoint.totalPannedClientPoint.y;
                parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
                parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
                parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
                parent.img.destTop += parent.panPoint.currentPannedPoint.y;
            }
            else {
                parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
            }
        }
        if (isObjCreated) {
            parent.isCropTab = false;
        }
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'pan', pen: 'pan', x: parent.panPoint.currentPannedPoint.x,
                y: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
        if (isObjCreated) {
            parent.isCropTab = true;
        }
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.activeObj = extend({}, rotatePanActiveObj, {}, true);
        if (parent.activeObj.activePoint) {
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                    points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
        }
        this.isReverseRotate = false;
    };
    Transform.prototype.limitPan = function () {
        var parent = this.parent;
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        var img = parent.img;
        if (parent.activeObj.activePoint) {
            if (img.destLeft > startX) {
                parent.img.destLeft = startX;
            }
            if (img.destTop > startY) {
                parent.img.destTop = startY;
            }
            if (img.destLeft + img.destWidth < endX) {
                parent.img.destLeft = endX - img.destWidth;
            }
            if (img.destTop + img.destHeight < endY) {
                parent.img.destTop = endY - img.destHeight;
            }
        }
    };
    Transform.prototype.pan = function (value, x, y) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (value) {
                parent.togglePan = true;
                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                    value: { x: null, y: null, isMouseDown: null } });
                parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
                parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';
                parent.notify('selection', { prop: 'setPanDown', onPropertyChange: false, value: { panDown: null } });
                if (x || y) {
                    x = x ? x : 0;
                    y = y ? y : 0;
                    if (isNullOrUndefined(this.panMove)) {
                        this.panMove = { x: x, y: y };
                    }
                    if (isNullOrUndefined(this.tempPanMove)) {
                        this.tempPanMove = { x: this.panMove.x, y: this.panMove.y };
                    }
                    this.panEvent(x, y, true);
                    this.tempPanMove = null;
                }
            }
            else {
                parent.togglePan = parent.currObjType.isCustomCrop = false;
                parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
                parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'default';
            }
        }
    };
    Transform.prototype.zoom = function (zoomFactor, zoomPoint) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            var value = this.getCurrentZoomFactor(zoomFactor);
            if (isNullOrUndefined(zoomPoint)) {
                this.zoomAction(value, zoomPoint);
            }
            else {
                var type = value > 0 ? 'zoomIn' : 'zoomOut';
                var absValue = Math.abs(value) * 10;
                for (var i = 0; i < absValue; i++) {
                    parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                        value: { x: zoomPoint.x, y: zoomPoint.y, type: type, isResize: null } });
                }
            }
            var actionArgs = { action: value > 0 ? 'zoom-in' : 'zoom-out',
                actionEventArgs: parent.editCompleteArgs };
            parent.triggerEditCompleteEvent(actionArgs);
        }
    };
    Transform.prototype.getCurrentZoomFactor = function (zoomFactor) {
        return zoomFactor >= 1 ? (this.prevZoomValue < 1 ? (zoomFactor - this.prevZoomValue) : (zoomFactor - this.prevZoomValue) * 0.1) :
            (zoomFactor - this.prevZoomValue);
    };
    Transform.prototype.setCurrPanRegion = function (region, type, obj) {
        var panRegion = region;
        if (region === '') {
            panRegion = type === 'horizontal' ? 'horizontal' : type === 'vertical' ? 'vertical' : region;
        }
        else if (region === 'horizontal') {
            panRegion = type === 'horizontal' ? 'horizontalVertical' : type === 'vertical' ? 'verticalHorizontal' : type === 90 ?
                'vertical' : type === -90 ? 'horizontal' : region;
        }
        else if (region === 'vertical') {
            panRegion = type === 'horizontal' ? 'horizontalVertical' : type === 'vertical' ? 'verticalHorizontal' : type === 90 ?
                'horizontal' : type === -90 ? 'vertical' : region;
        }
        else {
            panRegion = type === 'horizontal' ? 'vertical' : type === 'vertical' ? 'horizontal' : region;
        }
        obj['panRegion'] = panRegion;
    };
    Transform.prototype.rotate = function (degree, obj) {
        var parent = this.parent;
        var isRotate = false;
        if (!parent.disabled && parent.isImageLoaded && (degree % 90 === 0)) {
            this.rotateImage(degree);
        }
        obj['isRotate'] = isRotate;
    };
    Transform.prototype.flip = function (direction) {
        var parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            this.flipImage(direction);
        }
    };
    Transform.prototype.update = function () {
        var parent = this.parent;
        var toolbarHeight = 0;
        var isActiveObj = false;
        var freehandObj = { bool: false };
        var straightenObj = { bool: parent.isStraightening };
        var cxtTbarHeight = 0;
        var ctToolbar = parent.element.querySelector('#' + parent.element.id + '_contextualToolbar');
        var ctWrapper = parent.element.querySelector('.e-contextual-toolbar-wrapper');
        var hdWrapper = parent.element.querySelector('#' + parent.element.id + '_headWrapper');
        if (parent.isImageLoaded) {
            var isCropSelection = false;
            var splitWords = void 0;
            if (Browser.isDevice) {
                if (parent.activeObj.shape) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (parent.currObjType.isCustomCrop) {
                    isCropSelection = true;
                }
                else if (splitWords && splitWords[0] === 'crop') {
                    isCropSelection = true;
                }
            }
            var frameObj = { bool: null };
            parent.notify('toolbar', { prop: 'getFrameToolbar', onPropertyChange: false, value: { obj: frameObj } });
            if (!straightenObj['bool'] && ((ctToolbar && !ctToolbar.parentElement.classList.contains('e-hide')) ||
                (hdWrapper && !hdWrapper.parentElement.classList.contains('e-hide')))) {
                ctWrapper.classList.add('e-hide');
                if (!isCropSelection) {
                    parent.okBtn(null, true);
                }
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
            }
            parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: freehandObj } });
            if (freehandObj['bool']) {
                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
            }
            var actPoint = extend({}, parent.activeObj.activePoint, {}, true);
            if (parent.activeObj.shape && (actPoint.width !== 0 || actPoint.height !== 0)) {
                isActiveObj = true;
                if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
                    parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                        value: { x: null, y: null, isMouseDown: null } });
                    parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                }
                else {
                    parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                    parent.objColl.push(parent.activeObj);
                }
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            }
        }
        parent.updateDropInfoContent(parent.element.querySelector('.e-ie-drop-info'));
        var tempFilter = this.lowerContext.filter;
        var canvasWrapper = parent.element.querySelector('#' + parent.element.id + '_canvasWrapper');
        if (canvasWrapper) {
            canvasWrapper.style.width = parent.element.offsetWidth - 2 + 'px';
        }
        parent.lowerCanvas.width = parent.upperCanvas.width = parent.maskCanvas.width = parent.element.offsetWidth - 2;
        if (parent.toolbarTemplate) {
            toolbarHeight = parent.element.querySelector('#' + parent.element.id + '_toolbarArea').clientHeight;
        }
        else if (parent.element.querySelector('#' + parent.element.id + '_toolbar')) {
            toolbarHeight = parent.element.querySelector('#' + parent.element.id + '_toolbar').clientHeight;
            if (toolbarHeight === 0 && parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf('Open') === -1) {
                var obj = { toolbarHeight: 0 };
                parent.notify('toolbar', { prop: 'getToolbarHeight', value: { obj: obj } });
                toolbarHeight = obj['toolbarHeight'];
            }
        }
        var ctxTbarArea = parent.element.querySelector('#' + parent.element.id + '_contextualToolbarArea');
        if (Browser.isDevice && straightenObj['bool'] && ctxTbarArea) {
            cxtTbarHeight = ctxTbarArea.clientHeight;
        }
        parent.notify('toolbar', { prop: 'setToolbarHeight', value: { height: toolbarHeight } });
        if (Browser.isDevice) {
            if (canvasWrapper) {
                canvasWrapper.style.height = parent.element.offsetHeight - ((2 * toolbarHeight) + cxtTbarHeight) - 4 + 'px';
            }
        }
        else {
            if (canvasWrapper) {
                canvasWrapper.style.height = parent.element.offsetHeight - toolbarHeight - 2 + 'px';
            }
        }
        parent.lowerCanvas.height = parent.upperCanvas.height = parseFloat(canvasWrapper.style.height);
        this.lowerContext.filter =
            'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
        parent.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
        parent.canvasFilter = this.lowerContext.filter;
        parent.initialAdjustmentValue = this.lowerContext.filter;
        parent.clearContext(this.lowerContext);
        parent.clearContext(this.upperContext);
        if (parent.isImageLoaded) {
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.lowerContext.filter = tempFilter;
            parent.initialAdjustmentValue = tempFilter;
            parent.canvasFilter = this.lowerContext.filter;
            if (parent.isImageLoaded) {
                showSpinner(parent.element);
                parent.element.style.opacity = '0.5';
            }
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (canvasWrapper) {
                canvasWrapper.style.width = parent.element.offsetWidth - 2 + 'px';
                canvasWrapper.style.height = parent.element.offsetHeight + 'px';
                var obj_1 = { toolbarHeight: 0 };
                parent.notify('toolbar', { prop: 'getToolbarHeight', value: { obj: obj_1 } });
                if (Browser.isDevice) {
                    canvasWrapper.style.height = (parseFloat(canvasWrapper.style.height) - (2 * obj_1['toolbarHeight']) - cxtTbarHeight) - 4 + 'px';
                }
                else {
                    canvasWrapper.style.height = (parseFloat(canvasWrapper.style.height) - obj_1['toolbarHeight']) - 2 + 'px';
                }
            }
            parent.lowerCanvas.width = parent.upperCanvas.width = parent.maskCanvas.width =
                parseFloat(canvasWrapper.style.width);
            parent.lowerCanvas.height = parent.upperCanvas.height = parent.maskCanvas.height =
                parseFloat(canvasWrapper.style.height);
            this.lowerContext.filter = tempFilter;
            var obj = { width: 0, height: 0 };
            this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight, obj);
            var maxDimension = obj;
            if (straightenObj['bool'] && parent.transform.cropZoomFactor !== 0) {
                maxDimension.width += (maxDimension.width * parent.transform.cropZoomFactor);
                maxDimension.height += (maxDimension.height * parent.transform.cropZoomFactor);
            }
            else if (parent.transform.defaultZoomFactor > 0) {
                maxDimension.width += (maxDimension.width * parent.transform.defaultZoomFactor);
                maxDimension.height += (maxDimension.height * parent.transform.defaultZoomFactor);
            }
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
            if (parent.transform.degree === 0 && parent.transform.currFlipState === '') {
                if (parent.transform.defaultZoomFactor > 0) {
                    parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
                    parent.img.destTop += parent.panPoint.totalPannedPoint.y;
                }
                parent.notify('draw', { prop: 'draw-image-to-canvas', value: { dimension: maxDimension } });
            }
            else {
                parent.notify('draw', { prop: 'draw-image-to-canvas', value: { dimension: maxDimension } });
                parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                    value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
                var temp = this.lowerContext.filter;
                parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });
                this.lowerContext.filter = temp;
                parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                    value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            }
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
            if (parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            hideSpinner(parent.element);
            parent.element.style.opacity = '1';
            var obj1 = { defToolbarItems: null };
            parent.notify('toolbar', { prop: 'getDefToolbarItems', value: { obj: obj1 } });
            if (obj1['defToolbarItems'] && obj1['defToolbarItems'].length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var toolbar_1 = getComponent(parent.element.id + '_toolbar', 'toolbar');
                if (toolbar_1) {
                    toolbar_1.refreshOverflow();
                }
                if (ctWrapper && !straightenObj['bool']) {
                    ctWrapper.classList.add('e-hide');
                }
            }
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (isActiveObj) {
                var activeObj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
                parent.objColl.pop();
                if (activeObj.activePoint.width !== 0 && activeObj.activePoint.height !== 0) {
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                    parent.objColl.push(activeObj);
                    parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                        value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
                    activeObj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
                    parent.objColl.pop();
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                    parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });
                    if (straightenObj['bool']) {
                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: activeObj } });
                    }
                    if (parent.activeObj.shape === 'rectangle' || parent.activeObj.shape === 'ellipse' || parent.activeObj.shape === 'text' ||
                        parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path' ||
                        parent.activeObj.shape === 'image') {
                        parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                    }
                }
            }
            if (freehandObj['bool']) {
                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });
            }
            if (parent.isResize) {
                parent.aspectWidth = Math.ceil(parent.img.destWidth);
                parent.aspectHeight = Math.ceil(parent.img.destHeight);
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'resize',
                        isApplyBtn: false, isCropping: false } });
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'resize',
                        isApplyBtn: false, isCropping: false } });
            }
            if ((parent.transform.degree !== 0 || parent.transform.currFlipState !== '') && parent.transform.defaultZoomFactor > 0) {
                var totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, null, true);
                var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, null, true);
                var totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, null, true);
                this.zoomAction(.1);
                this.zoomAction(-.1);
                if (parent.transform.degree === 0) {
                    parent.img.destLeft += totalPannedPoint.x;
                    parent.img.destTop += totalPannedPoint.y;
                    parent.panPoint.totalPannedPoint = totalPannedPoint;
                    parent.notify('draw', { prop: 'updateFlipPan', value: { tempSelectionObj: null } });
                }
                else {
                    parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
                    parent.panPoint.totalPannedClientPoint = totalPannedClientPoint;
                    parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
                    parent.isCropTab = true;
                    this.rotatePan();
                    parent.isCropTab = false;
                }
            }
            else if (parent.transform.degree !== 0 && parent.transform.cropZoomFactor > 0) {
                parent.transform.zoomFactor = 0;
                parent.transform.cropZoomFactor = null;
                parent.notify('toolbar', { prop: 'enable-disable-btns', onPropertyChange: false });
            }
        }
    };
    Transform.prototype.calcMaxDimension = function (width, height, obj, isImgShape) {
        var object = { toolbarHeight: 0 };
        var parent = this.parent;
        parent.notify('toolbar', { prop: 'getToolbarHeight', value: { obj: object } });
        var canvasMaxWidth = isImgShape ? parent.element.clientWidth / 3 :
            parent.element.clientWidth;
        var canvasMaxHeight = isImgShape ? (parent.element.clientHeight - object['toolbarHeight']) / 3 :
            parent.element.clientHeight - (object['toolbarHeight']); // 1px border
        canvasMaxHeight = Browser.isDevice ? canvasMaxHeight - (object['toolbarHeight']) : canvasMaxHeight; // 1px border
        if (Browser.isDevice && parent.isStraightening) {
            var cxtTbar = parent.element.querySelector('#' + parent.element.id + '_contextualToolbarArea');
            canvasMaxHeight -= cxtTbar ? cxtTbar.clientHeight : 0;
        }
        if (!isImgShape && parent.element.clientHeight === 0) {
            canvasMaxHeight = 0;
        }
        if (isNullOrUndefined(isImgShape)) {
            if (canvasMaxWidth > 30) {
                canvasMaxWidth -= 30;
            }
            if (canvasMaxHeight > 30) {
                canvasMaxHeight -= 30;
            }
        }
        var widthScale = canvasMaxWidth / width;
        var heightScale = canvasMaxHeight / height;
        var cssMaxWidth = Math.min(width, canvasMaxWidth);
        var cssMaxHeight = Math.min(height, canvasMaxHeight);
        if (widthScale < 1 && widthScale < heightScale) {
            cssMaxWidth = width * widthScale;
            cssMaxHeight = height * widthScale;
        }
        else if (heightScale < 1 && heightScale < widthScale) {
            cssMaxWidth = width * heightScale;
            cssMaxHeight = height * heightScale;
        }
        if (isNullOrUndefined(isImgShape)) {
            var cropObj = { bool: null };
            parent.notify('crop', { prop: 'getPreventScaling', onPropertyChange: false,
                value: { obj: cropObj } });
            if (cropObj['bool'] && parent.cropObj.activeObj.activePoint &&
                parent.cropObj.activeObj.activePoint.width !== 0 && parent.cropObj.activeObj.activePoint.height !== 0) {
                cssMaxWidth = parent.cropObj.activeObj.activePoint.width;
                cssMaxHeight = parent.cropObj.activeObj.activePoint.height;
            }
        }
        if (obj) {
            obj['width'] = cssMaxWidth;
            obj['height'] = cssMaxHeight;
        }
        return { width: cssMaxWidth, height: cssMaxHeight };
    };
    Transform.prototype.updatePanPoints = function (x, y) {
        var parent = this.parent;
        var tempActObj = extend({}, parent.activeObj, {}, true);
        var tempDestLeft = parent.img.destLeft;
        var tempDestTop = parent.img.destTop;
        if (isNullOrUndefined(this.tempPanMove)) {
            this.tempPanMove = { x: this.panMove.x, y: this.panMove.y };
        }
        var xDiff = this.panMove.x - this.tempPanMove.x;
        var yDiff = this.panMove.y - this.tempPanMove.y;
        if (x || y) {
            xDiff = x;
            yDiff = y;
        }
        parent.img.destLeft += xDiff;
        parent.img.destTop += yDiff;
        this.limitPan();
        var obj = { bool: null };
        var object = { isIntersect: null };
        parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
        parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: object } });
        parent.notify('draw', { prop: 'isSelOutsideImg', onPropertyChange: false, value: { obj: obj } });
        var count = 0;
        while (parent.transform.straighten !== 0 && (object['isIntersect'] || obj['bool'])) {
            count++;
            parent.img.destLeft = tempDestLeft;
            parent.img.destTop = tempDestTop;
            if (xDiff !== 0 && xDiff > 0) {
                xDiff -= 1;
            }
            else if (xDiff !== 0 && xDiff < 0) {
                xDiff += 1;
            }
            if (yDiff !== 0 && yDiff > 0) {
                yDiff -= 1;
            }
            else if (yDiff !== 0 && yDiff < 0) {
                yDiff += 1;
            }
            if ((xDiff === 0 && yDiff === 0) || count === 200) {
                break;
            }
            parent.img.destLeft += xDiff;
            parent.img.destTop += yDiff;
            this.limitPan();
            parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
            parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: object } });
            parent.notify('draw', { prop: 'isSelOutsideImg', onPropertyChange: false, value: { obj: obj } });
        }
        parent.activeObj = tempActObj;
        return { x: parent.img.destLeft - tempDestLeft, y: parent.img.destTop - tempDestTop };
    };
    Transform.prototype.resizeImage = function (width, height) {
        var parent = this.parent;
        var temp = true;
        var temp1 = true;
        parent.allowDownScale = false;
        parent.img.srcLeft = 0;
        parent.img.srcTop = 0;
        parent.isAspectRatio = true;
        var minimum = [];
        parent.img.srcWidth = parent.baseImgCanvas.width;
        parent.img.srcHeight = parent.baseImgCanvas.height;
        if (parent.resizeSrc && parent.resizeSrc.width !== 0 && parent.resizeSrc.height !== 0) {
            parent.img.srcLeft = parent.resizeSrc.startX;
            parent.img.srcTop = parent.resizeSrc.startY;
            parent.img.srcWidth = parent.resizeSrc.width;
            parent.img.srcHeight = parent.resizeSrc.height;
        }
        while ((width < parent.img.destWidth || height < parent.img.destHeight) && temp1) {
            this.zoomAction(-.1, null, true, true);
            if (width > parent.img.destWidth || height > parent.img.destHeight) {
                while (width > parent.img.destWidth || height > parent.img.destHeight) {
                    this.zoomAction(0.0125, null, true, true);
                    temp1 = false;
                    minimum.push(parent.img.destWidth);
                }
            }
        }
        while ((width > parent.img.destWidth || height > parent.img.destHeight) && temp1 && temp) {
            this.zoomAction(.1, null, true, true);
            if (width < parent.img.destWidth || height < parent.img.destHeight) {
                while (width < parent.img.destWidth) {
                    this.zoomAction(-.0125, null, true, true);
                    temp = false;
                    minimum.push(parent.img.destWidth);
                }
            }
        }
        var nearestNumber = minimum[0];
        var smallestDifference = Math.abs(parent.img.destWidth - nearestNumber);
        for (var _i = 0, minimum_1 = minimum; _i < minimum_1.length; _i++) {
            var num = minimum_1[_i];
            var difference = Math.abs(width - num);
            if (difference < smallestDifference) {
                nearestNumber = num;
                smallestDifference = difference;
            }
        }
        if (nearestNumber < width && temp) {
            this.zoomAction(-.0125, null, true, true);
            temp = false;
        }
        if (nearestNumber > width && !temp) {
            this.zoomAction(.0125, null, true, true);
            temp = false;
        }
        this.zoomAction(.0125, null, true);
        parent.allowDownScale = true;
        this.zoomAction(-.0125, null, true);
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var prevObj = extend({}, this.prevResizeCurrObj, {}, true);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: { operation: 'resize',
                previousObj: prevObj, previousObjColl: prevObj.objColl, previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl, previousCropObj: prevCropObj, previousText: null, currentText: null,
                previousFilter: null, isCircleCrop: parent.isCircleCrop } });
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
    };
    Transform.prototype.resizeCrop = function (width, height) {
        var parent = this.parent;
        var temp = true;
        var obj1 = { prevObj: parent.prevObj };
        parent.cropObj = extend({}, parent.prevCropObj, {}, true);
        parent.allowDownScale = false;
        parent.notify('toolbar', { prop: 'getPrevObj', onPropertyChange: false, value: { obj: obj1 } });
        var activeObj = extend({}, obj1['prevObj']['activeObj'], {}, true);
        obj1['prevObj']['activeObj'] = extend({}, parent.activeObj, {}, true);
        parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: obj1['prevObj'] } });
        parent.objColl = extend([], obj1['prevObj']['objColl'], [], true);
        parent.pointColl = extend([], obj1['prevObj']['pointColl'], [], true);
        parent.transform.straighten = 0;
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        if (parent.transform.straighten === 0 && !this.isPreventSelect) {
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
        }
        var tempwidth = width;
        var tempheight = height;
        var tempZoom = false;
        if (height >= width && height <= Math.ceil(parent.img.destHeight)) {
            while ((height <= Math.ceil(parent.img.destHeight)) && temp) {
                this.zoomAction(-.1, null, true, true);
                if (width > parent.img.destWidth || height > parent.img.destHeight) {
                    while (width > parent.img.destWidth || height > parent.img.destHeight) {
                        this.zoomAction(.0125, null, true, true);
                        temp = false;
                    }
                }
            }
        }
        else if (height <= width && width < parent.img.destWidth) {
            while ((width < parent.img.destWidth) && temp) {
                this.zoomAction(-.1, null, true, true);
                if (width > parent.img.destWidth || height > parent.img.destHeight) {
                    while (width > parent.img.destWidth || height > parent.img.destHeight) {
                        this.zoomAction(.0125, null, true, true);
                        temp = false;
                    }
                }
            }
        }
        else if (height >= width && height >= parent.img.destHeight) {
            while ((height >= parent.img.destHeight) && temp) {
                this.zoomAction(.1, null, true, true);
            }
        }
        else if (width >= height && width >= parent.img.destWidth) {
            while ((width >= parent.img.destWidth) && temp) {
                this.zoomAction(.1, null, true, true);
            }
            if (width < parent.img.destWidth && height < parent.img.destHeight) {
                while (width < parent.img.destWidth && height < parent.img.destHeight) {
                    this.zoomAction(-.0125, null, true, true);
                    temp = false;
                }
                this.zoomAction(.0125, null, true, true);
            }
        }
        else if (height > parent.img.destHeight && width > parent.img.destWidth) {
            while ((height > parent.img.destHeight) && (width > parent.img.destWidth) && temp) {
                this.zoomAction(.1, null, true, true);
            }
            if (width < parent.img.destWidth && height < parent.img.destHeight) {
                while (width < parent.img.destWidth && height < parent.img.destHeight) {
                    this.zoomAction(-.0125, null, true, true);
                    temp = false;
                }
                this.zoomAction(.0125, null, true, true);
            }
        }
        this.resizeImg(activeObj, width, height);
        width = tempwidth;
        height = tempheight;
        if ((height !== parent.img.destHeight || width !== parent.img.destWidth)) {
            while ((height > parent.img.destHeight || width > parent.img.destWidth)) {
                this.zoomAction(.0125, null, true, true);
                tempZoom = true;
            }
            if (tempZoom) {
                this.zoomAction(-.0125, null, true, true);
                tempZoom = false;
            }
        }
        if ((height !== parent.img.destHeight || width !== parent.img.destWidth)) {
            while ((height < parent.img.destHeight || width < parent.img.destWidth)) {
                this.zoomAction(-.0125, null, true, true);
                tempZoom = true;
            }
            if (tempZoom) {
                this.zoomAction(-.0125, null, true, true);
                tempZoom = false;
            }
        }
        obj1['prevObj']['activeObj'] = extend({}, activeObj, {}, true);
        this.zoomAction(.0125, null, true);
        parent.allowDownScale = this.preventDownScale ? false : true;
        parent.isCropTab = false;
        this.zoomAction(-.0125, null, true);
        parent.aspectWidth = width;
        parent.aspectHeight = height;
    };
    Transform.prototype.resizeImg = function (activeObj, width, height) {
        var parent = this.parent;
        var widthRatio = width / parent.img.destWidth;
        var heightRatio = height / parent.img.destHeight;
        if (activeObj.shape) {
            parent.currSelectionPoint = activeObj;
            parent.notify('crop', { prop: 'setInitCrop', onPropertyChange: false, value: { bool: true } });
        }
        else if (parent.img.srcWidth === parent.baseImgCanvas.width && parent.img.srcHeight === parent.baseImgCanvas.height) {
            parent.currSelectionPoint = null;
            parent.notify('draw', { prop: 'select', onPropertyChange: false,
                value: { type: 'custom', startX: null, startY: null, width: null, height: null } });
        }
        if (isNullOrUndefined(parent.currSelectionPoint)) {
            parent.notify('draw', { prop: 'select', onPropertyChange: false,
                value: { type: 'custom', startX: parent.img.destLeft, startY: parent.img.destTop,
                    width: parent.img.destWidth, height: parent.img.destHeight } });
        }
        else {
            parent.notify('draw', { prop: 'select', onPropertyChange: false,
                value: { type: 'custom', startX: null, startY: null, width: null, height: null } });
        }
        width = parent.activeObj.activePoint.width * widthRatio;
        height = parent.activeObj.activePoint.height * heightRatio;
        var sx = (parent.activeObj.activePoint.startX + (parent.activeObj.activePoint.width / 2)) - (width / 2);
        var sy = (parent.activeObj.activePoint.startY + (parent.activeObj.activePoint.height / 2)) - (height / 2);
        var count = 0;
        while (Browser.isDevice && count < 500 && (sx < 0 || sy < 0 || (sx + width) > parent.img.destWidth
            || (sy + height) > parent.img.destHeight)) {
            count++;
            width -= 1;
            height -= 1;
            sx = (parent.activeObj.activePoint.startX + (parent.activeObj.activePoint.width / 2)) - (width / 2);
            sy = (parent.activeObj.activePoint.startY + (parent.activeObj.activePoint.height / 2)) - (height / 2);
        }
        parent.transform.defaultZoomFactor = 0;
        parent.notify('draw', { prop: 'setResizeSelect', value: { bool: true } });
        parent.notify('draw', { prop: 'setIsCropSelect', value: { bool: true } });
        parent.notify('draw', { prop: 'select', onPropertyChange: false,
            value: { type: 'custom', startX: sx, startY: sy, width: width, height: height } });
        parent.notify('draw', { prop: 'setResizeSelect', value: { bool: false } });
        if (parent.transform.straighten !== 0) {
            var obj = { isIntersect: null, arr: null };
            parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
            parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: obj } });
            while (obj['arr'][0] || obj['arr'][1] || obj['arr'][2] || obj['arr'][3]) {
                this.zoomAction(.0125, null, true);
                parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });
                parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: obj } });
            }
        }
        parent.isCropToolbar = true;
        parent.crop();
        parent.isCropToolbar = false;
    };
    Transform.prototype.updateResize = function () {
        var parent = this.parent;
        parent.prevCropObj = extend({}, parent.cropObj, {}, true);
        var currObject = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: currObject } });
        parent.prevObj = currObject['currObj'];
        if (parent.currSelectionPoint && parent.prevCropObj.activeObj.shape) {
            parent.prevObj.activeObj = extend({}, parent.prevCropObj.activeObj, {}, true);
        }
        parent.prevObj.objColl = extend([], parent.objColl, [], true);
        parent.prevObj.pointColl = extend([], parent.pointColl, [], true);
        parent.prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        parent.prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        parent.resizeSrc = { startX: parent.img.srcLeft, startY: parent.img.srcTop, width: parent.img.srcWidth,
            height: parent.img.srcHeight };
    };
    Transform.prototype.resize = function (width, height, isAspectRatio) {
        var parent = this.parent;
        var aspectHeight;
        parent.isResize = true;
        if (isNullOrUndefined(parent.prevCropObj) && isNullOrUndefined(parent.prevObj)) {
            parent.notify('transform', { prop: 'updateResize', value: { bool: false } });
        }
        var aspectIcon = parent.element.querySelector('#' + parent.element.id + '_aspectratio');
        var nonAspectIcon = parent.element.querySelector('#' + parent.element.id + '_nonaspectratio');
        if (aspectIcon && nonAspectIcon) {
            parent.notify('toolbar', { prop: 'initResizeToolbar' });
            if (Browser.isDevice) {
                parent.notify('toolbar', { prop: 'init-main-toolbar', value: { isApplyBtn: false, isDevice: true, isOkBtn: true, isResize: true } });
            }
        }
        var aspectRatioHeight = parent.element.querySelector('#' + parent.element.id + '_resizeHeight');
        if (aspectRatioHeight) {
            aspectHeight = aspectRatioHeight.value === '' ? aspectRatioHeight.placeholder : aspectRatioHeight.value;
        }
        else {
            aspectHeight = height + 'px';
        }
        var resizeEventArgs = { cancel: false, previousWidth: Math.ceil(parent.img.destWidth),
            previousHeight: Math.ceil(parent.img.destHeight), width: Math.ceil(width), height: height && height !== 0 ? Math.ceil(height) :
                (isAspectRatio ? Math.ceil(parseFloat(aspectHeight)) : Math.ceil(parent.img.destHeight)),
            isAspectRatio: isAspectRatio ? isAspectRatio : false };
        parent.trigger('resizing', resizeEventArgs);
        parent.editCompleteArgs = resizeEventArgs;
        if (!resizeEventArgs.cancel) {
            this.resizeEventHandler(resizeEventArgs);
        }
        else if (parent.aspectHeight && parent.aspectWidth) {
            parent.aspectHeight = resizeEventArgs.previousHeight;
            parent.aspectWidth = resizeEventArgs.previousWidth;
        }
    };
    Transform.prototype.resizeEventHandler = function (args) {
        var parent = this.parent;
        var isRotate;
        var aspectRatioWidth = parent.element.querySelector('#' + parent.element.id + '_resizeWidth');
        var aspectRatioHeight = parent.element.querySelector('#' + parent.element.id + '_resizeHeight');
        if (args.isAspectRatio) {
            if (this.resizedImgAngle == null || this.resizedImgAngle !== parent.transform.degree) {
                this.resizedImgAngle = parent.transform.degree;
                isRotate = true;
            }
            if (isRotate) {
                parent.notify('transform', { prop: 'resizeImage', value: { width: args.width, height: 0 } });
                var originalWidth = parent.img.destWidth;
                var originalHeight = parent.img.destHeight;
                var aspectRatioWidthValue = void 0;
                if (aspectRatioHeight) {
                    aspectRatioWidthValue = parseFloat(aspectRatioWidth.value === '' ? aspectRatioWidth.placeholder : aspectRatioWidth.value);
                    var value = aspectRatioWidthValue / (originalWidth / originalHeight);
                    // eslint-disable-next-line max-len
                    var height = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : (value < 0) ? Math.ceil(value) : Math.floor(value);
                    getComponent(aspectRatioHeight, 'numerictextbox').value = height;
                    aspectRatioHeight.value = height.toString() + ' px';
                    parent.aspectHeight = height;
                    if (aspectRatioWidth && aspectRatioWidth.value === '') {
                        var aspectRatioHeightValue = parseFloat(aspectRatioHeight.value === '' ? aspectRatioHeight.placeholder :
                            aspectRatioHeight.value);
                        value = aspectRatioHeightValue / (originalHeight / originalWidth);
                        // eslint-disable-next-line max-len
                        var width = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : (value < 0) ? Math.ceil(value) : Math.floor(value);
                        getComponent(aspectRatioWidth, 'numerictextbox').value = width;
                        aspectRatioWidth.value = width.toString() + ' px';
                        parent.aspectWidth = width;
                    }
                }
            }
            else {
                parent.notify('transform', { prop: 'resizeImage', value: { width: args.width, height: null } });
            }
        }
        else {
            if (this.resizedImgAngle !== null && this.resizedImgAngle !== parent.transform.degree) {
                this.resizedImgAngle = parent.transform.degree;
                isRotate = true;
            }
            if (isRotate) {
                parent.notify('transform', { prop: 'setPreventDownScale', value: { bool: true } });
                parent.notify('transform', { prop: 'resizeCrop', value: { width: args.width, height: args.height } });
                parent.notify('undo-redo', { prop: 'setPreventUR', value: { bool: true } });
                parent.okBtn(null, true);
                parent.notify('undo-redo', { prop: 'setPreventUR', value: { bool: false } });
                parent.resizeSrc = { startX: parent.img.srcLeft, startY: parent.img.srcTop, width: parent.img.srcWidth,
                    height: parent.img.srcHeight };
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'resize',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                parent.notify('transform', { prop: 'setPreventDownScale', value: { bool: false } });
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'resize',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            }
            else {
                parent.notify('transform', { prop: 'resizeCrop', value: { width: args.width, height: args.height } });
            }
        }
        this.resizedImgAngle = parent.transform.degree;
    };
    Transform.prototype.straightenImage = function (degree) {
        var parent = this.parent;
        var isSelection = parent.activeObj.shape && parent.activeObj.shape.indexOf('crop-') > -1;
        if (parent.toolbar && parent.toolbar.length === 0) {
            parent.notify('draw', { prop: 'select', onPropertyChange: false,
                value: { type: 'custom', startX: null, startY: null, width: null, height: null } });
        }
        parent.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: null } });
        parent.setStraighten(degree);
        if (!isSelection) {
            parent.okBtn();
        }
    };
    return Transform;
}());

var UndoRedo = /** @class */ (function () {
    function UndoRedo(parent) {
        this.undoRedoStep = 0;
        this.undoRedoColl = [];
        this.appliedUndoRedoColl = [];
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
        this.isPreventing = false;
        this.parent = parent;
        this.addEventListener();
    }
    UndoRedo.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    UndoRedo.prototype.addEventListener = function () {
        this.parent.on('undo-redo', this.undoRedo, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    UndoRedo.prototype.removeEventListener = function () {
        this.parent.off('undo-redo', this.undoRedo);
        this.parent.off('destroyed', this.destroy);
    };
    UndoRedo.prototype.initializeUrPvtProp = function () {
        if (this.parent.lowerCanvas) {
            this.lowerContext = this.parent.lowerCanvas.getContext('2d');
        }
        if (this.parent.upperCanvas) {
            this.upperContext = this.parent.upperCanvas.getContext('2d');
        }
    };
    UndoRedo.prototype.undoRedo = function (args) {
        this.initializeUrPvtProp();
        switch (args.prop) {
            case 'updateUndoRedoColl':
                this.updateUrc(args.value['operation'], args.value['previousObj'], args.value['previousObjColl'], args.value['previousPointColl'], args.value['previousSelPointColl'], args.value['previousCropObj'], args.value['previousText'], args.value['currentText'], args.value['previousFilter'], args.value['isCircleCrop']);
                break;
            case 'refreshUrc':
                this.refreshUrc(args.value['bool']);
                break;
            case 'updateCurrUrc':
                this.updateCurrUrc(args.value['type'], args.value['isCancel']);
                break;
            case 'call-undo':
                this.callUndo();
                break;
            case 'call-redo':
                this.callRedo();
                break;
            case 'undo':
                this.undo();
                break;
            case 'redo':
                this.redo();
                break;
            case 'updateUrObj':
                this.updateUrObj(args.value['objColl'], args.value['operation']);
                break;
            case 'updateUndoRedo':
                this.updateUndoRedo(args.value ? args.value['operation'] : null);
                break;
            case 'getAppliedUndoRedoColl':
                args.value['obj']['appliedUndoRedoColl'] = this.appliedUndoRedoColl;
                break;
            case 'getUndoRedoStep':
                args.value['obj']['undoRedoStep'] = this.undoRedoStep;
                break;
            case 'setUndoRedoStep':
                this.undoRedoStep = args.value['step'];
                break;
            case 'undoDefault':
                this.undoDefault(args.value['obj']);
                break;
            case 'setPreventUR':
                this.isPreventing = args.value['bool'];
                break;
            case 'updateUndoRedoStack':
                if (args.value && args.value['isPenDraw']) {
                    this.updateUndoRedoStack(args.value['isPenDraw']);
                }
                else {
                    this.updateUndoRedoStack();
                }
                break;
            case 'reset':
                this.reset();
                break;
        }
    };
    UndoRedo.prototype.getModuleName = function () {
        return 'undo-redo';
    };
    UndoRedo.prototype.reset = function () {
        this.tempCurrSelPoint = null;
        this.undoRedoStep = 0;
        this.undoRedoColl = [];
        this.appliedUndoRedoColl = [];
        this.tempActObj = null;
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
        this.isPreventing = false;
    };
    UndoRedo.prototype.refreshUrc = function (refreshToolbar) {
        var parent = this.parent;
        if (parent.isImageUpdated) {
            return;
        }
        refreshToolbar = refreshToolbar ? refreshToolbar : false;
        if (refreshToolbar) {
            parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: true } });
            this.tempUndoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
            this.tempUndoRedoStep = this.undoRedoStep;
        }
        parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: false } });
        this.undoRedoColl = this.undoRedoColl.slice(0, this.undoRedoStep);
        this.appliedUndoRedoColl = this.appliedUndoRedoColl.slice(0, this.undoRedoStep);
        parent.isUndoRedo = parent.currObjType.isUndoAction = false;
        parent.notify('toolbar', { prop: 'enable-disable-btns' });
    };
    UndoRedo.prototype.updateCurrUrc = function (type, isCancel) {
        var parent = this.parent;
        if (parent.isResize || this.isPreventing || parent.noPushUndo) {
            return;
        }
        parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: false } });
        if (type === 'ok') {
            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: false } });
            var collection = this.tempUndoRedoColl.length > 0 ?
                extend([], this.tempUndoRedoColl, [], true) :
                extend([], this.undoRedoColl, [], true);
            var prevObj = this.undoRedoColl[this.undoRedoColl.length - 1];
            var appliedURColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
            var prevTransform = prevObj ? extend({}, prevObj.previousObj, {}, true)
                : null;
            if (isNullOrUndefined(appliedURColl)) {
                if (this.undoRedoColl[0]) {
                    prevObj.previousCropObj = collection[0].previousCropObj;
                    prevObj.previousObj = collection[0].previousObj;
                    prevObj.previousObjColl = collection[0].previousObjColl;
                    prevObj.previousPointColl = collection[0].previousPointColl;
                    prevObj.previousText = collection[0].previousText;
                }
            }
            else if (prevObj.operation !== 'imageHFlip' && prevObj.operation !== 'imageVFlip') {
                prevObj.previousCropObj = appliedURColl.currentCropObj;
                prevObj.previousObj = appliedURColl.currentObj;
                prevObj.previousObjColl = appliedURColl.currentObjColl;
                prevObj.previousPointColl = appliedURColl.currentPointColl;
                prevObj.previousText = appliedURColl.currentText;
                if (prevObj.operation === 'frame' && prevObj.previousObj && prevTransform) {
                    prevObj.previousObj.defaultZoom = prevTransform.defaultZoom;
                    prevObj.previousObj.zoomFactor = prevTransform.zoomFactor;
                    prevObj.previousObj.cropZoom = prevTransform.cropZoom;
                }
            }
            if (prevObj) {
                if (prevObj.operation !== 'imageHFlip' && prevObj.operation !== 'imageVFlip') {
                    var obj = this.getZeroZoomObjPointValue(prevObj.currentObjColl, prevObj.currentPointColl);
                    prevObj.currentObjColl = obj['obj'];
                    prevObj.currentPointColl = obj['point'];
                    var adjObj = { adjustmentLevel: null };
                    parent.notify('filter', { prop: 'getAdjustmentLevel', onPropertyChange: false, value: { obj: adjObj } });
                    prevObj.currentObj.adjustmentLevel = extend({}, adjObj['adjustmentLevel'], {}, true);
                    parent.notify('filter', { prop: 'setTempAdjVal' });
                    prevObj.currentObj.currentFilter = parent.currentFilter;
                }
                this.appliedUndoRedoColl.push(prevObj);
                if (!isCancel) {
                    this.triggerActionCompletedEvent(prevObj.operation);
                }
            }
            this.tempUndoRedoColl = [];
            this.tempUndoRedoStep = 0;
        }
        else if (this.tempUndoRedoColl.length > 0) {
            this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
            this.undoRedoStep = this.tempUndoRedoStep;
            this.tempUndoRedoColl = [];
            this.tempUndoRedoStep = 0;
        }
        var lastObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
        var lastPrevObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 2];
        if (this.appliedUndoRedoColl.length > 16) {
            this.appliedUndoRedoColl.splice(0, 1);
        }
        else if (!isCancel && lastObj && lastPrevObj) {
            if ((((lastObj.operation === 'shapeTransform' && lastPrevObj.operation === 'shapeTransform') ||
                (lastObj.operation === 'shapeInsert' && lastPrevObj.operation === 'shapeInsert')) &&
                JSON.stringify(lastObj.currentObjColl) === JSON.stringify(lastPrevObj.currentObjColl)) ||
                (lastObj.operation === 'freehand-draw' && lastPrevObj.operation === 'freehand-draw' &&
                    JSON.stringify(lastObj.currentPointColl) === JSON.stringify(lastPrevObj.currentPointColl)) ||
                (lastObj.operation === 'freehanddrawCustomized' && lastPrevObj.operation === 'freehanddrawCustomized' &&
                    JSON.stringify(lastObj.currentPointColl) === JSON.stringify(lastPrevObj.currentPointColl))) {
                this.appliedUndoRedoColl.splice(this.appliedUndoRedoColl.length - 1, 1);
            }
            else if (this.undoRedoStep !== this.appliedUndoRedoColl.length - 1) {
                lastObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
                lastPrevObj = this.appliedUndoRedoColl[this.undoRedoStep];
                if (lastObj && lastPrevObj && lastObj.operation === 'shapeTransform' &&
                    lastPrevObj.operation === 'shapeTransform' &&
                    JSON.stringify(lastObj.currentObjColl) === JSON.stringify(lastPrevObj.previousObjColl)) {
                    this.appliedUndoRedoColl.splice(this.appliedUndoRedoColl.length - 1, 1);
                    this.undoRedoColl = [];
                    this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
                    return;
                }
            }
        }
        this.undoRedoColl = [];
        this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
        if (type === 'ok') {
            this.undoRedoStep = this.undoRedoColl.length;
            parent.notify('toolbar', { prop: 'enable-disable-btns' });
        }
        if (parent.transform.zoomFactor > 0) {
            parent.togglePan = true;
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
        }
    };
    UndoRedo.prototype.triggerActionCompletedEvent = function (action) {
        var parent = this.parent;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var actionMap = { 'brightness': 'fine-tune', 'contrast': 'fine-tune', 'hue': 'fine-tune',
            'saturation': 'fine-tune', 'opacity': 'fine-tune', 'blur': 'fine-tune', 'exposure': 'fine-tune',
            'default': 'filter', 'chrome': 'filter', 'cold': 'filter', 'warm': 'filter',
            'grayscale': 'filter', 'sepia': 'filter', 'invert': 'filter',
            'deleteObj': 'shape-delete', 'deleteFreehandDrawing': 'freehand-draw-delete',
            'shapeInsert': 'shape-insert', 'shapeTransform': 'shape-customize',
            'freehanddrawCustomized': 'freehand-draw-customize'
        };
        var actionResult = actionMap[action] || action;
        var actionArgs = { action: actionResult, actionEventArgs: parent.editCompleteArgs };
        parent.triggerEditCompleteEvent(actionArgs);
    };
    UndoRedo.prototype.getUndoRedoAction = function (action) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var actionMap = { 'brightness': 'fine-tune', 'contrast': 'fine-tune', 'hue': 'fine-tune',
            'saturation': 'fine-tune', 'opacity': 'fine-tune', 'blur': 'fine-tune', 'exposure': 'fine-tune',
            'default': 'filter', 'chrome': 'filter', 'cold': 'filter', 'warm': 'filter',
            'grayscale': 'filter', 'sepia': 'filter', 'invert': 'filter',
            'deleteObj': 'shape-delete', 'deleteFreehandDrawing': 'freehand-drawing-delete',
            'shapeInsert': 'shape-insert', 'shapeTransform': 'shape-customize', 'imageRotate': 'shape-customize',
            'freehanddraw': 'freehand-draw', 'freehanddrawCustomized': 'freehand-draw-customize',
            'textAreaCustomization': 'text-area-customization', 'imageHFlip': 'shape-customize',
            'imageVFlip': 'shape-customize', 'bgColor': 'background-color', 'updateImage': 'image-update'
        };
        return actionMap[action] || action;
    };
    UndoRedo.prototype.cancelCropSelection = function () {
        var parent = this.parent;
        var isCropSelection = false;
        var splitWords;
        if (parent.activeObj.shape) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (parent.currObjType.isCustomCrop || (splitWords && splitWords[0] === 'crop')) {
            isCropSelection = true;
        }
        if (isCropSelection) {
            parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
        }
        if (this.tempUndoRedoColl.length !== 0 || this.tempUndoRedoStep !== 0) {
            this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
            this.undoRedoColl = extend([], this.tempUndoRedoColl, [], true);
            this.undoRedoStep = this.tempUndoRedoStep;
            this.tempUndoRedoColl = [];
            this.tempUndoRedoStep = 0;
            parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: false } });
        }
    };
    UndoRedo.prototype.refreshToolbarActions = function () {
        var parent = this.parent;
        if (parent.activeObj.shape) {
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
        }
        else {
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        }
    };
    UndoRedo.prototype.applyCurrentChanges = function () {
        var parent = this.parent;
        parent.currObjType.isFiltered = false;
        if (parent.transform.zoomFactor === 0) {
            parent.togglePan = false;
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
        }
        if (parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
            parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
        }
        if (parent.togglePen) {
            parent.togglePen = false;
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        if (this.appliedUndoRedoColl.length > 0) {
            this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
        }
    };
    UndoRedo.prototype.callUndo = function () {
        this.applyCurrentChanges();
        this.undo();
    };
    UndoRedo.prototype.callRedo = function () {
        this.applyCurrentChanges();
        this.redo();
    };
    UndoRedo.prototype.undo = function () {
        var parent = this.parent;
        this.cancelCropSelection();
        parent.notify('draw', { prop: 'resetFrameZoom', onPropertyChange: false, value: { isOk: false } });
        if (!parent.disabled && parent.isImageLoaded) {
            if (this.undoRedoStep > 0) {
                this.refreshToolbarActions();
                if (parent.activeObj.activePoint && parent.activeObj.activePoint.width !== 0) {
                    this.tempActObj = parent.activeObj;
                }
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.undoRedoStep--;
                parent.notify('toolbar', { prop: 'enable-disable-btns' });
                if (parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
                    parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                }
                parent.isUndoRedo = true;
                var obj = this.undoRedoColl[this.undoRedoStep];
                if (this.undoRedoColl.length === this.undoRedoStep) {
                    parent.currObjType.isUndoAction = false;
                }
                else {
                    parent.currObjType.isUndoAction = true;
                }
                if (obj.operation !== 'textAreaCustomization' &&
                    (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')) {
                    parent.textArea.style.display = 'none';
                }
                parent.notify('draw', { prop: 'setCancelAction', onPropertyChange: false, value: { bool: true } });
                var activeObj = void 0;
                parent.cropObj = extend({}, obj.previousCropObj, {}, true);
                parent.afterCropActions = obj.previousObj.afterCropActions;
                this.lowerContext.filter = obj.previousObj.filter;
                parent.notify('filter', { prop: 'setAdjustmentLevel', onPropertyChange: false, value: { adjustmentLevel: obj.previousObj.adjustmentLevel } });
                parent.notify('filter', { prop: 'setTempAdjVal' });
                parent.currentFilter = obj.previousObj.currentFilter;
                parent.notify('filter', { prop: 'setTempFilVal' });
                parent.canvasFilter = this.lowerContext.filter;
                parent.initialAdjustmentValue = this.lowerContext.filter;
                parent.notify('filter', { prop: 'setBevelFilter', onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
                var editCompleteArgs = { action: this.getUndoRedoAction(obj.operation) };
                switch (obj.operation) {
                    case 'shapeTransform':
                    case 'brightness':
                    case 'contrast':
                    case 'hue':
                    case 'saturation':
                    case 'opacity':
                    case 'blur':
                    case 'exposure':
                    case 'default':
                    case 'chrome':
                    case 'cold':
                    case 'warm':
                    case 'grayscale':
                    case 'blackandwhite':
                    case 'sepia':
                    case 'invert':
                    case 'sharpen':
                    case 'imageRotate':
                    case 'shapeInsert':
                        this.shapeTransform(obj.previousObjColl, obj.previousPointColl);
                        break;
                    case 'freehanddraw':
                    case 'freehand-draw':
                        this.updateFreehandDraw(obj.previousPointColl, obj.previousSelPointColl);
                        parent.notify('freehand-draw', { prop: 'setCurrentFreehandDrawIndex',
                            value: { value: parent.pointColl.length } });
                        break;
                    case 'freehanddrawCustomized':
                        this.updateFreehandDrawCustomized(obj.previousObjColl, obj.previousPointColl);
                        break;
                    case 'deleteFreehandDrawing':
                    case 'deleteObj':
                        this.updateDelete(obj.operation, obj.previousObjColl, obj.previousPointColl, obj.previousSelPointColl);
                        break;
                    case 'textAreaCustomization':
                        this.shapeTransform(obj.previousObjColl, obj.previousPointColl);
                        this.updateTextAreaCustomization(activeObj, obj.previousObjColl);
                        break;
                    case 'text':
                        this.updateText(obj.previousObjColl, true);
                        break;
                    case 'frame':
                        parent.transform.zoomFactor = parent.transform.defaultZoomFactor = obj.previousObj.defaultZoom;
                        parent.setProperties({ zoomSettings: { zoomFactor: obj.previousObj.zoomFactor } }, true);
                        parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
                            value: { previousZoomValue: parent.zoomSettings.zoomFactor } });
                        extend(parent.frameObj, obj.previousObj.frameObj);
                        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: true, isPreventClearRect: null, isFrame: true } });
                        break;
                    case 'imageHFlip':
                        this.imageFlip('horizontal', obj.previousObjColl);
                        break;
                    case 'imageVFlip':
                        this.imageFlip('vertical', obj.previousObjColl);
                        break;
                    case 'bgColor':
                        parent.notify('draw', { prop: 'imageBackgroundColor', onPropertyChange: false, value: { color: obj.previousObj.bgColor } });
                        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
                        break;
                    case 'updateImage':
                        parent.isImageUpdated = true;
                        parent.baseImg.src = obj.previousObj.imageSource;
                        setTimeout(function () {
                            if (parent.cropObj.straighten !== 0) {
                                parent.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: 'crop-' + 'custom' } });
                                parent.noPushUndo = true;
                                parent.crop();
                                parent.noPushUndo = false;
                            }
                            else {
                                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
                            }
                            parent.isImageUpdated = false;
                        });
                        break;
                    default:
                        this.undoDefault(obj, true);
                        parent.notify('filter', { prop: 'set-adjustment', value: { operation: obj.operation } });
                        parent.notify('filter', { prop: 'update-filter', value: { operation: obj.operation, filter: obj.filter } });
                        break;
                }
                if (obj.operation === 'crop') {
                    if (obj.previousObj.currSelectionPoint) {
                        parent.currSelectionPoint = extend({}, obj.previousObj.currSelectionPoint, {}, true);
                        if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                            parent.currSelectionPoint = null;
                        }
                    }
                    parent.updateCropTransformItems();
                    parent.notify('draw', { prop: 'select', onPropertyChange: false,
                        value: { type: 'custom', startX: null, startY: null, width: null, height: null } });
                    if (parent.isCircleCrop) {
                        parent.isCircleCrop = false;
                        this.tempCurrSelPoint = extend({}, parent.currSelectionPoint, {}, true);
                        parent.currSelectionPoint = null;
                    }
                    var tempCircleCrop = parent.cancelCropSelection.isCircleCrop;
                    parent.cancelCropSelection.isCircleCrop = false;
                    parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null, isUndoRedo: true } });
                    parent.cancelCropSelection.isCircleCrop = tempCircleCrop;
                    parent.currObjType.isActiveObj = false;
                    if (parent.transform.straighten !== 0) {
                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                    }
                }
                else if (obj.operation === 'resize' && parent.cropObj && parent.cropObj.activeObj) {
                    parent.currSelectionPoint = extend({}, parent.cropObj.activeObj, {}, true);
                }
                if ((this.undoRedoColl[this.undoRedoStep - 1]
                    && this.undoRedoColl[this.undoRedoStep - 1].isCircleCrop)) {
                    parent.isCircleCrop = true;
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                this.endUndoRedo(obj.operation, true);
                var action = { action: 'undo', actionEventArgs: editCompleteArgs };
                parent.triggerEditCompleteEvent(action);
            }
        }
    };
    UndoRedo.prototype.redo = function () {
        var parent = this.parent;
        this.cancelCropSelection();
        parent.notify('draw', { prop: 'resetFrameZoom', onPropertyChange: false, value: { isOk: false } });
        if (!parent.disabled && parent.isImageLoaded) {
            if (this.undoRedoStep < this.appliedUndoRedoColl.length) {
                this.refreshToolbarActions();
                this.undoRedoStep++;
                parent.notify('toolbar', { prop: 'enable-disable-btns' });
                parent.isUndoRedo = true;
                var obj = this.undoRedoColl[this.undoRedoStep - 1];
                if (this.undoRedoColl.length === this.undoRedoStep) {
                    parent.currObjType.isUndoAction = false;
                }
                else {
                    parent.currObjType.isUndoAction = true;
                }
                if (obj.operation !== 'textAreaCustomization' &&
                    (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')) {
                    parent.textArea.style.display = 'none';
                }
                parent.notify('draw', { prop: 'setCancelAction', onPropertyChange: false, value: { bool: true } });
                parent.cropObj = extend({}, obj.currentCropObj, {}, true);
                parent.afterCropActions = obj.currentObj.afterCropActions;
                this.lowerContext.filter = obj.currentObj.filter;
                if (parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
                    parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                }
                parent.notify('filter', { prop: 'setAdjustmentLevel', onPropertyChange: false, value: { adjustmentLevel: obj.currentObj.adjustmentLevel } });
                parent.notify('filter', { prop: 'setTempAdjVal' });
                parent.currentFilter = obj.currentObj.currentFilter;
                parent.notify('filter', { prop: 'setTempFilVal' });
                parent.canvasFilter = this.lowerContext.filter;
                parent.initialAdjustmentValue = this.lowerContext.filter;
                parent.notify('filter', { prop: 'setBevelFilter', onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
                var activeObj = void 0;
                var editCompleteArgs = { action: this.getUndoRedoAction(obj.operation) };
                switch (obj.operation) {
                    case 'shapeTransform':
                    case 'brightness':
                    case 'contrast':
                    case 'hue':
                    case 'saturation':
                    case 'opacity':
                    case 'blur':
                    case 'exposure':
                    case 'default':
                    case 'chrome':
                    case 'cold':
                    case 'warm':
                    case 'grayscale':
                    case 'blackandwhite':
                    case 'sepia':
                    case 'invert':
                    case 'sharpen':
                    case 'imageRotate':
                    case 'shapeInsert':
                        this.shapeTransform(obj.currentObjColl, obj.currentPointColl);
                        break;
                    case 'freehanddraw':
                    case 'freehand-draw':
                        this.updateFreehandDraw(obj.currentPointColl, obj.currentSelPointColl);
                        parent.notify('freehand-draw', { prop: 'setCurrentFreehandDrawIndex',
                            value: { value: parent.pointColl.length } });
                        break;
                    case 'freehanddrawCustomized':
                        this.updateFreehandDrawCustomized(obj.currentObjColl, obj.currentPointColl);
                        break;
                    case 'deleteFreehandDrawing':
                    case 'deleteObj':
                        this.updateDelete(obj.operation, obj.currentObjColl, obj.currentPointColl, obj.currentSelPointColl);
                        break;
                    case 'textAreaCustomization':
                        this.shapeTransform(obj.currentObjColl, obj.currentPointColl);
                        this.updateTextAreaCustomization(activeObj, obj.currentObjColl);
                        break;
                    case 'text':
                        this.updateText(obj.currentObjColl, false);
                        break;
                    case 'frame':
                        extend(parent.frameObj, obj.currentObj.frameObj);
                        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: true, isPreventClearRect: null, isFrame: true } });
                        break;
                    case 'imageHFlip':
                        this.imageFlip('horizontal', obj.currentObjColl);
                        break;
                    case 'imageVFlip':
                        this.imageFlip('vertical', obj.currentObjColl);
                        break;
                    case 'bgColor':
                        parent.notify('draw', { prop: 'imageBackgroundColor', onPropertyChange: false, value: { color: obj.currentObj.bgColor } });
                        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
                        break;
                    case 'updateImage':
                        parent.isImageUpdated = true;
                        parent.baseImg.src = obj.currentObj.imageSource;
                        setTimeout(function () {
                            if (parent.cropObj.straighten !== 0) {
                                parent.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: 'crop-' + 'custom' } });
                                parent.noPushUndo = true;
                                parent.crop();
                                parent.noPushUndo = false;
                            }
                            else {
                                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
                            }
                            parent.isImageUpdated = false;
                        });
                        break;
                    default:
                        parent.objColl = [];
                        parent.pointColl = [];
                        parent.freehandCounter = 0;
                        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                            value: { obj: { selPointColl: [] } } });
                        parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: obj.currentObj, isUndoRedo: true } });
                        parent.img.destLeft = obj.currentObj.destPoints.startX;
                        parent.img.destTop = obj.currentObj.destPoints.startY;
                        activeObj = extend({}, parent.activeObj, {}, true);
                        parent.objColl = extend([], obj.currentObjColl, [], true);
                        parent.pointColl = extend([], obj.currentPointColl, [], true);
                        parent.freehandCounter = parent.pointColl.length;
                        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                            value: { obj: { selPointColl: extend([], obj.currentSelPointColl, [], true) } } });
                        parent.transform.straighten = 0;
                        this.lowerContext.filter = 'none';
                        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
                        this.lowerContext.filter = obj.currentObj.filter;
                        parent.prevStraightenedDegree = parent.transform.straighten;
                        parent.activeObj = activeObj;
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
                        }
                        parent.notify('filter', { prop: 'set-adjustment', value: { operation: obj.operation } });
                        parent.notify('filter', { prop: 'update-filter', value: { operation: obj.operation } });
                        break;
                }
                if (obj.operation === 'crop' && obj.isCircleCrop) {
                    parent.isCircleCrop = true;
                    parent.currSelectionPoint = extend({}, this.tempCurrSelPoint, {}, true);
                    this.tempCurrSelPoint = null;
                }
                if (obj.operation === 'crop' && !obj.isCircleCrop) {
                    parent.isCircleCrop = false;
                }
                if (obj.operation === 'crop' && obj.currentObj.currSelectionPoint) {
                    parent.currSelectionPoint = extend({}, obj.currentObj.currSelectionPoint, {}, true);
                    parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: parent.currSelectionPoint } });
                }
                if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                    parent.currSelectionPoint = null;
                }
                if (obj.operation === 'resize' && parent.cropObj && parent.cropObj.activeObj) {
                    parent.currSelectionPoint = extend({}, parent.cropObj.activeObj, {}, true);
                }
                this.endUndoRedo(obj.operation, false);
                var action = { action: 'redo', actionEventArgs: editCompleteArgs };
                parent.triggerEditCompleteEvent(action);
            }
        }
    };
    UndoRedo.prototype.imageFlip = function (type, objColl) {
        var parent = this.parent;
        this.shapeTransform(objColl, null);
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        var _a = parent.activeObj, shape = _a.shape, isHorImageFlip = _a.isHorImageFlip, isVerImageFlip = _a.isVerImageFlip;
        parent.objColl.pop();
        if (shape && shape === 'image') {
            if (type === 'horizontal') {
                if (isNullOrUndefined(isHorImageFlip) && isVerImageFlip) {
                    parent.activeObj.isHorImageFlip = true;
                    parent.activeObj.isVerImageFlip = null;
                    parent.horizontalFlip(this.upperContext, true);
                }
                else {
                    if (isNullOrUndefined(isHorImageFlip) || !isHorImageFlip) {
                        parent.activeObj.isHorImageFlip = true;
                    }
                    else {
                        parent.activeObj.isHorImageFlip = null;
                    }
                    parent.horizontalFlip(this.upperContext, true);
                }
            }
            else if (type === 'vertical') {
                if (isNullOrUndefined(isVerImageFlip) && isHorImageFlip) {
                    parent.activeObj.isVerImageFlip = true;
                    parent.activeObj.isHorImageFlip = null;
                    parent.verticalFlip(this.upperContext, true);
                }
                else {
                    if (isNullOrUndefined(isVerImageFlip) || !isVerImageFlip) {
                        parent.activeObj.isVerImageFlip = true;
                    }
                    else {
                        parent.activeObj.isVerImageFlip = null;
                    }
                    parent.verticalFlip(this.upperContext, true);
                }
            }
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
        }
        else {
            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: true } });
        }
    };
    UndoRedo.prototype.shapeTransform = function (objColl, pointColl) {
        var parent = this.parent;
        parent.objColl = extend([], objColl, [], true);
        if (pointColl) {
            parent.pointColl = extend([], pointColl, [], true);
            parent.freehandCounter = parent.pointColl.length;
        }
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
    };
    UndoRedo.prototype.updateFreehandDraw = function (pointColl, selPointColl) {
        var parent = this.parent;
        parent.pointColl = pointColl;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: selPointColl } } });
        parent.freehandCounter = parent.pointColl.length;
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
    };
    UndoRedo.prototype.updateFreehandDrawCustomized = function (objColl, pointColl) {
        var parent = this.parent;
        parent.objColl = extend([], objColl, [], true);
        parent.pointColl = pointColl;
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
    };
    UndoRedo.prototype.updateDelete = function (operation, objColl, pointColl, selPointColl) {
        var parent = this.parent;
        if (operation === 'deleteFreehandDrawing') {
            parent.pointColl = pointColl;
            parent.freehandCounter = parent.pointColl.length;
            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                value: { obj: { selPointColl: selPointColl } } });
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        }
        else if (operation === 'deleteObj') {
            parent.objColl = objColl;
            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        }
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
    };
    UndoRedo.prototype.updateTextAreaCustomization = function (activeObj, objColl) {
        var parent = this.parent;
        parent.objColl = extend([], objColl, [], true);
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        for (var i = 0, len = objColl.length; i < len; i++) {
            if (this.tempActObj) {
                if (this.tempActObj.currIndex === objColl[i].currIndex) {
                    activeObj = extend({}, objColl[i], {}, true);
                    parent.objColl.splice(i, 1);
                    break;
                }
            }
            else {
                activeObj = extend({}, objColl[objColl.length - 1], {}, true);
                parent.objColl.splice(i, 1);
                break;
            }
        }
        if (activeObj) {
            this.updateTextBox(activeObj);
        }
        if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
        }
    };
    UndoRedo.prototype.updateText = function (objColl, allowActiveObj) {
        var parent = this.parent;
        if (this.tempActObj) {
            parent.activeObj = extend({}, this.tempActObj, {}, true);
        }
        if (objColl.length === 0 && parent.objColl.length === 1) {
            this.tempActObj = extend({}, parent.objColl[0], {}, true);
        }
        else {
            for (var i = 0, iLen = parent.objColl.length; i < iLen; i++) {
                if (parent.objColl[i] && isNullOrUndefined(objColl[i])) {
                    this.tempActObj = extend({}, parent.objColl[i], {}, true);
                    break;
                }
                if (objColl[i].currIndex !== parent.objColl[i].currIndex) {
                    this.tempActObj = extend({}, parent.objColl[i], {}, true);
                    break;
                }
            }
        }
        if (allowActiveObj) {
            parent.activeObj = extend({}, this.tempActObj, {}, true);
        }
        parent.objColl = extend([], objColl, [], true);
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: true } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
    };
    UndoRedo.prototype.updateTextBox = function (obj) {
        var parent = this.parent;
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        var textArea = parent.textArea;
        textArea.style.display = 'block';
        textArea.style.fontFamily = obj.textSettings.fontFamily;
        textArea.style.fontSize = obj.textSettings.fontSize + 'px';
        textArea.style.color = obj.strokeSettings.strokeColor;
        textArea.style.fontWeight = obj.textSettings.bold ? 'bold' : 'normal';
        textArea.style.fontStyle = obj.textSettings.italic ? 'italic' : 'normal';
        textArea.style.border = '2px solid ' + parent.themeColl[parent.theme]['primaryColor'];
        textArea.value = obj.keyHistory;
        parent.activeObj = extend({}, obj, {}, true);
        parent.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,
            value: { isTextBox: null } });
        parent.textArea.style.width = parent.activeObj.activePoint.width + 'px';
    };
    UndoRedo.prototype.undoDefault = function (obj, isUndoRedo) {
        this.lowerContext.filter = obj.previousObj.filter;
        var parent = this.parent;
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: [] } } });
        var isCircleCrop = !isUndoRedo ? obj.isCircleCrop : false;
        parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: obj.previousObj, isUndoRedo: isUndoRedo, isCircleCrop: isCircleCrop } });
        parent.prevStraightenedDegree = parent.transform.straighten;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.img.destLeft = obj.previousObj.destPoints.startX;
        parent.img.destTop = obj.previousObj.destPoints.startY;
        var activeObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = extend([], obj.previousObjColl, [], true);
        parent.pointColl = extend([], obj.previousPointColl, [], true);
        parent.freehandCounter = parent.pointColl.length;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: extend([], obj.previousSelPointColl, [], true) } } });
        parent.transform.straighten = 0;
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        this.lowerContext.filter = obj.previousObj.filter;
        parent.activeObj = activeObj;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        }
    };
    UndoRedo.prototype.endUndoRedo = function (operation, isUndo) {
        var parent = this.parent;
        var frameObj = { type: 'none', color: '#fff', size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: 'solid', gradientColor: '' };
        if (((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) &&
            JSON.stringify(parent.frameObj) !== JSON.stringify(frameObj)) {
            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: true } });
        }
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.isCircleCrop && ((isUndo && operation !== 'crop') || !isUndo)) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        if (parent.transform.zoomFactor > 0) {
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
        }
        parent.notify('draw', { prop: 'setCancelAction', onPropertyChange: false, value: { bool: false } });
        if (parent.activeObj.shape && parent.activeObj.shape.split('-')[0] === 'crop') {
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                    isApplyBtn: true, isCropping: true, isZooming: null, cType: null } });
        }
        else {
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        }
        parent.notify('toolbar', { prop: 'enable-disable-btns' });
        if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {
            document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';
        }
        parent.notify('toolbar', { prop: 'enable-disable-btns' });
        if (parent.transform.degree !== 0) {
            parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,
                value: { xDiff: 0, yDiff: 0 } });
        }
        parent.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
        parent.currObjType.isCustomCrop = false;
    };
    UndoRedo.prototype.updateUrc = function (operation, previousObj, previousObjColl, previousPointColl, previousSelPointColl, previousCropObj, previousText, currentText, previousFilter, isCircleCrop) {
        var parent = this.parent;
        if (parent.isResize || this.isPreventing) {
            return;
        }
        var obj = { isInitialLoaded: false };
        if (parent.currObjType.isUndoAction) {
            this.refreshUrc(true);
        }
        parent.notify('draw', { prop: 'isInitialLoaded', onPropertyChange: false, value: { object: obj } });
        if (!obj['isInitialLoaded'] && parent.allowUndoRedo) {
            var object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var currentObj = object['currObj'];
            currentObj.objColl = extend([], parent.objColl, [], true);
            currentObj.pointColl = extend([], parent.pointColl, [], true);
            currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            currentObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            if (operation === 'crop') {
                currentObj.currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
            }
            else if (operation === 'frame') {
                previousObj.destPoints = { startX: parent.frameDestPoints.destLeft, startY: parent.frameDestPoints.destTop,
                    width: parent.frameDestPoints.destWidth, height: parent.frameDestPoints.destHeight };
                currentObj.destPoints = { startX: parent.frameDestPoints.destLeft, startY: parent.frameDestPoints.destTop,
                    width: parent.frameDestPoints.destWidth, height: parent.frameDestPoints.destHeight };
                if (!isNullOrUndefined(parent.tempFrameZoomLevel)) {
                    previousObj.defaultZoom = currentObj.defaultZoom = parent.tempFrameZoomLevel;
                }
            }
            else if ((operation === 'imageHFlip' || operation === 'imageVFlip') && this.appliedUndoRedoColl.length > 0) {
                var index = previousObjColl[previousObjColl.length - 1].currIndex;
                previousObjColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentObjColl;
                if (index) {
                    for (var i = 0, len = previousObjColl.length; i < len; i++) {
                        if (previousObjColl[i].currIndex === index) {
                            var actObj = extend({}, previousObjColl[i], {}, true);
                            previousObjColl.splice(i, 1);
                            previousObjColl.push(actObj);
                            break;
                        }
                    }
                }
            }
            this.undoRedoColl.push({ operation: operation, previousObj: previousObj, currentObj: currentObj,
                previousObjColl: previousObjColl, currentObjColl: currentObj.objColl,
                previousPointColl: previousPointColl, currentPointColl: currentObj.pointColl,
                previousSelPointColl: previousSelPointColl, currentSelPointColl: currentObj.selPointColl,
                previousCropObj: previousCropObj, currentCropObj: extend({}, parent.cropObj, {}, true),
                previousText: previousText, currentText: currentText, filter: previousFilter, isCircleCrop: isCircleCrop });
            parent.notify('toolbar', { prop: 'enable-disable-btns', onPropertyChange: false });
        }
    };
    UndoRedo.prototype.updateUrObj = function (objColl, operation) {
        var parent = this.parent;
        if (parent.allowUndoRedo) {
            if (parent.currObjType.isUndoAction && !parent.isShapeDrawing) {
                this.refreshUrc(true);
            }
            if (isNullOrUndefined(parent.activeObj.imageRatio)) {
                parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
            }
            parent.objColl.push(parent.activeObj);
            var cropObj = extend({}, parent.cropObj, {}, true);
            var object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var obj = object['currObj'];
            obj.objColl = extend([], parent.objColl, [], true);
            obj.pointColl = extend([], parent.pointColl, [], true);
            obj.afterCropActions = extend([], parent.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            obj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            var oper = operation ? operation : 'shapeTransform';
            this.undoRedoColl.push({ operation: oper, previousObj: obj, currentObj: obj,
                previousObjColl: objColl, currentObjColl: obj.objColl,
                previousPointColl: obj.pointColl, currentPointColl: obj.pointColl,
                previousSelPointColl: obj.selPointColl, currentSelPointColl: obj.selPointColl,
                previousCropObj: cropObj, currentCropObj: cropObj });
            parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
                value: { obj: parent.objColl[parent.objColl.length - 1] } });
        }
    };
    UndoRedo.prototype.updateUndoRedo = function (operation) {
        var parent = this.parent;
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (isNullOrUndefined(parent.activeObj.imageRatio)) {
            parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
        }
        parent.objColl.push(parent.activeObj);
        var oper = operation ? operation : 'shapeTransform';
        this.updateUrc(oper, prevObj, prevObj.objColl, prevObj.pointColl, prevObj.selPointColl, prevCropObj);
        parent.objColl.pop();
        parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
    };
    UndoRedo.prototype.getZeroZoomObjPointValue = function (obj, point) {
        var parent = this.parent;
        this.updateObjColl();
        var object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var currentObj = object['currObj'];
        currentObj.objColl = extend([], parent.objColl, [], true);
        currentObj.pointColl = extend([], parent.pointColl, [], true);
        currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        currentObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        var cropDimensionObj = { cropDimension: null };
        parent.notify('transform', { prop: 'getCropDimension', onPropertyChange: false, value: { obj: cropDimensionObj } });
        var getZeroZoomObjColl = extend([], parent.objColl, [], true);
        var getZeroZoomPointColl = extend([], parent.pointColl, [], true);
        var arrowObj = { arrowDimension: null };
        this.parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: arrowObj } });
        var tempArrowObj = extend({}, arrowObj['arrowDimension'], {}, true);
        if (parent.transform.zoomFactor > 0 && (obj.length > 0 || point.length > 0)) {
            if (obj.length > 0) {
                for (var i = 0; i < obj.length; i++) {
                    if (obj[i].currIndex) {
                        continue;
                    }
                    else {
                        obj[i].currIndex = 'shape_' + (i + 1);
                    }
                }
            }
            parent.objColl = obj;
            parent.pointColl = point;
            var isUndoRedo = parent.isUndoRedo;
            var isCropTab = parent.isCropTab;
            if (parent.transform.zoomFactor !== 0) {
                parent.isUndoRedo = true;
                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                    value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: true } });
                parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
                parent.isCropTab = true;
                var zoomSettings = extend({}, parent.zoomSettings, null, true);
                if (parent.transform.zoomFactor > 0) {
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: -parent.transform.zoomFactor, zoomPoint: null, isResize: null } });
                }
                else {
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: Math.abs(parent.transform.zoomFactor), zoomPoint: null, isResize: null } });
                }
                parent.zoomSettings = zoomSettings;
                parent.isCropTab = isCropTab;
                parent.isUndoRedo = isUndoRedo;
                getZeroZoomObjColl = extend([], parent.objColl, [], true);
                getZeroZoomPointColl = extend([], parent.pointColl, [], true);
                parent.objColl = [];
                parent.pointColl = [];
                parent.freehandCounter = 0;
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: [] } } });
                parent.notify('transform', { prop: 'setCropDimension', onPropertyChange: false,
                    value: { width: cropDimensionObj['cropDimension']['width'], height: cropDimensionObj['cropDimension']['height'] } });
                var maxDimension = { width: cropDimensionObj['cropDimension']['width'], height: cropDimensionObj['cropDimension']['height'] };
                maxDimension.width += (maxDimension.width * currentObj.defaultZoom);
                maxDimension.height += (maxDimension.height * currentObj.defaultZoom);
                parent.notify('draw', { prop: 'setZoomCropWidth', value: { width: maxDimension.width, height: maxDimension.height } });
                parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: currentObj } });
                parent.img.destLeft = currentObj.destPoints.startX;
                parent.img.destTop = currentObj.destPoints.startY;
                parent.panPoint.totalPannedPoint = currentObj.totalPannedPoint;
                parent.panPoint.totalPannedClientPoint = currentObj.totalPannedClientPoint;
                parent.panPoint.totalPannedInternalPoint = currentObj.totalPannedInternalPoint;
                parent.objColl = extend([], currentObj.objColl, [], true);
                parent.pointColl = extend([], currentObj.pointColl, [], true);
                parent.freehandCounter = parent.pointColl.length;
                parent.notify('draw', { prop: 'setArrowDimension', onPropertyChange: false, value: { arrowDimension: tempArrowObj } });
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: extend([], currentObj.selPointColl, [], true) } } });
                this.lowerContext.filter = 'none';
                parent.transform.straighten = 0;
                this.applyImgTranform();
                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                    value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
                parent.notify('freehand-draw', { prop: 'updateFHDCurPts', onPropertyChange: false });
                this.lowerContext.filter = currentObj.filter;
                if (parent.transform.degree !== 0) {
                    parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,
                        value: { xDiff: 0, yDiff: 0 } });
                }
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
            }
        }
        return { obj: getZeroZoomObjColl, point: getZeroZoomPointColl };
    };
    UndoRedo.prototype.updateObjColl = function () {
        var parent = this.parent;
        for (var i = 0; i < parent.objColl.length; i++) {
            var obj = parent.objColl[i];
            var isUpdated = false;
            if (obj.shape === 'line' || obj.shape === 'arrow') {
                if (obj.activePoint.width < 0) {
                    obj.activePoint.width = Math.abs(obj.activePoint.width);
                    isUpdated = true;
                }
                if (obj.activePoint.height < 0) {
                    obj.activePoint.height = Math.abs(obj.activePoint.height);
                    isUpdated = true;
                }
                if (isUpdated) {
                    var activeObj = extend({}, parent.activeObj, {}, true);
                    parent.activeObj = obj;
                    parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                    obj = parent.activeObj;
                    parent.activeObj = activeObj;
                }
            }
        }
    };
    UndoRedo.prototype.applyImgTranform = function () {
        var parent = this.parent;
        var obj = extend({}, parent.activeObj, {}, true);
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].shape === 'image') {
                parent.activeObj = extend({}, parent.objColl[i], {}, true);
                var ctx = parent.objColl[i].imageCanvas.getContext('2d');
                parent.notify('selection', { prop: 'applyTransformToImg', onPropertyChange: false, value: { ctx: ctx } });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('selection', { prop: 'setImageClarity', onPropertyChange: false, value: { bool: true } });
            }
        }
        parent.activeObj = obj;
    };
    UndoRedo.prototype.updateUndoRedoStack = function (isPenDraw) {
        var parent = this.parent;
        if ((parent.activeObj.currIndex && parent.activeObj.activePoint.width !== 0 ||
            parent.activeObj.activePoint.height !== 0 || (parent.activeObj.pointColl &&
            parent.activeObj.pointColl.length > 0)) || isPenDraw) {
            var isTextArea = parent.textArea.style.display === 'none' ? false : true;
            var temp = parent.noPushUndo;
            parent.noPushUndo = false;
            parent.isUndoRedoStack = true;
            if (isPenDraw) {
                var tempTogglePen = parent.togglePen;
                var obj = { freehandDrawSelectedId: null };
                parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });
                parent.okBtn();
                parent.noPushUndo = temp;
                if (obj['freehandDrawSelectedId']) {
                    parent.noRedact = true;
                    parent.selectShape(obj['freehandDrawSelectedId']);
                }
                else {
                    parent.freeHandDraw(true);
                }
                parent.togglePen = tempTogglePen;
            }
            else if (parent.activeObj.currIndex) {
                var shapeId = parent.activeObj.currIndex;
                parent.okBtn();
                parent.noPushUndo = temp;
                parent.noRedact = true;
                parent.selectShape(shapeId);
                if (parent.drawingShape) {
                    parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: parent.drawingShape.toLowerCase() } });
                }
                if (isTextArea) {
                    parent.enableTextEditing();
                }
            }
            parent.isUndoRedoStack = false;
        }
    };
    return UndoRedo;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Defines the settings for restricting uploaded images.
 */
var UploadSettings = /** @class */ (function (_super) {
    __extends(UploadSettings, _super);
    function UploadSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property(null)
    ], UploadSettings.prototype, "allowedExtensions", void 0);
    __decorate([
        Property(null)
    ], UploadSettings.prototype, "minFileSize", void 0);
    __decorate([
        Property(null)
    ], UploadSettings.prototype, "maxFileSize", void 0);
    return UploadSettings;
}(ChildProperty));
/**
 * This interface is used to specify settings for finetuning operations on images, including brightness, contrast, hue, saturation, exposure, opacity, and blur. It includes properties for setting minimum and maximum values for each of these options, as well as a default value.
 */
var FinetuneSettings = /** @class */ (function (_super) {
    __extends(FinetuneSettings, _super);
    function FinetuneSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property(null)
    ], FinetuneSettings.prototype, "brightness", void 0);
    __decorate([
        Property(null)
    ], FinetuneSettings.prototype, "contrast", void 0);
    __decorate([
        Property(null)
    ], FinetuneSettings.prototype, "hue", void 0);
    __decorate([
        Property(null)
    ], FinetuneSettings.prototype, "saturation", void 0);
    __decorate([
        Property(null)
    ], FinetuneSettings.prototype, "exposure", void 0);
    __decorate([
        Property(null)
    ], FinetuneSettings.prototype, "opacity", void 0);
    __decorate([
        Property(null)
    ], FinetuneSettings.prototype, "blur", void 0);
    return FinetuneSettings;
}(ChildProperty));
/**
 * An interface used to define the settings such as minimum, maximum, and default zoom factors, and the type of zooming which are available in the image editor control.
 */
var ZoomSettings = /** @class */ (function (_super) {
    __extends(ZoomSettings, _super);
    function ZoomSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property(null)
    ], ZoomSettings.prototype, "zoomTrigger", void 0);
    __decorate([
        Property(1)
    ], ZoomSettings.prototype, "minZoomFactor", void 0);
    __decorate([
        Property(10)
    ], ZoomSettings.prototype, "maxZoomFactor", void 0);
    __decorate([
        Property(1)
    ], ZoomSettings.prototype, "zoomFactor", void 0);
    __decorate([
        Property(null)
    ], ZoomSettings.prototype, "zoomPoint", void 0);
    return ZoomSettings;
}(ChildProperty));
/**
 * This interface is used to specify settings for selection operations on images, including visibility, stroke color and fill color.
 */
var SelectionSettings = /** @class */ (function (_super) {
    __extends(SelectionSettings, _super);
    function SelectionSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property(true)
    ], SelectionSettings.prototype, "showCircle", void 0);
    __decorate([
        Property(null)
    ], SelectionSettings.prototype, "strokeColor", void 0);
    __decorate([
        Property(null)
    ], SelectionSettings.prototype, "fillColor", void 0);
    return SelectionSettings;
}(ChildProperty));
/**
 * Predefine the font families that populate in font family dropdown list from the toolbar.
 */
var FontFamily = /** @class */ (function (_super) {
    __extends(FontFamily, _super);
    function FontFamily() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        Property('Arial')
    ], FontFamily.prototype, "default", void 0);
    __decorate([
        Property(null)
    ], FontFamily.prototype, "items", void 0);
    return FontFamily;
}(ChildProperty));
/**
 * The Image Editor is a graphical user interface for editing images.
 *
 * {% codeBlock src='image-editor/default/index.md' %}{% endcodeBlock %}
 *
 * @remarks
 * The Image Editor component provides various image editing features such as zooming, cropping, rotating, inserting text and shapes (rectangles, ellipses, and lines), drawing freehand on top of an image, undo/redo, and more.
 *
 */
var ImageEditor = /** @class */ (function (_super) {
    __extends(ImageEditor, _super);
    /**
     *
     * Constructor for creating the widget
     *
     * @param  {ImageEditorModel} options - Specifies the image editor model
     * @param  {string|HTMLDivElement} element - Specifies the target element
     */
    function ImageEditor(options, element) {
        var _this = _super.call(this, options) || this;
        /**
         *
         * Image Editor Private Properties
         */
        /** @hidden */
        _this.isImageLoaded = false;
        /** @hidden */
        _this.activeObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [], triangle: [], triangleRatio: [], rotatedAngle: 0, opacity: 1, order: null };
        // current object's ui interaction properties
        /** @hidden */
        _this.currObjType = { shape: '', isDragging: false, isActiveObj: false, isText: false, isInitialText: false, isLine: false, isInitialLine: false,
            isCustomCrop: false, isZoomed: false, isUndoZoom: false, isUndoAction: false, isFiltered: false, isSave: false, isResize: false, isRedact: false };
        /** @hidden */
        _this.objColl = [];
        /** @hidden */
        // eslint-disable-next-line
        _this.pointColl = {};
        /** @hidden */
        _this.freehandCounter = 0;
        /** @hidden */
        _this.points = [];
        /** @hidden */
        _this.togglePen = false;
        /** @hidden */
        _this.togglePan = false;
        /** @hidden */
        _this.img = { destLeft: 0, destTop: 0, destWidth: 0, destHeight: 0, srcLeft: 0, srcTop: 0, srcWidth: 0, srcHeight: 0 };
        /** @hidden */
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        _this.rotateFlipColl = [];
        // All prop values saved while cropping (to restore the image to its original state)
        /** @hidden */
        _this.cropObj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
            totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {}, rotateFlipColl: [],
            degree: 0, currFlipState: '', straighten: 0, destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
            srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: false,
            zoomFactor: 0, previousZoomValue: 0, aspectWidth: null, aspectHeight: null, frame: 'none', straightenZoom: 0,
            adjustmentLevel: { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
                exposure: 0, transparency: 100, sharpen: false, bw: false }, currentFilter: '' };
        // Stored transformations performed after cropping
        /** @hidden */
        _this.afterCropActions = [];
        /** @hidden */
        _this.transform = { degree: 0, currFlipState: '', zoomFactor: 0, cropZoomFactor: null, defaultZoomFactor: 0, straighten: 0 };
        /** @hidden */
        _this.panPoint = { currentPannedPoint: { x: 0, y: 0 }, totalPannedPoint: { x: 0, y: 0 }, totalPannedInternalPoint: { x: 0, y: 0 },
            totalPannedClientPoint: { x: 0, y: 0 } };
        /** @hidden */
        _this.isUndoRedo = false;
        /** @hidden */
        _this.isCropTab = false;
        /** @hidden */
        _this.isCircleCrop = false;
        /** @hidden */
        _this.fontSizeColl = [];
        /** @hidden */
        _this.initialAdjustmentValue = '';
        /** @hidden */
        _this.currentFilter = '';
        /** @hidden */
        _this.canvasFilter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
            'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
        /** @hidden */
        _this.toolbarHeight = 0;
        /** @hidden */
        _this.isPublicMethod = false;
        /** @hidden */
        _this.isCropToolbar = false;
        /** @hidden */
        _this.cursor = 'default';
        /** @hidden */
        _this.resizeSrc = { startX: _this.img.srcLeft, startY: _this.img.srcTop, width: _this.img.srcWidth, height: _this.img.srcHeight };
        /** @hidden */
        _this.isResize = false;
        /** @hidden */
        _this.isAspectRatio = false;
        /** @hidden */
        _this.frameObj = { type: 'none', color: '#fff', size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: 'solid', gradientColor: '' };
        /** @hidden */
        _this.tempFrameObj = { type: 'none', color: '#fff', size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: 'solid', gradientColor: '' };
        /** @hidden */
        _this.allowDownScale = true;
        /** @hidden */
        _this.gradientColor = '';
        /** @hidden */
        _this.size = 20;
        /** @hidden */
        _this.inset = 0;
        /** @hidden */
        _this.offset = 0;
        /** @hidden */
        _this.borderRadius = 0;
        /** @hidden */
        _this.lineCount = 0;
        /** @hidden */
        _this.prevStraightenedDegree = 0;
        /** @hidden */
        _this.tempStraighten = 0;
        /** @hidden */
        _this.isStraightening = false;
        /** @hidden */
        _this.isFinetuning = false;
        /** @hidden */
        _this.isZoomBtnClick = false;
        /** @hidden */
        _this.isFinetuneBtnClick = false;
        /** @hidden */
        _this.isFilterCanvasClick = false;
        /** @hidden */
        _this.isFrameBtnClick = false;
        /** @hidden */
        _this.isChangesSaved = false;
        /** @hidden */
        _this.isShapeDrawing = false;
        /** @hidden */
        _this.noPushUndo = false;
        /** @hidden */
        _this.isUndoRedoStack = false;
        /** @hidden */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _this.shapeColl = [];
        /** @hidden */
        _this.isKBDNavigation = false;
        /** @hidden */
        _this.isMaskImage = false;
        /** @hidden */
        _this.tempObjColl = [];
        /** @hidden */
        _this.tempPointColl = [];
        /** @hidden */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _this.tempShapeColl = [];
        /** @hidden */
        _this.isImageUpdated = false;
        /** @hidden */
        _this.noRedact = false;
        /** @hidden */
        _this.tempRedactBlur = 50;
        /** @hidden */
        _this.tempRedactPixel = 40;
        _this.tempToolbarHeight = 0;
        _this.tempToolbar = [];
        ImageEditor_1.Inject(Crop, Draw, Selection, Transform, Export, ToolbarModule);
        ImageEditor_1.Inject(UndoRedo);
        ImageEditor_1.Inject(Filter);
        ImageEditor_1.Inject(Shape);
        ImageEditor_1.Inject(FreehandDrawing);
        if (element) {
            _this.appendTo(element);
        }
        return _this;
    }
    ImageEditor_1 = ImageEditor;
    /**
     * To provide the array of modules needed for component rendering.
     *
     * @returns {ModuleDeclaration[]} - To provide the array of modules needed for component rendering.
     * @hidden
     */
    ImageEditor.prototype.requiredModules = function () {
        var modules = [];
        modules.push({ member: 'crop', args: [this] });
        modules.push({ member: 'draw', args: [this] });
        modules.push({ member: 'selection', args: [this] });
        modules.push({ member: 'transform', args: [this] });
        modules.push({ member: 'export', args: [this] });
        modules.push({ member: 'toolbar-module', args: [this] });
        modules.push({ member: 'undo-redo', args: [this] });
        modules.push({ member: 'filter', args: [this] });
        modules.push({ member: 'shape', args: [this] });
        modules.push({ member: 'freehand-draw', args: [this] });
        return modules;
    };
    ImageEditor.prototype.preRender = function () {
        // pre render code snippets
        this.element.id = this.element.id || getUniqueID('ej2-image-editor');
        this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (Browser.isDevice) {
            this.element.classList.add('e-device');
        }
        this.initializeThemeColl();
    };
    /**
     *
     * To Initialize the component rendering
     *
     * @private
     * @returns {void}
     */
    ImageEditor.prototype.render = function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (this.isAngular) {
            var originalElement = this.element;
            var clonedElement = originalElement.cloneNode(true);
            originalElement.parentNode.replaceChild(clonedElement, originalElement);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.element = clonedElement;
            setValue('ej2_instances', [this], this.element);
        }
        this.initialize();
    };
    /**
     * To get component name.
     *
     * @returns {string} - Module Name
     * @private
     */
    ImageEditor.prototype.getModuleName = function () {
        return 'image-editor';
    };
    /**
     *
     * To get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Persist data
     * @private
     */
    ImageEditor.prototype.getPersistData = function () {
        return this.addOnPersist([]);
    };
    /**
     *
     * Called internally if any of the property value changed.
     *
     * @param {ImageEditorModel} newProperties - Specifies new properties
     * @param {ImageEditorModel} oldProperties - Specifies old properties
     * @returns {void}
     * @private
     */
    ImageEditor.prototype.onPropertyChanged = function (newProperties, oldProperties) {
        var indexObj;
        for (var _i = 0, _a = Object.keys(newProperties); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'cssClass':
                    if (oldProperties.cssClass) {
                        removeClass([this.element], oldProperties.cssClass.replace(/\s+/g, ' ').trim().split(' '));
                    }
                    if (newProperties.cssClass) {
                        addClass([this.element], newProperties.cssClass.replace(/\s+/g, ' ').trim().split(' '));
                    }
                    break;
                case 'disabled':
                    if (newProperties.disabled) {
                        this.element.classList.add('e-disabled');
                        this.unwireEvent();
                    }
                    else {
                        this.element.classList.remove('e-disabled');
                        this.wireEvent();
                    }
                    break;
                case 'height':
                    this.element.style.height = newProperties.height;
                    this.update();
                    break;
                case 'width':
                    this.element.style.width = newProperties.width;
                    this.update();
                    break;
                case 'theme':
                    if (newProperties.theme) {
                        if (this.theme && this.theme !== '') {
                            this.theme = this.toPascalCase(this.theme);
                        }
                        else {
                            this.theme = 'Bootstrap5';
                        }
                        this.upperContext.strokeStyle = this.themeColl[this.theme]['primaryColor'];
                        this.upperContext.fillStyle = this.themeColl[this.theme]['secondaryColor'];
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    break;
                case 'finetuneSettings':
                    if (newProperties.finetuneSettings) {
                        this.finetuneSettings = newProperties.finetuneSettings;
                        this.notify('filter', { prop: 'update-finetunes' });
                    }
                    break;
                case 'locale':
                    if (newProperties.locale) {
                        this.notify('toolbar', { prop: 'setLocale', onPropertyChange: false, value: { locale: newProperties.locale } });
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    break;
                case 'allowUndoRedo':
                    if (newProperties.allowUndoRedo) {
                        this.allowUndoRedo = true;
                    }
                    else {
                        this.allowUndoRedo = false;
                    }
                    this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    break;
                case 'showQuickAccessToolbar':
                    if (newProperties.showQuickAccessToolbar) {
                        this.showQuickAccessToolbar = true;
                        this.notify('toolbar', { prop: 'create-qa-toolbar', onPropertyChange: false });
                        indexObj = { freehandSelectedIndex: null };
                        this.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                        if (this.activeObj.shape) {
                            this.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                        }
                        else if (indexObj['freehandSelectedIndex']) {
                            this.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });
                        }
                    }
                    else {
                        this.showQuickAccessToolbar = false;
                        this.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                    }
                    break;
                case 'zoomSettings':
                    if (newProperties.zoomSettings) {
                        this.zoomSettings.zoomTrigger = newProperties.zoomSettings.zoomTrigger;
                    }
                    if (isNullOrUndefined(this.zoomSettings.zoomTrigger)) {
                        this.zoomSettings.zoomTrigger = (ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar |
                            ZoomTrigger.Commands);
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if ((newProperties.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    break;
                case 'selectionSettings':
                    if (newProperties.selectionSettings) {
                        this.selectionSettings = newProperties.selectionSettings;
                        if (this.activeObj.shape) {
                            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                            this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: this.activeObj } });
                        }
                    }
                    break;
                case 'toolbar':
                    if (newProperties.toolbar) {
                        this.toolbar = newProperties.toolbar;
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    break;
                case 'toolbarTemplate':
                    if (newProperties.toolbarTemplate) {
                        this.notify('toolbar', { prop: 'destroy-bottom-toolbar', onPropertyChange: false });
                        this.notify('toolbar', { prop: 'destroy-top-toolbar', onPropertyChange: false });
                        this.element.appendChild(this.createElement('div', {
                            id: this.element.id + '_toolbarArea', className: 'e-toolbar-area'
                        }));
                        this.toolbarTemplateFn();
                    }
                    break;
                case 'quickAccessToolbarTemplate':
                    if (newProperties.quickAccessToolbarTemplate) {
                        this.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                        this.quickAccessToolbarTemplateFn();
                    }
                    break;
                case 'uploadSettings':
                    if (newProperties.uploadSettings) {
                        this.uploadSettings = newProperties.uploadSettings;
                        if (!this.uploadSettings.allowedExtensions) {
                            this.uploadSettings.allowedExtensions = '.jpg, .jpeg, .png, .svg, .webp';
                            this.notify('draw', { prop: 'setNullExtension', value: { extension: true } });
                        }
                        else {
                            this.notify('draw', { prop: 'setNullExtension', value: { extension: false } });
                        }
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else {
                        this.notify('draw', { prop: 'setNullExtension', value: { extension: true } });
                    }
                    this.updateDropInfoContent(this.element.querySelector('.e-ie-drop-info'));
                    break;
            }
        }
    };
    ImageEditor.prototype.destroy = function () {
        var classList = [];
        this.element.removeAttribute('tabindex');
        var saveDialog = this.element.querySelector('#' + this.element.id + '_saveDialog');
        if (saveDialog && saveDialog.style.display === 'block') {
            getComponent(document.getElementById(this.element.id + '_saveDialog'), 'dialog').destroy();
        }
        if (this.cssClass) {
            classList = classList.concat(this.cssClass.replace(/\s+/g, ' ').trim().split(' '));
        }
        removeClass([this.element], classList);
        if (!this.element.getAttribute('class')) {
            this.element.removeAttribute('class');
        }
        this.unwireEvent();
        this.notify('toolbar', { prop: 'destroySubComponents', onPropertyChange: false });
        this.notify('destroyed', null);
        _super.prototype.destroy.call(this);
        this.element.innerHTML = '';
    };
    ImageEditor.prototype.initialize = function () {
        if (this.toolbarTemplate) {
            this.element.appendChild(this.createElement('div', {
                id: this.element.id + '_toolbarArea', className: 'e-toolbar-area'
            }));
            this.toolbarTemplateFn();
        }
        else {
            this.notify('toolbar', { prop: 'create-toolbar', onPropertyChange: false });
            this.notify('toolbar', { prop: 'create-contextual-toolbar', onPropertyChange: false });
        }
        if (!this.uploadSettings.allowedExtensions) {
            this.setProperties({ uploadSettings: { allowedExtensions: '.jpg, .jpeg, .png, .svg, .webp' } }, true);
        }
        else {
            this.notify('draw', { prop: 'setNullExtension', value: { extension: false } });
        }
        this.createCanvas();
        if (this.element.offsetWidth > 359 && this.element.querySelector('.e-ie-min-drop-content') && this.element.querySelector('.e-ie-drop-content')) {
            this.element.querySelector('.e-ie-min-drop-content').style.display = 'none';
            this.element.querySelector('.e-ie-drop-content').style.display = 'block';
        }
        this.createDropUploader();
        if (this.showQuickAccessToolbar) {
            var canvasWrapper = document.querySelector('#' + this.element.id + '_canvasWrapper');
            canvasWrapper.appendChild(this.createElement('div', {
                id: this.element.id + '_quickAccessToolbarArea', className: 'e-quick-access-toolbar-area'
            }));
            var quickAccessToolbar = document.getElementById(this.element.id + '_quickAccessToolbarArea');
            quickAccessToolbar.style.position = 'absolute';
            quickAccessToolbar.style.display = 'none';
            if (this.activeObj) {
                quickAccessToolbar.style.left = this.activeObj.activePoint.startX + 'px';
                quickAccessToolbar.style.top = this.activeObj.activePoint.startY + 'px';
            }
            quickAccessToolbar.style.width = '100%';
        }
        if (this.quickAccessToolbarTemplate) {
            this.quickAccessToolbarTemplateFn();
        }
        else {
            this.notify('toolbar', { prop: 'create-qa-toolbar', onPropertyChange: false });
        }
        this.wireEvent();
        this.lowerContext = this.lowerCanvas.getContext('2d');
        this.upperContext = this.upperCanvas.getContext('2d');
        this.inMemoryContext = this.inMemoryCanvas.getContext('2d');
        this.lowerContext.filter = this.getDefaultFilter();
        this.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
        this.canvasFilter = this.lowerContext.filter;
        this.notify('toolbar', { prop: 'setInitialAdjustmentValue', onPropertyChange: false, value: { value: this.lowerContext.filter } });
        if (this.cssClass) {
            addClass([this.element], this.cssClass.replace(/\s+/g, ' ').trim().split(' '));
        }
        if (this.element) {
            createSpinner({
                target: this.element
            });
        }
        this.initializeZoomSettings();
        if (this.imgSrc) {
            this.open(this.imgSrc);
        }
    };
    ImageEditor.prototype.createDropUploader = function () {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var proxy = this;
        var uploadObj = new Uploader({
            dropArea: this.element.getElementsByClassName('e-canvas-wrapper')[0],
            allowedExtensions: this.uploadSettings.allowedExtensions,
            multiple: false,
            selected: function (args) {
                if (args.event.type === 'change' || args.event.type === 'drop') {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    var type = args.filesData[0].type;
                    var errType = 'unsupported';
                    var extension = _this.getExtensionArray();
                    var isAllowedFileType = (extension.indexOf(type) > -1 ||
                        (type === 'jpeg' && (proxy.uploadSettings.allowedExtensions.indexOf('jpg') > -1 ||
                            proxy.uploadSettings.allowedExtensions.indexOf('jpeg') > -1)));
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    var size = args.filesData[0].size;
                    var isInvalidSize = (proxy.uploadSettings.minFileSize && size < proxy.uploadSettings.minFileSize) ||
                        (proxy.uploadSettings.maxFileSize && size > proxy.uploadSettings.maxFileSize);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    if ((args.event.type === 'change' || (args.event.type === 'drop' && args.event.dataTransfer.files.length === 1)) && isAllowedFileType &&
                        !isInvalidSize) {
                        _this.notify('draw', { prop: 'fileSelect', value: { inputElement: _this.element.querySelector('#' + _this.element.id + '_dropfileUpload'), args: args } });
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        if (args.event.type === 'drop' && args.event.dataTransfer.files.length > 1) {
                            errType = 'multi-select-image';
                        }
                        _this.showDialogPopup(errType, !isAllowedFileType);
                    }
                }
            }
        });
        uploadObj.appendTo('#' + this.element.id + '_dropfileUpload');
    };
    ImageEditor.prototype.dlgCloseBtnClick = function () {
        getComponent(document.getElementById(this.element.id + '_dialog'), 'dialog').destroy();
    };
    /**
     * Show dialog popup for unsupported files.
     *
     * @param { string } type - Specifies the type of error.
     * @param { boolean } fileTypeError - Specifies the error is due to file type.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.showDialogPopup = function (type, fileTypeError) {
        var content = '';
        this.element.querySelector('#' + this.element.id + '_dialog').style.display = 'block';
        var headerObj;
        var okObj = { key: 'DlgOK' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: okObj } });
        if (type === 'multi-select-image') {
            headerObj = { key: 'ImageErrorDialogHeader' };
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: headerObj } });
            var contentObj = { key: 'ImageErrorDialogContent' };
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: contentObj } });
            content = '<span>' + contentObj['value'] + '</span>';
        }
        else {
            headerObj = { key: 'AlertDialogHeader' };
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: headerObj } });
            var contentObj = { key: 'AlertDialogContent' };
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: contentObj } });
            var supportObj = { key: 'SupportText' };
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: supportObj } });
            var extension = this.getExtensionString();
            var fileSizeObj = { key: 'MinMaxSizeAlert' };
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: fileSizeObj } });
            var andObj = { key: 'And' };
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: andObj } });
            var size = void 0;
            if (this.uploadSettings.minFileSize && this.uploadSettings.maxFileSize) {
                size = ' ' + fileSizeObj['value'] + ' <b> ' + this.formatSizeUnits(this.uploadSettings.minFileSize) + ' </b> ' + andObj['value'] + ' <b> ' + this.formatSizeUnits(this.uploadSettings.maxFileSize) + ' </b> ';
            }
            else if (this.uploadSettings.minFileSize) {
                fileSizeObj['key'] = 'MinSizeAlert';
                this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: fileSizeObj } });
                size = ' ' + fileSizeObj['value'] + ' <b> ' + this.formatSizeUnits(this.uploadSettings.minFileSize) + ' </b> ';
            }
            else if (this.uploadSettings.maxFileSize) {
                fileSizeObj['key'] = 'MaxSizeAlert';
                this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: fileSizeObj } });
                size = ' ' + fileSizeObj['value'] + ' <b> ' + this.formatSizeUnits(this.uploadSettings.maxFileSize) + ' </b> ';
            }
            if (fileTypeError) {
                content = '<span>' + contentObj['value'] + ' ' + supportObj['value'] + '<b>' + extension + '</b>' + '</span>';
            }
            else if (size) {
                content = '<span>' + contentObj['value'] + ' ' + supportObj['value'] + size + '</span>';
            }
        }
        var dialog = new Dialog({
            header: headerObj['value'],
            closeOnEscape: true,
            content: content,
            target: document.getElementById('target'),
            width: Browser.isDevice ? '285px' : '400px',
            isModal: true,
            animationSettings: { effect: 'Zoom' },
            close: this.dlgCloseBtnClick.bind(this),
            buttons: [
                { click: this.dlgCloseBtnClick.bind(this),
                    buttonModel: { content: okObj['value'] }
                }
            ]
        });
        dialog.appendTo('#' + this.element.id + '_dialog');
    };
    /**
     * Returns bytes in string format.
     *
     * @param { number } bytes - Specifies the bytes.
     *
     * @hidden
     * @returns {string}.
     */
    ImageEditor.prototype.formatSizeUnits = function (bytes) {
        var byte = '';
        if (bytes >= 1073741824) {
            byte = (bytes / 1073741824).toFixed(2) + ' GB';
        }
        else if (bytes >= 1048576) {
            byte = (bytes / 1048576).toFixed(2) + ' MB';
        }
        else if (bytes >= 1024) {
            byte = (bytes / 1024).toFixed(2) + ' KB';
        }
        else if (bytes > 1) {
            byte = bytes + ' bytes';
        }
        else if (bytes === 1) {
            byte = bytes + ' byte';
        }
        else {
            byte = '0 bytes';
        }
        return byte;
    };
    /**
     * Returns allowed file type extensions in string[].
     *
     * @hidden
     * @returns {string[]}.
     */
    ImageEditor.prototype.getExtensionArray = function () {
        var validExtensions = ['jpeg', 'jpg', 'png', 'svg', 'webp'];
        var split = this.uploadSettings.allowedExtensions.split(',');
        var extension = [];
        for (var _i = 0, split_1 = split; _i < split_1.length; _i++) {
            var ext = split_1[_i];
            var trimmedExt = ext.trim();
            for (var _a = 0, validExtensions_1 = validExtensions; _a < validExtensions_1.length; _a++) {
                var valid = validExtensions_1[_a];
                if (trimmedExt.indexOf(valid) !== -1) {
                    extension.push(valid);
                    break;
                }
            }
        }
        return extension;
    };
    /**
     * Returns allowed file type extensions in string.
     *
     * @hidden
     * @returns {string}.
     */
    ImageEditor.prototype.getExtensionString = function () {
        var andObj = { key: 'And' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: andObj } });
        var extension = this.getExtensionArray();
        var words = '';
        for (var i = 0; i < extension.length; i++) {
            if (i === extension.length - 1 && extension.length > 1 &&
                !((extension[i] === 'jpeg' || extension[i] === 'jpg') &&
                    (words.indexOf('JPG') > -1))) {
                if (extension.length === 2 || (extension.length === 3 && extension.indexOf('jpeg') !== -1 && extension.indexOf('jpg') !== -1)) {
                    words = words.replace(/,\s*$/, '');
                }
                words += ' ' + andObj['value'];
            }
            switch (extension[i]) {
                case 'jpeg':
                case 'jpg':
                    if (words.indexOf('JPG') === -1) {
                        words += ' JPG,';
                    }
                    break;
                case 'png':
                    words += ' PNG,';
                    break;
                case 'svg':
                    words += ' SVG,';
                    break;
                case 'webp':
                    words += ' WebP,';
                    break;
            }
            if (i === extension.length - 1) {
                words = words.slice(0, -1);
            }
        }
        return words;
    };
    /**
     *
     * This Method will add events to component (element, event, method, current reference)
     *
     * @returns {void}.
     */
    ImageEditor.prototype.wireEvent = function () {
        EventHandler.add(document, 'keydown', this.keyDownEventHandler, this);
        EventHandler.add(document, 'keypress', this.keyUpEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mousedown', this.mouseDownEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mousemove', this.mouseMoveEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mouseup', this.mouseUpEventHandler, this);
        EventHandler.add(document, 'mouseup', this.mouseUpEventHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousedown', this.canvasMouseDownHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousemove', this.canvasMouseMoveHandler, this);
        EventHandler.add(this.lowerCanvas, 'mouseup', this.canvasMouseUpHandler, this);
        EventHandler.add(this.upperCanvas, 'touchstart', this.touchStartHandler, this);
        EventHandler.add(this.lowerCanvas, 'touchstart', this.touchStartHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousewheel DOMMouseScroll', this.handleScroll, this);
        EventHandler.add(this.upperCanvas, 'mousewheel DOMMouseScroll', this.handleScroll, this);
        window.addEventListener('resize', this.windowResizeHandler.bind(this));
        if ((!Browser.isIos && Browser.info.name !== 'safari')) {
            screen.orientation.addEventListener('change', this.screenOrientation.bind(this));
        }
        this.notify('shape', { prop: 'wireEvent', onPropertyChange: false });
    };
    /**
     *
     * This Method will remove events from component
     *
     * @returns {void}.
     */
    ImageEditor.prototype.unwireEvent = function () {
        EventHandler.remove(document, 'keydown', this.keyDownEventHandler);
        EventHandler.remove(document, 'keypress', this.keyUpEventHandler);
        EventHandler.remove(this.upperCanvas, 'mousedown', this.mouseDownEventHandler);
        EventHandler.remove(this.upperCanvas, 'mousemove', this.mouseMoveEventHandler);
        EventHandler.remove(this.upperCanvas, 'mouseup', this.mouseUpEventHandler);
        EventHandler.remove(document, 'mouseup', this.mouseUpEventHandler);
        EventHandler.remove(this.lowerCanvas, 'mousedown', this.canvasMouseDownHandler);
        EventHandler.remove(this.lowerCanvas, 'mousemove', this.canvasMouseMoveHandler);
        EventHandler.remove(this.lowerCanvas, 'mouseup', this.canvasMouseUpHandler);
        EventHandler.remove(this.upperCanvas, 'touchstart', this.touchStartHandler);
        EventHandler.remove(this.lowerCanvas, 'touchstart', this.touchStartHandler);
        EventHandler.remove(this.lowerCanvas, 'mousewheel DOMMouseScroll', this.handleScroll);
        EventHandler.remove(this.upperCanvas, 'mousewheel DOMMouseScroll', this.handleScroll);
        window.removeEventListener('resize', this.windowResizeHandler.bind(this));
        if ((!Browser.isIos && Browser.info.name !== 'safari')) {
            screen.orientation.removeEventListener('change', this.screenOrientation.bind(this));
        }
        this.notify('shape', { prop: 'unWireEvent', onPropertyChange: false });
        this.notify('selection', { prop: 'unWireEvent', onPropertyChange: false });
    };
    ImageEditor.prototype.createCanvas = function () {
        this.element.style.boxSizing = 'border-box';
        var obj = { toolbarHeight: 0 };
        this.notify('toolbar', { prop: 'getToolbarHeight', value: { obj: obj } });
        var height = obj['toolbarHeight'];
        if (this.toolbar && this.toolbar.length > 0 && this.toolbar.indexOf('Open') === -1) {
            height = 0;
        }
        this.element.style.width = this.width;
        this.element.style.height = this.height;
        var canvasWrapperElement = this.createElement('div', { id: this.element.id + '_canvasWrapper', className: 'e-canvas-wrapper' });
        canvasWrapperElement.style.cssText = "height: " + (this.element.offsetHeight - height - 2) + "px; width: " + (this.element.offsetWidth - 2) + "px; position: relative; overflow: hidden; margin: 0 auto;";
        var canvasWrapper = this.element.appendChild(canvasWrapperElement);
        var dragObj = { key: 'DragText' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: dragObj } });
        var dropObj = { key: 'DropText' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: dropObj } });
        var browseObj = { key: 'BrowseText' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: browseObj } });
        var dropAreaElement = this.createElement('div', { id: this.element.id + '_dropArea', className: 'e-ie-drop-area' });
        dropAreaElement.style.position = 'relative';
        var dropIconElement = this.createElement('span', { className: 'e-ie-drop-icon e-icons e-image' });
        dropIconElement.style.position = 'absolute';
        var dropContentElement = this.createElement('span', { className: 'e-ie-drop-content' });
        dropContentElement.style.cssText = 'position: absolute; display: none;';
        dropContentElement.textContent = dragObj['value'] + ' ';
        var minDropContentElem = this.createElement('span', { className: 'e-ie-min-drop-content' });
        minDropContentElem.style.position = 'absolute';
        minDropContentElem.textContent = dropObj['value'] + ' ';
        var dropAnchorElement = this.createElement('a', { id: this.element.id + '_dropBrowse', className: 'e-ie-drop-browse' });
        dropAnchorElement.textContent = browseObj['value'];
        var minDropAnchorElem = this.createElement('a', { id: this.element.id + '_dropBrowse', className: 'e-ie-drop-browse' });
        minDropAnchorElem.textContent = browseObj['value'];
        dropContentElement.appendChild(dropAnchorElement);
        minDropContentElem.appendChild(minDropAnchorElem);
        dropAnchorElement.href = '';
        minDropAnchorElem.href = '';
        var dropInfoElement = this.createElement('span', { className: 'e-ie-drop-info', attrs: { position: 'absolute' } });
        this.updateDropInfoContent(dropInfoElement);
        var dropUploader = dropAreaElement.appendChild(this.createElement('input', {
            id: this.element.id + '_dropfileUpload', className: 'e-fileUpload e-image-upload'
        }));
        dropUploader.setAttribute('type', 'file');
        dropUploader.setAttribute('accept', 'image/*');
        dropAreaElement.appendChild(dropIconElement);
        dropAreaElement.appendChild(dropContentElement);
        dropAreaElement.appendChild(minDropContentElem);
        dropAreaElement.appendChild(dropInfoElement);
        canvasWrapper.appendChild(dropAreaElement);
        this.lowerCanvas = canvasWrapper.appendChild(this.createElement('canvas', {
            id: this.element.id + '_lowerCanvas', attrs: { name: 'canvasImage' }
        }));
        this.maskCanvas = canvasWrapper.appendChild(this.createElement('canvas', {
            id: this.element.id + '_maskCanvas', attrs: { name: 'canvasImage' }
        }));
        this.upperCanvas = canvasWrapper.appendChild(this.createElement('canvas', {
            id: this.element.id + '_upperCanvas', attrs: { name: 'canvasImage' }
        }));
        this.inMemoryCanvas = this.createElement('canvas', {
            id: this.element.id + '_inMemoryCanvas', attrs: { name: 'canvasImage' }
        });
        this.baseImgCanvas = this.createElement('canvas', {
            id: this.element.id + '_baseImgCanvas', attrs: { name: 'canvasImage' }
        });
        this.textArea = canvasWrapper.appendChild(this.createElement('textarea', {
            id: this.element.id + '_textArea', className: 'e-textarea', attrs: { name: 'textArea' }
        }));
        var dialog = this.element.appendChild(this.createElement('div', {
            id: this.element.id + '_dialog', className: 'e-dialog'
        }));
        dialog.style.display = 'none';
        var uploader = this.element.appendChild(this.createElement('input', {
            id: this.element.id + '_fileUpload', className: 'e-fileUpload'
        }));
        uploader.setAttribute('type', 'file');
        uploader.setAttribute('accept', 'image/*');
        uploader.style.display = 'none';
        this.textArea.setAttribute('spellcheck', 'false');
        this.textArea.style.lineHeight = 'normal';
        this.lowerCanvas.style.width = this.upperCanvas.style.width = this.maskCanvas.style.width =
            this.inMemoryCanvas.style.width = '100%';
        this.lowerCanvas.style.height = this.upperCanvas.style.height = this.maskCanvas.style.height =
            this.inMemoryCanvas.style.height = '100%';
        this.upperCanvas.style.position = this.lowerCanvas.style.position = this.maskCanvas.style.position =
            this.textArea.style.position = 'absolute';
        this.textArea.style.backgroundColor = 'transparent';
        this.textArea.style.display = 'none';
        this.maskCanvas.style.display = this.textArea.style.resize = 'none';
        this.lowerContext = this.lowerCanvas.getContext('2d');
        this.baseImg = this.createElement('img', {
            id: this.element.id + '_orgImg', attrs: { name: 'Image', crossorigin: 'anonymous' }
        });
        this.upperCanvas.style.cursor = this.cursor = 'default';
        this.upperCanvas.style.display = 'block';
        this.upperContext = this.upperCanvas.getContext('2d');
        dropAnchorElement.addEventListener('click', function (e) {
            e.preventDefault();
            dropUploader.click();
            return false;
        });
        minDropAnchorElem.addEventListener('click', function (e) {
            e.preventDefault();
            dropUploader.click();
            return false;
        });
    };
    ImageEditor.prototype.touchStartHandler = function (e) {
        this.notify('selection', { prop: 'touchStartHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.mouseDownEventHandler = function (e) {
        if (e.target.className === 'e-ie-drop-browse') {
            return;
        }
        this.notify('selection', { prop: 'mouseDownEventHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.mouseMoveEventHandler = function (e) {
        this.notify('selection', { prop: 'mouseMoveEventHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.mouseUpEventHandler = function (e) {
        if (e.target.className === 'e-ie-drop-browse') {
            return;
        }
        this.notify('selection', { prop: 'mouseUpEventHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.keyDownEventHandler = function (e) {
        this.notify('selection', { prop: 'keyDownEventHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.keyUpEventHandler = function (e) {
        if ((this.textArea.style.display === 'block' || this.textArea.style.display === 'inline-block')
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            && e.target.id === this.element.id + '_textArea') {
            this.notify('selection', { prop: 'textKeyDown', value: { e: e } });
        }
    };
    ImageEditor.prototype.canvasMouseDownHandler = function (e) {
        if (e.target.className === 'e-ie-drop-browse') {
            return;
        }
        this.notify('selection', { prop: 'canvasMouseDownHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.canvasMouseMoveHandler = function (e) {
        this.notify('selection', { prop: 'canvasMouseMoveHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.canvasMouseUpHandler = function (e) {
        if (e.target.className === 'e-ie-drop-browse') {
            return;
        }
        this.notify('selection', { prop: 'canvasMouseUpHandler', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.handleScroll = function (e) {
        this.notify('selection', { prop: 'handleScroll', onPropertyChange: false, value: { e: e } });
    };
    ImageEditor.prototype.adjustToScreen = function () {
        this.update();
    };
    ImageEditor.prototype.screenOrientation = function () {
        if (Browser.isDevice) {
            setTimeout(this.adjustToScreen.bind(this), 100);
        }
    };
    ImageEditor.prototype.windowResizeHandler = function () {
        if (!Browser.isDevice && this.element.classList.contains('e-image-editor')) {
            this.adjustToScreen();
        }
    };
    ImageEditor.prototype.notifyResetForAllModules = function () {
        var modules = this.requiredModules();
        for (var i = 0; i < modules.length; i++) {
            var module = modules[i].member;
            this.notify(module === 'toolbar-module' ? 'toolbar' : module, { prop: 'reset', onPropertyChange: false });
        }
    };
    ImageEditor.prototype.allowShape = function (x, y) {
        this.isPublicMethod = true;
        this.applyShapes();
        var obj = { inRange: false };
        this.notify('shape', { prop: 'isPointsInRange', onPropertyChange: false,
            value: { x: x, y: y, obj: obj } });
        return obj['inRange'];
    };
    ImageEditor.prototype.manageActiveAction = function () {
        this.applyShapes();
        if (this.activeObj.shape && this.activeObj.shape.indexOf('crop') > -1) {
            this.discard();
        }
    };
    /**
     * Clears the current selection performed in the image editor.
     *
     * @param { boolean } resetCrop - Specifies to reset last cropped image.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.clearSelection = function (resetCrop) {
        this.notify('selection', { prop: 'clearSelection', onPropertyChange: false, value: { resetCrop: resetCrop } });
    };
    /**
     * Crops an image based on the selection done in the image editor.
     *
     * {% codeBlock src='image-editor/crop/index.md' %}{% endcodeBlock %}
     *
     * @remarks
     * The selection can be done through programmatically using the 'select' method or through UI interactions.
     *
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.crop = function () {
        var obj = { isCrop: false };
        this.notify('crop', { prop: 'crop', onPropertyChange: false, value: { obj: obj } });
        return obj['isCrop'];
    };
    /**
     * Flips an image by horizontally or vertically in the image editor.
     *
     * {% codeBlock src='image-editor/zoom/index.md' %}{% endcodeBlock %}
     *
     * @param { Direction } direction - Specifies the direction to flip the image.
     * A horizontal direction for horizontal flipping and vertical direction for vertical flipping.
     *
     * @remarks
     * It flips the shapes including rectangle, circle, line, text, image, and freehand drawings.
     *
     * @returns {void}.
     *
     */
    ImageEditor.prototype.flip = function (direction) {
        this.applyShapes();
        this.updateImageTransformColl(direction.toLowerCase() + 'flip');
        this.notify('transform', { prop: 'flip', value: { direction: direction } });
        this.notify('draw', { prop: 'redrawDownScale' });
        this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        var actionArgs = { action: 'flip', actionEventArgs: this.editCompleteArgs };
        this.triggerEditCompleteEvent(actionArgs);
    };
    /**
     * Returns an image as ImageData to load it in to a canvas.
     *
     * @param {boolean} [includeAnnotations=true] - Optional. Specifies whether the returned image data should include annotations. The default value is true, meaning annotations are included.
     *
     * @remarks
     * The data returned from this method is directly drawn in a canvas using 'putImageData' method.
     * And then the user can get the base64 string from the canvas using toDataURL method.
     *
     * @returns {ImageData}.
     */
    ImageEditor.prototype.getImageData = function (includeAnnotations) {
        includeAnnotations = isNullOrUndefined(includeAnnotations) ? true : includeAnnotations;
        var imageData;
        if (includeAnnotations) {
            var obj = { canvas: null };
            this.applyShapes();
            this.notify('export', { prop: 'exportToCanvas', value: { object: obj } });
            imageData = obj['canvas'].getContext('2d').getImageData(0, 0, obj['canvas'].width, obj['canvas'].height);
        }
        else if (this.isMaskImage && this.element.getAttribute('data-value') === 'mask-drawing') {
            imageData = this.getData(true);
            this.updateColl('reset');
        }
        else {
            imageData = this.getData();
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
        }
        return imageData;
    };
    /**
     *  Opens an image as URL or ImageData for editing in an image editor.
     *
     * @param {string | ImageData } data - Specifies url of the image or image data.
     * @param {boolean} [resetChanges=true] - Optional. Determines whether to reset existing changes when opening the image. The default value is true, which resets all existing changes.
     * @param {ImageSettings} imageSettings - Optional. Specifies the image setting that contains background color to apply when opening a transparent image. The default value of background color is an empty string (''), meaning no background color is applied by default when a transparent image is opened.
     *
     * @remarks
     * The supported file types are JPG, JPEG, PNG, and SVG.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.open = function (data, resetChanges, imageSettings) {
        resetChanges = isNullOrUndefined(resetChanges) ? true : resetChanges;
        if (resetChanges) {
            if (isNullOrUndefined(data)) {
                return;
            }
            var dropArea = document.getElementById(this.element.id + '_dropArea');
            if (dropArea) {
                dropArea.style.display = 'none';
            }
            this.notify('draw', { prop: 'open', value: { data: data } });
        }
        else {
            this.updateImage(data, imageSettings ? imageSettings.backgroundColor : null);
        }
    };
    /**
     * Reset all the changesdone in an image editor and revert to original image.
     *
     * @remarks
     * The undo redo collection also cleared while resetting the image editor.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.reset = function () {
        this.updateColl('reset');
        var obj = { isErrorImage: false };
        this.notify('draw', { prop: 'getErrorImage', value: { obj: obj } });
        if (!this.disabled && !obj['isErrorImage']) {
            this.clearContext(this.inMemoryContext);
            this.clearContext(this.lowerContext);
            this.clearContext(this.upperContext);
            this.notify('shape', { prop: 'setRedactType', onPropertyChange: false, value: { redactType: 'blur' } });
            this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                    isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });
            if (Browser.isDevice && document.getElementById(this.element.id + '_bottomToolbar')) {
                getComponent(document.getElementById(this.element.id + '_bottomToolbar'), 'toolbar').destroy();
                this.notify('toolbar', { prop: 'create-bottom-toolbar', onPropertyChange: false });
            }
            var isImageLoaded = this.isImageLoaded;
            this.currObjType.isUndoAction = this.isUndoRedo = this.togglePan = this.togglePen = this.isImageLoaded = this.isFinetuning = false;
            this.isCircleCrop = this.isCropTab = false;
            this.objColl = [];
            this.transform.degree = 0;
            this.upperCanvas.style.display = 'block';
            this.transform.currFlipState = '';
            this.allowDownScale = true;
            this.upperCanvas.style.cursor = this.cursor = this.lowerCanvas.style.cursor = 'default';
            this.lowerContext.lineWidth = this.upperContext.lineWidth = undefined;
            this.frameDestPoints = null;
            this.textArea.value = this.textArea.textContent = '';
            this.textArea.style.display = 'none';
            this.lowerContext.filter = this.canvasFilter = this.getDefaultFilter();
            this.img.destLeft = this.img.destTop = this.img.srcLeft = this.img.srcTop = 0;
            this.img.destWidth = this.img.destHeight = this.img.srcWidth = this.img.srcHeight = null;
            this.currSelectionPoint = null;
            this.panPoint.currentPannedPoint = { x: 0, y: 0 };
            this.rotateFlipColl = [];
            this.points = [];
            this.pointColl = {};
            this.freehandCounter = 0;
            this.notify('draw', { prop: 'resetPanPoints' });
            this.lowerCanvas.style.left = this.upperCanvas.style.left = '';
            this.fontSizeColl = [];
            this.lowerCanvas.style.top = this.upperCanvas.style.top = '';
            this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = '';
            this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = '';
            this.transform.defaultZoomFactor = this.transform.zoomFactor = 0;
            this.transform.cropZoomFactor = null;
            this.frameObj = { type: 'none', color: '#fff', size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: 'solid', gradientColor: '' };
            this.tempFrameObj = { type: 'none', color: '#fff', size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: 'solid', gradientColor: '' };
            this.currObjType = { shape: '', isDragging: false, isActiveObj: false, isText: false, isInitialText: false, isLine: false,
                isInitialLine: false, isCustomCrop: false, isZoomed: false, isUndoZoom: false,
                isUndoAction: false, isFiltered: false, isSave: false, isResize: false, isRedact: false };
            this.cropObj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
                totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {},
                rotateFlipColl: [], degree: 0, currFlipState: '', straighten: 0, zoomFactor: 0, previousZoomValue: 0,
                destPoints: { startX: 0, startY: 0, width: 0, height: 0 }, frame: 'none',
                srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: false,
                aspectWidth: null, aspectHeight: null, straightenZoom: 0,
                adjustmentLevel: { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
                    exposure: 0, transparency: 100, sharpen: false, bw: false }, currentFilter: '' };
            this.afterCropActions = [];
            this.currentFilter = '';
            this.tempFrameZoomLevel = null;
            this.cxtTbarHeight = null;
            this.straightenPoint = null;
            this.transform.straighten = 0;
            this.cancelCropSelection = null;
            this.aspectWidth = this.aspectHeight = null;
            this.isResize = this.isMaskImage = false;
            this.drawingShape = null;
            this.isShapeDrawing = this.noPushUndo = this.isUndoRedoStack = this.isKBDNavigation = false;
            this.shapeColl = [];
            this.tempObjColl = [];
            this.tempPointColl = [];
            this.tempShapeColl = [];
            this.isImageUpdated = false;
            this.tempToolbarHeight = 0;
            this.tempToolbar = [];
            this.tempRedactBlur = 50;
            this.tempRedactPixel = 40;
            var obj_1 = { initialZoomValue: false };
            this.editCompleteArgs = null;
            this.isFinetuneBtnClick = false;
            this.notify('draw', { prop: 'getInitialZoomValue', onPropertyChange: false, value: { obj: obj_1 } });
            if (obj_1['initialZoomValue']) {
                this.setProperties({ zoomSettings: { zoomFactor: obj_1['initialZoomValue'] } }, true);
            }
            var qtArea = document.getElementById(this.element.id + '_quickAccessToolbarArea');
            if (qtArea) {
                qtArea.style.display = 'none';
            }
            this.notifyResetForAllModules();
            this.notify('filter', { prop: 'update-finetunes' });
            if (this.toolbarTemplate) {
                this.toolbarHeight = this.element.querySelector('#' + this.element.id + '_toolbarArea').clientHeight;
            }
            else if (this.element.querySelector('#' + this.element.id + '_toolbar')) {
                this.toolbarHeight = this.element.querySelector('#' + this.element.id + '_toolbar').clientHeight;
            }
            this.notify('toolbar', { prop: 'setToolbarHeight', value: { height: this.toolbarHeight } });
            this.isImageLoaded = isImageLoaded;
            this.straightenBaseImageCanvas();
            this.isImageLoaded = false;
            this.notify('draw', { prop: 'update-canvas', onPropertyChange: false });
            this.isImageLoaded = isImageLoaded;
            this.prevStraightenedDegree = 0;
            var ctWrapper = this.element.querySelector('.e-contextual-toolbar-wrapper');
            if (ctWrapper) {
                ctWrapper.classList.add('e-hide');
            }
            this.notify('toolbar', { prop: 'refresh-dropdown-btn', value: { isDisabled: false } });
            this.notify('toolbar', { prop: 'enable-disable-btns' });
            var straightenObj = { bool: this.isStraightening };
            if (Browser.isDevice && straightenObj['bool']) {
                this.notify('crop', { prop: 'resizeWrapper' });
            }
            var saveDialog = this.element.querySelector('#' + this.element.id + '_saveDialog');
            if (saveDialog) {
                getComponent(saveDialog, 'dialog').close();
            }
            var actionArgs = { action: 'reset', actionEventArgs: null };
            this.triggerEditCompleteEvent(actionArgs);
        }
    };
    /**
     * Rotate an image to clockwise and anti-clockwise.
     *
     * {% codeBlock src='image-editor/rotate/index.md' %}{% endcodeBlock %}
     *
     * @param {number} degree - Specifies a degree to rotate an image.
     * A positive integer value for clockwise and negative integer value for anti-clockwise rotation.
     *
     * @remarks
     * It rotated the shapes including rectangle, circle, line, text, image, and freehand drawings.
     *
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.rotate = function (degree) {
        var obj = { isRotate: false };
        this.applyShapes();
        if (degree === 90 || degree === -90) {
            this.updateImageTransformColl(degree === 90 ? 'rotateright' : 'rotateleft');
        }
        this.notify('transform', { prop: 'rotate', value: { degree: degree, obj: obj } });
        this.notify('draw', { prop: 'redrawDownScale' });
        var actionArgs = { action: 'rotate', actionEventArgs: this.editCompleteArgs };
        this.triggerEditCompleteEvent(actionArgs);
        return obj['isRotate'];
    };
    /**
     * Export an image using the specified file name and the extension.
     *
     * @param {string} type - Specifies a format of image to be saved.
     * @param {string} fileName  Specifies a file name to be saved
     * @param {number} imageQuality  Specifies the quality of an image to be saved. The default value is 1 which represents the original size of the image if not specified.
     *
     * @remarks
     * The supported file types are JPG, JPEG, PNG, and SVG.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.export = function (type, fileName, imageQuality) {
        this.applyShapes();
        this.notify('export', { prop: 'export', onPropertyChange: false, value: { type: type, fileName: fileName, imgQuality: imageQuality } });
    };
    /**
     * Perform selection in an image editor. The selection helps to crop an image.
     *
     * {% codeBlock src='image-editor/select/index.md' %}{% endcodeBlock %}
     *
     * @param {string} type - Specifies the shape - circle / square / custom selection / pre-defined ratios.
     * @param {number} startX  Specifies the start x-coordinate point of the selection.
     * @param {number} startY  Specifies the start y-coordinate point of the selection.
     * @param {number} width - Specifies the width of the selection area.
     * @param {number} height - Specifies the height of the selection area.
     *
     * @remarks
     * The selection UI is based on the 'theme' property.
     *
     * @returns {void}.
     *
     */
    ImageEditor.prototype.select = function (type, startX, startY, width, height) {
        this.applyShapes();
        this.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: 'crop-' + type } });
        this.notify('draw', { prop: 'select', onPropertyChange: false,
            value: { type: type, startX: startX, startY: startY, width: width, height: height } });
        if ((startX && startY) || (width && height)) {
            this.notify('draw', { prop: 'select', onPropertyChange: false,
                value: { type: type, startX: startX, startY: startY, width: width, height: height } });
        }
        else {
            this.cropObj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
                totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {},
                rotateFlipColl: [], degree: 0, currFlipState: '', straighten: 0, zoomFactor: 0, previousZoomValue: 0,
                destPoints: { startX: 0, startY: 0, width: 0, height: 0 }, frame: 'none',
                srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: false,
                aspectWidth: null, aspectHeight: null, straightenZoom: 0,
                adjustmentLevel: { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
                    exposure: 0, transparency: 100, sharpen: false, bw: false }, currentFilter: '' };
        }
    };
    /**
     * Enable or disable a freehand drawing option in an Image Editor.
     *
     * @param {boolean} value - Specifies a value whether to enable or disable freehand drawing.
     *
     * @returns {void}.
     * @private
     */
    ImageEditor.prototype.freeHandDraw = function (value) {
        this.notify('freehand-draw', { prop: 'freeHandDraw', onPropertyChange: false, value: { value: value } });
    };
    /**
     * Enable or disable a freehand drawing in an Image Editor.
     *
     * @param {boolean} value - Specifies a value whether to enable or disable freehand drawing.
     *
     * @remarks
     * User can directly drawing on a canvas after enabling this option.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.freehandDraw = function (value) {
        if (!this.disabled && this.isImageLoaded) {
            if (!value && this.isMaskImage) {
                this.discard();
                return;
            }
            this.manageActiveAction();
            this.freeHandDraw(value);
            var prevObj = { shapeSettingsObj: {} };
            this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: prevObj } });
            var shapeSettings = prevObj['shapeSettingsObj'];
            shapeSettings.type = ShapeType.FreehandDraw;
            var shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings };
            this.notify('freehand-draw', { prop: 'triggerShapeChanging', value: { shapeChangingArgs: shapeChangingArgs } });
        }
    };
    /**
     * Enable or disable a panning on the Image Editor.
     *
     * @param {boolean} value - Specifies a value whether enable or disable panning.
     * @param {number} x - Optional, Specifies a value to pan the image horizontally.
     * @param {number} y - Optional, Specifies a value to pan the image vertically.
     *
     * @remarks
     * This option will take into effect once the image's visibility is hidden when zooming an image or selection has been performed.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.pan = function (value, x, y) {
        this.applyShapes();
        this.notify('transform', { prop: 'pan', onPropertyChange: false, value: { value: value, x: x, y: y } });
    };
    /**
     * Zoom in or out on a point in the image editor.
     *
     * @param {number} zoomFactor - The percentage-based zoom factor to use (e.g. 20 for 2x zoom).
     * @param {Point} zoomPoint - The point in the image editor to zoom in/out on.
     *
     * @remarks
     * Zooming directly enables the panning option when the image's visibility is hidden.
     * User can disable it by using 'Pan' method.
     * @returns {void}
     *
     */
    ImageEditor.prototype.zoom = function (zoomFactor, zoomPoint) {
        this.isZoomBtnClick = true;
        this.notify('transform', { prop: 'zoom', onPropertyChange: false,
            value: { zoomFactor: zoomFactor, zoomPoint: zoomPoint } });
        this.notify('draw', { prop: 'redrawDownScale' });
    };
    /**
     * Draw ellipse on an image.
     *
     * {% codeBlock src='image-editor/ellipse/index.md' %}{% endcodeBlock %}
     *
     * @param {number} x - Specifies x-coordinate of ellipse.
     * @param {number} y - Specifies y-coordinate of ellipse.
     * @param {number} radiusX - Specifies the radius x point for the ellipse.
     * @param {number} radiusY - Specifies the radius y point for the ellipse.
     * @param {number} strokeWidth - Specifies the stroke width of ellipse.
     * @param {string} strokeColor - Specifies the stroke color of ellipse.
     * @param {string} fillColor - Specifies the fill color of the ellipse.
     * @param {number} degree - Specifies the degree to rotate the ellipse.
     * @param {boolean} isSelected - Specifies to show the ellipse in the selected state.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.drawEllipse = function (x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {
        var isEllipse = false;
        var isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            isEllipse = true;
            this.manageActiveAction();
            this.notify('shape', { prop: 'drawEllipse', onPropertyChange: false, value: { x: x, y: y, radiusX: radiusX, radiusY: radiusY,
                    strokeWidth: strokeWidth, strokeColor: strokeColor, fillColor: fillColor, degree: degree, isSelected: isSelected } });
            this.editCompleted();
        }
        return isEllipse;
    };
    /**
     * Draw line on an image.
     *
     * @param {number} startX  Specifies start point x-coordinate of line.
     * @param {number} startY  Specifies start point y-coordinate of line.
     * @param {number} endX - Specifies end point x-coordinates of line.
     * @param {number} endY - Specifies end point y-coordinates of the line.
     * @param {number} strokeWidth - Specifies the stroke width of line.
     * @param {string} strokeColor - Specifies the stroke color of line.
     * @param {boolean} isSelected - Specifies to show the line in the selected state.
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawLine = function (startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {
        var isLine = false;
        var isPointsInRange = this.allowShape(startX, startY);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(startX) && isNullOrUndefined(startY)))) {
            isLine = true;
            this.manageActiveAction();
            this.notify('shape', { prop: 'drawLine', onPropertyChange: false, value: { startX: startX, startY: startY, endX: endX,
                    endY: endY, strokeWidth: strokeWidth, strokeColor: strokeColor, isSelected: isSelected } });
            this.editCompleted();
        }
        return isLine;
    };
    /**
     * Draw arrow on an image.
     *
     * @param {number} startX  Specifies start point x-coordinate of arrow.
     * @param {number} startY  Specifies start point y-coordinate of arrow.
     * @param {number} endX - Specifies end point x-coordinates of arrow.
     * @param {number} endY - Specifies end point y-coordinates of the arrow.
     * @param {number} strokeWidth - Specifies the stroke width of arrow.
     * @param {string} strokeColor - Specifies the stroke color of arrow.
     * @param {ArrowheadType} arrowStart  Specifies the type of arrowhead for start position. The default value is None.
     * @param {ArrowheadType} arrowEnd  Specifies the type of arrowhead for end position. The default value is SolidArrow.
     * @param {boolean} isSelected - Specifies to show the arrow in the selected state.
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawArrow = function (startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {
        var isArrow = false;
        var isPointsInRange = this.allowShape(startX, startY);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(startX) && isNullOrUndefined(startY)))) {
            isArrow = true;
            this.manageActiveAction();
            this.notify('shape', { prop: 'drawArrow', onPropertyChange: false, value: { startX: startX, startY: startY, endX: endX,
                    endY: endY, strokeWidth: strokeWidth, strokeColor: strokeColor, arrowStart: arrowStart, arrowEnd: arrowEnd,
                    isSelected: isSelected } });
            this.editCompleted();
        }
        return isArrow;
    };
    /**
     * Draw path on an image.
     *
     * @param {Point[]} pointColl  Specifies collection of start and end x, y-coordinates of path.
     * @param {number} strokeWidth - Specifies the stroke width of path.
     * @param {string} strokeColor - Specifies the stroke color of path.
     * @param {boolean} isSelected - Specifies to show the path in the selected state.
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawPath = function (pointColl, strokeWidth, strokeColor, isSelected) {
        this.isPublicMethod = true;
        var obj = { inRange: false };
        var isPath = false;
        if (pointColl && pointColl.length > 0) {
            for (var i = 0; i < pointColl.length; i++) {
                if (obj['inRange']) {
                    break;
                }
                this.notify('shape', { prop: 'isPointsInRange', onPropertyChange: false,
                    value: { x: pointColl[i].x, y: pointColl[i].y, obj: obj } });
            }
        }
        if (!this.disabled && this.isImageLoaded && (obj['inRange'] || isNullOrUndefined(pointColl))) {
            isPath = true;
            this.manageActiveAction();
            this.notify('shape', { prop: 'drawPath', onPropertyChange: false, value: { pointColl: pointColl,
                    strokeWidth: strokeWidth, strokeColor: strokeColor, isSelected: isSelected } });
            this.editCompleted();
        }
        return isPath;
    };
    /**
     * Draw a rectangle on an image.
     *
     * @param {number} x - Specifies x-coordinate of rectangle.
     * @param {number} y - Specifies y-coordinate of rectangle.
     * @param {number} width - Specifies the width of the rectangle.
     * @param {number} height - Specifies the height of the rectangle.
     * @param {number} strokeWidth - Specifies the stroke width of rectangle.
     * @param {string} strokeColor - Specifies the stroke color of rectangle.
     * @param {string} fillColor - Specifies the fill color of the rectangle.
     * @param {number} degree - Specifies the degree to rotate the rectangle.
     * @param {boolean} isSelected - Specifies to show the rectangle in the selected state.
     * @param {number} borderRadius - Specifies the radius to apply border radius to rectangle.
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawRectangle = function (x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected, borderRadius) {
        var isRectangle = false;
        var isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            isRectangle = true;
            this.manageActiveAction();
            this.notify('shape', { prop: 'drawRectangle', onPropertyChange: false, value: { x: x, y: y, width: width, height: height,
                    strokeWidth: strokeWidth, strokeColor: strokeColor, fillColor: fillColor, degree: degree, isSelected: isSelected,
                    radius: borderRadius } });
            this.editCompleted();
        }
        return isRectangle;
    };
    /**
     * Draw a text on an image.
     *
     * {% codeBlock src='image-editor/text/index.md' %}{% endcodeBlock %}
     *
     * @param {number} x - Specifies x-coordinate of text.
     * @param {number} y - Specifies y-coordinate of text.
     * @param {string} text - Specifies the text to add on an image.
     * @param {string} fontFamily - Specifies the font family of the text.
     * @param {number} fontSize - Specifies the font size of the text.
     * @param {boolean} bold - Specifies whether the text is bold or not.
     * @param {boolean} italic - Specifies whether the text is italic or not.
     * @param {string} color - Specifies font color of the text.
     * @param {boolean} isSelected - Specifies to show the text in the selected state.
     * @param {number} degree - Specifies the degree to rotate the text.
     * @param {fillColor} fillColor - Specifies the background Color of the text.
     * @param {string} strokeColor - Specifies the outline color of the text annotation.
     * @param {number} strokeWidth - Specifies the outline stroke width of the text annotation.
     * @param {TransformationCollection[]} transformCollection - Specifies the transform collection of the text annotation.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.drawText = function (x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree, fillColor, strokeColor, strokeWidth, transformCollection) {
        var isText = false;
        var isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            isText = true;
            this.manageActiveAction();
            this.notify('shape', { prop: 'drawText', onPropertyChange: false, value: { x: x, y: y, text: text, fontFamily: fontFamily,
                    fontSize: fontSize, bold: bold, italic: italic, color: color, isSelected: isSelected, degree: degree, fillColor: fillColor,
                    outlineColor: strokeColor, outlineWidth: strokeWidth, transformCollection: transformCollection } });
            this.editCompleted();
        }
        return isText;
    };
    /**
     * Draw an image as annotation on an image.
     *
     *
     * @param {string | ImageData} data - Specifies url of the image or image data.
     * @param {number} x - Specifies x-coordinate of a starting point for an image.
     * @param {number} y - Specifies y-coordinate of a starting point for an image.
     * @param {number} width - Specifies the width of the image.
     * @param {number} height - Specifies the height of the image.
     * @param {boolean} isAspectRatio - Specifies whether to maintain aspect ratio or not.
     * @param {number} degree - Specifies the degree to rotate the image.
     * @param {number} opacity - Specifies the value for the image.
     * @param {boolean} isSelected - Specifies to show the image in the selected state.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.drawImage = function (data, x, y, width, height, isAspectRatio, degree, opacity, isSelected) {
        var isImage = false;
        var isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            this.manageActiveAction();
            var length_1 = this.objColl.length;
            this.notify('shape', { prop: 'drawImage', onPropertyChange: false, value: { x: x, y: y, width: width, height: height,
                    src: data, degree: degree, isAspectRatio: isAspectRatio, opacity: opacity, isSelected: isSelected } });
            this.editCompleted();
            if (this.objColl.length > length_1) {
                isImage = true;
            }
        }
        return isImage;
    };
    /**
     * This method is used to update the existing shapes by changing its height, width, color, and font styles in the component.
     * Use 'getShapeSettings' method to get the shape which is then passed to change the options of a shape.
     * {% codeBlock src='image-editor/updateShape/index.md' %}{% endcodeBlock %}
     *
     * @param {ShapeSettings} setting - Specifies the shape settings to be updated for the shape on an image.
     * @param {boolean} isSelected - Specifies to show the shape in the selected state.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.updateShape = function (setting, isSelected) {
        var obj = { isSelected: false };
        var isTextArea = false;
        var freehandObj = { bool: false };
        if (isNullOrUndefined(setting.id)) {
            if (setting.strokeColor) {
                this.activeObj.strokeSettings.strokeColor = setting.strokeColor;
            }
            if (setting.fillColor) {
                this.activeObj.strokeSettings.fillColor = setting.fillColor;
            }
            if (setting.strokeWidth) {
                this.activeObj.strokeSettings.strokeWidth = setting.strokeWidth;
            }
            if (setting.index) {
                this.activeObj.order = setting.index;
            }
            if (setting.type === 'FreehandDraw' && setting.strokeWidth) {
                this.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: setting.strokeWidth } });
            }
        }
        else {
            if (setting.type.toLowerCase() === 'text' && (this.textArea.style.display === 'block' ||
                this.textArea.style.display === 'inline-block')) {
                this.okBtn(null, true);
                isTextArea = true;
            }
            this.notify('shape', { prop: 'selectShape', onPropertyChange: false, value: { id: setting.id, obj: obj, isShape: true } });
            this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: freehandObj } });
            if (obj['isSelected']) {
                var tempFontSize = this.activeObj.textSettings.fontSize;
                this.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                    value: { shapeSettings: setting } });
                if (this.activeObj.shape === 'text' && tempFontSize) {
                    var diff = this.activeObj.textSettings.fontSize - tempFontSize;
                    if (diff !== 0) {
                        this.activeObj.activePoint.height += diff;
                        this.activeObj.activePoint.startY -= (diff / 2);
                        this.activeObj.activePoint.endY += (diff / 2);
                        this.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: this.activeObj.activePoint, obj: this.activeObj,
                                isMouseMove: null, x: null, y: null } });
                    }
                }
                var activeObj = extend({}, this.activeObj, {}, true);
                this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: null } });
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                if (activeObj.shape) {
                    this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });
                }
                if (this.activeObj.shape === 'text') {
                    this.notify('toolbar', { prop: 'editText', onPropertyChange: false });
                }
                if (freehandObj['bool']) {
                    this.notify('undo-redo', { prop: 'setPreventUR', value: { bool: true } });
                }
                this.okBtn(isSelected, true);
                if (freehandObj['bool']) {
                    this.notify('undo-redo', { prop: 'setPreventUR', value: { bool: false } });
                }
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                this.editCompleteArgs = { action: 'shape-update', currentShapeSettings: setting };
                this.editCompleted('shape-customize');
                if (isTextArea) {
                    this.enableTextEditing();
                }
                if (isSelected) {
                    this.noRedact = true;
                    this.selectShape(setting.id);
                }
            }
        }
        return obj['isSelected'];
    };
    /**
     * Select a shape based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform selection.
     *
     * {% codeBlock src='image-editor/selectShape/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the shape id to select a shape on an image.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.selectShape = function (id) {
        this.applyShapes();
        var obj = { isSelected: false };
        this.notify('shape', { prop: 'selectShape', onPropertyChange: false, value: { id: id, obj: obj, isShape: true } });
        this.editCompleted('shape-select');
        this.noRedact = false;
        return obj['isSelected'];
    };
    /**
     * Deletes a shape based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform selection.
     *
     * {% codeBlock src='image-editor/deleteShape/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the shape id to delete the shape on an image.
     * @returns {void}.
     *
     */
    ImageEditor.prototype.deleteShape = function (id) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var shape = this.getShapeSetting(id);
        if (shape.type === 'Redact') {
            return;
        }
        this.applyShapes();
        this.notify('shape', { prop: 'deleteShape', onPropertyChange: false, value: { id: id, isShape: true } });
        this.editCompleted('shape-delete');
    };
    /**
     * Get particular shapes details based on id of the shape which is drawn on an image editor.
     *
     * {% codeBlock src='image-editor/getShapeSetting/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the shape id on an image.
     * @returns {ShapeSettings}.
     *
     */
    ImageEditor.prototype.getShapeSetting = function (id) {
        this.applyShapes();
        var obj = { shapeDetails: null };
        this.notify('shape', { prop: 'getShapeSetting', onPropertyChange: false,
            value: { id: id, obj: obj } });
        this.notify('draw', { prop: 'redrawDownScale' });
        var shapeDetails = obj['shapeDetails'] ? obj['shapeDetails'] : {};
        return shapeDetails;
    };
    /**
     * Get all the shapes details which is drawn on an image editor.
     *
     * @returns {ShapeSettings[]}.
     */
    ImageEditor.prototype.getShapeSettings = function () {
        this.applyShapes();
        var obj = { shapeDetailsColl: [] };
        this.notify('shape', { prop: 'getShapeSettings', onPropertyChange: false, value: { obj: obj } });
        this.notify('draw', { prop: 'redrawDownScale' });
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        return obj.shapeDetailsColl.filter(function (item) { return item.type !== 'redact'; });
    };
    /**
     * Get all the shapes details which is drawn on an image editor.
     *
     * @returns {RedactSettings[]}.
     */
    ImageEditor.prototype.getRedacts = function () {
        this.applyShapes();
        var obj = { shapeDetailsColl: [] };
        this.notify('shape', { prop: 'getRedactSettings', onPropertyChange: false, value: { obj: obj } });
        this.notify('draw', { prop: 'redrawDownScale' });
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        return obj.shapeDetailsColl.filter(function (item) { return item.type !== 'redact'; });
    };
    /**
     * Select a redaction based on the given redaction id.
     * Use 'getRedacts' method to get the shape id which is then passed to perform selection.
     *
     *
     * @param {string} id - Specifies the shape id to select a redact on an image.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.selectRedact = function (id) {
        this.applyShapes();
        var obj = { isSelected: false };
        this.notify('shape', { prop: 'selectShape', onPropertyChange: false, value: { id: id, obj: obj, isRedact: true } });
        this.editCompleted('redact-select');
        this.noRedact = false;
        return obj['isSelected'];
    };
    /**
     * Deletes a redaction based on the given shape id.
     * Use 'getRedacts' method to get the redaaction id which is then passed to perform deletion.
     *
     *
     * @param {string} id - Specifies the redaction id to delete the redaction on an image.
     * @returns {void}.
     *
     */
    ImageEditor.prototype.deleteRedact = function (id) {
        this.applyShapes();
        this.notify('shape', { prop: 'deleteShape', onPropertyChange: false, value: { id: id, isRedact: true } });
        this.editCompleted('redact-delete');
    };
    /**
     * This method is used to update the existing redacts by changing its height, width, blur, and pixel size in the component.
     * Use 'getRedacts' method to get the redacts which is then passed to change the options of a redacts.
     *
     * @param {RedactSettings} setting - Specifies the redact settings to be updated for the shape on an image.
     * @param {boolean} isSelected - Specifies to show the redacts in the selected state.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.updateRedact = function (setting, isSelected) {
        this.applyShapes();
        var obj = { isSelected: false };
        this.notify('shape', { prop: 'selectShape', onPropertyChange: false, value: { id: setting.id, obj: obj, isRedact: true } });
        if (obj['isSelected']) {
            this.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                value: { shapeSettings: setting } });
            if (setting.blurIntensity) {
                this.activeObj.redactBlur = setting.blurIntensity;
            }
            if (setting.pixelSize) {
                this.activeObj.redactPixelate = setting.pixelSize;
            }
            this.activeObj.redactType = setting.type.toLowerCase() === 'blur' ? 'blur' : 'pixelate';
            var activeObj = extend({}, this.activeObj, {}, true);
            this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: null } });
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            if (activeObj.shape) {
                this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });
            }
            this.okBtn(isSelected, true);
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.editCompleteArgs = { action: 'redact-update', currentShapeSettings: setting };
            this.editCompleted('redact-customize');
            if (isSelected) {
                this.selectRedact(setting.id);
            }
        }
        return obj['isSelected'];
    };
    /**
     * To refresh the Canvas Wrapper.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.update = function () {
        this.notify('transform', { prop: 'update' });
    };
    /**
     * Finetuning an image with the given type of finetune and its value in the image editor.
     *
     * @param {ImageFinetuneOption } finetuneOption - Specifies the finetune options to be performed in the image.
     * @param {number } value - Specifies the value for finetuning the image.
     *
     * @remarks
     * The finetuning will not affect the shapes background and border color.
     *
     * @returns {void}.
     *
     */
    ImageEditor.prototype.finetuneImage = function (finetuneOption, value) {
        if (!this.disabled && this.isImageLoaded) {
            this.manageActiveAction();
            this.notify('filter', { prop: 'finetuneImage', value: { value: value, option: finetuneOption } });
            this.editCompleteArgs = { finetune: finetuneOption, value: value };
            this.editCompleted('fine-tune');
        }
    };
    /**
     * Filtering an image with the given type of filters.
     *
     * @param {ImageFilterOption } filterOption - Specifies the filter options to the image.
     *
     * @remarks
     * The filtering will not affect the shape's background and border color.
     * @returns {void}.
     */
    ImageEditor.prototype.applyImageFilter = function (filterOption) {
        if (!this.disabled && this.isImageLoaded) {
            this.manageActiveAction();
            this.notify('filter', { prop: 'applyImageFilter', value: { option: filterOption.toString() } });
            this.editCompleteArgs = { filter: filterOption };
            this.editCompleted('filter');
            this.canvasFilter = this.lowerContext.filter;
            this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
    };
    /**
     * Reverse the last action which performed by the user in the Image Editor.
     *
     * @remarks
     * This method will take into effect once the 'allowUndoRedo' property is enabled.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.undo = function () {
        this.manageActiveAction();
        this.notify('undo-redo', { prop: 'undo', onPropertyChange: false });
        this.notify('draw', { prop: 'redrawDownScale' });
    };
    /**
     * Redo the last user action that was undone by the user or `undo` method.
     *
     * @remarks
     * This method will take into effect once the 'allowUndoRedo' property is enabled.
     * @returns {void}.
     */
    ImageEditor.prototype.redo = function () {
        this.manageActiveAction();
        this.notify('undo-redo', { prop: 'redo', onPropertyChange: false });
        this.notify('draw', { prop: 'redrawDownScale' });
    };
    /**
     * Get the dimension of an image in the image editor such as x, y, width, and height.
     * The method helps to get dimension after cropped an image.
     *
     * @returns {Dimension}.
     * A Dimension object containing the x, y, width, and height of an image.
     */
    ImageEditor.prototype.getImageDimension = function () {
        return { x: this.img.destLeft, y: this.img.destTop, width: this.img.destWidth, height: this.img.destHeight };
    };
    /**
     * Resize an image by changing its width and height.
     *
     * @param {number} width - Specifies the width of an image.
     * @param {number} height - Specifies the height of an image.
     * @param {boolean} isAspectRatio - Specifies whether the scaling option is enabled or not.
     *
     * @returns {boolean} - A boolean value indicating the success of the resizing operation.
     */
    ImageEditor.prototype.resize = function (width, height, isAspectRatio) {
        var isResized = false;
        if (((width.toString()).length <= 4 && (height.toString()).length <= 4) && (!this.isCircleCrop || isAspectRatio)) {
            this.manageActiveAction();
            this.notify('toolbar', { prop: 'resizeClick', value: { bool: false } });
            var destPoints = { startX: this.img.destLeft, startY: this.img.destTop, width: this.img.destWidth,
                height: this.img.destHeight };
            if (isAspectRatio) {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'resize',
                        isApplyBtn: false, isCropping: false } });
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'resize',
                        isApplyBtn: false, isCropping: false } });
            }
            else {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'resize',
                        isApplyBtn: false, isCropping: false } });
            }
            var aspectRatioWidth = this.element.querySelector('#' + this.element.id + '_resizeWidth');
            var aspectRatioHeight = this.element.querySelector('#' + this.element.id + '_resizeHeight');
            if (aspectRatioWidth && aspectRatioHeight) {
                getComponent(aspectRatioWidth, 'numerictextbox').value = Math.floor(width);
                aspectRatioWidth.value = Math.floor(width).toString() + ' px';
                getComponent(aspectRatioHeight, 'numerictextbox').value = Math.floor(height);
                aspectRatioHeight.value = Math.floor(height).toString() + ' px';
            }
            this.notify('transform', { prop: 'resize', value: { width: width, height: height, isAspectRatio: isAspectRatio } });
            if (destPoints.startX !== this.img.destLeft || destPoints.startY !== this.img.destTop ||
                destPoints.width !== this.img.destWidth || destPoints.height !== this.img.destHeight) {
                isResized = true;
                this.aspectWidth = width;
                this.aspectHeight = height;
                if (isAspectRatio) {
                    this.aspectHeight = null;
                }
                this.okBtn(false, false, true);
            }
            else {
                this.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
            }
            this.notify('draw', { prop: 'redrawDownScale' });
        }
        return isResized;
    };
    /**
     * Draw a frame on an image.
     *
     * @param { FrameType} frameType - Specifies the frame option to be drawn on an image.
     * @param {string} color - Specifies the color of a frame on an image. The default value is #fff.
     * @param {string} gradientColor - Specifies the gradient color of a frame on an image. The default value is .
     * @param {number} size - Specifies the size of the frame as a percentage. It can be provided as an integer percentage (e.g., 10). Defaults to 20 if not specified.
     * @param {number} inset - Specifies the inset value for line, hook, and inset type frames, as a percentage. It can be provided as an integer percentage (e.g., 10). Defaults to 0 if not specified.
     * @param {number} offset - Specifies the offset value for line and inset type frames, as a percentage. It can be provided as an integer percentage (e.g., 10). Defaults to 0 if not specified.
     * @param {number} borderRadius - Specifies the border radius for line-type frames, as a percentage. It can be provided as an integer percentage (e.g., 10). Defaults to 0 if not specified.
     * @param {FrameLineStyle} frameLineStyle - Specifies the type of line to be drawn for line-type frames. Default to Solid if not specified.
     * @param {number} lineCount - Specifies the number of lines for line-type frames. Defaults to 0 if not specified.
     *
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawFrame = function (frameType, color, gradientColor, size, inset, offset, borderRadius, frameLineStyle, lineCount) {
        this.manageActiveAction();
        var isFrame = false;
        var obj = { frameChangeEventArgs: null };
        color = color ? color : '#fff';
        gradientColor = gradientColor ? gradientColor : '';
        size = size ? size : 20;
        inset = inset ? inset : 0;
        offset = offset ? offset : 0;
        borderRadius = borderRadius ? borderRadius : 0;
        frameLineStyle = frameLineStyle ? frameLineStyle : FrameLineStyle.Solid;
        lineCount = lineCount ? lineCount : 0;
        var prevFrameSettings = { type: this.toPascalCase(this.frameObj.type), color: this.frameObj.color,
            gradientColor: this.frameObj.gradientColor, size: this.frameObj.size, inset: this.frameObj.inset,
            offset: this.frameObj.offset, borderRadius: this.frameObj.radius,
            frameLineStyle: this.toPascalCase(this.frameObj.border), lineCount: this.frameObj.amount };
        extend(this.tempFrameObj, this.frameObj);
        this.tempFrameZoomLevel = this.transform.zoomFactor;
        this.frameDestPoints = extend({}, this.img, {}, true);
        this.notify('toolbar', { prop: 'frameToolbarClick' });
        this.frameObj.type = frameType.toLowerCase();
        this.frameObj.color = color;
        this.frameObj.gradientColor = gradientColor;
        this.frameObj.size = size;
        this.frameObj.inset = inset;
        this.frameObj.offset = offset;
        this.frameObj.radius = borderRadius;
        this.frameObj.border = frameLineStyle.toLowerCase();
        this.frameObj.amount = lineCount;
        this.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
        if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
            if (JSON.stringify(this.frameObj) !== JSON.stringify(this.tempFrameObj)) {
                isFrame = true;
                this.okBtn();
            }
            else {
                this.tempFrameZoomLevel = null;
            }
        }
        else {
            this.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
            extend(this.frameObj, this.tempFrameObj);
            this.tempFrameZoomLevel = null;
        }
        this.notify('draw', { prop: 'redrawDownScale' });
        var ctxTbar = this.element.querySelector('.e-contextual-toolbar-wrapper');
        if (ctxTbar) {
            ctxTbar.classList.add('e-hide');
        }
        return isFrame;
    };
    /**
     * Straightens an image by rotating it clockwise or counterclockwise.
     *
     * @param {number} degree - The degree value specifying the amount of rotation for straightening the image.
     * Positive values indicate clockwise rotation, while negative values indicate counterclockwise rotation.
     *
     * @remarks
     * The degree value should be within the range of -45 to +45 degrees for accurate straightening.
     *
     * @returns {boolean} - A boolean value indicating the success of the straightening operation.
     */
    ImageEditor.prototype.straightenImage = function (degree) {
        var isStraightened = false;
        if (degree >= -45 && degree <= 45) {
            this.applyShapes();
            isStraightened = true;
            this.notify('transform', { prop: 'straightenImage', value: { degree: degree } });
            this.notify('draw', { prop: 'redrawDownScale' });
        }
        return isStraightened;
    };
    /**
     * Duplicates a shape based on the given shape ID in the ImageEditor.
     * Use 'getShapeSettings' method to get the shape and then pass a shapeId from the returned shape to clone a shape.
     *
     * @param {string} shapeId - Specifies the shape id to clone a shape on an image.
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.cloneShape = function (shapeId) {
        var obj = { isSelected: false };
        if (shapeId.split('_')[0] === 'shape') {
            this.notify('shape', { prop: 'selectShape', onPropertyChange: false, value: { id: shapeId, obj: obj } });
            if (obj['isSelected']) {
                this.notify('toolbar', { prop: 'duplicateShape', onPropertyChange: false, value: { isPreventUndoRedo: false } });
                this.okBtn(null, true);
                this.notify('draw', { prop: 'redrawDownScale' });
            }
        }
        return obj['isSelected'];
    };
    /**
     * Update filter to the canvas in the ImageEditor.
     *
     * @param {ImageFilterOption } filterOption - Specifies the filter options to the image.
     *
     * @returns {string}.
     *
     */
    ImageEditor.prototype.getImageFilter = function (filterOption) {
        var canvas = this.createElement('canvas');
        var ctx = canvas.getContext('2d');
        this.notify('filter', { prop: 'updateAdj', value: { type: filterOption.toLowerCase(), value: null, isPreview: true, ctx: ctx } });
        return ctx.filter;
    };
    /**
     * Enable text area editing in the ImageEditor.
     *
     * @returns {void}.
     *
     */
    ImageEditor.prototype.enableTextEditing = function () {
        var activeObj = extend({}, this.activeObj, {}, true);
        if (!activeObj.order) {
            this.noPushUndo = true;
            this.okBtn();
            this.noPushUndo = false;
            this.noRedact = true;
            this.selectShape(activeObj.currIndex);
            activeObj.order = this.activeObj.order;
        }
        this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: false } });
        this.activeObj = activeObj;
        this.notify('toolbar', { prop: 'editText', onPropertyChange: false });
    };
    /**
     * Specifies if it's possible to undo the last recent action made in an Image Editor.
     *
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.canUndo = function () {
        var canUndo = false;
        var object = this.getUndoRedoColl();
        var undoRedoIndex = object['index'];
        if (undoRedoIndex > 0) {
            canUndo = true;
        }
        return canUndo;
    };
    /**
     * Specifies if it's possible to redo the last recent action made in an Image Editor.
     *
     * @returns {boolean}.
     *
     */
    ImageEditor.prototype.canRedo = function () {
        var canRedo = false;
        var object = this.getUndoRedoColl();
        var undoRedoColl = object['undoRedoColl'];
        var undoRedoIndex = object['index'];
        if (undoRedoColl && undoRedoColl.length > 0 && undoRedoIndex < undoRedoColl.length - 1) {
            canRedo = true;
        }
        if (undoRedoIndex === undoRedoColl.length) {
            canRedo = false;
        }
        else if (undoRedoIndex === 0 && undoRedoColl.length > 0) {
            canRedo = true;
        }
        else if (undoRedoIndex > 0) {
            canRedo = true;
        }
        return canRedo;
    };
    /**
     * Applies the operations performed in the Image Editor, such as annotation drawings.
     *
     * @returns{void}
     * @remarks
     * This method applies the actions performed after enabling annotation drawings, ensuring that the drawn annotations are applied to the image.
     */
    ImageEditor.prototype.apply = function () {
        if (this.isMaskImage) {
            this.discard();
        }
        else {
            this.updateColl('reset');
            this.closeOverlayTbar();
            this.okBtn(null, true);
        }
    };
    /**
     * Discards the operations performed in the Image Editor, such as annotation drawings.
     *
     * @returns{void}
     * @remarks
     * This method discards the actions performed after enabling annotation drawings, ensuring that the drawn annotations are not applied to the image.
     */
    ImageEditor.prototype.discard = function () {
        this.updateColl('reset');
        this.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: this.closeOverlayTbar(), isFinalCancel: true } });
    };
    /**
     * Enable or disable a shape drawing option in an Image Editor.
     *
     * @param {ShapeType} shapeType - Specifies the type of shape to be enabled or disabled for drawing.
     * @param {boolean} isEnabled - Optional. Specifies a value to indicate whether to enable or disable shape drawing. The default value is true.
     *
     * @remarks This function allows the user to toggle the shape drawing feature in the Image Editor. When enabled, users can draw shapes on the image. When disabled, the shape drawing functionality is not available.
     *
     * @returns {void}.
     */
    ImageEditor.prototype.enableShapeDrawing = function (shapeType, isEnabled) {
        this.manageActiveAction();
        if (isEnabled) {
            this.drawingShape = shapeType.toLowerCase();
            this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        }
        if (shapeType && isEnabled) {
            this.currObjType.shape = shapeType.toLowerCase();
            this.activeObj.shape = this.currObjType.shape;
            this.currObjType.isDragging = this.currObjType.isCustomCrop = false;
            this.activeObj.shapeDegree = this.transform.degree;
            this.activeObj.shapeFlip = this.transform.currFlipState;
            this.activeObj.textFlip = this.transform.currFlipState;
            this.activeObj.flipObjColl = [];
            var orderObj = { order: null };
            this.notify('shape', { prop: 'getNewOrder', onPropertyChange: false, value: { obj: orderObj } });
            this.activeObj.order = orderObj['order'];
            this.notify('selection', { prop: 'annotate', value: { shape: this.currObjType.shape } });
            if (this.currObjType.shape === 'text') {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            }
            else if (this.currObjType.shape === 'redact') {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            }
            else {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            }
            this.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
        }
        else if (!isEnabled) {
            this.okBtn(null, true);
        }
    };
    /**
     * Moves a shape to the front of all other shapes based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform moving.
     *
     * @param {string} shapeId - Specifies the shape id to move the shape on an image.
     * @returns {void}.
     *
     */
    ImageEditor.prototype.bringToFront = function (shapeId) {
        this.noRedact = true;
        if (this.selectShape(shapeId)) {
            this.updateShapeOrder(shapeId, 'bringToFront');
            this.apply();
        }
    };
    /**
     * Moves a shape to ahead of one shape based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform moving.
     *
     * @param {string} shapeId - Specifies the shape id to move the shape on an image.
     * @returns {void}.
     *
     */
    ImageEditor.prototype.bringForward = function (shapeId) {
        this.noRedact = true;
        if (this.selectShape(shapeId)) {
            this.updateShapeOrder(shapeId, 'bringForward');
            this.apply();
        }
    };
    /**
     * Moves a shape to behind all other shapes based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform moving.
     *
     * @param {string} shapeId - Specifies the shape id to move the shape on an image.
     * @returns {void}.
     *
     */
    ImageEditor.prototype.sendToBack = function (shapeId) {
        this.noRedact = true;
        if (this.selectShape(shapeId)) {
            this.updateShapeOrder(shapeId, 'sendToBack');
            this.apply();
        }
    };
    /**
     * Moves a shape to behind one shape based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform moving.
     *
     * @param {string} shapeId - Specifies the shape id to move the shape on an image.
     * @returns {void}.
     *
     */
    ImageEditor.prototype.sendBackward = function (shapeId) {
        this.noRedact = true;
        if (this.selectShape(shapeId)) {
            this.updateShapeOrder(shapeId, 'sendBackward');
            this.apply();
        }
    };
    /**
     * Clears the loaded image in the Image Editor.
     *
     * @returns{void}
     * @remarks
     * This method clears the loaded image and updates the component's user interface to its initial state (the initial user interface without a loaded image).
     */
    ImageEditor.prototype.clearImage = function () {
        this.reset();
        this.isImageLoaded = false;
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        var btoolbar = document.getElementById(this.element.id + '_bottomToolbar');
        if (Browser.isDevice && btoolbar) {
            document.getElementById(this.element.id + '_bottomToolbar').style.display = 'none';
        }
        this.notify('toolbar', { prop: 'destroy-top-toolbar', onPropertyChange: false });
        this.notify('toolbar', { prop: 'create-toolbar', onPropertyChange: false });
        this.notify('toolbar', { prop: 'create-contextual-toolbar', onPropertyChange: false });
        var dropArea = document.getElementById(this.element.id + '_dropArea');
        if (dropArea) {
            dropArea.style.display = 'block';
        }
    };
    // AI related codes
    /**
     * Enables overlay drawing to erase objects in an image editor. The eraser tool assists in selecting the mask image.
     *
     * @remarks
     * The selection UI is based on the 'theme' property.
     *
     * @param {number} strokeWidth - Specifies the stroke width of the drawing.
     * @param {string} color - Specifies the color of the drawing.
     * @hidden
     * @returns {void}.
     *
     */
    ImageEditor.prototype.selectMaskImage = function (strokeWidth, color) {
        strokeWidth = strokeWidth ? strokeWidth : 10;
        color = color ? color : '#512da880';
        this.applyShapes();
        this.isMaskImage = true;
        this.updateColl('empty');
        this.enableDisableToolbar(true);
        this.update();
        this.activeObj.strokeSettings.strokeWidth = strokeWidth;
        this.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: strokeWidth } });
        this.activeObj.strokeSettings.strokeColor = color;
        this.notify('freehand-draw', { prop: 'freeHandDraw', onPropertyChange: false, value: { value: true } });
        this.maskCanvas.style.display = 'block';
    };
    ImageEditor.prototype.enableDisableToolbar = function (value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var toolbar;
        var elem = document.getElementById(this.element.id + '_toolbar');
        if (elem) {
            toolbar = getComponent(elem, 'toolbar');
            if (toolbar) {
                toolbar.disable(value);
            }
        }
        elem = document.getElementById(this.element.id + '_bottomToolbar');
        if (elem) {
            toolbar = getComponent(elem, 'toolbar');
            if (toolbar) {
                toolbar.disable(value);
            }
        }
    };
    ImageEditor.prototype.updateImage = function (data, imageBackgroundColor) {
        var _this = this;
        if (data || imageBackgroundColor || imageBackgroundColor === '') {
            var prevCropObj_1 = extend({}, this.cropObj, {}, true);
            var object = { currObj: {} };
            this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var prevObj_1 = object['currObj'];
            prevObj_1.objColl = extend([], this.objColl, [], true);
            prevObj_1.pointColl = extend([], this.pointColl, [], true);
            prevObj_1.afterCropActions = extend([], this.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });
            prevObj_1.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            if (data) {
                this.isImageUpdated = true;
                if (typeof (data) !== 'string') {
                    var canvas = this.createElement('canvas');
                    canvas.width = data.width;
                    canvas.height = data.height;
                    canvas.getContext('2d').putImageData(data, 0, 0);
                    data = canvas.toDataURL();
                }
                this.baseImg.src = data;
                setTimeout(function () {
                    if (_this.cropObj.straighten !== 0) {
                        _this.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: 'crop-' + 'custom' } });
                        _this.noPushUndo = true;
                        _this.crop();
                        _this.noPushUndo = false;
                    }
                    else {
                        _this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
                    }
                    _this.isImageUpdated = false;
                    if (!imageBackgroundColor) {
                        _this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: { operation: 'updateImage', previousObj: prevObj_1,
                                previousObjColl: prevObj_1.objColl, previousPointColl: prevObj_1.pointColl,
                                previousSelPointColl: prevObj_1.selPointColl, previousCropObj: prevCropObj_1,
                                previousText: null, currentText: null, previousFilter: null, isCircleCrop: null
                            } });
                        _this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                    }
                }, 100);
            }
            if (imageBackgroundColor || imageBackgroundColor === '') {
                this.notify('draw', { prop: 'imageBackgroundColor', onPropertyChange: false, value: { color: imageBackgroundColor } });
                this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
                if (!data) {
                    this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: { operation: 'bgColor', previousObj: prevObj_1,
                            previousObjColl: prevObj_1.objColl, previousPointColl: prevObj_1.pointColl, previousSelPointColl: prevObj_1.selPointColl,
                            previousCropObj: prevCropObj_1, previousText: null, currentText: null, previousFilter: null, isCircleCrop: null
                        } });
                    this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
            }
            if (data && imageBackgroundColor) {
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: { operation: 'updateImage', previousObj: prevObj_1,
                        previousObjColl: prevObj_1.objColl, previousPointColl: prevObj_1.pointColl, previousSelPointColl: prevObj_1.selPointColl,
                        previousCropObj: prevCropObj_1, previousText: null, currentText: null, previousFilter: null, isCircleCrop: null
                    } });
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
        }
    };
    ImageEditor.prototype.editCompleted = function (type) {
        this.notify('draw', { prop: 'redrawDownScale' });
        var actionArgs = { action: type ? type : 'shape-insert',
            actionEventArgs: this.editCompleteArgs };
        this.triggerEditCompleteEvent(actionArgs);
    };
    ImageEditor.prototype.updateColl = function (type) {
        if (!this.isMaskImage) {
            return;
        }
        if (type === 'empty') {
            this.tempToolbarHeight = this.toolbarHeight;
            this.tempToolbar = this.toolbar ? extend([], this.toolbar, [], true) : null;
            this.tempObjColl = extend([], this.objColl, [], true);
            this.tempPointColl = extend([], this.pointColl, [], true);
            this.tempShapeColl = extend([], this.shapeColl, [], true);
            this.objColl = [];
            this.pointColl = [];
            this.shapeColl = [];
            this.freehandCounter = 0;
            this.notify('freehand-draw', { prop: 'setCurrentFreehandDrawIndex',
                value: { value: 0 } });
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
        }
        else if (type === 'reset') {
            this.objColl = this.tempObjColl;
            this.pointColl = this.tempPointColl;
            this.shapeColl = this.tempShapeColl;
            this.freehandCounter = this.pointColl.length;
            this.notify('freehand-draw', { prop: 'setCurrentFreehandDrawIndex',
                value: { value: this.freehandCounter } });
            this.enableDisableToolbar(false);
            if (this.cropObj.straighten !== 0) {
                this.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: 'crop-' + 'custom' } });
                this.noPushUndo = true;
                this.crop();
                this.noPushUndo = false;
            }
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
            this.isMaskImage = false;
            this.upperContext.globalCompositeOperation = 'source-over';
            this.maskCanvas.style.display = 'none';
            this.activeObj.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null,
                radius: null, outlineColor: '', outlineWidth: null };
            this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: this.activeObj.strokeSettings,
                    strokeColor: '#fff', fillColor: '', strokeWidth: null, outlineWidth: null } });
            this.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: 2 } });
            this.notify('freehand-draw', { prop: 'setMasking', onPropertyChange: false, value: { value: false } });
        }
    };
    // Toolbar related codes
    ImageEditor.prototype.resetToolbar = function () {
        if (this.toolbarHeight !== this.tempToolbarHeight && !((isNullOrUndefined(this.toolbar) ||
            (this.toolbar && this.toolbar.length > 0)
            || !isNullOrUndefined(this.toolbarTemplate)))) {
            this.toolbarHeight = this.tempToolbarHeight;
            this.notify('toolbar', { prop: 'setToolbarHeight', value: { height: this.toolbarHeight } });
            this.toolbar = this.tempToolbar;
            if (!this.toolbarTemplate) {
                this.notify('toolbar', { prop: 'create-toolbar', onPropertyChange: false });
                this.notify('toolbar', { prop: 'create-contextual-toolbar', onPropertyChange: false });
            }
            this.update();
        }
    };
    ImageEditor.prototype.getData = function (isMaskImage) {
        if (isMaskImage) {
            this.resetToolbar();
        }
        var objColl = extend([], this.objColl, null, true);
        var pointColl = extend([], this.pointColl, null, true);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var shapeColl = extend([], this.shapeColl, null, true);
        if (isMaskImage) {
            this.notify('shape', { prop: 'updateShapeColl', onPropertyChange: false });
            for (var i = 0; i < this.freehandCounter; i++) {
                this.pointColl[i].strokeColor = '#fff';
            }
        }
        else {
            this.objColl = [];
            this.pointColl = [];
            this.shapeColl = [];
            this.freehandCounter = 0;
        }
        var frameType = this.frameObj.type;
        this.frameObj.type = 'none';
        var aspectWidth = this.aspectWidth;
        var aspectHeight = this.aspectHeight;
        this.aspectWidth = this.aspectHeight = null;
        var straighten = this.cropObj.straighten;
        this.togglePen = false;
        this.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: 'crop-' + 'custom' } });
        var tempDestPoints = extend({}, this.img, {}, true);
        var tempCropObj = extend({}, this.cropObj, {}, true);
        var tempSel = extend({}, this.activeObj, {}, true);
        var tempTransform = extend({}, this.transform, {}, true);
        var panPoint = extend({}, this.panPoint, {}, true);
        if (straighten !== 0) {
            this.setStraighten(0);
        }
        var point = this.activeObj.activePoint;
        point.startX = this.img.destLeft;
        point.startY = this.img.destTop;
        point.width = this.img.destWidth;
        point.height = this.img.destHeight;
        point.endX = point.startX + point.width;
        point.endY = point.startY + point.height;
        this.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: point, obj: this.activeObj,
                isMouseMove: null, x: null, y: null } });
        this.noPushUndo = true;
        this.crop();
        this.noPushUndo = false;
        this.isCropTab = false;
        this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.notify('crop', { prop: 'resetZoom', onPropertyChange: false });
        this.isCropTab = true;
        var afterCropActions = extend([], this.afterCropActions, [], true);
        var coll = extend([], this.rotateFlipColl, [], true);
        this.notify('crop', { prop: 'revertTransform', value: { type: 'initial', coll: coll } });
        var imageData = this.getImageData();
        if (isMaskImage) {
            var canvas = this.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (this.pointColl.length > 0) {
                var obj = { width: 0, height: 0 };
                this.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
                    value: { obj: obj, dimension: { width: canvas.width, height: canvas.height } } });
                var ratio = obj;
                this.notify('export', { prop: 'drawAnnotation', value: { context: ctx, ratio: ratio } });
            }
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
        this.notify('crop', { prop: 'revertTransform', value: { type: 'reverse', coll: coll } });
        this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.afterCropActions = afterCropActions;
        if (!isMaskImage) {
            this.objColl = objColl;
            this.pointColl = pointColl;
            this.shapeColl = shapeColl;
            this.freehandCounter = this.pointColl.length;
        }
        this.frameObj.type = frameType;
        this.aspectWidth = aspectWidth;
        this.aspectHeight = aspectHeight;
        this.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: 'crop-' + 'custom' } });
        if (straighten !== 0) {
            this.setStraighten(straighten);
        }
        this.img = tempDestPoints;
        this.cropObj = tempCropObj;
        this.activeObj = tempSel;
        this.transform = tempTransform;
        this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
            value: { zoomFactor: 0.1, zoomPoint: null, isResize: null } });
        this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
            value: { zoomFactor: -0.1, zoomPoint: null, isResize: null } });
        if (this.transform.degree !== 0) {
            this.panPoint.currentPannedPoint = { x: panPoint.totalPannedClientPoint.x,
                y: panPoint.totalPannedClientPoint.y };
            this.notify('transform', { prop: 'drawPannedImage', value: { xDiff: panPoint.totalPannedClientPoint.x,
                    yDiff: panPoint.totalPannedClientPoint.y } });
            this.panPoint.currentPannedPoint = { x: 0, y: 0 };
            this.notify('transform', { prop: 'setTempPanMove', value: { point: null } });
        }
        this.noPushUndo = true;
        this.crop();
        this.noPushUndo = false;
        this.transform.straighten = 0;
        this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
        return imageData;
    };
    ImageEditor.prototype.applyShapes = function () {
        if (this.isUndoRedoStack) {
            return;
        }
        var shapes = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'text', 'image'];
        var dummyObj = { bool: false };
        this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: dummyObj } });
        if (dummyObj['bool'] || this.togglePen || (this.activeObj.shape && shapes.indexOf(this.activeObj.shape) !== -1) ||
            this.drawingShape) {
            this.okBtn(null, true);
        }
    };
    ImageEditor.prototype.closeOverlayTbar = function () {
        var isContextualToolbar = false;
        var frameObject = { bool: null };
        this.notify('toolbar', { prop: 'getFrameToolbar', onPropertyChange: false, value: { obj: frameObject } });
        if (!frameObject['bool'] && this.element.querySelector('.e-contextual-toolbar-wrapper')) {
            if (!this.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {
                isContextualToolbar = true;
            }
            var straightenObj = { bool: this.isStraightening };
            if (!Browser.isDevice || (Browser.isDevice && !straightenObj['bool'])) {
                this.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
            }
        }
        return isContextualToolbar;
    };
    ImageEditor.prototype.toolbarTemplateFn = function () {
        var template;
        var templateID = this.element.id + '_toolbar';
        var toolbarArea = this.element.querySelector('#' + this.element.id + '_toolbarArea');
        if (this.toolbarTemplate) {
            this.toolbarFn = this.templateParser(this.toolbarTemplate);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this.isReact) {
                template = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            else if (this.isAngular) {
                var templateColl = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID);
                template = (templateColl[0].nodeType === 3) ? templateColl[1] : templateColl[0];
            }
            else {
                template = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
            }
            toolbarArea.appendChild(template);
            this.toolbarHeight = toolbarArea.clientHeight;
            this.notify('toolbar', { prop: 'setToolbarHeight', value: { height: this.toolbarHeight } });
            this['renderReactTemplates']();
        }
    };
    ImageEditor.prototype.quickAccessToolbarTemplateFn = function () {
        var template;
        var templateID = this.element.id + '_quickAccessToolbar';
        var toolbarArea = this.element.querySelector('#' + this.element.id + '_quickAccessToolbarArea');
        if (this.quickAccessToolbarTemplate) {
            this.qatFn = this.templateParser(this.quickAccessToolbarTemplate);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this.isReact) {
                template = this.qatFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            else if (this.isAngular) {
                var templateColl = this.qatFn({ type: 'toolbar' }, this, 'Template', templateID);
                template = (templateColl[0].nodeType === 3) ? templateColl[1] : templateColl[0];
            }
            else {
                template = this.qatFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
            }
            toolbarArea.appendChild(template);
            this['renderReactTemplates']();
        }
    };
    ImageEditor.prototype.templateParser = function (template) {
        if (template) {
            try {
                if (typeof template !== 'function' && document.querySelectorAll(template).length) {
                    return compile(document.querySelector(template).innerHTML.trim());
                }
                else {
                    return compile(template);
                }
            }
            catch (error) {
                return compile(template);
            }
        }
        return undefined;
    };
    // Common codes for EJ2 and Blazor
    ImageEditor.prototype.getTextFromId = function (id) {
        var idToValue = { '1': 'none', '2': 'bar', '3': 'arrow', '4': 'arrowSolid',
            '5': 'circle', '6': 'circleSolid', '7': 'square', '8': 'squareSolid' };
        return idToValue["" + id];
    };
    ImageEditor.prototype.getFinetuneOption = function (type) {
        var typeToOption = { 'brightness': ImageFinetuneOption.Brightness, 'contrast': ImageFinetuneOption.Contrast,
            'hue': ImageFinetuneOption.Hue, 'saturation': ImageFinetuneOption.Saturation, 'opacity': ImageFinetuneOption.Opacity,
            'blur': ImageFinetuneOption.Blur, 'exposure': ImageFinetuneOption.Exposure };
        return typeToOption["" + type];
    };
    ImageEditor.prototype.setPenStroke = function (args) {
        this.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: parseInt(args, 10) } });
    };
    ImageEditor.prototype.updateFreehandDrawColorChange = function () {
        var obj = { tempFreeHandDrawEditingStyles: null };
        this.notify('freehand-draw', { prop: 'getTempFreeHandDrawEditingStyles', value: { obj: obj } });
        this.notify('freehand-draw', { prop: 'color-change', value: { color: obj['tempFreeHandDrawEditingStyles'].strokeColor } });
    };
    ImageEditor.prototype.getUndoRedoColl = function () {
        var obj = { undoRedoColl: null, index: null };
        var undoRedoObj = { undoRedoStep: null };
        var object = { appliedUndoRedoColl: [] };
        this.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: object } });
        this.notify('undo-redo', { prop: 'getUndoRedoStep', value: { obj: undoRedoObj } });
        obj['undoRedoColl'] = object['appliedUndoRedoColl'];
        obj['index'] = undoRedoObj['undoRedoStep'];
        return obj;
    };
    ImageEditor.prototype.updateImageTransformColl = function (type) {
        var value;
        if (type === 'rotateleft') {
            value = -90;
        }
        else if (type === 'rotateright') {
            value = 90;
        }
        else if (type === 'horizontalflip') {
            value = 'horizontal';
        }
        else if (type === 'verticalflip') {
            value = 'vertical';
        }
        for (var i = 0; i < this.objColl.length; i++) {
            var shape = this.objColl[i].shape;
            if (shape === 'image' || shape === 'text') {
                if (isNullOrUndefined(this.objColl[i].rotateFlipColl)) {
                    this.objColl[i].rotateFlipColl = [];
                }
                this.objColl[i].rotateFlipColl.push(value);
                var obj = { collection: this.objColl[i].rotateFlipColl };
                this.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
                    value: { collection: this.objColl[i].rotateFlipColl, isRotateFlipCollection: false, obj: obj } });
                this.objColl[i].rotateFlipColl = obj['collection'];
            }
        }
    };
    ImageEditor.prototype.setInitialZoomState = function () {
        this.objColl.push(this.activeObj);
        this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        var isUndoRedo = this.isUndoRedo;
        this.isCropTab = false;
        this.isUndoRedo = true;
        if (this.transform.cropZoomFactor && this.transform.cropZoomFactor > 0) {
            this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: -this.transform.cropZoomFactor, zoomPoint: null, isResize: true } });
        }
        else {
            this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: Math.abs(this.transform.cropZoomFactor), zoomPoint: null, isResize: true } });
        }
        this.isUndoRedo = isUndoRedo;
        this.panPoint.totalPannedPoint = { x: 0, y: 0 };
        this.transform.cropZoomFactor = 0;
        this.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
        this.activeObj = extend({}, this.objColl[this.objColl.length - 1], {}, true);
        this.objColl.pop();
        this.isCropTab = true;
        this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: this.activeObj } });
    };
    /**
     * Set the old item Transform item state.
     *
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateCropTransformItems = function () {
        this.prevCurrSelectionPoint = extend({}, this.currSelectionPoint, {}, true);
        this.notify('draw', { prop: 'updateCropSelection', onPropertyChange: false });
    };
    /**
     * Get the pascal case.
     *
     * @param { string } str - Specifies the string to convert to pascal case.
     * @param { Object } obj - Specifies the string to convert to pascal case.
     * @hidden
     * @returns {string}.
     * A pascal case string.
     */
    ImageEditor.prototype.toPascalCase = function (str, obj) {
        var strArr = [];
        if (!isNullOrUndefined(str)) {
            strArr = str.toLowerCase().split('-');
        }
        for (var i = 0; i < strArr.length; i++) {
            strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].slice(1);
        }
        if (obj) {
            obj['maxText'] = strArr.join('');
        }
        return strArr.join('');
    };
    /**
     * Get the font sizes.
     *
     * @hidden
     * @returns {DropDownButtonItemModel[]}.
     * A font size collections.
     */
    ImageEditor.prototype.getFontSizes = function () {
        var items = [];
        this.fontSizeColl = [];
        var fontSize;
        if (this.transform.degree === 0 || this.transform.degree % 180 === 0) {
            fontSize = this.img.destWidth / 25;
        }
        else {
            fontSize = this.img.destHeight / 25;
        }
        for (var i = 1; i <= 10; i++) {
            this.fontSizeColl.push({ text: (i * (Math.round(fontSize / 2))).toString() });
            items.push({ text: (i.toString()) });
        }
        return items;
    };
    /**
     * Updates drop area content dynamically.
     *
     * @param { HTMLElement } dropInfoElement - Specifies the drop area element.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateDropInfoContent = function (dropInfoElement) {
        if (!dropInfoElement) {
            return;
        }
        var supportObj = { key: 'SupportText' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: supportObj } });
        var words = this.getExtensionString();
        var fileSizeObj = { key: 'MinMaxSize' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: fileSizeObj } });
        var andObj = { key: 'And' };
        this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: andObj } });
        var size;
        if (this.uploadSettings.minFileSize && this.uploadSettings.maxFileSize) {
            size = ' ' + fileSizeObj['value'] + ' ' + this.formatSizeUnits(this.uploadSettings.minFileSize) + ' ' + andObj['value'] + ' ' + this.formatSizeUnits(this.uploadSettings.maxFileSize);
        }
        else if (this.uploadSettings.minFileSize) {
            fileSizeObj['key'] = 'MinSize';
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: fileSizeObj } });
            size = ' ' + fileSizeObj['value'] + ' ' + this.formatSizeUnits(this.uploadSettings.minFileSize);
        }
        else if (this.uploadSettings.maxFileSize) {
            fileSizeObj['key'] = 'MaxSize';
            this.notify('toolbar', { prop: 'getLocaleText', onPropertyChange: false, value: { obj: fileSizeObj } });
            size = ' ' + fileSizeObj['value'] + ' ' + this.formatSizeUnits(this.uploadSettings.maxFileSize);
        }
        if (size) {
            dropInfoElement.textContent = supportObj['value'] + words + size;
        }
        else {
            dropInfoElement.textContent = supportObj['value'] + words;
        }
    };
    /**
     * Handles the OK button operation
     *
     * @param { boolean } isMouseDown - Specifies whether it is a mouse down.
     * @param { boolean } isFinalApply - Specifies whether it is a final apply.
     * @param { boolean } isResize - Specifies whether it is called from resize public method.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.okBtn = function (isMouseDown, isFinalApply, isResize) {
        if (isFinalApply) {
            this.noPushUndo = false;
            var tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
                flipObjColl: [], triangle: [], triangleRatio: [], order: null };
            this.notify('selection', { prop: 'setTempActObj', onPropertyChange: false, value: { obj: tempActiveObj } });
        }
        var ctWrapper = this.element.querySelector('.e-contextual-toolbar-wrapper');
        if (ctWrapper) {
            ctWrapper.classList.remove('e-frame-wrapper');
        }
        var isCropSelection = false;
        var splitWords;
        this.isResizeOkBtn = true;
        var aspectIcon = this.element.querySelector('#' + this.element.id + '_aspectratio');
        var nonAspectIcon = this.element.querySelector('#' + this.element.id + '_nonaspectratio');
        var blrAspRatElem = this.element.querySelector('.e-ie-toolbar-aspect-ratio-btn');
        var blrNAspRatElem = this.element.querySelector('.e-ie-toolbar-nonaspect-ratio-btn');
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (splitWords === undefined && this.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        this.allowDownScale = true;
        if ((this.activeObj.shape && this.activeObj.shape !== 'image' || this.togglePen) && !isCropSelection) {
            var objt = { shapeSettingsObj: {} };
            this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
            var shapeSettings = objt['shapeSettingsObj'];
            if (this.togglePen) {
                shapeSettings.type = ShapeType.FreehandDraw;
            }
            var shapeChangedArgs = { action: 'apply', currentShapeSettings: extend({}, shapeSettings, {}, true) };
            if (!this.currObjType.isRedact && (isFinalApply || this.isShapeDrawing)) {
                if (this.isShapeDrawing) {
                    shapeChangedArgs.action = 'draw-end';
                }
                this.trigger('shapeChange', shapeChangedArgs);
            }
            this.editCompleteArgs = shapeChangedArgs;
            if (this.currObjType.isRedact) {
                this.currObjType.isRedact = false;
            }
        }
        if (aspectIcon || nonAspectIcon) {
            var obj_2 = { width: null, height: null };
            this.notify('selection', { prop: 'getNumTextValue', onPropertyChange: false, value: { obj: obj_2 } });
            var point = { x: obj_2['width'], y: obj_2['height'] };
            var obj1 = { prevCropObj: this.prevCropObj };
            var obj2 = { prevObj: this.prevObj };
            if (point && point.x && point.y && obj1['prevCropObj'] && obj2['prevObj']) {
                if (nonAspectIcon || (blrNAspRatElem && !blrNAspRatElem.classList.contains('e-hidden'))) {
                    this.notify('transform', { prop: 'resize', value: { width: point.x, height: point.y, isAspectRatio: false } });
                }
                else if (aspectIcon || (blrAspRatElem && !blrAspRatElem.classList.contains('e-hidden'))) {
                    this.notify('transform', { prop: 'resize', value: { width: point.x, height: null, isAspectRatio: true } });
                }
                this.isResize = false;
                this.aspectWidth = point.x;
                this.aspectHeight = point.y;
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                        isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });
                this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: -this.transform.zoomFactor, zoomPoint: null, isResize: true } });
                this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: obj2['prevObj']['defaultZoom'], zoomPoint: null, isResize: true } });
                if (obj2['prevObj'].zoomFactor) {
                    this.setProperties({ zoomSettings: { zoomFactor: obj2['prevObj'].zoomFactor } }, true);
                }
                this.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
                    value: { previousZoomValue: this.zoomSettings.zoomFactor } });
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: { operation: 'resize',
                        previousObj: obj2['prevObj'], previousObjColl: obj2['prevObj']['objColl'],
                        previousPointColl: obj2['prevObj']['pointColl'], previousSelPointColl: obj2['prevObj']['selPointColl'],
                        previousCropObj: obj1['prevCropObj'], previousText: null, currentText: null, previousFilter: null,
                        isCircleCrop: null } });
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                var obj_3 = this.cancelCropSelection;
                if ((obj_3 && (isNullOrUndefined(nonAspectIcon) || !nonAspectIcon))) {
                    obj_3.previousObj.aspectWidth = obj_3.currentObj.aspectWidth = this.aspectWidth;
                    obj_3.previousObj.aspectHeight = obj_3.currentObj.aspectHeight = this.aspectHeight;
                    obj_3.previousCropObj = extend({}, this.cropObj, {}, true);
                    obj_3.currentCropObj = extend({}, this.cropObj, {}, true);
                    this.notify('draw', { prop: 'updateCropSelObj' });
                }
                this.cancelCropSelection = null;
            }
            else if (point && (point.x === 0 || point.y === 0)) {
                this.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
            }
            else {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                        isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });
            }
            this.isAspectRatio = false;
        }
        else if (isResize) {
            var isAspectRatio = false;
            if (this.aspectWidth && this.aspectHeight) {
                this.notify('transform', { prop: 'resize', value: { width: this.aspectWidth, height: this.aspectHeight, isAspectRatio: false } });
            }
            else if (this.aspectWidth) {
                this.notify('transform', { prop: 'resize', value: { width: this.aspectWidth, height: null, isAspectRatio: true } });
                this.aspectHeight = this.aspectWidth / (this.img.destWidth / this.img.destHeight);
                isAspectRatio = true;
            }
            this.isResize = false;
            this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                    isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });
            this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: -this.transform.zoomFactor, zoomPoint: null, isResize: true } });
            this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: this.prevObj['defaultZoom'], zoomPoint: null, isResize: true } });
            if (this.prevObj.zoomFactor) {
                this.setProperties({ zoomSettings: { zoomFactor: this.prevObj.zoomFactor } }, true);
            }
            this.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
                value: { previousZoomValue: this.zoomSettings.zoomFactor } });
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: { operation: 'resize',
                    previousObj: this.prevObj, previousObjColl: this.prevObj['objColl'],
                    previousPointColl: this.prevObj['pointColl'], previousSelPointColl: this.prevObj['selPointColl'],
                    previousCropObj: this.prevCropObj, previousText: null, currentText: null, previousFilter: null,
                    isCircleCrop: null } });
            this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            var obj_4 = this.cancelCropSelection;
            if ((obj_4 && isAspectRatio)) {
                obj_4.previousObj.aspectWidth = obj_4.currentObj.aspectWidth = this.aspectWidth;
                obj_4.previousObj.aspectHeight = obj_4.currentObj.aspectHeight = this.aspectHeight;
                obj_4.previousCropObj = extend({}, this.cropObj, {}, true);
                obj_4.currentCropObj = extend({}, this.cropObj, {}, true);
                this.notify('draw', { prop: 'updateCropSelObj' });
            }
            this.cancelCropSelection = null;
            this.isAspectRatio = false;
        }
        var selElem = this.element.querySelector('.e-contextual-toolbar-wrapper .e-toolbar-item.e-selected');
        var obj = { bool: false };
        this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        var frameObject = { bool: null };
        this.notify('toolbar', { prop: 'getFrameToolbar', onPropertyChange: false, value: { obj: frameObject } });
        var sliderWrap = document.querySelector('#' + this.element.id + '_sliderWrapper');
        if (selElem) {
            this.currentFilter = selElem.children[0].children[0].id.replace('Canvas', '');
        }
        if (isCropSelection) {
            if (this.transform.straighten !== 0 && (this.panPoint.totalPannedPoint.x !== 0 || this.panPoint.totalPannedPoint.y !== 0 ||
                this.panPoint.totalPannedClientPoint.x !== 0 || this.panPoint.totalPannedClientPoint.y !== 0)) {
                var temp = this.prevStraightenedDegree;
                this.prevStraightenedDegree = this.transform.straighten;
                this.setStraighten(this.transform.straighten - 3);
                this.setStraighten(this.transform.straighten + 3);
                this.prevStraightenedDegree = temp;
            }
            this.isCroppedEvent = this.crop();
        }
        else if (this.togglePen) {
            this.freeHandDraw(false);
            if (!this.isMaskImage) {
                var widthObj = { penStrokeWidth: null };
                this.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: widthObj } });
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                this.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: widthObj['penStrokeWidth'] } });
            }
            this.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            this.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        }
        else if (this.textArea.style.display === 'block' || this.textArea.style.display === 'inline-block') {
            this.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
            if (isNullOrUndefined(isMouseDown)) {
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
            this.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            this.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        }
        else if ((sliderWrap || this.currObjType.isFiltered) && !this.drawingShape && this.activeObj.shape !== 'redact') {
            this.initialAdjustmentValue = this.canvasFilter = this.lowerContext.filter;
            this.currObjType.isFiltered = false;
            var obj_5 = { value: null };
            this.notify('draw', { prop: 'getTempAdjustmentValue', value: { obj: obj_5 } });
            if (!sliderWrap || sliderWrap.parentElement.previousElementSibling.textContent !== 'Opacity') {
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
            if ((this.activeObj.activePoint.width !== 0 && this.activeObj.activePoint.height !== 0) ||
                (this.activeObj.shape === 'path' && this.activeObj.pointColl.length > 0)) {
                this.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
            }
        }
        else if (obj['bool']) {
            this.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
            this.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: false } });
            this.notify('toolbar', { prop: 'destroy-qa-toolbar' });
            this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            this.notify('freehand-draw', { prop: 'resetFreehandDrawSelectedId', onPropertyChange: false });
        }
        else if ((this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) ||
            (this.activeObj.shape === 'path' && this.activeObj.pointColl.length > 0)) {
            if (this.activeObj.shape === 'image') {
                this.notify('draw', { prop: 'setImageApply', onPropertyChange: false, value: { bool: true } });
            }
            this.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
        }
        else {
            if (JSON.stringify(this.frameObj) !== JSON.stringify(this.tempFrameObj)) {
                var object = { currObj: {} };
                this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                        operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                        previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                        previousCropObj: extend({}, this.cropObj, {}, true), previousText: null, currentText: null,
                        previousFilter: null, isCircleCrop: null
                    } });
                this.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                var currFrameSettings = { type: this.toPascalCase(this.frameObj.type),
                    color: this.frameObj.color, gradientColor: this.frameObj.gradientColor, size: this.frameObj.size,
                    inset: this.frameObj.inset, offset: this.frameObj.offset, borderRadius: this.frameObj.radius,
                    frameLineStyle: this.toPascalCase(this.frameObj.border), lineCount: this.frameObj.amount };
                var prevFrameSettings = { type: this.toPascalCase(this.tempFrameObj.type),
                    color: this.tempFrameObj.color, gradientColor: this.tempFrameObj.gradientColor, size: this.tempFrameObj.size,
                    inset: this.tempFrameObj.inset, offset: this.tempFrameObj.offset, borderRadius: this.tempFrameObj.radius,
                    frameLineStyle: this.toPascalCase(this.tempFrameObj.border), lineCount: this.tempFrameObj.amount };
                var frameChange = { cancel: false, previousFrameSetting: prevFrameSettings,
                    currentFrameSetting: currFrameSettings };
                this.editCompleteArgs = frameChange;
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                this.tempFrameObj = extend({}, this.frameObj, {}, true);
            }
            this.notify('draw', { prop: 'resetFrameZoom', onPropertyChange: false, value: { isOk: true } });
        }
        if (!obj['isCropToolbar']) {
            this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                    isApplyBtn: false, isCropping: null, isZooming: null, cType: null } });
            this.currObjType.isRedact = false;
        }
        this.notify('draw', { prop: 'setNewPath', value: { bool: false } });
        this.transform.zoomFactor = this.transform.defaultZoomFactor;
        this.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
        this.isResizeOkBtn = false;
        this.notify('draw', { prop: 'redrawDownScale' });
        this.isChangesSaved = this.isFinetuneBtnClick = false;
        if (isFinalApply) {
            this.drawingShape = null;
            this.notify('draw', { prop: 'resetTempObjColl' });
            this.notify('draw', { prop: 'resetTempPointColl' });
        }
    };
    ImageEditor.prototype.triggerEditCompleteEvent = function (args) {
        if (args.action === 'shape-insert' && args.actionEventArgs &&
            args.actionEventArgs.currentShapeSettings &&
            args.actionEventArgs.currentShapeSettings.type.toString() === 'Redact') {
            args.action = 'redact';
        }
        this.trigger('editComplete', args);
        this.editCompleteArgs = null;
    };
    /**
     * Handles the OK button operation
     *
     * @param { string } id - Specifies shape id to return.
     * @hidden
     * @returns {SelectionPoint | Object}.
     */
    ImageEditor.prototype.getObjFromId = function (id) {
        var obj;
        if (this.activeObj.currIndex && this.activeObj.currIndex === id) {
            obj = extend({}, this.activeObj, {}, true);
        }
        else {
            for (var i = 0; i < this.shapeColl.length; i++) {
                var shapeId = this.shapeColl[i].id ? this.shapeColl[i].id :
                    this.shapeColl[i].currIndex;
                if (shapeId === id) {
                    obj = extend({}, this.shapeColl[i], {}, true);
                    break;
                }
            }
        }
        return obj;
    };
    /**
     * Set the temporary filter properties.
     *
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.setTempFilterProperties = function () {
        this.upperCanvas.style.display = 'block';
        this.cropSelectedState();
        var obj = { adjustmentLevel: null };
        this.notify('filter', { prop: 'getAdjustmentLevel', onPropertyChange: false,
            value: { obj: obj } });
        this.lowerContext.filter = this.initialAdjustmentValue;
        this.notify('draw', { prop: 'setTempAdjustmentValue', value: { tempAdjustmentValue: this.lowerContext.filter } });
        this.notify('filter', { prop: 'setTempAdjustmentLevel', onPropertyChange: false,
            value: { tempAdjustmentLevel: extend({}, obj['adjustmentLevel'], {}, true) } });
        this.notify('draw', { prop: 'setTempFilter', value: { tempFilter: this.currentFilter } });
        var undoRedoObj = { undoRedoStep: null };
        this.notify('undo-redo', { prop: 'getUndoRedoStep', value: { obj: undoRedoObj } });
        this.notify('draw', { prop: 'setTempUndoRedoStep', value: { tempUndoRedoStep: undoRedoObj['undoRedoStep'] } });
    };
    /**
     * To crop the selection.
     *
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.cropSelectedState = function () {
        if (this.activeObj.shape && this.activeObj.shape.split('-')[0] === 'crop') {
            this.okBtn();
        }
    };
    /**
     * Get the current canvas data.
     *
     * @hidden
     * @returns {ImageData}.
     * An ImageData returns the current canvas image data object.
     */
    ImageEditor.prototype.getCurrentCanvasData = function () {
        var tempFrame = extend({}, this.frameObj, {}, true);
        this.frameObj = { type: 'none', color: '#fff', size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: 'solid', gradientColor: '' };
        var tempFilter = this.lowerContext.filter;
        this.lowerContext.filter = this.canvasFilter = 'none';
        var objColl = extend([], this.objColl, null, true);
        var pointColl = extend([], this.pointColl, null, true);
        this.objColl = [];
        this.pointColl = [];
        this.freehandCounter = 0;
        this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
        var ctWrapper = this.element.querySelector('.e-contextual-toolbar-wrapper');
        if (ctWrapper) {
            ctWrapper.classList.add('e-hide');
        }
        var data = this.getImageData();
        if (ctWrapper) {
            ctWrapper.classList.remove('e-hide');
        }
        if (!Browser.isDevice) {
            this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                    isApplyBtn: true, isCropping: false } });
        }
        this.element.querySelector('#' + this.element.id + '_contextualToolbarArea').classList.remove('e-hide');
        this.objColl = objColl;
        this.pointColl = pointColl;
        this.freehandCounter = pointColl.length;
        this.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });
        this.lowerContext.filter = this.canvasFilter = tempFilter;
        this.frameObj = tempFrame;
        return data;
    };
    /**
     * To set current adjustment value
     *
     * @param { string } type - Specifies the type of adjustment.
     * @param { number } value - Specifies the value to adjust.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.setCurrAdjustmentValue = function (type, value) {
        var finetuneValueChanging = { finetune: this.getFinetuneOption(type), value: value, cancel: false };
        this.trigger('finetuneValueChanging', finetuneValueChanging);
        this.editCompleteArgs = finetuneValueChanging;
        if (finetuneValueChanging.cancel) {
            return;
        }
        this.notify('filter', { prop: 'setCurrAdjValue', value: { type: type.toLowerCase(), value: value } });
    };
    /**
     * Get the square point for path.
     *
     * @param { SelectionPoint } obj - Specifies the points of path.
     * @hidden
     * @returns {ActivePoint}.
     * An ActivePoint object which returns the square point.
     */
    ImageEditor.prototype.getSquarePointForPath = function (obj) {
        var point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        if (obj.pointColl.length > 0) {
            point = { startX: obj.pointColl[0].x, startY: obj.pointColl[0].y, endX: obj.pointColl[0].x, endY: obj.pointColl[0].y };
            for (var i = 1; i < obj.pointColl.length; i++) {
                if (obj.pointColl[i].x < point.startX) {
                    point.startX = obj.pointColl[i].x;
                }
                if (obj.pointColl[i].y < point.startY) {
                    point.startY = obj.pointColl[i].y;
                }
                if (obj.pointColl[i].x > point.endX) {
                    point.endX = obj.pointColl[i].x;
                }
                if (obj.pointColl[i].y > point.endY) {
                    point.endY = obj.pointColl[i].y;
                }
            }
            point.width = point.endX - point.startX;
            point.height = point.endY - point.startY;
        }
        return point;
    };
    /**
     * Get the SelectionType.
     *
     * @param { string } type - Specifies the SelectionType.
     * @hidden
     * @returns {string}.
     * An string which returns the SelectionType.
     */
    ImageEditor.prototype.getSelectionType = function (type) {
        type = type === 'crop-custom' ? 'CropCustom' : type;
        var typeToSelectionType = { 'CropCustom': 'Custom', 'CropSquare': 'Square', 'CropCircle': 'Circle',
            'Crop3:2': '3:2', 'Crop4:3': '4:3', 'Crop5:4': '5:4', 'Crop7:5': '7:5', 'Crop16:9': '16:9',
            'Crop2:3': '2:3', 'Crop3:4': '3:4', 'Crop4:5': '4:5', 'Crop5:7': '5:7', 'Crop9:16': '9:16' };
        return typeToSelectionType["" + type] ? typeToSelectionType["" + type] : type.split('Crop')[1];
    };
    /** Clears the context.
     *
     * @param { CanvasRenderingContext2D } ctx - Specifies the canvas context.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.clearContext = function (ctx) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clearRect(0, 0, ctx.canvas.height, ctx.canvas.width);
    };
    /**
     * Apply Arrow for start and end.
     *
     * @param { string } type - Specifies the start arrow or end arrow.
     * @param { string } id - Specifies the start arrow or end arrow item id.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateArrow = function (type, id) {
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        if (collLength !== this.objColl.length) {
            isObjPushed = true;
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        if (isObjPushed) {
            this.objColl.pop();
        }
        if (type === 'startArrow') {
            this.activeObj.start = this.getTextFromId(id);
        }
        else if (type === 'endArrow') {
            this.activeObj.end = this.getTextFromId(id);
        }
        this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                strokeWidth: this.activeObj.strokeSettings.strokeWidth } });
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
        }
        this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        if (Browser.isDevice) {
            if (document.getElementById(this.element.id + '_bottomToolbar')) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var toolbar_1 = getComponent(this.element.id + '_bottomToolbar', 'toolbar');
                toolbar_1.refreshOverflow();
            }
        }
        else {
            if (document.getElementById(this.element.id + '_toolbar')) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var toolbar_2 = getComponent(this.element.id + '_toolbar', 'toolbar');
                toolbar_2.refreshOverflow();
            }
        }
        var shapeChangedArgs = { action: type, currentShapeSettings: extend({}, shapeSettings, {}, true) };
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Font style for text.
     *
     * @param { string } id - Specifies the selected item id.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateFontFamily = function (id) {
        this.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        if (collLength !== this.objColl.length) {
            isObjPushed = true;
        }
        var objColl = extend([], this.objColl, [], true);
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (isObjPushed) {
            this.objColl.pop();
        }
        if (this.textArea.style.display === 'block' || this.textArea.style.display === 'inline-block') {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: true } });
            var temp = this.activeObj.textSettings.fontFamily;
            this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('shape', { prop: 'redraw-text' });
            }
            this.objColl.push(this.activeObj);
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
            }
            this.objColl.pop();
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            var width = this.activeObj.activePoint.width +
                this.activeObj.textSettings.fontSize * 0.25;
            this.textArea.style.width = width + 'px';
            this.textArea.style.fontFamily = this.toPascalCase(id);
            this.activeObj.textSettings.fontFamily = temp;
            this.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,
                value: { isTextBox: null } });
        }
        else {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: null } });
            var fontFamily = this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
            this.notify('shape', { prop: 'setTextSettings', onPropertyChange: false,
                value: { textSettings: null, fontFamily: fontFamily, fontSize: null } });
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('shape', { prop: 'redraw-text' });
            }
            this.objColl.push(this.activeObj);
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: objColl,
                        previousPointColl: extend([], this.pointColl, [], true),
                        previousSelPointColl: prevObj.selPointColl, previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
            }
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
        var shapeChangedArgs = { action: 'font-family', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.fontFamily = this.textArea.style.fontFamily;
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Font size for text.
     *
     * @param { string } text - Specifies the selected item text.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateFontSize = function (text) {
        var itemText = text;
        this.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        if (collLength !== this.objColl.length) {
            isObjPushed = true;
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (isObjPushed) {
            this.objColl.pop();
        }
        if (this.textArea.style.display === 'block' || this.textArea.style.display === 'inline-block') {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: true } });
            var temp = this.activeObj.textSettings.fontSize;
            this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[(parseInt(itemText, 10) - 1)].text, 10);
            this.objColl.push(this.activeObj);
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
            }
            this.objColl.pop();
            var textStyle = '';
            if (this.textArea.style.fontWeight === 'bold') {
                textStyle = 'bold ';
            }
            if (this.textArea.style.fontStyle === 'italic') {
                textStyle = 'italic ';
            }
            if (this.textArea.style.fontWeight === 'bold' && this.textArea.style.fontStyle === 'italic') {
                textStyle = 'italic bold ';
            }
            this.upperContext.font = textStyle + this.activeObj.textSettings.fontSize + 'px' + ' ' + this.textArea.style.fontFamily;
            var rows = this.textArea.value.split('\n');
            var obj = { maxText: '' };
            this.notify('shape', { prop: 'getMaxText', onPropertyChange: false,
                value: { isTextBox: true, text: null, obj: obj } });
            var text_1 = obj['maxText'];
            var width = this.upperContext.measureText(text_1).width +
                this.activeObj.textSettings.fontSize * 0.5;
            this.textArea.style.width = width + 'px';
            this.textArea.style.height = rows.length * (this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25) + 'px';
            this.activeObj.textSettings.fontSize = temp;
            this.upperContext.font = this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
            this.textArea.style.fontSize = parseInt(this.fontSizeColl[(parseInt(itemText, 10) - 1)].text, 10) + 'px';
            if (this.textArea.style.fontFamily === 'georgia') {
                this.textArea.style.width = parseFloat(this.textArea.style.width) + parseFloat(this.textArea.style.fontSize) + 'px';
            }
        }
        else {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: null } });
            var fontSize = this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[(parseInt(itemText, 10) - 1)].text, 10);
            this.notify('shape', { prop: 'setTextSettings', onPropertyChange: false,
                value: { textSettings: null, fontFamily: null, fontSize: fontSize } });
            this.upperContext.font = this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
            var rows = this.activeObj.keyHistory.split('\n');
            var obj = { maxText: '' };
            this.notify('shape', { prop: 'getMaxText', onPropertyChange: false,
                value: { isTextBox: null, text: null, obj: obj } });
            var text_2 = obj['maxText'];
            var width = this.upperContext.measureText(text_2).width +
                this.activeObj.textSettings.fontSize * 0.5;
            var height = rows.length * (this.activeObj.textSettings.fontSize +
                this.activeObj.textSettings.fontSize * 0.25);
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,
                    value: { width: width, height: height } });
                this.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: this.activeObj.activePoint, obj: this.activeObj,
                        isMouseMove: null, x: null, y: null } });
                this.notify('shape', { prop: 'redraw-text' });
            }
            this.objColl.push(this.activeObj);
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
            }
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
        var shapeChangedArgs = { action: 'font-size', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.fontSize = this.activeObj.textSettings.fontSize;
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Font color for text.
     *
     * @param { string } value - Specifies the selected color item value.
     * @param { string } color - Specifies the selected color type value.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateFontColor = function (value, color) {
        this.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        if (collLength !== this.objColl.length) {
            isObjPushed = true;
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (isObjPushed) {
            this.objColl.pop();
        }
        if (this.textArea.style.display === 'none') {
            if (color === 'Text') {
                this.activeObj.strokeSettings.strokeColor = value;
                this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null,
                        strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
            }
            else {
                this.activeObj.strokeSettings.fillColor = value;
                this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null,
                        strokeColor: null, fillColor: this.activeObj.strokeSettings.fillColor, strokeWidth: null } });
            }
            if (!this.togglePen) {
                if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                    this.objColl.push(this.activeObj);
                    this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                        value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                            previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                            previousCropObj: prevCropObj, previousText: null,
                            currentText: null, previousFilter: null, isCircleCrop: null } });
                    this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
                }
            }
        }
        else if (this.textArea.style.display === 'block' || this.textArea.style.display === 'inline-block') {
            this.textArea.style[color === 'Text' ? 'color' : 'backgroundColor'] = value;
            var temp = color === 'Text' ? this.activeObj.strokeSettings.strokeColor : this.activeObj.strokeSettings.fillColor;
            this.activeObj.strokeSettings[color === 'Text' ? 'strokeColor' : 'fillColor'] = value;
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.objColl.push(this.activeObj);
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
                this.objColl.pop();
            }
            this.activeObj.strokeSettings[color === 'Text' ? 'strokeColor' : 'fillColor'] = temp;
        }
        else if (!this.togglePen) {
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.objColl.push(this.activeObj);
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
                this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
            }
        }
        var shapeChangedArgs = { action: 'font-color', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.fillColor = value;
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Font color for text.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateStrokeTextColor = function (value) {
        this.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        if (collLength !== this.objColl.length) {
            isObjPushed = true;
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (isObjPushed) {
            this.objColl.pop();
        }
        if (this.textArea.style.display === 'none') {
            this.activeObj.strokeSettings.outlineColor = value;
            this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null,
                    strokeColor: null, fillColor: null, strokeWidth: null, outlineColor: this.activeObj.strokeSettings.outlineColor } });
            if (!this.togglePen) {
                if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                    this.objColl.push(this.activeObj);
                    this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                        value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                            previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                            previousCropObj: prevCropObj, previousText: null,
                            currentText: null, previousFilter: null, isCircleCrop: null } });
                    this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
                }
            }
        }
        else if (this.textArea.style.display === 'block' || this.textArea.style.display === 'inline-block') {
            this.textArea.style.textShadow = "-1px -1px 0 " + value + ", 1px -1px 0 " + value + ", -1px 1px 0 " + value + ", 1px 1px 0 " + value;
            var temp = this.activeObj.strokeSettings.outlineColor;
            this.activeObj.strokeSettings.outlineColor = value;
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.objColl.push(this.activeObj);
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
                this.objColl.pop();
            }
            this.activeObj.strokeSettings.outlineColor = temp;
        }
        else if (!this.togglePen) {
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.objColl.push(this.activeObj);
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
                this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
            }
        }
        var shapeChangedArgs = { action: 'font-color', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.fillColor = value;
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Pen stroke width.
     *
     * @param { string } id - Specifies the selected item id.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updatePenStrokeWidth = function (id) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var temp = extend([], this.pointColl, [], true);
        this.updateFreehandDrawColorChange();
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.pointColl = temp;
        this.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: true } });
        this.setPenStroke(id);
        var obj = { bool: false };
        this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (obj['bool']) {
            var obj_6 = { penStrokeWidth: null };
            this.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: obj_6 } });
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
            this.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                value: { strokeColor: null, strokeWidth: obj_6['penStrokeWidth'] } });
            var indexObj = { freehandSelectedIndex: null };
            this.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            this.pointColl[indexObj['freehandSelectedIndex']].strokeWidth = obj_6['penStrokeWidth'];
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
            this.notify('draw', { prop: 'redrawDownScale' });
            this.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                value: { strokeColor: null, strokeWidth: obj_6['penStrokeWidth'] } });
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'freehanddrawCustomized', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
        }
        shapeSettings.type = ShapeType.FreehandDraw;
        var shapeChangedArgs = { action: 'stroke-width', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.strokeWidth = this.activeObj.strokeSettings.strokeWidth;
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Pen stroke color.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updatePenStrokeColor = function (value) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var temp = extend([], this.pointColl, [], true);
        this.updateFreehandDrawColorChange();
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.pointColl = temp;
        this.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: true } });
        this.activeObj.strokeSettings.strokeColor = value;
        var indexObj = { freehandSelectedIndex: null };
        this.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
        if (indexObj['freehandSelectedIndex'] !== null && indexObj['freehandSelectedIndex'] !== undefined) {
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
            this.notify('draw', { prop: 'redrawDownScale' });
            this.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                value: { strokeColor: null, strokeWidth: null } });
        }
        var obj = { bool: false };
        this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (obj['bool']) {
            var indexObj_1 = { freehandSelectedIndex: null };
            this.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj_1 } });
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.pointColl[indexObj_1['freehandSelectedIndex']].strokeColor = value;
            this.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                value: { strokeColor: value } });
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'freehanddrawCustomized', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
        }
        else if (!this.togglePen) {
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.activeObj } });
        }
        shapeSettings.type = ShapeType.FreehandDraw;
        var shapeChangedArgs = { action: 'stroke-color', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.strokeColor = value;
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Shape stroke width.
     *
     * @param { string } id - Specifies the selected item id.
     * @param { string } type - Specifies the type of selected item.
     * @param { string } shapeType - Specifies the shape type of selected item.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateStrokeWidth = function (id, type, shapeType) {
        if (this.activeObj.shape && (this.activeObj.shape !== 'path' || (this.activeObj.shape === 'path' &&
            this.activeObj.pointColl.length > 0))) {
            var obj = { shapeSettingsObj: {} };
            this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
            var shapeSettings = obj['shapeSettingsObj'];
            var isObjPushed = false;
            var collLength = this.objColl.length;
            this.notify('shape', { prop: 'pushActItemIntoObj' });
            if (collLength !== this.objColl.length) {
                isObjPushed = true;
            }
            var prevCropObj = extend({}, this.cropObj, {}, true);
            var object = { currObj: {} };
            this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var prevObj = object['currObj'];
            prevObj.objColl = extend([], this.objColl, [], true);
            prevObj.pointColl = extend([], this.pointColl, [], true);
            prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            if (isObjPushed) {
                this.objColl.pop();
            }
            this.activeObj.strokeSettings[type === 'width' ? (shapeType === 'text' ? 'outlineWidth' : 'strokeWidth') : 'radius'] = parseInt(id, 10);
            if (this.activeObj.shape === 'rectangle' || this.activeObj.shape === 'ellipse') {
                this.activeObj.strokeSettings[type === 'width' ? (shapeType === 'text' ? 'outlineWidth' : 'strokeWidth') : 'radius'] = parseInt(id, 10) - 1;
            }
            this.activeObj.strokeSettings[type === 'width' ? (shapeType === 'text' ? 'outlineWidth' : 'strokeWidth') : 'radius'] *= 2;
            if (type === 'width') {
                if (shapeType === 'text') {
                    this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                            strokeWidth: null, radius: null, outlineWidth: this.activeObj.strokeSettings.outlineWidth } });
                }
                else {
                    this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                            strokeWidth: this.activeObj.strokeSettings.strokeWidth, radius: null, outlineWidth: null } });
                }
            }
            else {
                this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                        strokeWidth: null, radius: this.activeObj.strokeSettings.radius } });
            }
            this.objColl.push(this.activeObj);
            if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
            }
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
            var shapeChangedArgs = { action: 'stroke-width', currentShapeSettings: extend({}, shapeSettings, {}, true) };
            shapeChangedArgs.currentShapeSettings[type === 'width' ? (shapeType === 'text' ? 'outlineWidth' : 'strokeWidth') : 'radius'] = this.activeObj.strokeSettings[type === 'width' ? (shapeType === 'text' ? 'outlineWidth' : 'strokeWidth') : 'radius'];
            this.trigger('shapeChange', shapeChangedArgs);
            this.editCompleteArgs = shapeChangedArgs;
        }
        else if (this.activeObj.shape && (this.activeObj.shape === 'path' &&
            this.activeObj.pointColl.length === 0)) {
            this.activeObj.strokeSettings.strokeWidth = parseInt(id, 10);
            this.activeObj.strokeSettings.strokeWidth *= 2;
            if (type === 'width') {
                if (shapeType === 'text') {
                    this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                            strokeWidth: null, radius: null, outlineWidth: this.activeObj.strokeSettings.outlineWidth } });
                }
                else {
                    this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                            strokeWidth: this.activeObj.strokeSettings.strokeWidth, radius: null, outlineWidth: null } });
                }
            }
            else {
                this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                        strokeWidth: null, radius: this.activeObj.strokeSettings.radius } });
            }
        }
    };
    /**
     * Apply Shape stroke color.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateStrokeColor = function (value) {
        var objt = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt['shapeSettingsObj'];
        if (this.activeObj.shape && (this.activeObj.shape !== 'path' || (this.activeObj.shape === 'path' &&
            this.activeObj.pointColl.length > 0))) {
            var isObjPushed = false;
            var collLength = this.objColl.length;
            this.notify('shape', { prop: 'pushActItemIntoObj' });
            if (collLength !== this.objColl.length) {
                isObjPushed = true;
            }
            var prevCropObj = extend({}, this.cropObj, {}, true);
            var object = { currObj: {} };
            this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var prevObj = object['currObj'];
            prevObj.objColl = extend([], this.objColl, [], true);
            prevObj.pointColl = extend([], this.pointColl, [], true);
            prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            if (isObjPushed) {
                this.objColl.pop();
            }
            this.activeObj.strokeSettings.strokeColor = value;
            this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
            if (!this.togglePen) {
                this.objColl.push(this.activeObj);
                if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
                    this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                        value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                            previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                            previousCropObj: prevCropObj, previousText: null,
                            currentText: null, previousFilter: null, isCircleCrop: null } });
                }
                this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
            }
        }
        else if (this.activeObj.shape && (this.activeObj.shape === 'path' &&
            this.activeObj.pointColl.length === 0)) {
            this.activeObj.strokeSettings.strokeColor = value;
            this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
        }
        var shapeChangedArgs = { action: 'stroke-color', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings.strokeColor = value;
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply Shape fill color.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateFillColor = function (value) {
        var obj = { shapeSettingsObj: {} };
        this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
        var shapeSettings = obj['shapeSettingsObj'];
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        if (collLength !== this.objColl.length) {
            isObjPushed = true;
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        var prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (isObjPushed) {
            this.objColl.pop();
        }
        this.activeObj.strokeSettings.fillColor = value;
        this.notify('shape', { prop: 'setStrokeSettings',
            value: { strokeSettings: null, strokeColor: null, fillColor: this.activeObj.strokeSettings.fillColor,
                strokeWidth: null } });
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
        }
        this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        var shapeChangedArgs = { action: 'fill-color', currentShapeSettings: extend({}, shapeSettings, {}, true) };
        this.trigger('shapeChange', shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
    };
    /**
     * Apply horizontal flip.
     *
     * @param { CanvasRenderingContext2D } ctx - Specifies the canvas context 2D.
     * @param { boolean } isPreventURC - Specifies to update undo redo collection.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.horizontalFlip = function (ctx, isPreventURC) {
        var prevCropObj;
        var prevObj;
        if (isNullOrUndefined(isPreventURC)) {
            if (isNullOrUndefined(this.activeObj.imageRatio)) {
                this.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
            }
            this.notify('shape', { prop: 'pushActItemIntoObj' });
            prevCropObj = extend({}, this.cropObj, {}, true);
            var object = { currObj: {} };
            this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            prevObj = object['currObj'];
            prevObj.objColl = extend([], this.objColl, [], true);
            prevObj.pointColl = extend([], this.pointColl, [], true);
            prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            this.objColl.pop();
        }
        this.notify('toolbar', { prop: 'refreshSlider' });
        ctx.clearRect(0, 0, this.activeObj.imageCanvas.width, this.activeObj.imageCanvas.height);
        var activePoint = this.duplicateImage();
        this.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
            value: { ctx: this.activeObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: true, isVFlip: null } });
        this.activeObj.activePoint = activePoint;
        this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        if (isNullOrUndefined(isPreventURC)) {
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'imageHFlip', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
    };
    /**
     * Apply vertical flip.
     *
     * @param { CanvasRenderingContext2D } ctx - Specifies the canvas context 2D.
     * @param { boolean } isPreventURC - Specifies to update undo redo collection.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.verticalFlip = function (ctx, isPreventURC) {
        var prevCropObj;
        var prevObj;
        if (isNullOrUndefined(isPreventURC)) {
            if (isNullOrUndefined(this.activeObj.imageRatio)) {
                this.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
            }
            this.notify('shape', { prop: 'pushActItemIntoObj' });
            prevCropObj = extend({}, this.cropObj, {}, true);
            var object = { currObj: {} };
            this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            prevObj = object['currObj'];
            prevObj.objColl = extend([], this.objColl, [], true);
            prevObj.pointColl = extend([], this.pointColl, [], true);
            prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            this.objColl.pop();
        }
        this.notify('toolbar', { prop: 'refreshSlider' });
        ctx.clearRect(0, 0, this.activeObj.imageCanvas.width, this.activeObj.imageCanvas.height);
        var activePoint = this.duplicateImage();
        this.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
            value: { ctx: this.activeObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: null, isVFlip: true } });
        this.activeObj.activePoint = activePoint;
        this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        if (isNullOrUndefined(isPreventURC)) {
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'imageVFlip', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
    };
    /**
     * Apply rotate image.
     *
     * @param { string } rotate - Specifies the direction of rotation.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.rotateImage = function (rotate) {
        var prevCropObj;
        var prevObj;
        if (isNullOrUndefined(this.activeObj.imageRatio)) {
            this.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
        }
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        // eslint-disable-next-line prefer-const
        prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        // eslint-disable-next-line prefer-const
        prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.objColl.pop();
        this.notify('toolbar', { prop: 'refreshSlider' });
        if (rotate === 'rotleft') {
            this.activeObj.rotatedAngle -= (90 * (Math.PI / 180));
        }
        else {
            this.activeObj.rotatedAngle += (90 * (Math.PI / 180));
        }
        this.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: this.activeObj } });
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        this.objColl.push(this.activeObj);
        this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'imageRotate', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
        this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        this.notify('toolbar', { prop: 'destroy-qa-toolbar' });
        this.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
    };
    /**
     * Get pascalToSplitWords from string.
     *
     * @param { string } str - Specifies the word.
     * @hidden
     * @returns {string}.
     */
    ImageEditor.prototype.pascalToSplitWords = function (str) {
        str = str.charAt(0).toUpperCase() + str.slice(1);
        var splitStr = str.match(/[A-Z][a-z]+/g);
        if (isNullOrUndefined(splitStr)) {
            return str;
        }
        else {
            return splitStr.map(function (word) { return word.charAt(0).toUpperCase() + word.slice(1); }).join(' ');
        }
    };
    /**
     * Get Slider Value.
     *
     * @param { string } type - Finetune type.
     * @hidden
     * @returns {number}.
     */
    ImageEditor.prototype.getCurrAdjustmentValue = function (type) {
        var value = 100;
        var indexObj = { freehandSelectedIndex: null };
        this.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
        if (type === 'transparency' && this.togglePen) {
            var obj = { penOpacity: 1 };
            this.notify('freehand-draw', { prop: 'getPenOpacity', onPropertyChange: false, value: { obj: obj } });
            value = obj['penOpacity'] * 100;
        }
        else if (type === 'transparency' && indexObj['freehandSelectedIndex'] !== null && indexObj['freehandSelectedIndex'] !== undefined) {
            value = this.pointColl[indexObj['freehandSelectedIndex']].opacity * 100;
        }
        else {
            var obj = { adjustmentLevel: null };
            this.notify('filter', { prop: 'getAdjustmentLevel', onPropertyChange: false,
                value: { obj: obj } });
            var typeToAdjustmentLevel = { 'brightness': obj['adjustmentLevel'].brightness,
                'contrast': obj['adjustmentLevel'].contrast, 'hue': obj['adjustmentLevel'].hue,
                'saturation': obj['adjustmentLevel'].saturation, 'opacity': obj['adjustmentLevel'].opacity,
                'blur': obj['adjustmentLevel'].blur, 'exposure': obj['adjustmentLevel'].exposure,
                'transparency': obj['adjustmentLevel'].transparency, 'straighten': this.transform.straighten };
            value = typeToAdjustmentLevel["" + type];
        }
        return value;
    };
    /**
     * Apply transformSelect.
     *
     * @param { string } type - Specifies the selected item text.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.transformSelect = function (type) {
        if (this.transform.straighten === 0 && (type === 'rotateleft' || type === 'rotateright') &&
            this.activeObj.shape && (['crop-2:3', 'crop-3:2', 'crop-3:4', 'crop-4:3', 'crop-4:5', 'crop-5:4', 'crop-5:7', 'crop-7:5',
            'crop-9:16', 'crop-16:9'].indexOf(this.activeObj.shape) !== -1 || (this.activeObj.shape.indexOf('crop-') !== -1 &&
            this.activeObj.shape !== 'crop-custom' && this.activeObj.shape !== 'crop-square' && this.activeObj.shape !== 'crop-circle'))) {
            this.activeObj.shape = 'crop-' + this.activeObj.shape.split('-')[1].split(':')[1] + ':' + this.activeObj.shape.split('-')[1].split(':')[0];
            this.notify('toolbar', { prop: 'performCropTransformClick', value: { shape: this.activeObj.shape, isTransform: true } });
        }
        this.isCropToolbar = true;
        this.allowDownScale = false;
        var straighten = this.transform.straighten;
        var straightenObj = extend({}, this.activeObj, {}, true);
        var zoomFactor = this.transform.zoomFactor;
        this.prevEventSelectionPoint = extend({}, this.activeObj, {}, true);
        var object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        this.prevEventObjPoint = object['currObj'];
        this.prevEventObjPoint.objColl = extend([], this.objColl, [], true);
        this.prevEventObjPoint.pointColl = extend([], this.pointColl, [], true);
        this.prevEventObjPoint.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        this.prevEventObjPoint.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (this.transform.straighten !== 0) {
            this.transform.straighten = 0;
            this.straightenBaseImageCanvas();
            for (var i = 0, len = this.objColl.length; i < len; i++) {
                var shape = this.objColl[i].shape;
                if (shape !== 'line' && shape !== 'arrow' && shape !== 'path') {
                    this.objColl[i].rotatedAngle -= (straighten * (Math.PI / 180));
                    this.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: this.objColl[i] } });
                }
            }
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
            this.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
        }
        this.setInitialZoomState();
        var activeObj = extend({}, this.activeObj, {}, true);
        this.notify('crop', { prop: 'setTransformCrop', onPropertyChange: false, value: { bool: true } });
        this.cropSelectedState();
        this.notify('crop', { prop: 'setTransformCrop', onPropertyChange: false, value: { bool: false } });
        this.notify('draw', { prop: 'resetCurrentSelectionPoint' });
        this.updateImageTransformColl(type);
        this.notify('transform', { prop: 'performTransformation', value: { text: type } });
        this.isCropTab = true;
        this.notify('draw', { prop: 'moveToSelectionRange', value: { type: type, activeObj: activeObj } });
        if (this.isStraightening && (type === 'horizontalflip' || type === 'verticalflip')) {
            this.notify('draw', { prop: 'resetStraightenDestPoints' });
            this.notify('draw', { prop: 'setDestForStraighten' });
        }
        if (straighten !== 0) {
            this.transform.straighten = straighten;
            this.straightenBaseImageCanvas();
            for (var i = 0, len = this.objColl.length; i < len; i++) {
                var shape = this.objColl[i].shape;
                if (shape !== 'line' && shape !== 'arrow' && shape !== 'path') {
                    this.objColl[i].rotatedAngle += (straighten * (Math.PI / 180));
                    this.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: this.objColl[i] } });
                }
            }
            this.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
            this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: straightenObj } });
            this.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
            this.notify('draw', { prop: 'setStraightenInitZoom', value: { zoomFactor: zoomFactor } });
            if ((this.isStraightening && (type === 'horizontalflip' || type === 'verticalflip')) &&
                isNullOrUndefined(this.transform.zoomFactor) || this.transform.zoomFactor === 0) {
                if (this.transform.degree === 0) {
                    this.transform.zoomFactor += 0.025;
                }
                else if (this.transform.zoomFactor === 0) {
                    this.transform.zoomFactor = null;
                }
            }
            this.notify('draw', { prop: 'zoomToSel', value: { activeObj: straightenObj, isToolbar: false } });
        }
        this.isCropToolbar = false;
        var stValPan = this.element.querySelector('.e-ie-straighten-value-span');
        if (stValPan) {
            stValPan.innerHTML = this.transform.straighten.toString() + '&#176';
        }
    };
    /**
     * Returns default filter.
     *
     * @hidden
     * @returns {string}.
     */
    ImageEditor.prototype.getDefaultFilter = function () {
        return 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
            'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' +
            'grayscale(0%) ' + 'invert(0%)';
    };
    /**
     * Performs Straightening action.
     *
     * @param { number } value - Specifies the degree of straightening.
     * @hidden
     * @returns {void} .
     */
    ImageEditor.prototype.setStraighten = function (value) {
        var straightenEventArgs = { cancel: false, previousDegree: this.transform.straighten, currentDegree: value };
        this.trigger('rotating', straightenEventArgs);
        this.editCompleteArgs = straightenEventArgs;
        if (!straightenEventArgs.cancel) {
            this.performStraighten(straightenEventArgs);
            var actionArgs = { action: 'straighten', actionEventArgs: this.editCompleteArgs };
            this.triggerEditCompleteEvent(actionArgs);
        }
    };
    ImageEditor.prototype.duplicateImage = function () {
        var activePoint = extend({}, this.activeObj.activePoint, {}, true);
        var dimObj = { width: 0, height: 0 };
        this.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: this.activeObj.imageElement.width, height: this.activeObj.imageElement.height, obj: dimObj, isImgShape: null } });
        this.activeObj.activePoint.width = dimObj['width'];
        this.activeObj.activePoint.height = dimObj['height'];
        return activePoint;
    };
    ImageEditor.prototype.performStraighten = function (straightenEventArgs) {
        var value = straightenEventArgs.currentDegree;
        var stValPan = this.element.querySelector('.e-ie-straighten-value-span');
        if (stValPan) {
            stValPan.innerHTML = value.toString() + '&#176';
        }
        var obj = extend({}, this.activeObj, null, true);
        this.notify('freehand-draw', { prop: 'setCenterSelPoints' });
        this.transform.straighten = value;
        this.straightenPoint = { x: this.activeObj.activePoint.startX + (this.activeObj.activePoint.width / 2),
            y: this.activeObj.activePoint.startY + (this.activeObj.activePoint.height / 2) };
        this.straightenBaseImageCanvas();
        for (var i = 0, len = this.objColl.length; i < len; i++) {
            var shape = this.objColl[i].shape;
            if (shape !== 'line' && shape !== 'arrow' && shape !== 'path') {
                this.objColl[i].rotatedAngle += ((this.transform.straighten - this.prevStraightenedDegree) * (Math.PI / 180));
                this.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: this.objColl[i] } });
            }
        }
        if (this.transform.degree % 90 === 0 && this.transform.degree % 180 !== 0) {
            if (this.transform.straighten === 0) {
                this.transform.straighten = 360;
            }
            this.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                value: { x: this.activeObj.activePoint.startX + (this.activeObj.activePoint.width / 2),
                    y: this.activeObj.activePoint.startY + (this.activeObj.activePoint.height / 2), type: 'zoomIn', isResize: true } });
            this.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                value: { x: this.activeObj.activePoint.startX + (this.activeObj.activePoint.width / 2),
                    y: this.activeObj.activePoint.startY + (this.activeObj.activePoint.height / 2), type: 'zoomOut', isResize: true } });
            if (this.transform.straighten === 360) {
                this.transform.straighten = 0;
            }
        }
        else {
            this.notify('draw', { prop: 'render-image', value: { isMouseWheel: true, isPreventClearRect: null, isFrame: null, isStraighten: true } });
        }
        this.notify('draw', { prop: 'drawObject', onPropertyChange: false,
            value: { canvas: 'duplicate', obj: obj } });
        this.notify('draw', { prop: 'zoomToSel', value: { activeObj: obj, isToolbar: true } });
        this.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
        this.prevStraightenedDegree = this.transform.straighten;
    };
    /**
     * Straightens base image.
     *
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.straightenBaseImageCanvas = function () {
        if (this.isImageLoaded) {
            var flipState = this.getStraightenFlipState();
            var straighten = flipState === 'horizontal' || flipState === 'vertical' ?
                -this.transform.straighten : this.transform.straighten;
            var ctx = this.baseImgCanvas.getContext('2d');
            if (ctx.canvas.width !== this.lowerContext.canvas.width &&
                ctx.canvas.height !== this.lowerContext.canvas.height) {
                var obj_7 = { width: 0, height: 0 };
                this.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
                    value: { obj: obj_7, dimension: { width: ctx.canvas.width, height: ctx.canvas.height } } });
            }
            var dimension = void 0;
            // eslint-disable-next-line prefer-const
            dimension = this.getRotatedCanvasDim(this.baseImg.width, this.baseImg.height, this.transform.straighten);
            this.img.srcWidth = ctx.canvas.width = dimension.width;
            this.img.srcHeight = ctx.canvas.height = dimension.height;
            var x = ctx.canvas.width / 2;
            var y = ctx.canvas.height / 2;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.translate(x, y);
            ctx.rotate(straighten * Math.PI / 180);
            ctx.drawImage(this.baseImg, -this.baseImg.width / 2, -this.baseImg.height / 2, this.baseImg.width, this.baseImg.height);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            var obj = { width: 0, height: 0 };
            this.notify('crop', { prop: 'calcRatio', onPropertyChange: false, value: { obj: obj, dimension: { width: ctx.canvas.width, height: ctx.canvas.height } } });
        }
    };
    /**
     * Returns rotated canvas dimension.
     *
     * @param { number } width - Specifies the width of the canvas.
     * @param { number } height - Specifies the height of the canvas.
     * @param { number } angle - Specifies the angle of rotation in degrees.
     * @hidden
     * @returns {void} .
     */
    ImageEditor.prototype.getRotatedCanvasDim = function (width, height, angle) {
        var angleRad = angle * Math.PI / 180;
        var cosAngle = Math.cos(angleRad);
        var sinAngle = Math.sin(angleRad);
        var minX = Math.min(0, width * cosAngle, height * Math.cos(Math.PI / 2 - angleRad), width * cosAngle + height * Math.cos(Math.PI / 2 - angleRad));
        var maxX = Math.max(0, width * cosAngle, height * Math.cos(Math.PI / 2 - angleRad), width * cosAngle + height * Math.cos(Math.PI / 2 - angleRad));
        var minY = Math.min(0, width * sinAngle, height * Math.sin(Math.PI / 2 - angleRad), width * sinAngle + height * Math.sin(Math.PI / 2 - angleRad));
        var maxY = Math.max(0, width * sinAngle, height * Math.sin(Math.PI / 2 - angleRad), width * sinAngle + height * Math.sin(Math.PI / 2 - angleRad));
        return { width: Math.ceil(maxX - minX), height: Math.ceil(maxY - minY) };
    };
    /**
     * Apply Shape order.
     *
     * @param { string } id - Specifies the id of the shape to change the order.
     * @param { string } value - Specifies the order of the shapes.
     * @hidden
     * @returns {void}.
     */
    ImageEditor.prototype.updateShapeOrder = function (id, value) {
        var shapeObj = this.getObjFromId(id);
        if ((shapeObj.shape && (shapeObj.shape !== 'path' ||
            (shapeObj.shape === 'path' && shapeObj.pointColl.length > 0))) ||
            (shapeObj && shapeObj['id'] && shapeObj['id'].indexOf('pen') > -1)) {
            var obj = { shapeSettingsObj: {} };
            this.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
            var shapeSettings = obj['shapeSettingsObj'];
            if (shapeObj.shape) {
                this.notify('shape', { prop: 'pushActItemIntoObj' });
            }
            var prevCropObj = extend({}, this.cropObj, {}, true);
            var object = { currObj: {} };
            this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            var prevObj = object['currObj'];
            prevObj.objColl = extend([], this.objColl, [], true);
            prevObj.pointColl = extend([], this.pointColl, [], true);
            prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
            var selPointCollObj = { selPointColl: null };
            this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            if (shapeObj.shape) {
                this.objColl.pop();
            }
            this.notify('shape', { prop: 'z-order', onPropertyChange: false, value: { obj: shapeObj, value: value } });
            if (shapeObj.shape) {
                this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                        strokeWidth: shapeObj.strokeSettings.strokeWidth } });
                this.objColl.push(shapeObj);
            }
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            if (shapeObj.shape) {
                this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
                this.activeObj.order = shapeObj.order;
            }
            var shapeChangedArgs = { action: 'stroke-width', previousShapeSettings: extend({}, shapeSettings, {}, true),
                currentShapeSettings: extend({}, shapeSettings, {}, true) };
            shapeChangedArgs.currentShapeSettings.strokeWidth = this.activeObj.strokeSettings.strokeWidth;
        }
        else if (this.activeObj.shape && (this.activeObj.shape === 'path' &&
            this.activeObj.pointColl.length === 0)) {
            this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                    strokeWidth: this.activeObj.strokeSettings.strokeWidth } });
        }
    };
    ImageEditor.prototype.getStraightenFlipState = function () {
        var flipState = '';
        if (this.rotateFlipColl.length > 0) {
            for (var i = 0, len = this.rotateFlipColl.length; i < len; i++) {
                var curFlip = this.rotateFlipColl[i];
                if (curFlip === 'horizontal') {
                    flipState += 'horizontal';
                }
                else if (curFlip === 'vertical') {
                    flipState += 'vertical';
                }
                if (flipState === 'horizontalvertical' || flipState === 'verticalhorizontal') {
                    flipState = '';
                }
            }
        }
        return flipState;
    };
    ImageEditor.prototype.initializeZoomSettings = function () {
        this.theme = isNullOrUndefined(this.theme) ? 'Bootstrap5' : this.theme;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if (isNullOrUndefined(this.zoomSettings.zoomTrigger) || this.zoomSettings.zoomTrigger === 0) {
            this.zoomSettings.zoomTrigger = (ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar | ZoomTrigger.Commands);
        }
        if (isNullOrUndefined(this.selectionSettings.strokeColor)) {
            this.selectionSettings.strokeColor = this.themeColl[this.theme]['primaryColor'];
        }
        if (isNullOrUndefined(this.selectionSettings.fillColor)) {
            this.selectionSettings.fillColor = this.themeColl[this.theme]['secondaryColor'];
        }
    };
    ImageEditor.prototype.initializeThemeColl = function () {
        this.themeColl = {
            Bootstrap5: { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            Bootstrap5Dark: { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            Tailwind: { primaryColor: '#4f46e5', secondaryColor: '#fff' },
            TailwindDark: { primaryColor: '#22d3ee', secondaryColor: '#fff' },
            Fluent: { primaryColor: '#0078d4', secondaryColor: '#fff' },
            FluentDark: { primaryColor: '#0078d4', secondaryColor: '#fff' },
            Bootstrap4: { primaryColor: '#007bff', secondaryColor: '#fff' },
            Bootstrap: { primaryColor: '#317ab9', secondaryColor: '#fff' },
            BootstrapDark: { primaryColor: '#317ab9', secondaryColor: '#fff' },
            Material: { primaryColor: '#e3165b', secondaryColor: '#fff' },
            MaterialDark: { primaryColor: '#00b0ff', secondaryColor: '#fff' },
            Fabric: { primaryColor: '#0078d6', secondaryColor: '#fff' },
            FabricDark: { primaryColor: '#0074cc', secondaryColor: '#fff' },
            Highcontrast: { primaryColor: '#000000', secondaryColor: '#fff' },
            Material3: { primaryColor: '#6750a4', secondaryColor: '#fff' },
            Material3Dark: { primaryColor: '#d0bcff', secondaryColor: '#fff' },
            Fluent2: { primaryColor: '#0f6cbd', secondaryColor: '#fff' },
            Fluent2Dark: { primaryColor: '#115ea3', secondaryColor: '#fff' },
            Fluent2Highcontrast: { primaryColor: '#1aebff', secondaryColor: '#fff' },
            'Bootstrap5.3': { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            'Bootstrap5.3Dark': { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            Tailwind3: { primaryColor: '#4f46e5', secondaryColor: '#ffffff' },
            Tailwind3Dark: { primaryColor: '#6366f1', secondaryColor: '#ffffff03' }
        };
    };
    /**
     * Draw a redaction on an image.
     *
     * @param {RedactType} type  Optional. Specifies the type of redaction to be drawn on the image such as blur or pixelate. If not specified, the redaction drawing is initiated with the default blur value.
     * @param {number} x  Optional. Specifies x-coordinate of redaction. If not specified, the redaction drawing is initiated with the first parameter.
     * @param {number} y  Optional. Specifies y-coordinate of redaction. If not specified it draws redaction from the center point of the image.
     * @param {number} width  Optional. Specifies the width of the redaction. The default value is 100.
     * @param {number} height  Optional. Specifies the height of the redaction. The default value is 50.
     * @param {number} value  Optional. Specifies the blur value for blur-type redaction or the pixel size for pixelate-type redaction. Defaults to 20 since the default redaction is blur.
     * @returns {boolean}.
     */
    ImageEditor.prototype.drawRedact = function (type, x, y, width, height, value) {
        var isRedact = false;
        var isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            isRedact = true;
            this.manageActiveAction();
            this.notify('shape', {
                prop: 'drawRedact', onPropertyChange: false, value: {
                    x: x, y: y, width: width, height: height, type: type, value: value
                }
            });
            this.notify('draw', { prop: 'redrawDownScale' });
        }
        return isRedact;
    };
    var ImageEditor_1;
    __decorate([
        Property('')
    ], ImageEditor.prototype, "cssClass", void 0);
    __decorate([
        Property(false)
    ], ImageEditor.prototype, "disabled", void 0);
    __decorate([
        Property('100%')
    ], ImageEditor.prototype, "height", void 0);
    __decorate([
        Property('Bootstrap5')
    ], ImageEditor.prototype, "theme", void 0);
    __decorate([
        Property()
    ], ImageEditor.prototype, "toolbar", void 0);
    __decorate([
        Property()
    ], ImageEditor.prototype, "toolbarTemplate", void 0);
    __decorate([
        Property('100%')
    ], ImageEditor.prototype, "width", void 0);
    __decorate([
        Property(true)
    ], ImageEditor.prototype, "allowUndoRedo", void 0);
    __decorate([
        Property(true)
    ], ImageEditor.prototype, "showQuickAccessToolbar", void 0);
    __decorate([
        Property()
    ], ImageEditor.prototype, "quickAccessToolbarTemplate", void 0);
    __decorate([
        Property(false)
    ], ImageEditor.prototype, "isReadOnly", void 0);
    __decorate([
        Property(false)
    ], ImageEditor.prototype, "enableRtl", void 0);
    __decorate([
        Property(false)
    ], ImageEditor.prototype, "enablePersistence", void 0);
    __decorate([
        Complex({}, FinetuneSettings)
    ], ImageEditor.prototype, "finetuneSettings", void 0);
    __decorate([
        Complex({}, ZoomSettings)
    ], ImageEditor.prototype, "zoomSettings", void 0);
    __decorate([
        Complex({}, SelectionSettings)
    ], ImageEditor.prototype, "selectionSettings", void 0);
    __decorate([
        Complex({}, FontFamily)
    ], ImageEditor.prototype, "fontFamily", void 0);
    __decorate([
        Complex({}, UploadSettings)
    ], ImageEditor.prototype, "uploadSettings", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "beforeSave", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "created", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "destroyed", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "zooming", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "panning", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "cropping", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "rotating", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "flipping", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "shapeChanging", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "selectionChanging", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "fileOpened", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "saved", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "toolbarCreated", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "toolbarUpdating", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "toolbarItemClicked", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "imageFiltering", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "finetuneValueChanging", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "click", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "shapeChange", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "quickAccessToolbarOpen", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "resizing", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "quickAccessToolbarItemClick", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "frameChange", void 0);
    __decorate([
        Event()
    ], ImageEditor.prototype, "editComplete", void 0);
    ImageEditor = ImageEditor_1 = __decorate([
        NotifyPropertyChanges
    ], ImageEditor);
    return ImageEditor;
}(Component));

/**
 * An enum representing the file types supported by the image editor.
 *
 * @enum {string}
 */
var FileType;
(function (FileType) {
    /** The PNG file type. */
    FileType["Png"] = "Png";
    /** The JPEG file type. */
    FileType["Jpeg"] = "Jpeg";
    /** The SVG file type. */
    FileType["Svg"] = "Svg";
    /** The WebP file type. */
    FileType["WebP"] = "WebP";
})(FileType || (FileType = {}));
/**
 * An enumeration representing the direction of an image editor operation.
 *
 * @enum {string}
 */
var Direction;
(function (Direction) {
    /** The horizontal direction. */
    Direction["Horizontal"] = "Horizontal";
    /** The vertical direction. */
    Direction["Vertical"] = "Vertical";
})(Direction || (Direction = {}));
/**
 * An enumeration representing the type of shape to be added in the image editor.
 *
 * @enum {string}
 */
var ShapeType;
(function (ShapeType) {
    /** A rectangle shape. */
    ShapeType["Rectangle"] = "Rectangle";
    /** An ellipse shape. */
    ShapeType["Ellipse"] = "Ellipse";
    /** A line shape. */
    ShapeType["Line"] = "Line";
    /** An arrow shape. */
    ShapeType["Arrow"] = "Arrow";
    /** A path shape. */
    ShapeType["Path"] = "Path";
    /** A text shape. */
    ShapeType["Text"] = "Text";
    /** A freehand drawing shape. */
    ShapeType["FreehandDraw"] = "FreehandDraw";
    /** An Image shape. */
    ShapeType["Image"] = "Image";
})(ShapeType || (ShapeType = {}));
/**
 * An enumeration representing the different ways to trigger zooming in the image editor.
 *
 * @aspNumberEnum
 */
var ZoomTrigger;
(function (ZoomTrigger) {
    /** Zooming triggered by mouse wheel. */
    ZoomTrigger[ZoomTrigger["MouseWheel"] = 1] = "MouseWheel";
    /** Zooming triggered by pinch gesture. */
    ZoomTrigger[ZoomTrigger["Pinch"] = 2] = "Pinch";
    /** Zooming triggered by command keys. */
    ZoomTrigger[ZoomTrigger["Commands"] = 4] = "Commands";
    /** Zooming triggered by toolbar button click. */
    ZoomTrigger[ZoomTrigger["Toolbar"] = 8] = "Toolbar";
})(ZoomTrigger || (ZoomTrigger = {}));
/**
 * * An enum representing the available themes in the image editor.
 */
var Theme;
(function (Theme) {
    /** The Bootstrap 5 theme. */
    Theme["Bootstrap5"] = "Bootstrap5";
    /** The dark variant of the Bootstrap 5 theme. */
    Theme["Bootstrap5Dark"] = "Bootstrap5Dark";
    /** The Tailwind CSS theme. */
    Theme["Tailwind"] = "Tailwind";
    /** The dark variant of the Tailwind CSS theme. */
    Theme["TailwindDark"] = "TailwindDark";
    /** The Fluent UI theme. */
    Theme["Fluent"] = "Fluent";
    /** The dark variant of the Fluent UI theme. */
    Theme["FluentDark"] = "FluentDark";
    /** The Bootstrap 4 theme. */
    Theme["Bootstrap4"] = "Bootstrap4";
    /** The Bootstrap theme. */
    Theme["Bootstrap"] = "Bootstrap";
    /** The dark variant of the Bootstrap theme. */
    Theme["BootstrapDark"] = "BootstrapDark";
    /** The Material Design theme. */
    Theme["Material"] = "Material";
    /** The dark variant of the Material Design theme. */
    Theme["MaterialDark"] = "MaterialDark";
    /** The Fabric theme. */
    Theme["Fabric"] = "Fabric";
    /** The dark variant of the Fabric theme. */
    Theme["FabricDark"] = "FabricDark";
    /** The high contrast theme. */
    Theme["Highcontrast"] = "Highcontrast";
    /** The Fluent 2.0 UI theme. */
    Theme["Fluent2"] = "Fluent2";
    /** The dark variant of the Fluent 2.0 UI theme. */
    Theme["Fluent2Dark"] = "Fluent2Dark";
    /** The Tailwind 3 UI theme. */
    Theme["Tailwind3"] = "Tailwind3";
    /** The dark variant of the Tailwind 3 UI theme. */
    Theme["Tailwind3Dark"] = "Tailwind3Dark";
})(Theme || (Theme = {}));
/**
 * An enum representing the available toolbar commands in the image editor.
 */
var ImageEditorCommand;
(function (ImageEditorCommand) {
    ImageEditorCommand["Crop"] = "Crop";
    ImageEditorCommand["Transform"] = "Transform";
    ImageEditorCommand["Annotate"] = "Annotate";
    ImageEditorCommand["ZoomIn"] = "ZoomIn";
    ImageEditorCommand["ZoomOut"] = "ZoomOut";
    ImageEditorCommand["Open"] = "Open";
    ImageEditorCommand["Reset"] = "Reset";
    ImageEditorCommand["Save"] = "Save";
    ImageEditorCommand["Pan"] = "Pan";
    ImageEditorCommand["Move"] = "Move";
    ImageEditorCommand["Pen"] = "Pen";
    ImageEditorCommand["Line"] = "Line";
    ImageEditorCommand["Arrow"] = "Arrow";
    ImageEditorCommand["Path"] = "Path";
    ImageEditorCommand["Rectangle"] = "Rectangle";
    ImageEditorCommand["Image"] = "Image";
    ImageEditorCommand["Ellipse"] = "Ellipse";
    ImageEditorCommand["Text"] = "Text";
    ImageEditorCommand["CustomSelection"] = "CustomSelection";
    ImageEditorCommand["CircleSelection"] = "CircleSelection";
    ImageEditorCommand["SquareSelection"] = "SquareSelection";
    ImageEditorCommand["RatioSelection"] = "RatioSelection";
    ImageEditorCommand["RotateLeft"] = "RotateLeft";
    ImageEditorCommand["RotateRight"] = "RotateRight";
    ImageEditorCommand["FlipHorizontal"] = "FlipHorizontal";
    ImageEditorCommand["FlipVertical"] = "FlipVertical";
    ImageEditorCommand["Undo"] = "Undo";
    ImageEditorCommand["Redo"] = "Redo";
    ImageEditorCommand["None"] = "None";
    ImageEditorCommand["Mat"] = "Mat";
    ImageEditorCommand["Bevel"] = "Bevel";
    ImageEditorCommand["Inset"] = "Inset";
    ImageEditorCommand["Hook"] = "Hook";
    ImageEditorCommand["Finetune"] = "Finetune";
    ImageEditorCommand["Filter"] = "Filter";
    ImageEditorCommand["Frame"] = "Frame";
    ImageEditorCommand["Resize"] = "Resize";
    ImageEditorCommand["HorizontalFlip"] = "HorizontalFlip";
    ImageEditorCommand["VerticalFlip"] = "VerticalFlip";
    ImageEditorCommand["Brightness"] = "Brightness";
    ImageEditorCommand["Contrast"] = "Contrast";
    ImageEditorCommand["Hue"] = "Hue";
    ImageEditorCommand["Saturation"] = "Saturation";
    ImageEditorCommand["Opacity"] = "Opacity";
    ImageEditorCommand["Blur"] = "Blur";
    ImageEditorCommand["Exposure"] = "Exposure";
    ImageEditorCommand["Default"] = "Default";
    ImageEditorCommand["Chrome"] = "Chrome";
    ImageEditorCommand["Cold"] = "Cold";
    ImageEditorCommand["Warm"] = "Warm";
    ImageEditorCommand["Grayscale"] = "Grayscale";
    ImageEditorCommand["Sepia"] = "Sepia";
    ImageEditorCommand["Invert"] = "Invert";
    ImageEditorCommand["Straightening"] = "Straightening";
})(ImageEditorCommand || (ImageEditorCommand = {}));
/**
 * An enumeration of available image filter options.
 *
 * @remarks
 * These options can be used with the `applyImageFilter` method of the image editor control to apply filters to an image.
 */
var ImageFilterOption;
(function (ImageFilterOption) {
    /** Default filter */
    ImageFilterOption["Default"] = "Default";
    /** Chrome filter */
    ImageFilterOption["Chrome"] = "Chrome";
    /** Cold filter */
    ImageFilterOption["Cold"] = "Cold";
    /** Warm filter */
    ImageFilterOption["Warm"] = "Warm";
    /** Grayscale filter */
    ImageFilterOption["Grayscale"] = "Grayscale";
    /** Sepia filter */
    ImageFilterOption["Sepia"] = "Sepia";
    /** Invert filter */
    ImageFilterOption["Invert"] = "Invert";
})(ImageFilterOption || (ImageFilterOption = {}));
/**
 * An enumeration of available image finetune options.
 *
 * @remarks
 * These options can be used with the `finetuneImage` method of the image editor control to apply finetuning to an image.
 */
var ImageFinetuneOption;
(function (ImageFinetuneOption) {
    /** Adjust the brightness of the image */
    ImageFinetuneOption["Brightness"] = "Brightness";
    /** Adjust the contrast of the image */
    ImageFinetuneOption["Contrast"] = "Contrast";
    /** Adjust the hue of the image */
    ImageFinetuneOption["Hue"] = "Hue";
    /** Adjust the saturation of the image */
    ImageFinetuneOption["Saturation"] = "Saturation";
    /** Adjust the exposure of the image */
    ImageFinetuneOption["Exposure"] = "Exposure";
    /** Adjust the opacity of the image */
    ImageFinetuneOption["Opacity"] = "Opacity";
    /** Adjust the blur of the image */
    ImageFinetuneOption["Blur"] = "Blur";
})(ImageFinetuneOption || (ImageFinetuneOption = {}));
/**
 * Specifies the type of arrowhead should be drawn.
 *
 */
var ArrowheadType;
(function (ArrowheadType) {
    /** Indicates no arrowhead should be drawn. */
    ArrowheadType["None"] = "None";
    /** Indicates a normal triangle-shaped arrowhead should be drawn. */
    ArrowheadType["Arrow"] = "Arrow";
    /** Indicates a solid triangle-shaped arrowhead should be drawn. */
    ArrowheadType["SolidArrow"] = "SolidArrow";
    /** Indicates a circular-shaped arrowhead should be drawn. */
    ArrowheadType["Circle"] = "Circle";
    /** Indicates a solid circular-shaped arrowhead should be drawn. */
    ArrowheadType["SolidCircle"] = "SolidCircle";
    /** Indicates a square-shaped arrowhead should be drawn. */
    ArrowheadType["Square"] = "Square";
    /** Indicates a solid square-shaped arrowhead should be drawn. */
    ArrowheadType["SolidSquare"] = "SolidSquare";
    /** Indicates a bar shaped arrowhead should be drawn. */
    ArrowheadType["Bar"] = "Bar";
})(ArrowheadType || (ArrowheadType = {}));
/**
 * An enumeration of available frame options.
 *
 * @remarks
 * These options can be used with the `drawFrame` method of the image editor control to draw frames on an image.
 */
var FrameType;
(function (FrameType) {
    /** Represents a no frame. */
    FrameType["None"] = "None";
    /** Represents a mat frame. */
    FrameType["Mat"] = "Mat";
    /** Represents a bevel frame. */
    FrameType["Bevel"] = "Bevel";
    /** Represents a line frame. */
    FrameType["Line"] = "Line";
    /** Represents an inset frame. */
    FrameType["Inset"] = "Inset";
    /** Represents a hook frame. */
    FrameType["Hook"] = "Hook";
})(FrameType || (FrameType = {}));
/**
 * An enumeration of available line options.
 *
 * @remarks
 * These options can be used with the `drawFrame` method of the image editor control to draw frames on an image.
 */
var FrameLineStyle;
(function (FrameLineStyle) {
    /** Represents a solid line. */
    FrameLineStyle["Solid"] = "Solid";
    /** Represents a dashed line. */
    FrameLineStyle["Dashed"] = "Dashed";
    /** Represents a dotted line. */
    FrameLineStyle["Dotted"] = "Dotted";
})(FrameLineStyle || (FrameLineStyle = {}));
/**
 * An enumeration representing the type of redaction to be added in the image editor.
 *
 * @enum {string}
 */
var RedactType;
(function (RedactType) {
    /** Represents a blur redaction. */
    RedactType["Blur"] = "Blur";
    /** Represents a pixelate redaction. */
    RedactType["Pixelate"] = "Pixelate";
})(RedactType || (RedactType = {}));

var ToolbarModule = /** @class */ (function () {
    function ToolbarModule(parent) {
        this.defToolbarItems = [];
        this.toolbarHeight = 46;
        this.currToolbar = '';
        this.preventZoomBtn = false;
        this.currentToolbar = 'main';
        this.selFhdColor = '#42a5f5';
        this.preventEnableDisableUr = false;
        this.isAspectRatio = true;
        this.isFrameToolbar = false;
        this.presetColors = {
            'custom': ['#000000', '#f44336', '#e91e63', '#9c27b0', '#673ab7', '#2196f3',
                '#03a9f4', '#00bcd4', '#009688', '#ffeb3b', '#ffffff', '#ffebee', '#fce4ec', '#f3e5f5', '#ede7f6', '#e3f2fd',
                '#e1f5fe', '#e0f7fa', '#e0f2f1', '#fffde7', '#f2f2f2', '#ffcdd2', '#f8bbd0', '#e1bee7', '#d1c4e9', '#bbdefb',
                '#b3e5fc', '#b2ebf2', '#b2dfdb', '#fff9c4', '#e6e6e6', '#ef9a9a', '#f48fb1', '#ce93d8', '#b39ddb', '#90caf9',
                '#81d4fa', '#80deea', '#80cbc4', '#fff59d', '#cccccc', '#e57373', '#f06292', '#ba68c8', '#9575cd', '#64b5f6',
                '#4fc3f7', '#4dd0e1', '#4db6ac', '#fff176', '#b3b3b3', '#ef5350', '#ec407a', '#ab47bc', '#7e57c2', '#42a5f5',
                '#29b6f6', '#26c6da', '#26a69a', '#ffee58', '#999999', '#e53935', '#d81b60', '#8e24aa', '#5e35b1', '#1e88e5',
                '#039be5', '#00acc1', '#00897b', '#fdd835', '#808080', '#d32f2f', '#c2185b', '#7b1fa2', '#512da8', '#1976d2',
                '#0288d1', '#0097a7', '#00796b', '#fbc02d', '#666666', '#c62828', '#ad1457', '#6a1b9a', '#4527a0', '#1565c0',
                '#0277bd', '#00838f', '#00695c', '#f9a825', '#4d4d4d', '#b71c1c', '#880e4f', '#4a148c', '#311b92', '#0d47a1',
                '#01579b', '#006064', '#004d40', '#f57f17']
        };
        this.isSlider = false;
        this.currentQuality = 1;
        this.imageQuality = 'highest';
        this.parent = parent;
        this.addEventListener();
        this.initLocale();
    }
    ToolbarModule.prototype.destroy = function () {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    };
    ToolbarModule.prototype.addEventListener = function () {
        this.parent.on('toolbar', this.toolbar, this);
        this.parent.on('destroyed', this.destroy, this);
    };
    ToolbarModule.prototype.removeEventListener = function () {
        this.parent.off('toolbar', this.toolbar);
        this.parent.off('destroyed', this.destroy);
    };
    ToolbarModule.prototype.initLocale = function () {
        this.defaultLocale = {
            Crop: 'Crop',
            ZoomIn: 'Zoom In',
            ZoomOut: 'Zoom Out',
            Undo: 'Undo',
            Redo: 'Redo',
            Transform: 'Transform',
            Annotation: 'Annotation',
            Finetune: 'Finetune',
            Brightness: 'Brightness',
            Contrast: 'Contrast',
            Hue: 'Hue',
            Saturation: 'Saturation',
            Opacity: 'Opacity',
            Blur: 'Blur',
            Sharpen: 'Sharpen',
            Exposure: 'Exposure',
            Filter: 'Filter',
            Default: 'Default',
            Chrome: 'Chrome',
            Cold: 'Cold',
            Warm: 'Warm',
            Grayscale: 'Grayscale',
            BlackAndWhite: 'Black and White',
            Sepia: 'Sepia',
            Invert: 'Invert',
            Text: 'Add Text',
            Pen: 'Pen',
            Reset: 'Reset',
            Save: 'Save',
            Select: 'Select',
            RotateLeft: 'Rotate Left',
            RotateRight: 'Rotate Right',
            HorizontalFlip: 'Horizontal Flip',
            VerticalFlip: 'Vertical Flip',
            OK: 'Apply',
            Cancel: 'Discard',
            FillColor: 'Fill Color',
            StrokeColor: 'Stroke Color',
            StrokeWidth: 'Stroke Width',
            FontFamily: 'Font Family',
            FontStyle: 'Font Style',
            FontSize: 'Font Size',
            FontColor: 'Font Color',
            Pan: 'Pan',
            Move: 'Move',
            Load: 'Load',
            Custom: 'Custom',
            Square: 'Square',
            Circle: 'Circle',
            Ellipse: 'Ellipse',
            Rectangle: 'Rectangle',
            Line: 'Line',
            Arrow: 'Arrow',
            Path: 'Path',
            Bold: 'Bold',
            Italic: 'Italic',
            BoldItalic: 'Bold Italic',
            XSmall: 'X-Small',
            Small: 'Small',
            Medium: 'Medium',
            Large: 'Large',
            XLarge: 'X-Large',
            ABC: 'ABC',
            Browse: 'Browse',
            Duplicate: 'Duplicate',
            Remove: 'Remove',
            EditText: 'Edit Text',
            Start: 'Start',
            End: 'End',
            Bar: 'Bar',
            ArrowSolid: 'Arrow Solid',
            CircleSolid: 'Circle Solid',
            SquareSolid: 'Square Solid',
            None: 'None',
            CropAndTransform: 'Crop and Transform',
            CropSelection: 'Crop Selection',
            Image: 'Add Image',
            Transparency: 'Transparency',
            Height: 'Height',
            Width: 'Width',
            AspectRatio: 'Maintain aspect ratio',
            W: 'W',
            H: 'H',
            DragText: 'Drag and drop your image here or',
            DropText: 'Drop your image here or',
            BrowseText: 'Browse here...',
            SupportText: 'Supports:',
            Frame: 'Frame',
            Mat: 'Mat',
            Bevel: 'Bevel',
            Inset: 'Inset',
            Hook: 'Hook',
            Color: 'Color',
            Size: 'Size',
            Offset: 'Offset',
            Radius: 'Radius',
            Amount: 'Amount',
            Resize: 'Resize',
            0: '0%',
            20: '20%',
            40: '40%',
            60: '60%',
            80: '80%',
            100: '100%',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            Border: 'Border',
            Solid: 'Solid',
            Dashed: 'Dashed',
            Dotted: 'Dotted',
            GradientColor: 'Gradient Color',
            ConfirmDialogHeader: 'Confirm Save Changes',
            ConfirmDialogContent: 'Do you want to save the changes you made to the image?',
            AlertDialogHeader: 'Unsupported file',
            AlertDialogContent: 'The selected file is unsupported.',
            MinMaxSize: 'with file size between',
            MinMaxSizeAlert: 'File size between',
            MinSize: 'with minimum file size of',
            MinSizeAlert: 'A minimum file size of',
            MaxSize: 'with maximum file size of',
            MaxSizeAlert: 'A maximum file size of',
            To: 'to',
            Bytes: 'bytes',
            Yes: 'Yes',
            No: 'No',
            ImageErrorDialogHeader: 'Image Selection Error',
            ImageErrorDialogContent: 'Please select only one image to open.',
            Straighten: 'Straighten',
            NoOutline: 'No outline',
            DlgOK: 'OK',
            SaveAs: 'Save As',
            ImageName: 'Image name',
            Format: 'Format',
            Quality: 'Quality',
            Download: 'Download',
            Close: 'Close',
            ImageSize: 'Image Size',
            QualityInfo: 'The image quality option is only available for JPEG format',
            Good: 'Good',
            Great: 'Great',
            Highest: 'Highest',
            BringForward: 'Bring Forward',
            SendBackward: 'Send Backward',
            SendToBack: 'Send to Back',
            BringToFront: 'Bring to Front',
            ZOrder: 'Z-Order',
            Redact: 'Redact',
            Pixelate: 'Pixelate',
            BorderRadius: 'Border Radius',
            TextOutlineColor: 'Outline Color',
            TextOutlineWidth: 'Outline Width',
            PixelSize: 'Pixel Size',
            And: 'and'
        };
        this.l10n = new L10n('image-editor', this.defaultLocale, this.parent.locale);
    };
    ToolbarModule.prototype.toolbar = function (args) {
        var parent = this.parent;
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'create-toolbar':
                this.createToolbar();
                break;
            case 'create-contextual-toolbar':
                this.createContextualToolbar();
                break;
            case 'update-toolbar-items':
                this.updateToolbarItems();
                break;
            case 'refresh-toolbar':
                this.refreshToolbar(args.value['type'], args.value['isApplyBtn'], args.value['isCropping'], args.value['isZooming'], args.value['cType']);
                break;
            case 'renderQAT':
                this.renderQAT(args.value['isPenEdit']);
                break;
            case 'enable-disable-btns':
                this.enableDisableTbrBtn();
                break;
            case 'init-main-toolbar':
                this.initMainToolbar(args.value['isApplyBtn'], args.value['isDevice'], args.value['isOkBtn'], args.value['isResize'], args.value['isFrame'], args.value['isMainToolbar']);
                break;
            case 'create-bottom-toolbar':
                this.createBottomToolbar();
                break;
            case 'refresh-main-toolbar':
                this.refreshMainToolbar();
                break;
            case 'create-qa-toolbar':
                this.createQuickAccessToolbar();
                break;
            case 'destroy-qa-toolbar':
                this.destroyQuickAccessToolbar();
                break;
            case 'zoom-up-handler':
                this.zoomBtnMouseUpHandler();
                break;
            case 'refresh-dropdown-btn':
                this.refreshDropDownBtn(args.value['isDisabled']);
                break;
            case 'close-contextual-toolbar':
                this.closeContextualToolbar();
                break;
            case 'destroy-bottom-toolbar':
                this.destroyBottomToolbar();
                break;
            case 'destroy-top-toolbar':
                this.destroyTopToolbar();
                break;
            case 'destroySubComponents':
                this.destroySubComponents();
                break;
            case 'setLocale':
                this.l10n.setLocale(args.value['locale']);
                break;
            case 'setPreventZoomBtn':
                this.preventZoomBtn = args.value['isPrevent'];
                break;
            case 'getToolbarHeight':
                args.value['obj']['toolbarHeight'] = this.toolbarHeight;
                break;
            case 'setToolbarHeight':
                if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf('Open') > -1)) {
                    this.toolbarHeight = args.value['height'];
                }
                break;
            case 'setCurrentToolbar':
                this.currentToolbar = args.value['type'];
                break;
            case 'setSelectedFreehandColor':
                this.selFhdColor = args.value['color'];
                break;
            case 'setInitialAdjustmentValue':
                parent.initialAdjustmentValue = args.value['value'];
                break;
            case 'getCanvasFilter':
                args.value['obj']['canvasFilter'] = parent.canvasFilter;
                break;
            case 'getDefToolbarItems':
                args.value['obj']['defToolbarItems'] = this.defToolbarItems;
                break;
            case 'getPenStroke':
                this.getPenStroke(args.value['value']);
                break;
            case 'performDefToolbarClickAction':
                this.performDefTbrClick(args.value['type'], args.value['isContextualToolbar'], args.value['isDisabledAdjustment'], args.value['isDisabledFilter'], args.value['isFilterFinetune']);
                break;
            case 'setTempFilterProperties':
                parent.setTempFilterProperties();
                break;
            case 'refreshSlider':
                this.refreshSlider();
                break;
            case 'getCurrAdjustmentValue':
                parent.getCurrAdjustmentValue(args.value['type']);
                break;
            case 'setCurrAdjustmentValue':
                parent.setCurrAdjustmentValue(args.value['type'], args.value['value']);
                break;
            case 'refreshShapeDrawing':
                this.refreshShapeDrawing();
                break;
            case 'setEnableDisableUndoRedo':
                this.preventEnableDisableUr = args.value['isPrevent'];
                break;
            case 'reset':
                this.reset();
                break;
            case 'getLocaleText':
                args.value['obj']['value'] = this.l10n.getConstant(args.value['obj']['key']);
                break;
            case 'initResizeToolbar':
                this.initResizeToolbar();
                break;
            case 'getFrameToolbar':
                args.value['obj']['bool'] = this.isFrameToolbar;
                break;
            case 'resizeClick':
                this.resizeClick();
                break;
            case 'frameToolbarClick':
                this.frameToolbarClick();
                break;
            case 'performCropTransformClick':
                this.performCropTransformClick(args.value['shape'], args.value['isTransform']);
                break;
            case 'duplicateShape':
                this.duplicateShape(args.value['isPreventUndoRedo'], true);
                break;
            case 'editText':
                this.editText();
                break;
            case 'setInitialSize':
                this.initialSize = Number(args.value['value']);
                break;
            case 'widthPress':
                this.widthPress(args.value['e']);
                break;
            case 'heightPress':
                this.heightPress(args.value['e']);
                break;
            case 'widthAspectRatio':
                this.widthAspectRatio(args.value['e']);
                break;
            case 'heightAspectRatio':
                this.heightAspectRatio(args.value['e']);
                break;
            case 'cancelPan':
                this.cancelPan();
                break;
            case 'zoomInBtnMouseDownHandler':
                this.zoomInBtnMouseDownHandler(args.value['event']);
                break;
            case 'zoomOutBtnMouseDownHandler':
                this.zoomOutBtnMouseDownHandler(args.value['event']);
                break;
            case 'drawDashedLine':
                this.drawDashedLine(args.value['context']);
                break;
            case 'saveDialogClosed':
                this.saveDialogClosed(args.value['id']);
                break;
            case 'getIndex':
                this.getIndex(args.value['item']);
                break;
            case 'getRectRadius':
                this.getRectRadius(args.value['text']);
                break;
            case 'applyPreviewFilter':
                this.applyPreviewFilter();
                break;
            case 'renderSlider':
                this.renderSlider(args.value['type'], args.value['isSelect']);
                break;
            case 'zoomInBtnClickHandler':
                this.zoomInBtnClickHandler(args.value['e']);
                break;
            case 'zoomOutBtnClickHandler':
                this.zoomOutBtnClickHandler(args.value['e']);
                break;
            case 'getAdjustmentToolbarItem':
                this.getAdjustmentToolbarItem();
                break;
            case 'getFilterToolbarItem':
                this.getFilterToolbarItem();
                break;
            case 'renderCropBtn':
                this.renderCropBtn();
                break;
        }
    };
    ToolbarModule.prototype.updatePrivateVariables = function () {
        var parent = this.parent;
        this.inMemoryCanvas = parent.inMemoryCanvas;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
        if (this.inMemoryCanvas) {
            this.inMemoryContext = this.inMemoryCanvas.getContext('2d');
        }
    };
    ToolbarModule.prototype.reset = function () {
        var parent = this.parent;
        this.toolbarHeight = 46;
        parent.prevCurrSelectionPoint = null;
        this.zoomBtnHold = null;
        this.currToolbar = '';
        parent.cxtTbarHeight = null;
        this.currentToolbar = 'main';
        this.selFhdColor = '#42a5f5';
        parent.currentFilter = '';
        this.preventZoomBtn = parent.isCropToolbar = this.preventEnableDisableUr = this.isFrameToolbar = false;
        parent.initialAdjustmentValue = parent.canvasFilter =
            'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
        parent.tempStraighten = 0;
        parent.isStraightening = false;
    };
    ToolbarModule.prototype.destroyTopToolbar = function () {
        var parent = this.parent;
        var toolbar = document.getElementById(parent.element.id + '_toolbar');
        if (this.isToolbar() && toolbar && toolbar.classList.contains('e-control')) {
            getComponent(toolbar, 'toolbar').destroy();
        }
    };
    ToolbarModule.prototype.destroyBottomToolbar = function () {
        var parent = this.parent;
        var toolbar = document.getElementById(parent.element.id + '_bottomToolbar');
        if (toolbar && toolbar.classList.contains('e-control')) {
            getComponent(toolbar, 'toolbar').destroy();
        }
    };
    ToolbarModule.prototype.isToolbar = function () {
        var parent = this.parent;
        return (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)
            || !isNullOrUndefined(parent.toolbarTemplate));
    };
    ToolbarModule.prototype.createToolbar = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            parent.element.appendChild(parent.createElement('div', {
                id: id + '_toolbarArea', className: 'e-toolbar-area'
            }));
            var toolbarItems = { cssClass: 'e-image-upload', align: 'Left', type: 'Input',
                tooltipText: this.l10n.getConstant('Browse'), template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false }) };
            if (isNullOrUndefined(this.defToolbarItems)) {
                this.defToolbarItems = [];
            }
            this.defToolbarItems.push(toolbarItems);
            var toolbarArea = document.getElementById(id + '_toolbarArea');
            var toolbar_1 = parent.createElement('div', { id: id + '_toolbar' });
            toolbarArea.appendChild(toolbar_1);
            var uploadItems = [
                {
                    cssClass: 'e-image-upload',
                    align: 'Left', type: 'Input',
                    tooltipText: this.l10n.getConstant('Browse'),
                    template: new Uploader({
                        allowedExtensions: parent.uploadSettings.allowedExtensions,
                        multiple: false,
                        selected: function () {
                            var toolbar = document.getElementById(id + '_toolbar');
                            var bToolbar = document.getElementById(id + '_bottomToolbar');
                            if (!parent.disabled) {
                                if (Browser.isDevice) {
                                    if (_this.defToolbarItems.length > 0 && toolbar) {
                                        getComponent(toolbar, 'toolbar').destroy();
                                    }
                                    if (bToolbar) {
                                        getComponent(bToolbar, 'toolbar').destroy();
                                    }
                                    _this.initMainToolbar(false, Browser.isDevice, null);
                                    _this.createBottomToolbar();
                                }
                                else {
                                    if (_this.defToolbarItems.length > 0 && toolbar) {
                                        getComponent(toolbar, 'toolbar').destroy();
                                    }
                                    _this.initMainToolbar(false, false, null);
                                }
                            }
                        }
                    })
                }
            ];
            var toolbarObj = new Toolbar({ items: uploadItems, width: '100%',
                created: function () {
                    parent.trigger('toolbarCreated', { toolbarType: 'main' });
                },
                clicked: this.defToolbarClicked.bind(this) });
            toolbarObj.appendTo('#' + id + '_toolbar');
            this.createLeftToolbarControls();
            var mToolbar = document.getElementById(id + '_toolbar');
            if (toolbar_1) {
                this.toolbarHeight = mToolbar.clientHeight;
                if (parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf('Open') === -1) {
                    var toolabr = getComponent(document.getElementById(parent.element.id + '_toolbar'), 'toolbar');
                    if (toolabr) {
                        toolabr.destroy();
                        document.getElementById(parent.element.id + '_toolbar').innerHTML = '';
                    }
                }
            }
        }
        else {
            this.toolbarHeight = 0;
        }
    };
    ToolbarModule.prototype.createContextualToolbar = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            var contextualToolbarArea = parent.createElement('div', { id: id + '_contextualToolbarArea', className: 'e-contextual-toolbar-wrapper e-hide' });
            contextualToolbarArea.style.position = 'absolute';
            parent.element.appendChild(contextualToolbarArea);
            var toolbarArea = document.getElementById(id + '_contextualToolbarArea');
            var toolbar_2 = parent.createElement('div', { id: id + '_contextualToolbar' });
            toolbarArea.appendChild(toolbar_2);
        }
    };
    ToolbarModule.prototype.createBottomToolbar = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if (parent.element.querySelector('#' + id + '_bottomToolbarArea')) {
            parent.element.querySelector('#' + id + '_bottomToolbarArea').remove();
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            parent.element.appendChild(parent.createElement('div', {
                id: id + '_bottomToolbarArea', className: 'e-bottom-toolbar'
            }));
            if (!parent.toolbarTemplate) {
                var toolbarArea = document.getElementById(id + '_bottomToolbarArea');
                var toolbarElem = parent.createElement('div', {
                    id: id + '_bottomToolbar'
                });
                toolbarArea.appendChild(toolbarElem);
            }
            this.initBottomToolbar();
        }
    };
    ToolbarModule.prototype.createQuickAccessToolbar = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if (parent.showQuickAccessToolbar) {
            var toolbarItems = { cssClass: 'e-image-upload', align: 'Left', type: 'Input',
                tooltipText: this.l10n.getConstant('Browse'), template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false }) };
            if (isNullOrUndefined(this.defToolbarItems)) {
                this.defToolbarItems = [];
            }
            this.defToolbarItems.push(toolbarItems);
            var toolbarArea = document.getElementById(id + '_quickAccessToolbarArea');
            var toolbar_3 = parent.createElement('div', {
                id: id + '_quickAccessToolbar'
            });
            toolbarArea.appendChild(toolbar_3);
            var toolbarObj = new Toolbar({ clicked: this.defToolbarClicked.bind(this) });
            toolbarObj.appendTo('#' + id + '_quickAccessToolbar');
        }
    };
    ToolbarModule.prototype.initMainToolbar = function (isApplyOption, isDevice, isOkBtn, isResize, isFrame, isMainToolbar, isRedact) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (this.isToolbar()) {
            var leftItem = this.getLeftToolbarItem(isOkBtn, isResize);
            var rightItem = this.getRightToolbarItem(isOkBtn, isMainToolbar, isRedact);
            var mainItem = this.getMainToolbarItem(isApplyOption, isFrame, isRedact);
            var zoomItem = this.getZoomToolbarItem();
            if (isDevice) {
                if (isFrame || isRedact) {
                    this.defToolbarItems = mainItem;
                }
                else {
                    this.defToolbarItems = leftItem.concat(rightItem);
                }
            }
            else {
                this.defToolbarItems = leftItem.concat(mainItem, rightItem, zoomItem);
            }
            var args = { toolbarType: 'main', toolbarItems: this.defToolbarItems };
            parent.trigger('toolbarUpdating', args);
            this.defToolbarItems = args.toolbarItems;
            if (this.defToolbarItems.length > 0) {
                var toolbarObj = new Toolbar({
                    width: '100%',
                    items: this.defToolbarItems,
                    clicked: this.defToolbarClicked.bind(this),
                    created: function () {
                        if (!isDevice) {
                            _this.renderAnnotationBtn();
                        }
                        _this.wireZoomBtnEvents();
                        parent.trigger('toolbarCreated', { toolbarType: 'main' });
                    }
                });
                if ((isDevice && isFrame) || (isDevice && isRedact)) {
                    toolbarObj.appendTo('#' + id + '_bottomToolbar');
                }
                else {
                    toolbarObj.appendTo('#' + id + '_toolbar');
                }
                this.createLeftToolbarControls();
                this.enableDisableTbrBtn();
                if (this.isToolbar() && document.getElementById(id + '_toolbar')) {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    var toolbar_4 = getComponent(id + '_toolbar', 'toolbar');
                    toolbar_4.refreshOverflow();
                }
            }
        }
    };
    ToolbarModule.prototype.initBottomToolbar = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            var items = this.getMainToolbarItem();
            var args = { toolbarType: 'bottom-toolbar', toolbarItems: items };
            parent.trigger('toolbarUpdating', args);
            items = args.toolbarItems;
            var toolbarObj = new Toolbar({ items: items, width: '100%',
                created: function () {
                    _this.renderAnnotationBtn();
                    _this.renderCropBtn();
                    _this.renderTransformBtn();
                    parent.trigger('toolbarCreated', { toolbarType: 'main' });
                },
                clicked: this.defToolbarClicked.bind(this)
            });
            toolbarObj.appendTo('#' + id + '_bottomToolbar');
            if (this.defToolbarItems.length > 0 && document.getElementById(id + '_bottomToolbar')) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                var toolbar_5 = getComponent(id + '_bottomToolbar', 'toolbar');
                toolbar_5.refreshOverflow();
            }
        }
    };
    ToolbarModule.prototype.getLeftToolbarItem = function (isOkBtn, isResize) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        if (!isOkBtn || isResize) {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Open') > -1)) {
                toolbarItems.push({ id: id + '_upload', cssClass: 'e-image-upload', align: 'Left', type: 'Input', template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false }) });
                toolbarItems.push({ visible: false, cssClass: 'e-image-position e-btn e-flat', tooltipText: this.l10n.getConstant('Browse'), align: 'Left' });
            }
            else if (Browser.isDevice && (parent.toolbar && parent.toolbar.indexOf('Open') === -1)) {
                toolbarItems.push({ visible: false, id: id + '_upload', cssClass: 'e-image-upload', align: 'Left', type: 'Input', template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false }) });
                toolbarItems.push({ visible: false, cssClass: 'e-image-position e-btn e-flat', tooltipText: this.l10n.getConstant('Browse'), align: 'Left' });
            }
        }
        if (parent.allowUndoRedo && !isResize) {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Undo') > -1)) {
                toolbarItems.push({ id: id + '_undo', prefixIcon: 'e-icons e-undo', cssClass: 'top-icon e-undo',
                    tooltipText: this.l10n.getConstant('Undo'), align: 'Left' });
            }
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Redo') > -1)) {
                toolbarItems.push({ id: id + '_redo', prefixIcon: 'e-icons e-redo', cssClass: 'top-icon e-redo',
                    tooltipText: this.l10n.getConstant('Redo'), align: 'Left' });
            }
        }
        if (!this.preventZoomBtn && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar && !isResize) {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('ZoomOut') > -1)) {
                toolbarItems.push({ id: id + '_zoomOut', prefixIcon: 'e-icons e-zoom-out', cssClass: 'top-icon e-dec-zoom',
                    tooltipText: this.l10n.getConstant('ZoomOut'), align: 'Left' });
            }
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('ZoomIn') > -1)) {
                toolbarItems.push({ id: id + '_zoomIn', prefixIcon: 'e-icons e-zoom-in', cssClass: 'top-icon e-inc-zoom',
                    tooltipText: this.l10n.getConstant('ZoomIn'), align: 'Left' });
            }
        }
        var tempToolbarItems = this.processToolbar('left');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getRightToolbarItem = function (isOkBtn, isMainToolbar, isRedact) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        if (isOkBtn || isRedact) {
            toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
            toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        if ((isMainToolbar || !Browser.isDevice) && (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Reset') > -1))) {
            toolbarItems.push({ id: id + '_reset', prefixIcon: 'e-icons e-btn-reset', cssClass: 'top-icon e-img-reset',
                tooltipText: this.l10n.getConstant('Reset'), align: 'Right' });
        }
        if (!isOkBtn) {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Save') > -1)) {
                toolbarItems.push({ id: id + '_save', prefixIcon: 'e-icons e-btn-save', cssClass: 'e-caret-hide top-icon e-save',
                    tooltipText: this.l10n.getConstant('Save'), align: 'Right' });
            }
        }
        var tempToolbarItems = this.processToolbar('right');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getMainToolbarItem = function (isApplyOption, isFrame, isRedact) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        if (isFrame) {
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('None') > -1) || parent.toolbar.indexOf('Frame') > -1) {
                toolbarItems.push({ id: id + '_none', prefixIcon: 'e-icons e-frame-none', cssClass: 'top-icon e-frame-none',
                    tooltipText: this.l10n.getConstant('None'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Mat') > -1) || parent.toolbar.indexOf('Frame') > -1) {
                toolbarItems.push({ id: id + '_mat', prefixIcon: 'e-icons e-frame-mat', cssClass: 'top-icon e-frame-mat',
                    tooltipText: this.l10n.getConstant('Mat'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Bevel') > -1) || parent.toolbar.indexOf('Frame') > -1) {
                toolbarItems.push({ id: id + '_bevel', prefixIcon: 'e-icons e-frame-bevel', cssClass: 'top-icon e-frame-bevel',
                    tooltipText: this.l10n.getConstant('Bevel'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Line') > -1) || parent.toolbar.indexOf('Frame') > -1) {
                toolbarItems.push({ id: id + '_line', prefixIcon: 'e-icons e-frame-line', cssClass: 'top-icon e-frame-line',
                    tooltipText: this.l10n.getConstant('Line'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Inset') > -1) || parent.toolbar.indexOf('Frame') > -1) {
                toolbarItems.push({ id: id + '_inset', prefixIcon: 'e-icons e-frame-inset', cssClass: 'top-icon e-frame-inset',
                    tooltipText: this.l10n.getConstant('Inset'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Hook') > -1) || parent.toolbar.indexOf('Frame') > -1) {
                toolbarItems.push({ id: id + '_hook', prefixIcon: 'e-icons e-frame-hook', cssClass: 'top-icon e-frame-hook',
                    tooltipText: this.l10n.getConstant('Hook'), align: 'Center' });
            }
        }
        else if (isRedact) {
            toolbarItems.push({ id: id + '_redactBlur', prefixIcon: 'e-icons e-tint', cssClass: 'top-icon e-opacity',
                tooltipText: this.l10n.getConstant('Blur'), align: 'Center' });
            toolbarItems.push({ id: id + '_pixelate', prefixIcon: 'e-icons e-opacity', cssClass: 'top-icon e-opacity',
                tooltipText: this.l10n.getConstant('Pixelate'), align: 'Center' });
            toolbarItems.push({ id: id + '_duplicate', prefixIcon: 'e-icons e-order', cssClass: 'top-icon e-order',
                tooltipText: this.l10n.getConstant('Duplicate'), align: 'Center' });
            toolbarItems.push({ id: id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                tooltipText: this.l10n.getConstant('Remove'), align: 'Center' });
        }
        else {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Crop') > -1)) {
                toolbarItems.push({ id: id + '_cropTransform', prefixIcon: 'e-icons e-crop', cssClass: 'top-icon e-crop',
                    tooltipText: this.l10n.getConstant('CropAndTransform'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Annotate') > -1)) {
                toolbarItems.push({ id: id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                    template: '<button id="' + id + '_annotationBtn"></button>' });
            }
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Finetune') > -1)) {
                toolbarItems.push({ id: id + '_adjustment', prefixIcon: 'e-icons e-adjustment', cssClass: 'top-icon e-adjustment',
                    tooltipText: this.l10n.getConstant('Finetune'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Filter') > -1)) {
                toolbarItems.push({ id: id + '_filter', prefixIcon: 'e-icons e-filters', cssClass: 'top-icon e-filters',
                    tooltipText: this.l10n.getConstant('Filter'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Frame') > -1)) {
                toolbarItems.push({ id: id + '_frame', prefixIcon: 'e-icons e-border-frame', cssClass: 'top-icon e-border-frame',
                    tooltipText: this.l10n.getConstant('Frame'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Resize') > -1)) {
                toolbarItems.push({ id: id + '_resize', prefixIcon: 'e-icons e-resize', cssClass: 'top-icon e-resize',
                    tooltipText: this.l10n.getConstant('Resize'), align: 'Center' });
            }
            if (isNullOrUndefined(parent.toolbar) || (!isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf('Redact') > -1)) {
                toolbarItems.push({ id: id + '_redact', prefixIcon: 'e-icons e-redact', cssClass: 'top-icon e-opacity',
                    tooltipText: this.l10n.getConstant('Redact'), align: 'Center' });
            }
        }
        var tempToolbarItems = this.processToolbar('center');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (isApplyOption) {
            toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
            toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getZoomToolbarItem = function () {
        var toolbarItems = [];
        return toolbarItems;
    };
    ToolbarModule.prototype.updateContextualToolbar = function (type, cType, isSelect) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarArea = parent.element.querySelector('#' + id + '_toolbarArea');
        var contextualToolbarArea = parent.element.querySelector('#' + id + '_contextualToolbarArea');
        if (!contextualToolbarArea) {
            return;
        }
        contextualToolbarArea.classList.remove('e-hide');
        contextualToolbarArea.style.left = toolbarArea.offsetLeft + 'px';
        if (type === 'filter') {
            var toolbar_6 = document.getElementById(id + '_toolbar');
            if (toolbar_6 && this.defToolbarItems.length > 0) {
                getComponent(toolbar_6, 'toolbar').destroy();
            }
            if (Browser.isDevice) {
                this.initMainToolbar(false, true, true);
            }
            else {
                this.initMainToolbar(true, null, null);
            }
            this.refreshSlider();
            this.initFilterToolbarItem();
        }
        else {
            var ctxToolbar = document.querySelector('#' + id + '_contextualToolbar');
            if (ctxToolbar.classList.contains('e-control')) {
                getComponent(ctxToolbar, 'toolbar').destroy();
            }
            this.refreshSlider();
            if (type === 'frame') {
                this.initFrameToolbarItem();
            }
            else {
                this.renderSlider(cType, isSelect);
            }
        }
        if (parent.toolbarTemplate) {
            this.toolbarHeight = parent.element.querySelector('#' + id + '_toolbarArea').clientHeight;
        }
        else if (parent.element.querySelector('#' + id + '_toolbar')) {
            this.toolbarHeight = parent.element.querySelector('#' + id + '_toolbar').clientHeight;
        }
        parent.toolbarHeight = this.toolbarHeight;
        if (Browser.isDevice) {
            var cHt = contextualToolbarArea.offsetHeight + 1;
            var cusWrapper = parent.element.querySelector('#' + id + '_customizeWrapper');
            if (this.isFrameToolbar && cusWrapper) {
                cHt = cusWrapper.offsetHeight + 2;
            }
            var ht = parent.element.querySelector('#' + id + '_canvasWrapper').offsetHeight;
            contextualToolbarArea.style.top = this.toolbarHeight + 1 + ht - cHt + 'px';
            if (cType === 'straighten') {
                parent.isStraightening = true;
                var ctxToolbar = parent.element.querySelector('#' + id + '_contextualToolbarArea');
                if (ctxToolbar.style.position === 'absolute') {
                    ctxToolbar.style.position = '';
                    parent.element.insertBefore(ctxToolbar, parent.element.querySelector('#' + id + '_bottomToolbarArea'));
                    parent.update();
                    if (isSelect) {
                        parent.notify('draw', { prop: 'select', onPropertyChange: false,
                            value: { type: this.getCropTextContent(document.getElementById(id + '_cropBtn')).toLowerCase(),
                                startX: null, startY: null, width: null, height: null } });
                    }
                }
            }
        }
        else {
            contextualToolbarArea.style.top = this.toolbarHeight + 1 + 'px';
        }
    };
    ToolbarModule.prototype.processToolbar = function (position) {
        var parent = this.parent;
        var toolbarItems = [];
        if (parent.toolbar) {
            for (var i = 0, len = parent.toolbar.length; i < len; i++) {
                if (typeof (parent.toolbar[i]) === 'object') {
                    if (isNullOrUndefined(parent.toolbar[i].align)) {
                        if (position === 'left') {
                            toolbarItems.push(parent.toolbar[i]);
                        }
                    }
                    else if (parent.toolbar[i].align.toLowerCase() === position) {
                        toolbarItems.push(parent.toolbar[i]);
                    }
                }
            }
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.processSubToolbar = function (items) {
        var toolbarItems = [];
        if (items) {
            for (var i = 0, len = items.length; i < len; i++) {
                if (typeof (items[i]) === 'object') {
                    items[i].align = 'Center';
                    toolbarItems.push(items[i]);
                }
            }
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.wireZoomBtnEvents = function () {
        var zoomIn = document.querySelector('#' + this.parent.element.id + '_zoomIn');
        var zoomOut = document.querySelector('#' + this.parent.element.id + '_zoomOut');
        if (zoomIn) {
            zoomIn.addEventListener('mousedown', this.zoomInBtnMouseDownHandler.bind(this));
            zoomIn.addEventListener('mouseup', this.zoomBtnMouseUpHandler.bind(this));
            zoomIn.addEventListener('click', this.zoomInBtnClickHandler.bind(this));
        }
        if (zoomOut) {
            zoomOut.addEventListener('mousedown', this.zoomOutBtnMouseDownHandler.bind(this));
            zoomOut.addEventListener('mouseup', this.zoomBtnMouseUpHandler.bind(this));
            zoomOut.addEventListener('click', this.zoomOutBtnClickHandler.bind(this));
        }
    };
    ToolbarModule.prototype.widthPress = function (e) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if (e.keyCode === 109) {
            e.preventDefault();
            return;
        }
    };
    ToolbarModule.prototype.heightPress = function (e) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if (e.keyCode === 109) {
            e.preventDefault();
            return;
        }
    };
    ToolbarModule.prototype.widthAspectRatio = function (e) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if (e.keyCode === 109 || e.keyCode === 9) {
            return;
        }
        var parent = this.parent;
        var id = parent.element.id;
        var aspectRatioHeight = parent.element.querySelector('#' + id + '_resizeHeight');
        var aspectRatioWidth = parent.element.querySelector('#' + id + '_resizeWidth');
        var icon = parent.element.querySelector('#' + id + '_aspectratio');
        var originalWidth = parent.img.destWidth;
        var originalHeight = parent.img.destHeight;
        var aspectRatioHeightValue = parseFloat(aspectRatioHeight.value);
        var val = aspectRatioHeightValue / (originalHeight / originalWidth);
        var width = val % 1 >= 0.5 || val % 1 <= -0.5 ? Math.round(val) : (val < 0) ? Math.ceil(val) : Math.floor(val);
        var widthNumeric = getComponent(aspectRatioWidth, 'numerictextbox');
        var heightNumeric = getComponent(aspectRatioWidth, 'numerictextbox');
        if (icon) {
            if (width != null && !isNaN(width)) {
                if (isNullOrUndefined((widthNumeric).value)) {
                    (widthNumeric).placeholder = width + ' px';
                    aspectRatioWidth.placeholder = width.toString() + ' px';
                }
                else {
                    (widthNumeric).value = width;
                    aspectRatioWidth.value = width.toString() + ' px';
                }
            }
            else {
                if (isNullOrUndefined((widthNumeric).value)) {
                    (widthNumeric).placeholder = '0 px';
                    aspectRatioWidth.placeholder = '0 px';
                    if (isNullOrUndefined(heightNumeric.value) && !isNullOrUndefined(heightNumeric.placeholder)) {
                        (widthNumeric).placeholder = "" + parent.img.srcWidth;
                        aspectRatioWidth.placeholder = "" + parent.img.srcWidth;
                    }
                }
                else {
                    (widthNumeric).value = 0;
                    aspectRatioWidth.value = '0 px';
                }
            }
        }
    };
    ToolbarModule.prototype.heightAspectRatio = function (e) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        if (e.keyCode === 109 || e.keyCode === 9) {
            return;
        }
        var parent = this.parent;
        var id = parent.element.id;
        var aspectRatioHeight = parent.element.querySelector('#' + id + '_resizeHeight');
        var aspectRatioWidth = parent.element.querySelector('#' + id + '_resizeWidth');
        var icon = parent.element.querySelector('#' + id + '_aspectratio');
        var originalWidth = parent.img.destWidth;
        var originalHeight = parent.img.destHeight;
        var aspectRatioWidthValue = parseFloat(aspectRatioWidth.value);
        var value = aspectRatioWidthValue / (originalWidth / originalHeight);
        var ht = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : (value < 0) ? Math.ceil(value) : Math.floor(value);
        var heightNumeric = getComponent(aspectRatioHeight, 'numerictextbox');
        var widthNumeric = getComponent(aspectRatioWidth, 'numerictextbox');
        if (icon) {
            if (!isNaN(ht)) {
                if (isNullOrUndefined((heightNumeric).value)) {
                    (heightNumeric).placeholder = ht + ' px';
                    aspectRatioHeight.placeholder = ht.toString() + ' px';
                }
                else {
                    (heightNumeric).value = ht;
                    aspectRatioHeight.value = ht.toString() + ' px';
                }
            }
            else {
                if (isNullOrUndefined((heightNumeric).value)) {
                    (heightNumeric).placeholder = '0 px';
                    aspectRatioHeight.placeholder = '0 px';
                    if (isNullOrUndefined(widthNumeric.value) && !isNullOrUndefined(widthNumeric.placeholder)) {
                        (heightNumeric).placeholder = "" + parent.img.srcHeight;
                        aspectRatioHeight.placeholder = "" + parent.img.srcHeight;
                    }
                }
                else {
                    (heightNumeric).value = 0;
                    aspectRatioHeight.value = '0 px';
                }
            }
        }
    };
    ToolbarModule.prototype.getResizeToolbarItem = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var isResize = parent.aspectWidth && parent.aspectHeight ? true : false;
        var width = this.parent.transform.degree % 90 === 0 && this.parent.transform.degree % 180 !== 0 ?
            Math.ceil(this.parent.img.srcHeight).toString() : Math.ceil(this.parent.img.srcWidth).toString();
        var height = this.parent.transform.degree % 90 === 0 && this.parent.transform.degree % 180 !== 0 ?
            Math.ceil(this.parent.img.srcWidth).toString() : Math.ceil(this.parent.img.srcHeight).toString();
        var toolbarItems = [];
        var spanWidth = document.createElement('span');
        spanWidth.innerHTML = this.l10n.getConstant('W');
        toolbarItems.push({ id: id + '_width', cssClass: 'e-ie-resize-width', template: spanWidth, align: 'Center' });
        toolbarItems.push({ id: id + '_resizeWidth', prefixIcon: 'e-icons e-anti-clock-wise',
            tooltipText: this.l10n.getConstant('Width'), align: 'Center', type: 'Input', template: new NumericTextBox({ width: 75, htmlAttributes: { maxLength: '4' },
                showSpinButton: false, value: isResize ? parent.aspectWidth : null,
                placeholder: isResize ? null : width, format: '###.## px' })
        });
        var spanHeight = document.createElement('span');
        spanHeight.innerHTML = this.l10n.getConstant('H');
        toolbarItems.push({ id: id + '_height', cssClass: 'e-ie-resize-height', template: spanHeight, align: 'Center' });
        toolbarItems.push({ id: id + '_resizeHeight', prefixIcon: 'e-icons e-clock-wise',
            tooltipText: this.l10n.getConstant('Height'), align: 'Center', type: 'Input', template: new NumericTextBox({ width: 75, htmlAttributes: { maxLength: '4' },
                showSpinButton: false, value: isResize ? parent.aspectHeight : null,
                placeholder: isResize ? null : height, format: '###.## px' })
        });
        if (!this.isAspectRatio) {
            toolbarItems.push({ id: id + '_aspectratio', prefixIcon: 'e-icons e-lock', align: 'Center',
                tooltipText: this.l10n.getConstant('AspectRatio'), type: 'Button', tabIndex: 0 });
            this.isAspectRatio = true;
        }
        else {
            toolbarItems.push({ id: id + '_nonaspectratio', prefixIcon: 'e-icons e-unlock', align: 'Center', tooltipText: this.l10n.getConstant('AspectRatio'), type: 'Button' });
            this.isAspectRatio = false;
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
            toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.initResizeToolbar = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var leftItem = this.getLeftToolbarItem(false, true);
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getResizeToolbarItem();
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var args = { toolbarType: 'resize', toolbarItems: this.defToolbarItems };
        parent.trigger('toolbarUpdating', args);
        this.defToolbarItems = args.toolbarItems;
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.wireResizeBtnEvents();
                parent.trigger('toolbarCreated', { toolbarType: 'shapes' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(id + '_bottomToolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && (!isNullOrUndefined(document.getElementById(id + '_toolbar')))) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + id + '_toolbar');
        }
        parent.isResize = false;
        this.enableDisableTbrBtn();
        parent.isResize = true;
        parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
    };
    ToolbarModule.prototype.wireResizeBtnEvents = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var aspectRatioHeight = parent.element.querySelector('#' + id + '_resizeHeight');
        var aspectRatioWidth = parent.element.querySelector('#' + id + '_resizeWidth');
        if (!isNullOrUndefined(aspectRatioHeight)) {
            aspectRatioHeight.addEventListener('keydown', this.widthPress.bind(this));
            aspectRatioWidth.addEventListener('keyup', this.heightAspectRatio.bind(this));
        }
        if (!isNullOrUndefined(aspectRatioWidth)) {
            aspectRatioWidth.addEventListener('keydown', this.heightPress.bind(this));
            aspectRatioHeight.addEventListener('keyup', this.widthAspectRatio.bind(this));
        }
    };
    ToolbarModule.prototype.enableDisableTbrBtn = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if (!this.preventEnableDisableUr) {
            var object = { appliedUndoRedoColl: [] };
            parent.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: object } });
            var undoRedoObj = { undoRedoStep: null };
            parent.notify('undo-redo', { prop: 'getUndoRedoStep', value: { obj: undoRedoObj } });
            var undo = parent.element.querySelector('#' + id + '_undo');
            if (undo && undoRedoObj['undoRedoStep'] === 0) {
                undo.classList.add('e-disabled');
                undo.parentElement.classList.add('e-overlay');
            }
            else if (undo && undoRedoObj['undoRedoStep'] > 0) {
                undo.classList.remove('e-disabled');
                undo.parentElement.classList.remove('e-overlay');
            }
            var redo = parent.element.querySelector('#' + id + '_redo');
            if (redo && (undoRedoObj['undoRedoStep'] === object['appliedUndoRedoColl'].length)) {
                redo.classList.add('e-disabled');
                redo.parentElement.classList.add('e-overlay');
            }
            else if (redo && (undoRedoObj['undoRedoStep'] === 0 && object['appliedUndoRedoColl'].length > 0)) {
                redo.classList.remove('e-disabled');
                redo.parentElement.classList.remove('e-overlay');
            }
            else if (redo && undoRedoObj['undoRedoStep'] > 0) {
                redo.classList.remove('e-disabled');
                redo.parentElement.classList.remove('e-overlay');
            }
        }
        var zoomIn = document.querySelector('#' + id + '_zoomIn');
        if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
            zoomIn.classList.add('e-disabled');
            zoomIn.parentElement.classList.add('e-overlay');
        }
        else if (zoomIn) {
            zoomIn.classList.remove('e-disabled');
            zoomIn.parentElement.classList.remove('e-overlay');
        }
        var zoomOut = document.querySelector('#' + id + '_zoomOut');
        if (zoomOut && parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
            zoomOut.classList.add('e-disabled');
            zoomOut.parentElement.classList.add('e-overlay');
        }
        else if (zoomOut) {
            zoomOut.classList.remove('e-disabled');
            zoomOut.parentElement.classList.remove('e-overlay');
        }
        var frame = document.querySelector('#' + id + '_frame');
        if (frame && ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop)) {
            frame.classList.add('e-overlay');
        }
        else if (frame) {
            frame.classList.remove('e-overlay');
        }
        var ratio = document.querySelector('#' + id + '_aspectratio');
        if (ratio && ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop)) {
            ratio.classList.add('e-overlay');
        }
        else if (ratio) {
            ratio.classList.remove('e-overlay');
        }
    };
    ToolbarModule.prototype.createLeftToolbarControls = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if (this.defToolbarItems !== undefined && this.defToolbarItems.length > 0 &&
            (document.getElementById(id + '_toolbar'))) {
            var uploadDiv = document.getElementById(id + '_toolbar')
                .querySelector('.e-image-upload');
            if (uploadDiv) {
                var uploadElem = uploadDiv.getElementsByTagName('input')[0];
                var uploadBtnElem = uploadDiv.getElementsByTagName('button')[0];
                uploadBtnElem.className = 'e-tbar-btn e-tbtn-txt top-icon';
                uploadBtnElem.innerHTML = '';
                uploadBtnElem.title = this.l10n.getConstant('Browse');
                uploadBtnElem.appendChild(parent.createElement('span', {
                    className: 'e-btn-icon e-icons e-upload-icon e-icon-left'
                }));
                uploadElem.onchange = this.fileSelect.bind(this, uploadElem);
            }
        }
    };
    ToolbarModule.prototype.fileSelect = function (inputElement, args) {
        var parent = this.parent;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var type = inputElement.files[0].type.split('/')[1];
        var filesTypes = this.parent.getExtensionArray();
        var isJPG = ((type === 'jpg' || type === 'jpeg') &&
            (parent.uploadSettings.allowedExtensions.indexOf('jpg') > -1 ||
                parent.uploadSettings.allowedExtensions.indexOf('jpeg') > -1));
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.fileName = inputElement.files[0].name.split('.')[0];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var size = inputElement.files[0].size;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.parent.notify('toolbar', { prop: 'setInitialSize', value: { value: inputElement.files[0].size } });
        if ((filesTypes.indexOf(type) > -1 || isJPG || (type.indexOf('svg') > -1 && filesTypes.indexOf('svg') > -1)) &&
            (!this.parent.uploadSettings.minFileSize || size > this.parent.uploadSettings.minFileSize) &&
            (!this.parent.uploadSettings.maxFileSize || size < this.parent.uploadSettings.maxFileSize)) {
            this.parent.notify('draw', { prop: 'fileSelect', value: { inputElement: inputElement, args: args } });
        }
        else {
            if (!this.parent.isImageLoaded) {
                this.destroyTopToolbar();
                this.createToolbar();
                if (Browser.isDevice) {
                    this.destroyBottomToolbar();
                }
            }
            this.parent.showDialogPopup('unsupported', !((filesTypes.indexOf(type) > -1 || isJPG || (type.indexOf('svg') > -1 && filesTypes.indexOf('svg') > -1))));
        }
    };
    ToolbarModule.prototype.triggerTbarClickEvent = function (args) {
        var clickEvent = { item: args.item, originalEvent: args.event };
        this.parent.trigger('toolbarItemClicked', clickEvent);
    };
    ToolbarModule.prototype.renderAnnotationBtn = function (isContextualToolbar) {
        var _this = this;
        var parent = this.parent;
        var isCustomized = false;
        var items = [];
        var id = parent.element.id;
        var defItems = ['Ellipse', 'Arrow', 'Line', 'Rectangle', 'Pen', 'Path', 'Text', 'Image'];
        if (parent.toolbar) {
            for (var i = 0; i < defItems.length; i++) {
                if (parent.toolbar.indexOf(defItems[i]) !== -1) {
                    isCustomized = true;
                    break;
                }
            }
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Pen') > -1)) {
            items.push({ text: this.l10n.getConstant('Pen'), id: 'pen', iconCss: 'e-icons e-free-pen' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Line') > -1)) {
            items.push({ text: this.l10n.getConstant('Line'), id: 'line', iconCss: 'e-icons e-line' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Rectangle') > -1)) {
            items.push({ text: this.l10n.getConstant('Rectangle'), id: 'rectangle', iconCss: 'e-icons e-rectangle' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Ellipse') > -1)) {
            items.push({ text: this.l10n.getConstant('Ellipse'), id: 'ellipse', iconCss: 'e-icons e-circle' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Arrow') > -1)) {
            items.push({ text: this.l10n.getConstant('Arrow'), id: 'arrow', iconCss: 'e-icons e-arrow-right-up' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Path') > -1)) {
            items.push({ text: this.l10n.getConstant('Path'), id: 'path', iconCss: 'e-icons e-critical-path' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Text') > -1)) {
            items.push({ text: this.l10n.getConstant('Text'), id: 'text', iconCss: 'e-icons e-add-text' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Image') > -1)) {
            items.push({ text: this.l10n.getConstant('Image'), id: 'image', iconCss: 'e-icons e-image' });
        }
        var obj = { freehandDrawSelectedId: null };
        parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });
        var toolbarId = Browser.isDevice ? '#' + id + '_bottomToolbar ' + '#' + id : '#' + id;
        this.enableDisableCloneBtn(toolbarId, obj);
        var iconCss = isContextualToolbar ? this.getCurrentShapeIcon(parent.activeObj.shape) : 'e-annotation';
        var drpDownBtn = new DropDownButton({ items: items, iconCss: 'e-icons ' + iconCss,
            cssClass: 'e-image-popup',
            open: function (args) {
                if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
                    parent.okBtn();
                    parent.element.querySelector('#' + id + '_annotationBtn').click();
                }
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                if (parent.activeObj.shape) {
                    document.getElementById(parent.activeObj.shape).classList.add('e-selected');
                }
                else if (parent.togglePen) {
                    document.getElementById('pen').classList.add('e-selected');
                }
            },
            select: function (args) {
                parent.noPushUndo = false;
                _this.triggerTbarClickEvent(args);
                parent.okBtn();
                var isCropSelection = false;
                var splitWords;
                if (parent.activeObj.shape !== undefined) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (splitWords === undefined && parent.currObjType.isCustomCrop) {
                    isCropSelection = true;
                }
                else if (splitWords !== undefined && splitWords[0] === 'crop') {
                    isCropSelection = true;
                }
                parent.currObjType.isCustomCrop = false;
                if (isCropSelection || parent.togglePan) {
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                    _this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    _this.refreshToolbar('main');
                }
                var obj = { currentFreehandDrawIndex: null };
                parent.notify('freehand-draw', { prop: 'getCurrentFreehandDrawIndex', value: { obj: obj } });
                var prevObj = { shapeSettingsObj: {} };
                var shapeSettings;
                var shapeChangingArgs;
                var shapes = ['ellipse', 'rectangle', 'text', 'image'];
                var allowOutofBound;
                drpDownBtn.iconCss = 'e-icons ' + _this.getCurrentShapeIcon(args.item.id);
                parent.notify('draw', { prop: 'updateTempObjColl' });
                parent.notify('draw', { prop: 'updateTempPointColl' });
                var penStrokeWidthObj = { penStrokeWidth: 2 };
                switch (args.item.id) {
                    case 'pen':
                        parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: penStrokeWidthObj } });
                        parent.notify('draw', { prop: 'setTempStrokeWidth', value: { strokeWidth: penStrokeWidthObj['penStrokeWidth'] } });
                        parent.drawingShape = null;
                        parent.notify('draw', { prop: 'setTempFreehandCounter', value: { tempFreehandCounter: parent.freehandCounter } });
                        parent.notify('draw', { prop: 'setTempCurrentFreehandDrawIndex', value: { tempCurrentFreehandDrawIndex: obj['currentFreehandDrawIndex'] } });
                        _this.currentToolbar = 'pen';
                        parent.freeHandDraw(true);
                        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: prevObj } });
                        shapeSettings = prevObj['shapeSettingsObj'];
                        parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: penStrokeWidthObj } });
                        shapeSettings.strokeWidth = penStrokeWidthObj['penStrokeWidth'];
                        shapeSettings.type = ShapeType.FreehandDraw;
                        shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,
                            currentShapeSettings: shapeSettings };
                        parent.notify('freehand-draw', { prop: 'triggerShapeChanging', value: { shapeChangingArgs: shapeChangingArgs } });
                        break;
                    case 'text':
                        _this.currentToolbar = 'text';
                        parent.drawingShape = args.item.id;
                        _this.currentToolbar = 'text';
                        _this.setInitialShapeSettings(args);
                        parent.notify('selection', { prop: 'annotate', value: { shape: args.item.id } });
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        break;
                    case 'image':
                        parent.drawingShape = null;
                        _this.currentToolbar = 'shapes';
                        parent.element.querySelector('#' + id + '_fileUpload').click();
                        break;
                    case 'ellipse':
                    case 'arrow':
                    case 'line':
                    case 'rectangle':
                    case 'path':
                        parent.drawingShape = args.item.id;
                        _this.currentToolbar = 'shapes';
                        _this.setInitialShapeSettings(args);
                        parent.notify('selection', { prop: 'annotate', value: { shape: args.item.id } });
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: prevObj } });
                        shapeSettings = prevObj['shapeSettingsObj'];
                        allowOutofBound = shapes.indexOf(_this.parent.activeObj.shape) !== -1 ? false : true;
                        shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,
                            currentShapeSettings: shapeSettings, allowShapeOverflow: allowOutofBound };
                        parent.trigger('shapeChanging', shapeChangingArgs);
                        parent.editCompleteArgs = shapeChangingArgs;
                        parent.notify('shape', { prop: 'updateShapeChangeEventArgs', value: { shapeSettings: shapeChangingArgs.currentShapeSettings } });
                        break;
                }
                _this.updateToolbarItems();
                var tempTogglePen = parent.togglePen;
                if (args.item.id === 'pen') {
                    parent.togglePen = false;
                }
                parent.notify('draw', { prop: 'redrawDownScale' });
                parent.togglePen = tempTogglePen;
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_annotationBtn');
    };
    ToolbarModule.prototype.enableDisableCloneBtn = function (toolbarId, obj) {
        var parent = this.parent;
        var isDummyTextClick = false;
        var width = Math.floor(parent.activeObj.activePoint.width);
        if (parent.activeObj.shape && parent.activeObj.shape === 'text' &&
            parent.activeObj.textSettings.fontSize === 11 && (width === 55 || (parent.activeObj.textSettings.bold && width === 58)) &&
            Math.floor(parent.activeObj.activePoint.height) === 11) {
            isDummyTextClick = true;
        }
        var duplicateElement = document.querySelector(toolbarId + '_duplicate');
        var removeElement = document.querySelector(toolbarId + '_remove');
        var editTextElement = document.querySelector(toolbarId + '_editText');
        var zOrderElement = document.querySelector(toolbarId + '_zOrderBtn');
        if (isDummyTextClick || (parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) &&
            (isNullOrUndefined(parent.activeObj.pointColl) || (parent.activeObj.pointColl
                && parent.activeObj.pointColl.length === 0)) &&
            isNullOrUndefined(obj['freehandDrawSelectedId'])) {
            if (duplicateElement) {
                duplicateElement.classList.add('e-overlay');
            }
            if (removeElement) {
                removeElement.classList.add('e-overlay');
            }
            if (editTextElement) {
                editTextElement.classList.add('e-overlay');
            }
            if (zOrderElement) {
                zOrderElement.classList.add('e-overlay');
            }
        }
        else {
            if (duplicateElement) {
                duplicateElement.classList.remove('e-overlay');
            }
            if (removeElement) {
                removeElement.classList.remove('e-overlay');
            }
            if (editTextElement) {
                editTextElement.classList.remove('e-overlay');
            }
            if (zOrderElement) {
                zOrderElement.classList.remove('e-overlay');
            }
        }
        if (zOrderElement && (parent.shapeColl.length === 0 || (obj['freehandDrawSelectedId'] && parent.shapeColl.length === 1))) {
            zOrderElement.classList.add('e-overlay');
        }
    };
    ToolbarModule.prototype.renderStraightenSlider = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if ((isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Straightening') > -1)) &&
            parent.element.querySelector('#' + id + '_straightenSlider')) {
            var slider = this.createSlider(-45, 45, parent.cropObj.straighten, 'straighten');
            slider.appendTo('#' + id + '_straightenSlider');
            var sliderHandle = slider.element.querySelector('.e-handle');
            if (sliderHandle && !Browser.isDevice) {
                sliderHandle.addEventListener('mousedown', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                });
                sliderHandle.addEventListener('touchstart', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                });
            }
        }
    };
    ToolbarModule.prototype.renderCropBtn = function (shapeString) {
        var _this = this;
        var parent = this.parent;
        var items = [];
        var isCustomized = false;
        var defItems = ['CustomSelection', 'CircleSelection', 'SquareSelection', 'RatioSelection'];
        if (parent.toolbar) {
            for (var i = 0; i < defItems.length; i++) {
                if (parent.toolbar.indexOf(defItems[i]) !== -1) {
                    isCustomized = true;
                    break;
                }
            }
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('CustomSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Custom'), id: 'custom', iconCss: 'e-icons e-custom' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('CircleSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Circle'), id: 'circle', iconCss: 'e-icons e-circle' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('SquareSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Square'), id: 'square', iconCss: 'e-icons e-square' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('RatioSelection') > -1)) {
            items.push({ text: '2:3', id: '2:3', iconCss: 'e-icons e-custom-f' });
            items.push({ text: '3:2', id: '3:2', iconCss: 'e-icons e-custom-a' });
            items.push({ text: '3:4', id: '3:4', iconCss: 'e-icons e-custom-g' });
            items.push({ text: '4:3', id: '4:3', iconCss: 'e-icons e-custom-b' });
            items.push({ text: '4:5', id: '4:5', iconCss: 'e-icons e-custom-h' });
            items.push({ text: '5:4', id: '5:4', iconCss: 'e-icons e-custom-c' });
            items.push({ text: '5:7', id: '5:7', iconCss: 'e-icons e-custom-i' });
            items.push({ text: '7:5', id: '7:5', iconCss: 'e-icons e-custom-d' });
            items.push({ text: '9:16', id: '9:16', iconCss: 'e-icons e-custom-j' });
            items.push({ text: '16:9', id: '16:9', iconCss: 'e-icons e-custom-e' });
        }
        var iconCss;
        var shape;
        if (shapeString) {
            iconCss = this.getCurrentShapeIcon(shapeString);
            shape = shapeString;
        }
        else if (parent.activeObj.shape &&
            (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) ||
            (parent.activeObj.shape === 'path' && parent.activeObj.pointColl.length > 0)) {
            iconCss = this.getCurrentShapeIcon(parent.activeObj.shape);
            shape = parent.activeObj.shape;
        }
        else if (parent.currSelectionPoint) {
            iconCss = this.getCurrentShapeIcon(parent.currSelectionPoint.shape);
            shape = parent.currSelectionPoint.shape;
        }
        else {
            iconCss = items[0].iconCss;
            shape = items[0].id;
        }
        var drpDownBtn = new DropDownButton({
            open: function (args) {
                if (parent.togglePan) {
                    _this.cancelPan();
                }
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                if (parent.activeObj.shape && parent.activeObj.shape.split('-').length > 1) {
                    var elem = document.getElementById(parent.activeObj.shape.split('-')[1]);
                    if (elem) {
                        elem.classList.add('e-selected');
                        elem.focus();
                    }
                }
                parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
            },
            items: items,
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                _this.cropSelect(args);
                drpDownBtn.iconCss = 'e-icons ' + _this.getCurrentShapeIcon('crop-' + args.item.id);
                drpDownBtn.content = Browser.isDevice ? null : parent.toPascalCase(args.item.id);
            },
            iconCss: 'e-icons ' + iconCss, cssClass: 'e-image-popup e-ie-crop-ddb-popup',
            content: Browser.isDevice ? null : parent.toPascalCase(shape.replace('crop-', ''))
        });
        drpDownBtn.appendTo('#' + parent.element.id + '_cropBtn');
    };
    ToolbarModule.prototype.renderTransformBtn = function () {
        var _this = this;
        var parent = this.parent;
        var items = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('RotateLeft') > -1)) {
            items.push({ text: this.l10n.getConstant('RotateLeft'), id: 'rotateleft', iconCss: 'e-icons e-anti-clock-wise' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('RotateRight') > -1)) {
            items.push({ text: this.l10n.getConstant('RotateRight'), id: 'rotateright', iconCss: 'e-icons e-clock-wise' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('FlipHorizontal') > -1)) {
            items.push({ text: this.l10n.getConstant('HorizontalFlip'), id: 'horizontalflip', iconCss: 'e-icons e-horizontal-flip' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('FlipVertical') > -1)) {
            items.push({ text: this.l10n.getConstant('VerticalFlip'), id: 'verticalflip', iconCss: 'e-icons e-vertical-flip' });
        }
        var drpDownBtn = new DropDownButton({
            open: function (args) {
                if (Browser.isDevice) {
                    var elem = args.element.parentElement;
                    var ht = elem.offsetHeight;
                    elem.style.display = 'none';
                    elem.style.top = drpDownBtn.element.getBoundingClientRect().top - ht + 'px';
                    elem.style.display = 'block';
                }
            },
            items: items,
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                parent.transformSelect.bind(_this);
            },
            iconCss: 'e-icons e-transform', cssClass: 'e-image-popup'
        });
        drpDownBtn.appendTo('#' + parent.element.id + '_transformBtn');
    };
    ToolbarModule.prototype.saveDialogPopup = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var quality = ['Good', 'Great', 'Highest'];
        parent.element.appendChild(parent.createElement('div', { id: id + '_saveDialog' }));
        var dialogContent = parent.createElement('div', {
            id: id + '_dialogContent'
        });
        dialogContent.style.display = 'flex';
        var dialogImgContent = dialogContent.appendChild(parent.createElement('div', {
            id: id + '_dialogImgContent', className: 'e-ie-dlg-img-content'
        }));
        dialogImgContent.appendChild(parent.createElement('canvas', {
            id: id + '_imgPic', className: 'e-ie-img-dlg-canvas'
        }));
        var imageNameContainer = dialogImgContent.appendChild(parent.createElement('div', {
            id: id + '_imageNameContainer', className: 'e-ie-img-size'
        }));
        imageNameContainer.appendChild(parent.createElement('span', {
            id: id + '_imageNameLabel', className: 'e-ie-quality-info'
        }));
        var dialogRightContent = dialogContent.appendChild(parent.createElement('div', {
            id: id + '_dialogRightContent', className: 'e-ie-dlg-right-content'
        }));
        var imageNameDiv = dialogRightContent.appendChild(parent.createElement('div', {
            id: id + '_namediv', className: 'e-ie-img-save-name'
        }));
        imageNameDiv.appendChild(parent.createElement('span', {
            id: id + '_labelImgname', className: 'e-ie-img-label-name', innerHTML: this.l10n.getConstant('ImageName')
        }));
        imageNameDiv.appendChild(parent.createElement('input', {
            id: id + '_imgNametext', className: 'e-ie-img-input', attrs: { type: 'text' }
        }));
        var formatNameDiv = dialogRightContent.appendChild(parent.createElement('div', {
            id: id + '_imgNamediv', className: 'e-ie-img-save-dlg'
        }));
        formatNameDiv.appendChild(parent.createElement('span', {
            id: id + '_labelname', className: 'e-ie-img-label-name', innerHTML: this.l10n.getConstant('Format')
        }));
        formatNameDiv.appendChild(parent.createElement('button', {
            id: id + '_saveDropdownbtn', attrs: { tabindex: '1' }
        }));
        var qualityNameDiv = dialogRightContent.appendChild(parent.createElement('div', {
            id: id + '_imgQualitydiv', className: 'e-ie-img-quality-name'
        }));
        var qualityDiv = parent.createElement('div', {
            id: id + '_qualityContainer'
        });
        qualityDiv.appendChild(parent.createElement('span', {
            id: id + '_qualityLabel', className: 'e-ie-img-quality-label',
            innerHTML: this.l10n.getConstant('Quality')
        }));
        qualityDiv.appendChild(parent.createElement('span', {
            id: id + '_qualityInfo', className: 'e-circle-info e-icons e-ie-quality-span',
            attrs: { title: this.l10n.getConstant('QualityInfo') }
        }));
        var qualityValueElem = qualityDiv.appendChild(parent.createElement('div', {
            id: id + '_imgsizeSpan',
            className: 'e-ie-img-size-value-span'
        }));
        qualityValueElem.appendChild(parent.createElement('span', {
            id: id + '_imgsizeValueSpan', className: ''
        }));
        qualityNameDiv.appendChild(qualityDiv);
        var qualityOptionDiv = parent.createElement('div', {
            id: id + '_qualityOptionContainer', className: 'e-ie-quality-option-container'
        });
        var buttonGroup = qualityNameDiv.appendChild(parent.createElement('div', {
            id: id + '_qualityButtonGroup', className: 'e-btn-group'
        }));
        // eslint-disable-next-line @typescript-eslint/tslint/config
        quality.forEach(function (option) {
            var input = document.createElement('input');
            input.type = 'radio';
            input.id = id + '_' + option.toLowerCase();
            input.name = 'quality';
            input.value = option.toLowerCase();
            var label = document.createElement('label');
            label.className = 'e-btn';
            label.htmlFor = option.toLowerCase();
            label.textContent = _this.l10n.getConstant(option);
            buttonGroup.appendChild(input);
            buttonGroup.appendChild(label);
        });
        qualityOptionDiv.appendChild(buttonGroup);
        qualityOptionDiv.appendChild(parent.createElement('div', {
            id: id + '_qualitySlider', className: 'e-ie-img-quality-slider'
        }));
        qualityOptionDiv.appendChild(parent.createElement('button', { id: id + '_qualitybuttonIcon', className: 'e-ie-img-icon-button', attrs: { type: 'button' } }));
        qualityNameDiv.appendChild(qualityOptionDiv);
        if (Browser.isDevice) {
            dialogRightContent.appendChild(parent.createElement('span', {
                id: id + '_qualitySize', className: 'e-ie-img-quality-size'
            }));
        }
        parent.element.querySelector('#' + id + '_saveDialog').style.display = 'block';
        parent.element.appendChild(dialogContent);
        var dialog = new Dialog({
            target: parent.element,
            header: this.l10n.getConstant('SaveAs'),
            closeOnEscape: true, content: document.getElementById(id + '_dialogContent'),
            width: Browser.isDevice ? '345px' : '570px', isModal: true, animationSettings: { effect: 'Zoom' }, beforeOpen: this.onBeforeopen(),
            close: this.saveDialogClosed.bind(this, id),
            cssClass: 'e-ie-save-dialog',
            buttons: [
                {
                    'click': function () {
                        dialog.hide();
                    },
                    buttonModel: {
                        content: this.l10n.getConstant('Close'), cssClass: 'e-save-cancel-btn'
                    }
                },
                {
                    'click': function () {
                        _this.download();
                        dialog.hide();
                        _this.isSlider = false;
                    },
                    buttonModel: {
                        isPrimary: true, content: this.l10n.getConstant('Download'), cssClass: 'e-flat e-save-download-btn'
                    }
                }
            ]
        });
        dialog.appendTo('#' + id + '_saveDialog');
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    ToolbarModule.prototype.saveDialogClosed = function (id) {
        if (getComponent(document.getElementById(id + '_saveDropdownbtn'), 'dropdownbutton')) {
            getComponent(document.getElementById(id + '_saveDropdownbtn'), 'dropdownbutton').destroy();
        }
        this.isSlider = false;
        if (document.querySelector('#' + id + '_qualityButtonGroup') &&
            document.querySelector('#' + id + '_qualitySlider')) {
            document.querySelector('#' + id + '_qualityButtonGroup').remove();
            document.querySelector('#' + id + '_qualitySlider').remove();
            document.querySelector('#' + id + '_imgsizeValueSpan').remove();
            document.querySelector('#' + id + '_imageNameLabel').remove();
            document.querySelector('#' + id + '_imgsizeSpan').remove();
        }
        document.getElementById(id + '_dialogContent').remove();
        getComponent(document.getElementById(id + '_saveDialog'), 'dialog').destroy();
        document.getElementById(id + '_saveDialog').remove();
    };
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    ToolbarModule.prototype.onBeforeopen = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var obj = { canvas: null };
        var items = [
            { id: 'jpeg', text: 'JPEG' },
            { id: 'png', text: 'PNG' },
            { id: 'svg', text: 'SVG' },
            { id: 'webp', text: 'WebP' }
        ];
        var inputObj = new TextBox({
            placeholder: this.l10n.getConstant('ImageName')
        });
        inputObj.appendTo('#' + id + '_imgNametext');
        var qualityContainer = document.getElementById(id + '_imgQualitydiv');
        var slider = document.getElementById(id + '_qualitySlider');
        var qualityBtnGrp = document.querySelector('#' + id + '_qualityButtonGroup');
        var qualityBtnIcon = document.querySelector('#' + id + '_qualitybuttonIcon');
        var qualitySliderValue = document.querySelector('#' + id + '_imgsizeSpan');
        var imageNameLabel;
        if (Browser.isDevice) {
            imageNameLabel = document.getElementById(id + '_qualitySize');
        }
        else {
            imageNameLabel = document.getElementById(id + '_imageNameLabel');
        }
        var fileObj = { fileName: '', fileType: '' };
        parent.notify('draw', { prop: 'getFileName', onPropertyChange: false, value: { obj: fileObj } });
        this.fileType = fileObj['fileType'] ? fileObj['fileType'] : 'JPEG';
        parent.notify('export', { prop: 'exportToCanvas', value: { object: obj } });
        var tempCanvas = obj['canvas'];
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var canvas = document.getElementById(id + '_imgPic');
        canvas.width = tempCanvas.width;
        canvas.height = tempCanvas.height;
        var buttonIcon = new Button({ iconCss: 'e-icons e-settings' });
        buttonIcon.appendTo('#' + id + '_qualitybuttonIcon');
        var ddbElem = document.getElementById(id + '_saveDropdownbtn');
        if (ddbElem) {
            var spanElem_1 = document.createElement('span');
            spanElem_1.innerHTML = this.fileType === 'Webp' ? 'Webp' : this.fileType.toUpperCase();
            if (ddbElem) {
                ddbElem.appendChild(spanElem_1);
            }
            var drpDownBtn_1 = new DropDownButton({
                items: items,
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var activeBtn = spanElem_1.innerHTML;
                    if (activeBtn !== '') {
                        args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                    }
                },
                select: function (args) {
                    qualitySliderValue.style.display = 'none';
                    _this.fileType = spanElem_1.innerHTML = args.item.text;
                    if (args.item.id !== 'jpeg') {
                        qualityContainer.style.display = 'none';
                        imageNameLabel.style.display = 'block';
                        _this.updateImageSize(1, obj['canvas'], _this.fileType);
                        if (slider) {
                            if (_this.isSlider) {
                                getComponent(slider, 'slider').destroy();
                            }
                            slider.style.display = 'none';
                        }
                        _this.isSlider = false;
                    }
                    else {
                        qualityContainer.style.display = 'block';
                        removeClass([qualityBtnGrp], 'e-hide');
                        slider.style.display = 'none';
                        imageNameLabel.style.display = 'block';
                        _this.updateImageSize(isNullOrUndefined(_this.currentQuality) ? 1 : _this.currentQuality, obj['canvas'], _this.fileType);
                        document.getElementById(id + '_' + _this.imageQuality).checked = true;
                    }
                }
            });
            drpDownBtn_1.appendTo('#' + id + '_saveDropdownbtn');
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            var imgName = document.getElementById(id + '_imgNametext');
            imgName.value = this.fileName ? this.fileName : fileObj['fileName'];
            if (fileObj['fileType'] && fileObj['fileType'].toUpperCase() !== 'JPEG') {
                qualityContainer.style.display = 'none';
                qualitySliderValue.style.display = 'none';
            }
            if (Browser.isDevice) {
                document.getElementById(id + '_dialogImgContent').style.display = 'none';
                document.getElementById(id + '_dialogRightContent').style.width = '100%';
                this.updateImageSize(1, obj['canvas'], this.fileType);
            }
            else {
                this.updateImageSize(1, obj['canvas'], this.fileType);
            }
        }
        document.getElementById(id + '_' + this.imageQuality).checked = true;
        qualityBtnGrp.addEventListener('click', this.qualityBtnClickHandler.bind(this));
        qualityBtnIcon.addEventListener('click', this.qualityBtnClickHandler.bind(this));
    };
    ToolbarModule.prototype.qualityBtnClickHandler = function (event) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var target = event.target;
        var fileObj = { fileName: '' };
        var obj = { canvas: null };
        var compressionValues = {
            'Good': 0.8,
            'Great': 0.9,
            'Highest': 1
        };
        var qualityBtnGrp = document.querySelector('#' + id + '_qualityButtonGroup');
        var qualitySlider = document.querySelector('#' + id + '_qualitySlider');
        var qualityOption = document.querySelector('#' + id + '_qualityOptionContainer');
        var qualitySliderValueDiv = document.querySelector('#' + id + '_imgsizeSpan');
        var qualitySliderValueSpan = document.querySelector('#' + id + '_imgsizeValueSpan');
        parent.notify('draw', { prop: 'getFileName', onPropertyChange: false, value: { obj: fileObj } });
        parent.notify('export', { prop: 'exportToCanvas', value: { object: obj } });
        if (event.currentTarget.id === id + '_qualitybuttonIcon' && !this.isSlider) {
            addClass([qualityBtnGrp], 'e-hide');
            qualitySlider.style.display = 'block';
            qualitySliderValueDiv.style.display = 'inline-block';
            qualityOption.style.display = 'flex';
            var sliderObj = new Slider({
                tooltip: { placement: 'Before', isVisible: true, format: 'P0', showOn: 'Focus' },
                min: 0.01, max: 1, step: 0.01, value: this.currentQuality,
                type: 'MinRange',
                width: Browser.isDevice ? '80%' : '190px',
                created: function () {
                    _this.updateImageSize(_this.currentQuality, obj['canvas'], 'jpeg');
                    qualitySliderValueSpan.innerHTML = (Math.round(_this.currentQuality * 100)).toString();
                },
                changed: function (args) {
                    _this.currentQuality = args.value;
                    qualitySliderValueSpan.innerHTML = (Math.round(_this.currentQuality * 100)).toString();
                    parent.notify('export', { prop: 'setImageQuality', value: { value: args.value } });
                    _this.updateImageSize(args.value, obj['canvas'], 'jpeg');
                }
            });
            sliderObj.appendTo('#' + id + '_qualitySlider');
            sliderObj.element.parentElement.classList.add('e-ie-quality-slider');
            this.isSlider = true;
        }
        else if (event.currentTarget.id === id + '_qualitybuttonIcon' && this.isSlider) {
            getComponent(qualitySlider, 'slider').destroy();
            qualitySlider.style.display = 'none';
            qualitySliderValueDiv.style.display = 'none';
            removeClass([qualityBtnGrp], 'e-hide');
            qualityOption.style.display = 'block';
            this.isSlider = false;
            // eslint-disable-next-line no-prototype-builtins
        }
        else if (compressionValues.hasOwnProperty(target.textContent) && !this.isSlider) {
            event.target.previousElementSibling.checked = true;
            this.currentQuality = compressionValues[target.textContent];
            this.imageQuality = target.textContent.toLowerCase();
            this.updateImageSize(compressionValues[target.textContent], obj['canvas'], 'jpeg');
        }
    };
    ToolbarModule.prototype.updateImageSize = function (quality, tempCanvas, fileType) {
        var fileSize;
        var parent = this.parent;
        var id = parent.element.id;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var canvas = document.getElementById(id + '_imgPic');
        var ctx = canvas.getContext('2d');
        var imageNameLabel;
        if (Browser.isDevice) {
            imageNameLabel = document.getElementById(id + '_qualitySize');
        }
        else {
            imageNameLabel = document.getElementById(id + '_imageNameLabel');
        }
        if (fileType.toLowerCase() === 'jpeg') {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            tempCanvas.toBlob((function (blob) {
                fileSize = Math.floor(blob.size / 1024);
                if (fileSize > 1000) {
                    var megabytes = fileSize / 1024;
                    imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + megabytes.toFixed(2) + ' MB';
                    fileSize = +megabytes.toFixed(2);
                }
                else {
                    imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + fileSize.toFixed(2) + ' KB';
                    fileSize = +fileSize.toFixed(2);
                }
                if (Browser.isDevice) {
                    canvas.style.display = 'none';
                }
                else {
                    var compressedImage_1 = new Image();
                    compressedImage_1.src = URL.createObjectURL(blob);
                    // eslint-disable-next-line @typescript-eslint/tslint/config
                    compressedImage_1.onload = function () {
                        ctx.drawImage(compressedImage_1, 0, 0);
                        URL.revokeObjectURL(compressedImage_1.src);
                    };
                }
                this.fileSize = fileSize;
            }).bind(this), 'image/jpeg', quality);
        }
        else if (!isNullOrUndefined(fileType) && (fileType.toLowerCase() === 'png' || fileType.toLowerCase() === 'webp')) {
            var type = 'image/' + fileType.toLowerCase();
            ctx.drawImage(tempCanvas, 0, 0);
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            tempCanvas.toBlob((function (blob) {
                fileSize = Math.floor(blob.size / 1024);
                if (fileSize > 1000) {
                    var megabytes = fileSize / 1024;
                    imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + megabytes.toFixed(2) + ' MB';
                    fileSize = +megabytes.toFixed(2);
                }
                else {
                    imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + fileSize.toFixed(2) + ' KB';
                    fileSize = +fileSize.toFixed(2);
                }
                if (Browser.isDevice) {
                    canvas.style.display = 'none';
                }
                this.fileSize = fileSize;
            }).bind(this), type, 1);
        }
        else if (!isNullOrUndefined(fileType) && fileType.toLowerCase() === 'svg') {
            ctx.drawImage(tempCanvas, 0, 0);
            var svgDataUrl = tempCanvas.toDataURL('image/svg+xml');
            var base64Data = svgDataUrl.split(',')[1];
            var binaryStringLength = base64Data.length;
            var rawByteSize = binaryStringLength;
            var fileSize_1 = Math.floor(rawByteSize / 1024); // KB
            if (fileSize_1 > 1000) {
                var megabytes = fileSize_1 / 1024; // Convert to MB
                imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + megabytes.toFixed(2) + ' MB';
                fileSize_1 = +megabytes.toFixed(2);
            }
            else {
                imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + fileSize_1.toFixed(2) + ' KB';
                fileSize_1 = +fileSize_1.toFixed(2);
            }
            if (Browser.isDevice) {
                canvas.style.display = 'none';
            }
            this.fileSize = fileSize_1;
        }
        else {
            if (Browser.isDevice) {
                canvas.style.display = 'none';
            }
            else {
                ctx.drawImage(tempCanvas, 0, 0);
                if (this.initialSize > 1000) {
                    var megabytes = this.initialSize / 1048576;
                    imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + megabytes.toFixed(2) + ' MB';
                }
                else {
                    imageNameLabel.innerHTML = this.l10n.getConstant('ImageSize') + ': ' + this.initialSize.toFixed(2) + ' KB';
                }
            }
        }
    };
    ToolbarModule.prototype.download = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if (this.fileType === 'JPEG' && this.isSlider) {
            var value = getComponent(document.getElementById(id + '_qualitySlider'), 'slider').value;
            parent.notify('export', { prop: 'setImageQuality', value: { value: value } });
        }
        else {
            parent.notify('export', { prop: 'setImageQuality', value: { value: this.currentQuality } });
        }
        var fileName = document.getElementById(id + '_imgNametext').value;
        parent.export(this.fileType, fileName);
    };
    ToolbarModule.prototype.getCropTransformToolbarItem = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        toolbarItems.push({ id: id + '_crop', tooltipText: this.l10n.getConstant('CropSelection'), align: 'Center',
            template: '<button id="' + id + '_cropBtn"></button>'
        });
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && (parent.toolbar.indexOf('Transform') > -1 || parent.toolbar.indexOf('RotateLeft') > -1))) {
            toolbarItems.push({ id: id + '_rotateLeft', prefixIcon: 'e-icons e-anti-clock-wise', tooltipText: this.l10n.getConstant('RotateLeft'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && (parent.toolbar.indexOf('Transform') > -1 || parent.toolbar.indexOf('RotateRight') > -1))) {
            toolbarItems.push({ id: id + '_rotateRight', prefixIcon: 'e-icons e-clock-wise', tooltipText: this.l10n.getConstant('RotateRight'), align: 'Center' });
        }
        if (toolbarItems.length > 2) {
            toolbarItems.push({ align: 'Center', type: 'Separator' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && (parent.toolbar.indexOf('Transform') > -1 || parent.toolbar.indexOf('HorizontalFlip') > -1))) {
            toolbarItems.push({ id: id + '_horizontalFlip', prefixIcon: 'e-icons e-horizontal-flip', tooltipText: this.l10n.getConstant('HorizontalFlip'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && (parent.toolbar.indexOf('Transform') > -1 || parent.toolbar.indexOf('VerticalFlip') > -1))) {
            toolbarItems.push({ id: id + '_verticalFlip', prefixIcon: 'e-icons e-vertical-flip', tooltipText: this.l10n.getConstant('VerticalFlip'), align: 'Center' });
        }
        if ((isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Straightening') > -1)) && !Browser.isDevice) {
            toolbarItems.push({ align: 'Center', type: 'Separator' });
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Straightening') > -1)) {
                var spanWidth = document.createElement('span');
                spanWidth.innerHTML = this.l10n.getConstant('Straighten');
                toolbarItems.push({ id: id + '_straightenSpan', cssClass: 'e-ie-straighten-span', template: spanWidth, align: 'Center' });
                toolbarItems.push({ id: id + '_straighten',
                    cssClass: 'top-icon e-straighten', tooltipText: this.l10n.getConstant('Straighten'), align: 'Center', type: 'Input',
                    template: '<div id="' + id + '_straightenSlider"></div>' });
                var straightenSpan = document.createElement('span');
                straightenSpan.innerHTML = parent.transform.straighten.toString() + '&#176';
                toolbarItems.push({ id: id + '_straightenSpan', cssClass: 'e-ie-straighten-value-span',
                    template: straightenSpan, align: 'Center' });
            }
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
            toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getShapesToolbarItem = function (items) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar)) {
            toolbarItems.push({ id: id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + id + '_annotationBtn"></button>' });
        }
        if (items.indexOf('fillColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: id + '_fillcolor',
                cssClass: 'top-icon e-fill', tooltipText: this.l10n.getConstant('FillColor'), align: 'Center', type: 'Input',
                template: '<button id="' + id + '_fillColorBtn"></button>' });
        }
        if (items.indexOf('strokeColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: id + '_strokecolor',
                cssClass: 'top-icon e-stroke', tooltipText: this.l10n.getConstant('StrokeColor'), align: 'Center', type: 'Input',
                template: '<button id="' + id + '_borderColorBtn"></button>' });
        }
        if (items.indexOf('strokeWidth') > -1) {
            toolbarItems.push({ id: id + '_strokeWidth', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('StrokeWidth'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_borderWidthBtn"></button>' });
        }
        if (items.indexOf('start') > -1) {
            toolbarItems.push({ id: id + '_start', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('Start'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_startBtn"></button>' });
        }
        if (items.indexOf('borderRadius') > -1) {
            toolbarItems.push({ id: id + '_rectangleRadius', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('BorderRadius'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_rectangleRadiusBtn"></button>' });
        }
        if (items.indexOf('end') > -1) {
            toolbarItems.push({ id: id + '_end', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('End'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_endBtn"></button>' });
        }
        if (items.indexOf('flip') > -1) {
            toolbarItems.push({ id: id + '_rotLeft', prefixIcon: 'e-anti-clock-wise',
                tooltipText: this.l10n.getConstant('RotateLeft'), align: 'Center' });
            toolbarItems.push({ id: id + '_rotRight', prefixIcon: 'e-clock-wise',
                tooltipText: this.l10n.getConstant('RotateRight'), align: 'Center' });
            toolbarItems.push({ id: id + '_hFlip', prefixIcon: 'e-horizontal-flip',
                tooltipText: this.l10n.getConstant('HorizontalFlip'), align: 'Center' });
            toolbarItems.push({ id: id + '_vFlip', prefixIcon: 'e-vertical-flip',
                tooltipText: this.l10n.getConstant('VerticalFlip'), align: 'Center' });
        }
        if (items.indexOf('transparency') > -1) {
            toolbarItems.push({ align: 'Center', type: 'Separator' });
            toolbarItems.push({ id: id + '_transparency', prefixIcon: 'e-opacity',
                tooltipText: this.l10n.getConstant('Opacity'), align: 'Center' });
        }
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        if (items.indexOf('z-order') > -1) {
            toolbarItems.push({ id: id + '_zOrder', cssClass: 'top-icon e-list-unordered-3', tooltipText: this.l10n.getConstant('ZOrder'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_zOrderBtn"></button>' });
        }
        if (items.indexOf('duplicate') > -1) {
            toolbarItems.push({ id: id + '_duplicate', prefixIcon: 'e-icons e-order', cssClass: 'top-icon e-order',
                tooltipText: this.l10n.getConstant('Duplicate'), align: 'Center' });
        }
        if (items.indexOf('remove') > -1) {
            toolbarItems.push({ id: id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                tooltipText: this.l10n.getConstant('Remove'), align: 'Center' });
        }
        if (items.indexOf('text') > -1) {
            toolbarItems.push({ id: id + '_editText', prefixIcon: 'e-icons e-annotation-edit', cssClass: 'top-icon e-annotation-edit',
                tooltipText: this.l10n.getConstant('EditText'), align: 'Center' });
        }
        var tempToolbarItems = this.processSubToolbar(items);
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            var obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] !== 'path') {
                toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                    tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
                toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                    tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
            }
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.initCropTransformToolbar = function (shape, isTransform) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getCropTransformToolbarItem();
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var args = { toolbarType: 'crop-transform', toolbarItems: this.defToolbarItems };
        parent.trigger('toolbarUpdating', args);
        this.defToolbarItems = args.toolbarItems;
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.renderCropBtn(shape);
                _this.renderStraightenSlider();
                _this.wireZoomBtnEvents();
                parent.trigger('toolbarCreated', { toolbarType: 'shapes' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                if (document.getElementById(id + '_cropBtn') && isNullOrUndefined(isTransform)) {
                    if (!Browser.isDevice) {
                        parent.notify('draw', { prop: 'select', onPropertyChange: false,
                            value: { type: _this.getCropTextContent(document.getElementById(id + '_cropBtn')).toLowerCase(),
                                startX: null, startY: null, width: null, height: null } });
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + id + '_toolbar');
        }
        var slider = parent.element.querySelector('#' + id + '_straightenSlider');
        if ((isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Straightening') > -1))
            && slider && slider.parentElement.clientHeight > this.toolbarHeight) {
            this.toolbarHeight = parent.toolbarHeight = slider.parentElement.clientHeight;
        }
        this.enableDisableTbrBtn();
        parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
    };
    ToolbarModule.prototype.getCropTextContent = function (elem) {
        if (elem) {
            var classToContentMap = { 'e-custom': 'Custom', 'e-circle': 'Circle',
                'e-square': 'Square', 'e-custom-a': '3:2', 'e-custom-b': '4:3', 'e-custom-c': '5:4', 'e-custom-d': '7:5',
                'e-custom-e': '16:9', 'e-custom-f': '2:3', 'e-custom-g': '3:4', 'e-custom-h': '4:5', 'e-custom-i': '5:7',
                'e-custom-j': '9:16'
            };
            var classList = elem.children[0].classList;
            for (var className in classToContentMap) {
                if (classList.contains(className)) {
                    return classToContentMap[className];
                }
            }
        }
        return '';
    };
    ToolbarModule.prototype.getCurrentShapeIcon = function (shape) {
        // eslint-disable-next-line @typescript-eslint/tslint/config
        var shapeIcons = {
            rectangle: 'e-rectangle',
            ellipse: 'e-circle',
            line: 'e-line',
            arrow: 'e-arrow-right-up',
            path: 'e-critical-path',
            text: 'e-add-text',
            image: 'e-image',
            pen: 'e-free-pen',
            'crop-custom': 'e-custom',
            'crop-circle': 'e-circle',
            'crop-square': 'e-square',
            'crop-3:2': 'e-custom-a',
            'crop-4:3': 'e-custom-b',
            'crop-5:4': 'e-custom-c',
            'crop-7:5': 'e-custom-d',
            'crop-16:9': 'e-custom-e',
            'crop-2:3': 'e-custom-f',
            'crop-3:4': 'e-custom-g',
            'crop-4:5': 'e-custom-h',
            'crop-5:7': 'e-custom-i',
            'crop-9:16': 'e-custom-j'
        };
        return shapeIcons[shape] ? shapeIcons[shape] : (shape && shape.indexOf('crop-') !== -1) ? 'e-custom' : 'e-free-pen';
    };
    ToolbarModule.prototype.initShapesToolbarItem = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getShapesToolbarItem(items);
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var args = { toolbarType: parent.activeObj.shape ? parent.activeObj.shape : 'shapes',
            toolbarItems: this.defToolbarItems };
        parent.trigger('toolbarUpdating', args);
        if (this.isToolbarString(args.toolbarItems)) {
            items = args.toolbarItems;
            this.excludeItems(args.toolbarItems);
        }
        else {
            this.defToolbarItems = args.toolbarItems;
        }
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.renderAnnotationBtn(true);
                _this.createRectangleRadius(items);
                _this.createShapeColor(items);
                _this.createShapeBtn(items);
                _this.createZOrderBtn(items);
                if (parent.activeObj.shape === 'arrow') {
                    // eslint-disable-next-line @typescript-eslint/tslint/config
                    if (items.some(function (item) { return item.toLowerCase().indexOf('start') > -1; })) {
                        _this.createStartBtn();
                    }
                    // eslint-disable-next-line @typescript-eslint/tslint/config
                    if (items.some(function (item) { return item.toLowerCase().indexOf('end') > -1; })) {
                        _this.createEndBtn();
                    }
                }
                _this.wireZoomBtnEvents();
                parent.trigger('toolbarCreated', { toolbarType: 'shapes' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    };
    ToolbarModule.prototype.createRectangleRadius = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('borderRadius') > -1) {
            var strokeWidthItems = [
                { id: '1', text: this.l10n.getConstant('0') },
                { id: '2', text: this.l10n.getConstant('20') },
                { id: '3', text: this.l10n.getConstant('40') },
                { id: '4', text: this.l10n.getConstant('60') },
                { id: '5', text: this.l10n.getConstant('80') },
                { id: '6', text: this.l10n.getConstant('100') }
            ];
            var strokeWidthBtn = document.getElementById(id + '_rectangleRadiusBtn');
            var spanElem_2 = document.createElement('span');
            spanElem_2.innerHTML = this.l10n.getConstant(parent.frameObj.radius.toString());
            spanElem_2.className = 'e-shape-rectangle-radius';
            strokeWidthBtn.appendChild(spanElem_2);
            // Initialize the DropDownButton component.
            var drpDownBtn_2 = new DropDownButton({ items: strokeWidthItems,
                open: function (args) {
                    if (Browser.isDevice) {
                        var parentElem = args.element.parentElement;
                        parentElem.style.top = drpDownBtn_2.element.getBoundingClientRect().top -
                            parentElem.offsetHeight + 'px';
                    }
                    var activeBtn = drpDownBtn_2.element.childNodes[0].textContent;
                    if (activeBtn !== '') {
                        args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                    }
                },
                select: function (args) {
                    _this.triggerTbarClickEvent(args);
                    spanElem_2.textContent = args.item.text;
                    parent.updateStrokeWidth(args.item.id, 'radius');
                    if (Browser.isDevice) {
                        if (document.getElementById(id + '_bottomToolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_7 = getComponent(id + '_bottomToolbar', 'toolbar');
                            toolbar_7.refreshOverflow();
                        }
                    }
                    else {
                        if (document.getElementById(id + '_toolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_8 = getComponent(id + '_toolbar', 'toolbar');
                            toolbar_8.refreshOverflow();
                        }
                    }
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn_2.appendTo('#' + id + '_rectangleRadiusBtn');
        }
    };
    ToolbarModule.prototype.beforeModeSwitch = function (args, inst) {
        this.popupLeft = args.element.offsetParent.style.left;
        if (args.mode === 'Picker') {
            inst.showButtons = true;
            inst.dataBind();
            args.element.querySelector('.e-apply').title = this.l10n.getConstant('Apply');
            args.element.querySelector('.e-cancel').title = this.l10n.getConstant('Cancel');
            args.element.querySelector('.e-mode-switch-btn').title = this.l10n.getConstant('StandardColors');
        }
        else {
            inst.showButtons = false;
            inst.dataBind();
            args.element.querySelector('.e-mode-switch-btn').title = this.l10n.getConstant('MoreColors');
        }
    };
    ToolbarModule.prototype.createShapeColor = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('fillColor') > -1) {
            parent.element.querySelector('.e-template.e-fill').appendChild(parent.createElement('input', {
                id: id + '_shape_fill'
            }));
            var fillColor_1 = new ColorPicker({
                modeSwitcher: true, noColor: true, value: '', inline: true,
                showButtons: false, mode: 'Palette', cssClass: 'e-shape-fill-color',
                beforeModeSwitch: function (args) { return _this.beforeModeSwitch(args, fillColor_1); },
                presetColors: {
                    'custom': ['', '#f44336', '#e91e63', '#9c27b0', '#673ab7', '#2196f3',
                        '#03a9f4', '#00bcd4', '#009688', '#ffeb3b', '#ffffff', '#ffebee', '#fce4ec', '#f3e5f5', '#ede7f6', '#e3f2fd',
                        '#e1f5fe', '#e0f7fa', '#e0f2f1', '#fffde7', '#f2f2f2', '#ffcdd2', '#f8bbd0', '#e1bee7', '#d1c4e9', '#bbdefb',
                        '#b3e5fc', '#b2ebf2', '#b2dfdb', '#fff9c4', '#e6e6e6', '#ef9a9a', '#f48fb1', '#ce93d8', '#b39ddb', '#90caf9',
                        '#81d4fa', '#80deea', '#80cbc4', '#fff59d', '#cccccc', '#e57373', '#f06292', '#ba68c8', '#9575cd', '#64b5f6',
                        '#4fc3f7', '#4dd0e1', '#4db6ac', '#fff176', '#b3b3b3', '#ef5350', '#ec407a', '#ab47bc', '#7e57c2', '#42a5f5',
                        '#29b6f6', '#26c6da', '#26a69a', '#ffee58', '#999999', '#e53935', '#d81b60', '#8e24aa', '#5e35b1', '#1e88e5',
                        '#039be5', '#00acc1', '#00897b', '#fdd835', '#808080', '#d32f2f', '#c2185b', '#7b1fa2', '#512da8', '#1976d2',
                        '#0288d1', '#0097a7', '#00796b', '#fbc02d', '#666666', '#c62828', '#ad1457', '#6a1b9a', '#4527a0', '#1565c0',
                        '#0277bd', '#00838f', '#00695c', '#f9a825', '#4d4d4d', '#b71c1c', '#880e4f', '#4a148c', '#311b92', '#0d47a1',
                        '#01579b', '#006064', '#004d40', '#f57f17']
                },
                beforeTileRender: function (args) {
                    if (args.value === '') {
                        args.element.classList.add('e-nocolor-item');
                    }
                },
                change: function (args) {
                    parent.updateFillColor(args.value);
                    if (args.currentValue.rgba === '') {
                        fillDDB_1.element.children[0].classList.add('e-nocolor-item');
                    }
                    else {
                        fillDDB_1.element.children[0].classList.remove('e-nocolor-item');
                        fillDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    }
                    fillDDB_1.toggle();
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                },
                onModeSwitch: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.parentElement.style.left = _this.popupLeft;
                        args.element.parentElement.parentElement.style.top = (fillDDB_1.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight) + 'px';
                    }
                },
                beforeClose: function () {
                    fillDDB_1.toggle();
                }
            }, '#' + id + '_shape_fill');
            var fillDDB_1 = new DropDownButton({
                open: function (args) {
                    var parenElem = args.element.parentElement;
                    if (Browser.isDevice) {
                        parenElem.style.top = fillDDB_1.element.getBoundingClientRect().top -
                            parenElem.offsetHeight + 'px';
                        if (window.innerWidth <= 520) {
                            parenElem.style.left = parent.element.offsetLeft + 'px';
                        }
                    }
                },
                target: '.e-shape-fill-color',
                iconCss: 'e-dropdownbtn-preview',
                cssClass: 'e-ie-ddb-popup'
            }, '#' + id + '_fillColorBtn');
            fillColor_1.inline = true;
            fillColor_1.value = fillColor_1.getValue(fillColor_1.value, 'rgba');
            parent.element.querySelector('.e-fill.e-template .e-dropdownbtn-preview').classList.add('e-nocolor-item');
        }
        if (items.indexOf('strokeColor') > -1) {
            parent.element.querySelector('.e-template.e-stroke').appendChild(parent.createElement('input', {
                id: id + '_shape_stroke'
            }));
            var strokeColor_1 = new ColorPicker({
                modeSwitcher: true, noColor: false, value: '#fff', inline: true,
                showButtons: false, mode: 'Palette', cssClass: 'e-shape-stroke-color',
                beforeModeSwitch: function (args) {
                    _this.popupLeft = args.element.offsetParent.style.left;
                    strokeColor_1.value = parent.activeObj.strokeSettings.strokeColor !== '#fff' ? parent.activeObj.strokeSettings.strokeColor : '#008000ff';
                    _this.beforeModeSwitch(args, strokeColor_1);
                },
                presetColors: this.presetColors,
                change: function (args) {
                    parent.updateStrokeColor(args.value);
                    strokeDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB_1.toggle();
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                },
                onModeSwitch: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.parentElement.style.left = _this.popupLeft;
                        args.element.parentElement.parentElement.style.top = (strokeDDB_1.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight) + 'px';
                    }
                },
                beforeClose: function () {
                    strokeDDB_1.toggle();
                }
            }, '#' + id + '_shape_stroke');
            var strokeDDB_1 = new DropDownButton({
                open: function (args) {
                    var parenElem = args.element.parentElement;
                    if (Browser.isDevice) {
                        parenElem.style.top = strokeDDB_1.element.getBoundingClientRect().top -
                            parenElem.offsetHeight + 'px';
                        if (window.innerWidth <= 520) {
                            parenElem.style.left = parent.element.offsetLeft + 'px';
                        }
                    }
                },
                target: '.e-shape-stroke-color',
                iconCss: 'e-dropdownbtn-preview',
                cssClass: 'e-ie-ddb-popup'
            }, '#' + id + '_borderColorBtn');
            strokeColor_1.inline = true;
            strokeColor_1.value = strokeColor_1.getValue(strokeColor_1.value, 'rgba');
            parent.element.querySelector('.e-stroke.e-template .e-dropdownbtn-preview').style.background = '#fff';
        }
    };
    ToolbarModule.prototype.createShapeBtn = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('strokeWidth') > -1) {
            var strokeWidthItems = [
                { id: '1', text: this.l10n.getConstant('XSmall') },
                { id: '2', text: this.l10n.getConstant('Small') },
                { id: '3', text: this.l10n.getConstant('Medium') },
                { id: '4', text: this.l10n.getConstant('Large') },
                { id: '5', text: this.l10n.getConstant('XLarge') }
            ];
            if (parent.activeObj.shape && (parent.activeObj.shape === 'rectangle' || parent.activeObj.shape === 'ellipse')) {
                strokeWidthItems = [
                    { id: '1', text: this.l10n.getConstant('NoOutline') },
                    { id: '2', text: this.l10n.getConstant('XSmall') },
                    { id: '3', text: this.l10n.getConstant('Small') },
                    { id: '4', text: this.l10n.getConstant('Medium') },
                    { id: '5', text: this.l10n.getConstant('Large') },
                    { id: '6', text: this.l10n.getConstant('XLarge') }
                ];
            }
            var strokeWidthBtn = document.getElementById(id + '_borderWidthBtn');
            var spanElem_3 = document.createElement('span');
            spanElem_3.innerHTML = this.l10n.getConstant('XSmall');
            spanElem_3.className = 'e-shape-stroke-width';
            strokeWidthBtn.appendChild(spanElem_3);
            // Initialize the DropDownButton component.
            var drpDownBtn_3 = new DropDownButton({ items: strokeWidthItems,
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn_3.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var activeBtn = spanElem_3.innerHTML;
                    if (activeBtn !== '') {
                        args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                    }
                },
                select: function (args) {
                    _this.triggerTbarClickEvent(args);
                    spanElem_3.textContent = args.item.text;
                    parent.updateStrokeWidth(args.item.id, 'width', parent.activeObj.shape);
                    if (Browser.isDevice) {
                        if (document.getElementById(id + '_bottomToolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_9 = getComponent(id + '_bottomToolbar', 'toolbar');
                            toolbar_9.refreshOverflow();
                        }
                    }
                    else {
                        if (document.getElementById(id + '_toolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_10 = getComponent(id + '_toolbar', 'toolbar');
                            toolbar_10.refreshOverflow();
                        }
                    }
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn_3.appendTo('#' + id + '_borderWidthBtn');
        }
    };
    ToolbarModule.prototype.createZOrderBtn = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('z-order') > -1) {
            var zOrderItems = [
                { text: this.l10n.getConstant('BringForward'), id: 'bringForward', iconCss: 'e-icons e-bring-forward' },
                { text: this.l10n.getConstant('SendBackward'), id: 'sendBackward', iconCss: 'e-icons e-send-backward' },
                { text: this.l10n.getConstant('BringToFront'), id: 'bringToFront', iconCss: 'e-icons e-bring-to-front' },
                { text: this.l10n.getConstant('SendToBack'), id: 'sendToBack', iconCss: 'e-icons e-send-to-back' }
            ];
            // Initialize the DropDownButton component.
            var drpDownBtn_4 = new DropDownButton({ items: zOrderItems, iconCss: 'e-icons e-layers',
                beforeOpen: function (args) {
                    if (document.getElementById(parent.element.id + '_zOrderBtn').classList.contains('e-disabled')) {
                        args.cancel = true;
                    }
                    var indexObj = { freehandSelectedIndex: -1 };
                    parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                    var orderObj = { order: null };
                    parent.notify('shape', { prop: 'getHighestOrder', onPropertyChange: false, value: { obj: orderObj } });
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var order = parent.activeObj.order ? parent.activeObj.order : parent.getObjFromId(parent.pointColl[indexObj['freehandSelectedIndex']].id).order;
                    if (order && order >= orderObj['order']) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        args.items[0].disabled = true;
                        args.items[2].disabled = true;
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        args.items[0].disabled = false;
                        args.items[2].disabled = false;
                    }
                    parent.notify('shape', { prop: 'getLowestOrder', onPropertyChange: false, value: { obj: orderObj } });
                    if (order && order <= orderObj['order']) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        args.items[1].disabled = true;
                        args.items[3].disabled = true;
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        args.items[1].disabled = false;
                        args.items[3].disabled = false;
                    }
                },
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn_4.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                },
                select: function (args) {
                    _this.triggerTbarClickEvent(args);
                    var obj = { freehandDrawSelectedId: null };
                    parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });
                    var shapeId = obj['freehandDrawSelectedId'] ? obj['freehandDrawSelectedId'] : parent.activeObj.currIndex;
                    parent.updateShapeOrder(shapeId, args.item.id);
                    if (Browser.isDevice) {
                        if (document.getElementById(id + '_bottomToolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_11 = getComponent(id + '_bottomToolbar', 'toolbar');
                            toolbar_11.refreshOverflow();
                        }
                    }
                    else {
                        if (document.getElementById(id + '_toolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_12 = getComponent(id + '_toolbar', 'toolbar');
                            toolbar_12.refreshOverflow();
                        }
                    }
                    if (shapeId.indexOf('shape') > -1) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    }
                    else if (shapeId.indexOf('pen') > -1) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', value: { isPenDraw: true } });
                    }
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn_4.appendTo('#' + id + '_zOrderBtn');
        }
    };
    ToolbarModule.prototype.createStartBtn = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('None') },
            { id: '2', text: this.l10n.getConstant('Bar') },
            { id: '3', text: this.l10n.getConstant('Arrow') },
            { id: '4', text: this.l10n.getConstant('ArrowSolid') },
            { id: '5', text: this.l10n.getConstant('Circle') },
            { id: '6', text: this.l10n.getConstant('CircleSolid') },
            { id: '7', text: this.l10n.getConstant('Square') },
            { id: '8', text: this.l10n.getConstant('SquareSolid') }
        ];
        var strokeWidthBtn = document.getElementById(id + '_startBtn');
        var spanElem = document.createElement('span');
        if (isNullOrUndefined(parent.activeObj.start)) {
            parent.activeObj.start = 'none';
        }
        spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.start);
        spanElem.className = 'e-shape-start';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                var activeBtn = spanElem.innerHTML;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                var idToValue = { '1': 'none', '2': 'bar', '3': 'arrow', '4': 'arrowSolid',
                    '5': 'circle', '6': 'circleSolid', '7': 'square', '8': 'squareSolid' };
                parent.notify('selection', { prop: 'setArrowShape', value: { type: 'initial', shape: idToValue["" + args.item.id] } });
                _this.triggerTbarClickEvent(args);
                spanElem.textContent = args.item.text;
                parent.updateArrow('startArrow', args.item.id);
                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_startBtn');
    };
    ToolbarModule.prototype.createEndBtn = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('None') },
            { id: '2', text: this.l10n.getConstant('Bar') },
            { id: '3', text: this.l10n.getConstant('Arrow') },
            { id: '4', text: this.l10n.getConstant('ArrowSolid') },
            { id: '5', text: this.l10n.getConstant('Circle') },
            { id: '6', text: this.l10n.getConstant('CircleSolid') },
            { id: '7', text: this.l10n.getConstant('Square') },
            { id: '8', text: this.l10n.getConstant('SquareSolid') }
        ];
        var strokeEndBtn = document.getElementById(id + '_endBtn');
        var spanElem = document.createElement('span');
        if (isNullOrUndefined(parent.activeObj.end)) {
            parent.activeObj.end = 'arrowSolid';
        }
        spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.end);
        spanElem.className = 'e-shape-end';
        strokeEndBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                var activeBtn = spanElem.innerHTML;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                var idToValue = { '1': 'none', '2': 'bar', '3': 'arrow', '4': 'arrowSolid',
                    '5': 'circle', '6': 'circleSolid', '7': 'square', '8': 'squareSolid' };
                parent.notify('selection', { prop: 'setArrowShape', value: { type: 'final', shape: idToValue["" + args.item.id] } });
                _this.triggerTbarClickEvent(args);
                spanElem.textContent = args.item.text;
                parent.updateArrow('endArrow', args.item.id);
                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_endBtn');
    };
    ToolbarModule.prototype.getTextToolbarItem = function (items) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar)) {
            toolbarItems.push({ id: id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + id + '_annotationBtn"></button>' });
        }
        if (items.indexOf('fontFamily') > -1) {
            toolbarItems.push({ id: id + '_fontFamily', cssClass: 'top-icon e-img-font-family',
                tooltipText: this.l10n.getConstant('FontFamily'), align: 'Center',
                template: '<button id="' + id + '_fontFamilyBtn"></button>' });
        }
        if (items.indexOf('fontSize') > -1) {
            toolbarItems.push({ id: id + '_fontSize', cssClass: 'top-icon e-img-font-size',
                tooltipText: this.l10n.getConstant('FontSize'), align: 'Center',
                template: '<button id="' + id + '_fontSizeBtn"></button>' });
        }
        if (items.indexOf('fontColor') > -1) {
            toolbarItems.push({ cssClass: 'top-icon e-text-font-color', id: id + '_text_strokecolor',
                tooltipText: this.l10n.getConstant('FontColor'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_fontColorBtn"></button>' });
        }
        if (items.indexOf('strokeColor') > -1) {
            toolbarItems.push({ cssClass: 'top-icon e-stroke-text-font-color', id: id + '_stroke_text_color',
                tooltipText: this.l10n.getConstant('TextOutlineColor'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_strokeTextColorBtn"></button>' });
        }
        if (items.indexOf('fillColor') > -1) {
            toolbarItems.push({ cssClass: 'top-icon e-text-background-color', id: id + '_text_backgroundcolor',
                tooltipText: this.l10n.getConstant('FillColor'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_bgColorBtn"></button>'
            });
        }
        if (items.indexOf('bold') > -1) {
            toolbarItems.push({ id: id + '_bold', prefixIcon: 'e-icons e-bold', cssClass: 'top-icon e-bold',
                tooltipText: this.l10n.getConstant('Bold'), align: 'Center' });
        }
        if (items.indexOf('italic') > -1) {
            toolbarItems.push({ id: id + '_italic', prefixIcon: 'e-icons e-italic', cssClass: 'top-icon e-italic',
                tooltipText: this.l10n.getConstant('Italic'), align: 'Center' });
        }
        if (items.indexOf('strokeWidth') > -1) {
            toolbarItems.push({ id: id + '_strokeWidth', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('TextOutlineWidth'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_borderWidthBtn"></button>' });
        }
        if (items.indexOf('transparency') > -1) {
            toolbarItems.push({ id: id + '_transparency', prefixIcon: 'e-opacity',
                tooltipText: this.l10n.getConstant('Opacity'), align: 'Center' });
        }
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        if (items.indexOf('z-order') > -1) {
            toolbarItems.push({ id: id + '_zOrder', cssClass: 'top-icon e-list-unordered-3', tooltipText: this.l10n.getConstant('ZOrder'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_zOrderBtn"></button>' });
        }
        if (items.indexOf('duplicate') > -1) {
            toolbarItems.push({ id: id + '_duplicate', prefixIcon: 'e-icons e-order', cssClass: 'top-icon e-order',
                tooltipText: this.l10n.getConstant('Duplicate'), align: 'Center', disabled: (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') ? true : false });
        }
        if (items.indexOf('remove') > -1) {
            toolbarItems.push({ id: id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                tooltipText: this.l10n.getConstant('Remove'), align: 'Center', disabled: (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') ? true : false });
        }
        if (items.indexOf('text') > -1) {
            toolbarItems.push({ id: id + '_editText', prefixIcon: 'e-icons e-annotation-edit', cssClass: 'top-icon e-annotation-edit',
                tooltipText: this.l10n.getConstant('EditText'), align: 'Center', disabled: (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') ? true : false });
        }
        var tempToolbarItems = this.processSubToolbar(items);
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
            toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getFontFamilyItems = function () {
        var parent = this.parent;
        var items = [];
        if (parent.fontFamily && parent.fontFamily.items && parent.fontFamily.items.length > 0) {
            items = parent.fontFamily.items;
        }
        else {
            if (Browser.isDevice) {
                items = [{ id: 'arial', text: 'ABC' }, { id: 'calibri', text: 'ABC' }, { id: 'georgia', text: 'ABC' },
                    { id: 'roboto', text: 'ABC' }, { id: 'tahoma', text: 'ABC' }];
            }
            else {
                items = [{ id: 'arial', text: 'Arial' }, { id: 'calibri', text: 'Calibri' }, { id: 'georgia', text: 'Georgia' },
                    { id: 'roboto', text: 'Roboto' }, { id: 'tahoma', text: 'Tahoma' }];
            }
        }
        return items;
    };
    ToolbarModule.prototype.initTextToolbarItem = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getTextToolbarItem(items);
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var args = { toolbarType: 'text', toolbarItems: this.defToolbarItems };
        parent.trigger('toolbarUpdating', args);
        if (this.isToolbarString(args.toolbarItems)) {
            items = args.toolbarItems;
            this.excludeItems(args.toolbarItems);
        }
        else {
            this.defToolbarItems = args.toolbarItems;
        }
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.renderAnnotationBtn(true);
                _this.createTextColor(items);
                _this.createStrokeTextColor(items);
                _this.createShapeBtn(items);
                _this.createBackgroundColor(items);
                _this.createTextBtn(items);
                _this.createZOrderBtn(items);
                _this.wireZoomBtnEvents();
                parent.trigger('toolbarCreated', { toolbarType: 'text' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    };
    ToolbarModule.prototype.createTextColor = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('fontColor') > -1 && parent.element.querySelector('.e-template.e-text-font-color')) {
            parent.element.querySelector('.e-template.e-text-font-color').appendChild(parent.createElement('input', {
                id: id + '_text_font'
            }));
            var fontColor_1 = new ColorPicker({
                modeSwitcher: true, noColor: false, value: '#fff', inline: true,
                showButtons: false, mode: 'Palette', cssClass: 'e-text-fontt-color',
                beforeModeSwitch: function (args) {
                    _this.popupLeft = args.element.offsetParent.style.left;
                    fontColor_1.value = parent.activeObj.strokeSettings.strokeColor !== '#fff' ? parent.activeObj.strokeSettings.strokeColor : '#008000ff';
                    _this.beforeModeSwitch(args, fontColor_1);
                },
                presetColors: this.presetColors,
                change: function (args) {
                    parent.updateFontColor(args.value, 'Text');
                    strokeDDB_2.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB_2.toggle();
                    if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    }
                },
                onModeSwitch: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.parentElement.style.left = _this.popupLeft;
                        args.element.parentElement.parentElement.style.top = (strokeDDB_2.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight) + 'px';
                    }
                },
                beforeClose: function () {
                    strokeDDB_2.toggle();
                }
            }, '#' + id + '_text_font');
            var strokeDDB_2 = new DropDownButton({
                open: function (args) {
                    var parenElem = args.element.parentElement;
                    if (Browser.isDevice) {
                        parenElem.style.top = strokeDDB_2.element.getBoundingClientRect().top -
                            parenElem.offsetHeight + 'px';
                        if (window.innerWidth <= 520) {
                            parenElem.style.left = parent.element.offsetLeft + 'px';
                        }
                    }
                },
                target: '.e-text-fontt-color',
                iconCss: 'e-dropdownbtn-preview',
                cssClass: 'e-ie-ddb-popup'
            }, '#' + id + '_fontColorBtn');
            fontColor_1.inline = true;
            fontColor_1.value = fontColor_1.getValue(fontColor_1.value, 'rgba');
            parent.element.querySelector('.e-text-font-color.e-template .e-dropdownbtn-preview').style.background
                = '#fff';
        }
    };
    ToolbarModule.prototype.createBackgroundColor = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('fillColor') > -1 && parent.element.querySelector('.e-template.e-text-background-color')) {
            parent.element.querySelector('.e-template.e-text-background-color').appendChild(parent.createElement('input', {
                id: id + '_text_bgColor'
            }));
            var backgroundColor_1 = new ColorPicker({
                modeSwitcher: true, noColor: true, value: '', inline: true,
                showButtons: false, mode: 'Palette', cssClass: 'e-text-fontt-color',
                beforeModeSwitch: function (args) {
                    _this.popupLeft = args.element.offsetParent.style.left;
                    _this.beforeModeSwitch(args, backgroundColor_1);
                },
                presetColors: {
                    'custom': ['', '#f44336', '#e91e63', '#9c27b0', '#673ab7', '#2196f3',
                        '#03a9f4', '#00bcd4', '#009688', '#ffeb3b', '#ffffff', '#ffebee', '#fce4ec', '#f3e5f5', '#ede7f6', '#e3f2fd',
                        '#e1f5fe', '#e0f7fa', '#e0f2f1', '#fffde7', '#f2f2f2', '#ffcdd2', '#f8bbd0', '#e1bee7', '#d1c4e9', '#bbdefb',
                        '#b3e5fc', '#b2ebf2', '#b2dfdb', '#fff9c4', '#e6e6e6', '#ef9a9a', '#f48fb1', '#ce93d8', '#b39ddb', '#90caf9',
                        '#81d4fa', '#80deea', '#80cbc4', '#fff59d', '#cccccc', '#e57373', '#f06292', '#ba68c8', '#9575cd', '#64b5f6',
                        '#4fc3f7', '#4dd0e1', '#4db6ac', '#fff176', '#b3b3b3', '#ef5350', '#ec407a', '#ab47bc', '#7e57c2', '#42a5f5',
                        '#29b6f6', '#26c6da', '#26a69a', '#ffee58', '#999999', '#e53935', '#d81b60', '#8e24aa', '#5e35b1', '#1e88e5',
                        '#039be5', '#00acc1', '#00897b', '#fdd835', '#808080', '#d32f2f', '#c2185b', '#7b1fa2', '#512da8', '#1976d2',
                        '#0288d1', '#0097a7', '#00796b', '#fbc02d', '#666666', '#c62828', '#ad1457', '#6a1b9a', '#4527a0', '#1565c0',
                        '#0277bd', '#00838f', '#00695c', '#f9a825', '#4d4d4d', '#b71c1c', '#880e4f', '#4a148c', '#311b92', '#0d47a1',
                        '#01579b', '#006064', '#004d40', '#f57f17']
                },
                beforeTileRender: function (args) {
                    if (args.value === '') {
                        args.element.classList.add('e-nocolor-item');
                    }
                },
                change: function (args) {
                    parent.updateFontColor(args.value, 'Background');
                    if (args.currentValue.rgba === '') {
                        strokeDDB_3.element.children[0].classList.add('e-nocolor-item');
                    }
                    else {
                        strokeDDB_3.element.children[0].classList.remove('e-nocolor-item');
                        strokeDDB_3.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    }
                    strokeDDB_3.toggle();
                    if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    }
                },
                onModeSwitch: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.parentElement.style.left = _this.popupLeft;
                        args.element.parentElement.parentElement.style.top = (strokeDDB_3.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight) + 'px';
                    }
                },
                beforeClose: function () {
                    strokeDDB_3.toggle();
                }
            }, '#' + id + '_text_bgColor');
            var strokeDDB_3 = new DropDownButton({
                open: function (args) {
                    var parenElem = args.element.parentElement;
                    if (Browser.isDevice) {
                        parenElem.style.top = strokeDDB_3.element.getBoundingClientRect().top -
                            parenElem.offsetHeight + 'px';
                        if (window.innerWidth <= 520) {
                            parenElem.style.left = parent.element.offsetLeft + 'px';
                        }
                    }
                },
                target: '.e-text-fontt-color',
                iconCss: 'e-dropdownbtn-preview',
                cssClass: 'e-ie-ddb-popup'
            }, '#' + id + '_bgColorBtn');
            backgroundColor_1.inline = true;
            backgroundColor_1.value = backgroundColor_1.getValue(backgroundColor_1.value, 'rgba');
            parent.element.querySelector('.e-text-background-color.e-template .e-dropdownbtn-preview').style.background
                = '#fff';
        }
    };
    ToolbarModule.prototype.createStrokeTextColor = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('strokeColor') > -1 && parent.element.querySelector('.e-template.e-stroke-text-font-color')) {
            parent.element.querySelector('.e-template.e-stroke-text-font-color').appendChild(parent.createElement('input', {
                id: id + '_stroke_text'
            }));
            var fontColor_2 = new ColorPicker({
                modeSwitcher: true, noColor: true, value: '', inline: true,
                showButtons: false, mode: 'Palette', cssClass: 'e-text-fontt-color',
                beforeModeSwitch: function (args) {
                    _this.popupLeft = args.element.offsetParent.style.left;
                    _this.beforeModeSwitch(args, fontColor_2);
                },
                presetColors: {
                    'custom': ['', '#f44336', '#e91e63', '#9c27b0', '#673ab7', '#2196f3',
                        '#03a9f4', '#00bcd4', '#009688', '#ffeb3b', '#ffffff', '#ffebee', '#fce4ec', '#f3e5f5', '#ede7f6', '#e3f2fd',
                        '#e1f5fe', '#e0f7fa', '#e0f2f1', '#fffde7', '#f2f2f2', '#ffcdd2', '#f8bbd0', '#e1bee7', '#d1c4e9', '#bbdefb',
                        '#b3e5fc', '#b2ebf2', '#b2dfdb', '#fff9c4', '#e6e6e6', '#ef9a9a', '#f48fb1', '#ce93d8', '#b39ddb', '#90caf9',
                        '#81d4fa', '#80deea', '#80cbc4', '#fff59d', '#cccccc', '#e57373', '#f06292', '#ba68c8', '#9575cd', '#64b5f6',
                        '#4fc3f7', '#4dd0e1', '#4db6ac', '#fff176', '#b3b3b3', '#ef5350', '#ec407a', '#ab47bc', '#7e57c2', '#42a5f5',
                        '#29b6f6', '#26c6da', '#26a69a', '#ffee58', '#999999', '#e53935', '#d81b60', '#8e24aa', '#5e35b1', '#1e88e5',
                        '#039be5', '#00acc1', '#00897b', '#fdd835', '#808080', '#d32f2f', '#c2185b', '#7b1fa2', '#512da8', '#1976d2',
                        '#0288d1', '#0097a7', '#00796b', '#fbc02d', '#666666', '#c62828', '#ad1457', '#6a1b9a', '#4527a0', '#1565c0',
                        '#0277bd', '#00838f', '#00695c', '#f9a825', '#4d4d4d', '#b71c1c', '#880e4f', '#4a148c', '#311b92', '#0d47a1',
                        '#01579b', '#006064', '#004d40', '#f57f17']
                },
                beforeTileRender: function (args) {
                    if (args.value === '') {
                        args.element.classList.add('e-nocolor-item');
                    }
                },
                change: function (args) {
                    parent.updateStrokeTextColor(args.value);
                    if (args.currentValue.rgba === '') {
                        strokeDDB_4.element.children[0].classList.add('e-nocolor-item');
                    }
                    else {
                        strokeDDB_4.element.children[0].classList.remove('e-nocolor-item');
                        strokeDDB_4.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    }
                    strokeDDB_4.toggle();
                    if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    }
                },
                onModeSwitch: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.parentElement.style.left = _this.popupLeft;
                        args.element.parentElement.parentElement.style.top = (strokeDDB_4.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight) + 'px';
                    }
                },
                beforeClose: function () {
                    strokeDDB_4.toggle();
                }
            }, '#' + id + '_stroke_text');
            var strokeDDB_4 = new DropDownButton({
                open: function (args) {
                    var parenElem = args.element.parentElement;
                    if (Browser.isDevice) {
                        parenElem.style.top = strokeDDB_4.element.getBoundingClientRect().top -
                            parenElem.offsetHeight + 'px';
                        if (window.innerWidth <= 520) {
                            parenElem.style.left = parent.element.offsetLeft + 'px';
                        }
                    }
                },
                target: '.e-text-fontt-color',
                iconCss: 'e-dropdownbtn-preview',
                cssClass: 'e-ie-ddb-popup'
            }, '#' + id + '_strokeTextColorBtn');
            fontColor_2.inline = true;
            fontColor_2.value = fontColor_2.getValue(fontColor_2.value, 'rgba');
            parent.element.querySelector('.e-stroke-text-font-color.e-template .e-dropdownbtn-preview').style.background
                = '#fff';
        }
    };
    ToolbarModule.prototype.createTextBtn = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('fontFamily') > -1) {
            var fontNameBtn = document.getElementById(id + '_fontFamilyBtn');
            var spanElem_4 = document.createElement('span');
            if (Browser.isDevice) {
                spanElem_4.innerHTML = 'ABC';
                spanElem_4.setAttribute('style', 'font-family: ' + parent.fontFamily.default.toLowerCase() + '\'');
            }
            else {
                spanElem_4.innerHTML = parent.fontFamily.default;
            }
            spanElem_4.className = 'e-text-font-family';
            if (fontNameBtn) {
                fontNameBtn.appendChild(spanElem_4);
            }
            var fontFamilyBtn_1 = new DropDownButton({ items: this.getFontFamilyItems(),
                cssClass: 'e-font-family',
                createPopupOnClick: true,
                beforeItemRender: function (args) {
                    args.element.setAttribute('style', 'font-family:' + args.element.id);
                },
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fontFamilyBtn_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var fontFamily;
                    if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {
                        fontFamily = parent.textArea.style.fontFamily;
                    }
                    else {
                        fontFamily = parent.activeObj.textSettings.fontFamily;
                    }
                    var elem = args.element.querySelector('[id *= ' + '"' + fontFamily.toLowerCase() + '"' + ']');
                    if (elem) {
                        elem.classList.add('e-selected-btn');
                    }
                },
                select: function (args) {
                    _this.triggerTbarClickEvent(args);
                    spanElem_4.textContent = args.item.text;
                    if (Browser.isDevice) {
                        spanElem_4.setAttribute('style', 'font-family:' + args.item.id);
                    }
                    parent.updateFontFamily(args.item.id);
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    var toolbar = document.getElementById(parent.element.id + '_toolbar');
                    if (toolbar && toolbar.classList.contains('e-control')) {
                        getComponent(toolbar, 'toolbar').refreshOverflow();
                    }
                }
            });
            fontFamilyBtn_1.appendTo('#' + id + '_fontFamilyBtn');
        }
        if (items.indexOf('fontSize') > -1) {
            var fontSizeBtnElem = document.getElementById(id + '_fontSizeBtn');
            var fontSizeSpanElem_1 = document.createElement('span');
            var fontSizes = parent.getFontSizes();
            fontSizeSpanElem_1.innerHTML = fontSizes[0].text;
            fontSizeSpanElem_1.className = 'e-text-font-size';
            fontSizeBtnElem.appendChild(fontSizeSpanElem_1);
            var fontSizeBtn_1 = new DropDownButton({
                cssClass: 'e-font-size',
                items: fontSizes,
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fontSizeBtn_1.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var activeBtn = fontSizeSpanElem_1.innerHTML;
                    args.element.querySelector('[aria-label *= ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                },
                select: function (args) {
                    _this.triggerTbarClickEvent(args);
                    fontSizeSpanElem_1.textContent = args.item.text;
                    parent.updateFontSize(args.item.text);
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                }
            });
            fontSizeBtn_1.appendTo('#' + id + '_fontSizeBtn');
        }
    };
    ToolbarModule.prototype.refreshToolbar = function (type, isApplyBtn, isCropping, isZooming, cType, shape, isTransform) {
        var parent = this.parent;
        var id = parent.element.id;
        if (!parent.isImageLoaded || parent.isCropToolbar) {
            return;
        }
        var args = {};
        var aspectIcon;
        var nonAspectIcon;
        if (type !== 'filter' && type !== 'color') {
            var toolbarElement = document.getElementById(id + '_toolbar');
            var cusWrapper = document.getElementById(id + '_customizeWrapper');
            var bottomToolbar = document.getElementById(id + '_bottomToolbar');
            if (cusWrapper && (getComponent(cusWrapper, 'toolbar')) && this.defToolbarItems.length > 0) {
                getComponent(cusWrapper, 'toolbar').destroy();
                cusWrapper.innerHTML = '';
            }
            if (toolbarElement && toolbarElement.classList.contains('e-control') && this.defToolbarItems.length > 0) {
                getComponent(toolbarElement, 'toolbar').destroy();
                toolbarElement.innerHTML = '';
            }
            if (toolbarElement && (this.defToolbarItems.length > 0 || parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf('Open') === -1)) {
                var toolbar_13 = getComponent(toolbarElement, 'toolbar');
                if (!isNullOrUndefined(toolbar_13)) {
                    toolbar_13.destroy();
                    document.getElementById(parent.element.id + '_toolbar').innerHTML = '';
                }
            }
            if (bottomToolbar && this.defToolbarItems.length > 0) {
                if (bottomToolbar.className.indexOf('e-control') > -1) {
                    getComponent(bottomToolbar, 'toolbar').destroy();
                    bottomToolbar.innerHTML = '';
                }
            }
        }
        this.refreshSlider();
        if (document.querySelector('.e-slider-tooltip')) {
            document.querySelector('.e-slider-tooltip').remove();
        }
        this.isFrameToolbar = parent.isCropTab = false;
        switch (type) {
            case 'main':
                if (Browser.isDevice) {
                    if (isCropping) {
                        this.initMainToolbar(false, true, true, false, false, true);
                    }
                    else {
                        this.initMainToolbar(false, true, null, false, false, true);
                    }
                }
                else if (!Browser.isDevice || isZooming) {
                    if (isZooming) {
                        this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
                    }
                    else {
                        this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
                    }
                }
                if (Browser.isDevice) {
                    this.initBottomToolbar();
                }
                break;
            case 'shapes':
                if (!parent.isPublicMethod) {
                    parent.noPushUndo = true;
                }
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'path') {
                    args.toolbarItems = ['strokeColor', 'strokeWidth', 'z-order', 'duplicate', 'remove'];
                }
                else if (parent.activeObj.shape === 'arrow') {
                    args.toolbarItems = ['strokeColor', 'strokeWidth', 'start', 'end', 'z-order', 'duplicate', 'remove'];
                }
                else if (parent.activeObj.shape === 'image') {
                    args.toolbarItems = ['flip', 'z-order', 'duplicate', 'remove', 'transparency'];
                }
                else if (parent.activeObj.shape === 'rectangle') {
                    args.toolbarItems = ['fillColor', 'strokeColor', 'strokeWidth', 'borderRadius', 'z-order', 'duplicate', 'remove'];
                }
                else {
                    args.toolbarItems = ['fillColor', 'strokeColor', 'strokeWidth', 'z-order', 'duplicate', 'remove'];
                }
                this.initShapesToolbarItem(args.toolbarItems);
                if (parent.activeObj.shape === 'image') {
                    var actObj = extend({}, parent.activeObj, {}, true);
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.activeObj = actObj;
                    parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj,
                            isCropRatio: null, points: null, isPreventDrag: true } });
                    this.renderQAT(false);
                }
                break;
            case 'text':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                args.toolbarItems = ['fontFamily', 'fontSize', 'fontColor', 'fillColor', 'strokeColor', 'strokeWidth', 'bold', 'italic', 'z-order', 'duplicate', 'remove', 'text'];
                this.initTextToolbarItem(args.toolbarItems);
                break;
            case 'pen':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                args.toolbarItems = ['strokeColor', 'strokeWidth', 'z-order', 'remove', 'transparency'];
                this.initPenToolbarItem(args.toolbarItems);
                break;
            case 'adjustment':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                this.initAdjustmentToolbarItem();
                break;
            case 'filter':
                this.updateContextualToolbar(type);
                break;
            case 'resize':
                if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
                    parent.aspectHeight = parent.aspectWidth;
                    this.isAspectRatio = false;
                }
                this.initResizeToolbar();
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true, true);
                }
                aspectIcon = parent.element.querySelector('#' + id + '_aspectratio');
                nonAspectIcon = parent.element.querySelector('#' + id + '_nonaspectratio');
                if (parent.aspectWidth && parent.aspectHeight) {
                    if (nonAspectIcon) {
                        parent.notify('transform', { prop: 'resize', value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: false } });
                    }
                    else if (aspectIcon) {
                        parent.notify('transform', { prop: 'resize', value: { width: parent.aspectWidth, height: null, isAspectRatio: true } });
                    }
                }
                break;
            case 'color':
                this.updateContextualToolbar(type, cType);
                break;
            case 'croptransform':
                if (isNullOrUndefined(isTransform)) {
                    parent.allowDownScale = false;
                    parent.isCropTab = true;
                }
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                if (isNullOrUndefined(isTransform)) {
                    parent.updateCropTransformItems();
                }
                this.initCropTransformToolbar(shape, isTransform);
                if (Browser.isDevice && this.isToolbar()) {
                    this.updateContextualToolbar('color', 'straighten', true);
                }
                if (parent.isMaskImage) {
                    this.refreshToolbar('main');
                }
                break;
            case 'frame':
                this.isFrameToolbar = true;
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                    this.initMainToolbar(false, true, true, false, true);
                }
                else {
                    this.initMainToolbar(true, null, null, false, true);
                }
                // eslint-disable-next-line no-case-declarations
                var frameElem = parent.element.querySelector('#' + id + '_' + parent.frameObj.type);
                if (frameElem) {
                    frameElem.classList.add('e-selected-btn');
                }
                if (parent.frameObj.type !== 'none') {
                    this.updateContextualToolbar(type, cType);
                }
                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                break;
            case 'redact':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                    this.initMainToolbar(false, true, true, null, null, null, true);
                }
                else {
                    this.initMainToolbar(isApplyBtn, Browser.isDevice, null, null, null, null, true);
                }
                this.enableDisableTbrBtn();
                if (parent.activeObj.redactType === 'blur') {
                    var redactBlurElement = parent.element.querySelector('#' + id + '_' + 'redactBlur');
                    if (redactBlurElement) {
                        redactBlurElement.classList.add('e-selected-btn');
                    }
                }
                else {
                    var pixelateElement = parent.element.querySelector('#' + id + '_' + 'pixelate');
                    if (pixelateElement) {
                        pixelateElement.classList.add('e-selected-btn');
                    }
                }
                this.redactSlider(parent.activeObj.redactType);
                break;
        }
        this.refreshDropDownBtn(isCropping);
        this.updateKBDNavigation(type);
        this.currToolbar = type;
    };
    ToolbarModule.prototype.updateRedactObj = function () {
        var parent = this.parent;
        var objColl = extend([], parent.objColl, [], true);
        parent.objColl = [];
        var activeObj = extend({}, parent.activeObj, {}, true);
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
        parent.objColl = objColl;
        for (var i = 0; i < parent.objColl.length; i++) {
            var obj = parent.objColl[i];
            if (obj.shape === 'redact') {
                obj.redactImage = parent.createElement('canvas');
                obj.redactImage.width = obj.activePoint.width;
                obj.redactImage.height = obj.activePoint.height;
                obj.redactImage.getContext('2d').drawImage(parent.lowerCanvas, obj.activePoint.startX, obj.activePoint.startY, obj.activePoint.width, obj.activePoint.height, 0, 0, obj.redactImage.width, obj.redactImage.height);
            }
        }
        parent.isCropTab = false;
        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
        parent.isCropTab = true;
        if (activeObj) {
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj,
                    isCropRatio: null, points: null, isPreventDrag: true } });
        }
        var panMoveObj = { panMove: null };
        parent.notify('transform', { prop: 'getPanMove', onPropertyChange: false,
            value: { obj: panMoveObj } });
        if (panMoveObj['panMove']) {
            parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,
                value: { xDiff: null, yDiff: null } });
        }
    };
    ToolbarModule.prototype.updateKBDNavigation = function (type) {
        var parent = this.parent;
        var id = parent.element.id;
        if (!parent.isKBDNavigation || this.currToolbar === type) {
            return;
        }
        if (this.isToolbar()) {
            var tbar = parent.element.querySelectorAll('#' + id + '_toolbar')[0];
            var tbarInitialChild = void 0;
            var tbarInitialBtn_1;
            if (tbar) {
                tbarInitialChild = tbar.querySelector('.e-toolbar-center');
                if (!tbarInitialChild || !tbarInitialChild.children[0]) {
                    return;
                }
                tbarInitialBtn_1 = tbarInitialChild.children[0].querySelector('.e-btn');
                var tempElem = tbarInitialChild.children[1];
                if (tempElem) {
                    tempElem = tempElem.children[0];
                }
                if (tempElem) {
                    tempElem = tempElem.children[0];
                }
                if (type === 'resize' && tempElem) {
                    tbarInitialBtn_1 = tempElem;
                }
                if (type === 'filter') {
                    var defaultFilter_1 = document.querySelector('#' + id + '_defaultCanvas');
                    if (defaultFilter_1) {
                        setTimeout(function () { return defaultFilter_1.focus(); }, 50);
                    }
                }
                if (tbarInitialBtn_1) {
                    if (type === 'main') {
                        setTimeout(function () { return tbarInitialBtn_1.focus(); }, 50);
                    }
                    else {
                        tbarInitialBtn_1.focus();
                    }
                }
            }
        }
    };
    ToolbarModule.prototype.performCropTransformClick = function (shape, isTransform) {
        var parent = this.parent;
        if (isNullOrUndefined(isTransform)) {
            parent.notify('draw', { prop: 'setTempStraightenZoomDeg' });
            parent.tempStraighten = parent.transform.straighten;
            if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
                parent.okBtn();
            }
            parent.isStraightening = true;
        }
        this.refreshToolbar('croptransform', null, null, null, null, shape, isTransform);
        if (isNullOrUndefined(isTransform)) {
            parent.notify('draw', { prop: 'setDestForStraighten' });
            parent.notify('draw', { prop: 'setTempDestForStraighten' });
        }
    };
    ToolbarModule.prototype.getAdjustmentToolbarItem = function () {
        var toolbarItems = [];
        var parent = this.parent;
        var isCustomized = false;
        var id = parent.element.id;
        var defItems = ['Brightness', 'Contrast', 'Hue', 'Saturation', 'Exposure', 'Opacity', 'Blur'];
        if (parent.toolbar) {
            for (var i = 0; i < defItems.length; i++) {
                if (parent.toolbar.indexOf(defItems[i]) !== -1) {
                    isCustomized = true;
                    break;
                }
            }
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Brightness') > -1)) {
            toolbarItems.push({ id: id + '_brightness', prefixIcon: 'e-icons e-brightness', cssClass: 'top-icon e-brightness',
                tooltipText: this.l10n.getConstant('Brightness'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Contrast') > -1)) {
            toolbarItems.push({ id: id + '_contrast', prefixIcon: 'e-icons e-contrast', cssClass: 'top-icon e-contrast',
                tooltipText: this.l10n.getConstant('Contrast'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Hue') > -1)) {
            toolbarItems.push({ id: id + '_hue', prefixIcon: 'e-icons e-fade', cssClass: 'top-icon e-fade',
                tooltipText: this.l10n.getConstant('Hue'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Saturation') > -1)) {
            toolbarItems.push({ id: id + '_saturation', prefixIcon: 'e-icons e-saturation', cssClass: 'top-icon e-saturation',
                tooltipText: this.l10n.getConstant('Saturation'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Exposure') > -1)) {
            toolbarItems.push({ id: id + '_exposure', prefixIcon: 'e-icons e-grain', cssClass: 'top-icon e-grain',
                tooltipText: this.l10n.getConstant('Exposure'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Opacity') > -1)) {
            toolbarItems.push({ id: id + '_opacity', prefixIcon: 'e-icons e-opacity', cssClass: 'top-icon e-opacity',
                tooltipText: this.l10n.getConstant('Opacity'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Blur') > -1)) {
            toolbarItems.push({ id: id + '_blur', prefixIcon: 'e-icons e-tint', cssClass: 'top-icon e-tint',
                tooltipText: this.l10n.getConstant('Blur'), align: 'Center' });
        }
        var tempToolbarItems = this.processToolbar('center');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
            toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getFrameToolbarItem = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: id + '_frameColor',
            cssClass: 'top-icon e-stroke', tooltipText: this.l10n.getConstant('Color'), align: 'Center', type: 'Input',
            template: '<span>' + this.l10n.getConstant('Color') + '</span><button id="' + id + '_frameColorBtn"></button>' });
        toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: id + '_frameGradient',
            cssClass: 'top-icon e-frame-stroke', tooltipText: this.l10n.getConstant('GradientColor'), align: 'Center', type: 'Input',
            template: '<span>' + this.l10n.getConstant('GradientColor') + '</span><button id="' + id + '_frameGradientColorBtn"></button>' });
        toolbarItems.push({ id: id + '_frameSize', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('Size'), align: 'Center',
            type: 'Input', template: '<span>' + this.l10n.getConstant('Size') + '</span><button id="' + id + '_frameSizeBtn"></button>' });
        if (parent.frameObj.type === 'line' || parent.frameObj.type === 'inset' || parent.frameObj.type === 'hook') {
            toolbarItems.push({ id: id + '_frameInset', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('Inset'), align: 'Center',
                type: 'Input', template: '<span>' + this.l10n.getConstant('Inset') + '</span><button id="' + id + '_frameInsetBtn"></button>' });
        }
        if (parent.frameObj.type === 'line' || parent.frameObj.type === 'inset') {
            toolbarItems.push({ id: id + '_frameOffset', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('Offset'), align: 'Center',
                type: 'Input', template: '<span>' + this.l10n.getConstant('Offset') + '</span><button id="' + id + '_frameOffsetBtn"></button>' });
        }
        if (parent.frameObj.type === 'line') {
            toolbarItems.push({ id: id + '_frameRadius', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('Radius'), align: 'Center',
                type: 'Input', template: '<span>' + this.l10n.getConstant('Radius') + '</span><button id="' + id + '_frameRadiusBtn"></button>' });
            toolbarItems.push({ id: id + '_frameAmount', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('Amount'), align: 'Center',
                type: 'Input', template: '<span>' + this.l10n.getConstant('Amount') + '</span><button id="' + id + '_frameAmountBtn"></button>' });
            toolbarItems.push({ id: id + '_frameBorder', cssClass: 'top-icon e-size', tooltipText: this.l10n.getConstant('Border'), align: 'Center',
                type: 'Input', template: '<span>' + this.l10n.getConstant('Border') + '</span><button id="' + id + '_frameBorderBtn"></button>' });
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getFilterToolbarItem = function () {
        var toolbarItems = [];
        var parent = this.parent;
        var isCustomized = false;
        var id = parent.element.id;
        var defItems = ['Default', 'Chrome', 'Cold', 'Warm', 'Grayscale', 'Sepia', 'Invert'];
        if (parent.toolbar) {
            for (var i = 0; i < defItems.length; i++) {
                if (parent.toolbar.indexOf(defItems[i]) !== -1) {
                    isCustomized = true;
                    break;
                }
            }
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Default') > -1)) {
            toolbarItems.push({ id: id + '_default', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Default'), align: 'Center',
                template: '<div class="filter-wrapper"><canvas id=' + id + '_defaultCanvas' + ' tabindex=0></canvas><div><span>' + this.l10n.getConstant('Default') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Chrome') > -1)) {
            toolbarItems.push({ id: id + '_chrome', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Chrome'), align: 'Center',
                template: '<div class="filter-wrapper"><canvas id=' + id + '_chromeCanvas' + '></canvas><div><span>' + this.l10n.getConstant('Chrome') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Cold') > -1)) {
            toolbarItems.push({ id: id + '_cold', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Cold'), align: 'Center',
                template: '<div class="filter-wrapper"><canvas id=' + id + '_coldCanvas' + '></canvas><div><span>' + this.l10n.getConstant('Cold') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Warm') > -1)) {
            toolbarItems.push({ id: id + '_warm', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Warm'), align: 'Center',
                template: '<div class="filter-wrapper"><canvas id=' + id + '_warmCanvas' + '></canvas><div><span>' + this.l10n.getConstant('Warm') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Grayscale') > -1)) {
            toolbarItems.push({ id: id + '_grayscale', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Grayscale'), align: 'Center',
                template: '<div class="filter-wrapper"><canvas id=' + id + '_grayscaleCanvas' + '></canvas><div><span>' + this.l10n.getConstant('Grayscale') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Sepia') > -1)) {
            toolbarItems.push({ id: id + '_sepia', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Sepia'), align: 'Center',
                template: '<div class="filter-wrapper"><canvas id=' + id + '_sepiaCanvas' + '></canvas><div><span>' + this.l10n.getConstant('Sepia') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || !isCustomized || (parent.toolbar && parent.toolbar.indexOf('Invert') > -1)) {
            toolbarItems.push({ id: id + '_invert', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Invert'), align: 'Center',
                template: '<div class="filter-wrapper"><canvas id=' + id + '_invertCanvas' + '></canvas><div><span>' + this.l10n.getConstant('Invert') + '</span></div></div>' });
        }
        var tempToolbarItems = this.processToolbar('center');
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.getPenToolbarItem = function (items) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarItems = [];
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
            toolbarItems.push({ id: id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + id + '_annotationBtn"></button>' });
        }
        if (items.indexOf('strokeColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: id + '_pen_strokecolor',
                cssClass: 'top-icon e-pen-stroke-color',
                tooltipText: this.l10n.getConstant('StrokeColor'), align: 'Center', type: 'Input',
                template: '<button id="' + id + '_penColorBtn"></button>' });
        }
        if (items.indexOf('strokeWidth') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: id + '_pen_strokewidth',
                cssClass: 'top-icon e-size',
                tooltipText: this.l10n.getConstant('StrokeWidth'),
                align: 'Center', type: 'Input', template: '<button id="' + id + '_penStrokeWidth"></button>' });
        }
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        if (items.indexOf('z-order') > -1) {
            toolbarItems.push({ id: id + '_zOrder', cssClass: 'top-icon e-list-unordered-3', tooltipText: this.l10n.getConstant('ZOrder'), align: 'Center',
                type: 'Input', template: '<button id="' + id + '_zOrderBtn"></button>' });
        }
        if (items.indexOf('remove') > -1) {
            toolbarItems.push({ id: id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                tooltipText: this.l10n.getConstant('Remove'), align: 'Center' });
        }
        var tempToolbarItems = this.processSubToolbar(items);
        for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right', tabIndex: 0 });
            toolbarItems.push({ id: id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    };
    ToolbarModule.prototype.initPenToolbarItem = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var leftItem = this.getLeftToolbarItem();
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getPenToolbarItem(items);
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var args = { toolbarType: 'pen', toolbarItems: this.defToolbarItems };
        parent.trigger('toolbarUpdating', args);
        if (this.isToolbarString(args.toolbarItems)) {
            items = args.toolbarItems;
            this.excludeItems(args.toolbarItems);
        }
        else {
            this.defToolbarItems = args.toolbarItems;
        }
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.renderAnnotationBtn(true);
                _this.createPenColor(items);
                _this.createPenBtn(items);
                _this.createZOrderBtn(items);
                _this.wireZoomBtnEvents();
                parent.trigger('toolbarCreated', { toolbarType: 'pen' });
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    };
    ToolbarModule.prototype.createPenColor = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        if (items.indexOf('strokeColor') > -1) {
            parent.element.querySelector('.e-template.e-pen-stroke-color').appendChild(parent.createElement('input', {
                id: id + '_pen_stroke'
            }));
            var presentVal = parent.activeObj.strokeSettings.strokeColor;
            var penColor = new ColorPicker({
                modeSwitcher: false, value: '#fff',
                showButtons: false, mode: 'Palette', cssClass: 'e-pen-color',
                change: function (args) {
                    parent.updatePenStrokeColor(args.currentValue.hex);
                    _this.selFhdColor = args.currentValue.hex;
                    strokeDDB_5.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB_5.toggle();
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', value: { isPenDraw: true } });
                }
            }, '#' + id + '_pen_stroke');
            var strokeDDB_5 = new DropDownButton({
                open: function (args) {
                    var parentElem = args.element.parentElement;
                    if (Browser.isDevice) {
                        parentElem.style.top = strokeDDB_5.element.getBoundingClientRect().top -
                            parentElem.offsetHeight + 'px';
                        if (window.innerWidth <= 520) {
                            parentElem.style.left = parent.element.offsetLeft + 'px';
                        }
                    }
                },
                target: '.e-pen-color',
                iconCss: 'e-dropdownbtn-preview',
                cssClass: 'e-ie-ddb-popup'
            }, '#' + id + '_penColorBtn');
            penColor.inline = true;
            penColor.value = penColor.getValue(parent.activeObj.strokeSettings.strokeColor, 'rgba');
            if (penColor.value === 'null') {
                penColor.value = presentVal;
            }
            var obj = { tempFreeHandDrawEditingStyles: null };
            parent.notify('freehand-draw', { prop: 'getTempFreeHandDrawEditingStyles', value: { obj: obj } });
            var indexObj = { freehandSelectedIndex: null };
            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) && indexObj['freehandSelectedIndex'] > -1) {
                parent.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview').style.background
                    = this.selFhdColor === '#42a5f5' ? obj['tempFreeHandDrawEditingStyles'].strokeColor :
                        parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;
            }
            else {
                parent.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview').style.background
                    = penColor.value;
            }
        }
    };
    ToolbarModule.prototype.createPenBtn = function (items) {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('XSmall') },
            { id: '2', text: this.l10n.getConstant('Small') },
            { id: '3', text: this.l10n.getConstant('Medium') },
            { id: '4', text: this.l10n.getConstant('Large') },
            { id: '5', text: this.l10n.getConstant('XLarge') }
        ];
        if (items.indexOf('strokeWidth') > -1) {
            var strokeWidthBtn = document.getElementById(id + '_penStrokeWidth');
            var spanElem_5 = document.createElement('span');
            var indexObj = { freehandSelectedIndex: null };
            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) && indexObj['freehandSelectedIndex'] > -1) {
                spanElem_5.innerHTML = this.getPenStroke(parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth);
            }
            else {
                var obj = { penStrokeWidth: 2 };
                parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: obj } });
                if (obj['penStrokeWidth']) {
                    spanElem_5.innerHTML = this.getPenStroke(obj['penStrokeWidth']);
                }
                else {
                    spanElem_5.innerHTML = this.l10n.getConstant('Small');
                }
            }
            spanElem_5.className = 'e-pen-stroke-width';
            strokeWidthBtn.appendChild(spanElem_5);
            var drpDownBtn_5 = new DropDownButton({ items: strokeWidthItems,
                open: function (args) {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn_5.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    var activeBtn = spanElem_5.innerHTML;
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                },
                select: function (args) {
                    _this.triggerTbarClickEvent(args);
                    spanElem_5.textContent = args.item.text;
                    parent.updatePenStrokeWidth(args.item.id);
                    if (Browser.isDevice) {
                        if (document.getElementById(id + '_bottomToolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_14 = getComponent(id + '_bottomToolbar', 'toolbar');
                            toolbar_14.refreshOverflow();
                        }
                    }
                    else {
                        if (document.getElementById(id + '_toolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var toolbar_15 = getComponent(id + '_toolbar', 'toolbar');
                            toolbar_15.refreshOverflow();
                        }
                    }
                    var widthObj = { penStrokeWidth: null };
                    parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: widthObj } });
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', value: { isPenDraw: true } });
                    parent.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: widthObj['penStrokeWidth'] } });
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn_5.appendTo('#' + id + '_penStrokeWidth');
        }
    };
    ToolbarModule.prototype.getPenStroke = function (value) {
        var textContent = '';
        var valueToTextContent = {
            1: this.l10n.getConstant('XSmall'),
            2: this.l10n.getConstant('Small'),
            3: this.l10n.getConstant('Medium'),
            4: this.l10n.getConstant('Large'),
            5: this.l10n.getConstant('XLarge')
        };
        if (value >= 1 && value <= 5) {
            textContent = valueToTextContent[value];
        }
        return textContent;
    };
    ToolbarModule.prototype.initAdjustmentToolbarItem = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var leftItem = this.getLeftToolbarItem(null);
        var rightItem = this.getRightToolbarItem();
        var mainItem = this.getAdjustmentToolbarItem();
        var zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
        }
        var args = { toolbarType: 'finetune', toolbarItems: this.defToolbarItems };
        parent.trigger('toolbarUpdating', args);
        this.defToolbarItems = args.toolbarItems;
        var toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.wireZoomBtnEvents();
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    };
    ToolbarModule.prototype.initFrameToolbarItem = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var canvasWrapper = document.querySelector('#' + id + '_contextualToolbarArea');
        var frameWrapper = document.querySelector('#' + id + '_frameWrapper');
        if (frameWrapper) {
            frameWrapper.style.display = 'block';
        }
        else {
            frameWrapper = canvasWrapper.appendChild(parent.createElement('div', {
                id: id + '_frameWrapper', className: 'e-frame-wrapper', styles: 'position: relative'
            }));
        }
        frameWrapper.appendChild(parent.createElement('div', {
            id: id + '_customizeWrapper',
            styles: 'position: absolute'
        }));
        var mainItem = this.getFrameToolbarItem();
        var args = { toolbarType: 'frame', toolbarItems: mainItem };
        parent.trigger('toolbarUpdating', args);
        mainItem = args.toolbarItems;
        var toolbar = new Toolbar({
            width: '100%',
            items: mainItem,
            clicked: this.defToolbarClicked.bind(this),
            created: function () {
                _this.createFrameColor();
                _this.createFrameSize();
                var frameType = parent.frameObj.type;
                if (frameType === 'line') {
                    _this.createFrameRadius();
                }
                if (frameType === 'line' || frameType === 'inset' || frameType === 'hook') {
                    _this.createFrameInset();
                }
                if (frameType === 'line' || frameType === 'inset') {
                    _this.createFrameOffset();
                }
                if (frameType === 'line') {
                    _this.createFrameAmount();
                    _this.createFrameBorder();
                }
                _this.createFrameGradientColor();
                if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    _this.createLeftToolbarControls();
                    if (_this.defToolbarItems.length > 0 && document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                parent.element.querySelector('#' + id + '_' + frameType).focus();
            }
        });
        toolbar.appendTo('#' + id + '_customizeWrapper');
    };
    ToolbarModule.prototype.createFrameGradientColor = function () {
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        parent.element.querySelector('.e-template.e-frame-stroke').appendChild(parent.createElement('input', {
            id: id + '_frame_gradient_fill'
        }));
        var fillColor = new ColorPicker({
            modeSwitcher: false, noColor: true, value: parent.frameObj.gradientColor,
            showButtons: false, mode: 'Palette', cssClass: 'e-frame-gradient-fill-color',
            change: function (args) {
                prevFrameSettings = { type: parent.toPascalCase(parent.frameObj.type), color: parent.frameObj.color,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
                    frameLineStyle: parent.toPascalCase(parent.frameObj.border), lineCount: parent.frameObj.amount };
                var temp = parent.frameObj.gradientColor;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.gradientColor = args.currentValue.hex;
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    if (args.currentValue.rgba === '') {
                        fillDDB.element.children[0].classList.add('e-nocolor-item');
                    }
                    else {
                        fillDDB.element.children[0].classList.remove('e-nocolor-item');
                        fillDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    }
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting,
                        currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.gradientColor = temp;
                }
                fillDDB.toggle();
            }
        }, '#' + id + '_frame_gradient_fill');
        var fillDDB = new DropDownButton({
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = fillDDB.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                    if (window.innerWidth <= 520) {
                        parentElem.style.left = parent.element.offsetLeft + 'px';
                    }
                }
            },
            target: '.e-frame-gradient-fill-color',
            iconCss: 'e-dropdownbtn-preview',
            cssClass: 'e-ie-ddb-popup'
        }, '#' + id + '_frameGradientColorBtn');
        fillColor.inline = true;
        if (parent.frameObj.gradientColor === '') {
            parent.element.querySelector('.e-frame-stroke.e-template .e-dropdownbtn-preview').classList.add('e-nocolor-item');
        }
        else {
            parent.element.querySelector('.e-frame-stroke.e-template .e-dropdownbtn-preview').style.background
                = parent.frameObj.gradientColor;
        }
    };
    ToolbarModule.prototype.createFrameColor = function () {
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        parent.element.querySelector('.e-template.e-stroke').appendChild(parent.createElement('input', {
            id: id + '_frame_fill'
        }));
        var fillColor = new ColorPicker({
            modeSwitcher: false, value: parent.frameObj.color,
            showButtons: false, mode: 'Palette', cssClass: 'e-frame-fill-color',
            change: function (args) {
                prevFrameSettings = { type: parent.toPascalCase(parent.frameObj.type), color: parent.frameObj.color,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
                    frameLineStyle: parent.toPascalCase(parent.frameObj.border), lineCount: parent.frameObj.amount };
                var temp = parent.frameObj.color;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.color = args.currentValue.hex;
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    if (args.currentValue.rgba === '') {
                        fillDDB.element.children[0].classList.add('e-nocolor-item');
                    }
                    else {
                        fillDDB.element.children[0].classList.remove('e-nocolor-item');
                        fillDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    }
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting,
                        currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.color = temp;
                }
                fillDDB.toggle();
            }
        }, '#' + id + '_frame_fill');
        var fillDDB = new DropDownButton({
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = fillDDB.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                    if (window.innerWidth <= 520) {
                        parentElem.style.left = parent.element.offsetLeft + 'px';
                    }
                }
            },
            target: '.e-frame-fill-color',
            iconCss: 'e-dropdownbtn-preview',
            cssClass: 'e-ie-ddb-popup'
        }, '#' + id + '_frameColorBtn');
        fillColor.inline = true;
        parent.element.querySelector('.e-stroke.e-template .e-dropdownbtn-preview').style.background = parent.frameObj.color;
    };
    ToolbarModule.prototype.createFrameSize = function () {
        var _this = this;
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('20') },
            { id: '2', text: this.l10n.getConstant('40') },
            { id: '3', text: this.l10n.getConstant('60') },
            { id: '4', text: this.l10n.getConstant('80') },
            { id: '5', text: this.l10n.getConstant('100') }
        ];
        var strokeWidthBtn = document.getElementById(id + '_frameSizeBtn');
        var spanElem = document.createElement('span');
        spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.size.toString());
        spanElem.className = 'e-frame-stroke-width';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                }
                var activeBtn = drpDownBtn.element.childNodes[0].textContent;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                prevFrameSettings = { type: parent.toPascalCase(parent.frameObj.type), color: parent.frameObj.color,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
                    frameLineStyle: parent.toPascalCase(parent.frameObj.border), lineCount: parent.frameObj.amount };
                var temp = parent.frameObj.size;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.size = parseInt(args.item.text, 10);
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    drpDownBtn.content = args.item.text;
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting,
                        currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.size = temp;
                }
                if (Browser.isDevice) {
                    if (document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_16 = getComponent(id + '_bottomToolbar', 'toolbar');
                        toolbar_16.refreshOverflow();
                    }
                }
                else {
                    if (document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_17 = getComponent(id + '_toolbar', 'toolbar');
                        toolbar_17.refreshOverflow();
                    }
                }
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_frameSizeBtn');
    };
    ToolbarModule.prototype.createFrameInset = function () {
        var _this = this;
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('20') },
            { id: '2', text: this.l10n.getConstant('40') },
            { id: '3', text: this.l10n.getConstant('60') },
            { id: '4', text: this.l10n.getConstant('80') },
            { id: '5', text: this.l10n.getConstant('100') }
        ];
        var strokeWidthBtn = document.getElementById(id + '_frameInsetBtn');
        var spanElem = document.createElement('span');
        spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.inset.toString());
        spanElem.className = 'e-frame-inset';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                }
                var activeBtn = drpDownBtn.element.childNodes[0].textContent;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                prevFrameSettings = { type: parent.toPascalCase(parent.frameObj.type), color: parent.frameObj.color,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
                    frameLineStyle: parent.toPascalCase(parent.frameObj.border), lineCount: parent.frameObj.amount };
                var temp = parent.frameObj.inset;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.inset = parseInt(args.item.text, 10);
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    drpDownBtn.content = args.item.text;
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting,
                        currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.inset = temp;
                }
                if (Browser.isDevice) {
                    if (document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_18 = getComponent(id + '_bottomToolbar', 'toolbar');
                        toolbar_18.refreshOverflow();
                    }
                }
                else {
                    if (document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_19 = getComponent(id + '_toolbar', 'toolbar');
                        toolbar_19.refreshOverflow();
                    }
                }
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_frameInsetBtn');
    };
    ToolbarModule.prototype.createFrameOffset = function () {
        var _this = this;
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('20') },
            { id: '2', text: this.l10n.getConstant('40') },
            { id: '3', text: this.l10n.getConstant('60') },
            { id: '4', text: this.l10n.getConstant('80') },
            { id: '5', text: this.l10n.getConstant('100') }
        ];
        var strokeWidthBtn = document.getElementById(id + '_frameOffsetBtn');
        var spanElem = document.createElement('span');
        spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.offset.toString());
        spanElem.className = 'e-frame-offset';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                }
                var activeBtn = drpDownBtn.element.childNodes[0].textContent;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                prevFrameSettings = { type: parent.toPascalCase(parent.frameObj.type), color: parent.frameObj.color,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
                    lineCount: parent.frameObj.amount, frameLineStyle: parent.toPascalCase(parent.frameObj.border) };
                var temp = parent.frameObj.offset;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.offset = parseInt(args.item.text, 10);
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    drpDownBtn.content = args.item.text;
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting,
                        currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.offset = temp;
                }
                if (Browser.isDevice) {
                    if (document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_20 = getComponent(id + '_bottomToolbar', 'toolbar');
                        toolbar_20.refreshOverflow();
                    }
                }
                else {
                    if (document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_21 = getComponent(id + '_toolbar', 'toolbar');
                        toolbar_21.refreshOverflow();
                    }
                }
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_frameOffsetBtn');
    };
    ToolbarModule.prototype.createFrameRadius = function () {
        var _this = this;
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('0') },
            { id: '2', text: this.l10n.getConstant('20') },
            { id: '3', text: this.l10n.getConstant('40') },
            { id: '4', text: this.l10n.getConstant('60') },
            { id: '5', text: this.l10n.getConstant('80') },
            { id: '6', text: this.l10n.getConstant('100') }
        ];
        var strokeWidthBtn = document.getElementById(id + '_frameRadiusBtn');
        var spanElem = document.createElement('span');
        spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.radius.toString());
        spanElem.className = 'e-frame-radius';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                }
                var activeBtn = drpDownBtn.element.childNodes[0].textContent;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                prevFrameSettings = { type: parent.toPascalCase(parent.frameObj.type), color: parent.frameObj.color,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
                    frameLineStyle: parent.toPascalCase(parent.frameObj.border),
                    lineCount: parent.frameObj.amount };
                var temp = parent.frameObj.radius;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.radius = parseInt(args.item.text, 10);
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    drpDownBtn.content = args.item.text;
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting,
                        currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.radius = temp;
                }
                if (Browser.isDevice) {
                    if (document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_22 = getComponent(id + '_bottomToolbar', 'toolbar');
                        toolbar_22.refreshOverflow();
                    }
                }
                else {
                    if (document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_23 = getComponent(id + '_toolbar', 'toolbar');
                        toolbar_23.refreshOverflow();
                    }
                }
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_frameRadiusBtn');
    };
    ToolbarModule.prototype.createFrameAmount = function () {
        var _this = this;
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('1') },
            { id: '2', text: this.l10n.getConstant('2') },
            { id: '3', text: this.l10n.getConstant('3') },
            { id: '4', text: this.l10n.getConstant('4') },
            { id: '5', text: this.l10n.getConstant('5') }
        ];
        var strokeWidthBtn = document.getElementById(id + '_frameAmountBtn');
        var spanElem = document.createElement('span');
        spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.amount.toString());
        spanElem.className = 'e-frame-amount';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                }
                var activeBtn = drpDownBtn.element.childNodes[0].textContent;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                prevFrameSettings = { type: parent.toPascalCase(parent.frameObj.type), color: parent.frameObj.color,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, borderRadius: parent.frameObj.radius,
                    lineCount: parent.frameObj.amount, frameLineStyle: parent.toPascalCase(parent.frameObj.border) };
                var temp = parent.frameObj.amount;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.amount = parseInt(args.item.text, 10);
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    drpDownBtn.content = args.item.text;
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting, currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.amount = temp;
                }
                if (Browser.isDevice) {
                    if (document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_24 = getComponent(id + '_bottomToolbar', 'toolbar');
                        toolbar_24.refreshOverflow();
                    }
                }
                else {
                    if (document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_25 = getComponent(id + '_toolbar', 'toolbar');
                        toolbar_25.refreshOverflow();
                    }
                }
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_frameAmountBtn');
    };
    ToolbarModule.prototype.createFrameBorder = function () {
        var _this = this;
        var parent = this.parent;
        var prevFrameSettings;
        var obj = { frameChangeEventArgs: null };
        var id = parent.element.id;
        var strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('Solid') },
            { id: '2', text: this.l10n.getConstant('Dashed') },
            { id: '3', text: this.l10n.getConstant('Dotted') }
        ];
        var strokeWidthBtn = document.getElementById(id + '_frameBorderBtn');
        var spanElem = document.createElement('span');
        spanElem.innerHTML = this.l10n.getConstant(parent.toPascalCase(parent.frameObj.border));
        spanElem.className = 'e-frame-border';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        var drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: function (args) {
                if (Browser.isDevice) {
                    var parentElem = args.element.parentElement;
                    parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        parentElem.offsetHeight + 'px';
                }
                var activeBtn = drpDownBtn.element.childNodes[0].textContent;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: function (args) {
                _this.triggerTbarClickEvent(args);
                prevFrameSettings = { lineCount: parent.frameObj.amount, color: parent.frameObj.color, borderRadius: parent.frameObj.radius,
                    gradientColor: parent.frameObj.gradientColor, size: parent.frameObj.size, inset: parent.frameObj.inset,
                    offset: parent.frameObj.offset, frameLineStyle: parent.toPascalCase(parent.frameObj.border),
                    type: parent.toPascalCase(parent.frameObj.type) };
                var temp = parent.frameObj.border;
                var object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                parent.frameObj.border = args.item.text.toLowerCase();
                parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: prevFrameSettings, obj: obj } });
                if (obj['frameChangeEventArgs'] && !obj['frameChangeEventArgs'].cancel) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                            operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                            previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                            previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                            previousFilter: null, isCircleCrop: null
                        } });
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                    drpDownBtn.content = args.item.text;
                    parent.curFrameObjEvent = { previousFrameSetting: obj['frameChangeEventArgs'].previousFrameSetting, currentFrameSetting: obj['frameChangeEventArgs'].currentFrameSetting };
                    parent.isFrameBtnClick = true;
                }
                else {
                    parent.frameObj.border = temp;
                }
                if (Browser.isDevice) {
                    if (document.getElementById(id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_26 = getComponent(id + '_bottomToolbar', 'toolbar');
                        toolbar_26.refreshOverflow();
                    }
                }
                else {
                    if (document.getElementById(id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        var toolbar_27 = getComponent(id + '_toolbar', 'toolbar');
                        toolbar_27.refreshOverflow();
                    }
                }
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + id + '_frameBorderBtn');
    };
    ToolbarModule.prototype.initFilterToolbarItem = function () {
        var _this = this;
        var parent = this.parent;
        var id = parent.element.id;
        var mainItem = this.getFilterToolbarItem();
        var args = { toolbarType: 'filter', toolbarItems: mainItem };
        parent.trigger('toolbarUpdating', args);
        mainItem = args.toolbarItems;
        if (document.querySelector('#' + id + '_contextualToolbar').classList.contains('e-control')) {
            getComponent(document.getElementById(id + '_contextualToolbar'), 'toolbar').destroy();
        }
        var toolbar = new Toolbar({
            width: '100%',
            items: mainItem,
            clicked: this.contextualToolbarClicked.bind(this),
            created: function () {
                _this.updatePrivateVariables();
                _this.createCanvasFilter();
                if (parent.currentFilter === '') {
                    parent.currentFilter = id + '_default';
                }
                var hdrWrapper = document.querySelector('#' + id + '_headWrapper');
                if (hdrWrapper) {
                    hdrWrapper.style.display = 'none';
                }
                var filterElem = document.getElementById(parent.currentFilter + 'Canvas');
                if (filterElem) {
                    filterElem.parentElement.parentElement.classList.add('e-selected');
                }
                _this.enableDisableTbrBtn();
                toolbar.refreshOverflow();
            }
        });
        toolbar.appendTo('#' + id + '_contextualToolbar');
    };
    ToolbarModule.prototype.drawDashedLine = function (ctx) {
        ctx.beginPath();
        ctx.setLineDash([5]);
        ctx.rect(10, 10, 280, 130);
        ctx.stroke();
        ctx.closePath();
    };
    ToolbarModule.prototype.createCanvasFilter = function () {
        var parent = this.parent;
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        var imageData = parent.getCurrentCanvasData();
        this.inMemoryCanvas.width = imageData.width;
        this.inMemoryCanvas.height = imageData.height;
        this.inMemoryContext.putImageData(imageData, 0, 0);
        this.updateFilterCanvas('_defaultCanvas', 'default');
        this.updateFilterCanvas('_chromeCanvas', 'chrome');
        this.updateFilterCanvas('_coldCanvas', 'cold');
        this.updateFilterCanvas('_warmCanvas', 'warm');
        this.updateFilterCanvas('_grayscaleCanvas', 'grayscale');
        this.updateFilterCanvas('_sepiaCanvas', 'sepia');
        this.updateFilterCanvas('_invertCanvas', 'invert');
        hideSpinner(parent.element);
        parent.element.style.opacity = '1';
        parent.initialAdjustmentValue = this.lowerContext.filter;
    };
    ToolbarModule.prototype.updateFilterCanvas = function (selector, type) {
        var parent = this.parent;
        var filter = parent.element.querySelector('#' + parent.element.id + selector);
        if (filter) {
            var ctx = filter.getContext('2d');
            ctx = filter.getContext('2d');
            filter.style.width = '100px';
            filter.style.height = '100px';
            parent.notify('filter', { prop: 'updateAdj', value: { type: type, value: null, isPreview: true, ctx: ctx } });
            ctx.drawImage(this.inMemoryCanvas, 0, 0, 300, 150);
            if (parent.isSafari) {
                parent.notify('filter', { prop: 'apply-filter', onPropertyChange: false, value: { context: ctx } });
            }
        }
    };
    ToolbarModule.prototype.getQuickAccessToolbarItem = function (isPenEdit) {
        var parent = this.parent;
        var id = parent.element.id;
        var args = { cancel: false, toolbarItems: [] };
        var toolbarItems = [];
        if (isNullOrUndefined(isPenEdit)) {
            if (parent.activeObj.shape === 'image') {
                toolbarItems.push('Flip');
            }
            if (parent.activeObj.shape !== 'redact') {
                toolbarItems.push('BringToFront');
            }
            toolbarItems.push('Clone');
            toolbarItems.push('Delete');
            if (parent.activeObj.shape === 'text') {
                toolbarItems.push('EditText');
            }
            args.shape = parent.toPascalCase(parent.activeObj.shape);
        }
        else if (isPenEdit) {
            toolbarItems.push('BringToFront');
            toolbarItems.push('Delete');
            args.shape = 'Freehand draw';
        }
        args.toolbarItems = extend([], toolbarItems, null, true);
        parent.trigger('quickAccessToolbarOpen', args);
        var orgToolbarItems = [];
        if (args.cancel) {
            orgToolbarItems = [];
        }
        else {
            for (var i = 0; i < args.toolbarItems.length; i++) {
                switch (args.toolbarItems[i]) {
                    case 'BringToFront':
                        orgToolbarItems.push({ id: id + '_bringToFront', prefixIcon: 'e-icons e-bring-to-front',
                            tooltipText: this.l10n.getConstant('BringToFront'), align: 'Left' });
                        break;
                    case 'Clone':
                        orgToolbarItems.push({ id: id + '_duplicate', prefixIcon: 'e-icons e-order', cssClass: 'top-icon e-order',
                            tooltipText: this.l10n.getConstant('Duplicate'), align: 'Left' });
                        break;
                    case 'Delete':
                        orgToolbarItems.push({ id: id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                            tooltipText: this.l10n.getConstant('Remove'), align: 'Left' });
                        break;
                    case 'EditText':
                        orgToolbarItems.push({ id: id + '_editText', prefixIcon: 'e-icons e-annotation-edit', cssClass: 'top-icon e-annotation-edit',
                            tooltipText: this.l10n.getConstant('EditText'), align: 'Left' });
                        break;
                    case 'Flip':
                        orgToolbarItems.push({ id: id + '_hFlip', prefixIcon: 'e-icons e-horizontal-flip',
                            tooltipText: this.l10n.getConstant('HorizontalFlip'), align: 'Left' });
                        orgToolbarItems.push({ id: id + '_vFlip', prefixIcon: 'e-icons e-vertical-flip',
                            tooltipText: this.l10n.getConstant('VerticalFlip'), align: 'Left' });
                        break;
                    default:
                        orgToolbarItems.push(args.toolbarItems[i]);
                        break;
                }
            }
        }
        return orgToolbarItems;
    };
    ToolbarModule.prototype.renderQAT = function (isPenEdit) {
        var parent = this.parent;
        var id = parent.element.id;
        if (parent.activeObj && parent.showQuickAccessToolbar) {
            var qtArea = document.getElementById(id + '_quickAccessToolbarArea');
            if (qtArea) {
                this.destroyQuickAccessToolbar();
                qtArea.style.display = 'block';
            }
            var items = this.getQuickAccessToolbarItem(isPenEdit);
            if (items.length === 0) {
                return;
            }
            if (isNullOrUndefined(parent.quickAccessToolbarTemplate)) {
                var toolbarObj = new Toolbar({
                    items: items,
                    clicked: this.quickAccessToolbarClicked.bind(this)
                });
                toolbarObj.appendTo('#' + id + '_quickAccessToolbar');
            }
            var height = this.toolbarHeight && this.toolbarHeight !== 0 ? this.toolbarHeight : qtArea.clientHeight;
            var wrapperElement = parent.element.querySelector('#' + id + '_headWrapper');
            if (isNullOrUndefined(isPenEdit) && (parent.activeObj.activePoint.width !== 0 ||
                parent.activeObj.activePoint.height !== 0 ||
                (parent.activeObj.shape && parent.activeObj.shape === 'path' && parent.activeObj.pointColl.length > 0))) {
                var orderObj = { order: null };
                parent.notify('shape', { prop: 'getHighestOrder', onPropertyChange: false, value: { obj: orderObj } });
                if (parent.activeObj.order > orderObj['order'] && document.getElementById(parent.element.id + '_bringToFront')) {
                    document.getElementById(parent.element.id + '_bringToFront').classList.add('e-overlay');
                }
                else {
                    if (document.getElementById(parent.element.id + '_bringToFront')) {
                        document.getElementById(parent.element.id + '_bringToFront').classList.remove('e-overlay');
                    }
                }
                qtArea.style.width = 'auto';
                parent.activeObj.activePoint.width = Math.abs(parent.activeObj.activePoint.width);
                parent.activeObj.activePoint.height = Math.abs(parent.activeObj.activePoint.height);
                var x = parent.activeObj.activePoint.startX < parent.activeObj.activePoint.endX ?
                    parent.activeObj.activePoint.startX : parent.activeObj.activePoint.endX;
                var y = parent.activeObj.activePoint.startY < parent.activeObj.activePoint.endY ?
                    parent.activeObj.activePoint.startY : parent.activeObj.activePoint.endY;
                var width = parent.activeObj.activePoint.width;
                if (parent.activeObj.rotatedAngle !== 0 && parent.activeObj.shape !== 'arrow') {
                    var object = { activePoint: null };
                    parent.notify('shape', { prop: 'getSquarePointForRotatedShape', onPropertyChange: false,
                        value: { obj: parent.activeObj, object: object } });
                    var point = object['activePoint'];
                    x = point.startX;
                    y = point.startY;
                    width = point.width;
                }
                else if (parent.activeObj.shape === 'path') {
                    var path = parent.getSquarePointForPath(parent.activeObj);
                    x = path.startX;
                    y = path.startY;
                    width = path.width;
                }
                qtArea.style.left = (x + (width / 2)) - (items.length * 25) + 'px';
                if (parseFloat(qtArea.style.left) + (qtArea.clientWidth / 2) !== x + (width / 2)) {
                    var diff = (x + (width / 2)) - (parseFloat(qtArea.style.left) + (qtArea.clientWidth / 2));
                    qtArea.style.left = parseFloat(qtArea.style.left) + diff + 'px';
                }
                if (wrapperElement) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    height = wrapperElement.offsetHeight + height;
                }
                if (y - (height + (height / 1.5)) < parent.img.destTop) {
                    qtArea.style.top = parent.img.destTop + 'px';
                    if (wrapperElement) {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        qtArea.style.top = (parent.img.destTop < 0 ? 0 : parent.img.destTop) + wrapperElement.offsetHeight + 'px';
                    }
                }
                else {
                    height = this.toolbarHeight;
                    qtArea.style.top = y - (height + (height / 1.5)) + 'px';
                }
            }
            else if (isPenEdit) {
                var indexObj = { freehandSelectedIndex: -1 };
                parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                var orderObj = { order: null };
                parent.notify('shape', { prop: 'getHighestOrder', onPropertyChange: false, value: { obj: orderObj } });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (parent.getObjFromId(parent.pointColl[indexObj['freehandSelectedIndex']].id).order >= orderObj['order'] && document.getElementById(parent.element.id + '_bringToFront')) {
                    document.getElementById(parent.element.id + '_bringToFront').classList.add('e-overlay');
                }
                else {
                    if (document.getElementById(parent.element.id + '_bringToFront')) {
                        document.getElementById(parent.element.id + '_bringToFront').classList.remove('e-overlay');
                    }
                }
                var obj = { activePoint: null };
                parent.notify('freehand-draw', { prop: 'getSqPtFD',
                    value: { idx: indexObj['freehandSelectedIndex'], obj: obj } });
                var point = obj['activePoint'];
                qtArea.style.width = 'auto';
                qtArea.style.left = (point.startX + (point.width / 2)) - (items.length * 24) + 'px';
                if (point.startY - (height + (height / 1.5)) < parent.img.destTop) {
                    qtArea.style.top = parent.img.destTop + 'px';
                }
                else {
                    qtArea.style.top = point.startY - (height + (height / 1.5)) + 'px';
                }
            }
            else {
                qtArea.style.display = 'none';
            }
            if (parseFloat(qtArea.style.top) < 0) {
                qtArea.style.top = '0px';
            }
        }
    };
    ToolbarModule.prototype.refreshDropDownBtn = function (isDisabled) {
        if (isNullOrUndefined(isDisabled)) {
            return;
        }
        var parent = this.parent;
        var id = parent.element.id;
        var annotation = document.querySelector('#' + id + '_annotationBtn');
        if (annotation) {
            if (isDisabled) {
                annotation.classList.add('e-disabled');
                annotation.parentElement.classList.add('e-overlay');
            }
            else {
                annotation.classList.remove('e-disabled');
                annotation.parentElement.classList.remove('e-overlay');
            }
            getComponent(annotation, 'dropdown-btn').disabled = isDisabled;
        }
        var transform = document.querySelector('#' + id + '_transformBtn');
        if (transform) {
            if (isDisabled) {
                transform.classList.add('e-disabled');
                transform.parentElement.classList.add('e-overlay');
            }
            else {
                transform.classList.remove('e-disabled');
                transform.parentElement.classList.remove('e-overlay');
            }
            getComponent(transform, 'dropdown-btn').disabled = isDisabled;
        }
        var adjustment = document.querySelector('#' + id + '_adjustment');
        if (adjustment) {
            if (isDisabled) {
                adjustment.classList.add('e-disabled');
                adjustment.parentElement.classList.add('e-overlay');
            }
            else {
                adjustment.classList.remove('e-disabled');
                adjustment.parentElement.classList.remove('e-overlay');
            }
            getComponent(adjustment, 'btn').disabled = isDisabled;
        }
        var filter = document.querySelector('#' + id + '_filter');
        if (filter) {
            if (isDisabled) {
                filter.classList.add('e-disabled');
                filter.parentElement.classList.add('e-overlay');
            }
            else {
                filter.classList.remove('e-disabled');
                filter.parentElement.classList.remove('e-overlay');
            }
            getComponent(filter, 'btn').disabled = isDisabled;
        }
    };
    ToolbarModule.prototype.cropSelect = function (args) {
        var parent = this.parent;
        parent.isCropTab = true;
        if (isNullOrUndefined(parent.transform.cropZoomFactor)) {
            parent.transform.cropZoomFactor = parent.transform.zoomFactor;
            parent.notify('draw', { prop: 'setTempZoomFactor', onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
        }
        parent.transform.zoomFactor = parent.transform.cropZoomFactor;
        var text = args.item.id;
        this.currentToolbar = 'crop';
        parent.currSelectionPoint = null;
        parent.notify('draw', { prop: 'setIsCropSelect', value: { bool: true } });
        var obj = { prevObj: null };
        parent.notify('crop', { prop: 'getPreviousCropCurrentObj', value: { obj: obj } });
        parent.notify('draw', { prop: 'select', onPropertyChange: false,
            value: { type: text, startX: null, startY: null, width: null, height: null } });
        parent.notify('crop', { prop: 'setPreviousCropCurrentObj', value: { obj: obj['prevObj'] } });
        this.enableDisableTbrBtn();
        parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
    };
    ToolbarModule.prototype.quickAccessToolbarClicked = function (args, isContextualToolbar) {
        var parent = this.parent;
        var id = parent.element.id;
        if (args.item) {
            var isPreventUndoRedo = null;
            var obj = { prevActObj: null };
            var object = { tempObj: null };
            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });
            parent.notify('selection', { prop: 'getTempActObj', onPropertyChange: false, value: { obj: object } });
            object['tempObj']['activePoint']['height'] = Math.abs(object['tempObj']['activePoint']['height']);
            var pathObject = { isNewPath: null };
            var ctx = void 0;
            parent.notify('draw', { prop: 'getNewPath', value: { obj: pathObject } });
            var type = args.item.id.replace(id + '_', '').toLowerCase();
            var left = void 0;
            var right = void 0;
            var indexObj = { freehandSelectedIndex: null };
            var shapeId = void 0;
            var isDisabled = void 0;
            var orderObj = { order: null };
            switch (type) {
                case 'duplicate':
                    if (!parent.element.querySelector('#' + id + '_duplicate').classList.contains('e-overlay')) {
                        this.refreshSlider();
                        if (!pathObject['isNewPath'] && JSON.stringify(object['tempObj']) === JSON.stringify(parent.activeObj)) {
                            isPreventUndoRedo = true;
                        }
                        this.duplicateShape(isPreventUndoRedo);
                    }
                    break;
                case 'remove':
                    if (!parent.element.querySelector('#' + id + '_remove').classList.contains('e-overlay')) {
                        parent.noPushUndo = false;
                        this.refreshSlider();
                        parent.notify('selection', { prop: 'deleteItem', onPropertyChange: false });
                    }
                    break;
                case 'edittext':
                    if (!parent.element.querySelector('#' + id + '_editText').classList.contains('e-overlay')) {
                        this.editText();
                    }
                    break;
                case 'rotleft':
                case 'rotright':
                    left = parent.element.querySelector('#' + id + '_rotLeft');
                    right = parent.element.querySelector('#' + id + '_rotRight');
                    if ((left && !left.classList.contains('e-disabled')) ||
                        (right && !right.classList.contains('e-disabled'))) {
                        parent.rotateImage(args.item.id.replace(id + '_', '').toLowerCase());
                    }
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    break;
                case 'hflip':
                    if (!parent.element.querySelector('#' + id + '_hFlip').classList.contains('e-disabled')) {
                        ctx = parent.activeObj.imageCanvas.getContext('2d');
                        parent.horizontalFlip(ctx);
                    }
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    break;
                case 'vflip':
                    if (!parent.element.querySelector('#' + id + '_vFlip').classList.contains('e-disabled')) {
                        ctx = parent.activeObj.imageCanvas.getContext('2d');
                        parent.verticalFlip(ctx);
                    }
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    break;
                case 'bringtofront':
                    if (!parent.element.querySelector('#' + id + '_bringToFront').classList.contains('e-overlay')) {
                        parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                        shapeId = indexObj['freehandSelectedIndex'] !== null ? parent.pointColl[indexObj['freehandSelectedIndex']].id :
                            parent.activeObj.currIndex;
                        parent.updateShapeOrder(shapeId, type);
                        isDisabled = false;
                        parent.notify('shape', { prop: 'getHighestOrder', onPropertyChange: false, value: { obj: orderObj } });
                        if (shapeId.indexOf('pen') > -1) {
                            parent.notify('shape', { prop: 'updateShapeColl', onPropertyChange: false });
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var order = parent.getObjFromId(shapeId).order;
                            isDisabled = order >= orderObj['order'] ? true : false;
                        }
                        else {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            var order = parent.getObjFromId(shapeId).order;
                            isDisabled = order > orderObj['order'] ? true : false;
                        }
                        if (isDisabled) {
                            document.getElementById(parent.element.id + '_bringToFront').classList.add('e-overlay');
                        }
                        else {
                            document.getElementById(parent.element.id + '_bringToFront').classList.remove('e-overlay');
                        }
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    }
                    break;
            }
            if (type === 'duplicate' || type === 'remove') {
                parent.notify('draw', { prop: 'redrawDownScale' });
            }
        }
        if (isNullOrUndefined(isContextualToolbar)) {
            parent.trigger('quickAccessToolbarItemClick', args);
        }
    };
    ToolbarModule.prototype.editText = function () {
        var parent = this.parent;
        var points = { x: parent.activeObj.activePoint.startX, y: parent.activeObj.activePoint.startY };
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('selection', { prop: 'setTempActObj', onPropertyChange: false,
            value: { obj: extend({}, parent.activeObj, {}, true) } });
        parent.notify('selection', { prop: 'setInitialTextEdit', onPropertyChange: false,
            value: { bool: true } });
        parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false,
            value: { prevActObj: extend({}, parent.activeObj, {}, true) } });
        if (parent.activeObj.rotatedAngle !== 0) {
            var object = { x: points.x, y: points.y };
            parent.notify('shape', { prop: 'getTextBoxPosition', onPropertyChange: false,
                value: { obj: parent.activeObj, object: object } });
            points.x = object['x'];
            points.y = object['y'];
            var object1 = { x: points.x, y: points.y };
            parent.notify('shape', { prop: 'setFlipState', onPropertyChange: false,
                value: { x: points.x, y: points.y, obj: parent.activeObj, object: object1 } });
            points.x = object1['x'];
            points.y = object1['y'];
        }
        var tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'redrawDownScale' });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        parent.activeObj = tempActiveObj;
        parent.notify('shape', { prop: 'renderTextArea', onPropertyChange: false,
            value: { x: points.x, y: points.y, actObj: parent.activeObj } });
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: true } });
        }
        if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {
            document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';
        }
    };
    ToolbarModule.prototype.duplicateShape = function (isPreventUndoRedo, isPublicMethod) {
        var parent = this.parent;
        var tempObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [], triangle: [], triangleRatio: [] };
        parent.notify('selection', { prop: 'setTempActObj', onPropertyChange: false,
            value: { obj: tempObj } });
        var obj = { prevActObj: null };
        parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });
        var pathObject = { isNewPath: null };
        parent.notify('draw', { prop: 'getNewPath', value: { obj: pathObject } });
        var objColl;
        var duplicateObj = extend({}, parent.activeObj, {}, true);
        var orderObj = { order: null };
        parent.notify('shape', { prop: 'getHighestOrder', onPropertyChange: false, value: { obj: orderObj } });
        if (duplicateObj.order) {
            parent.notify('shape', { prop: 'updateShapeColl', onPropertyChange: false });
            duplicateObj.order = orderObj['order'] > duplicateObj.order ? orderObj['order'] + 1 : duplicateObj.order + 1;
        }
        else {
            parent.noPushUndo = true;
            parent.okBtn();
            parent.noPushUndo = false;
            parent.selectShape(duplicateObj.currIndex);
            duplicateObj.order = orderObj['order'] > duplicateObj.order ? orderObj['order'] + 1 : duplicateObj.order + 1;
        }
        if (duplicateObj.shape === 'image') {
            objColl = extend([], parent.objColl, [], true);
            parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
        }
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
        }
        else if (obj['prevActObj'] || isPublicMethod) {
            parent.activeObj.currIndex = null;
            duplicateObj.currIndex = null;
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
        }
        else {
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
        }
        var noPushUndo = parent.noPushUndo;
        parent.noPushUndo = false;
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        parent.noPushUndo = noPushUndo;
        objColl = extend([], parent.objColl, [], true);
        duplicateObj.activePoint.startX += 10;
        duplicateObj.activePoint.startY -= 10;
        duplicateObj.activePoint.endX += 10;
        duplicateObj.activePoint.endY -= 10;
        if (duplicateObj.shape === 'path') {
            for (var i = 0; i < duplicateObj.pointColl.length; i++) {
                duplicateObj.pointColl[i].x += 10;
                duplicateObj.pointColl[i].y -= 10;
            }
        }
        else if (duplicateObj.shape === 'image') {
            duplicateObj.imageCanvas = parent.createElement('canvas');
        }
        var shapeIDObj = { id: 'shape_' + (parent.objColl.length + 1) };
        parent.notify('shape', { prop: 'getNewShapeId', onPropertyChange: false, value: { obj: shapeIDObj } });
        duplicateObj.currIndex = shapeIDObj['id'];
        parent.activeObj = extend({}, duplicateObj, {}, true);
        if (parent.activeObj.shape === 'image') {
            var activePoint = extend({}, duplicateObj.activePoint, {}, true);
            var dimObj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: parent.activeObj.imageElement.width, height: parent.activeObj.imageElement.height,
                    obj: dimObj, isImgShape: null } });
            parent.activeObj.activePoint.width = dimObj['width'];
            parent.activeObj.activePoint.height = dimObj['height'];
            if (parent.activeObj.isHorImageFlip && parent.activeObj.isVerImageFlip) {
                parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = false;
                parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                    value: { ctx: duplicateObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: true, isVFlip: true } });
                parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = true;
            }
            else if (parent.activeObj.isHorImageFlip) {
                parent.activeObj.isHorImageFlip = false;
                parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                    value: { ctx: duplicateObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: true, isVFlip: null } });
                parent.activeObj.isHorImageFlip = true;
            }
            else if (parent.activeObj.isVerImageFlip) {
                parent.activeObj.isVerImageFlip = false;
                parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                    value: { ctx: duplicateObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: null, isVFlip: true } });
                parent.activeObj.isVerImageFlip = true;
            }
            else {
                parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,
                    value: { ctx: duplicateObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: null, isVFlip: null } });
            }
            parent.activeObj.activePoint = activePoint;
        }
        if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow') {
            parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj,
                isCropRatio: null, points: null, isPreventDrag: true } });
        parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
        parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
        parent.noPushUndo = false;
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        parent.noPushUndo = true;
        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
            value: { obj: parent.objColl[parent.objColl.length - 1] } });
        var id = parent.element.id;
        var toolbarId = Browser.isDevice ? '#' + id + '_bottomToolbar ' + '#' + id : '#' + id;
        var object = { freehandDrawSelectedId: null };
        parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: object } });
        this.enableDisableCloneBtn(toolbarId, object);
        this.renderQAT();
        if (parent.activeObj.shape && parent.activeObj.shape === 'redact') {
            this.redactSlider(parent.activeObj.redactType);
        }
    };
    ToolbarModule.prototype.defToolbarClicked = function (args) {
        var parent = this.parent;
        var id = parent.element.id;
        var isContextualToolbar = false;
        var isFilterFinetune = false;
        if (!this.isFrameToolbar && parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
            if (!parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {
                isContextualToolbar = isFilterFinetune = true;
            }
            var straightenObj = { bool: parent.isStraightening };
            if (!Browser.isDevice || (Browser.isDevice && !straightenObj['bool'])) {
                parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
            }
        }
        if (args.item) {
            var type = args.item.id.replace(id + '_', '').toLowerCase();
            if (type === 'duplicate' || type === 'remove' || type === 'edittext' ||
                type === 'hflip' || type === 'vflip' || type === 'rotleft' || type === 'rotright') {
                this.quickAccessToolbarClicked(args, true);
                parent.trigger('toolbarItemClicked', args);
            }
            else {
                var isDisabledFilter = false;
                var isDisabledAdjustment = false;
                var adjustment = document.querySelector('#' + id + '_adjustment');
                if (adjustment && adjustment.classList.contains('e-disabled')) {
                    isDisabledAdjustment = true;
                }
                var filter = document.querySelector('#' + id + '_filter');
                if (filter && filter.classList.contains('e-disabled')) {
                    isDisabledFilter = true;
                }
                this.enableDisableTbrBtn();
                this.performDefTbrClick(type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune);
                parent.trigger('toolbarItemClicked', args);
                if (parent.isStraightening) {
                    parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
                }
                var validTypes = ['undo', 'redo', 'cancel', 'aspectratio', 'nonaspectratio',
                    'save', 'duplicate', 'filter', 'frame', 'none', 'mat', 'bevel', 'line', 'inset', 'hook', 'resize',
                    'remove'];
                if (validTypes.indexOf(type) !== -1) {
                    parent.notify('draw', { prop: 'redrawDownScale' });
                }
            }
        }
    };
    ToolbarModule.prototype.performDefTbrClick = function (type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune) {
        var parent = this.parent;
        var id = parent.element.id;
        var zoomIn = parent.element.querySelector('#' + id + '_zoomIn');
        var aspectRatioHeight = parent.element.querySelector('#' + id + '_resizeHeight');
        var aspectRatioWidth = parent.element.querySelector('#' + id + '_resizeWidth');
        var isCropSelection = false;
        var panBtn;
        var splitWords;
        var actionType;
        var actionArgs;
        var isRedactClick = false;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords === undefined && parent.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (!parent.disabled) {
            switch (type) {
                case 'pan':
                    parent.currObjType.isCustomCrop = parent.currObjType.isFiltered = false;
                    parent.currObjType.isRedact = false;
                    if (parent.currObjType.isUndoAction) {
                        parent.notify('undo-redo', { prop: 'refreshUrc', value: { bool: null } });
                    }
                    if (isCropSelection) {
                        parent.currObjType.isCustomCrop = false;
                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                        this.refreshToolbar('main');
                    }
                    if (parent.togglePan) {
                        this.cancelPan();
                        parent.notify('transform', { prop: 'setDisablePan', onPropertyChange: false, value: { bool: true } });
                        if (this.currentToolbar === 'pen') {
                            parent.freeHandDraw(true);
                        }
                    }
                    else {
                        panBtn = parent.element.querySelector('.e-img-pan .e-btn');
                        if (panBtn) {
                            panBtn.classList.add('e-selected-btn');
                        }
                        parent.pan(true);
                        parent.notify('transform', { prop: 'setDisablePan', onPropertyChange: false, value: { bool: false } });
                    }
                    if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
                        zoomIn.classList.add('e-disabled');
                        zoomIn.parentElement.classList.add('e-overlay');
                    }
                    else if (zoomIn) {
                        zoomIn.classList.remove('e-disabled');
                        zoomIn.parentElement.classList.remove('e-overlay');
                    }
                    this.refreshToolbar('main');
                    break;
                case 'cancel':
                    if (parent.currObjType.isRedact) {
                        parent.currObjType.isRedact = false;
                    }
                    if (this.isFrameToolbar && parent.element.querySelector('.e-contextual-toolbar-wrapper') && !parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {
                        parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                    }
                    parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: isContextualToolbar, isFinalCancel: true } });
                    break;
                case 'ok':
                    if (Browser.isDevice && this.isFrameToolbar && parent.element.querySelector('.e-contextual-toolbar-wrapper') && !parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {
                        parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                    }
                    parent.okBtn(null, true);
                    parent.drawingShape = null;
                    this.refreshDropDownBtn(false);
                    this.currentToolbar = 'main';
                    parent.isStraightening = false;
                    parent.notify('draw', { prop: 'resetTempObjColl' });
                    parent.notify('draw', { prop: 'resetTempPointColl' });
                    break;
                case 'crop':
                    parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
                    if (Browser.isDevice) {
                        this.updateContextualToolbar('color', 'straighten');
                    }
                    break;
                case 'reset':
                    parent.reset();
                    this.imageHeight = null;
                    this.imageWidth = null;
                    parent.aspectHeight = null;
                    parent.aspectWidth = null;
                    this.isAspectRatio = true;
                    this.currentToolbar = 'main';
                    break;
                case 'undo':
                    parent.noPushUndo = false;
                    if (parent.togglePen || parent.drawingShape) {
                        parent.okBtn();
                        parent.drawingShape = null;
                    }
                    parent.notify('undo-redo', { prop: 'call-undo' });
                    break;
                case 'redo':
                    parent.noPushUndo = false;
                    if (parent.togglePen || parent.drawingShape) {
                        parent.okBtn();
                        parent.drawingShape = null;
                    }
                    parent.notify('undo-redo', { prop: 'call-redo' });
                    break;
                case 'aspectratio':
                    if (!parent.isCircleCrop && (isNullOrUndefined(parent.currSelectionPoint)) ||
                        (parent.currSelectionPoint && parent.currSelectionPoint.shape !== 'crop-circle')) {
                        if (getComponent(aspectRatioWidth, 'numerictextbox').value) {
                            parent.aspectWidth = getComponent(aspectRatioWidth, 'numerictextbox').value;
                            parent.aspectHeight = getComponent(aspectRatioHeight, 'numerictextbox').value;
                            parent.notify('transform', { prop: 'resize', value: { width: parent.aspectWidth, height: null, isAspectRatio: true } });
                        }
                        else if (getComponent(aspectRatioHeight, 'numerictextbox').value) {
                            parent.aspectWidth = parseFloat(getComponent(aspectRatioWidth, 'numerictextbox').placeholder);
                            parent.aspectHeight = getComponent(aspectRatioHeight, 'numerictextbox').value;
                            parent.notify('transform', { prop: 'resize', value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: true } });
                        }
                        parent.resizeSrc = { startX: parent.img.srcLeft, startY: parent.img.srcTop, width: parent.img.srcWidth,
                            height: parent.img.srcHeight };
                        this.refreshToolbar('resize');
                    }
                    break;
                case 'nonaspectratio':
                    if (getComponent(aspectRatioWidth, 'numerictextbox').value ||
                        getComponent(aspectRatioHeight, 'numerictextbox').value) {
                        parent.aspectWidth = getComponent(aspectRatioWidth, 'numerictextbox').value ?
                            getComponent(aspectRatioWidth, 'numerictextbox').value :
                            parseFloat(getComponent(aspectRatioWidth, 'numerictextbox').placeholder);
                        parent.aspectHeight = getComponent(aspectRatioHeight, 'numerictextbox').value ?
                            getComponent(aspectRatioHeight, 'numerictextbox').value :
                            parseFloat(getComponent(aspectRatioHeight, 'numerictextbox').placeholder);
                        parent.notify('transform', { prop: 'resize', value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: false } });
                    }
                    parent.resizeSrc = { startX: parent.img.srcLeft, startY: parent.img.srcTop, width: parent.img.srcWidth,
                        height: parent.img.srcHeight };
                    this.refreshToolbar('resize');
                    break;
                case 'resize':
                    if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
                        parent.okBtn();
                    }
                    this.resizeClick();
                    break;
                case 'adjustment':
                    if (!isDisabledAdjustment) {
                        if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
                            parent.okBtn();
                        }
                        this.refreshToolbar('adjustment');
                        parent.setTempFilterProperties();
                        parent.notify('draw', { prop: 'updateFinetune' });
                        parent.notify('filter', { prop: 'setTempAdjVal' });
                        this.openSlider('brightness');
                    }
                    break;
                case 'brightness':
                case 'contrast':
                case 'hue':
                case 'saturation':
                case 'opacity':
                case 'blur':
                case 'exposure':
                    this.openSlider(type);
                    break;
                case 'filter':
                    if (!isDisabledFilter) {
                        showSpinner(parent.element);
                        this.refreshToolbar('filter');
                        parent.setTempFilterProperties();
                        hideSpinner(parent.element);
                    }
                    break;
                case 'default':
                case 'chrome':
                case 'cold':
                case 'warm':
                case 'grayscale':
                case 'blackandwhite':
                case 'sepia':
                case 'invert':
                case 'sharpen':
                    parent.currObjType.isFiltered = true;
                    parent.notify('filter', { prop: 'applyImageFilter', value: { option: type } });
                    break;
                case 'upload':
                    if (isFilterFinetune) {
                        parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.remove('e-hide');
                    }
                    break;
                case 'bold':
                    parent.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
                    if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'italic' } });
                    }
                    else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'default' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bolditalic' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bold' } });
                    }
                    if (parent.element.querySelector('#' + id + '_bold').classList.contains('e-selected-btn')) {
                        parent.element.querySelector('#' + id + '_bold').classList.remove('e-selected-btn');
                    }
                    else {
                        parent.element.querySelector('#' + id + '_bold').classList.add('e-selected-btn');
                    }
                    if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    }
                    break;
                case 'italic':
                    parent.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
                    if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bold' } });
                    }
                    else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bolditalic' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'default' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'italic' } });
                    }
                    if (parent.element.querySelector('#' + id + '_italic').classList.contains('e-selected-btn')) {
                        parent.element.querySelector('#' + id + '_italic').classList.remove('e-selected-btn');
                    }
                    else {
                        parent.element.querySelector('#' + id + '_italic').classList.add('e-selected-btn');
                    }
                    if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                    }
                    break;
                case 'croptransform':
                    this.performCropTransformClick();
                    break;
                case 'rotateleft':
                case 'rotateright':
                case 'horizontalflip':
                case 'verticalflip':
                    parent.transformSelect(type);
                    this.updateRedactObj();
                    if (type === 'rotateleft' || type === 'rotateright') {
                        parent.notify('draw', { prop: 'resetStraightenDestPoints' });
                        parent.notify('draw', { prop: 'setDestForStraighten' });
                    }
                    parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
                    if (Browser.isDevice) {
                        this.updateContextualToolbar('color', 'straighten');
                    }
                    actionType = type === 'rotateleft' || type === 'rotateright' ?
                        'rotate' : 'flip';
                    actionArgs = { action: actionType, actionEventArgs: parent.editCompleteArgs };
                    parent.triggerEditCompleteEvent(actionArgs);
                    break;
                case 'save':
                    parent.noPushUndo = false;
                    parent.okBtn();
                    parent.drawingShape = null;
                    this.saveDialogPopup();
                    break;
                case 'transparency':
                    this.updateContextualToolbar('transparency', 'transparency');
                    break;
                case 'frame':
                    this.frameToolbarClick();
                    break;
                case 'none':
                case 'mat':
                case 'bevel':
                case 'line':
                case 'inset':
                case 'hook':
                    this.unselectFrameBtn();
                    if (parent.element.querySelector('#' + id + '_' + type)) {
                        parent.element.querySelector('#' + id + '_' + type).classList.add('e-selected-btn');
                    }
                    parent.frameObj.type = type;
                    parent.frameObj.size = 20;
                    parent.frameObj.inset = 20;
                    parent.frameObj.radius = 0;
                    parent.frameObj.amount = 1;
                    if (type === 'inset') {
                        parent.frameObj.offset = 60;
                    }
                    else {
                        parent.frameObj.offset = 20;
                    }
                    this.refreshToolbar('frame');
                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
                    parent.isFrameBtnClick = true;
                    parent.curFrameObjEvent = { previousFrameSetting: parent.tempFrameObj, currentFrameSetting: parent.frameObj };
                    parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: parent.tempFrameObj, obj: { frameChangeEventArgs: null } } });
                    break;
                case 'redact':
                    parent.currObjType.isRedact = isRedactClick = true;
                    parent.drawingShape = 'redact';
                    if (isNullOrUndefined(parent.activeObj.redactBlur)) {
                        parent.activeObj.redactBlur = 20;
                    }
                    if (isNullOrUndefined(parent.activeObj.redactPixelate)) {
                        parent.activeObj.redactPixelate = 20;
                    }
                    parent.notify('selection', { prop: 'annotate', value: { shape: 'redact' } });
                    this.refreshToolbar('redact');
                    this.redactSlider(parent.activeObj.redactType);
                    break;
                case 'pixelate':
                    parent.currObjType.isRedact = isRedactClick = true;
                    parent.drawingShape = 'redact';
                    parent.notify('selection', { prop: 'annotate', value: { shape: 'redact' } });
                    if (parent.activeObj.redactType === 'blur') {
                        this.updateRedactType('pixelate');
                    }
                    parent.notify('shape', { prop: 'setRedactType', onPropertyChange: false,
                        value: { redactType: 'pixelate' } });
                    if (parent.activeObj.redactType === 'pixelate') {
                        var pixelateBtn = parent.element.querySelector('#' + id + '_' + 'pixelate');
                        var redactBlurBtn = parent.element.querySelector('#' + id + '_' + 'redactBlur');
                        if (pixelateBtn) {
                            pixelateBtn.classList.add('e-selected-btn');
                        }
                        if (redactBlurBtn && redactBlurBtn.classList.contains('e-selected-btn')) {
                            redactBlurBtn.classList.remove('e-selected-btn');
                        }
                    }
                    else {
                        var redactBlurBtn = parent.element.querySelector('#' + id + '_' + 'redactBlur');
                        if (redactBlurBtn) {
                            redactBlurBtn.classList.add('e-selected-btn');
                        }
                    }
                    this.redactSlider(parent.activeObj.redactType);
                    if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                            value: { operation: 'shapeTransform', previousObj: null, previousObjColl: null,
                                previousPointColl: null, previousSelPointColl: null,
                                previousCropObj: null, previousText: null,
                                currentText: null, previousFilter: null, isCircleCrop: null } });
                    }
                    break;
                case 'redactblur':
                    parent.currObjType.isRedact = isRedactClick = true;
                    parent.drawingShape = 'redact';
                    parent.notify('selection', { prop: 'annotate', value: { shape: 'redact' } });
                    parent.notify('shape', { prop: 'setRedactType', onPropertyChange: false,
                        value: { redactType: 'blur' } });
                    if (parent.activeObj.redactType === 'pixelate') {
                        this.updateRedactType('blur');
                    }
                    parent.notify('shape', { prop: 'setRedactType', onPropertyChange: false, value: { redactType: 'blur' } });
                    if (parent.activeObj.redactType === 'blur') {
                        var redactBlurBtn = parent.element.querySelector('#' + id + '_' + 'redactBlur');
                        var pixelateBtn = parent.element.querySelector('#' + id + '_' + 'pixelate');
                        if (redactBlurBtn) {
                            redactBlurBtn.classList.add('e-selected-btn');
                        }
                        if (pixelateBtn && pixelateBtn.classList.contains('e-selected-btn')) {
                            pixelateBtn.classList.remove('e-selected-btn');
                        }
                    }
                    else {
                        var pixelateBtn = parent.element.querySelector('#' + id + '_' + 'pixelate');
                        if (pixelateBtn) {
                            pixelateBtn.classList.add('e-selected-btn');
                        }
                    }
                    this.redactSlider(parent.activeObj.redactType);
                    if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                            value: { operation: 'shapeTransform', previousObj: null, previousObjColl: null,
                                previousPointColl: null, previousSelPointColl: null,
                                previousCropObj: null, previousText: null,
                                currentText: null, previousFilter: null, isCircleCrop: null } });
                    }
                    break;
            }
            if (isRedactClick) {
                parent.notify('draw', { prop: 'updateTempObjColl' });
                parent.notify('draw', { prop: 'updateTempPointColl' });
            }
        }
    };
    ToolbarModule.prototype.updateRedactType = function (value) {
        var parent = this.parent;
        parent.activeObj.redactType = value;
        parent.notify('shape', { prop: 'setRedactType', value: { type: value } });
        this.parent.objColl.push(parent.activeObj);
        parent.notify('selection', { prop: 'redrawShape', value: { obj: parent.objColl[parent.objColl.length - 1] } });
    };
    ToolbarModule.prototype.frameToolbarClick = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var frame = document.querySelector('#' + id + '_frame');
        var zoom;
        var frameObj;
        var tempFrameObj;
        parent.notify('draw', { prop: 'updateCropSelection', onPropertyChange: false });
        if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
            parent.okBtn();
        }
        if (frame && !frame.classList.contains('e-overlay')) {
            zoom = parent.transform.zoomFactor;
            parent.frameDestPoints = extend({}, parent.img, {}, true);
            if (isNullOrUndefined(parent.cxtTbarHeight)) {
                frameObj = extend({}, parent.frameObj, {}, true);
                tempFrameObj = extend({}, parent.tempFrameObj, {}, true);
                this.callFrameToolbar();
                parent.frameObj.type = 'mat';
                this.callFrameToolbar();
                parent.cxtTbarHeight = parent.element.querySelector('#' + id + '_customizeWrapper').scrollHeight;
                parent.frameObj = frameObj;
                parent.tempFrameObj = tempFrameObj;
            }
            this.zoomToFrameRange();
            parent.tempFrameZoomLevel = zoom;
            if (Browser.isDevice) {
                parent.img.destTop -= (parent.cxtTbarHeight / 2);
            }
            else {
                parent.img.destTop += (parent.cxtTbarHeight / 2);
            }
            this.callFrameToolbar();
            parent.notify('draw', { prop: 'triggerFrameChange', value: { prevFrameSettings: parent.frameObj, obj: { frameChangeEventArgs: null } } });
        }
    };
    ToolbarModule.prototype.zoomToFrameRange = function () {
        var parent = this.parent;
        this.isFrameToolbar = false;
        parent.notify('transform', { prop: 'resetZoom', onPropertyChange: false });
        var isSmaller = true;
        while (isSmaller) {
            if (this.toolbarHeight + parent.img.destTop >= (this.toolbarHeight + parent.cxtTbarHeight)) {
                isSmaller = false;
                break;
            }
            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: -.1, zoomPoint: null, isResize: true } });
        }
        this.isFrameToolbar = true;
    };
    ToolbarModule.prototype.resizeClick = function () {
        var parent = this.parent;
        parent.notify('draw', { prop: 'updateCropSelection', onPropertyChange: false });
        parent.upperCanvas.style.cursor = 'default';
        parent.notify('transform', { prop: 'updateResize', value: { bool: false } });
        if (this.isAspectRatio) {
            this.isAspectRatio = false;
        }
        else {
            this.isAspectRatio = true;
        }
        parent.isResize = true;
        this.refreshToolbar('resize');
    };
    ToolbarModule.prototype.callFrameToolbar = function () {
        var parent = this.parent;
        extend(parent.tempFrameObj, parent.frameObj);
        var undoRedoObj = { appliedUndoRedoColl: [] };
        parent.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: undoRedoObj } });
        if (undoRedoObj['appliedUndoRedoColl']['length'] === 0) {
            var object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false, value: {
                    operation: 'frame', previousObj: object['currObj'], previousObjColl: object['currObj']['objColl'],
                    previousPointColl: object['currObj']['pointColl'], previousSelPointColl: object['currObj']['selPointColl'],
                    previousCropObj: extend({}, parent.cropObj, {}, true), previousText: null, currentText: null,
                    previousFilter: null, isCircleCrop: null
                } });
        }
        this.refreshToolbar('frame');
    };
    ToolbarModule.prototype.contextualToolbarClicked = function (args) {
        var parent = this.parent;
        var selEle = parent.element.querySelector('.e-contextual-toolbar-wrapper .e-toolbar-item.e-selected');
        if (selEle) {
            selEle.classList.remove('e-selected');
        }
        var type = args.item.id.replace(parent.element.id, '').split('_')[1];
        var imageFiltering = { filter: parent.toPascalCase(type), cancel: false };
        parent.trigger('imageFiltering', imageFiltering);
        parent.editCompleteArgs = imageFiltering;
        if (imageFiltering.cancel) {
            return;
        }
        document.getElementById(args.item.id + 'Canvas').parentElement.parentElement.classList.add('e-selected');
        parent.currObjType.isFiltered = true;
        parent.notify('filter', { prop: 'applyImageFilter', value: { option: type.toLowerCase() } });
        parent.notify('draw', { prop: 'redrawDownScale' });
        parent.currentFilter = args.item.id;
        this.enableDisableTbrBtn();
        parent.isFilterCanvasClick = true;
        parent.curFilterObjEvent = imageFiltering;
    };
    ToolbarModule.prototype.refreshShapeDrawing = function () {
        var parent = this.parent;
        var object = { shape: '' };
        parent.notify('selection', { prop: 'getCurrentDrawingShape', onPropertyChange: false, value: { obj: object } });
        if (object['shape'] !== '') {
            parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.refreshToolbar('main', false);
        }
    };
    ToolbarModule.prototype.zoomInBtnClickHandler = function (e) {
        if (e) {
            var parent_1 = this.parent;
            if ((parent_1.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
                parent_1.noPushUndo = false;
                if (parent_1.currObjType.isFiltered) {
                    parent_1.okBtn();
                }
                var drawingShape = parent_1.drawingShape;
                if (parent_1.drawingShape) {
                    var id = parent_1.activeObj.currIndex;
                    parent_1.noPushUndo = true;
                    parent_1.okBtn();
                    parent_1.noPushUndo = false;
                    parent_1.drawingShape = null;
                    if (id) {
                        parent_1.selectShape(id);
                    }
                }
                this.refreshShapeDrawing();
                if (Browser.isDevice && e.type === 'touchstart') {
                    if (!e.returnValue) {
                        return;
                    }
                    e.preventDefault();
                }
                var zoomIn = document.querySelector('#' + parent_1.element.id + '_zoomIn');
                EventHandler.trigger(zoomIn, 'click');
                var obj = { bool: false };
                parent_1.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
                if (obj['bool']) {
                    parent_1.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
                    this.destroyQuickAccessToolbar();
                }
                parent_1.isZoomBtnClick = true;
                this.applyPreviewFilter();
                parent_1.currObjType.isFiltered = false;
                parent_1.currObjType.isRedact = false;
                if (parent_1.togglePen) {
                    parent_1.currObjType.isZoomed = true;
                    parent_1.freeHandDraw(false);
                    parent_1.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
                parent_1.notify('draw', { prop: 'resetCurrentSelectionPoint' });
                parent_1.drawingShape = drawingShape;
                parent_1.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: .1, zoomPoint: null, isResize: null } });
                parent_1.notify('draw', { prop: 'redrawDownScale' });
                if (parent_1.isCropTab || parent_1.activeObj.shape) {
                    parent_1.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                    parent_1.notify('freehand-draw', { prop: 'resetStraightenPoint' });
                }
                if (parent_1.isStraightening) {
                    parent_1.notify('draw', { prop: 'resetStraightenDestPoints' });
                    parent_1.notify('draw', { prop: 'setDestForStraighten' });
                }
                var actionArgs = { action: 'zoom-in',
                    actionEventArgs: parent_1.editCompleteArgs };
                parent_1.triggerEditCompleteEvent(actionArgs);
                if (Browser.isDevice) {
                    zoomIn.focus();
                }
            }
        }
    };
    ToolbarModule.prototype.zoomOutBtnClickHandler = function (e) {
        if (e) {
            var parent_2 = this.parent;
            if ((parent_2.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
                parent_2.noPushUndo = false;
                if (parent_2.currObjType.isFiltered) {
                    parent_2.okBtn();
                }
                var drawingShape = parent_2.drawingShape;
                if (parent_2.drawingShape) {
                    var id = parent_2.activeObj.currIndex;
                    parent_2.noPushUndo = true;
                    parent_2.okBtn();
                    parent_2.noPushUndo = false;
                    parent_2.drawingShape = null;
                    if (id) {
                        parent_2.selectShape(id);
                    }
                }
                this.refreshShapeDrawing();
                if (Browser.isDevice && e.type === 'touchstart') {
                    if (!e.returnValue) {
                        return;
                    }
                    e.preventDefault();
                }
                var zoomOut = document.querySelector('#' + parent_2.element.id + '_zoomOut');
                EventHandler.trigger(zoomOut, 'click');
                var obj = { bool: false };
                parent_2.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
                if (obj['bool']) {
                    parent_2.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
                    this.destroyQuickAccessToolbar();
                }
                parent_2.isZoomBtnClick = true;
                this.applyPreviewFilter();
                parent_2.currObjType.isFiltered = false;
                parent_2.currObjType.isRedact = false;
                if (parent_2.togglePen) {
                    parent_2.currObjType.isZoomed = true;
                    parent_2.freeHandDraw(false);
                    parent_2.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
                parent_2.notify('draw', { prop: 'resetCurrentSelectionPoint' });
                parent_2.drawingShape = drawingShape;
                parent_2.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: -.1, zoomPoint: null, isResize: null } });
                parent_2.notify('draw', { prop: 'redrawDownScale' });
                if (parent_2.isCropTab || parent_2.activeObj.shape) {
                    parent_2.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });
                    parent_2.notify('freehand-draw', { prop: 'resetStraightenPoint' });
                }
                if (parent_2.isStraightening) {
                    parent_2.notify('draw', { prop: 'resetStraightenDestPoints' });
                    parent_2.notify('draw', { prop: 'setDestForStraighten' });
                }
                var actionArgs = { action: 'zoom-out',
                    actionEventArgs: parent_2.editCompleteArgs };
                parent_2.triggerEditCompleteEvent(actionArgs);
                if (Browser.isDevice) {
                    zoomOut.focus();
                }
            }
        }
    };
    ToolbarModule.prototype.zoomInBtnMouseDownHandler = function (e) {
        e.preventDefault();
        this.zoomBtnHold = setInterval(this.zoomInBtnClickHandler.bind(this), 250);
    };
    ToolbarModule.prototype.zoomOutBtnMouseDownHandler = function (e) {
        e.preventDefault();
        this.zoomBtnHold = setInterval(this.zoomOutBtnClickHandler.bind(this), 250);
    };
    ToolbarModule.prototype.zoomBtnMouseUpHandler = function () {
        clearInterval(this.zoomBtnHold);
        this.zoomBtnHold = 0;
    };
    ToolbarModule.prototype.closeContextualToolbar = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var isContextualToolbar = false;
        var straightenObj = { bool: parent.isStraightening };
        if (!Browser.isDevice || (Browser.isDevice && !straightenObj['bool'])) {
            if ((parent.element.querySelector('#' + id + '_contextualToolbar') &&
                !parent.element.querySelector('#' + id + '_contextualToolbar').parentElement.classList.contains('e-hide')) ||
                (parent.element.querySelector('#' + id + '_headWrapper')
                    && !parent.element.querySelector('#' + id + '_headWrapper').parentElement.classList.contains('e-hide'))) {
                parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                parent.okBtn();
                this.refreshMainToolbar();
                isContextualToolbar = true;
            }
        }
        return isContextualToolbar;
    };
    ToolbarModule.prototype.destroyQuickAccessToolbar = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var quickToolbar = document.getElementById(id + '_quickAccessToolbar');
        if (quickToolbar && quickToolbar.classList.contains('e-control')) {
            getComponent(quickToolbar, 'toolbar').destroy();
        }
        var qatArea = document.getElementById(id + '_quickAccessToolbarArea');
        if (qatArea) {
            qatArea.style.display = 'none';
        }
    };
    ToolbarModule.prototype.renderSlider = function (type, isSelect) {
        var parent = this.parent;
        var id = parent.element.id;
        var canvasWrapper = document.querySelector('#' + id + '_contextualToolbarArea');
        var hdrWrapper = document.querySelector('#' + id + '_headWrapper');
        var labelWrapper = document.querySelector('#' + id + '_labelWrapper');
        if (hdrWrapper) {
            hdrWrapper.remove();
            labelWrapper.remove();
        }
        hdrWrapper = canvasWrapper.appendChild(parent.createElement('div', {
            id: id + '_headWrapper',
            styles: 'position: relative'
        }));
        if (type === 'transparency') {
            labelWrapper = hdrWrapper.appendChild(parent.createElement('label', {
                id: id + '_labelWrapper',
                className: 'e-ie-finetune-slider-label',
                styles: Browser.isDevice ? 'position: absolute; top: 31%; left: calc(50% - 150px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
                    : 'position: absolute; top: 31%; left: calc(50% - 220px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
            }));
        }
        else {
            labelWrapper = hdrWrapper.appendChild(parent.createElement('label', {
                id: id + '_labelWrapper',
                className: 'e-ie-finetune-slider-label',
                styles: Browser.isDevice ? ('position: absolute; top: 31%; left: calc(50% - 160px); font-size: 15px; text-transform: capitalize; font-weight: 400;')
                    : 'position: absolute; top: 25%; left: calc(50% - 226px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
            }));
        }
        labelWrapper.textContent = this.l10n.getConstant(parent.toPascalCase(type === 'transparency' ? 'opacity' : type));
        var sliderWrapper = hdrWrapper.appendChild(parent.createElement('div', {
            id: id + '_sliderWrapper',
            className: 'e-ie-finetune-slider-wrap',
            styles: 'position: absolute'
        }));
        var value = parent.getCurrAdjustmentValue(type);
        if (isSelect && type === 'straighten' && Browser.isDevice) {
            value = parent.cropObj.straighten;
        }
        var min;
        var max;
        var slider;
        if (type === 'brightness' || type === 'contrast' || type === 'saturation' || type === 'exposure') {
            if (parent.finetuneSettings) {
                if (type === 'brightness' && parent.finetuneSettings.brightness) {
                    min = parent.finetuneSettings.brightness.min;
                    max = parent.finetuneSettings.brightness.max;
                }
                else if (type === 'contrast' && parent.finetuneSettings.contrast) {
                    min = parent.finetuneSettings.contrast.min;
                    max = parent.finetuneSettings.contrast.max;
                }
                else if (type === 'saturation' && parent.finetuneSettings.saturation) {
                    min = parent.finetuneSettings.saturation.min;
                    max = parent.finetuneSettings.saturation.max;
                }
                else if (type === 'exposure' && parent.finetuneSettings.exposure) {
                    min = parent.finetuneSettings.exposure.min;
                    max = parent.finetuneSettings.exposure.max;
                }
                else {
                    min = -100;
                    max = 100;
                }
            }
            else {
                min = -100;
                max = 100;
            }
            slider = this.createSlider(min, max, value, type);
        }
        else if (type === 'hue' || type === 'blur' || type === 'opacity') {
            if (parent.finetuneSettings) {
                if (type === 'hue' && parent.finetuneSettings.hue) {
                    min = parent.finetuneSettings.hue.min;
                    max = parent.finetuneSettings.hue.max;
                }
                else if (type === 'blur' && parent.finetuneSettings.blur) {
                    min = parent.finetuneSettings.blur.min;
                    max = parent.finetuneSettings.blur.max;
                }
                else if (type === 'opacity' && parent.finetuneSettings.opacity) {
                    min = parent.finetuneSettings.opacity.min;
                    max = parent.finetuneSettings.opacity.max;
                }
                else {
                    min = 0;
                    max = 100;
                }
            }
            else {
                min = 0;
                max = 100;
            }
            slider = this.createSlider(min, max, value, type);
        }
        else if (type === 'transparency') {
            min = 0;
            max = 100;
            slider = this.createSlider(min, max, value, type);
        }
        else if (type === 'straighten') {
            min = -45;
            max = 45;
            slider = this.createSlider(min, max, value, type);
        }
        slider.appendTo('#' + id + '_sliderWrapper');
        sliderWrapper.style.left = (parseFloat(canvasWrapper.style.width) - parseFloat(slider.width)) / 2 + 'px';
        if (type === 'straighten' && Browser.isDevice) {
            var sLabelWrapper = hdrWrapper.appendChild(parent.createElement('label', {
                id: id + '_sLabelWrapper',
                className: 'e-ie-straighten-value-span e-ie-finetune-value-span',
                styles: 'position: absolute; top: 31%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;'
            }));
            sLabelWrapper.innerHTML = parent.transform.straighten.toString() + '&#176';
            sliderWrapper.parentElement.classList.add('e-straighten-slider');
        }
        if (type !== 'straighten') {
            hdrWrapper.appendChild(parent.createElement('label', {
                id: id + '_finetuneSpan',
                className: 'e-ie-finetune-value-span',
                styles: Browser.isDevice ? ('position: absolute; top: 25%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;') :
                    'position: absolute; top: 25%; left: calc(50% + 190px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
            }));
            sliderWrapper.parentElement.classList.add('e-finetune-slider');
            if (type === 'transparency' && Browser.isDevice) {
                sliderWrapper.parentElement.classList.add('e-ie-device-transparency-slider');
            }
            this.updateFinetuneSpan(type);
        }
    };
    ToolbarModule.prototype.createSlider = function (min, max, value, type) {
        var _this = this;
        var parent = this.parent;
        var step = type === 'straighten' ? 3 : 1;
        return new Slider({
            value: value, type: 'MinRange', min: min, max: max,
            step: step, width: Browser.isDevice ? '180px' : (type === 'straighten' ? '200px' : '300px'),
            cssClass: 'e-slider',
            change: function (args) {
                parent.notify('selection', { prop: 'setSliderActive', onPropertyChange: false, value: { bool: true } });
                if (type === 'transparency') {
                    if (parent.activeObj.shape) {
                        if (isNullOrUndefined(parent.activeObj.imageRatio)) {
                            parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                        }
                        parent.notify('shape', { prop: 'pushActItemIntoObj' });
                        var prevCropObj = extend({}, parent.cropObj, {}, true);
                        var object = { currObj: {} };
                        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                        var prevObj = object['currObj'];
                        prevObj.objColl = extend([], parent.objColl, [], true);
                        prevObj.pointColl = extend([], parent.pointColl, [], true);
                        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
                        var selPointCollObj = { selPointColl: null };
                        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                            value: { obj: selPointCollObj } });
                        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
                        parent.objColl.pop();
                        parent.activeObj.opacity = args.value / 100;
                        _this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
                        parent.objColl.push(parent.activeObj);
                        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                            value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                                previousCropObj: prevCropObj, previousText: null,
                                currentText: null, previousFilter: null, isCircleCrop: null } });
                        parent.notify('selection', { prop: 'redrawShape', value: { obj: parent.objColl[parent.objColl.length - 1] } });
                        _this.updateFinetuneSpan(type);
                    }
                }
                else if (type === 'straighten') {
                    parent.setStraighten(args.value);
                }
                else {
                    if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
                        parent.isFinetuning = true;
                    }
                    parent.notify('selection', { prop: 'setSliding', value: { bool: true } });
                    parent.setCurrAdjustmentValue(type, args.value);
                    _this.updateFinetuneSpan(type);
                    _this.enableDisableTbrBtn();
                    parent.isFinetuning = false;
                }
            },
            changed: function () {
                if (type !== 'transparency' && type !== 'straighten') {
                    parent.notify('selection', { prop: 'setSliding', value: { bool: false } });
                    parent.notify('draw', { prop: 'redrawDownScale' });
                }
                parent.notify('selection', { prop: 'setSliderActive', onPropertyChange: false, value: { bool: false } });
                if (type === 'transparency') {
                    setTimeout(function () {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                        parent.element.querySelector('#' + parent.element.id + '_transparency').click();
                    }, 50);
                }
            }
        });
    };
    ToolbarModule.prototype.updateFinetuneSpan = function (type) {
        var parent = this.parent;
        var ftValPan = parent.element.querySelector('.e-ie-finetune-value-span');
        if (ftValPan) {
            var adjObj = { adjustmentLevel: null };
            parent.notify('filter', { prop: 'getAdjustmentLevel', onPropertyChange: false, value: { obj: adjObj } });
            ftValPan.innerHTML = Math.round(adjObj['adjustmentLevel'][type]).toString();
        }
    };
    ToolbarModule.prototype.applyPreviewFilter = function () {
        var parent = this.parent;
        if (document.querySelector('#' + parent.element.id + '_sliderWrapper') ||
            parent.currObjType.isFiltered) {
            parent.initialAdjustmentValue = this.lowerContext.filter;
            parent.canvasFilter = this.lowerContext.filter;
            parent.currObjType.isFiltered = false;
        }
    };
    ToolbarModule.prototype.unselectBtn = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var selectors = [
            '#' + id + '_brightness',
            '#' + id + '_contrast',
            '#' + id + '_hue',
            '#' + id + '_saturation',
            '#' + id + '_opacity',
            '#' + id + '_blur',
            '#' + id + '_exposure'
        ];
        for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
            var selector = selectors_1[_i];
            var element = document.querySelector(selector);
            if (element && element.classList.contains('e-selected-btn')) {
                element.classList.remove('e-selected-btn');
                break;
            }
        }
    };
    ToolbarModule.prototype.openSlider = function (type) {
        this.unselectBtn();
        this.parent.currObjType.isFiltered = true;
        this.refreshToolbar('color', null, null, null, type);
        document.getElementById(this.parent.element.id + '_' + type).classList.add('e-selected-btn');
    };
    ToolbarModule.prototype.refreshSlider = function () {
        var id = this.parent.element.id;
        var sliderWrapper = document.querySelector('#' + id + '_sliderWrapper');
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        var slider = document.querySelector('.e-slider');
        var hdrWrapper = document.querySelector('#' + id + '_headWrapper');
        if (hdrWrapper) {
            hdrWrapper.style.display = 'none';
        }
        if (sliderWrapper && slider) {
            slider.ej2_instances[0].destroy();
            sliderWrapper.remove();
        }
    };
    ToolbarModule.prototype.unselectFrameBtn = function () {
        var parent = this.parent;
        var id = parent.element.id;
        var selectors = [
            '#' + id + '_none',
            '#' + id + '_mat',
            '#' + id + '_line',
            '#' + id + '_inset',
            '#' + id + '_bevel',
            '#' + id + '_hook'
        ];
        for (var _i = 0, selectors_2 = selectors; _i < selectors_2.length; _i++) {
            var selector = selectors_2[_i];
            var element = document.querySelector(selector);
            if (element.classList.contains('e-selected-btn')) {
                element.classList.remove('e-selected-btn');
                break;
            }
        }
    };
    ToolbarModule.prototype.updateToolbarItems = function () {
        var parent = this.parent;
        var id = parent.element.id;
        if (!parent.isImageLoaded) {
            return;
        }
        if (this.isToolbar()) {
            var selFillElem = parent.element.querySelector('.e-fill.e-template .e-dropdownbtn-preview');
            var selStrokeElem = parent.element.querySelector('.e-stroke.e-template .e-dropdownbtn-preview');
            var selTextStrokeElem = parent.element.querySelector('.e-text-font-color.e-template .e-dropdownbtn-preview');
            var selStrokeTextColorElem = parent.element.querySelector('.e-stroke-text-font-color.e-template .e-dropdownbtn-preview');
            var selTextBGElem = parent.element.querySelector('.e-text-background-color.e-template .e-dropdownbtn-preview');
            var selPenStrokeElem = parent.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview');
            var strokeWidthElem = parent.element.querySelector('.e-shape-stroke-width');
            var rectangleRadiusElem = parent.element.querySelector('.e-shape-rectangle-radius');
            var fontFamilyElem = parent.element.querySelector('.e-text-font-family');
            var fontSizeElem = parent.element.querySelector('.e-text-font-size');
            var boldBtn = parent.element.querySelector('#' + id + '_bold');
            var italicBtn = parent.element.querySelector('#' + id + '_italic');
            if (parent.activeObj.strokeSettings && parent.activeObj.textSettings) {
                if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
                    parent.activeObj.strokeSettings.strokeWidth = 2;
                }
                if (isNullOrUndefined(parent.activeObj.strokeSettings.outlineWidth)) {
                    parent.activeObj.strokeSettings.outlineWidth = 2;
                }
                if (selFillElem) {
                    var value = parent.activeObj.strokeSettings.fillColor;
                    if (parent.activeObj.strokeSettings.fillColor === '') {
                        selFillElem.classList.add('e-nocolor-item');
                    }
                    else {
                        selFillElem.classList.remove('e-nocolor-item');
                        selFillElem.style.background = value;
                    }
                    if (document.querySelector('#' + id + '_shape_fill')) {
                        getComponent(id + '_shape_fill', 'colorpicker').value = value;
                    }
                }
                if (selStrokeElem) {
                    var value = parent.activeObj.strokeSettings.strokeColor;
                    selStrokeElem.style.background = value;
                    if (document.querySelector('#' + id + '_shape_stroke')) {
                        getComponent(id + '_shape_stroke', 'colorpicker').value = value;
                    }
                }
                if (selTextStrokeElem) {
                    var value = parent.activeObj.strokeSettings.strokeColor;
                    selTextStrokeElem.style.background = value;
                    if (document.querySelector('#' + id + '_text_font')) {
                        getComponent(id + '_text_font', 'colorpicker').value = value;
                    }
                }
                if (selStrokeTextColorElem) {
                    var value = parent.activeObj.strokeSettings.outlineColor;
                    if (!/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$|^[a-zA-Z]+$/.test(parent.activeObj.strokeSettings.outlineColor)) {
                        selStrokeTextColorElem.classList.add('e-nocolor-item');
                    }
                    else {
                        selStrokeTextColorElem.classList.remove('e-nocolor-item');
                        selStrokeTextColorElem.style.background = value;
                    }
                    if (document.querySelector('#' + id + '_stroke_text')) {
                        getComponent(id + '_stroke_text', 'colorpicker').value = value;
                    }
                }
                if (selTextBGElem) {
                    var value = parent.activeObj.strokeSettings.fillColor;
                    if (parent.activeObj.strokeSettings.fillColor === '' || parent.activeObj.strokeSettings.fillColor === 'transparent') {
                        selTextBGElem.classList.add('e-nocolor-item');
                    }
                    else {
                        selTextBGElem.classList.remove('e-nocolor-item');
                        selTextBGElem.style.background = value;
                    }
                    if (document.querySelector('#' + id + '_text_bgColor')) {
                        getComponent(id + '_text_bgColor', 'colorpicker').value = value;
                    }
                }
                if (selPenStrokeElem) {
                    var value = parent.activeObj.strokeSettings.strokeColor;
                    selPenStrokeElem.style.background = value;
                    if (document.querySelector('#' + id + '_pen_stroke')) {
                        getComponent(id + '_pen_stroke', 'colorpicker').value = value;
                    }
                    var obj = { penOpacity: 1 };
                    parent.notify('freehand-draw', { prop: 'getPenOpacity', onPropertyChange: false, value: { obj: obj } });
                }
                if (fontFamilyElem) {
                    if (Browser.isDevice) {
                        fontFamilyElem.setAttribute('style', 'font-family:' + parent.activeObj.textSettings.fontFamily.toLowerCase());
                    }
                    else {
                        fontFamilyElem.textContent = parent.activeObj.textSettings.fontFamily;
                    }
                }
                if (fontSizeElem) {
                    for (var i = 0; i < parent.fontSizeColl.length; i++) {
                        if (parseInt(parent.fontSizeColl[i].text, 10) >= Math.round(parent.activeObj.textSettings.fontSize)) {
                            fontSizeElem.textContent = (i + 1).toString();
                            break;
                        }
                        else {
                            if (Math.round(parent.activeObj.textSettings.fontSize) < parseInt(parent.fontSizeColl[0].text, 10)) {
                                fontSizeElem.textContent = '1';
                                break;
                            }
                            else if (Math.round(parent.activeObj.textSettings.fontSize) >
                                parseInt(parent.fontSizeColl[parent.fontSizeColl.length - 1].text, 10)) {
                                fontSizeElem.textContent = ((parent.fontSizeColl.length - 1) + 1).toString();
                                break;
                            }
                        }
                    }
                }
                if (boldBtn) {
                    if (parent.activeObj.textSettings.bold) {
                        boldBtn.classList.add('e-selected-btn');
                    }
                    else {
                        boldBtn.classList.remove('e-selected-btn');
                    }
                }
                if (italicBtn) {
                    if (parent.activeObj.textSettings.italic) {
                        italicBtn.classList.add('e-selected-btn');
                    }
                    else {
                        italicBtn.classList.remove('e-selected-btn');
                    }
                }
                if (strokeWidthElem) {
                    var width = parent.activeObj.shape === 'text' ? parent.activeObj.strokeSettings.outlineWidth : parent.activeObj.strokeSettings.strokeWidth;
                    var strokeWidth = Math.round(width).toString();
                    strokeWidthElem.textContent = this.getStrokeWidth(strokeWidth);
                }
                if (rectangleRadiusElem) {
                    var rectRadius = Math.round((parent.activeObj.strokeSettings.radius)).toString();
                    rectangleRadiusElem.textContent = this.getRectRadius(rectRadius);
                }
            }
        }
    };
    ToolbarModule.prototype.getStrokeWidth = function (text) {
        var strokeWidth;
        var currentWidth = parseInt(text, 10) / 2;
        switch (currentWidth) {
            case 0:
                strokeWidth = this.l10n.getConstant('NoOutline');
                break;
            case 1:
                strokeWidth = this.l10n.getConstant('XSmall');
                break;
            case 2:
                strokeWidth = this.l10n.getConstant('Small');
                break;
            case 3:
                strokeWidth = this.l10n.getConstant('Medium');
                break;
            case 4:
                strokeWidth = this.l10n.getConstant('Large');
                break;
            case 5:
                strokeWidth = this.l10n.getConstant('XLarge');
                break;
        }
        return strokeWidth;
    };
    ToolbarModule.prototype.getRectRadius = function (text) {
        var rectRadius;
        var currentWidth = parseInt(text, 10) / 2;
        switch (currentWidth) {
            case 0:
                rectRadius = this.l10n.getConstant('0');
                break;
            case 1:
                rectRadius = this.l10n.getConstant('20');
                break;
            case 2:
                rectRadius = this.l10n.getConstant('40');
                break;
            case 3:
                rectRadius = this.l10n.getConstant('60');
                break;
            case 4:
                rectRadius = this.l10n.getConstant('80');
                break;
            case 5:
                rectRadius = this.l10n.getConstant('100');
                break;
        }
        return rectRadius;
    };
    ToolbarModule.prototype.cancelPan = function () {
        var parent = this.parent;
        parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
        var panBtn = parent.element.querySelector('.e-img-pan .e-btn');
        if (panBtn) {
            panBtn.classList.remove('e-selected-btn');
        }
        parent.pan(false);
    };
    ToolbarModule.prototype.refreshMainToolbar = function () {
        if (this.currToolbar !== 'main') {
            this.refreshToolbar('main');
        }
    };
    ToolbarModule.prototype.destroySubComponents = function () {
        var parent = this.parent;
        var inputElement = parent.element.querySelectorAll('input.e-control');
        var btnElement = parent.element.querySelectorAll('button.e-control');
        for (var i = 0, len = inputElement.length; i < len; i++) {
            if (inputElement[i].classList.contains('e-color-picker')) {
                getComponent(inputElement[i], 'color-picker').destroy();
                detach(select('input#' + inputElement[i].id, parent.element));
            }
        }
        for (var i = 0, len = btnElement.length; i < len; i++) {
            if (btnElement[i].classList.contains('e-dropdown-btn')) {
                getComponent(btnElement[i], 'dropdown-btn').destroy();
                detach(select('button#' + btnElement[i].id, parent.element));
            }
            else if (btnElement[i].classList.contains('e-btn')) {
                getComponent(btnElement[i], 'btn').destroy();
                detach(select('button#' + btnElement[i].id, parent.element));
            }
        }
    };
    ToolbarModule.prototype.setInitialShapeSettings = function (args) {
        var parent = this.parent;
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.currObjType.shape = args.item.id;
        parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
        parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
        parent.activeObj.shapeDegree = parent.transform.degree;
        parent.activeObj.shapeFlip = parent.transform.currFlipState;
        parent.activeObj.textFlip = parent.transform.currFlipState;
        parent.activeObj.flipObjColl = [];
        var orderObj = { order: null };
        parent.notify('shape', { prop: 'getNewOrder', onPropertyChange: false, value: { obj: orderObj } });
        parent.activeObj.order = orderObj['order'];
    };
    ToolbarModule.prototype.isToolbarString = function (items) {
        var isString = false;
        for (var i = 0; i < items.length; i++) {
            if (typeof (items[i]) === 'string') {
                isString = true;
                break;
            }
        }
        return isString;
    };
    ToolbarModule.prototype.excludeItems = function (items) {
        var indexArr = [];
        for (var i = 0; i < items.length; i++) {
            var index = this.getIndex(items[i]);
            if (index !== -1) {
                indexArr.push(index);
            }
        }
        var negativeIndexArr = [];
        for (var i = 0; i < this.defToolbarItems.length; i++) {
            if (this.defToolbarItems[i].align === 'Center' && !this.isSameIndex(indexArr, i) &&
                this.defToolbarItems[i].id !== this.parent.element.id + '_' + 'annotation') {
                negativeIndexArr.push(i);
            }
        }
        for (var i = negativeIndexArr.length - 1; i >= 0; i--) {
            this.defToolbarItems.splice(negativeIndexArr[i], 1);
        }
    };
    ToolbarModule.prototype.isSameIndex = function (indexArr, index) {
        for (var i = 0; i < indexArr.length; i++) {
            if (indexArr[i] === index) {
                return true;
            }
        }
        return false;
    };
    ToolbarModule.prototype.getIndex = function (item) {
        var index = -1;
        var isFontColor = false;
        if (item === 'rotateLeft') {
            item = 'rotLeft';
        }
        if (item === 'rotateRight') {
            item = 'rotRight';
        }
        if (item === 'horizontalFlip') {
            item = 'hflip';
        }
        if (item === 'verticalFlip') {
            item = 'vflip';
        }
        if (item === 'arrowStart') {
            item = 'start';
        }
        if (item === 'arrowEnd') {
            item = 'end';
        }
        if (item === 'fontColor') {
            item = 'strokeColor';
            isFontColor = true;
        }
        for (var i = 0; i < this.defToolbarItems.length; i++) {
            var id = this.defToolbarItems[i].id;
            if (id && id.toLowerCase().indexOf(item.toLowerCase()) !== -1) {
                index = i;
                break;
            }
        }
        if (isFontColor) {
            item = 'fontColor';
        }
        return index;
    };
    ToolbarModule.prototype.getModuleName = function () {
        return 'toolbar-module';
    };
    ToolbarModule.prototype.redactSlider = function (type) {
        var parent = this.parent;
        var id = parent.element.id;
        var toolbarArea = parent.element.querySelector('#' + id + '_toolbarArea');
        var contextualToolbarArea = parent.element.querySelector('#' + id + '_contextualToolbarArea');
        if (!contextualToolbarArea) {
            return;
        }
        contextualToolbarArea.classList.remove('e-hide');
        contextualToolbarArea.style.left = toolbarArea.offsetLeft + 'px';
        var canvasWrapper = document.querySelector('#' + id + '_contextualToolbarArea');
        var hdrWrapper = document.querySelector('#' + id + '_headWrapper');
        var labelWrapper = document.querySelector('#' + id + '_labelWrapper');
        var ctxTbar = document.querySelector('#' + id + '_contextualToolbar');
        if (hdrWrapper) {
            hdrWrapper.remove();
            labelWrapper.remove();
        }
        if (ctxTbar) {
            ctxTbar.remove();
            this.createContextualToolbar();
        }
        hdrWrapper = canvasWrapper.appendChild(parent.createElement('div', {
            id: id + '_headWrapper',
            styles: 'position: relative'
        }));
        labelWrapper = hdrWrapper.appendChild(parent.createElement('label', {
            id: id + '_labelWrapper',
            className: 'e-ie-finetune-slider-label',
            styles: Browser.isDevice ? ('position: absolute; top: 31%; left: calc(50% - 160px); font-size: 15px; text-transform: capitalize; font-weight: 400;')
                : 'position: absolute; top: 25%; left: calc(50% - 226px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
        }));
        var text = type === 'blur' ? this.l10n.getConstant('Blur') : this.l10n.getConstant('PixelSize');
        labelWrapper.textContent = text;
        var sliderWrapper = hdrWrapper.appendChild(parent.createElement('div', {
            id: id + '_sliderWrapper',
            className: 'e-ie-finetune-slider-wrap',
            styles: 'position: absolute'
        }));
        hdrWrapper.appendChild(parent.createElement('label', {
            id: id + '_redactSpan',
            className: 'e-ie-redact-value-span',
            styles: Browser.isDevice ? ('position: absolute; top: 30%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;') :
                'position: absolute; top: 30%; left: calc(50% + 190px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
        }));
        sliderWrapper.parentElement.classList.add('e-finetune-slider');
        var value = parent.activeObj.redactType === 'blur' ? parent.activeObj.redactBlur :
            parent.activeObj.redactPixelate;
        var redactSlider = new Slider({
            tooltip: { placement: 'Before', isVisible: true, showOn: 'Focus' },
            min: 10, max: 100, step: 1, value: value,
            type: 'MinRange',
            width: Browser.isDevice ? '130px' : '300px',
            created: function () {
                parent.element.querySelector('.e-ie-redact-value-span').innerText = value.toString();
            },
            change: function (args) {
                parent.element.querySelector('.e-ie-redact-value-span').innerText = args.value.toString();
                if (parent.activeObj.redactType === 'blur') {
                    parent.activeObj.redactBlur = parent.tempRedactBlur = args.value;
                }
                else if (parent.activeObj.redactType === 'pixelate') {
                    parent.activeObj.redactPixelate = parent.tempRedactPixel = args.value;
                }
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });
            },
            changed: function () {
                setTimeout(function () {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });
                }, 50);
            }
        });
        redactSlider.appendTo('#' + id + '_sliderWrapper');
        if (Browser.isDevice) {
            var cHt = contextualToolbarArea.offsetHeight + 1;
            var cusWrapper = parent.element.querySelector('#' + id + '_customizeWrapper');
            if (this.isFrameToolbar && cusWrapper) {
                cHt = cusWrapper.offsetHeight + 2;
            }
            var ht = parent.element.querySelector('#' + id + '_canvasWrapper').offsetHeight;
            contextualToolbarArea.style.top = this.toolbarHeight + 1 + ht - cHt + 'px';
        }
    };
    return ToolbarModule;
}());

export { ArrowheadType, Crop, Direction, Draw, Export, FileType, Filter, FinetuneSettings, FontFamily, FrameLineStyle, FrameType, FreehandDrawing, ImageEditor, ImageEditorCommand, ImageFilterOption, ImageFinetuneOption, RedactType, Selection, SelectionSettings, Shape, ShapeType, Theme, ToolbarModule, Transform, UndoRedo, UploadSettings, ZoomSettings, ZoomTrigger };
//# sourceMappingURL=ej2-image-editor.es5.js.map
