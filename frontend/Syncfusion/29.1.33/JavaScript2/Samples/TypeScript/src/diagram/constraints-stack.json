{"index.html":"<html><head><link href=\"https://cdn.syncfusion.com/ej2/28.1.33/{{theme}}.css\" rel=\"stylesheet\">\n\n    <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\">\n\n    <style>\n            body{\n                touch-action:none;\n            }\n            .control-section{\n                margin-top:100px;\n            }\n        </style></head><body><div class=\"stackblitz-container {{theme}}\">\n<div class=\"col-lg-10 control-section\">\n    <style>\n        /* Property panel CSS */\n        .diagram-property-tab .row {\n            margin-left: 0px;\n            margin-right: 0px;\n            padding-top: 8px;\n        }\n    </style>\n<div class=\"content-wrapper\" style=\"width:100%;background: white\">\n    <div id=\"diagram\"></div>\n</div>\n    \n    \n</div>\n<div class=\"col-lg-2 property-section diagram-property-tab\">\n    <div class=\"property-panel-header\">\n        Diagram Constraints\n    </div>\n    <div class=\"row property-panel-content\">\n        <div class=\"row\">\n            <input type=\"checkbox\" id=\"zooming\">\n        </div>\n        <div class=\"row\">\n            <input type=\"checkbox\" id=\"undoRedo\">\n        </div>\n        <div class=\"row\">\n            <input type=\"checkbox\" id=\"textedit\">\n        </div>\n        <div class=\"row\">\n            <input type=\"checkbox\" id=\"contextMenu\">\n        </div>\n        <div class=\"row\">\n            <input type=\"checkbox\" id=\"selectable\">\n        </div>\n        <div class=\"row\">\n            <input type=\"checkbox\" id=\"draggablee\">\n        </div>\n    </div>\n</div>\n</div></body></html>","package.json":"{\n  \"@syncfusion/ej2-base\": \"*\",\n  \"@syncfusion/ej2-buttons\": \"*\",\n  \"@syncfusion/ej2-data\": \"*\",\n  \"@syncfusion/ej2-inputs\": \"*\",\n  \"@syncfusion/ej2-lists\": \"*\",\n  \"@syncfusion/ej2-navigations\": \"*\",\n  \"@syncfusion/ej2-popups\": \"*\",\n  \"markdown-spellcheck\": \"^1.3.1\",\n  \"@syncfusion/ej2-diagrams\": \"*\",\n  \"@types/crossroads\": \"0.0.28\",\n  \"@types/signals\": \"0.0.16\",\n  \"@types/moment-timezone\": \"^0.5.3\",\n  \"@types/hasher\": \"0.0.27\",\n  \"fuse.js\": \"^3.2.0\",\n  \"marked\": \"5.1.2\",\n  \"codemirror\": \"^5.37.0\",\n  \"crossroads\": \"^0.12.2\",\n  \"@types/marked\": \"5.0.1\",\n  \"@types/codemirror\": \"0.0.56\",\n  \"@types/es6-promise\": \"0.0.28\",\n  \"hasher\": \"^1.2.0\",\n  \"moment-timezone\": \"^0.5.14\"\n}","index.ts":"{{ripple}}\n import {\n    Diagram,\n    Node,\n    ConnectorEditing,\n    NodeConstraints,\n    ConnectorConstraints,\n    SelectorConstraints,\n    AnnotationConstraints,\n    DiagramConstraints,\n    DiagramContextMenu,\n    UndoRedo,\n    UserHandleModel,\n    NodeModel,\n    ConnectorModel,\n    ISelectionChangeEventArgs,\n    ToolBase,\n  } from '@syncfusion/ej2-diagrams';\n  import {\n    CheckBox,\n    ChangeEventArgs as CheckBoxChangeEventArgs,\n  } from '@syncfusion/ej2-buttons';\n  Diagram.Inject(DiagramContextMenu, ConnectorEditing, UndoRedo);\n\n  let diagram: Diagram;\n  let Zooming: CheckBox;\n  let undoRedo: CheckBox;\n  let Selectable: CheckBox;\n  let Draggable: CheckBox;\n  let contextMenu: CheckBox;\n  let textedit: CheckBox;\n  \n  //Initializes the UserHandle for the diagram\n  let handles: UserHandleModel[] = [\n    {\n      name: 'delete',\n      pathData:\n        'M 7.04 22.13 L 92.95 22.13 L 92.95 88.8 C 92.95 91.92 91.55 94.58 88.76 96.74 C 85.97 98.91 82.55 100 78.52 100 L 21.48 100 C 17.45 100 14.03 98.91 11.24 96.74 C 8.45 94.58 7.04 91.92 7.04 88.8 z M 32.22 0 L 67.78 0 L 75.17 5.47 L 100 5.47 L 100 16.67 L 0 16.67 L 0 5.47 L 24.83 5.47 z',\n      visible: true,\n      offset: 0.5,\n      side: 'Bottom',\n      margin: { top: 0, bottom: 0, left: 0, right: 0 },\n    },\n  ];\n  //Initializes the nodes for the diagram\n  let nodes: NodeModel[] = [\n    {\n      id: 'textNode1',\n      // Position of the node\n      offsetX: 340,\n      offsetY: 50,\n      // Size of the node\n      width: 500,\n      height: 50,\n      //Sets type of the node\n      shape: {\n        type: 'Text',\n        content:\n          'Use Node Constraints to restrict end-users from performing certain operations on Node.',\n      },\n      //Customizes the appearances such as text, font, fill, and stroke.\n      style: {\n        strokeColor: 'none',\n        fill: 'none',\n        color: 'black',\n        textAlign: 'Center',\n      },\n      constraints: NodeConstraints.None,\n    },\n    {\n      id: 'rectangle',\n      offsetX: 80,\n      offsetY: 160,\n      height: 65,\n      shape: { type: 'Basic', shape: 'Rectangle' },\n      annotations: [{ content: 'Selection = False' }],\n      constraints: NodeConstraints.Default & ~NodeConstraints.Select,\n    },\n    {\n      id: 'ellipse',\n      offsetX: 190,\n      offsetY: 160,\n      height: 80,\n      shape: { type: 'Basic', shape: 'Ellipse', cornerRadius: 10 },\n      annotations: [{ content: 'Dragging = False' }],\n      constraints: NodeConstraints.Default & ~NodeConstraints.Drag,\n    },\n    {\n      id: 'heptagon',\n      offsetX: 295,\n      offsetY: 160,\n      height: 80,\n      shape: { type: 'Basic', shape: 'Heptagon' },\n      annotations: [{ content: 'Delete = False' }],\n      constraints: NodeConstraints.Default & ~NodeConstraints.Delete,\n    },\n    {\n      id: 'directData',\n      offsetX: 410,\n      offsetY: 160,\n      height: 80,\n      rotateAngle: -45,\n      shape: { type: 'Flow', shape: 'DirectData' },\n      annotations: [{ content: 'Rotate = False' }],\n      constraints: NodeConstraints.Default & ~NodeConstraints.Rotate,\n    },\n    {\n      id: 'Plus',\n      offsetX: 530,\n      offsetY: 160,\n      height: 80,\n      shape: { type: 'Basic', shape: 'Plus' },\n      annotations: [\n        {\n          content: 'TextEdit = False',\n          constraints: AnnotationConstraints.ReadOnly,\n        },\n      ],\n    },\n    {\n      id: 'decision',\n      offsetX: 630,\n      offsetY: 160,\n      height: 80,\n      shape: { type: 'Flow', shape: 'Decision' },\n      annotations: [{ content: 'Resizing = False' }],\n      constraints: NodeConstraints.Default & ~NodeConstraints.Resize,\n    },\n    {\n      id: 'textNode2',\n      // Position of the node\n      offsetX: 350,\n      offsetY: 280,\n      // Size of the node\n      width: 550,\n      height: 50,\n      //Sets type of the node\n      shape: {\n        type: 'Text',\n        content:\n          'Use Connector Constraints to restrict end-users from performing certain operations on Connector.',\n      },\n      //Customizes the appearances such as text, font, fill, and stroke.\n      style: {\n        strokeColor: 'none',\n        fill: 'none',\n        color: 'black',\n        textAlign: 'Center',\n      },\n      constraints: NodeConstraints.None,\n    },\n  ];\n  //Initialize Diagram connectors\n  let connectors: ConnectorModel[] = [\n    {\n      id: 'select',\n      type: 'Orthogonal',\n      annotations: [\n        {\n          content: 'Selection = False',\n          horizontalAlignment: 'Right',\n          verticalAlignment: 'Bottom',\n        },\n      ],\n      constraints: ConnectorConstraints.Default & ~ConnectorConstraints.Select,\n      sourcePoint: {\n        x: 40,\n        y: 350,\n      },\n      targetPoint: {\n        x: 120,\n        y: 430,\n      },\n    },\n    {\n      id: 'connector2',\n      type: 'Orthogonal',\n      annotations: [\n        {\n          content: 'Dragging = True',\n          horizontalAlignment: 'Right',\n          verticalAlignment: 'Bottom',\n        },\n      ],\n      constraints:\n        ConnectorConstraints.Default |\n        ConnectorConstraints.DragSegmentThumb |\n        ConnectorConstraints.Drag,\n      sourcePoint: {\n        x: 140,\n        y: 350,\n      },\n      targetPoint: {\n        x: 220,\n        y: 430,\n      },\n    },\n    {\n      id: 'delete',\n      type: 'Orthogonal',\n      annotations: [\n        {\n          content: 'Delete = False',\n          horizontalAlignment: 'Right',\n          verticalAlignment: 'Bottom',\n        },\n      ],\n      constraints:\n        (ConnectorConstraints.Default | ConnectorConstraints.DragSegmentThumb) &\n        ~(ConnectorConstraints.Delete | ConnectorConstraints.Drag),\n      sourcePoint: {\n        x: 250,\n        y: 350,\n      },\n      targetPoint: {\n        x: 320,\n        y: 430,\n      },\n    },\n    {\n      id: 'endThumb',\n      type: 'Orthogonal',\n      annotations: [\n        {\n          content: 'EndThumb = False',\n          horizontalAlignment: 'Right',\n          verticalAlignment: 'Bottom',\n        },\n      ],\n      constraints:\n        SelectorConstraints.All &\n        ~(\n          SelectorConstraints.ConnectorSourceThumb |\n          SelectorConstraints.ConnectorTargetThumb\n        ),\n      sourcePoint: {\n        x: 360,\n        y: 350,\n      },\n      targetPoint: {\n        x: 440,\n        y: 430,\n      },\n    },\n    {\n      id: 'draggable',\n      type: 'Orthogonal',\n      annotations: [\n        {\n          content: 'EndDraggable = False',\n          horizontalAlignment: 'Right',\n          verticalAlignment: 'Bottom',\n        },\n      ],\n      constraints:\n        (ConnectorConstraints.Default | ConnectorConstraints.DragSegmentThumb) &\n        ~(\n          ConnectorConstraints.DragSourceEnd | ConnectorConstraints.DragTargetEnd\n        ),\n      sourcePoint: {\n        x: 460,\n        y: 350,\n      },\n      targetPoint: {\n        x: 540,\n        y: 430,\n      },\n    },\n    {\n      id: 'segmentThumb',\n      type: 'Orthogonal',\n      annotations: [\n        {\n          content: 'SegmentThumb = False',\n          horizontalAlignment: 'Right',\n          verticalAlignment: 'Bottom',\n        },\n      ],\n      constraints: ConnectorConstraints.Default & ~ConnectorConstraints.Drag,\n      sourcePoint: {\n        x: 580,\n        y: 350,\n      },\n      targetPoint: {\n        x: 660,\n        y: 430,\n      },\n    },\n  ];\n  // Function to define default properties for nodes\n  function nodeDefaults(nodes: NodeModel) {\n    // Check if the node ID is not textNode1 or textNode2\n      if(nodes.id !== \"textNode1\" && nodes.id !== \"textNode2\") {\n      // Set default width and styling for nodes\n      nodes.width = 80;\n      nodes.style.fill = '#C7E6FF';\n      nodes.style.strokeColor = '#1587FF';\n      }\n  }\n  // Function to define default properties for connectors\n  function connectorDefaults(connectors: ConnectorModel) {\n    // Set default styling for connectors\n    connectors.style.strokeColor = '#6BA5D7';\n    connectors.style.fill = '#6BA5D7';\n    connectors.style.strokeWidth = 2;\n    // Set default styling for target decorator of connectors\n    connectors.targetDecorator.style.fill = '#6BA5D7';\n    connectors.targetDecorator.style.strokeColor = '#6BA5D7';\n  }\n  // Selection change method for handling diagram item selection events\n  function selectionChange(args: ISelectionChangeEventArgs) {\n    {\n      // Handle selection change during the 'Changing' state\n      if (args.state === 'Changing') {\n        // Check if items are being added to selection\n        if (args.type === 'Addition') {\n          // Check if the newly selected item is 'endThumb'\n          if (args.newValue.length > 0 && args.newValue[0].id === 'endThumb') {\n            // Restrict selector constraints for 'endThumb' connector\n            diagram.selectedItems.constraints =\n              SelectorConstraints.All &\n              ~(\n                SelectorConstraints.ConnectorSourceThumb |\n                SelectorConstraints.ConnectorTargetThumb\n              );\n          } else {\n            // Set selector constraints for all other additions\n            diagram.selectedItems.constraints = SelectorConstraints.All;\n          }\n        } else {\n          // Set selector constraints for all other changes during 'Changing' state\n          diagram.selectedItems.constraints = SelectorConstraints.All;\n        }\n      }\n      // Handle selection change during the 'Changed' state\n      if (args.state === 'Changed') {\n        // Check if there are newly selected items and if the first item is a Node instance\n        if (args.newValue.length > 0 && args.newValue[0] instanceof Node) {\n          // Set selector constraints with user handles for nodes\n          diagram.selectedItems = {\n            constraints: SelectorConstraints.All | SelectorConstraints.UserHandle,\n            userHandles: handles,\n          };\n        } else {\n          // Check if there are newly selected items and if the first item is not 'endThumb'\n          if (args.newValue.length > 0 && args.newValue[0].id !== 'endThumb') {\n            // Set selector constraints for all other selected items\n            diagram.selectedItems = {\n              constraints:\n                SelectorConstraints.All & ~SelectorConstraints.UserHandle,\n            };\n          } else {\n            // Set selector constraints for all other selected items, excluding specific thumbs\n            diagram.selectedItems = {\n              constraints:\n                SelectorConstraints.All &\n                ~(\n                  SelectorConstraints.UserHandle |\n                  SelectorConstraints.ConnectorSourceThumb |\n                  SelectorConstraints.ConnectorTargetThumb\n                ),\n            };\n          }\n        }\n      }\n    }\n  }\n  //used to delete object using user handle\n  function getTool(action: string): ToolBase {\n    let tool: ToolBase;\n    if (action === 'delete') {\n      diagram.remove();\n    }\n    return tool;\n  }\n  \n  // tslint:disable-next-line:max-func-body-length\n  \n    \n  //Initializes the diagram\n  diagram= new Diagram({\n    width: '100%',\n    height: '550px',\n    nodes: nodes,\n    connectors: connectors,\n    contextMenuSettings: {\n    show: true,\n  },\n  // Function called after the diagram is created to set default values\n  created: function () {\n    // Loop through connectors to apply specific constraints\n    for (let i = 0; i < diagram.connectors.length; i++) {\n      // Check if the connector ID matches 'endThumb'\n      if (diagram.connectors[i].id === 'endThumb') {\n        // Adjust connector constraints to allow dragging segment thumb but not dragging\n        diagram.connectors[i].constraints =\n          (ConnectorConstraints.Default |\n            ConnectorConstraints.DragSegmentThumb) &\n          ~ConnectorConstraints.Drag;\n      }\n    }\n  },\n  // Settings to display rulers in the diagram\n  rulerSettings: { showRulers: true },\n  // Function to handle selection change events in the diagram\n  selectionChange: selectionChange,\n  // Function to provide custom tools for the diagram\n  getCustomTool: getTool,\n  // Initial selected items configuration with user handles\n  selectedItems: {\n    constraints: SelectorConstraints.UserHandle,\n    userHandles: handles,\n  },\n   //Defines the default node and connector properties\n   getNodeDefaults: nodeDefaults,\n   getConnectorDefaults: connectorDefaults,\n  });\n  diagram.appendTo('#diagram');\n    \n//Enable or disable the AspectRatio for Node.\nZooming = new CheckBox({\n    checked: true,\n    label: 'Zooming',\n    change: function () {\n      diagram.constraints = diagram.constraints ^ DiagramConstraints.Zoom;\n    },\n  });\n  Zooming.appendTo('#zooming');\n  \n   //CheckBox used to enable undo redo in diagram\n  undoRedo = new CheckBox({\n    label: 'Undo/Redo',\n    checked: true,\n    change: function () {\n      diagram.constraints = diagram.constraints ^ DiagramConstraints.UndoRedo;\n      diagram.dataBind();\n    },\n  });\n  undoRedo.appendTo('#undoRedo');\n\n  // CheckBox used to enable text editing in the diagram\n  textedit = new CheckBox({\n    label: 'Text Edit',\n    checked: true,\n    // Change event handler for checkbox state changes\n    change: function (args:any) {\n      // Loop through nodes in the diagram\n      for (let i: number = 0; i < diagram.nodes.length; i++) {\n        // Check if the node has annotations and content\n        var node = diagram.nodes[i];\n          if (node.annotations.length > 0 && node.annotations[0].content) {\n            // Enable or disable text editing based on checkbox state\n            if (args.checked) {\n              // Allow editing if checkbox is checked, except for node with ID 'Plus'\n              if (node.id !== 'Plus') {\n                node.annotations[0].constraints =\n                  node.annotations[0].constraints ^\n                  AnnotationConstraints.ReadOnly;\n              }\n            } else {\n              // Set read-only if checkbox is unchecked\n              node.annotations[0].constraints =\n                node.annotations[0].constraints | AnnotationConstraints.ReadOnly;\n            }\n          }\n      }\n      // Loop through connectors in the diagram\n      for (let x: number = 0; x < diagram.connectors.length; x++) {\n        var connector = diagram.connectors[x];\n        // Check if the connector has annotations and content\n          if (connector.annotations.length > 0 && connector.annotations[0].content) {\n            // Enable or disable text editing based on checkbox state\n            if (args.checked) {\n              // Allow editing if checkbox is checked, handle special case for connector with ID 'select'\n              if (connector.id === 'select') {\n                connector.constraints =\n                  connector.constraints & ~(ConnectorConstraints.Select);\n              } else {\n                connector.annotations[0].constraints =\n                  connector.annotations[0].constraints ^\n                  AnnotationConstraints.ReadOnly;\n              }\n            } else {\n              // Set read-only if checkbox is unchecked\n              connector.annotations[0].constraints =\n                connector.annotations[0].constraints ^\n                AnnotationConstraints.ReadOnly;\n            }\n        }\n      }\n      diagram.dataBind(); // Apply changes to the diagram\n    },\n  });\n  textedit.appendTo('#textedit');\n  \n  // CheckBox used to enable selection in diagram\n  Selectable = new CheckBox({\n    label: 'Selectable',\n    checked: true,\n    // Change event handler for checkbox state changes\n    change: function (args:any) {\n      // Loop through nodes in the diagram\n      for (let i: number = 0; i < diagram.nodes.length; i++) {\n        let node = diagram.nodes[i];\n        // Exclude node with ID 'rectangle' from selection toggle\n        if (node.id != 'rectangle') {\n          // Enable or disable node selection based on checkbox state\n          if (args.checked) {\n            node.constraints = node.constraints | NodeConstraints.Select;\n          } else {\n            node.constraints = node.constraints & ~NodeConstraints.Select;\n          }\n        }\n        diagram.dataBind(); // Apply changes to the diagram\n      }\n       // Loop through connectors in the diagram\n      for (let j: number = 0; j < diagram.connectors.length; j++) {\n        let connector = diagram.connectors[j];\n        // Exclude connector with ID 'select' from selection toggle\n        if (connector.id != 'select') {\n          // Enable or disable connector selection based on checkbox state\n          if (args.checked) {\n            connector.constraints =\n              connector.constraints | ConnectorConstraints.Select;\n          } else {\n            connector.constraints =\n              connector.constraints & ~ConnectorConstraints.Select;\n          }\n        }\n        diagram.dataBind(); // Apply changes to the diagram\n      }\n    },\n  });\n  // Append checkbox to HTML element with id 'selectable'\n  Selectable.appendTo('#selectable');\n  \n  // CheckBox used to enable dragging interactions in diagram\n  Draggable = new CheckBox({\n    label: 'Draggable',\n    checked: true,\n    change: function (args:any) { // Change event handler for checkbox state changes\n      // Loop through nodes in the diagram  \n      for (let i: number = 0; i < diagram.nodes.length; i++) {\n        let nodes: any = diagram.nodes[i];\n        // Enable or disable node dragging based on checkbox state\n        if (args.checked) {\n        // Toggle drag constraint for node with ID 'ellipse'\n          if (nodes.id === 'ellipse') {\n            nodes.constraints = NodeConstraints.Default & ~NodeConstraints.Drag;\n          } else {\n            nodes.constraints = nodes.constraints | NodeConstraints.Drag;\n          }\n        } else {\n          nodes.constraints = nodes.constraints & ~NodeConstraints.Drag;\n        }\n        diagram.dataBind(); //Apply changes to the diagram \n      }\n       // Loop through connectors in the diagram\n      for (let j: number = 0; j < diagram.connectors.length; j++) {\n        let connectors: any = diagram.connectors[j];\n        // Enable or disable connector dragging based on checkbox state\n        if (args.checked) {\n          connectors.constraints =\n            connectors.constraints | ConnectorConstraints.Drag;\n        } else {\n          connectors.constraints =\n            connectors.constraints & ~ConnectorConstraints.Drag;\n        }\n        diagram.dataBind(); // Apply changes to the diagram\n      }\n    },\n  });\n  // Append checkbox to HTML element with id 'draggablee'\n  Draggable.appendTo('#draggablee');\n  \n  // CheckBox used to enable context menu on right click\n  contextMenu = new CheckBox({\n    label: 'Context Menu',\n    checked: true,\n    // Change event handler for checkbox state changes\n    change: function (args) {\n      if (args.checked) {\n        // If checkbox is checked\n        diagram.contextMenuSettings.show = true;\n        diagram.refresh(); // Refresh the diagram to apply changes\n      } else {\n        diagram.contextMenuSettings.show = false;\n      }\n      diagram.dataBind(); // Apply changes to the diagram UI\n    },\n  });\n  // Append checkbox to HTML element with id 'contextMenu'\n  contextMenu.appendTo('#contextMenu');\n\n  \n "}