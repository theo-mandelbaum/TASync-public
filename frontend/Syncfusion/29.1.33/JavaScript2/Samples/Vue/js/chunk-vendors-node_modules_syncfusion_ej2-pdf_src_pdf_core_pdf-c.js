"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdf_src_pdf_core_pdf-c"],{

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-catalog.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-catalog.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _PdfCatalog: () => (/* binding */ _PdfCatalog)\n/* harmony export */ });\n/* harmony import */ var _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pdf-primitives */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-primitives.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/utils.js\");\n\n\nvar _PdfCatalog = /** @class */ (function () {\n    function _PdfCatalog(xref) {\n        this._crossReference = xref;\n        this._catalogDictionary = xref._getCatalogObj();\n        if (!(this._catalogDictionary instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfDictionary)) {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError('Catalog object is not a dictionary.');\n        }\n        else {\n            this._catalogDictionary.isCatalog = true;\n        }\n        this._topPagesDictionary = this._catalogDictionary.get('Pages');\n        this.pageKidsCountCache = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReferenceSetCache();\n        this.pageIndexCache = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReferenceSetCache();\n    }\n    Object.defineProperty(_PdfCatalog.prototype, \"version\", {\n        get: function () {\n            var value;\n            if (this._catalogDictionary.has('Version')) {\n                var version = this._catalogDictionary.get('Version');\n                if (version) {\n                    value = version.name;\n                }\n            }\n            return value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_PdfCatalog.prototype, \"pageCount\", {\n        get: function () {\n            var obj = this._topPagesDictionary.get('Count');\n            if (typeof obj === 'undefined' || !Number.isInteger(obj)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError('Invalid page count');\n            }\n            return obj;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_PdfCatalog.prototype, \"acroForm\", {\n        get: function () {\n            var form;\n            if (this._catalogDictionary.has('AcroForm')) {\n                form = this._catalogDictionary.get('AcroForm');\n            }\n            if (form === null || typeof form === 'undefined') {\n                form = this._createForm();\n            }\n            return form;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /* eslint-disable */\n    _PdfCatalog.prototype._createForm = function () {\n        var form = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfDictionary(this._crossReference);\n        var ref = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(ref, form);\n        this._catalogDictionary.set('AcroForm', ref);\n        this._catalogDictionary._updated = true;\n        this._crossReference._allowCatalog = true;\n        form._updated = true;\n        return form;\n    };\n    _PdfCatalog.prototype.getPageDictionary = function (pageIndex) {\n        var nodesToVisit = [this._topPagesDictionary];\n        var visitedNodes = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReferenceSet();\n        var pagesRef = this._catalogDictionary.getRaw('Pages');\n        if (pagesRef && pagesRef instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference) {\n            visitedNodes.put(pagesRef);\n        }\n        var xref = this._crossReference;\n        var pageKidsCountCache = this.pageKidsCountCache;\n        var pageIndexCache = this.pageIndexCache;\n        var currentPageIndex = 0;\n        while (nodesToVisit.length > 0) {\n            var currentNode = nodesToVisit.pop();\n            if (currentNode !== null && typeof currentNode !== 'undefined' && currentNode instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference) {\n                var count_1 = pageKidsCountCache.get(currentNode);\n                if (count_1 >= 0 && currentPageIndex + count_1 <= pageIndex) {\n                    currentPageIndex += count_1;\n                    continue;\n                }\n                if (visitedNodes.has(currentNode)) {\n                    throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError('Pages tree contains circular reference.');\n                }\n                visitedNodes.put(currentNode);\n                var obj = xref._fetch(currentNode);\n                if (obj && obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfDictionary) {\n                    var type = obj.getRaw('Type');\n                    if (type !== null && typeof type !== 'undefined' && type instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference) {\n                        type = xref._fetch(type);\n                    }\n                    if ((0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isName)(type, 'Page') || !obj.has('Kids')) {\n                        if (!pageKidsCountCache.has(currentNode)) {\n                            pageKidsCountCache.put(currentNode, 1);\n                        }\n                        if (!pageIndexCache.has(currentNode)) {\n                            pageIndexCache.put(currentNode, currentPageIndex);\n                        }\n                        if (currentPageIndex === pageIndex) {\n                            return { dictionary: obj, reference: currentNode };\n                        }\n                        currentPageIndex++;\n                        continue;\n                    }\n                }\n                nodesToVisit.push(obj);\n                continue;\n            }\n            if (!(currentNode instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfDictionary)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError('Page dictionary kid reference points to wrong type of object.');\n            }\n            var objId = currentNode.objId;\n            var count = currentNode.get('Count');\n            if (count !== null && typeof count !== 'undefined' && count instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference) {\n                count = xref._fetch(count);\n            }\n            if (count !== null && typeof count !== 'undefined' && Number.isInteger(count) && count >= 0) {\n                if (objId && !pageKidsCountCache.has(objId)) {\n                    pageKidsCountCache.set(objId, count);\n                }\n                if (currentPageIndex + count <= pageIndex) {\n                    currentPageIndex += count;\n                    continue;\n                }\n            }\n            var kids = currentNode.getRaw('Kids');\n            if (kids !== null && typeof kids !== 'undefined' && kids instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference) {\n                kids = xref._fetch(kids);\n            }\n            if (!Array.isArray(kids)) {\n                var type = currentNode.getRaw('Type');\n                if (type !== null && typeof type !== 'undefined' && type instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference) {\n                    type = xref._fetch(type);\n                }\n                if ((0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isName)(type, 'Page') || !currentNode.has('Kids')) {\n                    if (currentPageIndex === pageIndex) {\n                        return { dictionary: currentNode, reference: null };\n                    }\n                    currentPageIndex++;\n                    continue;\n                }\n                throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError('Page dictionary kids object is not an array.');\n            }\n            for (var last = kids.length - 1; last >= 0; last--) {\n                nodesToVisit.push(kids[last]);\n            }\n        }\n        throw new Error(\"Page index \" + pageIndex + \" not found.\");\n    };\n    _PdfCatalog.prototype._destroy = function () {\n        if (this._catalogDictionary) {\n            this._catalogDictionary = undefined;\n        }\n        if (this._topPagesDictionary) {\n            this._topPagesDictionary = undefined;\n        }\n        if (this.pageIndexCache) {\n            this.pageIndexCache.clear();\n            this.pageIndexCache = undefined;\n        }\n        if (this.pageKidsCountCache) {\n            this.pageKidsCountCache.clear();\n            this.pageKidsCountCache = undefined;\n        }\n    };\n    return _PdfCatalog;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-catalog.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-file-structure.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-file-structure.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PdfFileStructure: () => (/* binding */ PdfFileStructure)\n/* harmony export */ });\n/**\n * `PdfFileStructure` class represents the internal structure of the PDF file.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access the internal file structure of the PDF document\n * let fileStructure: PdfFileStructure = document.fileStructure;\n * // Set the cross reference type\n * fileStructure.crossReferenceType = PdfCrossReferenceType.stream;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfFileStructure = /** @class */ (function () {\n    function PdfFileStructure() {\n        this._incrementalUpdate = true;\n    }\n    Object.defineProperty(PdfFileStructure.prototype, \"crossReferenceType\", {\n        /**\n         * Gets the cross reference type of the PDF document.\n         *\n         * @returns {PdfCrossReferenceType} - Returns the cross reference type of the PDF document.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the internal file structure of the PDF document\n         * let fileStructure: PdfFileStructure = document.fileStructure;\n         * // Get the cross reference type\n         * let type: PdfCrossReferenceType = fileStructure.crossReferenceType;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._crossReferenceType;\n        },\n        /**\n         * Sets the cross reference type of the PDF document.\n         *\n         * @param {PdfCrossReferenceType} value - Specifies the cross reference type of the PDF document.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the internal file structure of the PDF document\n         * let fileStructure: PdfFileStructure = document.fileStructure;\n         * // Set the cross reference type\n         * fileStructure.crossReferenceType = PdfCrossReferenceType.stream;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._crossReferenceType = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFileStructure.prototype, \"isIncrementalUpdate\", {\n        /**\n         * Gets the boolean flag indicating whether the update is incremental.\n         *\n         * @returns { boolean } - Returns true if the PDF document supports incremental updates, otherwise false\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the internal file structure of the PDF document\n         * let fileStructure: PdfFileStructure = document.fileStructure;\n         * // Get the incremental update\n         * let incrementalUpdate: boolean = fileStructure.isIncrementalUpdate;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._incrementalUpdate;\n        },\n        /**\n         * Sets the boolean flag indicating whether the update is incremental.\n         *\n         * @param {boolean} value - If `true`, enables incremental updates for the PDF document; otherwise, disables it.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the internal file structure of the PDF document\n         * let fileStructure: PdfFileStructure = document.fileStructure;\n         * // Set the incremental updates\n         * fileStructure.isIncrementalUpdate = false;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._incrementalUpdate = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfFileStructure;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-file-structure.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-page-import-options.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-page-import-options.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PdfPageImportOptions: () => (/* binding */ PdfPageImportOptions)\n/* harmony export */ });\n/**\n * `PdfPageImportOptions` class represents to customize the support of import PDF pages\n *\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Options to customize the support of import PDF pages.\n * let options: PdfPageImportOptions = new PdfPageImportOptions();\n * // Sets the target page index to import\n * options.targetIndex = 1;\n * // Sets the rotation angle of the page to import\n * options.rotation = PdfRotationAngle.angle180;\n * // Sets the boolean value indicating whether the optimize resources while import pages or not\n * options.optimizeResources = true;\n * // Copy the first page and add it as second page with page rotation\n * document.importPage(0, options);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPageImportOptions = /** @class */ (function () {\n    function PdfPageImportOptions() {\n        this._optimizeResources = true;\n        this._groupFormFields = false;\n    }\n    Object.defineProperty(PdfPageImportOptions.prototype, \"targetIndex\", {\n        /**\n         * Gets the target page index to import\n         *\n         * @returns {PdfRotationAngle} Page rotation angle.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Gets the target page index to import\n         * let targetIndex: number = options.targetIndex;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._targetIndex;\n        },\n        /**\n         * Sets the target page index to import\n         *\n         * @param {number} value Target page index to import.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Sets the target page index to import\n         * options.targetIndex = 1;\n         * // Copy the first page and add it as second page with page rotation\n         * document.importPage(0, options);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._targetIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPageImportOptions.prototype, \"rotation\", {\n        /**\n         * Gets the rotation angle of the page to import\n         *\n         * @returns {PdfRotationAngle} Page rotation angle.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Gets the rotation angle of the page to import\n         * let rotation: PdfRotationAngle = options.rotation;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._rotation;\n        },\n        /**\n         * Sets the rotation angle of the page to import\n         *\n         * @param {PdfRotationAngle} value Page rotation angle.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Sets the rotation angle of the page to import\n         * options.rotation = PdfRotationAngle.angle270;\n         * // Copy the first page and add it as second page with page rotation\n         * document.importPage(0, options);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._rotation = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPageImportOptions.prototype, \"optimizeResources\", {\n        /**\n         * Gets the boolean value indicating whether the optimize resources while import pages or not\n         *\n         * @returns {boolean} Indicates resource optimization.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Gets the boolean value indicating whether the optimize resources while import pages or not\n         * let resource: optimizeResources = options.optimizeResources;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._optimizeResources;\n        },\n        /**\n         * Sets the boolean value indicating whether the optimize resources while import pages or not\n         *\n         * @param {boolean} value Indicates resource optimization.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Sets the boolean value indicating whether the optimize resources while import pages or not\n         * options.optimizeResources = true;\n         * // Copy the first page and add it as second page with page rotation\n         * document.importPage(0, options);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._optimizeResources = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPageImportOptions.prototype, \"groupFormFields\", {\n        /**\n         * Gets the boolean value indicating whether the form fields are grouped or not while importing pages.\n         *\n         * @returns {boolean} value Indicates form fields grouping.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Gets the boolean value indicating whether the form fields are grouped or not while importing pages.\n         * let groupFormfields: number = options.groupFormFields;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._groupFormFields;\n        },\n        /**\n         * Sets the boolean value indicating whether the form fields are grouped or not while importing pages.\n         *\n         * @param {boolean} value Indicates form fields grouping\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Options to customize the support of import PDF pages.\n         * let options: PdfPageImportOptions = new PdfPageImportOptions();\n         * // Sets the boolean value indicating whether the form fields are grouped or not while importing pages.\n         * options.groupFormFields = true;\n         * // Copy the first page and add it as second page.\n         * document.importPage(0, options);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._groupFormFields = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfPageImportOptions;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-page-import-options.js?");

/***/ })

}]);