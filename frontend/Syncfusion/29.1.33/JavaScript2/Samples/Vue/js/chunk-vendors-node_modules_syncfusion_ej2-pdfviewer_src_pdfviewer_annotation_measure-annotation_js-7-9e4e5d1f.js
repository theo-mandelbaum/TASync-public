"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_annotation_measure-annotation_js-7-9e4e5d1f"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/measure-annotation.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/measure-annotation.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeasureAnnotation: () => (/* binding */ MeasureAnnotation)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/index.js\");\n/* harmony import */ var _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-inputs */ \"./node_modules/@syncfusion/ej2-inputs/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_popups__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-popups */ \"./node_modules/@syncfusion/ej2-popups/index.js\");\n/* harmony import */ var _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-splitbuttons */ \"./node_modules/@syncfusion/ej2-splitbuttons/index.js\");\n/* harmony import */ var _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @syncfusion/ej2-drawings */ \"./node_modules/@syncfusion/ej2-drawings/index.js\");\n\n\n\n\n\n\n/**\n * @hidden\n */\nvar MeasureAnnotation = /** @class */ (function () {\n    function MeasureAnnotation(pdfviewer, pdfViewerBase) {\n        /**\n         * @private\n         */\n        this.measureShapeCount = 0;\n        /**\n         * @private\n         */\n        this.isAddAnnotationProgramatically = false;\n        this.pdfViewer = pdfviewer;\n        this.pdfViewerBase = pdfViewerBase;\n    }\n    Object.defineProperty(MeasureAnnotation.prototype, \"pixelToPointFactor\", {\n        /**\n         * @private\n         * @returns {number} - number\n         */\n        get: function () {\n            return (72 / 96);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {any} shapeAnnotations - It describes about the shape annotations\n     * @param {number} pageNumber - It describes about the page number\n     * @param {boolean} isImportAction - It describes about whether the isImportAction is true or not\n     * @param {boolean} isAnnotOrderAction - It describes about whether the isAnnotOrderAction is true or not\n     * @private\n     * @returns {void}\n     */\n    MeasureAnnotation.prototype.renderMeasureShapeAnnotations = function (shapeAnnotations, pageNumber, isImportAction, isAnnotOrderAction) {\n        if (shapeAnnotations) {\n            if (shapeAnnotations.length >= 1) {\n                var measureAnnots = this.pdfViewer.annotation.getStoredAnnotations(pageNumber, shapeAnnotations, '_annotations_shape_measure');\n                if (!measureAnnots || isImportAction || isAnnotOrderAction) {\n                    for (var i = 0; i < shapeAnnotations.length; i++) {\n                        var annotation = shapeAnnotations[parseInt(i.toString(), 10)];\n                        var annotationObject = null;\n                        this.measureShapeCount = this.measureShapeCount + 1;\n                        annotation.annotationAddMode = this.pdfViewer.annotationModule.\n                            findAnnotationMode(annotation, pageNumber, annotation.AnnotType);\n                        var isAnnotationRotated = void 0;\n                        if (annotation.ShapeAnnotationType) {\n                            if (isImportAction) {\n                                if (this.pdfViewerBase.isJsonImported) {\n                                    annotation.Bounds = this.pdfViewerBase.\n                                        importJsonForRotatedDocuments(annotation.Rotate, pageNumber, annotation.Bounds, annotation.AnnotationRotation);\n                                    isAnnotationRotated = this.pdfViewerBase.isPageRotated;\n                                }\n                            }\n                            var vertexPoints = null;\n                            if (annotation.VertexPoints) {\n                                vertexPoints = [];\n                                if (isImportAction && this.pdfViewerBase.isJsonImported) {\n                                    vertexPoints = this.pdfViewerBase.\n                                        calculateVertexPoints(annotation.Rotate, pageNumber, annotation.VertexPoints, annotation.AnnotationRotation);\n                                }\n                                else {\n                                    for (var j = 0; j < annotation.VertexPoints.length; j++) {\n                                        var x = annotation.VertexPoints[parseInt(j.toString(), 10)].X ?\n                                            annotation.VertexPoints[parseInt(j.toString(), 10)].X :\n                                            annotation.VertexPoints[parseInt(j.toString(), 10)].x;\n                                        var y = annotation.VertexPoints[parseInt(j.toString(), 10)].Y ?\n                                            annotation.VertexPoints[parseInt(j.toString(), 10)].Y :\n                                            annotation.VertexPoints[parseInt(j.toString(), 10)].y;\n                                        var point = { x: x, y: y };\n                                        vertexPoints.push(point);\n                                    }\n                                }\n                            }\n                            if (annotation.Bounds && annotation.EnableShapeLabel === true) {\n                                annotation.LabelBounds = this.pdfViewer.annotationModule.\n                                    inputElementModule.calculateLabelBoundsFromLoadedDocument(annotation.Bounds);\n                                annotation.LabelBorderColor = annotation.LabelBorderColor ?\n                                    annotation.LabelBorderColor : annotation.StrokeColor;\n                                annotation.FontColor = annotation.FontColor ? annotation.FontColor : annotation.StrokeColor;\n                                annotation.LabelFillColor = annotation.LabelFillColor ? annotation.LabelFillColor : annotation.FillColor;\n                                annotation.FontSize = annotation.FontSize ? annotation.FontSize : 16;\n                                annotation.LabelSettings = annotation.LabelSettings ? annotation.LabelSettings :\n                                    this.pdfViewer.shapeLabelSettings;\n                            }\n                            annotation.AnnotationSettings = annotation.AnnotationSettings ? annotation.AnnotationSettings :\n                                this.pdfViewer.annotationModule.updateAnnotationSettings(annotation);\n                            if (annotation.IsLocked) {\n                                annotation.AnnotationSettings.isLock = annotation.IsLocked;\n                            }\n                            annotation.allowedInteractions = annotation.AllowedInteractions ? annotation.AllowedInteractions :\n                                this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n                            var isPrint = annotation.IsPrint;\n                            var measureObject = {\n                                ratio: annotation.Calibrate.Ratio, x: this.getNumberFormatArray(annotation.Calibrate.X),\n                                distance: this.getNumberFormatArray(annotation.Calibrate.Distance),\n                                area: this.getNumberFormatArray(annotation.Calibrate.Area),\n                                angle: this.getNumberFormatArray(annotation.Calibrate.Angle),\n                                volume: this.getNumberFormatArray(annotation.Calibrate.Volume),\n                                targetUnitConversion: annotation.Calibrate.TargetUnitConversion\n                            };\n                            if (annotation.Calibrate.Depth) {\n                                measureObject.depth = annotation.Calibrate.Depth;\n                            }\n                            var left = annotation.Bounds.X ? annotation.Bounds.X : annotation.Bounds.x;\n                            var top_1 = annotation.Bounds.Y ? annotation.Bounds.Y : annotation.Bounds.y;\n                            var width = annotation.Bounds.Width ? annotation.Bounds.Width : annotation.Bounds.width;\n                            var height = annotation.Bounds.Height ? annotation.Bounds.Height : annotation.Bounds.height;\n                            annotationObject = {\n                                id: 'measure' + this.measureShapeCount, shapeAnnotationType: annotation.ShapeAnnotationType, author: annotation.Author, allowedInteractions: annotation.allowedInteractions, modifiedDate: annotation.ModifiedDate, subject: annotation.Subject,\n                                note: annotation.Note, strokeColor: annotation.StrokeColor, fillColor: annotation.FillColor,\n                                opacity: annotation.Opacity, thickness: annotation.Thickness,\n                                rectangleDifference: annotation.RectangleDifference,\n                                borderStyle: annotation.BorderStyle, borderDashArray: annotation.BorderDashArray,\n                                rotateAngle: annotation.RotateAngle, isCloudShape: annotation.IsCloudShape,\n                                cloudIntensity: annotation.CloudIntensity, vertexPoints: vertexPoints,\n                                lineHeadStart: annotation.LineHeadStart, lineHeadEnd: annotation.LineHeadEnd,\n                                isLocked: annotation.IsLocked,\n                                bounds: { left: left, top: top_1, width: width, height: height, right: annotation.Bounds.Right,\n                                    bottom: annotation.Bounds.Bottom },\n                                caption: annotation.Caption, captionPosition: annotation.CaptionPosition, calibrate: measureObject,\n                                leaderLength: annotation.LeaderLength, leaderLineExtension: annotation.LeaderLineExtension,\n                                leaderLineOffset: annotation.LeaderLineOffset, indent: annotation.Indent,\n                                annotName: annotation.AnnotName, comments: this.pdfViewer.annotationModule.\n                                    getAnnotationComments(annotation.Comments, annotation, annotation.Author),\n                                review: { state: annotation.State, stateModel: annotation.StateModel,\n                                    modifiedDate: annotation.ModifiedDate, author: annotation.Author },\n                                labelContent: annotation.LabelContent, enableShapeLabel: annotation.EnableShapeLabel,\n                                labelFillColor: annotation.LabelFillColor,\n                                fontColor: annotation.FontColor, labelBorderColor: annotation.LabelBorderColor,\n                                fontSize: annotation.FontSize,\n                                labelBounds: annotation.LabelBounds, annotationSelectorSettings: this.getSettings(annotation),\n                                labelSettings: annotation.LabelSettings, annotationSettings: annotation.AnnotationSettings,\n                                customData: this.pdfViewer.annotation.getCustomData(annotation),\n                                isPrint: annotation.IsPrint, isCommentLock: annotation.IsCommentLock,\n                                isAnnotationRotated: isAnnotationRotated\n                            };\n                            var vPoints = annotationObject.vertexPoints;\n                            if (vertexPoints == null) {\n                                vPoints = [];\n                            }\n                            var annotationSelectorSettings = typeof (annotation.AnnotationSelectorSettings) === 'string' ? JSON.parse(annotation.AnnotationSelectorSettings) : annotation.AnnotationSelectorSettings;\n                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(annotation.AnnotationSelectorSettings)) {\n                                this.pdfViewerBase.annotationSelectorSettingLoad(annotation);\n                            }\n                            else {\n                                annotation.AnnotationSelectorSettings = annotationSelectorSettings;\n                            }\n                            annotation.allowedInteractions = annotation.AllowedInteractions ?\n                                annotation.AllowedInteractions : this.pdfViewer.annotationModule.\n                                updateAnnotationAllowedInteractions(annotation);\n                            var annot = {\n                                id: 'measure' + this.measureShapeCount, shapeAnnotationType: this.getShapeType(annotationObject), author: annotationObject.author, allowedInteractions: annotation.allowedInteractions, modifiedDate: annotationObject.modifiedDate,\n                                subject: annotationObject.subject, notes: annotationObject.note, fillColor: annotationObject.fillColor,\n                                strokeColor: annotationObject.strokeColor, opacity: annotationObject.opacity,\n                                thickness: annotationObject.thickness, borderStyle: annotationObject.borderStyle, borderDashArray: annotationObject.borderDashArray.toString(), rotateAngle: parseFloat(annotationObject.rotateAngle.split('Angle')[1]),\n                                isCloudShape: annotationObject.isCloudShape, cloudIntensity: annotationObject.cloudIntensity,\n                                taregetDecoraterShapes: this.pdfViewer.annotation.getArrowType(annotationObject.lineHeadEnd),\n                                sourceDecoraterShapes: this.pdfViewer.annotation.getArrowType(annotationObject.lineHeadStart),\n                                vertexPoints: vPoints, bounds: { x: annotationObject.bounds.left, y: annotationObject.bounds.top,\n                                    width: annotationObject.bounds.width, height: annotationObject.bounds.height },\n                                leaderHeight: annotationObject.leaderLength, pageIndex: pageNumber,\n                                annotName: annotationObject.annotName, comments: annotationObject.comments,\n                                review: annotationObject.review,\n                                measureType: this.getMeasureType(annotationObject),\n                                labelContent: annotation.LabelContent, enableShapeLabel: annotation.EnableShapeLabel,\n                                labelFillColor: annotation.LabelFillColor,\n                                fontColor: annotation.FontColor, labelBorderColor: annotation.LabelBorderColor,\n                                fontSize: annotation.FontSize,\n                                labelBounds: annotation.LabelBounds, annotationSelectorSettings: annotation.AnnotationSelectorSettings,\n                                annotationSettings: annotationObject.annotationSettings, annotationAddMode: annotation.annotationAddMode,\n                                isPrint: isPrint, isCommentLock: annotationObject.isCommentLock, customData: annotationObject.customData\n                            };\n                            this.pdfViewer.annotation.storeAnnotations(pageNumber, annotationObject, '_annotations_shape_measure');\n                            this.pdfViewer.add(annot);\n                            if (this.isAddAnnotationProgramatically) {\n                                var settings = {\n                                    opacity: annot.opacity, strokeColor: annot.strokeColor, thickness: annot.thickness,\n                                    modifiedDate: annot.modifiedDate,\n                                    width: annot.bounds.width, height: annot.bounds.height\n                                };\n                                this.pdfViewer.fireAnnotationAdd(annot.pageIndex, annot.annotName, annotation.ShapeAnnotationType, annot.bounds, settings);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (shapeAnnotations.shapeAnnotationType) {\n                var annotationObject = this.createAnnotationObject(shapeAnnotations);\n                this.pdfViewer.annotationModule.isFormFieldShape = false;\n                this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotationObject, '_annotations_shape_measure');\n                if (shapeAnnotations) {\n                    shapeAnnotations.customData = annotationObject.customData;\n                }\n                this.pdfViewer.annotationModule.triggerAnnotationAdd(shapeAnnotations);\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @private\n     * @returns {any} - any\n     */\n    MeasureAnnotation.prototype.getSettings = function (annotation) {\n        var selector = this.pdfViewer.annotationSelectorSettings;\n        if (annotation.AnnotationSelectorSettings) {\n            selector = typeof (annotation.AnnotationSelectorSettings) === 'string' ? JSON.parse(annotation.AnnotationSelectorSettings) : annotation.AnnotationSelectorSettings;\n        }\n        else {\n            selector = this.getSelector(annotation.Subject);\n        }\n        return selector;\n    };\n    /**\n     * @param {AnnotType} type - It describes about the annotation type\n     * @private\n     * @returns {void}\n     */\n    MeasureAnnotation.prototype.setAnnotationType = function (type) {\n        var author = 'Guest';\n        var subject = '';\n        var customData;\n        this.updateMeasureproperties();\n        this.pdfViewerBase.disableTextSelectionMode();\n        switch (type) {\n            case 'Distance': {\n                this.currentAnnotationMode = 'Distance';\n                var modifiedDateDist = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.distanceSettings.author ? this.pdfViewer.distanceSettings.author : 'Guest';\n                subject = (this.pdfViewer.annotationSettings.subject !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.subject)) ? this.pdfViewer.annotationSettings.subject : this.pdfViewer.distanceSettings.subject ? this.pdfViewer.distanceSettings.subject : 'Distance calculation';\n                customData = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.customData) ?\n                    this.pdfViewer.annotationSettings.customData : this.pdfViewer.distanceSettings.customData ?\n                    this.pdfViewer.distanceSettings.customData : null;\n                this.pdfViewer.drawingObject = {\n                    sourceDecoraterShapes: this.pdfViewer.annotation.getArrowType(this.distanceStartHead),\n                    taregetDecoraterShapes: this.pdfViewer.annotation.getArrowType(this.distanceEndHead), measureType: 'Distance',\n                    fillColor: this.distanceFillColor, notes: '', strokeColor: this.distanceStrokeColor, leaderHeight: this.leaderLength,\n                    opacity: this.distanceOpacity, thickness: this.distanceThickness, borderDashArray: this.distanceDashArray.toString(),\n                    shapeAnnotationType: 'Distance', author: author, subject: subject, isCommentLock: false, customData: customData\n                };\n                this.pdfViewer.tool = 'Distance';\n                break;\n            }\n            case 'Perimeter': {\n                this.currentAnnotationMode = 'Perimeter';\n                var modifiedDatePeri = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.perimeterSettings.author ? this.pdfViewer.perimeterSettings.author : 'Guest';\n                subject = (this.pdfViewer.annotationSettings.subject !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.subject)) ? this.pdfViewer.annotationSettings.subject : this.pdfViewer.perimeterSettings.subject ? this.pdfViewer.perimeterSettings.subject : 'Perimeter calculation';\n                this.pdfViewer.drawingObject = {\n                    shapeAnnotationType: 'LineWidthArrowHead', fillColor: this.perimeterFillColor, notes: '', strokeColor: this.perimeterStrokeColor, opacity: this.perimeterOpacity,\n                    thickness: this.perimeterThickness, sourceDecoraterShapes: this.pdfViewer.annotation.getArrowType(this.perimeterStartHead),\n                    taregetDecoraterShapes: this.pdfViewer.annotation.getArrowType(this.perimeterEndHead), measureType: 'Perimeter', borderDashArray: this.perimeterDashArray.toString(),\n                    author: author, subject: subject, isCommentLock: false, customData: customData\n                };\n                this.pdfViewer.tool = 'Perimeter';\n                break;\n            }\n            case 'Area': {\n                this.currentAnnotationMode = 'Area';\n                var modifiedDateArea = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.areaSettings.author ? this.pdfViewer.areaSettings.author : 'Guest';\n                subject = (this.pdfViewer.annotationSettings.subject !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.subject)) ? this.pdfViewer.annotationSettings.subject : this.pdfViewer.areaSettings.subject ? this.pdfViewer.areaSettings.subject : 'Area calculation';\n                this.pdfViewer.drawingObject = {\n                    shapeAnnotationType: 'Polygon', fillColor: this.areaFillColor, notes: '', strokeColor: this.areaStrokeColor,\n                    thickness: this.areaThickness, opacity: this.areaOpacity, measureType: 'Area',\n                    modifiedDate: modifiedDateArea, borderStyle: '', borderDashArray: '0',\n                    author: author, subject: subject, isCommentLock: false, customData: customData\n                };\n                this.pdfViewer.tool = 'Polygon';\n                break;\n            }\n            case 'Radius': {\n                this.currentAnnotationMode = 'Radius';\n                var modifiedDateRad = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.radiusSettings.author ? this.pdfViewer.radiusSettings.author : 'Guest';\n                subject = (this.pdfViewer.annotationSettings.subject !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.subject)) ? this.pdfViewer.annotationSettings.subject : this.pdfViewer.radiusSettings.subject ? this.pdfViewer.radiusSettings.subject : 'Radius calculation';\n                customData = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.customData) ?\n                    this.pdfViewer.annotationSettings.customData : this.pdfViewer.radiusSettings.customData ?\n                    this.pdfViewer.radiusSettings.customData : null;\n                this.pdfViewer.drawingObject = {\n                    shapeAnnotationType: 'Radius', fillColor: this.radiusFillColor, notes: '', strokeColor: this.radiusStrokeColor, opacity: this.radiusOpacity,\n                    thickness: this.radiusThickness, measureType: 'Radius', modifiedDate: modifiedDateRad, borderStyle: '', borderDashArray: '0',\n                    author: author, subject: subject, isCommentLock: false, customData: customData\n                };\n                this.pdfViewer.tool = 'DrawTool';\n                break;\n            }\n            case 'Volume': {\n                this.currentAnnotationMode = 'Volume';\n                var modifiedDateVol = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.volumeSettings.author ? this.pdfViewer.volumeSettings.author : 'Guest';\n                subject = (this.pdfViewer.annotationSettings.subject !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.subject)) ? this.pdfViewer.annotationSettings.subject : this.pdfViewer.volumeSettings.subject ? this.pdfViewer.volumeSettings.subject : 'Volume calculation';\n                this.pdfViewer.drawingObject = {\n                    shapeAnnotationType: 'Polygon', notes: '', fillColor: this.volumeFillColor, strokeColor: this.volumeStrokeColor,\n                    opacity: this.volumeOpacity, thickness: this.volumeThickness, measureType: 'Volume',\n                    modifiedDate: modifiedDateVol, borderStyle: '', borderDashArray: '0',\n                    author: author, subject: subject, isCommentLock: false, customData: customData\n                };\n                this.pdfViewer.tool = 'Polygon';\n                break;\n            }\n        }\n    };\n    MeasureAnnotation.prototype.updateMeasureproperties = function () {\n        this.distanceFillColor = this.pdfViewer.distanceSettings.fillColor ? this.pdfViewer.distanceSettings.fillColor : '#ff0000';\n        this.distanceStrokeColor = this.pdfViewer.distanceSettings.strokeColor ? this.pdfViewer.distanceSettings.strokeColor : '#ff0000';\n        this.distanceOpacity = this.pdfViewer.distanceSettings.opacity ? this.pdfViewer.distanceSettings.opacity : 1;\n        this.distanceThickness = this.pdfViewer.distanceSettings.thickness ? this.pdfViewer.distanceSettings.thickness : 1;\n        this.distanceDashArray = this.pdfViewer.distanceSettings.borderDashArray ? this.pdfViewer.distanceSettings.borderDashArray : 0;\n        this.leaderLength = this.pdfViewer.distanceSettings.leaderLength != null ? this.pdfViewer.distanceSettings.leaderLength : 40;\n        this.distanceStartHead = this.pdfViewer.distanceSettings.lineHeadStartStyle ? this.pdfViewer.distanceSettings.lineHeadStartStyle : 'Closed';\n        this.distanceEndHead = this.pdfViewer.distanceSettings.lineHeadEndStyle ? this.pdfViewer.distanceSettings.lineHeadEndStyle : 'Closed';\n        this.perimeterFillColor = this.pdfViewer.perimeterSettings.fillColor ? this.pdfViewer.perimeterSettings.fillColor : '#ffffff00';\n        this.perimeterStrokeColor = this.pdfViewer.perimeterSettings.strokeColor ? this.pdfViewer.perimeterSettings.strokeColor : '#ff0000';\n        this.perimeterOpacity = this.pdfViewer.perimeterSettings.opacity ? this.pdfViewer.perimeterSettings.opacity : 1;\n        this.perimeterThickness = this.pdfViewer.perimeterSettings.thickness ? this.pdfViewer.perimeterSettings.thickness : 1;\n        this.perimeterDashArray = this.pdfViewer.perimeterSettings.borderDashArray ? this.pdfViewer.perimeterSettings.borderDashArray : 0;\n        this.perimeterStartHead = this.pdfViewer.perimeterSettings.lineHeadStartStyle ? this.pdfViewer.perimeterSettings.lineHeadStartStyle : 'Open';\n        this.perimeterEndHead = this.pdfViewer.perimeterSettings.lineHeadEndStyle ? this.pdfViewer.perimeterSettings.lineHeadEndStyle : 'Open';\n        this.areaFillColor = this.pdfViewer.areaSettings.fillColor ? this.pdfViewer.areaSettings.fillColor : '#ffffff00';\n        this.areaStrokeColor = this.pdfViewer.areaSettings.strokeColor ? this.pdfViewer.areaSettings.strokeColor : '#ff0000';\n        this.areaOpacity = this.pdfViewer.areaSettings.opacity ? this.pdfViewer.areaSettings.opacity : 1;\n        this.areaThickness = this.pdfViewer.areaSettings.thickness ? this.pdfViewer.areaSettings.thickness : 1;\n        this.radiusFillColor = this.pdfViewer.radiusSettings.fillColor ? this.pdfViewer.radiusSettings.fillColor : '#ffffff00';\n        this.radiusStrokeColor = this.pdfViewer.radiusSettings.strokeColor ? this.pdfViewer.radiusSettings.strokeColor : '#ff0000';\n        this.radiusOpacity = this.pdfViewer.radiusSettings.opacity ? this.pdfViewer.radiusSettings.opacity : 1;\n        this.radiusThickness = this.pdfViewer.radiusSettings.thickness ? this.pdfViewer.radiusSettings.thickness : 1;\n        this.volumeFillColor = this.pdfViewer.volumeSettings.fillColor ? this.pdfViewer.volumeSettings.fillColor : '#ffffff00';\n        this.volumeStrokeColor = this.pdfViewer.volumeSettings.strokeColor ? this.pdfViewer.volumeSettings.strokeColor : '#ff0000';\n        this.volumeOpacity = this.pdfViewer.volumeSettings.opacity ? this.pdfViewer.volumeSettings.opacity : 1;\n        this.volumeThickness = this.pdfViewer.volumeSettings.thickness ? this.pdfViewer.volumeSettings.thickness : 1;\n        this.unit = this.pdfViewer.measurementSettings.conversionUnit.toLowerCase();\n        this.displayUnit = this.pdfViewer.measurementSettings.displayUnit.toLowerCase();\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.ratio) || this.ratio !== this.pdfViewer.measurementSettings.scaleRatio) {\n            this.ratio = this.pdfViewer.measurementSettings.scaleRatio;\n        }\n        this.volumeDepth = this.pdfViewer.measurementSettings.depth;\n        this.scaleRatioString = '1 ' + this.unit + ' = ' + this.ratio.toString() + ' ' + this.displayUnit;\n    };\n    MeasureAnnotation.prototype.createAnnotationObject = function (annotationModel) {\n        var bound;\n        var labelBound;\n        var annotationName = this.pdfViewer.annotation.createGUID();\n        var commentsDivid = this.pdfViewer.annotation.stickyNotesAnnotationModule.addComments('shape_measure', (annotationModel.pageIndex + 1), annotationModel.measureType);\n        if (commentsDivid) {\n            document.getElementById(commentsDivid).id = annotationName;\n        }\n        annotationModel.annotName = annotationName;\n        // eslint-disable-next-line\n        annotationModel.author = annotationModel && annotationModel.author != 'Guest' ? annotationModel.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('measure', annotationModel.subject);\n        this.pdfViewer.annotation.stickyNotesAnnotationModule.addTextToComments(annotationName, annotationModel.notes);\n        if (annotationModel.wrapper.bounds) {\n            bound = {\n                left: annotationModel.wrapper.bounds.x, top: annotationModel.wrapper.bounds.y,\n                height: annotationModel.wrapper.bounds.height, width: annotationModel.wrapper.bounds.width,\n                right: annotationModel.wrapper.bounds.right, bottom: annotationModel.wrapper.bounds.bottom\n            };\n            labelBound = this.pdfViewer.annotationModule.inputElementModule.calculateLabelBounds(annotationModel.wrapper.bounds);\n        }\n        else {\n            bound = { left: 0, top: 0, height: 0, width: 0, right: 0, bottom: 0 };\n            labelBound = { left: 0, top: 0, height: 0, width: 0, right: 0, bottom: 0 };\n        }\n        var borderDashArray = parseInt(annotationModel.borderDashArray, 10);\n        borderDashArray = isNaN(borderDashArray) ? 0 : borderDashArray;\n        var measure = { ratio: this.scaleRatioString, x: [this.createNumberFormat('x')], distance: [this.createNumberFormat('d')], area: [this.createNumberFormat('a')] };\n        if (annotationModel.measureType === 'Volume') {\n            measure.depth = this.volumeDepth;\n        }\n        var annotationSettings = this.pdfViewer.annotationModule.findAnnotationSettings(annotationModel, true);\n        var allowedInteractions = this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotationModel);\n        annotationModel.isPrint = annotationSettings.isPrint;\n        var setting = this.pdfViewer.shapeLabelSettings;\n        var labelSettings = { borderColor: annotationModel.strokeColor, fillColor: annotationModel.fillColor,\n            fontColor: annotationModel.fontColor, fontSize: annotationModel.fontSize, labelContent: annotationModel.labelContent,\n            labelHeight: setting.labelHeight, labelWidth: setting.labelMaxWidth, opacity: annotationModel.opacity\n        };\n        return {\n            id: annotationModel.id, shapeAnnotationType: this.getShapeAnnotType(annotationModel.measureType),\n            author: annotationModel.author, allowedInteractions: allowedInteractions,\n            subject: annotationModel.subject, note: annotationModel.notes, strokeColor: annotationModel.strokeColor,\n            fillColor: annotationModel.fillColor, opacity: annotationModel.opacity, thickness: annotationModel.thickness,\n            borderStyle: annotationModel.borderStyle, borderDashArray: borderDashArray, bounds: bound,\n            modifiedDate: this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime(),\n            rotateAngle: 'RotateAngle' + annotationModel.rotateAngle, isCloudShape: annotationModel.isCloudShape, cloudIntensity: annotationModel.cloudIntensity,\n            vertexPoints: annotationModel.vertexPoints, lineHeadStart: this.pdfViewer.annotation.\n                getArrowTypeForCollection(annotationModel.sourceDecoraterShapes),\n            lineHeadEnd: this.pdfViewer.annotation.getArrowTypeForCollection(annotationModel.taregetDecoraterShapes),\n            rectangleDifference: [], isLocked: annotationSettings.isLock,\n            leaderLength: annotationModel.leaderHeight, leaderLineExtension: 2, leaderLineOffset: 0, calibrate: measure, caption: true, captionPosition: 'Top',\n            indent: this.getIndent(annotationModel.measureType), annotName: annotationName, comments: [], review: { state: '', stateModel: '', modifiedDate: this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime(), author: annotationModel.author },\n            labelContent: annotationModel.labelContent, enableShapeLabel: annotationModel.enableShapeLabel,\n            labelFillColor: annotationModel.labelFillColor,\n            labelBorderColor: annotationModel.labelBorderColor, fontColor: annotationModel.fontColor, fontSize: annotationModel.fontSize,\n            labelBounds: labelBound, annotationSelectorSettings: this.getSelector(annotationModel.subject),\n            labelSettings: labelSettings, annotationSettings: annotationSettings,\n            customData: this.pdfViewer.annotation.getMeasureData(annotationModel.subject), isPrint: annotationModel.isPrint,\n            isCommentLock: annotationModel.isCommentLock, isAnnotationRotated: false\n        };\n    };\n    MeasureAnnotation.prototype.getSelector = function (type) {\n        var selector = this.pdfViewer.annotationSelectorSettings;\n        if ((type === 'Distance calculation') && this.pdfViewer.distanceSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.distanceSettings.annotationSelectorSettings;\n        }\n        else if ((type === 'Perimeter calculation') && this.pdfViewer.perimeterSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.perimeterSettings.annotationSelectorSettings;\n        }\n        else if ((type === 'Area calculation') && this.pdfViewer.areaSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.areaSettings.annotationSelectorSettings;\n        }\n        else if ((type === 'Radius calculation') && this.pdfViewer.radiusSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.radiusSettings.annotationSelectorSettings;\n        }\n        else if ((type === 'Volume calculation') && this.pdfViewer.volumeSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.volumeSettings.annotationSelectorSettings;\n        }\n        return selector;\n    };\n    MeasureAnnotation.prototype.getShapeAnnotType = function (measureType) {\n        var annotationType;\n        switch (measureType) {\n            case 'Distance':\n                annotationType = 'Line';\n                break;\n            case 'Perimeter':\n                annotationType = 'Polyline';\n                break;\n            case 'Area':\n            case 'Volume':\n                annotationType = 'Polygon';\n                break;\n            case 'Radius':\n                annotationType = 'Circle';\n                break;\n        }\n        return annotationType;\n    };\n    MeasureAnnotation.prototype.getShapeType = function (shape) {\n        var shapeType;\n        if (shape.shapeAnnotationType === 'Line') {\n            shapeType = 'Distance';\n        }\n        else if (shape.shapeAnnotationType === 'Polyline') {\n            shapeType = 'LineWidthArrowHead';\n        }\n        else if (shape.shapeAnnotationType === 'Polygon' && shape.indent === 'PolygonDimension') {\n            shapeType = 'Polygon';\n        }\n        else if ((shape.shapeAnnotationType === 'Polygon' && shape.indent === 'PolygonRadius') || shape.shapeAnnotationType === 'Circle') {\n            shapeType = 'Radius';\n        }\n        else if (shape.shapeAnnotationType === 'Polygon' && shape.indent === 'PolygonVolume') {\n            shapeType = 'Polygon';\n        }\n        return shapeType;\n    };\n    MeasureAnnotation.prototype.getMeasureType = function (shape) {\n        var measureType;\n        if (shape.shapeAnnotationType === 'Line') {\n            measureType = 'Distance';\n        }\n        else if (shape.shapeAnnotationType === 'Polyline') {\n            measureType = 'Perimeter';\n        }\n        else if (shape.shapeAnnotationType === 'Polygon' && shape.indent === 'PolygonDimension') {\n            measureType = 'Area';\n        }\n        else if ((shape.shapeAnnotationType === 'Polygon' && shape.indent === 'PolygonRadius') || shape.shapeAnnotationType === 'Circle') {\n            measureType = 'Radius';\n        }\n        else if (shape.shapeAnnotationType === 'Polygon' && shape.indent === 'PolygonVolume') {\n            measureType = 'Volume';\n        }\n        return measureType;\n    };\n    MeasureAnnotation.prototype.getIndent = function (measureType) {\n        var indent;\n        switch (measureType) {\n            case 'Distance':\n                indent = 'LineDimension';\n                break;\n            case 'Perimeter':\n                indent = 'PolyLineDimension';\n                break;\n            case 'Area':\n                indent = 'PolygonDimension';\n                break;\n            case 'Radius':\n                indent = 'PolygonRadius';\n                break;\n            case 'Volume':\n                indent = 'PolygonVolume';\n                break;\n        }\n        return indent;\n    };\n    MeasureAnnotation.prototype.getNumberFormatArray = function (list) {\n        var numberFormatArray = [];\n        if (list) {\n            for (var i = 0; i < list.length; i++) {\n                numberFormatArray[parseInt(i.toString(), 10)] = { unit: list[parseInt(i.toString(), 10)].Unit,\n                    fractionalType: list[parseInt(i.toString(), 10)].FractionalType,\n                    conversionFactor: list[parseInt(i.toString(), 10)].ConversionFactor,\n                    denominator: list[parseInt(i.toString(), 10)].Denominator,\n                    formatDenominator: list[parseInt(i.toString(), 10)].FormatDenominator };\n            }\n        }\n        return numberFormatArray;\n    };\n    MeasureAnnotation.prototype.createNumberFormat = function (type) {\n        var cFactor = 1;\n        var unit = this.displayUnit;\n        if (type === 'x') {\n            cFactor = this.getFactor(this.unit);\n        }\n        if (type === 'a') {\n            unit = 'sq ' + this.displayUnit;\n        }\n        var numberFormat = { unit: unit, fractionalType: 'D', conversionFactor: cFactor, denominator: 100, formatDenominator: false };\n        return numberFormat;\n    };\n    /**\n     * @private\n     * @returns {string} - string\n     */\n    MeasureAnnotation.prototype.saveMeasureShapeAnnotations = function () {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_shape_measure');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_shape_measure'];\n        }\n        var annotations = [];\n        for (var j = 0; j < this.pdfViewerBase.pageCount; j++) {\n            annotations[parseInt(j.toString(), 10)] = [];\n        }\n        if (storeObject && !this.pdfViewer.annotationSettings.skipDownload) {\n            var annotationCollection = JSON.parse(storeObject);\n            for (var i = 0; i < annotationCollection.length; i++) {\n                var newArray = [];\n                var pageAnnotationObject = annotationCollection[parseInt(i.toString(), 10)];\n                if (pageAnnotationObject) {\n                    for (var z = 0; pageAnnotationObject.annotations.length > z; z++) {\n                        this.pdfViewer.annotationModule.updateModifiedDate(pageAnnotationObject.annotations[parseInt(z.toString(), 10)]);\n                        if (this.pdfViewerBase.isJsonExported) {\n                            if (pageAnnotationObject.annotations[parseInt(z.toString(), 10)].isAnnotationRotated) {\n                                pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds =\n                                    this.pdfViewer.annotation.getBounds(pageAnnotationObject.\n                                        annotations[parseInt(z.toString(), 10)].bounds, pageAnnotationObject.pageIndex);\n                                pageAnnotationObject.annotations[parseInt(z.toString(), 10)].vertexPoints =\n                                    this.pdfViewer.annotation.getVertexPoints(pageAnnotationObject.\n                                        annotations[parseInt(z.toString(), 10)].vertexPoints, pageAnnotationObject.pageIndex);\n                            }\n                            else {\n                                var pageDetails = this.pdfViewerBase.pageSize[pageAnnotationObject.pageIndex];\n                                if (pageDetails) {\n                                    pageAnnotationObject.annotations[parseInt(z.toString(), 10)].annotationRotation = pageDetails.rotation;\n                                }\n                            }\n                        }\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds =\n                            JSON.stringify(this.pdfViewer.annotation.\n                                getBounds(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds, pageAnnotationObject.pageIndex));\n                        var strokeColorString = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].strokeColor;\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].strokeColor =\n                            JSON.stringify(this.getRgbCode(strokeColorString));\n                        var fillColorString = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].fillColor;\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].fillColor =\n                            JSON.stringify(this.getRgbCode(fillColorString));\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].vertexPoints =\n                            JSON.stringify(this.pdfViewer.annotation.\n                                getVertexPoints(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].vertexPoints, pageAnnotationObject.pageIndex));\n                        if (pageAnnotationObject.annotations[parseInt(z.toString(), 10)].rectangleDifference !== null) {\n                            pageAnnotationObject.annotations[parseInt(z.toString(), 10)].rectangleDifference =\n                                JSON.stringify(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].rectangleDifference);\n                        }\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].calibrate =\n                            this.getStringifiedMeasure(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].calibrate);\n                        if (pageAnnotationObject.annotations[parseInt(z.toString(), 10)].enableShapeLabel === true) {\n                            pageAnnotationObject.annotations[parseInt(z.toString(), 10)].labelBounds =\n                                JSON.stringify(this.pdfViewer.annotationModule.inputElementModule.calculateLabelBounds(JSON.parse(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds), pageAnnotationObject.pageIndex));\n                            var labelFillColorString = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].labelFillColor;\n                            pageAnnotationObject.annotations[parseInt(z.toString(), 10)].labelFillColor =\n                                JSON.stringify(this.getRgbCode(labelFillColorString));\n                            var labelBorderColorString = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].labelBorderColor;\n                            pageAnnotationObject.annotations[parseInt(z.toString(), 10)].labelBorderColor =\n                                JSON.stringify(this.getRgbCode(labelBorderColorString));\n                            pageAnnotationObject.annotations[parseInt(z.toString(), 10)].labelSettings.fillColor = labelFillColorString;\n                            var fontColorString = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].labelSettings.fontColor;\n                            pageAnnotationObject.annotations[parseInt(z.toString(), 10)].fontColor =\n                                JSON.stringify(this.getRgbCode(fontColorString));\n                        }\n                    }\n                    newArray = pageAnnotationObject.annotations;\n                }\n                annotations[pageAnnotationObject.pageIndex] = newArray;\n            }\n        }\n        return JSON.stringify(annotations);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    MeasureAnnotation.prototype.createScaleRatioWindow = function () {\n        var _this = this;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isBlazor)()) {\n            var elementID = this.pdfViewer.element.id;\n            var dialogDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { id: elementID + '_scale_ratio_window', className: 'e-pv-scale-ratio-window' });\n            this.pdfViewerBase.pageContainer.appendChild(dialogDiv);\n            var contentElement = this.createRatioUI();\n            this.scaleRatioDialog = new _syncfusion_ej2_popups__WEBPACK_IMPORTED_MODULE_3__.Dialog({\n                showCloseIcon: true, closeOnEscape: false, isModal: true, header: this.pdfViewer.localeObj.getConstant('Scale Ratio'),\n                target: this.pdfViewer.element, content: contentElement, close: function () {\n                    _this.sourceTextBox.destroy();\n                    _this.convertUnit.destroy();\n                    _this.destTextBox.destroy();\n                    _this.dispUnit.destroy();\n                    _this.scaleRatioDialog.destroy();\n                    var dialogElement = _this.pdfViewerBase.getElement('_scale_ratio_window');\n                    dialogElement.parentElement.removeChild(dialogElement);\n                }\n            });\n            if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.Browser.isDevice || this.pdfViewer.enableDesktopMode) {\n                this.scaleRatioDialog.buttons = [\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('OK'), isPrimary: true }, click: this.onOkClicked.bind(this) },\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('Cancel') }, click: this.onCancelClicked.bind(this) }\n                ];\n            }\n            else {\n                this.scaleRatioDialog.buttons = [\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('Cancel') }, click: this.onCancelClicked.bind(this) },\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('OK'), isPrimary: true }, click: this.onOkClicked.bind(this) }\n                ];\n            }\n            if (this.pdfViewer.enableRtl) {\n                this.scaleRatioDialog.enableRtl = true;\n            }\n            this.scaleRatioDialog.appendTo(dialogDiv);\n            this.convertUnit.content = this.createContent(this.pdfViewer.localeObj.getConstant(this.unit)).outerHTML;\n            this.dispUnit.content = this.createContent(this.pdfViewer.localeObj.getConstant(this.displayUnit)).outerHTML;\n            this.depthUnit.content = this.createContent(this.pdfViewer.localeObj.getConstant(this.displayUnit)).outerHTML;\n        }\n        else {\n            this.pdfViewer._dotnetInstance.invokeMethodAsync('OpenScaleRatioDialog');\n        }\n    };\n    MeasureAnnotation.prototype.createRatioUI = function () {\n        var element = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div');\n        var elementID = this.pdfViewer.element.id;\n        var items = [{ text: this.pdfViewer.localeObj.getConstant('pt'), label: 'pt' }, { text: this.pdfViewer.localeObj.getConstant('in'), label: 'in' }, { text: this.pdfViewer.localeObj.getConstant('mm'), label: 'mm' }, { text: this.pdfViewer.localeObj.getConstant('cm'), label: 'cm' }, { text: this.pdfViewer.localeObj.getConstant('p'), label: 'p' }, { text: this.pdfViewer.localeObj.getConstant('ft'), label: 'ft' }, { text: this.pdfViewer.localeObj.getConstant('ft_in'), label: 'ft_in' }, { text: this.pdfViewer.localeObj.getConstant('m'), label: 'm' }];\n        var labelText = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { id: elementID + '_scale_ratio_label', className: 'e-pv-scale-ratio-text' });\n        labelText.textContent = this.pdfViewer.localeObj.getConstant('Scale Ratio');\n        element.appendChild(labelText);\n        var sourceContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { id: elementID + '_scale_src_container' });\n        element.appendChild(sourceContainer);\n        var srcInputElement = this.createInputElement('input', 'e-pv-scale-ratio-src-input', elementID + '_src_input', sourceContainer);\n        this.sourceTextBox = new _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_1__.NumericTextBox({ value: this.srcValue ? this.srcValue : 1, format: '##', cssClass: 'e-pv-scale-ratio-src-input', min: 1, max: 100 }, srcInputElement);\n        var srcUnitElement = this.createInputElement('button', 'e-pv-scale-ratio-src-unit', elementID + '_src_unit', sourceContainer);\n        this.convertUnit = new _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__.DropDownButton({ items: items, cssClass: 'e-pv-scale-ratio-src-unit' }, srcUnitElement);\n        this.convertUnit.select = this.convertUnitSelect.bind(this);\n        var destinationContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { id: elementID + '_scale_dest_container' });\n        var destInputElement = this.createInputElement('input', 'e-pv-scale-ratio-dest-input', elementID + '_dest_input', destinationContainer);\n        this.destTextBox = new _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_1__.NumericTextBox({ value: this.destValue ? this.destValue : 1, format: '##', cssClass: 'e-pv-scale-ratio-dest-input', min: 1, max: 100 }, destInputElement);\n        var destUnitElement = this.createInputElement('button', 'e-pv-scale-ratio-dest-unit', elementID + '_dest_unit', destinationContainer);\n        this.dispUnit = new _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__.DropDownButton({ items: items, cssClass: 'e-pv-scale-ratio-dest-unit' }, destUnitElement);\n        this.dispUnit.select = this.dispUnitSelect.bind(this);\n        element.appendChild(destinationContainer);\n        var depthLabelText = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { id: elementID + '_depth_label', className: 'e-pv-depth-text' });\n        depthLabelText.textContent = this.pdfViewer.localeObj.getConstant('Depth');\n        element.appendChild(depthLabelText);\n        var depthContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { id: elementID + '_depth_container' });\n        element.appendChild(depthContainer);\n        var depthInputElement = this.createInputElement('input', 'e-pv-depth-input', elementID + '_depth_input', depthContainer);\n        this.depthTextBox = new _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_1__.NumericTextBox({ value: this.volumeDepth, format: '##', cssClass: 'e-pv-depth-input', min: 1 }, depthInputElement);\n        var depthUnitElement = this.createInputElement('button', 'e-pv-depth-unit', elementID + '_depth_unit', depthContainer);\n        this.depthUnit = new _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__.DropDownButton({ items: items, cssClass: 'e-pv-depth-unit' }, depthUnitElement);\n        this.depthUnit.select = this.depthUnitSelect.bind(this);\n        return element;\n    };\n    MeasureAnnotation.prototype.convertUnitSelect = function (args) {\n        this.convertUnit.content = this.createContent(args.item.text).outerHTML;\n    };\n    MeasureAnnotation.prototype.dispUnitSelect = function (args) {\n        this.dispUnit.content = this.createContent(args.item.text).outerHTML;\n        this.depthUnit.content = this.createContent(args.item.text).outerHTML;\n    };\n    MeasureAnnotation.prototype.depthUnitSelect = function (args) {\n        this.depthUnit.content = this.createContent(args.item.text).outerHTML;\n    };\n    MeasureAnnotation.prototype.createContent = function (text) {\n        var divElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { className: 'e-pv-scale-unit-content' });\n        divElement.textContent = text;\n        return divElement;\n    };\n    MeasureAnnotation.prototype.createInputElement = function (input, className, idString, parentElement) {\n        var container = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)('div', { id: idString + '_container', className: className + '-container' });\n        var textBoxInput = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.createElement)(input, { id: idString });\n        if (input === 'input') {\n            textBoxInput.type = 'text';\n        }\n        container.appendChild(textBoxInput);\n        parentElement.appendChild(container);\n        return textBoxInput;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    MeasureAnnotation.prototype.onOkClicked = function () {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isBlazor)()) {\n            var unitElement = document.querySelector('#' + this.pdfViewer.element.id + '_src_unit');\n            var displayElement = document.querySelector('#' + this.pdfViewer.element.id + '_dest_unit');\n            var sourceTextBox = document.querySelector('#' + this.pdfViewer.element.id + '_ratio_input');\n            var destTextBox = document.querySelector('#' + this.pdfViewer.element.id + '_dest_input');\n            var depthTextBox = document.querySelector('#' + this.pdfViewer.element.id + '_depth_input');\n            if (unitElement && displayElement && sourceTextBox && destTextBox && depthTextBox) {\n                this.unit = unitElement.value;\n                this.displayUnit = displayElement.value;\n                this.ratio = parseInt(destTextBox.value, 10) / parseInt(sourceTextBox.value, 10);\n                this.volumeDepth = parseInt(depthTextBox.value, 10);\n            }\n            this.scaleRatioString = parseInt(sourceTextBox.value, 10) + ' ' + this.unit + ' = ' + parseInt(destTextBox.value, 10) + ' ' + this.displayUnit;\n            this.updateMeasureValues(this.scaleRatioString, this.displayUnit, this.unit, this.volumeDepth);\n        }\n        else {\n            this.unit = this.getContent(this.convertUnit.content);\n            this.displayUnit = this.getContent(this.dispUnit.content);\n            this.ratio = this.destTextBox.value / this.sourceTextBox.value;\n            this.volumeDepth = this.depthTextBox.value;\n            this.scaleRatioString = this.sourceTextBox.value + ' ' + this.unit + ' = ' + this.destTextBox.value + ' ' + this.displayUnit;\n            this.scaleRatioDialog.hide();\n            var originalUnit = this.restoreUnit(this.convertUnit);\n            var originalDisplayUnit = this.restoreUnit(this.dispUnit);\n            this.updateMeasureValues(this.scaleRatioString, originalDisplayUnit, originalUnit, this.volumeDepth);\n        }\n    };\n    MeasureAnnotation.prototype.restoreUnit = function (dropdownObject) {\n        var calibUnit;\n        for (var i = 0; i < dropdownObject.items.length; i++) {\n            var convertUnitItem = dropdownObject.items[parseInt(i.toString(), 10)];\n            if (this.unit === convertUnitItem.text) {\n                calibUnit = convertUnitItem.label;\n            }\n        }\n        return calibUnit;\n    };\n    /**\n     * @param {string} ratio - It describes about the ratio\n     * @param {CalibrationUnit} displayUnit - It describes about the display unit\n     * @param {CalibrationUnit} conversionUnit - It describes about the conversion unit\n     * @param {number} depth - It describes about the depth\n     * @private\n     * @returns {void}\n     */\n    MeasureAnnotation.prototype.updateMeasureValues = function (ratio, displayUnit, conversionUnit, depth) {\n        this.scaleRatioString = ratio;\n        this.displayUnit = displayUnit;\n        this.unit = conversionUnit;\n        this.volumeDepth = depth;\n        for (var i = 0; i < this.pdfViewerBase.pageCount; i++) {\n            var pageAnnotations = this.getAnnotations(i, null);\n            if (pageAnnotations) {\n                for (var j = 0; j < pageAnnotations.length; j++) {\n                    pageAnnotations = this.getAnnotations(i, null);\n                    var measureObject = pageAnnotations[parseInt(j.toString(), 10)];\n                    if (!measureObject.annotationSettings.isLock) {\n                        measureObject.calibrate.ratio = ratio;\n                        measureObject.calibrate.x[0].unit = displayUnit;\n                        measureObject.calibrate.distance[0].unit = displayUnit;\n                        measureObject.calibrate.area[0].unit = displayUnit;\n                        measureObject.calibrate.x[0].conversionFactor = this.getFactor(conversionUnit);\n                        if (measureObject.indent === 'PolygonVolume') {\n                            measureObject.calibrate.depth = depth;\n                        }\n                        pageAnnotations[parseInt(j.toString(), 10)] = measureObject;\n                        this.manageAnnotations(pageAnnotations, i);\n                        this.pdfViewer.annotation.updateCalibrateValues(this.getAnnotationBaseModel(measureObject.id));\n                    }\n                }\n            }\n            this.pdfViewer.annotation.renderAnnotations(i, null, null, null, null, false);\n        }\n    };\n    MeasureAnnotation.prototype.getAnnotationBaseModel = function (id) {\n        var annotationBase = null;\n        for (var i = 0; i < this.pdfViewer.annotations.length; i++) {\n            if (id === this.pdfViewer.annotations[parseInt(i.toString(), 10)].id) {\n                annotationBase = this.pdfViewer.annotations[parseInt(i.toString(), 10)];\n                break;\n            }\n        }\n        return annotationBase;\n    };\n    MeasureAnnotation.prototype.getContent = function (unit) {\n        return unit.split('</div>')[0].split('\">')[1];\n    };\n    /**\n     * @param value\n     * @param currentAnnot\n     * @private\n     */\n    MeasureAnnotation.prototype.setConversion = function (value, currentAnnot) {\n        var values;\n        if (currentAnnot) {\n            var pageIndex = currentAnnot.pageIndex;\n            if (currentAnnot.id === 'diagram_helper') {\n                pageIndex = currentAnnot.pageIndex ? currentAnnot.pageIndex : this.pdfViewerBase.activeElements.activePageID;\n                currentAnnot = this.getCurrentObject(pageIndex, null, currentAnnot.annotName);\n            }\n            if (currentAnnot) {\n                values = this.getCurrentValues(currentAnnot.id, pageIndex);\n            }\n            else {\n                values = this.getCurrentValues();\n            }\n        }\n        else {\n            values = this.getCurrentValues();\n        }\n        var scaledValue = value * values.ratio;\n        return this.convertPointToUnits(values.factor, scaledValue, values.unit);\n    };\n    MeasureAnnotation.prototype.onCancelClicked = function () {\n        this.scaleRatioDialog.hide();\n    };\n    /**\n     * @param {string} property - It describes about the property\n     * @param {number} pageNumber - It describes about the page number\n     * @param {any} annotationBase - It describes about the annotation base\n     * @param {boolean} isNewlyAdded - It describes about whether the isNewlyAdded is true or not\n     * @private\n     * @returns {IMeasureShapeAnnotation} - IMeasureShapeAnnotation\n     */\n    MeasureAnnotation.prototype.modifyInCollection = function (property, pageNumber, annotationBase, isNewlyAdded) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(annotationBase.formFieldAnnotationType) && annotationBase.formFieldAnnotationType !== '') {\n            this.pdfViewer.annotationModule.isFormFieldShape = true;\n        }\n        else {\n            this.pdfViewer.annotationModule.isFormFieldShape = false;\n        }\n        var currentAnnotObject = null;\n        var isEdited = false;\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations != null && annotationBase) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (annotationBase.id === pageAnnotations[parseInt(i.toString(), 10)].id) {\n                    if (property === 'bounds') {\n                        this.pdfViewerBase.isBounds =\n                            this.pdfViewerBase.boundsCalculation(pageAnnotations[parseInt(i.toString(), 10)].bounds, annotationBase.wrapper.bounds);\n                        if (this.pdfViewerBase.isBounds) {\n                            this.pdfViewer.annotationModule.stickyNotesAnnotationModule.updateAnnotationModifiedDate(annotationBase, true);\n                            if (pageAnnotations[parseInt(i.toString(), 10)].shapeAnnotationType === 'Line' || pageAnnotations[parseInt(i.toString(), 10)].shapeAnnotationType === 'Polyline') {\n                                pageAnnotations[parseInt(i.toString(), 10)].vertexPoints = annotationBase.vertexPoints;\n                                pageAnnotations[parseInt(i.toString(), 10)].bounds =\n                                    {\n                                        left: annotationBase.bounds.x, top: annotationBase.bounds.y,\n                                        width: annotationBase.bounds.width, height: annotationBase.bounds.height,\n                                        right: annotationBase.bounds.right, bottom: annotationBase.bounds.bottom\n                                    };\n                            }\n                            else if (pageAnnotations[parseInt(i.toString(), 10)].shapeAnnotationType === 'Polygon') {\n                                pageAnnotations[parseInt(i.toString(), 10)].vertexPoints = annotationBase.vertexPoints;\n                                pageAnnotations[parseInt(i.toString(), 10)].bounds =\n                                    {\n                                        left: annotationBase.bounds.x, top: annotationBase.bounds.y, width: annotationBase.bounds.width,\n                                        height: annotationBase.bounds.height, right: annotationBase.bounds.right,\n                                        bottom: annotationBase.bounds.bottom\n                                    };\n                            }\n                            else {\n                                pageAnnotations[parseInt(i.toString(), 10)].bounds =\n                                    {\n                                        left: annotationBase.bounds.x, top: annotationBase.bounds.y, width: annotationBase.bounds.width,\n                                        height: annotationBase.bounds.height, right: annotationBase.bounds.right,\n                                        bottom: annotationBase.bounds.bottom\n                                    };\n                            }\n                        }\n                        if (pageAnnotations[parseInt(i.toString(), 10)].enableShapeLabel === true && annotationBase.wrapper) {\n                            pageAnnotations[parseInt(i.toString(), 10)].labelBounds =\n                                this.pdfViewer.annotationModule.inputElementModule.calculateLabelBounds(annotationBase.wrapper.bounds);\n                        }\n                    }\n                    else if (property === 'fill') {\n                        pageAnnotations[parseInt(i.toString(), 10)].fillColor = annotationBase.wrapper.children[0].style.fill;\n                        if (this.pdfViewer.enableShapeLabel) {\n                            pageAnnotations[parseInt(i.toString(), 10)].labelFillColor = annotationBase.wrapper.children[0].style.fill;\n                        }\n                    }\n                    else if (property === 'stroke') {\n                        pageAnnotations[parseInt(i.toString(), 10)].strokeColor = annotationBase.wrapper.children[0].style.strokeColor;\n                    }\n                    else if (property === 'opacity') {\n                        pageAnnotations[parseInt(i.toString(), 10)].opacity = annotationBase.wrapper.children[0].style.opacity;\n                    }\n                    else if (property === 'thickness') {\n                        pageAnnotations[parseInt(i.toString(), 10)].thickness = annotationBase.wrapper.children[0].style.strokeWidth;\n                    }\n                    else if (property === 'dashArray') {\n                        pageAnnotations[parseInt(i.toString(), 10)].borderDashArray =\n                            annotationBase.wrapper.children[0].style.strokeDashArray;\n                        pageAnnotations[parseInt(i.toString(), 10)].borderStyle = annotationBase.borderStyle;\n                    }\n                    else if (property === 'startArrow') {\n                        pageAnnotations[parseInt(i.toString(), 10)].lineHeadStart =\n                            this.pdfViewer.annotation.getArrowTypeForCollection(annotationBase.sourceDecoraterShapes);\n                    }\n                    else if (property === 'endArrow') {\n                        pageAnnotations[parseInt(i.toString(), 10)].lineHeadEnd =\n                            this.pdfViewer.annotation.getArrowTypeForCollection(annotationBase.taregetDecoraterShapes);\n                    }\n                    else if (property === 'leaderLength') {\n                        pageAnnotations[parseInt(i.toString(), 10)].leaderLength = annotationBase.leaderHeight;\n                    }\n                    else if (property === 'notes') {\n                        pageAnnotations[parseInt(i.toString(), 10)].note = annotationBase.notes;\n                        if (pageAnnotations[parseInt(i.toString(), 10)].enableShapeLabel === true) {\n                            isEdited = true;\n                            pageAnnotations[parseInt(i.toString(), 10)].labelContent = annotationBase.notes;\n                        }\n                    }\n                    else if (property === 'delete') {\n                        currentAnnotObject = pageAnnotations.splice(i, 1)[0];\n                        break;\n                    }\n                    else if (property === 'labelContent') {\n                        pageAnnotations[parseInt(i.toString(), 10)].note = annotationBase.labelContent;\n                        pageAnnotations[parseInt(i.toString(), 10)].labelContent = annotationBase.labelContent;\n                        break;\n                    }\n                    else if (property === 'fontColor') {\n                        pageAnnotations[parseInt(i.toString(), 10)].fontColor = annotationBase.fontColor;\n                    }\n                    else if (property === 'fontSize') {\n                        pageAnnotations[parseInt(i.toString(), 10)].fontSize = annotationBase.fontSize;\n                    }\n                    if (this.pdfViewerBase.isBounds) {\n                        pageAnnotations[parseInt(i.toString(), 10)].modifiedDate =\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                    }\n                    this.pdfViewer.annotationModule.storeAnnotationCollections(pageAnnotations[parseInt(i.toString(), 10)], pageNumber);\n                }\n            }\n            this.manageAnnotations(pageAnnotations, pageNumber);\n        }\n        if (!isNewlyAdded && isEdited) {\n            this.pdfViewerBase.updateDocumentEditedProperty(true);\n        }\n        return currentAnnotObject;\n    };\n    /**\n     * @param {number} pageNumber -It describes about the page number\n     * @param {IMeasureShapeAnnotation} annotationBase - It describes about the annotation base\n     * @private\n     * @returns {void}\n     */\n    MeasureAnnotation.prototype.addInCollection = function (pageNumber, annotationBase) {\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations) {\n            pageAnnotations.push(annotationBase);\n        }\n        this.manageAnnotations(pageAnnotations, pageNumber);\n    };\n    MeasureAnnotation.prototype.manageAnnotations = function (pageAnnotations, pageNumber) {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_shape_measure');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_shape_measure'];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            if (!this.pdfViewerBase.isStorageExceed) {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_shape_measure');\n            }\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageNumber);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotObject[parseInt(index.toString(), 10)].annotations = pageAnnotations;\n            }\n            var annotationStringified = JSON.stringify(annotObject);\n            if (this.pdfViewerBase.isStorageExceed) {\n                this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_shape_measure'] = annotationStringified;\n            }\n            else {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_shape_measure', annotationStringified);\n            }\n        }\n    };\n    MeasureAnnotation.prototype.getAnnotations = function (pageIndex, shapeAnnotations) {\n        var annotationCollection;\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_shape_measure');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_shape_measure'];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageIndex);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotationCollection = annotObject[parseInt(index.toString(), 10)].annotations;\n            }\n            else {\n                annotationCollection = shapeAnnotations;\n            }\n        }\n        else {\n            annotationCollection = shapeAnnotations;\n        }\n        return annotationCollection;\n    };\n    MeasureAnnotation.prototype.getCurrentObject = function (pageNumber, id, annotName) {\n        var currentAnnotObject = null;\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations != null) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (id) {\n                    if (id === pageAnnotations[parseInt(i.toString(), 10)].id) {\n                        currentAnnotObject = pageAnnotations[parseInt(i.toString(), 10)];\n                        break;\n                    }\n                }\n                else if (annotName) {\n                    if (annotName === pageAnnotations[parseInt(i.toString(), 10)].annotName) {\n                        currentAnnotObject = pageAnnotations[parseInt(i.toString(), 10)];\n                        break;\n                    }\n                }\n            }\n        }\n        return currentAnnotObject;\n    };\n    MeasureAnnotation.prototype.getCurrentValues = function (id, pageNumber) {\n        var ratio;\n        var unit;\n        var factor;\n        var depth;\n        if (id && !isNaN(pageNumber)) {\n            var currentAnnotObject = this.getCurrentObject(pageNumber, id);\n            if (currentAnnotObject) {\n                ratio = this.getCurrentRatio(currentAnnotObject.calibrate.ratio);\n                unit = currentAnnotObject.calibrate.x[0].unit;\n                factor = currentAnnotObject.calibrate.x[0].conversionFactor;\n                depth = currentAnnotObject.calibrate.depth;\n            }\n            else {\n                ratio = this.ratio;\n                unit = this.displayUnit;\n                factor = this.getFactor(this.unit);\n                depth = this.volumeDepth;\n            }\n        }\n        else {\n            ratio = this.ratio;\n            unit = this.displayUnit;\n            factor = this.getFactor(this.unit);\n            depth = this.volumeDepth;\n        }\n        return { ratio: ratio, unit: unit, factor: factor, depth: depth };\n    };\n    MeasureAnnotation.prototype.getCurrentRatio = function (ratioString) {\n        var stringArray = ratioString.split(' ');\n        if (stringArray[3] === '=') {\n            return parseFloat(stringArray[4]) / parseFloat(stringArray[0]);\n        }\n        else {\n            return parseFloat(stringArray[3]) / parseFloat(stringArray[0]);\n        }\n    };\n    /**\n     * @param {PointModel} points - It describes about the points\n     * @param {string} id - It describes about the id\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {string} - string\n     */\n    MeasureAnnotation.prototype.calculateArea = function (points, id, pageNumber) {\n        var values = this.getCurrentValues(id, pageNumber);\n        var area = this.getArea(points, values.factor, values.unit) * values.ratio;\n        if (values.unit === 'ft_in') {\n            var calculateValue = Math.round(area * 100) / 100;\n            if (calculateValue >= 12) {\n                calculateValue = (Math.round(calculateValue / 12 * 100) / 100).toString();\n                calculateValue = calculateValue.split('.');\n                if (calculateValue[1]) {\n                    var inchValue = 0;\n                    if (calculateValue[1].charAt(1)) {\n                        inchValue = parseInt(calculateValue[1].charAt(0), 10) + '.' + parseInt(calculateValue[1].charAt(1), 10);\n                        inchValue = Math.round(inchValue);\n                    }\n                    else {\n                        inchValue = calculateValue[1];\n                    }\n                    if (!inchValue) {\n                        return (calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('sq') + ' ' + this.pdfViewer.localeObj.getConstant('ft'));\n                    }\n                    else {\n                        return (calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('sq') + ' ' + this.pdfViewer.localeObj.getConstant('ft') + ' ' + inchValue + ' ' + this.pdfViewer.localeObj.getConstant('in'));\n                    }\n                }\n                else {\n                    return (calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('sq') + ' ' + this.pdfViewer.localeObj.getConstant('ft'));\n                }\n            }\n            else {\n                return (Math.round(area * 100) / 100) + ' ' + this.pdfViewer.localeObj.getConstant('sq') + ' ' + this.pdfViewer.localeObj.getConstant('in');\n            }\n        }\n        if (values.unit === 'm') {\n            return ((area * 100) / 100) + ' ' + this.pdfViewer.localeObj.getConstant('sq') + ' ' + this.pdfViewer.localeObj.getConstant(values.unit);\n        }\n        return (Math.round(area * 100) / 100) + ' ' + this.pdfViewer.localeObj.getConstant('sq') + ' ' + this.pdfViewer.localeObj.getConstant(values.unit);\n    };\n    MeasureAnnotation.prototype.getArea = function (points, factor, unit) {\n        var area = 0;\n        var j = points.length - 1;\n        for (var i = 0; i < points.length; i++) {\n            area += (points[parseInt(j.toString(), 10)].x * this.pixelToPointFactor *\n                factor + points[parseInt(i.toString(), 10)].x * this.pixelToPointFactor * factor) *\n                (points[parseInt(j.toString(), 10)].y * this.pixelToPointFactor * factor - points[parseInt(i.toString(), 10)].y *\n                    this.pixelToPointFactor * factor);\n            j = i;\n        }\n        if (unit === 'ft_in') {\n            return (Math.abs((area) * 2.0));\n        }\n        else {\n            return (Math.abs((area) / 2.0));\n        }\n    };\n    /**\n     * @param {PointModel} points - It describes about the points\n     * @param {string} id - It describes about the id\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {string} - string\n     */\n    MeasureAnnotation.prototype.calculateVolume = function (points, id, pageNumber) {\n        var values = this.getCurrentValues(id, pageNumber);\n        var depth = values.depth ? values.depth : this.volumeDepth;\n        var area = this.getArea(points, values.factor, values.unit);\n        var volume = area * ((depth * this.convertUnitToPoint(values.unit)) * values.factor) * values.ratio;\n        if (values.unit === 'ft_in') {\n            var calculateValue = Math.round(volume * 100) / 100;\n            if (calculateValue >= 12) {\n                calculateValue = (Math.round(calculateValue / 12 * 100) / 100).toString();\n                calculateValue = calculateValue.split('.');\n                if (calculateValue[1]) {\n                    var inchValue = 0;\n                    if (calculateValue[1].charAt(1)) {\n                        inchValue = parseInt(calculateValue[1].charAt(0), 10) + '.' + parseInt(calculateValue[1].charAt(1), 10);\n                        inchValue = Math.round(inchValue);\n                    }\n                    else {\n                        inchValue = calculateValue[1];\n                    }\n                    if (!inchValue) {\n                        return (calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('cu') + ' ' + this.pdfViewer.localeObj.getConstant('ft'));\n                    }\n                    else {\n                        return (calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('cu') + ' ' + this.pdfViewer.localeObj.getConstant('ft') + ' ' + inchValue + ' ' + this.pdfViewer.localeObj.getConstant('in'));\n                    }\n                }\n                else {\n                    return (calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('cu') + ' ' + this.pdfViewer.localeObj.getConstant('ft'));\n                }\n            }\n            else {\n                return (Math.round(volume * 100) / 100) + ' ' + this.pdfViewer.localeObj.getConstant('cu') + ' ' + this.pdfViewer.localeObj.getConstant('in');\n            }\n        }\n        return (Math.round(volume * 100) / 100) + ' ' + this.pdfViewer.localeObj.getConstant('cu') + ' ' + this.pdfViewer.localeObj.getConstant(values.unit);\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} pdfAnnotationBase - It describes about the pdf annotation base\n     * @private\n     * @returns {string} - string\n     */\n    MeasureAnnotation.prototype.calculatePerimeter = function (pdfAnnotationBase) {\n        var perimeter = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__.Point.getLengthFromListOfPoints(pdfAnnotationBase.vertexPoints);\n        return this.setConversion(perimeter * this.pixelToPointFactor, pdfAnnotationBase);\n    };\n    MeasureAnnotation.prototype.getFactor = function (unit) {\n        var factor;\n        switch (unit) {\n            case 'in':\n                factor = (1 / 72);\n                break;\n            case 'cm':\n                factor = (1 / 28.346);\n                break;\n            case 'mm':\n                factor = (1 / 2.835);\n                break;\n            case 'pt':\n                factor = 1;\n                break;\n            case 'p':\n                factor = 1 / 12;\n                break;\n            case 'ft':\n                factor = 1 / 864;\n                break;\n            case 'ft_in':\n                factor = 1 / 72;\n                break;\n            case 'm':\n                factor = (1 / 2834.64567);\n                break;\n        }\n        return factor;\n    };\n    MeasureAnnotation.prototype.convertPointToUnits = function (factor, value, unit) {\n        var convertedValue;\n        if (unit === 'ft_in') {\n            var calculateValue = Math.round((value * factor) * 100) / 100;\n            if (calculateValue >= 12) {\n                calculateValue = (Math.round(calculateValue / 12 * 100) / 100).toString();\n                calculateValue = calculateValue.split('.');\n                if (calculateValue[1]) {\n                    var inchValue = 0;\n                    if (calculateValue[1].charAt(1)) {\n                        inchValue = parseInt(calculateValue[1].charAt(0), 10) + '.' + parseInt(calculateValue[1].charAt(1), 10);\n                        inchValue = Math.round(inchValue);\n                    }\n                    else {\n                        inchValue = calculateValue[1];\n                    }\n                    if (!inchValue) {\n                        convertedValue = calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('ft');\n                    }\n                    else {\n                        convertedValue = calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('ft') + ' ' + inchValue + ' ' + this.pdfViewer.localeObj.getConstant('in');\n                    }\n                }\n                else {\n                    convertedValue = calculateValue[0] + ' ' + this.pdfViewer.localeObj.getConstant('ft');\n                }\n            }\n            else {\n                convertedValue = Math.round((value * factor) * 100) / 100 + ' ' + this.pdfViewer.localeObj.getConstant('in');\n            }\n        }\n        else {\n            convertedValue = Math.round((value * factor) * 100) / 100 + ' ' + this.pdfViewer.localeObj.getConstant(unit);\n        }\n        return convertedValue;\n    };\n    MeasureAnnotation.prototype.convertUnitToPoint = function (unit) {\n        var factor;\n        switch (unit) {\n            case 'in':\n                factor = 72;\n                break;\n            case 'cm':\n                factor = 28.346;\n                break;\n            case 'mm':\n                factor = 2.835;\n                break;\n            case 'pt':\n                factor = 1;\n                break;\n            case 'p':\n                factor = 12;\n                break;\n            case 'ft':\n                factor = 864;\n                break;\n            case 'ft_in':\n                factor = 72;\n                break;\n            case 'm':\n                factor = 2834.64567;\n                break;\n        }\n        return factor;\n    };\n    MeasureAnnotation.prototype.getStringifiedMeasure = function (measure) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(measure)) {\n            measure.angle = JSON.stringify(measure.angle);\n            measure.area = JSON.stringify(measure.area);\n            measure.distance = JSON.stringify(measure.distance);\n            measure.volume = JSON.stringify(measure.volume);\n        }\n        return JSON.stringify(measure);\n    };\n    MeasureAnnotation.prototype.getRgbCode = function (colorString) {\n        // eslint-disable-next-line\n        if (!colorString.match(/#([a-z0-9]+)/gi) && !colorString.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/)) {\n            colorString = this.pdfViewer.annotationModule.nameToHash(colorString);\n        }\n        var stringArray = colorString.split(',');\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(stringArray[1])) {\n            colorString = this.pdfViewer.annotationModule.getValue(colorString, 'rgba');\n            stringArray = colorString.split(',');\n        }\n        var r = parseInt(stringArray[0].split('(')[1], 10);\n        var g = parseInt(stringArray[1], 10);\n        var b = parseInt(stringArray[2], 10);\n        var a = parseInt(stringArray[3], 10);\n        return { r: r, g: g, b: b, a: a };\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {any} - any\n     */\n    MeasureAnnotation.prototype.saveImportedMeasureAnnotations = function (annotation, pageNumber) {\n        var annotationObject = null;\n        var vertexPoints = null;\n        if (annotation.VertexPoints) {\n            vertexPoints = [];\n            for (var j = 0; j < annotation.VertexPoints.length; j++) {\n                var point = { x: annotation.VertexPoints[parseInt(j.toString(), 10)].X,\n                    y: annotation.VertexPoints[parseInt(j.toString(), 10)].Y };\n                vertexPoints.push(point);\n            }\n        }\n        var measureObject = {\n            ratio: annotation.Calibrate.Ratio, x: this.getNumberFormatArray(annotation.Calibrate.X),\n            distance: this.getNumberFormatArray(annotation.Calibrate.Distance),\n            area: this.getNumberFormatArray(annotation.Calibrate.Area),\n            angle: this.getNumberFormatArray(annotation.Calibrate.Angle),\n            volume: this.getNumberFormatArray(annotation.Calibrate.Volume),\n            targetUnitConversion: annotation.Calibrate.TargetUnitConversion\n        };\n        if (annotation.Calibrate.Depth) {\n            measureObject.depth = annotation.Calibrate.Depth;\n        }\n        if (annotation.Bounds && annotation.EnableShapeLabel === true) {\n            annotation.LabelBounds =\n                this.pdfViewer.annotationModule.inputElementModule.calculateLabelBoundsFromLoadedDocument(annotation.Bounds);\n            annotation.LabelBorderColor = annotation.LabelBorderColor ? annotation.LabelBorderColor : annotation.StrokeColor;\n            annotation.FontColor = annotation.FontColor ? annotation.FontColor : annotation.StrokeColor;\n            annotation.LabelFillColor = annotation.LabelFillColor ? annotation.LabelFillColor : annotation.FillColor;\n            annotation.FontSize = annotation.FontSize ? annotation.FontSize : 16;\n            annotation.LabelSettings = annotation.LabelSettings ? annotation.LabelSettings : this.pdfViewer.shapeLabelSettings;\n        }\n        annotation.allowedInteractions = annotation.AllowedInteractions ?\n            annotation.AllowedInteractions : this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n        annotation.AnnotationSettings = annotation.AnnotationSettings ?\n            annotation.AnnotationSettings : this.pdfViewer.annotationModule.updateAnnotationSettings(annotation);\n        annotation.Author = this.pdfViewer.annotationModule.updateAnnotationAuthor('measure', annotation.Subject);\n        annotationObject = {\n            id: 'measure', shapeAnnotationType: annotation.ShapeAnnotationType, author: annotation.Author, allowedInteractions: annotation.allowedInteractions, modifiedDate: annotation.ModifiedDate, subject: annotation.Subject,\n            note: annotation.Note, strokeColor: annotation.StrokeColor, fillColor: annotation.FillColor,\n            opacity: annotation.Opacity, thickness: annotation.Thickness, rectangleDifference: annotation.RectangleDifference,\n            borderStyle: annotation.BorderStyle, borderDashArray: annotation.BorderDashArray,\n            rotateAngle: annotation.RotateAngle, isCloudShape: annotation.IsCloudShape,\n            cloudIntensity: annotation.CloudIntensity, vertexPoints: vertexPoints,\n            lineHeadStart: annotation.LineHeadStart, lineHeadEnd: annotation.LineHeadEnd, isLocked: annotation.IsLocked,\n            bounds: { left: annotation.Bounds.X, top: annotation.Bounds.Y, width: annotation.Bounds.Width,\n                height: annotation.Bounds.Height, right: annotation.Bounds.Right, bottom: annotation.Bounds.Bottom },\n            caption: annotation.Caption, captionPosition: annotation.CaptionPosition, calibrate: measureObject,\n            leaderLength: annotation.LeaderLength, leaderLineExtension: annotation.LeaderLineExtension,\n            leaderLineOffset: annotation.LeaderLineOffset, indent: annotation.Indent, annotName: annotation.AnnotName,\n            comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author),\n            review: { state: annotation.State, stateModel: annotation.StateModel, modifiedDate: annotation.ModifiedDate,\n                author: annotation.Author },\n            labelContent: annotation.LabelContent, enableShapeLabel: annotation.EnableShapeLabel, labelFillColor: annotation.LabelFillColor,\n            labelBorderColor: annotation.LabelBorderColor, fontColor: annotation.FontColor, fontSize: annotation.FontSize,\n            labelBounds: annotation.LabelBounds, annotationSelectorSettings: this.getSettings(annotation),\n            labelSettings: annotation.LabelSettings, annotationSettings: annotation.AnnotationSettings,\n            customData: this.pdfViewer.annotation.getCustomData(annotation), isPrint: annotation.IsPrint,\n            isCommentLock: annotation.IsCommentLock, isAnnotationRotated: false\n        };\n        this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotationObject, '_annotations_shape_measure');\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number value\n     * @private\n     * @returns {any} - any\n     */\n    MeasureAnnotation.prototype.updateMeasureAnnotationCollections = function (annotation, pageNumber) {\n        var annotationObject = null;\n        var vertexPoints = null;\n        if (annotation.VertexPoints) {\n            vertexPoints = [];\n            for (var j = 0; j < annotation.VertexPoints.length; j++) {\n                var point = { x: annotation.VertexPoints[parseInt(j.toString(), 10)].X,\n                    y: annotation.VertexPoints[parseInt(j.toString(), 10)].Y };\n                vertexPoints.push(point);\n            }\n        }\n        var measureObject = {\n            ratio: annotation.Calibrate.Ratio, x: this.getNumberFormatArray(annotation.Calibrate.X),\n            distance: this.getNumberFormatArray(annotation.Calibrate.Distance),\n            area: this.getNumberFormatArray(annotation.Calibrate.Area),\n            angle: this.getNumberFormatArray(annotation.Calibrate.Angle), volume: this.getNumberFormatArray(annotation.Calibrate.Volume),\n            targetUnitConversion: annotation.Calibrate.TargetUnitConversion\n        };\n        if (annotation.Calibrate.Depth) {\n            measureObject.depth = annotation.Calibrate.Depth;\n        }\n        if (annotation.Bounds && annotation.EnableShapeLabel === true) {\n            annotation.LabelBounds =\n                this.pdfViewer.annotationModule.inputElementModule.calculateLabelBoundsFromLoadedDocument(annotation.Bounds);\n            annotation.LabelBorderColor = annotation.LabelBorderColor ? annotation.LabelBorderColor : annotation.StrokeColor;\n            annotation.FontColor = annotation.FontColor ? annotation.FontColor : annotation.StrokeColor;\n            annotation.LabelFillColor = annotation.LabelFillColor ? annotation.LabelFillColor : annotation.FillColor;\n            annotation.FontSize = annotation.FontSize ? annotation.FontSize : 16;\n            var settings = this.pdfViewer.shapeLabelSettings;\n            var labelSettings = { borderColor: annotation.StrokeColor, fillColor: annotation.FillColor, fontColor: annotation.FontColor,\n                fontSize: annotation.FontSize, labelContent: annotation.LabelContent, labelHeight: settings.labelHeight,\n                labelWidth: settings.labelWidth, opacity: annotation.Opacity\n            };\n            annotation.LabelSettings = annotation.LabelSettings ? annotation.LabelSettings : labelSettings;\n        }\n        annotation.allowedInteractions = annotation.AllowedInteractions ?\n            annotation.AllowedInteractions : this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n        annotation.AnnotationSelectorSettings =\n            annotation.AnnotationSelectorSettings ? annotation.AnnotationSelectorSettings :\n                this.pdfViewerBase.annotationSelectorSettingLoad(annotation);\n        annotation.AnnotationSettings = annotation.AnnotationSettings ?\n            annotation.AnnotationSettings : this.pdfViewer.annotationModule.updateAnnotationSettings(annotation);\n        if (annotation.IsLocked) {\n            annotation.AnnotationSettings.isLock = annotation.IsLocked;\n        }\n        annotationObject = {\n            id: 'measure', shapeAnnotationType: annotation.ShapeAnnotationType, author: annotation.Author, allowedInteractions: annotation.allowedInteractions, modifiedDate: annotation.ModifiedDate, subject: annotation.Subject,\n            note: annotation.Note, strokeColor: annotation.StrokeColor, fillColor: annotation.FillColor,\n            opacity: annotation.Opacity, thickness: annotation.Thickness, rectangleDifference: annotation.RectangleDifference,\n            borderStyle: annotation.BorderStyle, borderDashArray: annotation.BorderDashArray,\n            rotateAngle: annotation.RotateAngle, isCloudShape: annotation.IsCloudShape,\n            cloudIntensity: annotation.CloudIntensity, vertexPoints: vertexPoints, lineHeadStart: annotation.LineHeadStart,\n            lineHeadEnd: annotation.LineHeadEnd, isLocked: annotation.IsLocked,\n            bounds: { left: annotation.Bounds.X, top: annotation.Bounds.Y, width: annotation.Bounds.Width,\n                height: annotation.Bounds.Height, right: annotation.Bounds.Right, bottom: annotation.Bounds.Bottom },\n            caption: annotation.Caption, captionPosition: annotation.CaptionPosition, calibrate: measureObject,\n            leaderLength: annotation.LeaderLength, leaderLineExtension: annotation.LeaderLineExtension,\n            leaderLineOffset: annotation.LeaderLineOffset, indent: annotation.Indent, annotationId: annotation.AnnotName,\n            comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author),\n            review: { state: annotation.State, stateModel: annotation.StateModel, modifiedDate: annotation.ModifiedDate,\n                author: annotation.Author },\n            labelContent: annotation.LabelContent, enableShapeLabel: annotation.EnableShapeLabel, labelFillColor: annotation.LabelFillColor,\n            labelBorderColor: annotation.LabelBorderColor, fontColor: annotation.FontColor, fontSize: annotation.FontSize,\n            labelBounds: annotation.LabelBounds, pageNumber: pageNumber, annotationSelectorSettings: annotation.AnnotationSelectorSettings,\n            labelSettings: annotation.labelSettings, annotationSettings: annotation.AnnotationSettings,\n            customData: this.pdfViewer.annotation.getCustomData(annotation), isPrint: annotation.IsPrint,\n            isCommentLock: annotation.IsCommentLock\n        };\n        return annotationObject;\n    };\n    /**\n     * This method used to add annotations with using program.\n     *\n     * @param {AnnotationType} annotationType - It describes the annotation type\n     * @param {any} annotationObject - It describes type of annotation object\n     * @param {IPoint} offset - It describes about the annotation bounds or location\n     * @returns {object} - object\n     * @private\n     */\n    MeasureAnnotation.prototype.updateAddAnnotationDetails = function (annotationType, annotationObject, offset) {\n        //Creating new object if annotationObject is null\n        if (!annotationObject) {\n            annotationObject = { offset: { x: 10, y: 10 }, pageNumber: 0, width: undefined, height: undefined };\n            offset = annotationObject.offset;\n        }\n        else if (!annotationObject.offset) {\n            offset = { x: 10, y: 10 };\n        }\n        else {\n            offset = annotationObject.offset;\n        }\n        //Initialize the annotation settings\n        var annotationSelectorSettings = null;\n        var allowedInteractions = null;\n        var annotationSettings = null;\n        var measureAnnotationType = '';\n        var shapeAnnotationType = '';\n        var subject = '';\n        var isArrow = false;\n        var vertexPoints = [];\n        //Creating the CurrentDate and Annotation name\n        var currentDateString = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n        var annotationName = this.pdfViewer.annotation.createGUID();\n        if (annotationType === 'Distance') {\n            //Creating annotation settings\n            annotationSelectorSettings = this.pdfViewer.lineSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotationSelectorSettings);\n            annotationSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.lineSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('measure', annotationType);\n            allowedInteractions = this.pdfViewer.lineSettings.allowedInteractions ?\n                this.pdfViewer.lineSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            measureAnnotationType = 'LineDimension';\n            shapeAnnotationType = 'Line';\n            subject = this.pdfViewer.lineSettings.subject !== '' ? this.pdfViewer.lineSettings.subject : this.pdfViewer.annotationSettings.subject !== '' ? this.pdfViewer.annotationSettings.subject : 'Distance calculation';\n            isArrow = true;\n            if (annotationObject.vertexPoints) {\n                vertexPoints = annotationObject.vertexPoints;\n            }\n            else {\n                vertexPoints = [{ x: offset.x, y: offset.y }, { x: offset.x + 100, y: offset.y }];\n            }\n            annotationObject.width = annotationObject.width ? annotationObject.width : 1;\n            annotationObject.height = annotationObject.height ? annotationObject.height : 1;\n        }\n        else if (annotationType === 'Perimeter') {\n            //Creating annotation settings\n            annotationSelectorSettings = this.pdfViewer.arrowSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotationSelectorSettings);\n            annotationSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.arrowSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('measure', annotationType);\n            allowedInteractions = this.pdfViewer.arrowSettings.allowedInteractions ?\n                this.pdfViewer.arrowSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            measureAnnotationType = 'PolyLineDimension';\n            shapeAnnotationType = 'Polyline';\n            subject = this.pdfViewer.arrowSettings.subject !== '' ? this.pdfViewer.arrowSettings.subject : this.pdfViewer.annotationSettings.subject !== '' ? this.pdfViewer.annotationSettings.subject : 'Perimeter calculation';\n            isArrow = true;\n            if (annotationObject.vertexPoints) {\n                vertexPoints = annotationObject.vertexPoints;\n            }\n            else {\n                vertexPoints = [{ x: offset.x, y: offset.y },\n                    { x: offset.x + 85, y: offset.y },\n                    { x: offset.x + 86, y: offset.y + 62 }];\n            }\n            annotationObject.width = annotationObject.width ? annotationObject.width : 1;\n            annotationObject.height = annotationObject.height ? annotationObject.height : 1;\n        }\n        else if (annotationType === 'Area') {\n            //Creating annotation settings\n            annotationSelectorSettings = this.pdfViewer.rectangleSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotationSelectorSettings);\n            annotationSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.rectangleSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('measure', annotationType);\n            allowedInteractions = this.pdfViewer.rectangleSettings.allowedInteractions ?\n                this.pdfViewer.rectangleSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            measureAnnotationType = 'PolygonDimension';\n            shapeAnnotationType = 'Polygon';\n            subject = this.pdfViewer.rectangleSettings.subject !== '' ? this.pdfViewer.rectangleSettings.subject : this.pdfViewer.annotationSettings.subject !== '' ? this.pdfViewer.annotationSettings.subject : 'Area calculation';\n            if (annotationObject.vertexPoints) {\n                vertexPoints = annotationObject.vertexPoints;\n            }\n            else {\n                vertexPoints = [{ x: offset.x, y: offset.y },\n                    { x: offset.x + 88, y: offset.y - 1 },\n                    { x: offset.x + 89, y: offset.y + 53 },\n                    { x: offset.x, y: offset.y }];\n            }\n            annotationObject.width = annotationObject.width ? annotationObject.width : 1;\n            annotationObject.height = annotationObject.height ? annotationObject.height : 1;\n        }\n        else if (annotationType === 'Radius') {\n            //Creating annotation settings\n            annotationSelectorSettings = this.pdfViewer.circleSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotationSelectorSettings);\n            annotationSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.circleSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('measure', annotationType);\n            allowedInteractions = this.pdfViewer.circleSettings.allowedInteractions ?\n                this.pdfViewer.circleSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            measureAnnotationType = 'PolygonRadius';\n            shapeAnnotationType = 'Circle';\n            subject = this.pdfViewer.circleSettings.subject !== '' ? this.pdfViewer.circleSettings.subject : this.pdfViewer.annotationSettings.subject !== '' ? this.pdfViewer.annotationSettings.subject : 'Radius calculation';\n            annotationObject.width = annotationObject.width ? annotationObject.width : 100;\n            annotationObject.height = annotationObject.height ? annotationObject.height : 100;\n            vertexPoints = null;\n        }\n        else if (annotationType === 'Volume') {\n            //Creating annotation settings\n            annotationSelectorSettings = this.pdfViewer.polygonSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotationSelectorSettings);\n            annotationSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.polygonSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('measure', annotationType);\n            allowedInteractions = this.pdfViewer.polygonSettings.allowedInteractions ?\n                this.pdfViewer.polygonSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            measureAnnotationType = 'PolygonVolume';\n            shapeAnnotationType = 'Polygon';\n            subject = this.pdfViewer.polygonSettings.subject !== '' ? this.pdfViewer.polygonSettings.subject : this.pdfViewer.annotationSettings.subject !== '' ? this.pdfViewer.annotationSettings.subject : 'Volume calculation';\n            if (annotationObject.vertexPoints) {\n                vertexPoints = annotationObject.vertexPoints;\n            }\n            else {\n                vertexPoints = [\n                    { x: offset.x, y: offset.y },\n                    { x: offset.x, y: offset.y + 109 },\n                    { x: offset.x + 120, y: offset.y + 109 },\n                    { x: offset.x + 120, y: offset.y - 1 },\n                    { x: offset.x, y: offset.y }\n                ];\n            }\n            annotationObject.width = annotationObject.width ? annotationObject.width : 1;\n            annotationObject.height = annotationObject.height ? annotationObject.height : 1;\n        }\n        annotationSettings.isLock = annotationObject.isLock ? annotationObject.isLock : annotationSettings.isLock;\n        annotationSettings.minHeight = annotationObject.minHeight ? annotationObject.minHeight : annotationSettings.minHeight;\n        annotationSettings.minWidth = annotationObject.minWidth ? annotationObject.minWidth : annotationSettings.minWidth;\n        annotationSettings.maxWidth = annotationObject.maxWidth ? annotationObject.maxWidth : annotationSettings.maxWidth;\n        annotationSettings.maxHeight = annotationObject.maxHeight ? annotationObject.maxHeight : annotationSettings.maxHeight;\n        //Calculating area for all the measurements\n        var values = { depth: 96,\n            factor: 0.013888888888888888,\n            ratio: 1,\n            unit: 'in' };\n        var notes = '';\n        if (vertexPoints || annotationType === 'Radius' || annotationType === 'Volume') {\n            if (annotationType === 'Distance' || annotationType === 'Perimeter' || annotationType === 'Radius') {\n                var length_1 = 0;\n                if (annotationType === 'Radius') {\n                    length_1 = (annotationObject.width / 2) * this.pixelToPointFactor;\n                }\n                else {\n                    for (var i = 0; i < vertexPoints.length - 1; i++) {\n                        length_1 += Math.sqrt(Math.pow((vertexPoints[parseInt(i.toString(), 10)].x - vertexPoints[i + 1].x), 2)\n                            + Math.pow((vertexPoints[parseInt(i.toString(), 10)].y - vertexPoints[i + 1].y), 2));\n                    }\n                    length_1 = length_1 * this.pixelToPointFactor;\n                }\n                var scaledValue = length_1 * values.ratio;\n                notes = this.convertPointToUnits(values.factor, scaledValue, values.unit);\n            }\n            else if (annotationType === 'Area' || annotationType === 'Volume') {\n                var area = 0;\n                var j = vertexPoints.length - 1;\n                for (var i = 0; i < vertexPoints.length; i++) {\n                    area += (vertexPoints[parseInt(j.toString(), 10)].x * this.pixelToPointFactor *\n                        values.factor + vertexPoints[parseInt(i.toString(), 10)].x * this.pixelToPointFactor *\n                        values.factor) * (vertexPoints[parseInt(j.toString(), 10)].y * this.pixelToPointFactor *\n                        values.factor - vertexPoints[parseInt(i.toString(), 10)].y * this.pixelToPointFactor * values.factor);\n                    j = i;\n                }\n                area = (Math.abs((area) / 2.0));\n                if (annotationType === 'Volume') {\n                    area = area * ((values.depth * this.convertUnitToPoint(values.unit)) * values.factor) * values.ratio;\n                    notes = Math.round(area * 100) / 100 + this.pdfViewer.localeObj.getConstant('cu') + ' ' + this.pdfViewer.localeObj.getConstant(values.unit);\n                }\n                else {\n                    notes = Math.round(area * 100) / 100 + this.pdfViewer.localeObj.getConstant('sq') + ' ' + this.pdfViewer.localeObj.getConstant(values.unit);\n                }\n            }\n        }\n        //Converting points model into vertex property\n        if (vertexPoints) {\n            vertexPoints = this.pdfViewer.annotation.getVertexPointsXY(vertexPoints);\n        }\n        //Creating Annotation objects with it's proper properties\n        var measureShapeAnnotation = [];\n        var shape = {\n            AllowedInteractions: annotationObject.allowedInteractions ? annotationObject.allowedInteractions : allowedInteractions,\n            AnnotName: annotationName,\n            AnnotType: 'shape_measure',\n            AnnotationSelectorSettings: annotationObject.annotationSelectorSettings ?\n                annotationObject.annotationSelectorSettings : annotationSelectorSettings,\n            AnnotationSettings: annotationSettings,\n            Author: annotationObject.author ? annotationObject.author : 'Guest',\n            BorderDashArray: annotationObject.borderDashArray ? annotationObject.borderDashArray : 0,\n            BorderStyle: 'Solid',\n            Bounds: { X: offset.x, Y: offset.y, Width: annotationObject.width, Height: annotationObject.height,\n                Left: offset.x, Top: offset.y, Location: { X: offset.x, Y: offset.y },\n                Size: { Height: annotationObject.height, IsEmpty: false, Width: annotationObject.width } },\n            Calibrate: {\n                Area: [{ ConversionFactor: 1, Denominator: 100, FormatDenominator: false, FractionalType: 'D', Unit: 'sq in' }],\n                Depth: annotationObject.depth ? annotationObject.depth : 0,\n                Distance: [{ ConversionFactor: 1, Denominator: 100, FormatDenominator: false, FractionalType: 'D', Unit: 'in' }],\n                Ratio: '1 in = 1 in',\n                TargetUnitConversion: 0,\n                Volume: null,\n                X: [{ ConversionFactor: 0.013888889, Denominator: 100, FormatDenominator: false, FractionalType: 'D', Unit: 'in' }]\n            },\n            Caption: true,\n            CaptionPosition: 'Top',\n            CloudIntensity: 0,\n            Comments: null,\n            CustomData: annotationObject.customData ? annotationObject.customData : null,\n            CreatedDate: currentDateString,\n            EnableShapeLabel: false,\n            ExistingCustomData: null,\n            FillColor: annotationObject.fillColor ? annotationObject.fillColor : '#ffffff00',\n            FontColor: null,\n            FontSize: 0,\n            Indent: measureAnnotationType,\n            IsCloudShape: false,\n            IsCommentLock: false,\n            IsLocked: annotationObject.isLock ? annotationObject.isLock : false,\n            IsPrint: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(annotationObject.isPrint) ? annotationObject.isPrint : true,\n            LabelBorderColor: null,\n            LabelBounds: { X: 0, Y: 0, Width: 0, Height: 0 },\n            LabelContent: null,\n            LabelFillColor: null,\n            LabelSettings: null,\n            LeaderLength: annotationObject.leaderLength ? annotationObject.leaderLength : 0,\n            LeaderLineExtension: 0,\n            LeaderLineOffset: 0,\n            LineHeadStart: annotationObject.lineHeadStartStyle ? annotationObject.lineHeadStartStyle : isArrow ? 'ClosedArrow' : 'None',\n            LineHeadEnd: annotationObject.lineHeadEndStyle ? annotationObject.lineHeadEndStyle : isArrow ? 'ClosedArrow' : 'None',\n            ModifiedDate: '',\n            Note: notes,\n            Opacity: annotationObject.opacity ? annotationObject.opacity : 1,\n            RectangleDifference: [],\n            RotateAngle: 'RotateAngle0',\n            ShapeAnnotationType: shapeAnnotationType,\n            State: '',\n            StateModel: '',\n            StrokeColor: annotationObject.strokeColor ? annotationObject.strokeColor : '#ff0000',\n            Subject: annotationObject.subject ? annotationObject.subject : subject,\n            Thickness: annotationObject.thickness ? annotationObject.thickness : 1,\n            VertexPoints: vertexPoints\n        };\n        //Adding the annotation object to an array and return it\n        measureShapeAnnotation[0] = shape;\n        return { measureShapeAnnotation: measureShapeAnnotation };\n    };\n    return MeasureAnnotation;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/measure-annotation.js?");

/***/ })

}]);