"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_axis_multi-level-labels_js-dd6a3818"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/axis/multi-level-labels.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/axis/multi-level-labels.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiLevelLabel: () => (/* binding */ MultiLevelLabel)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n\n\n\n\n\n/**\n * The `MultiLevelLabel` module is used to render multi-level labels in charts.\n */\nvar MultiLevelLabel = /** @class */ (function () {\n    /**\n     * Constructor for the logerithmic module.\n     *\n     * @private\n     * @param {Chart} chart - Specifies the chart.\n     */\n    function MultiLevelLabel(chart) {\n        /** @private */\n        this.xAxisPrevHeight = [];\n        /** @private */\n        this.xAxisMultiLabelHeight = [];\n        /** @private */\n        this.yAxisPrevHeight = [];\n        /** @private */\n        this.yAxisMultiLabelHeight = [];\n        /** @private */\n        this.multiLevelLabelRectXRegion = [];\n        /** @private */\n        this.xLabelCollection = [];\n        this.chart = chart;\n        this.addEventListener();\n    }\n    /**\n     * Binding events for multi level module.\n     *\n     * @returns {void}\n     */\n    MultiLevelLabel.prototype.addEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.on('click', this.click, this);\n    };\n    /**\n     * Gets the height of multilevel labels for the axis.\n     *\n     * @private\n     * @param {Axis} axis - The axis.\n     * @returns {void}\n     */\n    MultiLevelLabel.prototype.getMultilevelLabelsHeight = function (axis) {\n        var _this = this;\n        var value = 0;\n        var multiLevelLabelsHeight = [];\n        var prevHeight = [];\n        var isVertical = axis.orientation === 'Vertical';\n        var axisValue = isVertical ? axis.rect.height : axis.rect.width;\n        var labelSize;\n        var height;\n        var padding = 10;\n        var gap;\n        axis.multiLevelLabels.map(function (multiLevel, index) {\n            multiLevel.categories.map(function (categoryLabel, i) {\n                if (categoryLabel.text !== '' && categoryLabel.start !== null && categoryLabel.end !== null) {\n                    labelSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)(categoryLabel.text, multiLevel.textStyle, _this.chart.themeStyle.axisLabelFont);\n                    height = isVertical ? labelSize.width : labelSize.height;\n                    height += 2 * multiLevel.border.width +\n                        (multiLevel.border.type === 'CurlyBrace' ? padding : 0);\n                    gap = (categoryLabel.maximumTextWidth !== null) ? categoryLabel.maximumTextWidth :\n                        ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valueToCoefficient)(typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) :\n                            categoryLabel.end, axis) * axisValue) -\n                            ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valueToCoefficient)(typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) :\n                                categoryLabel.start, axis) * axisValue);\n                    var len = axis.multiLevelLabels[index].categories.length;\n                    gap = ((i === 0 || i === len - 1) && axis.labelPlacement === 'OnTicks' && axis.edgeLabelPlacement === 'Shift') ? gap / 2 : gap;\n                    if ((labelSize.width > gap - padding) && (_this.chart.enableRtl ? gap < 0 : gap > 0) && (multiLevel.overflow === 'Wrap') && !isVertical) {\n                        height = (height * ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textWrap)(categoryLabel.text, gap - padding, multiLevel.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont).length));\n                    }\n                    multiLevelLabelsHeight[index] = !multiLevelLabelsHeight[index] ? height :\n                        ((multiLevelLabelsHeight[index] < height) ? height : multiLevelLabelsHeight[index]);\n                }\n            });\n            prevHeight[index] = value;\n            value += multiLevelLabelsHeight[index] ? (multiLevelLabelsHeight[index] + padding) : 0;\n        });\n        axis.multiLevelLabelHeight = value + ((axis.title !== '' || (this.chart.legendModule && this.chart.legendSettings.visible))\n            ? padding / 2 : 0);\n        if (isVertical) {\n            this.yAxisMultiLabelHeight = multiLevelLabelsHeight;\n            this.yAxisPrevHeight = prevHeight;\n        }\n        else {\n            this.xAxisMultiLabelHeight = multiLevelLabelsHeight;\n            this.xAxisPrevHeight = prevHeight;\n        }\n    };\n    /**\n     * Renders the multilevel labels for the X-axis.\n     *\n     * @private\n     * @param {Axis} axis - The X-axis.\n     * @param {number} index - The index of the axis.\n     * @param {Element} parent - The parent element to render the multilevel labels.\n     * @param {Rect} axisRect - The axis rectangle.\n     * @returns {void}\n     */\n    MultiLevelLabel.prototype.renderXAxisMultiLevelLabels = function (axis, index, parent, axisRect) {\n        var _this = this;\n        var x;\n        var y;\n        var padding = 10;\n        var startX;\n        var pointIndex;\n        var startY = (axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0) +\n            (axis.maxLabelSize.height) + padding;\n        var endX;\n        var pathRect = '';\n        var start;\n        var end;\n        var labelSize;\n        var isOutside = axis.labelPosition === 'Outside';\n        var gap;\n        var anchor;\n        var isInversed = axis.isAxisInverse;\n        var argsData;\n        var opposedPosition = axis.isAxisOpposedPosition;\n        var len;\n        var scrollBarHeight = axis.scrollbarSettings.enable || (isOutside && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt)) ?\n            axis.scrollBarHeight : 0;\n        var clipY = ((opposedPosition && !isOutside) || (!opposedPosition && isOutside)) ?\n            (axisRect.y + startY - axis.majorTickLines.width) : (axisRect.y - startY - axis.multiLevelLabelHeight);\n        this.createClipRect(axisRect.x - axis.majorTickLines.width, clipY + scrollBarHeight, axis.multiLevelLabelHeight + padding, axisRect.width + 2 * axis.majorTickLines.width, this.chart.element.id + '_XAxis_Clippath_' + index, this.chart.element.id + 'XAxisMultiLevelLabel' + index);\n        axis.multiLevelLabels.map(function (multiLevel, level) {\n            pointIndex = 0;\n            _this.labelElement = _this.chart.renderer.createGroup({ id: _this.chart.element.id + index + '_MultiLevelLabel' + level });\n            multiLevel.categories.map(function (categoryLabel, i) {\n                len = multiLevel.categories.length;\n                pathRect = '';\n                start = typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) : categoryLabel.start;\n                end = typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) : categoryLabel.end;\n                var labelFontStyle = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)('properties', multiLevel.textStyle), null, true));\n                argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, labelFontStyle, axis.multiLevelLabels[level].alignment, categoryLabel.customAttributes);\n                if (!argsData.cancel) {\n                    startX = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valueToCoefficient)(start, axis) * axisRect.width;\n                    endX = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valueToCoefficient)(end, axis) * axisRect.width;\n                    endX = isInversed ? [startX, startX = endX][0] : endX;\n                    labelSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);\n                    gap = ((categoryLabel.maximumTextWidth === null) ? endX - startX : categoryLabel.maximumTextWidth) - padding;\n                    x = startX + axisRect.x + padding;\n                    y = (((opposedPosition && !isOutside) || (!opposedPosition && isOutside)) ? (startY + axisRect.y +\n                        labelSize.height / 2 + padding + _this.xAxisPrevHeight[level]) :\n                        (axisRect.y - startY + labelSize.height / 2 - _this.xAxisMultiLabelHeight[level] -\n                            _this.xAxisPrevHeight[level])) + scrollBarHeight;\n                    if (argsData.alignment === 'Center') {\n                        x += (endX - startX - padding) / 2;\n                        anchor = 'middle';\n                    }\n                    else if (argsData.alignment === 'Far') {\n                        x = x + (endX - startX - padding) - multiLevel.border.width / 2;\n                        if (axis.labelPlacement === 'OnTicks' && (i === 0 || i === len - 1)) {\n                            x += (endX - startX - padding) / 2;\n                            x = x - labelSize.width / 2;\n                        }\n                        anchor = 'end';\n                    }\n                    else {\n                        anchor = 'start';\n                        x += multiLevel.border.width / 2;\n                    }\n                    y = multiLevel.border.type === 'CurlyBrace' ?\n                        (((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? y + padding : y - padding / 2) : y;\n                    var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.TextOption(_this.chart.element.id + index + '_Axis_MultiLevelLabel_Level_' + level + '_Text_' + i, x, y, anchor, argsData.text);\n                    if (multiLevel.overflow !== 'None') {\n                        if (axis.edgeLabelPlacement && axis.labelPlacement === 'OnTicks') {\n                            switch (axis.edgeLabelPlacement) {\n                                case 'None':\n                                    break;\n                                case 'Shift':\n                                    if ((i === 0 || (isInversed && i === len - 1))) {\n                                        if (argsData.alignment === 'Center' && ((options.x < axisRect.x + padding) || (options.x - labelSize.width / 2)) < axis.rect.x) {\n                                            options.x += axisRect.x / 2;\n                                            if ((options.x / 2) < axisRect.x) {\n                                                options.x = axisRect.x + padding / 2;\n                                                options.anchor = 'start';\n                                            }\n                                        }\n                                        else if (argsData.alignment === 'Far' && ((options.x < axisRect.x + padding) || (options.x > axisRect.x + padding))) {\n                                            options.x += labelSize.width / 2 - gap / 2;\n                                        }\n                                        else if (argsData.alignment === 'Near' && ((options.x < axisRect.x + padding) || (options.x > axisRect.x + padding))) {\n                                            options.x = axisRect.x + padding;\n                                        }\n                                        gap = gap / 2;\n                                    }\n                                    else if ((i === len - 1 || (isInversed && i === 0))) {\n                                        if (argsData.alignment === 'Center' && (options.x) > axisRect.x + axisRect.width) {\n                                            options.x -= padding;\n                                            if (options.x > axisRect.width) {\n                                                options.x = axisRect.width + axisRect.x;\n                                                options.anchor = 'end';\n                                            }\n                                        }\n                                        else if (argsData.alignment === 'Far') {\n                                            options.x = axisRect.width + axisRect.x;\n                                        }\n                                        gap = gap / 2;\n                                    }\n                                    break;\n                            }\n                        }\n                        options.text = (multiLevel.overflow === 'Wrap') ?\n                            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textWrap)(argsData.text, gap, argsData.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont) :\n                            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textTrim)(gap, argsData.text, argsData.textStyle, _this.chart.enableRtl, _this.chart.themeStyle.axisLabelFont);\n                        options.x = options.x - padding / 2;\n                    }\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textElement)(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color ||\n                        _this.chart.themeStyle.axisLabelFont.color, _this.labelElement, false, _this.chart.redraw, true, null, null, null, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.axisLabelFont);\n                    if (_this.chart.enableCanvas) {\n                        var textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);\n                        _this.multiLevelLabelRectXRegion.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(options.x, options.y, textSize.width, textSize.height));\n                        _this.xLabelCollection.push(options);\n                    }\n                    if (multiLevel.border.width > 0 && multiLevel.border.type !== 'WithoutBorder') {\n                        pathRect = _this.renderXAxisLabelBorder(level, endX - startX - padding, axis, startX, startY, labelSize, options, axisRect, argsData.alignment, pathRect, isOutside, opposedPosition, pointIndex);\n                        // fix for generating seperate rect\n                        if (pathRect !== '') {\n                            _this.createBorderElement(level, index, axis, pathRect, pointIndex);\n                            pointIndex++;\n                        }\n                    }\n                    if (!_this.chart.enableCanvas) {\n                        _this.multiElements.appendChild(_this.labelElement);\n                    }\n                }\n            });\n        });\n        if (!this.chart.enableCanvas) {\n            parent.appendChild(this.multiElements);\n        }\n    };\n    /**\n     * Renders the border for the X-axis labels.\n     *\n     * @private\n     * @param {number} labelIndex - The index of the label.\n     * @param {number} gap - The gap between labels.\n     * @param {Axis} axis - The X-axis.\n     * @param {number} startX - The starting X-coordinate.\n     * @param {number} startY - The starting Y-coordinate.\n     * @param {Size} labelSize - The size of the label.\n     * @param {TextOption} textOptions - The text options for the label.\n     * @param {Rect} axisRect - The axis rectangle.\n     * @param {Alignment} alignment - The alignment of the label.\n     * @param {string} path - The SVG path.\n     * @param {boolean} isOutside - Indicates if the label is outside the axis.\n     * @param {boolean} opposedPosition - Indicates if the axis is in the opposed position.\n     * @param {number} categoryIndex - The index of the category.\n     * @returns {string} - The SVG path.\n     */\n    MultiLevelLabel.prototype.renderXAxisLabelBorder = function (labelIndex, gap, axis, startX, startY, labelSize, textOptions, axisRect, alignment, path, isOutside, opposedPosition, categoryIndex) {\n        var padding = 10;\n        var padding1;\n        var padding2;\n        var value;\n        var value1;\n        var groupLabel = axis.multiLevelLabels[labelIndex];\n        var categoryType = groupLabel.categories[categoryIndex].type;\n        var width = gap + padding;\n        var height = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.xAxisMultiLabelHeight[labelIndex]) ? 0 :\n            (this.xAxisMultiLabelHeight[labelIndex] + padding);\n        var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n        var x = startX + axisRect.x;\n        var y = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? (startY + axisRect.y +\n            this.xAxisPrevHeight[labelIndex] + scrollBarHeight) : (axisRect.y - startY -\n            this.xAxisPrevHeight[labelIndex] - scrollBarHeight);\n        var borderType = categoryType ? categoryType : groupLabel.border.type;\n        switch (borderType) {\n            case 'WithoutTopandBottomBorder':\n            case 'Rectangle':\n            case 'WithoutTopBorder': {\n                var len = axis.multiLevelLabels[labelIndex].categories.length;\n                var lastX = (categoryIndex === len - 1 && (x + width > axisRect.width)) ? axisRect.width + axisRect.x : x + width;\n                var initialX = (categoryIndex === 0 &&\n                    axis.multiLevelLabels[labelIndex].categories[0].start <= 0) ? axisRect.x : x;\n                height = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? height : -height;\n                path += 'M ' + initialX + ' ' + y + ' L ' + initialX + ' ' + (y + height) + ' M ' + (lastX) + ' '\n                    + y + ' L ' + (lastX) + ' ' + (y + height);\n                path += (borderType !== 'WithoutTopandBottomBorder') ? (' L' + ' ' + (initialX) + ' ' + (y + height) + ' ') : ' ';\n                path += (borderType === 'Rectangle') ? ('M ' + initialX + ' ' + y + ' L ' + (lastX) + ' ' + y) : ' ';\n                break;\n            }\n            case 'Brace':\n                if (alignment === 'Near') {\n                    value = textOptions.x;\n                    value1 = textOptions.x + labelSize.width + 2;\n                }\n                else if (alignment === 'Center') {\n                    value = textOptions.x - labelSize.width / 2 - 2;\n                    value1 = textOptions.x + labelSize.width / 2 + 2;\n                }\n                else {\n                    value = textOptions.x - labelSize.width - 2;\n                    value1 = textOptions.x;\n                }\n                height = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? height : -height;\n                path += 'M ' + x + ' ' + y + ' L ' + x + ' ' + (y + height / 2) +\n                    ' M ' + x + ' ' + (y + height / 2) + ' L ' + (value - 2) + ' ' + (y + height / 2) +\n                    ' M ' + (value1) + ' ' + (y + height / 2) + ' L ' + (x + width) + ' ' + (y + height / 2) +\n                    ' M ' + (x + width) + ' ' + (y + height / 2) + ' L ' + (x + width) + ' ' + (y);\n                break;\n            case 'CurlyBrace':\n                if ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) {\n                    padding = 10;\n                    padding1 = 15;\n                    padding2 = 5;\n                }\n                else {\n                    padding = -10;\n                    padding1 = -15;\n                    padding2 = -5;\n                }\n                if (alignment === 'Center') {\n                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' +\n                        (y + padding) + ' L ' + (x + width / 2 - 5) + ' ' + (y + padding) + ' L ' + (x + width / 2) + ' ' + (y + padding1) +\n                        ' L ' + (x + width / 2 + 5) + ' ' + (y + padding) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' C ' +\n                        (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' ' + (y + padding2) + ' ' + (x + width) + ' ' + (y);\n                }\n                else if (alignment === 'Near') {\n                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' +\n                        (y + padding) + ' L ' + (x + 15) + ' ' + (y + padding1) + ' L ' + (x + 20) + ' ' + (y + padding) + ' L ' +\n                        (x + width - 10) + ' ' + (y + padding) + ' C ' + (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' '\n                        + (y + padding2) + ' ' + (x + width) + ' ' + (y);\n                }\n                else {\n                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + 5) + ' ' + (y + padding) + ' ' + (x + 10) + ' ' +\n                        (y + padding) + ' L ' + (x + width - 20) + ' ' + (y + padding) + ' L ' + (x + width - 15) + ' ' + (y + padding1) +\n                        ' L ' + (x + width - 10) + ' ' + (y + padding) + ' L ' + (x + width - 10) + ' ' + (y + padding) + ' C '\n                        + (x + width - 10) + ' ' + (y + padding) + ' ' + (x + width) + ' ' + (y + padding2) + ' ' + (x + width) + ' ' + (y);\n                }\n                break;\n        }\n        return path;\n    };\n    /**\n     * Renders the multi-level labels for the Y-axis.\n     *\n     * @private\n     * @param {Axis} axis - The Y-axis.\n     * @param {number} index - The index of the axis.\n     * @param {Element} parent - The parent element to which the labels are appended.\n     * @param {Rect} rect - The axis rectangle.\n     * @returns {void}\n     */\n    MultiLevelLabel.prototype.renderYAxisMultiLevelLabels = function (axis, index, parent, rect) {\n        var _this = this;\n        var labelSize;\n        var isOutside = axis.labelPosition === 'Outside';\n        var x;\n        var y;\n        var padding = 10;\n        var startX = (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0) +\n            (axis.maxLabelSize.width) + padding;\n        var startY;\n        var path = '';\n        var endY;\n        var argsData;\n        var pointIndex;\n        var isInversed = axis.isAxisInverse;\n        var start;\n        var end;\n        var gap;\n        var anchor = 'middle';\n        var opposedPosition = axis.isAxisOpposedPosition;\n        var scrollBarHeight = isOutside && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt) ? axis.scrollBarHeight : 0;\n        scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);\n        var clipX = ((opposedPosition && !isOutside) || (!opposedPosition && isOutside)) ?\n            (rect.x - axis.multiLevelLabelHeight - startX - padding) : (rect.x + startX);\n        this.createClipRect(clipX + scrollBarHeight, rect.y - axis.majorTickLines.width, rect.height + 2 * axis.majorTickLines.width, axis.multiLevelLabelHeight + padding, this.chart.element.id + '_YAxis_Clippath_' + index, this.chart.element.id\n            + 'YAxisMultiLevelLabel' + index);\n        axis.multiLevelLabels.map(function (multiLevel, level) {\n            _this.labelElement = _this.chart.renderer.createGroup({ id: _this.chart.element.id + index + '_MultiLevelLabel' + level });\n            pointIndex = 0;\n            multiLevel.categories.map(function (categoryLabel, i) {\n                path = '';\n                end = typeof categoryLabel.end === 'string' ? Number(new Date(categoryLabel.end)) : categoryLabel.end;\n                start = typeof categoryLabel.start === 'string' ? Number(new Date(categoryLabel.start)) : categoryLabel.start;\n                startY = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valueToCoefficient)((start), axis) * (rect.height);\n                endY = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.valueToCoefficient)((end), axis) * (rect.height);\n                endY = isInversed ? [startY, startY = endY][0] : endY;\n                var labelFontStyle = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)('properties', multiLevel.textStyle), null, true));\n                argsData = _this.triggerMultiLabelRender(axis, categoryLabel.text, labelFontStyle, multiLevel.alignment, categoryLabel.customAttributes);\n                if (!argsData.cancel) {\n                    var maximumWidth = ((categoryLabel.maximumTextWidth === null ?\n                        (_this.yAxisMultiLabelHeight[level] / 2) : categoryLabel.maximumTextWidth / 2));\n                    labelSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)(argsData.text, argsData.textStyle, _this.chart.themeStyle.axisLabelFont);\n                    gap = endY - startY;\n                    x = rect.x - startX - _this.yAxisPrevHeight[level] -\n                        (maximumWidth) - padding / 2;\n                    y = rect.height + rect.y - startY - (gap / 2);\n                    if (opposedPosition) {\n                        x = isOutside ? rect.x + startX + padding / 2 + (maximumWidth) +\n                            _this.yAxisPrevHeight[level] + scrollBarHeight : rect.x - startX - (maximumWidth) -\n                            _this.yAxisPrevHeight[level] - padding / 2;\n                    }\n                    else {\n                        x = isOutside ? x + scrollBarHeight : rect.x + startX + padding / 2 + (maximumWidth) +\n                            _this.yAxisPrevHeight[level];\n                    }\n                    if (argsData.alignment === 'Center') {\n                        y += labelSize.height / 4;\n                    }\n                    else if (argsData.alignment === 'Far') {\n                        y += gap / 2 - labelSize.height / 2;\n                    }\n                    else {\n                        y = y - gap / 2 + labelSize.height;\n                    }\n                    x = multiLevel.border.type === 'CurlyBrace' ? (((!opposedPosition && isOutside) ||\n                        (opposedPosition && !isOutside)) ? x - padding : x + padding) : x;\n                    var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.TextOption(_this.chart.element.id + index + '_Axis_MultiLevelLabel_Level_' + level + '_Text_' + i, x, y, anchor, argsData.text);\n                    options.text = (multiLevel.overflow === 'Trim') ?\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textTrim)((categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] :\n                            categoryLabel.maximumTextWidth), argsData.text, argsData.textStyle, _this.chart.enableRtl, _this.chart.themeStyle.axisLabelFont) : options.text;\n                    options.text = (multiLevel.overflow === 'Wrap') ?\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textWrap)(argsData.text, (categoryLabel.maximumTextWidth === null ? _this.yAxisMultiLabelHeight[level] :\n                            categoryLabel.maximumTextWidth), argsData.textStyle, _this.chart.enableRtl, null, null, _this.chart.themeStyle.axisLabelFont) : options.text;\n                    if (typeof options.text !== 'string' && options.text.length > 1) {\n                        options.y -= (padding * options.text.length / 2);\n                    }\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textElement)(_this.chart.renderer, options, argsData.textStyle, argsData.textStyle.color ||\n                        _this.chart.themeStyle.axisLabelFont.color, _this.labelElement, _this.chart.redraw, true, null, null, null, null, null, null, _this.chart.enableCanvas, null, _this.chart.themeStyle.axisLabelFont);\n                    if (multiLevel.border.width > 0 && multiLevel.border.type !== 'WithoutBorder') {\n                        path = _this.renderYAxisLabelBorder(level, gap, axis, endY, startX, startY, labelSize, options, rect, argsData.alignment, path, isOutside, opposedPosition, pointIndex);\n                        if (path !== '') {\n                            _this.createBorderElement(level, index, axis, path, pointIndex);\n                            pointIndex++;\n                        }\n                    }\n                    if (!_this.chart.enableCanvas) {\n                        _this.multiElements.appendChild(_this.labelElement);\n                    }\n                }\n            });\n        });\n        if (!this.chart.enableCanvas) {\n            parent.appendChild(this.multiElements);\n        }\n    };\n    /**\n     * Renders the border for the Y-axis labels.\n     *\n     * @param {number} labelIndex - The index of the label.\n     * @param {number} gap - The gap between labels.\n     * @param {Axis} axis - The Y-axis.\n     * @param {number} endY - The end Y-coordinate.\n     * @param {number} startX - The start X-coordinate.\n     * @param {number} startY - The start Y-coordinate.\n     * @param {Size} labelSize - The size of the label.\n     * @param {TextOption} textOptions - The text options for the label.\n     * @param {Rect} rect - The axis rectangle.\n     * @param {Alignment} alignment - The alignment of the label.\n     * @param {string} path - The path for rendering.\n     * @param {boolean} isOutside - Indicates whether the label is outside.\n     * @param {boolean} opposedPosition - Indicates whether the label position is opposed.\n     * @param {number} categoryIndex - The index of the category.\n     * @returns {string} - The path for rendering the label border.\n     */\n    MultiLevelLabel.prototype.renderYAxisLabelBorder = function (labelIndex, gap, axis, endY, startX, startY, labelSize, textOptions, rect, alignment, path, isOutside, opposedPosition, categoryIndex) {\n        var height = endY - startY;\n        var padding = 10;\n        var padding1;\n        var padding2;\n        var groupLabel = axis.multiLevelLabels[labelIndex];\n        var categoryType = groupLabel.categories[categoryIndex].type;\n        var y = rect.y + rect.height - endY;\n        var scrollBarHeight = isOutside && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt) ? axis.scrollBarHeight : 0;\n        scrollBarHeight = scrollBarHeight * (opposedPosition ? 1 : -1);\n        var width = (groupLabel.categories[categoryIndex].maximumTextWidth === null ?\n            this.yAxisMultiLabelHeight[labelIndex] :\n            (groupLabel.categories[categoryIndex].maximumTextWidth)) + padding;\n        var x = (((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? rect.x - startX -\n            this.yAxisPrevHeight[labelIndex] : rect.x + startX + this.yAxisPrevHeight[labelIndex]) + scrollBarHeight;\n        var borderType = categoryType ? categoryType : groupLabel.border.type;\n        switch (borderType) {\n            case 'WithoutTopandBottomBorder':\n            case 'Rectangle':\n            case 'WithoutTopBorder':\n                width = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? -width : width;\n                path += 'M ' + x + ' ' + y + ' L ' + (x + width) + ' ' + y +\n                    ' M ' + x + ' ' + (y + height) + ' L ' + (x + width) + ' ' + (y + height);\n                path += (borderType !== 'WithoutTopandBottomBorder') ? (' L' + ' ' + (x + width) + ' ' + y + ' ') : ' ';\n                path += (borderType === 'Rectangle') ? ('M ' + (x) + ' ' + (y + height) + 'L' + ' ' + (x) + ' ' + y + ' ') : ' ';\n                break;\n            case 'Brace':\n                width = ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) ? width : -width;\n                path += 'M ' + (x) + ' ' + y + ' L ' + (x - width / 2) + ' ' + y + ' L ' + (x - width / 2) + ' ' +\n                    (textOptions.y - labelSize.height / 2 - 4) + ' M ' + (x - width / 2) + ' ' +\n                    (textOptions.y + labelSize.height / 4 + 2) +\n                    ' L ' + (x - width / 2) + ' ' + (y + height) + ' L ' + (x) + ' ' + (y + height);\n                break;\n            case 'CurlyBrace':\n                if ((!opposedPosition && isOutside) || (opposedPosition && !isOutside)) {\n                    padding = -10;\n                    padding1 = -15;\n                    padding2 = -5;\n                }\n                else {\n                    padding = 10;\n                    padding1 = 15;\n                    padding2 = 5;\n                }\n                if (alignment === 'Center') {\n                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10)\n                        + ' L ' + (x + padding) + ' ' + (y + (height - 10) / 2) + ' L ' + (x + padding1) + ' ' + (y + (height - 10) / 2 + 5)\n                        + ' L ' + (x + padding) + ' ' + (y + (height - 10) / 2 + 10) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) +\n                        ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding2) + ' ' + (y + height) + ' '\n                        + x + ' ' + (y + height);\n                }\n                else if (alignment === 'Far') {\n                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10)\n                        + ' L ' + (x + padding) + ' ' + (y + height - 20) + ' ' + ' L ' + (x + padding1) + ' ' + (y + (height - 15)) +\n                        ' L ' + (x + padding) + ' ' + (y + (height - 10)) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) +\n                        ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding) + ' ' + (y + height) + ' ' + x + ' '\n                        + (y + height);\n                }\n                else {\n                    path += 'M ' + x + ' ' + y + ' C ' + x + ' ' + y + ' ' + (x + padding) + ' ' + y + ' ' + (x + padding) + ' ' + (y + 10)\n                        + ' L ' + (x + padding1) + ' ' + (y + 15) +\n                        ' L ' + (x + padding) + ' ' + (y + 20) + ' L ' + (x + padding) + ' ' + (y + (height - 10)) +\n                        ' C ' + (x + padding) + ' ' + (y + (height - 10)) + ' ' + (x + padding2) + ' ' + (y + height) + ' ' + x +\n                        ' ' + (y + height);\n                }\n                break;\n        }\n        return path;\n    };\n    /**\n     * create cliprect\n     *\n     * @returns {void}\n     * @private\n     */\n    MultiLevelLabel.prototype.createClipRect = function (x, y, height, width, clipId, axisId) {\n        this.multiElements = this.chart.renderer.createGroup({\n            'id': axisId,\n            'clip-path': 'url(#' + clipId + ')'\n        });\n        if (!this.chart.enableCanvas) {\n            this.multiElements.appendChild((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendClipElement)(this.chart.redraw, {\n                'id': clipId,\n                'x': x,\n                'y': y,\n                'width': width,\n                'height': height,\n                'fill': 'white',\n                'stroke-width': 1, 'stroke': 'Gray'\n            }, this.chart.renderer));\n        }\n    };\n    /**\n     * create borer element\n     *\n     * @returns {void}\n     * @private\n     */\n    MultiLevelLabel.prototype.createBorderElement = function (borderIndex, axisIndex, axis, path, pointIndex) {\n        var direction = path;\n        var borderElement = this.chart.renderer.drawPath(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.chart.element.id + axisIndex + '_Axis_MultiLevelLabel_Rect_' + borderIndex + '_' + pointIndex, 'Transparent', axis.multiLevelLabels[borderIndex].border.width, axis.multiLevelLabels[borderIndex].border.color || this.chart.themeStyle.axisLine, 1, '', path));\n        borderElement.style.pointerEvents = 'none';\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(this.chart.enableCanvas, this.labelElement, borderElement, this.chart.redraw, true, 'x', 'y', null, direction);\n    };\n    /**\n     * Triggers the event.\n     *\n     * @returns {void}\n     * @private\n     */\n    MultiLevelLabel.prototype.triggerMultiLabelRender = function (axis, text, textStyle, textAlignment, customAttributes) {\n        var argsData = {\n            cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_3__.axisMultiLabelRender, axis: axis,\n            text: text, textStyle: textStyle, alignment: textAlignment, customAttributes: customAttributes\n        };\n        this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_3__.axisMultiLabelRender, argsData);\n        return argsData;\n    };\n    /**\n     * Handles the click event for multi-level labels.\n     *\n     * @private\n     * @param {string} labelIndex - The index of the clicked label.\n     * @param {number} axisIndex - The index of the axis.\n     * @returns {IMultiLevelLabelClickEventArgs} - The event arguments for multi-level label click.\n     */\n    MultiLevelLabel.prototype.MultiLevelLabelClick = function (labelIndex, axisIndex) {\n        var level = parseInt(labelIndex.substr(0, 1), 10);\n        var textElement = parseInt(labelIndex.substr(7), 10);\n        var chart = this.chart;\n        var axis = chart.axisCollections[axisIndex];\n        var categories = axis.multiLevelLabels[level].categories;\n        var text = categories[textElement].text;\n        var start = categories[textElement].start;\n        var end = categories[textElement].end;\n        var customAttributes = categories[textElement].customAttributes;\n        var multilevelclickArgs = {\n            axis: axis, level: level, text: text, customAttributes: customAttributes,\n            start: start, end: end, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_3__.multiLevelLabelClick, cancel: false\n        };\n        this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_3__.multiLevelLabelClick, multilevelclickArgs);\n        return multilevelclickArgs;\n    };\n    /**\n     * To click the multi level label\n     *\n     * @param {Event} event - The click event.\n     * @returns {void}\n     * @private\n     */\n    MultiLevelLabel.prototype.click = function (event) {\n        var targetId = event.target.id;\n        var multiLevelID = '_Axis_MultiLevelLabel_Level_';\n        var textId;\n        var elementId;\n        var axisIndex;\n        if (this.chart.enableCanvas) {\n            for (var i = 0; i < this.multiLevelLabelRectXRegion.length; i++) {\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(event['x'], event['y'], this.multiLevelLabelRectXRegion[i], this.multiLevelLabelRectXRegion[i].width, this.multiLevelLabelRectXRegion[i].height)) {\n                    targetId = this.xLabelCollection[i].id;\n                }\n            }\n        }\n        if (targetId.indexOf(multiLevelID) > -1) {\n            textId = targetId.split(multiLevelID)[1];\n            elementId = targetId.split(multiLevelID)[0];\n            axisIndex = parseInt(elementId.charAt(elementId.length - 1), 10);\n            this.MultiLevelLabelClick(textId, axisIndex);\n        }\n    };\n    /**\n     * To get the module name for `MultiLevelLabel`.\n     *\n     * @private\n     * @returns {string} - Returns the module name.\n     */\n    MultiLevelLabel.prototype.getModuleName = function () {\n        return 'MultiLevelLabel';\n    };\n    /**\n     * To destroy the `MultiLevelLabel` module.\n     *\n     * @private\n     * @returns {void}\n     */\n    MultiLevelLabel.prototype.destroy = function () {\n        // destroy peform here\n    };\n    return MultiLevelLabel;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/axis/multi-level-labels.js?");

/***/ })

}]);