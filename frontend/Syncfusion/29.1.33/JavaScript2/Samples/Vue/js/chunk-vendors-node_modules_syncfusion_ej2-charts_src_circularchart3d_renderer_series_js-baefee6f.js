"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_circularchart3d_renderer_series_js-baefee6f"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/series.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/series.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircularChart3DEmptyPointSettings: () => (/* binding */ CircularChart3DEmptyPointSettings),\n/* harmony export */   CircularChart3DPoints: () => (/* binding */ CircularChart3DPoints),\n/* harmony export */   CircularChart3DSeries: () => (/* binding */ CircularChart3DSeries),\n/* harmony export */   PieSeries3D: () => (/* binding */ PieSeries3D)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_model_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/model/base */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/base.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _model_theme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../model/theme */ \"./node_modules/@syncfusion/ej2-charts/src/circularchart3d/model/theme.js\");\n/* harmony import */ var _dataLabel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataLabel */ \"./node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/dataLabel.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Circular 3D chart series.\n */\n\n\n\n\n\n\n\n\n/**\n * Model representing data points for the circular 3D series.\n *\n * @public\n */\nvar CircularChart3DPoints = /** @class */ (function () {\n    function CircularChart3DPoints() {\n        /**Circular 3D point visibility. */\n        this.visible = true;\n        /** @private */\n        this.isExplode = false;\n        /** @private  */\n        this.argsData = null;\n    }\n    return CircularChart3DPoints;\n}());\n\n/**\n * Configures settings for empty points in the circular 3D series.\n */\nvar CircularChart3DEmptyPointSettings = /** @class */ (function (_super) {\n    __extends(CircularChart3DEmptyPointSettings, _super);\n    function CircularChart3DEmptyPointSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DEmptyPointSettings.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Gap')\n    ], CircularChart3DEmptyPointSettings.prototype, \"mode\", void 0);\n    return CircularChart3DEmptyPointSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n *  Configures the series in a circular 3D chart.\n */\nvar CircularChart3DSeries = /** @class */ (function (_super) {\n    __extends(CircularChart3DSeries, _super);\n    function CircularChart3DSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** @private */\n        _this.points = [];\n        /** @private */\n        _this.sumOfPoints = 0;\n        /** @private */\n        _this.isRectSeries = true;\n        /** @private */\n        _this.clipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(0, 0, 0, 0);\n        /** @private */\n        _this.category = 'Series';\n        /** @private */\n        _this.rightSidePoints = [];\n        /** @private */\n        _this.leftSidePoints = [];\n        /** @private */\n        _this.segments = [];\n        /** @private */\n        _this.isExploded = false;\n        return _this;\n    }\n    /**\n     * Refreshes the DataManager for the circular 3D series.\n     *\n     * @private\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @param {boolean} render - A boolean value indicating whether rendering is required.\n     * @returns {void}\n     */\n    CircularChart3DSeries.prototype.refreshDataManager = function (chart, render) {\n        var _this = this;\n        var dateSource = this.dataSource || chart.dataSource;\n        if (!(dateSource instanceof _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.DataManager) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.query)) {\n            this.dataManagerSuccess({ result: dateSource, count: dateSource.length }, chart, render);\n            return;\n        }\n        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());\n        dataManager.then(function (e) { return _this.dataManagerSuccess(e, chart); });\n    };\n    /**\n     * Handles the success event when the DataManager fetches data for the circular 3D series.\n     *\n     * @private\n     * @param {Object} dataObject - Specifies the series data object.\n     * @param {Object} dataObject.result - The actual data.\n     * @param {number} dataObject.count - The count of data.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @param {boolean} [render=true] - A boolean value indicating whether rendering is required. Default is true.\n     * @returns {void}\n     */\n    CircularChart3DSeries.prototype.dataManagerSuccess = function (dataObject, chart, render) {\n        if (render === void 0) { render = true; }\n        var argsData = {\n            name: _common_model_constants__WEBPACK_IMPORTED_MODULE_5__.seriesRender, series: this, data: dataObject.result\n        };\n        chart.allowServerDataBinding = false;\n        chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_5__.seriesRender, argsData);\n        this.resultData = dataObject.result !== '' ? dataObject.result : [];\n        if (!render) {\n            this.getPoints(this.resultData, chart);\n        }\n        if ((++chart.seriesCounts === chart.visibleSeries.length && render)) {\n            this.getPoints(this.resultData, chart);\n            chart.refreshChart();\n        }\n    };\n    /**\n     * Retrieves and processes data points for rendering on a circular 3D chart.\n     *\n     * @param {Object} result - An object containing the data points for the chart.\n     * @param {CircularChart3D}chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DSeries.prototype.getPoints = function (result, chart) {\n        var length = Object.keys(result).length;\n        this.sumOfPoints = 0;\n        if (length === 0) {\n            this.points = [];\n            return null;\n        }\n        this.findSumOfPoints(result);\n        this.points = [];\n        var point;\n        var colors = this.palettes.length ? this.palettes : (0,_model_theme__WEBPACK_IMPORTED_MODULE_6__.getCircular3DSeriesColor)(chart.theme);\n        for (var i = 0; i < length; i++) {\n            point = this.setPoints(result, i, chart);\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y)) {\n                point.visible = false;\n            }\n            this.pushPoints(point, colors, chart);\n        }\n    };\n    /**\n     * Sets point index and color for a circular 3D data point.\n     *\n     * @param {CircularChart3DPoints} point - The CircularChart3DPoints object representing the data point.\n     * @param {string[]} colors - An array specifying the point colors.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DSeries.prototype.pushPoints = function (point, colors, chart) {\n        point.index = this.points.length;\n        point.isExplode = this.explodeAll || (point.index === this.explodeIndex);\n        point.color = point.color || colors[point.index % colors.length];\n        var argsData = {\n            cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_5__.pointRender, series: this, point: point,\n            fill: point.color\n        };\n        chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_5__.pointRender, argsData);\n        point.color = argsData.fill;\n        point.visible = !argsData.cancel;\n        this.points.push(point);\n    };\n    /**\n     * Calculates the sum of points in the circular 3D series.\n     *\n     * @param {Object} result - The result object containing data points.\n     * @returns {void}\n     */\n    CircularChart3DSeries.prototype.findSumOfPoints = function (result) {\n        var length = Object.keys(result).length;\n        for (var i = 0; i < length; i++) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(result[i]) &&\n                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(result[i][this.yName]) && !isNaN(result[i][this.yName])) {\n                this.sumOfPoints += Math.abs(result[i][this.yName]);\n            }\n        }\n    };\n    /**\n     * Sets x, y, and text points from the specified data source.\n     *\n     * @param {Object} data - The data source containing information for the point.\n     * @param {number} index - The index specifying the position in the data array.\n     * @param {CircularChart3D} chart - Specifies the circular 3D chart instance.\n     * @returns {CircularChart3DPoints} - Returns the CircularChart3DPoints object representing the data point.\n     */\n    CircularChart3DSeries.prototype.setPoints = function (data, index, chart) {\n        var point = new CircularChart3DPoints();\n        point.x = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.xName, data[index]);\n        point.y = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.yName, data[index]);\n        point.percentage = (+(point.y / this.sumOfPoints * 100).toFixed(2));\n        point.legendImageUrl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.legendImageUrl, data[index]);\n        point.color = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.pointColorMapping, data[index]);\n        point.text = point.originalText = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.dataLabel.name || '', data[index]);\n        point.tooltip = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.tooltipMappingName || '', data[index]);\n        point.sliceRadius = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue)(this.radius ? this.radius : '80%', data[index]);\n        point.sliceRadius = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.sliceRadius) ? '80%' : point.sliceRadius;\n        point.separatorY = chart.intl.formatNumber(point.y, { useGrouping: chart.useGroupingSeparator });\n        this.setEmptyPoint(point, index, data, chart);\n        return point;\n    };\n    /**\n     * Draws the circular 3D series on the chart.\n     *\n     * @param {CircularChart3DSeries} series - The series to be drawn.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @returns {void}\n     * @private\n     */\n    CircularChart3DSeries.prototype.draw = function (series, chart) {\n        var marginRatio = 0.03;\n        var seriesIndex = chart.visibleSeries.indexOf(series);\n        this.calculateSize(chart, series);\n        var seriesRadius = series.radius ? series.radius : (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice && series.dataLabel.position === 'Outside') ? '40%' : '80%';\n        var radius = parseInt(seriesRadius, 10);\n        if (!((seriesRadius.indexOf('%') !== -1 || typeof radius === 'number') && !isNaN(radius))) {\n            this.isRadiusMapped = true;\n        }\n        series.size = this.isRadiusMapped ? 0.8 : parseInt(seriesRadius, 10) / 100;\n        series.coefficient = parseInt(series.innerRadius, 10) / 100;\n        chart.circularRadius[seriesIndex] =\n            (((1 - marginRatio) * Math.min(series.actualWidth / 2 - ((chart.legendSettings.visible && chart.circularChartLegend3DModule && (chart.legendSettings.position === 'Right' ||\n                chart.legendSettings.position === 'Left')) ? chart.circularChartLegend3DModule.legendBounds.width : 0), series.actualHeight / 2)) * series.size);\n        chart.innerRadius[seriesIndex] =\n            series.coefficient * chart.circularRadius[seriesIndex];\n        this.createPolygons(series, chart);\n        if (this.dataLabel.visible) {\n            chart.circularChartDataLabel3DModule.renderDataLabel(series, chart);\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(false, chart.svgObject, chart.groupElement, chart.redraw);\n        var size = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Size(chart.availableSize.width, chart.availableSize.height);\n        chart.graphics.prepareView(0, chart.depth, chart.rotation, chart.tilt, size, chart);\n        chart.graphics.view(chart.svgObject, chart);\n    };\n    /**\n     * Calculates the size of the series based on the chart settings.\n     *\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @param {CircularChart3DSeries} series - The series for which to calculate the size.\n     * @returns {{ centerX: number, centerY: number }} - The calculated center coordinates.\n     */\n    CircularChart3DSeries.prototype.calculateSize = function (chart, series) {\n        var legend = chart.legendSettings;\n        var legXSpace = 0;\n        var legYSpace = 0;\n        var legendPosition = chart.circularChartLegend3DModule ? chart.circularChartLegend3DModule.position : 'Auto';\n        var title = chart.title;\n        var subTitle = chart.subTitle;\n        var titleLocation = chart.titleLocation;\n        var subTitleLocation = chart.subTitleLocation;\n        var titleTextOverflow = chart.titleStyle.textOverflow;\n        var subTitleTextOverflow = chart.subTitleStyle.textOverflow;\n        var titleEnable = (title &&\n            (titleTextOverflow === 'Wrap')) ? true : false;\n        var subTitleEnable = (subTitle &&\n            (subTitleTextOverflow === 'Wrap')) ? true : false;\n        if (legend.visible && chart.circularChartLegend3DModule && legendPosition !== 'Custom') {\n            if (legendPosition === 'Right' || legendPosition === 'Left') {\n                legXSpace = (legendPosition.toLowerCase() === 'right') ?\n                    chart.margin.right : chart.margin.left + chart.circularChartLegend3DModule.legendBounds.width;\n            }\n            else {\n                legYSpace = (legendPosition === 'Top') ? chart.margin.top :\n                    ((legendPosition === 'Bottom') ? chart.margin.bottom + chart.circularChartLegend3DModule.legendBounds.height : 0);\n            }\n        }\n        series.actualWidth = chart.availableSize.width - legXSpace;\n        var centerx = (series.actualWidth * 0.5) + ((legendPosition === 'Left') ? legXSpace : 0);\n        if (titleEnable || subTitleEnable) {\n            var yOffset = titleLocation.size.height + (subTitleEnable ? subTitleLocation.size.height : 0) + legYSpace;\n            series.actualHeight = chart.svgObject.height.baseVal.value - yOffset;\n            var centery = series.actualHeight * 0.5 + (titleLocation.size.height + (subTitleEnable ? subTitleLocation.size.height : 0));\n            return { centerX: centerx, centerY: centery };\n        }\n        else {\n            var yOffset = ((title) ? titleLocation.y : 0) + legYSpace;\n            series.actualHeight = chart.svgObject.height.baseVal.value - yOffset;\n            var centery = series.actualHeight * 0.5 + ((legendPosition === 'Top') ?\n                yOffset : ((title) ? (titleLocation.y) : 0));\n            return { centerX: centerx, centerY: centery };\n        }\n    };\n    /**\n     * Creates polygons for a 3D circular chart series.\n     *\n     * @param {CircularChart3DSeries} series - The CircularChart3D series for which to create polygons.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @returns {CircularChart3DPolygon[][]} - The array of created polygons.\n     */\n    CircularChart3DSeries.prototype.createPolygons = function (series, chart) {\n        var segments = [];\n        var polygons = [];\n        var seg;\n        var style;\n        var pointIndex;\n        var polygonCollection = [];\n        if (series.segments.length === 0) {\n            segments = this.createPoints(series, chart);\n        }\n        else {\n            segments = series.segments;\n        }\n        var segmentsLength = segments.length;\n        for (var i = 0; i < segmentsLength; i++) {\n            seg = segments[i];\n            if (seg.visible) {\n                pointIndex = segments[i].pointIndex;\n                style = {\n                    opacity: series.opacity,\n                    interior: series.points[pointIndex].color\n                };\n                polygonCollection = this.createSector(seg, chart, style, series.index);\n                if (polygonCollection !== null) {\n                    for (var k = 0; k < polygonCollection.length; k++) {\n                        if (!polygons[k]) {\n                            polygons[k] = [];\n                        }\n                        if (polygonCollection[k] !== null) {\n                            for (var j = 0; j < polygonCollection[k].length; j++) {\n                                polygons[k].push(polygonCollection[k][j]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < polygons.length; i++) {\n            for (var k = 0; k < polygons[i].length; k++) {\n                var polygone = (polygons[i][k]);\n                chart.circular3DPolygon.push(polygone);\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates sectors for a circular 3D chart based on the specified parameters.\n     *\n     * @param {CircularChart3DSegments} segment - The CircularChart3DSegments instance defining the segment.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @param {CircularChart3DSeriesStyle} style - The CircularChart3DSeriesStyle defining the style of the sectors.\n     * @param {number} seriesIndex - The index of the series to which the sectors belong.\n     * @returns {CircularChart3DPolygon[][]} - An array of CircularChart3DPolygon arrays representing the created sectors.\n     */\n    CircularChart3DSeries.prototype.createSector = function (segment, chart, style, seriesIndex) {\n        var count = Math.ceil(segment.actualEndValue / 6);\n        var degreesToRadians = Math.PI / 180;\n        var index = 0;\n        var depth = chart.depth;\n        if (count < 1) {\n            return null;\n        }\n        var polygonCollection = [];\n        var endValue = segment.actualEndValue / count;\n        var outputPoints = [];\n        var inputPoints = [];\n        for (var i = 0; i < count + 1; i++) {\n            var ox = segment.center.x + segment.radius * Math.cos((segment.actualStartValue + i * endValue) * degreesToRadians);\n            var oy = segment.center.y + segment.radius * Math.sin((segment.actualStartValue + i * endValue) * degreesToRadians);\n            outputPoints[i] = { x: ox, y: oy };\n            var ix = segment.center.x +\n                segment.inSideRadius * Math.cos((segment.actualStartValue + i * endValue) * degreesToRadians);\n            var iy = segment.center.y +\n                segment.inSideRadius * Math.sin((segment.actualStartValue + i * endValue) * degreesToRadians);\n            inputPoints[i] = { x: ix, y: iy };\n        }\n        var originPolygon = [];\n        var vts = [];\n        for (var i = 0; i < count; i++) {\n            vts = [\n                this.vector(outputPoints[i].x, outputPoints[i].y, 0),\n                this.vector(outputPoints[i].x, outputPoints[i].y, depth),\n                this.vector(outputPoints[i + 1].x, outputPoints[i + 1].y, depth),\n                this.vector(outputPoints[i + 1].x, outputPoints[i + 1].y, 0)\n            ];\n            originPolygon[i] = chart.polygon.polygon3D(vts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText);\n            index++;\n        }\n        polygonCollection[1] = originPolygon;\n        if (segment.inSideRadius > 0) {\n            var iPlgs = [];\n            for (var i = 0; i < count; i++) {\n                vts = [\n                    this.vector(inputPoints[i].x, inputPoints[i].y, 0),\n                    this.vector(inputPoints[i].x, inputPoints[i].y, depth),\n                    this.vector(inputPoints[i + 1].x, inputPoints[i + 1].y, depth),\n                    this.vector(inputPoints[i + 1].x, inputPoints[i + 1].y, 0)\n                ];\n                iPlgs[i] = chart.polygon.polygon3D(vts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText);\n                index++;\n            }\n            polygonCollection[3] = iPlgs;\n        }\n        var tVtxs = [];\n        var bVtxs = [];\n        for (var i = 0; i < count + 1; i++) {\n            tVtxs.push(this.vector(outputPoints[i].x, outputPoints[i].y, 0));\n            bVtxs.push(this.vector(outputPoints[i].x, outputPoints[i].y, depth));\n        }\n        if (segment.inSideRadius > 0) {\n            for (var i = count; i > -1; i--) {\n                tVtxs.push(this.vector(inputPoints[i].x, inputPoints[i].y, 0));\n                bVtxs.push(this.vector(inputPoints[i].x, inputPoints[i].y, depth));\n            }\n        }\n        else {\n            tVtxs.push(segment.center);\n            bVtxs.push(this.vector(segment.center.x, segment.center.y, depth));\n        }\n        polygonCollection[0] = [];\n        polygonCollection[0].push(chart.polygon.polygon3D(tVtxs, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText));\n        index++;\n        polygonCollection[0].push(chart.polygon.polygon3D(bVtxs, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText));\n        index++;\n        if (segment.inSideRadius > 0) {\n            var rvts = [\n                this.vector(outputPoints[0].x, outputPoints[0].y, 0),\n                this.vector(outputPoints[0].x, outputPoints[0].y, depth),\n                this.vector(inputPoints[0].x, inputPoints[0].y, depth),\n                this.vector(inputPoints[0].x, inputPoints[0].y, 0)\n            ];\n            var lvts = [\n                this.vector(outputPoints[count].x, outputPoints[count].y, 0),\n                this.vector(outputPoints[count].x, outputPoints[count].y, depth),\n                this.vector(inputPoints[count].x, inputPoints[count].y, depth),\n                this.vector(inputPoints[count].x, inputPoints[count].y, 0)\n            ];\n            polygonCollection[2] = [];\n            polygonCollection[2].push(chart.polygon.polygon3D(rvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText));\n            index++;\n            polygonCollection[2].push(chart.polygon.polygon3D(lvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText));\n            index++;\n        }\n        else {\n            var rvts = [\n                this.vector(outputPoints[0].x, outputPoints[0].y, 0),\n                this.vector(outputPoints[0].x, outputPoints[0].y, depth),\n                this.vector(segment.center.x, segment.center.y, depth),\n                this.vector(segment.center.x, segment.center.y, 0)\n            ];\n            var lvts = [\n                this.vector(outputPoints[count].x, outputPoints[count].y, 0),\n                this.vector(outputPoints[count].x, outputPoints[count].y, depth),\n                this.vector(segment.center.x, segment.center.y, depth),\n                this.vector(segment.center.x, segment.center.y, 0)\n            ];\n            polygonCollection[2] = [];\n            polygonCollection[2].push(chart.polygon.polygon3D(rvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText));\n            index++;\n            polygonCollection[2].push(chart.polygon.polygon3D(lvts, null, segment.index, null, null, style.opacity, style.interior, index.toString() + '-region' + '-series-' + seriesIndex + '-point-' + segment.index, chart.groupElement, segment.accessibilityText));\n            index++;\n        }\n        return polygonCollection;\n    };\n    /**\n     * Creates CircularChart3DSegments based on the provided CircularChart3D series and circular 3D chart.\n     *\n     * @param {CircularChart3DSeries} series - The circular 3D series for which to generate points.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @returns {CircularChart3DSegments[]} - An array of CircularChart3DSegments created for the series.\n     */\n    CircularChart3DSeries.prototype.createPoints = function (series, chart) {\n        series.segments = [];\n        var size = this.calculateSize(chart, series);\n        var all = 0;\n        var visiblePoints = series.points;\n        var count = visiblePoints.length;\n        for (var j = 0; j < count; j++) {\n            if (visiblePoints[j].visible && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(visiblePoints[j].y)) {\n                all += visiblePoints[j].y;\n            }\n        }\n        all = all !== 0 ? all : 1;\n        var coefficient = 360 / all;\n        var seriesIndex = series.index;\n        var insideRadius = chart.innerRadius[seriesIndex];\n        var yValues = this.getYValues(series.points);\n        var pieHeight = chart.depth;\n        var center;\n        var arcStartAngle = 0;\n        var arcEndAngle = 0;\n        var current = 0;\n        var pointIndex;\n        var value;\n        var rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(0, 0, 0, 0);\n        var offset = { X: 0, Y: 0 };\n        var segment;\n        var segIndex = 0;\n        var radius = chart.circularRadius[seriesIndex];\n        for (var i = 0; i < count; i++) {\n            if (series.points[i].visible && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(yValues[i])) {\n                pointIndex = series.points[i].index;\n                value = Math.abs(yValues[i]);\n                arcEndAngle = Math.abs(value) * ((Math.PI * 2) / all);\n                rect.x = 0;\n                rect.y = 0;\n                var point = series.points[i];\n                if (series.isRadiusMapped) {\n                    if (series.points[i].sliceRadius.indexOf('%') !== -1) {\n                        point.radius = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(series.points[i].sliceRadius, this.size / 2);\n                    }\n                    else {\n                        point.radius = parseInt(series.points[i].sliceRadius, 10);\n                    }\n                }\n                else {\n                    point.radius = radius;\n                }\n                var accessibilityText = point.x + ':' + point.y + ', ' + series.name;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value)) {\n                    if (series.explode && (series.explodeIndex === point.index ||\n                        !series.isExploded && series.explodeAll)) {\n                        offset.X = Math.cos(2 * Math.PI * (current + value / 2) / all);\n                        offset.Y = Math.sin(2 * Math.PI * (current + value / 2) / all);\n                        rect.x = 0.01 * point.radius * offset.X * (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(series.explodeOffset, 100);\n                        rect.y = 0.01 * point.radius * offset.Y * (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(series.explodeOffset, 100);\n                    }\n                    center = this.vector(rect.x + size.centerX, rect.y + size.centerY, 0);\n                    segment = this.createSegment(center, (coefficient * current), (coefficient * value), pieHeight, point.radius, i, value, insideRadius, pointIndex, series, accessibilityText);\n                    series.segments.push(segment);\n                }\n                this.addPieDataLabel(segIndex, yValues[i], arcStartAngle, arcStartAngle + arcEndAngle, point.radius, this.isChartRotated(chart) ? chart.depth + 5 : 0, center, series.points[i]);\n                segIndex++;\n                arcStartAngle += arcEndAngle;\n                current += value;\n            }\n        }\n        return series.segments;\n    };\n    /**\n     * Adds a data label to a circular 3D chart at the specified position and orientation.\n     *\n     * @param {number} x - The x-coordinate of the data label position.\n     * @param {number} y - The y-coordinate of the data label position.\n     * @param {number} startAngle - The starting angle of the pie slice in degrees.\n     * @param {number} endAngle - The ending angle of the pie slice in degrees.\n     * @param {number} radius - The radius of the pie slice.\n     * @param {number} startDepth - The depth at which the pie slice starts in the 3D space.\n     * @param {CircularChart3DVector} center - The center point of the pie chart in 3D space.\n     * @param {CircularChart3DPoints} point - The specific data point associated with the data label.\n     * @returns {void}\n     */\n    CircularChart3DSeries.prototype.addPieDataLabel = function (x, y, startAngle, endAngle, radius, startDepth, center, point) {\n        var angle = (startAngle + endAngle) / 2;\n        point.symbolLocation = { x: 0, y: 0, radius: 0, angle: 0 };\n        point.symbolLocation.x = x;\n        point.symbolLocation.y = y;\n        point.symbolLocation.radius = radius;\n        point.symbolLocation.angle = angle;\n        point.symbolLocation.center = center;\n        point.startDepth = startDepth;\n    };\n    /**\n     * Checks if the circular 3D chart is rotated.\n     *\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @returns {boolean} - A boolean indicating whether the chart is rotated.\n     */\n    CircularChart3DSeries.prototype.isChartRotated = function (chart) {\n        var actualTiltView = Math.abs(chart.tilt % 360);\n        var actualRotateView = Math.abs(chart.rotation % 360);\n        if ((actualTiltView > 90 && actualTiltView < 270) !== (actualRotateView > 90 && actualRotateView < 270)) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Creates a segment based on the provided parameters.\n     *\n     * @param {CircularChart3DVector} center - The center point of the segment.\n     * @param {number} start - The starting angle of the segment in radians.\n     * @param {number} end - The ending angle of the segment in radians.\n     * @param {number} height - The height of the segment.\n     * @param {number} radius - The radial distance from the center to the segment.\n     * @param {number} index - The index value of the segment.\n     * @param {number} yValue - The y value associated with the segment.\n     * @param {number} insideRadius - The inside radius of the segment.\n     * @param {number} pointIndex - The index of the point associated with the segment.\n     * @param {CircularChart3DSeries} series - The CircularChart3DSeries to which the segment belongs.\n     * @param {string} accessibilityText - The accessibility text of the segment.\n     * @returns {CircularChart3DSegments} - The created segment.\n     */\n    CircularChart3DSeries.prototype.createSegment = function (center, start, end, height, radius, index, yValue, insideRadius, pointIndex, series, accessibilityText) {\n        return {\n            startValue: start,\n            endValue: end,\n            depth: height,\n            radius: radius,\n            index: index,\n            yData: yValue,\n            center: center,\n            inSideRadius: insideRadius,\n            actualEndValue: end,\n            actualStartValue: start,\n            pointIndex: pointIndex,\n            series: series,\n            visible: true,\n            accessibilityText: accessibilityText\n        };\n    };\n    /**\n     * Creates a new Vector3D instance from provided coordinates.\n     *\n     * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n     * @param {number} vy - The y-coordinate.\n     * @param {number} vz - The z-coordinate.\n     * @returns {CircularChart3DVector} - The new Vector3D instance.\n     */\n    CircularChart3DSeries.prototype.vector = function (vx, vy, vz) {\n        return { x: vx, y: vy, z: vz };\n    };\n    /**\n     * Gets the `Y` values from an array of circular 3D series points.\n     *\n     * @param {CircularChart3DPoints[]} points - An array of CircularChart3DPoints.\n     * @returns {number[]} - An array containing the Y values extracted from the CircularChart3DPoints.\n     */\n    CircularChart3DSeries.prototype.getYValues = function (points) {\n        var values = [];\n        var length = points.length;\n        for (var i = 0; i < length; i++) {\n            values.push(points[i].y);\n        }\n        return values;\n    };\n    /**\n     * Updates the total bounds to encompass the maximum area covered by the specified bound and the current total bounds.\n     *\n     * @param {Rect} totalBound - The current total bounds to be updated.\n     * @param {Rect} bound - The new bound to compare and update the total bounds.\n     * @returns {void}\n     * @private\n     */\n    CircularChart3DSeries.prototype.findMaxBounds = function (totalBound, bound) {\n        totalBound.x = bound.x < totalBound.x ? bound.x : totalBound.x;\n        totalBound.y = bound.y < totalBound.y ? bound.y : totalBound.y;\n        totalBound.height = (bound.y + bound.height) > totalBound.height ? (bound.y + bound.height) : totalBound.height;\n        totalBound.width = (bound.x + bound.width) > totalBound.width ? (bound.x + bound.width) : totalBound.width;\n    };\n    /**\n     * Sets the empty point value for null points in the circular 3D chart series.\n     *\n     * @param {CircularChart3DPoints} point - The data point to be checked and modified.\n     * @param {number} index - The index of the data point.\n     * @param {Object} data - The data object containing information about the data point.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @returns {void}\n     */\n    CircularChart3DSeries.prototype.setEmptyPoint = function (point, index, data, chart) {\n        if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y) || isNaN(point.y))) {\n            return null;\n        }\n        point.color = this.emptyPointSettings.fill || point.color;\n        var previous;\n        var next;\n        switch (this.emptyPointSettings.mode) {\n            case 'Zero':\n                point.y = 0;\n                point.visible = true;\n                break;\n            case 'Average':\n                previous = data[index - 1] ? (data[index - 1][this.yName] || 0) : 0;\n                next = data[index + 1] ? (data[index + 1][this.yName] || 0) : 0;\n                point.y = (Math.abs(previous) + Math.abs(next)) / 2;\n                point.separatorY = chart.intl.formatNumber(point.y, { useGrouping: chart.useGroupingSeparator });\n                this.sumOfPoints += point.y;\n                point.visible = true;\n                break;\n            default:\n                point.visible = false;\n                break;\n        }\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], CircularChart3DSeries.prototype, \"dataSource\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], CircularChart3DSeries.prototype, \"query\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], CircularChart3DSeries.prototype, \"xName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], CircularChart3DSeries.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], CircularChart3DSeries.prototype, \"tooltipMappingName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], CircularChart3DSeries.prototype, \"yName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], CircularChart3DSeries.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, _common_model_base__WEBPACK_IMPORTED_MODULE_1__.Animation)\n    ], CircularChart3DSeries.prototype, \"animation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('SeriesType')\n    ], CircularChart3DSeries.prototype, \"legendShape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], CircularChart3DSeries.prototype, \"legendImageUrl\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], CircularChart3DSeries.prototype, \"pointColorMapping\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _dataLabel__WEBPACK_IMPORTED_MODULE_7__.CircularChart3DDataLabelSettings)\n    ], CircularChart3DSeries.prototype, \"dataLabel\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)([])\n    ], CircularChart3DSeries.prototype, \"palettes\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DSeries.prototype, \"radius\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('0')\n    ], CircularChart3DSeries.prototype, \"innerRadius\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], CircularChart3DSeries.prototype, \"enableTooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], CircularChart3DSeries.prototype, \"explode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('30%')\n    ], CircularChart3DSeries.prototype, \"explodeOffset\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], CircularChart3DSeries.prototype, \"explodeAll\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DSeries.prototype, \"explodeIndex\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ mode: 'Drop' }, CircularChart3DEmptyPointSettings)\n    ], CircularChart3DSeries.prototype, \"emptyPointSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], CircularChart3DSeries.prototype, \"opacity\", void 0);\n    return CircularChart3DSeries;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `PieSeries3D` module is used to render circular 3D `Pie` and `Donut` series.\n */\nvar PieSeries3D = /** @class */ (function (_super) {\n    __extends(PieSeries3D, _super);\n    function PieSeries3D() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * To get the module name of the circular 3D chart pie series.\n     *\n     * @returns {string} - Returns the module name of the Pie series.\n     */\n    PieSeries3D.prototype.getModuleName = function () {\n        return 'PieSeries3D';\n    };\n    /**\n     * Destroys the circular 3D chart series.\n     *\n     * @returns {void}\n     * @private\n     */\n    PieSeries3D.prototype.destroy = function () {\n        /**\n         * Calling the destroy method here.\n         */\n    };\n    return PieSeries3D;\n}(CircularChart3DSeries));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/series.js?");

/***/ })

}]);