"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_stacking-l"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-line-series.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-line-series.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StackingLineSeries: () => (/* binding */ StackingLineSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _line_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `StackingLineSeries` module is used to render the stacking line series.\n */\nvar StackingLineSeries = /** @class */ (function (_super) {\n    __extends(StackingLineSeries, _super);\n    function StackingLineSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render the Stacking line series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The x-axis of the chart.\n     * @param {Axis} yAxis - The y-axis of the chart.\n     * @param {boolean} isInverted - Specifies whether the chart is inverted.\n     * @param {boolean} pointAnimate - Specifies whether the point has to be animated or not.\n     * @param {boolean} pointUpdate - Specifies whether the point has to be updated or not.\n     * @returns {void}\n     * @private\n     */\n    StackingLineSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        var polarType = series.chart.chartAreaType === 'PolarRadar';\n        var getCoordinate = polarType ? _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.TransformToVisible : _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint;\n        var direction = '';\n        var visiblePts = this.enableComplexProperty(series);\n        var pointsLength = visiblePts.length;\n        var stackedvalue = series.stackedValues;\n        var pointIndex;\n        var nextPointIndex;\n        var point1;\n        var point2;\n        for (var i = 0; i < pointsLength; i++) {\n            visiblePts[i].regions = [];\n            visiblePts[i].symbolLocations = [];\n            pointIndex = visiblePts[i].index;\n            if (visiblePts[i].visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePts[i - 1], visiblePts[i], visiblePts[i + 1], series)) {\n                point1 = getCoordinate(visiblePts[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series);\n                direction = direction.concat((i ? 'L' : 'M') + ' ' + (point1.x) + ' ' + (point1.y) + ' ');\n                visiblePts[i].symbolLocations.push(getCoordinate(visiblePts[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series));\n                visiblePts[i].regions.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(visiblePts[i].symbolLocations[0].x - series.marker.width, visiblePts[i].symbolLocations[0].y - series.marker.height, 2 * series.marker.width, 2 * series.marker.height));\n            }\n            else {\n                if (series.emptyPointSettings.mode !== 'Drop') {\n                    if (visiblePts[i + 1] && visiblePts[i + 1].visible) {\n                        nextPointIndex = visiblePts[i + 1].index;\n                        point1 = getCoordinate(visiblePts[i + 1].xValue, stackedvalue.endValues[nextPointIndex], xAxis, yAxis, isInverted, series);\n                        direction = direction.concat('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');\n                    }\n                }\n            }\n        }\n        if (series.chart.chartAreaType === 'PolarRadar' && visiblePts.length > 1) {\n            point1 = { 'y': stackedvalue.endValues[0], 'x': series.points[0].xValue };\n            point2 = getCoordinate(point1.x, point1.y, xAxis, yAxis, isInverted, series);\n            direction += ('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');\n        }\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index, 'none', series.width, series.interior, series.opacity, series.dashArray, direction);\n        this[pointAnimate ? 'addPath' : 'appendLinePath'](options, series, '');\n        if (!pointUpdate) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * To animate point for stacking line series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    StackingLineSeries.prototype.updateDirection = function (series, point) {\n        this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n        for (var i = 0; i < point.length; i++) {\n            if (series.marker && series.marker.visible) {\n                series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    StackingLineSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * To destroy the stacking line.\n     *\n     * @returns {void}\n     * @private\n     */\n    StackingLineSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    StackingLineSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'StackingLineSeries';\n    };\n    return StackingLineSeries;\n}(_line_base__WEBPACK_IMPORTED_MODULE_2__.LineBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-line-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-step-area-series.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-step-area-series.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StackingStepAreaSeries: () => (/* binding */ StackingStepAreaSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _line_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `StackingStepAreaSeries` module is used to render the stacking step area series.\n */\nvar StackingStepAreaSeries = /** @class */ (function (_super) {\n    __extends(StackingStepAreaSeries, _super);\n    function StackingStepAreaSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render the Stacking Step Area series.\n     *\n     * @param {Series} stackSeries - The series to be rendered.\n     * @param {Axis} xAxis - The x-axis of the chart.\n     * @param {Axis} yAxis - The y-axis of the chart.\n     * @param {boolean} isInverted - Specifies whether the chart is inverted.\n     * @param {boolean} pointAnimate - Specifies whether the point has to be animated or not.\n     * @param {boolean} pointUpdate - Specifies whether the point has to be updated or not.\n     * @returns {void}\n     * @private\n     */\n    StackingStepAreaSeries.prototype.render = function (stackSeries, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        var currentPointLocation;\n        var secondPoint;\n        var start = null;\n        var direction = '';\n        var borderDirection = '';\n        var stackedvalue = stackSeries.stackedValues;\n        var visiblePoint = this.enableComplexProperty(stackSeries);\n        var origin = Math.max(stackSeries.yAxis.visibleRange.min, stackedvalue.startValues[0]);\n        var pointsLength = visiblePoint.length;\n        var options;\n        var point;\n        var point2;\n        var point3;\n        var xValue;\n        var lineLength;\n        var prevPoint = null;\n        var validIndex;\n        var startPoint = 0;\n        var pointIndex;\n        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n            lineLength = 0.5;\n        }\n        else {\n            lineLength = 0;\n        }\n        for (var i = 0; i < pointsLength; i++) {\n            point = visiblePoint[i];\n            xValue = point.xValue;\n            point.symbolLocations = [];\n            point.regions = [];\n            pointIndex = point.index;\n            if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoint[i - 1], point, visiblePoint[i + 1], stackSeries)) {\n                if (start === null) {\n                    start = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(xValue, 0);\n                    currentPointLocation = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(xValue - lineLength, origin, xAxis, yAxis, isInverted);\n                    direction += ('M' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                    currentPointLocation = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(xValue - lineLength, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n                    direction += ('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                    borderDirection += ('M' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                }\n                if (prevPoint != null) {\n                    currentPointLocation = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n                    secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(prevPoint.xValue, stackedvalue.endValues[prevPoint.index], xAxis, yAxis, isInverted);\n                    direction += (this.GetStepLineDirection(currentPointLocation, secondPoint, stackSeries.step, 'L', stackSeries, false));\n                    borderDirection += (this.GetStepLineDirection(currentPointLocation, secondPoint, stackSeries.step, 'L', stackSeries, true));\n                }\n                else if (stackSeries.emptyPointSettings.mode === 'Gap') {\n                    currentPointLocation = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n                    direction += 'L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ';\n                    borderDirection += 'L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ';\n                }\n                visiblePoint[i].symbolLocations.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(visiblePoint[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted));\n                visiblePoint[i].regions.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(visiblePoint[i].symbolLocations[0].x - stackSeries.marker.width, visiblePoint[i].symbolLocations[0].y - stackSeries.marker.height, 2 * stackSeries.marker.width, 2 * stackSeries.marker.height));\n                prevPoint = point;\n            }\n            // If we set the empty point mode is Gap or next point of the current point is false, we will close the series path.\n            if (visiblePoint[i + 1] && (!visiblePoint[i + 1].visible && start !== null) && stackSeries.emptyPointSettings.mode !== 'Drop') {\n                var previousPointIndex = void 0;\n                for (var j = i; j >= startPoint; j--) {\n                    pointIndex = visiblePoint[j].index;\n                    previousPointIndex = j === 0 ? 0 : visiblePoint[j - 1].index;\n                    currentPointLocation = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n                    if (j !== 0 && (stackedvalue.startValues[pointIndex] <\n                        stackedvalue.startValues[previousPointIndex] ||\n                        stackedvalue.startValues[pointIndex] > stackedvalue.startValues[previousPointIndex])) {\n                        direction = direction.concat('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\n                        secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(visiblePoint[previousPointIndex].xValue, stackedvalue.startValues[previousPointIndex], xAxis, yAxis, isInverted);\n                    }\n                    else {\n                        secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n                    }\n                    if (visiblePoint[previousPointIndex].visible) {\n                        direction = direction.concat(this.GetStepLineDirection(secondPoint, currentPointLocation, this.prevStep, 'L', stackSeries));\n                    }\n                }\n                startPoint = i + 2;\n                start = null;\n                prevPoint = null;\n            }\n        }\n        if (direction !== '') {\n            // For category axis\n            if (pointsLength > 1) {\n                pointIndex = visiblePoint[pointsLength - 1].index;\n                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.endValues[pointIndex] };\n                secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(start.x, start.y, xAxis, yAxis, isInverted);\n                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n                borderDirection += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.startValues[pointIndex] };\n                secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(start.x, start.y, xAxis, yAxis, isInverted);\n                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n            }\n            // To close the stacked step area series path in reverse order\n            for (var j = pointsLength - 1; j >= startPoint; j--) {\n                var index = void 0;\n                if (visiblePoint[j].visible) {\n                    pointIndex = visiblePoint[j].index;\n                    point2 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(visiblePoint[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n                    direction = direction.concat('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');\n                }\n                if (j !== 0 && !visiblePoint[j - 1].visible) {\n                    index = this.getNextVisiblePointIndex(visiblePoint, j);\n                }\n                if (j !== 0) {\n                    validIndex = index ? index : j - 1;\n                    pointIndex = index ? visiblePoint[index].index : visiblePoint[j - 1].index;\n                    point3 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(visiblePoint[validIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n                    if (!(j !== 0 && !visiblePoint[j - 1].visible)) {\n                        direction = direction.concat(this.GetStepLineDirection(point3, point2, this.prevStep, 'L', stackSeries));\n                    }\n                }\n            }\n            this.prevStep = stackSeries.step === 'Right' ? 'Left' : stackSeries.step === 'Left' ? 'Right' : stackSeries.step;\n            options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(stackSeries.chart.element.id + '_Series_' + stackSeries.index, stackSeries.interior, 0, 'transparent', stackSeries.opacity, stackSeries.dashArray, direction);\n            this[pointAnimate ? 'addPath' : 'appendLinePath'](options, stackSeries, '');\n            /**\n             * To draw border for the path directions of area\n             */\n            if (stackSeries.border.width !== 0) {\n                options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(stackSeries.chart.element.id + '_Series_border_' + stackSeries.index, 'transparent', stackSeries.border.width, stackSeries.border.color ? stackSeries.border.color : stackSeries.interior, 1, stackSeries.border.dashArray, borderDirection);\n                this[pointAnimate ? 'addPath' : 'appendLinePath'](options, stackSeries, '');\n            }\n            if (!pointUpdate) {\n                this.renderMarker(stackSeries);\n            }\n        }\n    };\n    /**\n     * To animate point for stacking step area series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    StackingStepAreaSeries.prototype.updateDirection = function (series, point) {\n        for (var i = 0; i < series.xAxis.series.length; i++) {\n            var stackSeries = series.xAxis.series[i];\n            this.render(stackSeries, stackSeries.xAxis, stackSeries.yAxis, stackSeries.chart.requireInvertedAxis, false, true);\n            for (var j = 0; j < point.length; j++) {\n                if (stackSeries.marker && stackSeries.marker.visible) {\n                    stackSeries.chart.markerRender.renderMarker(stackSeries, stackSeries.points[point[j]], stackSeries.points[point[j]].symbolLocations[0], null, true);\n                }\n                if (stackSeries.marker.dataLabel.visible && stackSeries.chart.dataLabelModule) {\n                    stackSeries.chart.dataLabelModule.commonId = stackSeries.chart.element.id + '_Series_' + stackSeries.index + '_Point_';\n                    stackSeries.chart.dataLabelModule.\n                        renderDataLabel(stackSeries, stackSeries.points[point[j]], null, stackSeries.marker.dataLabel);\n                }\n            }\n        }\n    };\n    /**\n     * Adds a area path to equate the start and end paths.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clip rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    StackingStepAreaSeries.prototype.addPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = startPathCommands.length; i < endPathCommands.length; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.splice((Math.floor((startPathCommands.length / 2)) - 1), 0, startPathCommands[Math.floor((startPathCommands.length / 2)) - 1], startPathCommands[Math.floor((startPathCommands.length / 2)) - 1]);\n                        startPathCommands.splice((Math.floor((startPathCommands.length / 2)) + 2), 0, startPathCommands[Math.floor((startPathCommands.length / 2)) + 2], startPathCommands[Math.floor((startPathCommands.length / 2)) + 2], startPathCommands[Math.floor((startPathCommands.length / 2)) + 2]);\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        endPathCommands.splice(2, 0, endPathCommands[2]);\n                        endPathCommands.splice(endPathCommands.length - 3, 0, endPathCommands[endPathCommands.length - 3]);\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    StackingStepAreaSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * To destroy the stacking step area.\n     *\n     * @returns {void}\n     * @private\n     */\n    StackingStepAreaSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    StackingStepAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'StackingStepAreaSeries';\n    };\n    /**\n     * To get the nearest visible point.\n     *\n     * @param {Points[]} points points\n     * @param {number} j index\n     * @returns {number} - Returns the nearest visible point.\n     */\n    StackingStepAreaSeries.prototype.getNextVisiblePointIndex = function (points, j) {\n        var index;\n        for (index = j - 1; index >= 0; index--) {\n            if (!points[index].visible) {\n                continue;\n            }\n            else {\n                return index;\n            }\n        }\n        return 0;\n    };\n    return StackingStepAreaSeries;\n}(_line_base__WEBPACK_IMPORTED_MODULE_2__.LineBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-step-area-series.js?");

/***/ })

}]);