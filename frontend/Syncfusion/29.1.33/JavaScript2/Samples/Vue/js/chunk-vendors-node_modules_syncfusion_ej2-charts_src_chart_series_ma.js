"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_ma"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/marker.js":
/*!************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/marker.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   markerShapes: () => (/* binding */ markerShapes)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _marker_explode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./marker-explode */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/marker-explode.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\nvar markerShapes = ['Circle', 'Triangle', 'Diamond', 'Rectangle', 'Pentagon', 'InvertedTriangle', 'VerticalLine', 'Cross', 'Plus', 'HorizontalLine', 'Star'];\n/**\n * The `Marker` module is used to render markers for line-type series.\n */\nvar Marker = /** @class */ (function (_super) {\n    __extends(Marker, _super);\n    /**\n     * Constructor for the marker module.\n     *\n     * @private\n     */\n    function Marker(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.addEventListener();\n        return _this;\n    }\n    /**\n     * Render the marker for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    Marker.prototype.render = function (series) {\n        var _this = this;\n        var redraw = series.chart.redraw;\n        this.createElement(series, redraw);\n        var _loop_1 = function (point) {\n            if (point.visible && point.symbolLocations && point.symbolLocations.length) {\n                point.symbolLocations.map(function (location, index) {\n                    if (series.marker.shape !== 'None') {\n                        _this.renderMarker(series, point, location, index, redraw);\n                    }\n                });\n            }\n        };\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            _loop_1(point);\n        }\n    };\n    Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\n        var seriesIndex = series.index === undefined ? series.category : series.index;\n        var marker = series.marker;\n        series.marker.shape = series.marker.shape ? series.marker.shape : markerShapes[seriesIndex % 10];\n        var border = {\n            color: marker.border.color,\n            width: marker.border.width\n        };\n        var borderColor = marker.border.color;\n        var previousLocation;\n        var previousPath;\n        var circlePath;\n        var shapeOption;\n        location.x = location.x + marker.offset.x;\n        location.y = location.y - marker.offset.y;\n        var isBoxPlot = series.type === 'BoxAndWhisker';\n        var fill = marker.fill || ((isBoxPlot || series.marker.isFilled) ? point.interior || series.interior : '#ffffff');\n        var markerElement;\n        var parentElement = isBoxPlot && !this.chart.enableCanvas ?\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.findlElement)(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index)\n            : series.symbolElement;\n        border.color = borderColor || series.setPointColor(point, series.interior);\n        var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) || this.chart.pointsAdded ?\n            (point.index + 1) : point.index) + '_Symbol' + (index ? index : '');\n        var argsData = {\n            cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_3__.pointRender, series: series, point: point,\n            fill: point.isEmpty ? (series.emptyPointSettings.fill || fill) : fill,\n            border: {\n                color: series.type === 'BoxAndWhisker' ?\n                    (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(borderColor) && borderColor !== 'transparent') ? borderColor :\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getSaturationColor)(fill, -0.6)\n                    : border.color,\n                width: border.width\n            },\n            height: marker.height, width: marker.width, shape: marker.shape\n        };\n        argsData.border = series.setBorderColor(point, { width: argsData.border.width, color: argsData.border.color });\n        if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_3__.pointRender, argsData);\n            point.color = argsData.fill;\n        }\n        if (!argsData.cancel) {\n            var y = void 0;\n            if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn'\n                || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') {\n                y = index ? point.low : point.high;\n            }\n            else if (isBoxPlot) {\n                y = point.outliers[index];\n            }\n            else {\n                y = point.y;\n            }\n            var markerFill = argsData.point.marker.fill || argsData.fill;\n            var markerBorder = void 0;\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(argsData.point.marker.border)) {\n                markerBorder = {\n                    color: argsData.point.marker.border.color || argsData.border.color,\n                    width: argsData.point.marker.border.width || argsData.border.width\n                };\n            }\n            else {\n                markerBorder = { color: argsData.border.color, width: argsData.border.width };\n            }\n            var markerWidth = argsData.point.marker.width || argsData.width;\n            var markerHeight = argsData.point.marker.height || argsData.height;\n            var markerOpacity = argsData.point.marker.opacity || marker.opacity;\n            var markerShape = argsData.point.marker.shape || argsData.shape;\n            var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\n            shapeOption = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, series.marker.border.dashArray);\n            if ((parentElement !== undefined && parentElement !== null) || this.chart.enableCanvas) {\n                if (redraw && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(shapeOption.id)) {\n                    markerElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(shapeOption.id);\n                    circlePath = markerShape === 'Circle' ? 'c' : '';\n                    previousLocation = {\n                        x: +markerElement.getAttribute(circlePath + 'x'), y: +markerElement.getAttribute(circlePath + 'y')\n                    };\n                    previousPath = markerElement.getAttribute('d');\n                }\n                markerElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.drawSymbol)(location, markerShape, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\n                if (markerElement) {\n                    markerElement.setAttribute('role', 'img');\n                    if (series.category === 'TrendLine' && (shapeOption.id === this.elementId + '_Series_0_Point_0_Symbol')) {\n                        markerElement.setAttribute('tabindex', '0');\n                        markerElement.setAttribute('class', 'e-chart-focused');\n                    }\n                    markerElement.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : (point.x + ': ' + point.y + ', ' + series.name));\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\n                if ((series.removedPointIndex !== null && series.removedPointIndex <= point.index)) {\n                    parentElement.lastChild.id = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' + (index ? index : '');\n                }\n            }\n            point.marker = {\n                border: markerBorder, fill: markerFill, height: markerHeight,\n                visible: true, shape: markerShape, width: markerWidth, imageUrl: imageURL\n            };\n        }\n        else {\n            location = null;\n            point.marker = {\n                visible: false\n            };\n        }\n    };\n    Marker.prototype.createElement = function (series, redraw) {\n        var markerClipRect;\n        var marker = series.marker;\n        // 8 for extend border value 5 for extend size value\n        var explodeValue = marker.border.width + (this.chart.zoomModule &&\n            this.chart.zoomModule.isAxisZoomed(this.chart.axisCollections) ? 0 : 8 + 5);\n        var render = series.chart.svgRenderer;\n        var index = series.index === undefined ? series.category : series.index;\n        var options;\n        var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';\n        if (marker.visible) {\n            var markerHeight = (marker.height + explodeValue) / 2;\n            var markerWidth = (marker.width + explodeValue) / 2;\n            if (series.chart.chartAreaType === 'Cartesian') {\n                options = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                    x: -markerWidth, y: -markerHeight,\n                    width: series.clipRect.width + (markerWidth * 2),\n                    height: series.clipRect.height + markerHeight * 2\n                }, 0, 0, '', series.marker.border.dashArray);\n                markerClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendClipElement)(redraw, options, render);\n            }\n            else {\n                options = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\n                markerClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendClipElement)(redraw, options, render, 'drawCircularClipPath');\n            }\n            options = {\n                'id': this.elementId + 'SymbolGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\n            };\n            series.symbolElement = render.createGroup(options);\n            series.symbolElement.appendChild(markerClipRect);\n            if (this.chart.enableCanvas) {\n                var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\n                element.appendChild(series.symbolElement);\n            }\n        }\n    };\n    Marker.prototype.getRangeLowPoint = function (region, series) {\n        var x = region.x;\n        var y = region.y;\n        if (series.chart.requireInvertedAxis) {\n            y += region.height / 2;\n            x += series.yAxis.isAxisInverse ? region.width : 0;\n        }\n        else {\n            y += series.yAxis.isAxisInverse ? 0 : region.height;\n            x += region.width / 2;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Calculates the distance between two points in a chart.\n     *\n     * @param {ChartLocation} startPoint - The starting point with x and y coordinates.\n     * @param {ChartLocation} endPoint - The ending point with x and y coordinates.\n     * @returns {number} - The distance between the startPoint and endPoint.\n     */\n    Marker.prototype.calculateDistance = function (startPoint, endPoint) {\n        var dx = endPoint.x - startPoint.x;\n        var dy = endPoint.y - startPoint.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n    /**\n     * Perform marker animation for the given series.\n     *\n     * @param {Series} series - The series for which marker animation needs to be performed.\n     * @returns {void}\n     * @private\n     */\n    Marker.prototype.doMarkerAnimation = function (series) {\n        if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' ||\n            series.type === 'HiloOpenClose' || (series.chart.chartAreaType === 'PolarRadar' && (series.drawType === 'Scatter')))) {\n            var markerElements = series.symbolElement.childNodes;\n            var delay = series.animation.delay + (series.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.animationMode === 'Enable' ? 1000 : series.animation.duration);\n            var duration = series.chart.animated ? series.chart.duration : 200;\n            var markerDelay = delay;\n            var pathLength = series.pathElement ? series.pathElement.getTotalLength() : 0;\n            var distances = [];\n            for (var i = 1; (series.type === 'Line' && i < series.points.length); i++) {\n                if (series.points[i - 1].symbolLocations[0] && series.points[i].symbolLocations[0]) {\n                    var distance = this.calculateDistance(series.points[i - 1].symbolLocations[0], series.points[i].symbolLocations[0]);\n                    distances.push(distance);\n                }\n            }\n            var j = 1;\n            var incFactor = (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea' || series.type === 'RangeStepArea') ? 2 : 1;\n            for (var i = 0; i < series.points.length; i++) {\n                if (series.points[i].symbolLocations) {\n                    if (!series.points[i].symbolLocations.length || !markerElements[j]) {\n                        continue;\n                    }\n                    if (series.type === 'Line') {\n                        if (i === 0) {\n                            markerDelay = 0;\n                        }\n                        if (i > 0) {\n                            markerDelay += (distances[i - 1] / pathLength) * delay;\n                            duration = 0;\n                        }\n                    }\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerAnimate)(markerElements[j], markerDelay, duration, series, i, series.points[i].symbolLocations[0], false);\n                    if (incFactor === 2) {\n                        var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerAnimate)(markerElements[j + 1], markerDelay, duration, series, i, lowPoint, false);\n                    }\n                    j += incFactor;\n                }\n            }\n        }\n    };\n    return Marker;\n}(_marker_explode__WEBPACK_IMPORTED_MODULE_4__.MarkerExplode));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/marker.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-area-series.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-area-series.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiColoredAreaSeries: () => (/* binding */ MultiColoredAreaSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _multi_colored_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./multi-colored-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * The `MultiColoredAreaSeries` module is used to render area series with multiple colors.\n */\nvar MultiColoredAreaSeries = /** @class */ (function (_super) {\n    __extends(MultiColoredAreaSeries, _super);\n    function MultiColoredAreaSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render the multi colored area series on the chart.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The X-axis associated with the series.\n     * @param {Axis} yAxis - The Y-axis associated with the series.\n     * @param {boolean} isInverted - Specifies whether the chart is inverted or not.\n     * @param {boolean} pointAnimate - Specifies whether the point has to be animated or not.\n     * @param {boolean} pointUpdate - Specifies whether the point has to be updated or not.\n     * @returns {void}\n     * @private\n     */\n    MultiColoredAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        var _this = this;\n        var firstPoint;\n        var startPoint = null;\n        var direction = '';\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        var options = [];\n        var startRegion;\n        var previous;\n        var rendered;\n        var segments = this.sortSegments(series, series.segments);\n        var emptyPointDirection = '';\n        var visiblePoints = this.enableComplexProperty(series);\n        visiblePoints.map(function (point, i, seriesPoints) {\n            point.symbolLocations = [];\n            point.regions = [];\n            rendered = false;\n            if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(seriesPoints[i - 1], point, seriesPoints[i + 1], series)) {\n                direction += _this.getAreaPathDirection(point.xValue, origin, series, isInverted, _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint, startPoint, 'M');\n                startPoint = startPoint || new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(point.xValue, origin);\n                firstPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.yValue, xAxis, yAxis, isInverted);\n                if (previous && _this.setPointColor(point, previous, series, series.segmentAxis === 'X', segments)) {\n                    rendered = true;\n                    startRegion = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(startPoint.x, origin, xAxis, yAxis, isInverted);\n                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');\n                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (startRegion.y) + ' ');\n                    _this.generatePathOption(options, series, previous, direction, '_Point_' + previous.index);\n                    direction = 'M' + ' ' + (firstPoint.x) + ' ' + (startRegion.y) + ' ' + 'L' + ' ' +\n                        (firstPoint.x) + ' ' + (firstPoint.y) + ' ';\n                }\n                else {\n                    direction += ('L' + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');\n                    _this.setPointColor(point, null, series, series.segmentAxis === 'X', segments);\n                }\n                if (seriesPoints[i + 1] && !seriesPoints[i + 1].visible && series.emptyPointSettings.mode !== 'Drop') {\n                    direction += _this.getAreaEmptyDirection({ 'x': point.xValue, 'y': origin }, startPoint, series, isInverted, _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint);\n                    startPoint = null;\n                }\n                previous = point;\n                _this.storePointLocation(point, series, isInverted, _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint);\n            }\n        });\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(rendered) && !rendered) {\n            direction = series.points.length > 1 ?\n                (direction + this.getAreaPathDirection(previous.xValue, origin, series, isInverted, _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint, null, 'L')) : '';\n            this.generatePathOption(options, series, previous, direction, '');\n        }\n        if (series.border.width !== 0) {\n            emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(direction));\n            this.generateBorderPathOption(options, series, previous, emptyPointDirection, '');\n        }\n        this.applySegmentAxis(series, options, segments, pointAnimate);\n        if (!pointUpdate) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * Generate path options for rendering series elements.\n     *\n     * @param {PathOption[]} options - The array of path options to be updated.\n     * @param {Series} series - The series associated with the path options.\n     * @param {Points} point - The point associated with the path options.\n     * @param {string} direction - The direction of the path options.\n     * @param {string} id - The id associated with the path options.\n     * @returns {void}\n     */\n    MultiColoredAreaSeries.prototype.generatePathOption = function (options, series, point, direction, id) {\n        options.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index + id, series.setPointColor(point, series.interior), 0, 'transparent', series.opacity, series.dashArray, direction));\n    };\n    /**\n     * Generate path options for rendering series border elements.\n     *\n     * @param {PathOption[]} options - The array of path options to be updated.\n     * @param {Series} series - The series associated with the path options.\n     * @param {Points} point - The point associated with the path options.\n     * @param {string} emptyPointDirection - The direction of the empty point.\n     * @param {string} id - The ID associated with the path options.\n     * @returns {void}\n     */\n    MultiColoredAreaSeries.prototype.generateBorderPathOption = function (options, series, point, emptyPointDirection, id) {\n        options.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_border_' + series.index + id, 'transparent', series.border.width, series.border.color ? series.border.color : series.interior, 1, series.border.dashArray, emptyPointDirection));\n    };\n    /**\n     * To animate point for multicolored area series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    MultiColoredAreaSeries.prototype.updateDirection = function (series, point) {\n        this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n        for (var i = 0; i < point.length; i++) {\n            if (series.marker && series.marker.visible) {\n                series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * To destroy the area series.\n     *\n     * @returns {void}\n     * @private\n     */\n    MultiColoredAreaSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    MultiColoredAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'MultiColoredAreaSeries';\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    MultiColoredAreaSeries.prototype.doAnimation = function (series) {\n        this.doLinearAnimation(series, series.animation);\n    };\n    return MultiColoredAreaSeries;\n}(_multi_colored_base__WEBPACK_IMPORTED_MODULE_3__.MultiColoredSeries));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-area-series.js?");

/***/ })

}]);