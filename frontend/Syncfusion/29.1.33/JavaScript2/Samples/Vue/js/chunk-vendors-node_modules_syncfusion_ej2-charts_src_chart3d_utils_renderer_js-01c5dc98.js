"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart3d_utils_renderer_js-01c5dc98"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/renderer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/renderer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AxisRenderer: () => (/* binding */ AxisRenderer),\n/* harmony export */   WallRenderer: () => (/* binding */ WallRenderer)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _chart3dRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chart3dRender */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js\");\n\n\n\n\n/**\n * The WallRenderer class provides methods to update the 3D wall of the chart.\n */\nvar WallRenderer = /** @class */ (function () {\n    function WallRenderer() {\n    }\n    /**\n     * Updates the 3D wall of the chart based on the chart area type.\n     *\n     * @param {Chart3D} chart - The Chart3D instance to update the 3D wall for.\n     * @returns {void}\n     */\n    WallRenderer.prototype.update3DWall = function (chart) {\n        this.updateBackWall(chart);\n        for (var i = 0; i < chart.axisCollections.length; i++) {\n            var axis = chart.axisCollections[i];\n            var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;\n            if (axis.orientation.toLowerCase() === 'vertical') {\n                if (!opposedPosition) {\n                    this.updateLeftWall(chart);\n                }\n                else {\n                    this.updateRightWall(chart);\n                }\n            }\n            else {\n                if (!opposedPosition) {\n                    this.updateBottomWall(chart);\n                }\n                else {\n                    this.updateTopWall(chart);\n                }\n            }\n        }\n    };\n    /**\n     * Updates the top wall of the 3D chart based on the specified chart and axis.\n     *\n     * @param {Chart3D} chart - The Chart3D instance for which the top wall is updated.\n     * @returns {void}\n     */\n    WallRenderer.prototype.updateTopWall = function (chart) {\n        var offset = 0;\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var y = areaBounds.y;\n        if (chart.wallSize < y) {\n            offset = y - chart.wallSize;\n        }\n        else {\n            offset = -(chart.wallSize - y);\n        }\n        var topLeftFrontVector = chart.vector.vector3D(areaBounds.x + areaBounds.width, -chart.depth, y - 0.1);\n        var bottomRightBackVector = chart.vector.vector3D(areaBounds.x, -0.1, offset);\n        var topSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf('Fluent2') > -1 ? 0.3 : chart.theme.indexOf('Bootstrap5') > -1 ? 0.1 : 0.5, false, 'top-wall-brush', chart.chart3D);\n        for (var i = 0; i < topSideWallPlans.length; i++) {\n            chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), topSideWallPlans[i]);\n        }\n    };\n    /**\n     * Updates the right wall of the 3D chart based on the specified chart and axis.\n     *\n     * @param {Chart3D} chart - The Chart3D instance for which the right wall is updated.\n     * @returns {void}\n     */\n    WallRenderer.prototype.updateRightWall = function (chart) {\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var x = areaBounds.x + areaBounds.width;\n        var rightRect = { left: -chart.depth, top: areaBounds.y, bottom: areaBounds.height + areaBounds.y, right: 0 };\n        var topLeftFrontVector = chart.vector.vector3D(rightRect.left, rightRect.top, x + 1.5);\n        var bottomRightBackVector = chart.vector.vector3D(rightRect.right, rightRect.bottom, x + chart.wallSize);\n        var rightSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf('Fluent2') > -1 ? 0.3 : chart.theme.indexOf('Bootstrap5') > -1 ? 0.1 : 0.5, false, 'right-wall-brush', chart.chart3D);\n        for (var i = 0; i < rightSideWallPlans.length; i++) {\n            chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), rightSideWallPlans[i]);\n        }\n    };\n    /**\n     * Updates the back wall of the 3D chart based on the specified chart.\n     *\n     * @param {Chart3D} chart - The Chart3D instance for which the back wall is updated.\n     * @returns {void}\n     */\n    WallRenderer.prototype.updateBackWall = function (chart) {\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var topLeftFrontVector = chart.vector.vector3D(areaBounds.x, areaBounds.y, chart.depth === 0 ? 1.5 : chart.depth + chart.wallSize);\n        var bottomRightBackVector = chart.vector.vector3D((areaBounds.x + areaBounds.width), areaBounds.y + areaBounds.height, chart.depth === 0 ? 1.5 : chart.depth);\n        chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.backWallColor, chart.wallColor || chart.themeStyle.backWallColor, 0, chart.theme.indexOf('Fluent2') > -1 ? 0.3 : chart.theme.indexOf('Bootstrap5') > -1 ? 0.1 : 0.25, false, 'back-wall-brush', chart.chart3D);\n    };\n    /**\n     * Updates the left wall of the 3D chart based on the specified chart.\n     *\n     * @param {Chart3D} chart - The Chart3D instance for which the left wall is updated.\n     * @returns {void}\n     */\n    WallRenderer.prototype.updateLeftWall = function (chart) {\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var leftRect = { left: -chart.depth, top: areaBounds.y, bottom: areaBounds.height + areaBounds.y, right: 0 };\n        var offset = areaBounds.x;\n        var topLeftFrontVector = chart.vector.vector3D(leftRect.left, leftRect.top, offset - 0.1);\n        var bottomRightBackVector = chart.vector.vector3D(leftRect.right, leftRect.bottom, offset - chart.wallSize);\n        var leftSideWallPlans = chart.polygon.createBox(topLeftFrontVector, bottomRightBackVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf('Fluent2') > -1 ? 0.3 : chart.theme.indexOf('Bootstrap5') > -1 ? 0.1 : 0.5, false, 'left-wall-brush', chart.chart3D);\n        for (var i = 0; i < leftSideWallPlans.length; i++) {\n            chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), leftSideWallPlans[i]);\n        }\n    };\n    /**\n     * Updates the bottom wall of the 3D chart based on the specified chart.\n     *\n     * @param {Chart3D} chart - The Chart3D instance for which the bottom wall is updated.\n     * @returns {void}\n     */\n    WallRenderer.prototype.updateBottomWall = function (chart) {\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var y = areaBounds.y + areaBounds.height;\n        var topLeftFrontVector = chart.vector.vector3D((areaBounds.x + areaBounds.width), -chart.depth, chart.wallSize + y);\n        var bottomRightBackVector = chart.vector.vector3D(areaBounds.x, -0.1, y + 1);\n        var bottomSideWallPlans = chart.polygon.createBox(bottomRightBackVector, topLeftFrontVector, chart, 0, chart.wallColor || chart.themeStyle.leftWallColor, chart.wallColor || chart.themeStyle.leftWallColor, 0, chart.theme.indexOf('Fluent2') > -1 ? 0.3 : chart.theme.indexOf('Bootstrap5') > -1 ? 0.1 : 0.5, false, 'bottom-wall-brush', chart.chart3D);\n        for (var i = 0; i < bottomSideWallPlans.length; i++) {\n            chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), bottomSideWallPlans[i]);\n        }\n    };\n    return WallRenderer;\n}());\n\n/**\n * 3D chart axis render/\n */\nvar AxisRenderer = /** @class */ (function () {\n    function AxisRenderer() {\n    }\n    /**\n     * Draws the 3D axes at the specified index for the given axis and chart.\n     *\n     * @param {number} index - The index of the axis.\n     * @param {Chart3DAxis} axis - The Chart3DAxis instance to draw.\n     * @param {Chart3D} chart - The Chart3D instance for which the axes are drawn.\n     * @returns {void}\n     */\n    AxisRenderer.prototype.drawAxes = function (index, axis, chart) {\n        if (axis.majorGridLines.width) {\n            this.drawGridLines3D(axis, chart, index);\n        }\n        if (axis.visible && axis.internalVisibility && axis.majorTickLines.width) {\n            this.renderTicks3D(axis, axis.majorTickLines.height, axis.majorTickLines.width, chart, index);\n        }\n        if (axis.visible && axis.internalVisibility) {\n            this.drawAxisLabel(axis, chart, index);\n            this.drawAxisTitle(axis, chart, index);\n        }\n    };\n    /**\n     * Draws the title for the specified 3D axis on the given chart.\n     *\n     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the title is drawn.\n     * @param {Chart3D} chart - The Chart3D instance on which the title is drawn.\n     * @param {number} index - The index of the axis.\n     * @returns {void}\n     */\n    AxisRenderer.prototype.drawAxisTitle = function (axis, chart, index) {\n        if (axis.title) {\n            var font = {\n                size: axis.titleStyle.size || chart.themeStyle.axisTitleFont.size,\n                fontWeight: axis.titleStyle.fontWeight || chart.themeStyle.axisTitleFont.fontWeight,\n                fontStyle: axis.titleStyle.fontStyle || chart.themeStyle.axisTitleFont.fontStyle,\n                fontFamily: axis.titleStyle.fontFamily || chart.themeStyle.axisTitleFont.fontFamily,\n                color: axis.titleStyle.color,\n                opacity: axis.titleStyle.opacity\n            };\n            var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;\n            var size = { width: chart.availableSize.width, height: chart.availableSize.height };\n            var transform = chart.transform3D.transform3D(size);\n            transform.viewingArea = size;\n            transform.rotation = 0;\n            transform.tilt = 0;\n            transform.depth = 100;\n            transform.perspectiveAngle = 90;\n            chart.transform3D.transform(transform);\n            var orientation_1 = axis.orientation.toLowerCase();\n            var elementSpacing = 10;\n            if (orientation_1 === 'horizontal') {\n                var padding = 0;\n                var titlesize = ((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(axis.title, axis.titleStyle, chart.themeStyle.axisTitleFont).height / 2);\n                if (axis.titleRotation) {\n                    padding = axis.titlePadding + (elementSpacing) + axis.labelPadding + (axis.titleSize.height / 2);\n                }\n                else {\n                    padding = axis.titlePadding + titlesize + axis.labelPadding + elementSpacing;\n                }\n                var xtitleLocation = axis.maxLabelSize.height + padding;\n                var data = {\n                    text: axis.title,\n                    location: {\n                        x: (axis.rect.width) / 2,\n                        y: (xtitleLocation + axis.majorTickLines.height + chart.wallSize)\n                    }\n                };\n                var x1 = data.location.x + axis.rect.x;\n                var y1 = (opposedPosition) ? (axis.rect.y - data.location.y) : (data.location.y + axis.rect.y);\n                var element = { width: 0, height: 0, angle: axis.titleRotation ? axis.titleRotation : 0, label: data, textAnchor: 'middle', tag: 'text', font: font, id: chart.element.id + '-svg-axis-title-' + index, child: chart.chart3D };\n                element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisTitle;\n                element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisTitleFont.fontFamily;\n                chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);\n            }\n            else {\n                var titleSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(axis.title, axis.titleStyle, chart.themeStyle.axisTitleFont);\n                var padding = 0;\n                if (axis.titleRotation) {\n                    padding = axis.labelPadding + axis.titlePadding + axis.titleSize.width / 2;\n                }\n                else {\n                    padding = axis.titlePadding + axis.labelPadding;\n                }\n                var x1 = (opposedPosition) ? axis.rect.x + ((elementSpacing) + axis.maxLabelSize.width +\n                    axis.majorTickLines.height + chart.wallSize + padding) : axis.rect.x - ((elementSpacing) +\n                    axis.maxLabelSize.width + axis.majorTickLines.height + chart.wallSize + padding);\n                var angle = (axis.titleRotation == null ? (opposedPosition ? 90 : -90) : axis.titleRotation) % 360;\n                var data = {\n                    text: axis.title,\n                    location: {\n                        x: titleSize.width / 2,\n                        y: 0\n                    }\n                };\n                var y1 = data.location.y + (axis.rect.y + axis.rect.height) + (((axis.rect.height) / 2) * -1);\n                var element = { width: titleSize.width, height: titleSize.height, angle: angle, label: data, textAnchor: 'middle', tag: 'text', font: font, id: chart.element.id + '-svg-axis-title-' + index, child: chart.chart3D };\n                element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisTitle;\n                element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisTitleFont.fontFamily;\n                chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);\n            }\n        }\n    };\n    /**\n     * Trims the specified text to fit within the maximum width, applying the provided labelStyle and font settings.\n     *\n     * @param {number} maxWidth - The maximum width to fit the text within.\n     * @param {string} text - The text to be trimmed.\n     * @param {Chart3DTextFontModel} labelStyle - The label style settings to be applied.\n     * @param {Chart3DTextFontModel} font - The font settings to be applied.\n     * @returns {string} - The trimmed text.\n     */\n    AxisRenderer.prototype.textTrim = function (maxWidth, text, labelStyle, font) {\n        var textLength = text.length;\n        var trimmedSize;\n        var label;\n        var textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(text, labelStyle, font);\n        if (textSize.width > maxWidth) {\n            for (var k = textLength - 1; k >= 0; --k) {\n                label = text.substring(0, k) + '...';\n                trimmedSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(label, labelStyle, font);\n                if (trimmedSize.width <= maxWidth) {\n                    return label;\n                }\n            }\n            return '';\n        }\n        else {\n            return text;\n        }\n    };\n    /**\n     * Distributes labels into multiple rows based on the specified length, currentX, currentLabel, axis, and font settings.\n     *\n     * @param {number} length - The length of the labels.\n     * @param {number} currentX - The current X-coordinate.\n     * @param {Visible3DLabels} currentLabel - The current label settings.\n     * @param {Chart3DAxis} axis - The Chart3DAxis instance.\n     * @param {Chart3DTextFontModel} font - The font settings to be applied.\n     * @returns {void}\n     */\n    AxisRenderer.prototype.multipleRows = function (length, currentX, currentLabel, axis, font) {\n        var label;\n        var pointX;\n        var labelSize;\n        var store = [];\n        var isMultiRows;\n        for (var i = length - 1; i >= 0; i--) {\n            label = axis.visibleLabels[i];\n            labelSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(label.text, axis.labelStyle, font);\n            pointX = (0,_chart3dRender__WEBPACK_IMPORTED_MODULE_3__.valueToCoefficients)(i, axis) * axis.rect.width + axis.rect.x;\n            isMultiRows = currentX < (pointX + labelSize.width / 2);\n            if (isMultiRows) {\n                label.index = label.index ? label.index : 0;\n                store.push(label.index);\n                currentLabel.index = (currentLabel.index > label.index) ? currentLabel.index : label.index + 1;\n            }\n            else {\n                currentLabel.index = store.indexOf(label.index) > -1 ? currentLabel.index : label.index;\n            }\n        }\n    };\n    /**\n     * Draws the labels for the specified 3D axis on the given chart.\n     *\n     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the labels are drawn.\n     * @param {Chart3D} chart - The Chart3D instance on which the labels are drawn.\n     * @param {number} index - The index of the axis.\n     * @returns {void}\n     */\n    AxisRenderer.prototype.drawAxisLabel = function (axis, chart, index) {\n        var labels = [];\n        var angleValue;\n        var labelsCount = axis.visibleLabels.length;\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;\n        var elementSpacing = axis.angle ? 5 : 10;\n        var y = areaBounds.y + (!opposedPosition && areaBounds.height);\n        var x = areaBounds.x + (opposedPosition && areaBounds.width);\n        for (var i = 0; i < labelsCount; i++) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(axis.visibleLabels[i].text)) {\n                var x1 = 0;\n                var y1 = 0;\n                var pointX = void 0;\n                axis.visibleLabels[i].originalText = axis.visibleLabels[i].text;\n                var textAnchor = void 0;\n                var textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(axis.visibleLabels[i].text, axis.labelStyle, chart.themeStyle.axisLabelFont);\n                var value = (axis.visibleLabels[i].value - axis.visibleRange.min) / axis.visibleRange.delta;\n                value = axis.isInversed || axis.isAxisInverse ? 1 - value : value;\n                value = isNaN(value) ? 0 : value;\n                if (axis.orientation.toLowerCase() === 'horizontal') {\n                    x1 = Math.round(axis.rect.width * value) + areaBounds.x + axis.plotOffset;\n                    y1 = opposedPosition ? (y - chart.wallSize - axis.majorTickLines.height - axis.labelPadding - elementSpacing / 2) :\n                        y + chart.wallSize + axis.majorTickLines.height + elementSpacing + axis.labelPadding;\n                    textAnchor = 'middle';\n                }\n                else {\n                    y1 = Math.round(axis.plotOffset + axis.rect.y + (textSize.height / 4) + (axis.rect.height * (1 - value)));\n                    var padding = 0;\n                    if (axis.labelRotation === 90 || axis.labelRotation === -90 ||\n                        axis.labelRotation === 270 || axis.labelRotation === -270) {\n                        padding = elementSpacing * 2;\n                    }\n                    else {\n                        padding = elementSpacing;\n                    }\n                    x1 = opposedPosition ? (axis.rect.x + axis.majorTickLines.height + padding + axis.labelPadding) :\n                        (x - chart.wallSize - axis.majorTickLines.height - padding + axis.labelPadding);\n                    textAnchor = opposedPosition ? (axis.isRTLEnabled ? 'end' : 'start') : (axis.isRTLEnabled ? 'start' : 'end');\n                }\n                labels.push({ x: x1, y: y1, size: textSize });\n                var maxWidth = axis.rect.width / axis.visibleLabels.length - 5;\n                var label = labels[i];\n                if (((label.x > axis.rect.x && i === 0) ||\n                    (label.x + label.size.width / 2 > axis.rect.x + axis.rect.width && i === axis.visibleLabels.length - 1)) &&\n                    axis.labelIntersectAction !== 'Trim' && axis.labelIntersectAction.indexOf('wrap') < 0) {\n                    if (axis.edgeLabelPlacement === 'Hide') {\n                        continue;\n                    }\n                    else if (axis.edgeLabelPlacement === 'Shift') {\n                        if (i === 0) {\n                            label.x = x1 = axis.rect.x + label.size.width / 2;\n                        }\n                        else if (i === axis.visibleLabels.length - 1) {\n                            label.x = x1 = axis.rect.x + axis.rect.width - label.size.width / 2;\n                        }\n                    }\n                }\n                if (axis.orientation.toLowerCase() === 'horizontal') {\n                    if (axis.labelRotation) {\n                        angleValue = axis.labelRotation;\n                        var rotatedSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.rotateTextSize)(axis.labelStyle, axis.visibleLabels[i].text, angleValue, chart, chart.themeStyle.axisLabelFont);\n                        y1 += rotatedSize.height / 2;\n                    }\n                    else {\n                        if (axis.labelIntersectAction === 'Trim') {\n                            axis.visibleLabels[i].text = this.textTrim(maxWidth, axis.visibleLabels[i].text, axis.labelStyle, chart.themeStyle.axisLabelFont);\n                        }\n                        else if (axis.angle && (axis.labelIntersectAction === 'Rotate45' || axis.labelIntersectAction === 'Rotate90')) {\n                            var rotatedSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.rotateTextSize)(axis.labelStyle, axis.visibleLabels[i].text, axis.angle, chart, chart.themeStyle.axisLabelFont);\n                            y1 += rotatedSize.height / 2;\n                        }\n                        else if (axis.labelIntersectAction === 'MultipleRows') {\n                            pointX = label.x;\n                            pointX -= textSize.width / 2;\n                            this.multipleRows(i, pointX, axis.visibleLabels[i], axis, chart.themeStyle.axisLabelFont);\n                            y1 = axis.visibleLabels[i].index ?\n                                y1 + axis.visibleLabels[i].index * (textSize.height + 5) : y1;\n                        }\n                        else if (axis.labelIntersectAction === 'Hide') {\n                            var isAxisLabelHidden = false;\n                            for (var j = 0; j < i; j++) {\n                                if (labels[j].x + (labels[j].size.width / 2) >=\n                                    labels[i].x - (labels[i].size.width / 2)) {\n                                    isAxisLabelHidden = true;\n                                    break;\n                                }\n                            }\n                            if (isAxisLabelHidden) {\n                                continue;\n                            }\n                        }\n                    }\n                }\n                var font = {\n                    size: axis.visibleLabels[i].labelStyle.size,\n                    fontWeight: axis.visibleLabels[i].labelStyle.fontWeight,\n                    fontStyle: axis.visibleLabels[i].labelStyle.fontStyle,\n                    fontFamily: axis.visibleLabels[i].labelStyle.fontFamily,\n                    color: axis.visibleLabels[i].labelStyle.color,\n                    opacity: axis.visibleLabels[i].labelStyle.opacity\n                };\n                var element = {\n                    width: textSize.width, height: textSize.height, label: axis.visibleLabels[i], textAnchor: textAnchor,\n                    tag: 'text', font: font, id: chart.element.id + '-' + index + '-axis-label-' + i, child: chart.chart3D, angle: axis.angle\n                };\n                element.font.color = element.font.color ? element.font.color : chart.themeStyle.axisLabel;\n                element.font.fontFamily = element.font.fontFamily ? element.font.fontFamily : chart.themeStyle.axisLabelFont.fontFamily;\n                chart.graphics.addVisual(chart.polygon.createTextElement(chart.vector.vector3D(x1, y1, 0), element, 10, 10), chart);\n            }\n        }\n    };\n    /**\n     * Renders the 3D ticks for the specified axis with the given size, width, and on the provided chart.\n     *\n     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the ticks are rendered.\n     * @param {number} size - The size of the ticks.\n     * @param {number} width - The width of the ticks.\n     * @param {Chart3D} chart - The Chart3D instance on which the ticks are rendered.\n     * @param {number} index - The index of the axis.\n     * @returns {void}\n     */\n    AxisRenderer.prototype.renderTicks3D = function (axis, size, width, chart, index) {\n        var labelsCount = axis.visibleLabels.length;\n        var minorTicks;\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? 0.5 : 0;\n        labelsCount += (axis.valueType === 'Category' && labelsCount > 0 && axis.labelPlacement === 'BetweenTicks') ? 1 : 0;\n        var labelValue;\n        for (var i = 0; i < labelsCount; i++) {\n            if (axis.valueType !== 'DateTimeCategory') {\n                labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel :\n                    (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;\n            }\n            else {\n                labelValue = axis.visibleLabels[i].value ? axis.visibleLabels[i].value - ticksbwtLabel\n                    : axis.visibleRange.max;\n            }\n            var x1 = 0;\n            var x2 = 0;\n            var y1 = 0;\n            var y2 = 0;\n            var value = (labelValue - axis.visibleRange.min) / axis.visibleRange.delta;\n            value = axis.isInversed || axis.isAxisInverse ? 1 - value : value;\n            value = isNaN(value) ? 0 : value;\n            if (axis.orientation.toLowerCase() === 'horizontal') {\n                x2 = x1 = (Math.round(axis.rect.width * value)) + areaBounds.x + axis.plotOffset;\n            }\n            else {\n                y1 = y2 = Math.round(axis.plotOffset + (axis.rect.height * (1 - value))) + axis.rect.y;\n            }\n            var position = this.calculatePosition3D(axis, size, width, x1, y1, x2, y2, chart);\n            var line = { width: axis.majorTickLines.width, opacity: 1, stroke: axis.majorTickLines.color || chart.themeStyle.majorTickLine, child: chart.chart3D, tag: 'line', id: '' };\n            line.id = chart.element.id + '-' + index + '-major-tick-lines-' + i;\n            chart.graphics.addVisual(chart.polygon.createLine(line, position.x1, position.y1, position.x2, position.y2, 0), chart);\n            if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {\n                minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);\n                for (var k = 0; k < axis.minorTicksPerInterval; k++) {\n                    value = (0,_chart3dRender__WEBPACK_IMPORTED_MODULE_3__.valueToCoefficients)(axis.visibleLabels[i].value + (minorTicks * (k + 1)), axis);\n                    value = isNaN(value) ? 0 : value;\n                    if (axis.orientation.toLowerCase() === 'horizontal') {\n                        x1 = x2 = Math.round(axis.plotOffset + (areaBounds.width * value) + areaBounds.x);\n                    }\n                    else {\n                        y1 = y2 = Math.round(axis.plotOffset + ((areaBounds.height) * (1 - value))) + axis.rect.y;\n                    }\n                    var position_1 = this.calculatePosition3D(axis, size, width, x1, y1, x2, y2, chart);\n                    var line_1 = { width: axis.minorTickLines.width, opacity: 0.6, stroke: axis.minorTickLines.color || chart.themeStyle.minorTickLine, child: chart.chart3D, tag: 'line', id: '' };\n                    line_1.id = chart.element.id + '-' + index + '-minor-tick-lines-' + i + '-' + k;\n                    chart.graphics.addVisual(chart.polygon.createLine(line_1, position_1.x1, position_1.y1, position_1.x2, position_1.y2, 0), chart);\n                }\n            }\n        }\n    };\n    /**\n     * Calculates the 3D position for ticks on the specified axis with the given tickSize, width, and chart dimensions.\n     *\n     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the tick position is calculated.\n     * @param {number} tickSize - The size of the ticks.\n     * @param {number} width - The width of the ticks.\n     * @param {number} x1 - The X-coordinate of the starting point.\n     * @param {number} y1 - The Y-coordinate of the starting point.\n     * @param {number} x2 - The X-coordinate of the ending point.\n     * @param {number} y2 - The Y-coordinate of the ending point.\n     * @param {Chart3D} chart - The Chart3D instance.\n     * @returns {Chart3DTickPosition} - The calculated 3D tick position.\n     */\n    AxisRenderer.prototype.calculatePosition3D = function (axis, tickSize, width, x1, y1, x2, y2, chart) {\n        var isOpposed = axis.opposedPosition || axis.isAxisOpposedPosition;\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var y = areaBounds.y + (!isOpposed && areaBounds.height);\n        var x = areaBounds.x + (isOpposed && areaBounds.width);\n        if (axis.orientation.toLowerCase() === 'horizontal') {\n            y1 = 0;\n            y2 = isOpposed ? tickSize : y1 + tickSize;\n            var screenPositionTop = isOpposed ? y - chart.wallSize - tickSize : y + chart.wallSize - (tickSize / 2);\n            y1 += screenPositionTop;\n            y2 += screenPositionTop;\n            x1 = x2 = x1;\n        }\n        else {\n            x1 = 0;\n            x2 = isOpposed ? x1 + tickSize : tickSize;\n            var screenPositionLeft = isOpposed ? x + chart.wallSize : (x - chart.wallSize - tickSize);\n            x1 += screenPositionLeft;\n            x2 += screenPositionLeft;\n            y1 = y2 = y1;\n        }\n        return { x1: x1, y1: y1, x2: x2, y2: y2 };\n    };\n    /**\n     * Draws the 3D grid lines for the specified axis on the given chart.\n     *\n     * @param {Chart3DAxis} axis - The Chart3DAxis instance for which the grid lines are drawn.\n     * @param {Chart3D} chart - The Chart3D instance on which the grid lines are drawn.\n     * @param {number} index - The index of the axis.\n     * @returns {void}\n     */\n    AxisRenderer.prototype.drawGridLines3D = function (axis, chart, index) {\n        if (axis == null) {\n            return;\n        }\n        var labelsCount = axis.visibleLabels.length;\n        var minorTicks;\n        var opposedPosition = axis.opposedPosition || axis.isAxisOpposedPosition;\n        var orientation = axis.orientation;\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var labelValue;\n        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? 0.5 : 0;\n        labelsCount += (axis.valueType === 'Category' && labelsCount > 0 && axis.labelPlacement === 'BetweenTicks') ? 1 : 0;\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        if (orientation.toLowerCase() === 'horizontal') {\n            var i = void 0;\n            for (i = 0; i < labelsCount; i++) {\n                if (axis.valueType !== 'DateTimeCategory') {\n                    labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel :\n                        (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;\n                }\n                else {\n                    labelValue = axis.visibleLabels[i].value ? axis.visibleLabels[i].value - ticksbwtLabel\n                        : axis.visibleRange.max;\n                }\n                var value = (0,_chart3dRender__WEBPACK_IMPORTED_MODULE_3__.valueToCoefficients)(labelValue, axis);\n                value = isNaN(value) ? 0 : value;\n                x2 = x1 = (Math.round(axis.rect.width * value)) + areaBounds.x + axis.plotOffset;\n                y1 = areaBounds.y;\n                y2 = areaBounds.y + areaBounds.height;\n                var depth = chart.depth > 2 ? chart.depth - 2 : 1;\n                var bottom = areaBounds.y + (!opposedPosition && areaBounds.height);\n                var line = { opacity: 1, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color || chart.themeStyle.majorGridLine, child: chart.chart3D, tag: 'line', id: '' };\n                line.id = chart.element.id + '-' + index + '-grid-lines-' + i;\n                chart.graphics.addVisual(chart.polygon.createLine(line, x1, y1, x2, y2, depth), chart);\n                var parallelLine = { opacity: line.opacity, width: line.width, stroke: line.stroke, child: line.child, tag: line.tag, id: '' };\n                parallelLine.id = line.id + '-parallel';\n                parallelLine.id = chart.element.id + '-' + index + '-parallel-grid-lines-' + i;\n                var line3D = chart.polygon.createLine(parallelLine, x2, 0, x2, -depth, bottom);\n                // To fold the gridline alone the wall(bottom)\n                chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), line3D);\n                chart.graphics.addVisual(line3D, chart);\n                if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {\n                    minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);\n                    for (var k = 0; k < axis.minorTicksPerInterval; k++) {\n                        value = (0,_chart3dRender__WEBPACK_IMPORTED_MODULE_3__.valueToCoefficients)(axis.visibleLabels[i].value + (minorTicks * (k + 1)), axis);\n                        value = isNaN(value) ? 0 : value;\n                        x2 = x1 = (Math.round(areaBounds.width * value) + areaBounds.x);\n                        y1 = areaBounds.y;\n                        y2 = areaBounds.y + areaBounds.height;\n                        var line_2 = { opacity: 0.6, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color || chart.themeStyle.minorGridLine, child: chart.chart3D, tag: 'line', id: '' };\n                        line_2.id = chart.element.id + '-' + index + '-minor-grid-lines-' + i + '-' + k;\n                        chart.graphics.addVisual(chart.polygon.createLine(line_2, x1, y1, x2, y2, depth), chart);\n                        var parallelLine_1 = { opacity: line_2.opacity, width: line_2.width, stroke: line_2.stroke, child: line_2.child, tag: line_2.tag, id: '' };\n                        parallelLine_1.id = chart.element.id + '-' + index + '-parallel-minor-grid-lines-' + i + '-' + k;\n                        var line3D_1 = chart.polygon.createLine(parallelLine_1, x2, 0, x2, -depth, bottom);\n                        // To fold the gridline alone the wall(bottom)\n                        chart.polygon.transform(chart.matrixObj.tilt(Math.PI / 2), line3D_1);\n                        chart.graphics.addVisual(line3D_1, chart);\n                    }\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < labelsCount; i++) {\n                labelValue = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel :\n                    (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;\n                var value = (labelValue - axis.visibleRange.min) / axis.visibleRange.delta;\n                x1 = areaBounds.x;\n                y1 = Math.round((axis.rect.height) * (1 - value)) + 0.5;\n                y1 += axis.rect.y;\n                x2 = x1 + areaBounds.width;\n                y2 = y1;\n                var depth = chart.depth > 2 ? chart.depth - 2 : 1;\n                var line = { opacity: 1, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color || chart.themeStyle.majorGridLine, axisName: axis.name, child: chart.chart3D, tag: 'line', id: '' };\n                line.id = chart.element.id + '-' + index + '-grid-lines-' + i;\n                chart.graphics.addVisual(chart.polygon.createLine(line, x1, y1, x2, y2, depth), chart);\n                var depthD = areaBounds.x + (opposedPosition && areaBounds.width + 1);\n                var sideLine = { opacity: line.opacity, width: line.width, stroke: line.stroke, child: line.child, tag: line.tag, id: '' };\n                sideLine.id = chart.element.id + '-' + index + '-parallel-grid-lines-' + i;\n                var line3D = chart.polygon.createLine(sideLine, -depth, y2, 0, y2, depthD);\n                // To fold the gridline alone the wall(right of vertical)\n                chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), line3D);\n                chart.graphics.addVisual(line3D, chart);\n                if (axis.minorGridLines.width && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {\n                    minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);\n                    for (var k = 0; k < axis.minorTicksPerInterval; k++) {\n                        var value_1 = (0,_chart3dRender__WEBPACK_IMPORTED_MODULE_3__.valueToCoefficients)(axis.visibleLabels[i].value + (minorTicks * (k + 1)), axis);\n                        x1 = areaBounds.x;\n                        y1 = Math.round((axis.rect.height) * (1 - value_1)) + 0.5;\n                        y1 += axis.rect.y;\n                        x2 = x1 + areaBounds.width;\n                        y2 = y1;\n                        var line_3 = { opacity: 0.6, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color || chart.themeStyle.minorGridLine, axisName: axis.name, child: chart.chart3D, tag: 'line', id: '' };\n                        line_3.id = chart.element.id + '-' + index + '-minor-grid-lines-' + i + '-' + k;\n                        chart.graphics.addVisual(chart.polygon.createLine(line_3, x1, y1, x2, y2, depth), chart);\n                        var sideLine_1 = { opacity: line_3.opacity, width: line_3.width, stroke: line_3.stroke, child: line_3.child, tag: line_3.tag, id: '' };\n                        sideLine_1.id = chart.element.id + '-' + index + '-parallel-minor-grid-lines-' + i + k;\n                        var line3D_2 = chart.polygon.createLine(sideLine_1, -depth, y2, 0, y2, depthD);\n                        // To fold the gridline alone the wall(right of vertical)\n                        chart.polygon.transform(chart.matrixObj.turn(-Math.PI / 2), line3D_2);\n                        chart.graphics.addVisual(line3D_2, chart);\n                    }\n                }\n            }\n        }\n    };\n    return AxisRenderer;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/renderer.js?");

/***/ })

}]);