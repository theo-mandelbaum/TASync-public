"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_connector-editing_js-0e70-f8eeca09"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/connector-editing.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/connector-editing.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectorEditing: () => (/* binding */ ConnectorEditing)\n/* harmony export */ });\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/actions.js\");\n/* harmony import */ var _utility_connector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utility/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js\");\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tool */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/tool.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\n\n/**\n * Multiple segments editing for Connector\n */\nvar ConnectorEditing = /** @class */ (function (_super) {\n    __extends(ConnectorEditing, _super);\n    function ConnectorEditing(commandHandler, endPoint) {\n        var _this = _super.call(this, commandHandler, true) || this;\n        _this.oldValue = null;\n        _this.endPoint = endPoint;\n        return _this;\n    }\n    /**\n     * mouseDown method\\\n     *\n     * @returns {  void }    mouseDown method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @private\n     */\n    ConnectorEditing.prototype.mouseDown = function (args) {\n        var connectors;\n        var edit = true;\n        if (args.source && args.source.connectors) {\n            connectors = args.source.connectors[0];\n        }\n        if (args.info && args.actualObject) {\n            edit = args.info.ctrlKey && args.actualObject.type !== 'Orthogonal';\n        }\n        if (connectors && edit) {\n            this.inAction = true;\n            this.undoElement = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(args.source);\n            _super.prototype.mouseDown.call(this, args);\n            // 927583: Segment points cannot be dragged when the pointer is in the outer part of the segmentThumb\n            var inheritSegmentThumbSize = (connectors.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_4__.ConnectorConstraints.InheritSegmentThumbSize);\n            var segmentThumbSize = inheritSegmentThumbSize ?\n                this.commandHandler.diagram.segmentThumbSize : connectors.segmentThumbSize;\n            var padding = (segmentThumbSize > 20) && connectors.type !== 'Straight' ? segmentThumbSize / 2 : 10;\n            padding = padding / this.commandHandler.diagram.scrollSettings.currentZoom;\n            // Sets the selected segment\n            for (var i = 0; i < connectors.segments.length; i++) {\n                var segment = connectors.segments[parseInt(i.toString(), 10)];\n                if (this.endPoint === 'OrthoThumb') {\n                    for (var j = 0; j < segment.points.length - 1; j++) {\n                        var segPoint = { x: 0, y: 0 };\n                        segPoint.x = ((segment.points[parseInt(j.toString(), 10)].x + segment.points[j + 1].x) / 2);\n                        segPoint.y = ((segment.points[parseInt(j.toString(), 10)].y + segment.points[j + 1].y) / 2);\n                        if ((0,_actions__WEBPACK_IMPORTED_MODULE_5__.contains)(this.currentPosition, segPoint, padding)) {\n                            this.selectedSegment = segment;\n                            this.segmentIndex = j;\n                        }\n                    }\n                }\n                else {\n                    if ((0,_actions__WEBPACK_IMPORTED_MODULE_5__.contains)(this.currentPosition, segment.point, padding)) {\n                        this.selectedSegment = segment;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * mouseMove method\\\n     *\n     * @returns {  void }    mouseMove method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @private\n     */\n    ConnectorEditing.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        this.currentPosition = args.position;\n        if (this.currentPosition && this.prevPosition) {\n            var diffY = this.currentPosition.y - this.prevPosition.y;\n            var diffX = this.currentPosition.x - this.prevPosition.x;\n            this.currentPosition = this.commandHandler.snapConnectorEnd(this.currentPosition);\n            var connector = void 0;\n            var newValue = void 0;\n            var isSame = false;\n            if (args.source && args.source.connectors) {\n                connector = args.source.connectors[0];\n            }\n            if (_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.equals(this.startPosition, this.prevPosition)) {\n                isSame = true;\n            }\n            if (this.oldValue === null) {\n                this.oldValue = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.selectedSegment);\n            }\n            var arg = {\n                source: connector, state: 'Start', oldValue: this.oldValue, newValue: this.oldValue,\n                segment: this.selectedSegment, cancel: false\n            };\n            //EJ2-66217 - Support to add event for segment points editing in connector.\n            arg = {\n                source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(connector), state: 'Start', oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(this.oldValue),\n                newValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(this.oldValue),\n                segment: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(this.selectedSegment), cancel: false\n            };\n            if (isSame && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_9__.isBlazor)()) {\n                this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentChange, arg);\n            }\n            // When cancel is set to true at state Start, the segment change will be prevented.\n            if (arg.cancel) {\n                this.commandHandler.diagram.resetTool();\n            }\n            if ((this.inAction && this.selectedSegment !== undefined && this.endPoint !== undefined)\n                && (diffX !== 0 || diffY !== 0) && !arg.cancel) {\n                if (this.endPoint === 'OrthoThumb') {\n                    this.blocked = !this.dragOrthogonalSegment(connector, this.selectedSegment, this.currentPosition, this.segmentIndex);\n                    if (this.oldValue.length === null && this.oldValue.direction === null) {\n                        this.oldValue = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.selectedSegment);\n                    }\n                    newValue = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.selectedSegment);\n                }\n                else {\n                    var tx = this.currentPosition.x - this.selectedSegment.point.x;\n                    var ty = this.currentPosition.y - this.selectedSegment.point.y;\n                    var index = connector.segments.indexOf(this.selectedSegment);\n                    this.blocked = !this.commandHandler.dragControlPoint(connector, tx, ty, false, index);\n                    newValue = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.selectedSegment);\n                }\n                this.commandHandler.updateSelector();\n                this.currentPosition = args.position;\n                var arg1 = {\n                    source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(connector), state: 'Progress', oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(this.oldValue),\n                    newValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(newValue),\n                    segment: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(this.selectedSegment), cancel: false\n                };\n                this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentChange, arg1);\n            }\n        }\n        this.prevPosition = this.currentPosition;\n        return !this.blocked;\n    };\n    /**\n     * mouseUp method\\\n     *\n     * @returns {  void }    mouseUp method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @private\n     */\n    ConnectorEditing.prototype.mouseUp = function (args) {\n        var connector;\n        var oldValues;\n        if (args.source && args.source.connectors) {\n            connector = args.source.connectors[0];\n            oldValues = { segments: connector.segments };\n        }\n        if (args && args.source && args.info && args.info.ctrlKey && args.info.shiftKey && connector.type === 'Straight') {\n            this.addOrRemoveSegment(connector, this.currentPosition);\n        }\n        else {\n            if (this.endPoint === 'OrthoThumb' && this.selectedSegment) {\n                var index = connector.segments.indexOf(this.selectedSegment);\n                var prev = connector.segments[index - 1];\n                var next = connector.segments[index + 1];\n                if (index === connector.segments.length - 2\n                    && this.updateLastSegment(connector, this.selectedSegment)) {\n                    connector.segments.splice(connector.segments.length - 2, 1);\n                }\n                else {\n                    //Bug 853404: Exception occurs while adjusting the connector segment.\n                    if (prev && Math.abs(prev.length) < 5 && prev.length > 0) {\n                        if (index !== 1) {\n                            this.removePrevSegment(connector, index);\n                        }\n                    }\n                    else if (next) {\n                        var len = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(next.points[0], next.points[1]);\n                        var length_1 = ((next.length || next.length === 0) ? next.length : len);\n                        if ((Math.abs(length_1) <= 5)) {\n                            this.removeNextSegment(connector, index);\n                        }\n                    }\n                }\n                this.commandHandler.updateEndPoint(connector, oldValues);\n                // EJ2-65063 - While mouseUp set the selectedSegmentIndex as zero.\n                connector.selectedSegmentIndex = 0;\n            }\n        }\n        if (this.undoElement) {\n            //let obj: SelectorModel;\n            var obj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(args.source);\n            var entry = {\n                type: 'SegmentChanged', redoObject: obj, undoObject: this.undoElement, category: 'Internal'\n            };\n            this.commandHandler.addHistoryEntry(entry);\n        }\n        if (connector.isBezierEditing) {\n            connector.isBezierEditing = false;\n        }\n        if (this.prevPosition !== this.startPosition) {\n            var arg = {\n                source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(connector), state: 'Completed', oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(this.oldValue),\n                newValue: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.selectedSegment), cancel: false, segment: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(this.selectedSegment)\n            };\n            this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentChange, arg);\n        }\n        _super.prototype.mouseUp.call(this, args);\n    };\n    ConnectorEditing.prototype.removePrevSegment = function (connector, index) {\n        var first = connector.segments[index - 2];\n        var next = connector.segments[index + 1];\n        //Bug 905092: Exception through while dragging segment and reverted back to its original position.\n        //Added next condition to check the next segment is not null.\n        if (next) {\n            var length_2 = (next.length || next.length === 0) ? next.length : _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(next.points[0], next.points[1]);\n            if (!(length_2 <= 5)) {\n                var removeSegments = connector.segments.slice(index - 1, index + 1);\n                var args = {\n                    element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false\n                };\n                //Removed isBlazor code\n                this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args);\n                if (!args.cancel) {\n                    var last = connector.segments[index + 1];\n                    connector.segments.splice(index - 1, 2);\n                    var segment = this.selectedSegment;\n                    if (segment.direction === 'Left' || segment.direction === 'Right') {\n                        first.points[first.points.length - 1].x = last.points[0].x;\n                        last.points[0].y = first.points[first.points.length - 1].y;\n                    }\n                    else {\n                        first.points[first.points.length - 1].y = last.points[0].y;\n                        last.points[0].x = first.points[first.points.length - 1].x;\n                    }\n                    if (segment.length || segment.length === 0) {\n                        this.findSegmentDirection(first);\n                    }\n                    this.findSegmentDirection(last);\n                }\n            }\n        }\n    };\n    ConnectorEditing.prototype.findSegmentDirection = function (segment) {\n        if (segment.direction && (segment.length || segment.length === 0)) {\n            segment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n            segment.direction = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(segment.points[0], segment.points[segment.points.length - 1]);\n        }\n    };\n    ConnectorEditing.prototype.removeNextSegment = function (connector, index) {\n        var segment = this.selectedSegment;\n        var first = connector.segments[index - 1];\n        var last = connector.segments[index + 2];\n        var next = connector.segments[index + 1];\n        // eslint-disable-next-line\n        var removeSegments;\n        var args;\n        if (next.length || next.length === 0) {\n            removeSegments = connector.segments.slice(index, 2);\n            args = {\n                element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false\n            };\n            args = {\n                element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(connector), removeSegments: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(removeSegments),\n                type: 'Removal', cancel: false\n            };\n            //Removed isBlazor code\n            this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args);\n            if (!args.cancel) {\n                connector.segments.splice(index, 2);\n                if (segment.direction === 'Top' || segment.direction === 'Bottom') {\n                    last.points[0].y = segment.points[0].y;\n                    first.points[first.points.length - 1].x = last.points[0].x;\n                }\n                else {\n                    last.points[0].x = segment.points[0].x;\n                    first.points[first.points.length - 1].y = last.points[0].y;\n                }\n            }\n        }\n        else {\n            removeSegments = connector.segments.slice(index + 1, 1);\n            args = {\n                element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false\n            };\n            //Removed isBlazor code\n            this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args);\n            if (!args.cancel) {\n                connector.segments.splice(index + 1, 1);\n                if (segment.direction === 'Top' || segment.direction === 'Bottom') {\n                    first.points[first.points.length - 1].x = next.points[next.points.length - 1].x;\n                }\n                else {\n                    first.points[first.points.length - 1].y = next.points[next.points.length - 1].y;\n                }\n                this.findSegmentDirection(first);\n                segment.length = segment.direction = null;\n            }\n        }\n        if (first && last && !args.cancel) {\n            first.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(first.points[0], last.points[0]);\n            first.direction = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(first.points[0], last.points[0]);\n            if (last.length || last.length === 0) {\n                last.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(first.points[first.points.length - 1], last.points[last.points.length - 1]);\n                var point1 = first.points;\n                var point2 = last.points;\n                last.direction = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(point1[point1.length - 1], point2[point2.length - 1]);\n            }\n        }\n    };\n    /**\n     * addOrRemoveSegment method Used to add or remove intermediate segments to the straight connector. \\\n     *\n     * @returns {void} addOrRemoveSegment method Used to add or remove intermediate segments to the straight connector.\n     * @param {ConnectorModel} connector - provide the connector value in which segment to be added/removed.\n     * @param {PointModel} point - provide the mouse clicked position as a point of the segment\n     * @param {CommandHandler} commandHandler - provide the CommandHandler value that defines the behavior of commands\n     * @private\n     */\n    ConnectorEditing.prototype.addOrRemoveSegment = function (connector, point, commandHandler) {\n        var updateSeg;\n        var segmentIndex;\n        var segmentsChanged = [];\n        var oldValues = { segments: connector.segments };\n        for (var i = 0; i < connector.segments.length; i++) {\n            var segment = (connector.segments)[parseInt(i.toString(), 10)];\n            if ((0,_actions__WEBPACK_IMPORTED_MODULE_5__.contains)(point, segment.point, connector.hitPadding)) {\n                segmentIndex = i;\n                updateSeg = true;\n                //848696-Trigger SegmentCollectionChange Event for straight connector\n                segmentsChanged.push(segment);\n                var args = {\n                    element: connector, removeSegments: segmentsChanged, type: 'Removal', cancel: false\n                };\n                if (commandHandler) {\n                    commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args);\n                }\n            }\n        }\n        //827745-support to edit Segment for Straight connector at runtime\n        if (!this.commandHandler) {\n            this.commandHandler = commandHandler;\n        }\n        if (updateSeg && segmentIndex !== undefined) {\n            if (connector.segments && connector.segments[parseInt(segmentIndex.toString(), 10)] && connector.segments[parseInt(segmentIndex.toString(), 10)].type === 'Straight') {\n                var segment = connector.segments[parseInt(segmentIndex.toString(), 10)];\n                var previous = connector.segments[segmentIndex + 1];\n                if (previous) {\n                    connector.segments.splice(segmentIndex, 1);\n                    previous.points[0] = segment.points[0];\n                }\n            }\n        }\n        else {\n            this.commandHandler.enableServerDataBinding(false);\n            var index = this.findIndex(connector, point);\n            if (connector.segments && connector.segments[parseInt(index.toString(), 10)] && connector.segments[parseInt(index.toString(), 10)].type === 'Straight') {\n                var segment = connector.segments[parseInt(index.toString(), 10)];\n                var newseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.StraightSegment(connector, 'segments', { type: 'Straight', point: point }, true);\n                newseg.points[0] = segment.points[0];\n                newseg.points[1] = point;\n                segment.points[0] = point;\n                connector.segments.splice(index, 0, newseg);\n                updateSeg = true;\n                //848696-Trigger SegmentCollectionchange Event for straight connector\n                segmentsChanged.push(segment);\n                var args = {\n                    element: connector, addSegments: segmentsChanged, type: 'Addition', cancel: false\n                };\n                this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args);\n            }\n            this.commandHandler.enableServerDataBinding(true);\n        }\n        if (updateSeg) {\n            this.commandHandler.updateEndPoint(connector, oldValues);\n        }\n    };\n    ConnectorEditing.prototype.findIndex = function (connector, point) {\n        var intersectingSegs = [];\n        for (var i = 0; i < connector.segments.length; i++) {\n            var segment = connector.segments[parseInt(i.toString(), 10)];\n            var rect = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds([segment.points[0], segment.points[1]]);\n            rect.Inflate(connector.hitPadding);\n            if (rect.containsPoint(point)) {\n                intersectingSegs.push(segment);\n            }\n        }\n        if (intersectingSegs.length === 1) {\n            return connector.segments.indexOf(intersectingSegs[0]);\n        }\n        else {\n            var ratio = void 0;\n            var min = void 0;\n            var index = void 0;\n            var seg = void 0;\n            var v = void 0;\n            var h = void 0;\n            for (var i = 0; i < intersectingSegs.length; i++) {\n                seg = intersectingSegs[parseInt(i.toString(), 10)];\n                v = (point.y - seg.points[0].y) / (seg.points[1].y - point.y);\n                h = (point.x - seg.points[0].x) / (seg.points[1].x - point.x);\n                ratio = Math.abs(v - h);\n                if (i === 0) {\n                    min = ratio;\n                    index = 0;\n                }\n                if (ratio < min) {\n                    min = ratio;\n                    index = i;\n                }\n            }\n            return connector.segments.indexOf(intersectingSegs[parseInt(index.toString(), 10)]);\n        }\n    };\n    ConnectorEditing.prototype.dragOrthogonalSegment = function (obj, segment, point, segmentIndex) {\n        var segmentPoint = { x: 0, y: 0 };\n        var oldValues = { segments: obj.segments };\n        segmentPoint.x = ((segment.points[parseInt(segmentIndex.toString(), 10)].x + segment.points[segmentIndex + 1].x) / 2);\n        segmentPoint.y = ((segment.points[parseInt(segmentIndex.toString(), 10)].y + segment.points[segmentIndex + 1].y) / 2);\n        var ty = point.y - segmentPoint.y;\n        var tx = point.x - segmentPoint.x;\n        var index = obj.segments.indexOf(segment);\n        var update = false;\n        //const orientation: string = (segment.points[0].y.toFixed(2) === segment.points[1].y.toFixed(2)) ? 'horizontal' : 'vertical';\n        //const prevSegment: OrthogonalSegmentModel; const nextSegment: OrthogonalSegmentModel;\n        // EJ2-65063 - If the allowNodeOverlap is set as true means then we set the segment index which is going to drag in selectedSegmentIndex property\n        if (obj.allowNodeOverlap) {\n            obj.selectedSegmentIndex = index ? index : segmentIndex;\n        }\n        if (index !== -1) {\n            if (index === 0 && obj.segments.length === 1 && segment.points.length === 2) {\n                index = this.addSegments(obj, segment, tx, ty, index);\n                update = true;\n            }\n            else if (index === obj.segments.length - 1 && (segment.direction === null || segment.length === null)) {\n                index = this.addTerminalSegment(obj, segment, tx, ty, segmentIndex);\n                update = true;\n            }\n            else if (index === 0) {\n                index = this.insertFirstSegment(obj, segment, tx, ty, index);\n                update = true;\n            }\n            if (index) {\n                if (update) {\n                    this.selectedSegment = segment = obj.segments[parseInt(index.toString(), 10)];\n                    this.segmentIndex = 0;\n                }\n                this.updateAdjacentSegments(obj, index, tx, ty);\n                this.commandHandler.updateEndPoint(obj, oldValues);\n            }\n        }\n        return true;\n    };\n    ConnectorEditing.prototype.addSegments = function (obj, segment, tx, ty, coll) {\n        var index;\n        var segments = []; //let len: number;\n        var length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[0], segment.points[1]);\n        var segmentDirection = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(segment.points[0], segment.points[1]);\n        segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: segmentDirection, length: length / 4 }, true));\n        var direction = (segment.points[0].y === segment.points[1].y) ? ((ty > 0) ? 'Bottom' : 'Top') : ((tx > 0) ? 'Right' : 'Left');\n        var len = (segment.points[0].x === segment.points[1].x) ? ty : tx;\n        segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: direction, length: len }, true));\n        segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: segmentDirection, length: length / 2 }, true));\n        var args = {\n            element: obj, addSegments: segments, type: 'Addition', cancel: false\n        };\n        //Removed isBlazor code\n        this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args);\n        if (!args.cancel) {\n            obj.segments = segments.concat(obj.segments);\n            index = coll + 2;\n        }\n        return index;\n    };\n    // eslint-disable-next-line\n    ConnectorEditing.prototype.insertFirstSegment = function (obj, segment, tx, ty, coll) {\n        var direction;\n        var length;\n        var segments = [];\n        var segValues;\n        var index;\n        var insertseg;\n        if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {\n            var prev = void 0;\n            for (var i = 0; i < segment.points.length - 1; i++) {\n                var len = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);\n                var dir = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);\n                insertseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: dir, length: len }, true);\n                if (insertseg.length === 0) {\n                    if (prev && (prev.direction === 'Top' || prev.direction === 'Bottom')) {\n                        insertseg.direction = tx > 0 ? 'Right' : 'Left';\n                    }\n                    else {\n                        insertseg.direction = ty > 0 ? 'Bottom' : 'Top';\n                    }\n                }\n                prev = insertseg;\n                segments.push(insertseg);\n            }\n        }\n        else {\n            segValues = { type: 'Orthogonal', direction: segment.direction, length: segment.length / 3 };\n            segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(obj, 'segments', segValues, true));\n            if (segment.direction === 'Bottom' || segment.direction === 'Top') {\n                length = Math.abs(tx);\n                direction = tx > 0 ? 'Right' : 'Left';\n            }\n            else {\n                length = Math.abs(ty);\n                direction = ty > 0 ? 'Bottom' : 'Top';\n            }\n            insertseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: direction, length: length }, true);\n            segments.push(insertseg);\n        }\n        var args = {\n            element: obj, addSegments: segments, type: 'Addition', cancel: false\n        };\n        //Removed isBlazor code\n        this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args);\n        if (!args.cancel) {\n            if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {\n                obj.segments.splice(0, 1);\n                index = 1;\n            }\n            else {\n                var nextseg = obj.segments[1];\n                if (nextseg && nextseg.length) {\n                    nextseg.length = (direction !== nextseg.direction) ? nextseg.length + length : nextseg.length - length;\n                }\n                index = 2;\n                segment.length = 2 * segment.length / 3;\n            }\n            obj.segments = segments.concat(obj.segments);\n        }\n        return index;\n    };\n    ConnectorEditing.prototype.updateAdjacentSegments = function (obj, index, tx, ty) {\n        var current = obj.segments[parseInt(index.toString(), 10)];\n        var endPoint = current.points[current.points.length - 1];\n        var startPoint = current.points[0];\n        var isNextUpdate = true;\n        if (current.type === 'Orthogonal') {\n            current.points[0] = startPoint;\n            current.points[current.points.length - 1] = endPoint;\n            var prev = obj.segments[index - 1];\n            if (prev) {\n                isNextUpdate = this.updatePreviousSegment(tx, ty, obj, index);\n            }\n            if (obj.segments.length - 1 > index && isNextUpdate) {\n                var nextSegment = obj.segments[index + 1];\n                this.updateNextSegment(obj, current, nextSegment, tx, ty);\n            }\n        }\n    };\n    ConnectorEditing.prototype.addTerminalSegment = function (connector, segment, tx, ty, segmentIndex) {\n        //const oldValues: Connector = { segments: connector.segments } as Connector;\n        var index = connector.segments.indexOf(segment);\n        var first;\n        var insertseg;\n        var len;\n        var dir;\n        var segments = [];\n        var removeSegment = connector.segments.pop();\n        var last = connector.segments[connector.segments.length - 1];\n        first = (last && last.type === 'Orthogonal') ? last : null;\n        for (var i = 0; i < segment.points.length - 2; i++) {\n            len = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);\n            dir = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(segment.points[parseInt(i.toString(), 10)], segment.points[i + 1]);\n            insertseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: dir }, true);\n            segments.push(insertseg);\n            first = insertseg;\n        }\n        var sec = segmentIndex;\n        if (segment.points.length === 2 || sec === segment.points.length - 2) {\n            if (first) {\n                first.length += 5;\n            }\n            if (sec !== undefined) {\n                //let newseg: OrthogonalSegment;\n                len = 2 * _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]) / 3;\n                dir = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]);\n                var newseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: dir });\n                segments.push(newseg);\n            }\n        }\n        var lastseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n        segments.push(lastseg);\n        var args = {\n            element: connector, addSegments: segments, type: 'Addition', cancel: false\n        };\n        var args1 = {\n            element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(connector), addSegments: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.cloneBlazorObject)(segments),\n            type: 'Addition', cancel: args.cancel\n        };\n        //Removed isBlazor code\n        this.commandHandler.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramEvent.segmentCollectionChange, args1);\n        if (!args1.cancel) {\n            connector.segments = connector.segments.concat(segments);\n            index = index + segmentIndex;\n        }\n        else {\n            connector.segments.push(removeSegment);\n        }\n        this.commandHandler.updateEndPoint(connector);\n        return index;\n    };\n    // eslint-disable-next-line\n    ConnectorEditing.prototype.updatePortSegment = function (prev, connector, index, tx, ty) {\n        if (index === 1 && prev.points.length === 2 && prev.length < 0) {\n            var source = connector.sourceWrapper.corners;\n            var current = connector.segments[parseInt(index.toString(), 10)];\n            var next = connector.segments[index + 1];\n            var newseg = void 0;\n            var segment = [];\n            newseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: 13, direction: prev.direction });\n            segment.push(newseg);\n            var len = void 0;\n            if (current.direction === 'Left') {\n                len = (current.points[0].x - (source.middleLeft.x - 20));\n            }\n            else if (current.direction === 'Right') {\n                len = ((source.middleRight.x + 20) - current.points[0].x);\n            }\n            else if (current.direction === 'Bottom') {\n                len = ((source.bottomCenter.y + 20) - current.points[0].y);\n            }\n            else {\n                len = (current.points[0].y - (source.topCenter.y - 20));\n            }\n            //const dir: Direction = current.direction;\n            newseg = new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: current.direction });\n            segment.push(newseg);\n            current.length = current.length - len;\n            if (next && next.length && next.direction) {\n                if (next.direction === prev.direction) {\n                    next.length -= 13;\n                }\n                else if (next.direction === (0,_utility_connector__WEBPACK_IMPORTED_MODULE_6__.getOppositeDirection)(prev.direction)) {\n                    next.length += 13;\n                }\n            }\n            connector.segments = segment.concat(connector.segments);\n            this.selectedSegment = connector.segments[3];\n        }\n    };\n    ConnectorEditing.prototype.updatePreviousSegment = function (tx, ty, connector, index) {\n        var current = connector.segments[parseInt(index.toString(), 10)];\n        var prev = connector.segments[index - 1];\n        //const firstSegment: boolean = (index === 1) ? true : false;\n        prev.points[prev.points.length - 1] = current.points[0];\n        var isSourceNode = (connector.sourceID && connector.sourcePortID === '') ? false : true;\n        var isNextUpdate = true;\n        if (prev.type === 'Orthogonal') {\n            if (prev.direction === 'Bottom') {\n                prev.length += ty;\n            }\n            else if (prev.direction === 'Top') {\n                prev.length -= ty;\n            }\n            else if (prev.direction === 'Right') {\n                prev.length += tx;\n            }\n            else {\n                prev.length -= tx;\n            }\n            // EJ2-65063 - Added the below condition !allowNodeOverlap to prevent the segment to split into two segments while intersect with source node.\n            if (connector.sourcePortID !== '' && prev.length < 0 && !connector.allowNodeOverlap) {\n                this.updatePortSegment(prev, connector, index, tx, ty);\n            }\n            else if (connector.sourceID && connector.sourcePortID === '' && prev.length < 0 && index === 1) {\n                isNextUpdate = false;\n                this.updateFirstSegment(connector, current);\n            }\n            if (isSourceNode) {\n                this.changeSegmentDirection(prev, connector);\n            }\n        }\n        return isNextUpdate;\n    };\n    ConnectorEditing.prototype.changeSegmentDirection = function (segment, connector) {\n        if (!connector.maxSegmentThumb) {\n            if (segment.length < 0) {\n                segment.direction = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_6__.getOppositeDirection)(segment.direction);\n                segment.length *= -1;\n            }\n        }\n    };\n    ConnectorEditing.prototype.updateNextSegment = function (obj, current, next, tx, ty) {\n        next.points[0] = current.points[current.points.length - 1];\n        if (next && next.type === 'Orthogonal') {\n            if (next.length || next.length === 0) {\n                if (next.direction === 'Left' || next.direction === 'Right') {\n                    if (tx !== 0) {\n                        next.length = (next.direction === 'Right') ? next.length - tx : next.length + tx;\n                        if (next.length || next.length === 0) {\n                            this.changeSegmentDirection(next, obj);\n                        }\n                    }\n                }\n                else {\n                    if (ty !== 0) {\n                        next.length = (next.direction === 'Bottom') ? next.length - ty : next.length + ty;\n                        if (next.length || next.length === 0) {\n                            this.changeSegmentDirection(next, obj);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    ConnectorEditing.prototype.updateFirstSegment = function (connector, selectedSegment) {\n        var index = connector.segments.indexOf(selectedSegment);\n        var insertfirst = false;\n        var current = connector.segments[parseInt(index.toString(), 10)];\n        var prev = connector.segments[index - 1];\n        var con = connector;\n        var sourcePoint;\n        var oldValues = { segments: connector.segments };\n        if (prev.length < 0 && connector.sourceID) {\n            var sourceNode = connector.sourceWrapper.corners;\n            var segments = [];\n            var segValues = void 0;\n            var removeCurrentPrev = false;\n            this.changeSegmentDirection(current, connector);\n            var next = connector.segments[index + 1];\n            var nextNext = connector.segments[index + 2];\n            if (next) {\n                this.changeSegmentDirection(next, connector);\n            }\n            if (nextNext) {\n                this.changeSegmentDirection(nextNext, connector);\n            }\n            switch (prev.direction) {\n                case 'Top':\n                case 'Bottom':\n                    sourcePoint = (current.length > 0 && current.direction === 'Left') ? sourceNode.middleLeft : sourceNode.middleRight;\n                    if (current.length > sourceNode.width / 2) {\n                        if (Math.abs(prev.length) < sourceNode.height / 2) {\n                            prev.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);\n                            current.points[0].x = sourcePoint.x;\n                            current.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(current.points[0], current.points[current.points.length - 1]);\n                            current.length -= 20;\n                            insertfirst = true;\n                        }\n                    }\n                    else {\n                        if (next && next.direction && next.length) {\n                            next.points[0].y = sourcePoint.y;\n                            next.points[0].x = next.points[next.points.length - 1].x = (current.direction === 'Right') ?\n                                sourcePoint.x + 20 : sourcePoint.x - 20;\n                        }\n                        insertfirst = true;\n                        removeCurrentPrev = true;\n                    }\n                    break;\n                case 'Left':\n                case 'Right':\n                    sourcePoint = (current.length > 0 && current.direction === 'Top') ? sourceNode.topCenter : sourceNode.bottomCenter;\n                    if (current.length > sourceNode.height / 2) {\n                        if (Math.abs(prev.length) < sourceNode.width / 2) {\n                            prev.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);\n                            current.points[0].y = sourcePoint.y;\n                            current.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(current.points[0], current.points[current.points.length - 1]);\n                            current.length -= 20;\n                            insertfirst = true;\n                        }\n                    }\n                    else {\n                        if (next && next.direction && next.length) {\n                            next.points[0].x = sourcePoint.x;\n                            next.points[0].y = next.points[next.points.length - 1].y = (current.direction === 'Bottom') ?\n                                sourcePoint.y + 20 : sourcePoint.y - 20;\n                        }\n                        insertfirst = true;\n                        removeCurrentPrev = true;\n                    }\n                    break;\n            }\n            this.changeSegmentDirection(prev, connector);\n            this.changeSegmentDirection(current, connector);\n            if (insertfirst) {\n                segValues = { type: 'Orthogonal', direction: current.direction, length: 20 };\n                segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_7__.OrthogonalSegment(connector, 'segments', segValues, true));\n                if (removeCurrentPrev) {\n                    if (next && next.direction && next.length) {\n                        next.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                    }\n                    if (nextNext && nextNext.direction && nextNext.length) {\n                        nextNext.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(next.points[next.points.length - 1], nextNext.points[nextNext.points.length - 1]);\n                    }\n                    connector.segments.splice(index - 1, 2);\n                }\n                connector.segments = segments.concat(connector.segments);\n            }\n            this.selectedSegment = ((removeCurrentPrev) ? connector.segments[index - 1] :\n                connector.segments[index + 1]);\n            this.commandHandler.updateEndPoint(connector, oldValues);\n        }\n    };\n    ConnectorEditing.prototype.updateLastSegment = function (connector, selectedSegment) {\n        if (connector.targetID && connector.targetPortID === '') {\n            var line1Start = void 0;\n            var line1End = void 0;\n            var line2Start = void 0;\n            var line2End = void 0;\n            var corners = connector.targetWrapper.corners;\n            var firstSegPoint = selectedSegment.points[0];\n            var lastSegPoint = selectedSegment.points[selectedSegment.points.length - 1];\n            if (selectedSegment.direction === 'Right' || selectedSegment.direction === 'Left') {\n                line1Start = { x: firstSegPoint.x, y: firstSegPoint.y };\n                line1End = {\n                    x: (selectedSegment.direction === 'Left') ? lastSegPoint.x - corners.width / 2 : lastSegPoint.x + corners.width / 2,\n                    y: lastSegPoint.y\n                };\n                line2Start = { x: corners.center.x, y: corners.center.y - corners.height };\n                line2End = { x: corners.center.x, y: corners.center.y + corners.height };\n            }\n            else {\n                line1Start = { x: firstSegPoint.x, y: firstSegPoint.y };\n                line1End = {\n                    x: lastSegPoint.x,\n                    y: (selectedSegment.direction === 'Bottom') ? lastSegPoint.y + corners.height / 2 : lastSegPoint.y - corners.height / 2\n                };\n                line2Start = { x: corners.center.x - corners.width, y: corners.center.y };\n                line2End = { x: corners.center.x + corners.width, y: corners.center.y };\n            }\n            var line1 = { x1: line1Start.x, y1: line1Start.y, x2: line1End.x, y2: line1End.y };\n            var line2 = { x1: line2Start.x, y1: line2Start.y, x2: line2End.x, y2: line2End.y };\n            return ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_2__.intersect3)(line1, line2).enabled);\n        }\n        return false;\n    };\n    /**\n     *To destroy the module\n     *\n     * @returns {void} To destroy the module\n     */\n    ConnectorEditing.prototype.destroy = function () {\n        /**\n         * Destroys the connector editing module\n         */\n    };\n    /**\n     * Get module name.\n     */\n    /**\n     * Get module name.\\\n     *\n     * @returns {  string  }    Get module name.\\\n     */\n    ConnectorEditing.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'ConnectorEditingTool';\n    };\n    return ConnectorEditing;\n}(_tool__WEBPACK_IMPORTED_MODULE_8__.ToolBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/connector-editing.js?");

/***/ })

}]);