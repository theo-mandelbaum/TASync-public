"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_circularchart3d_renderer_3d-renderer_js-d790693-4dc72bb6"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/3d-renderer.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/3d-renderer.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircularChart3DBinaryTreeBuilder: () => (/* binding */ CircularChart3DBinaryTreeBuilder),\n/* harmony export */   CircularChart3DGraphics: () => (/* binding */ CircularChart3DGraphics),\n/* harmony export */   CircularChart3DMatrix: () => (/* binding */ CircularChart3DMatrix),\n/* harmony export */   CircularChart3DPolygonModule: () => (/* binding */ CircularChart3DPolygonModule),\n/* harmony export */   CircularChart3DRender: () => (/* binding */ CircularChart3DRender),\n/* harmony export */   CircularChart3DSvgRenderer: () => (/* binding */ CircularChart3DSvgRenderer),\n/* harmony export */   CircularChart3DTransform: () => (/* binding */ CircularChart3DTransform),\n/* harmony export */   CircularChart3DVectorModule: () => (/* binding */ CircularChart3DVectorModule)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n/**\n * Represents a 3D rendering configuration for the EJ 3D rendering engine.\n *\n */\nvar CircularChart3DRender = /** @class */ (function () {\n    function CircularChart3DRender() {\n        this.transform = null; // Chart3DBasicTransform\n    }\n    return CircularChart3DRender;\n}());\n\nvar circular3DRender = new CircularChart3DRender();\n/**\n * Represents a circular 3D vector in space.\n */\nvar CircularChart3DVectorModule = /** @class */ (function () {\n    /**\n     * Constructs a new Vector3D instance.\n     *\n     * @constructor\n     * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n     * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n     * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n     */\n    function CircularChart3DVectorModule(pointX, vy, vz) {\n        /** The x-coordinate of the vector. */\n        this.x = 0;\n        /** The y-coordinate of the vector. */\n        this.y = 0;\n        /** The z-coordinate of the vector. */\n        this.z = 0;\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.00001;\n        this.x = pointX;\n        this.y = vy || 0;\n        this.z = vz || 0;\n    }\n    /**\n     * Checks if a vector is valid (not NaN for any component).\n     *\n     * @param {CircularChart3DVector} point - The vector to check.\n     * @returns {boolean} - True if the vector is valid, false otherwise.\n     */\n    CircularChart3DVectorModule.prototype.isValid = function (point) {\n        return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n    };\n    /**\n     * Creates a new Vector3D instance from provided coordinates.\n     *\n     * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n     * @param {number} vy - The y-coordinate.\n     * @param {number} vz - The z-coordinate.\n     * @returns {CircularChart3DVector} - The new Vector3D instance.\n     */\n    CircularChart3DVectorModule.prototype.vector3D = function (vx, vy, vz) {\n        this.x = vx;\n        this.y = vy;\n        this.z = vz;\n        return { x: this.x, y: this.y, z: this.z };\n    };\n    /**\n     * Subtracts one vector from another and returns the result.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector to subtract from the first.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DMinus = function (v1, v2) {\n        return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    };\n    /**\n     * Adds two vectors and returns the result.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector to add to the first.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DPlus = function (v1, v2) {\n        return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    };\n    /**\n     * Multiplies two vectors using the cross product and returns the result.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DMultiply = function (v1, v2) {\n        var x = v1.y * v2.z - v2.y * v1.z;\n        var y = v1.z * v2.x - v2.z * v1.x;\n        var z = v1.x * v2.y - v2.x * v1.y;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the dot product of two vectors.\n     *\n     * @param {CircularChart3DVector} v1 - The first vector.\n     * @param {CircularChart3DVector} v2 - The second vector.\n     * @returns {number} - The dot product.\n     */\n    CircularChart3DVectorModule.prototype.vector3DAdd = function (v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    };\n    /**\n     * Multiplies a vector by a scalar value.\n     *\n     * @param {CircularChart3DVector} v1 - The vector to multiply.\n     * @param {number} value - The scalar value.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DVectorModule.prototype.vector3DStarMultiply = function (v1, value) {\n        var x = v1.x * value;\n        var y = v1.y * value;\n        var z = v1.z * value;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the length of a vector.\n     *\n     * @param {CircularChart3DVector} vector - The vector to calculate the length of.\n     * @returns {number} - The length of the vector.\n     */\n    CircularChart3DVectorModule.prototype.getLength = function (vector) {\n        var sqt = this.vector3DAdd(vector, vector);\n        return Math.sqrt(sqt);\n    };\n    /**\n     * Calculates the normal vector of a triangle defined by three vectors.\n     *\n     * @param {CircularChart3DVector} v1 - The first vertex of the triangle.\n     * @param {CircularChart3DVector} v2 - The second vertex of the triangle.\n     * @param {CircularChart3DVector} v3 - The third vertex of the triangle.\n     * @returns {CircularChart3DVector} - The normal vector of the triangle.\n     */\n    CircularChart3DVectorModule.prototype.getNormal = function (v1, v2, v3) {\n        var vector4 = this.vector3DMinus(v1, v2);\n        var vector5 = this.vector3DMinus(v3, v2);\n        var n = this.vector3DMultiply(vector4, vector5);\n        var length = this.getLength(n);\n        if (length < this.epsilon) {\n            return this.vector3D(0, 0, 0);\n        }\n        return this.vector3D(n.x / length, n.y / length, n.z / length);\n    };\n    return CircularChart3DVectorModule;\n}());\n\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar CircularChart3DMatrix = /** @class */ (function () {\n    function CircularChart3DMatrix() {\n        /** The size of the matrix, which is set to 4 by default. */\n        this.matrixSize = 4;\n    }\n    /**\n     * Generates a 3D matrix of the specified size.\n     *\n     * @param {number} size - The size of the 3D matrix.\n     * @returns {number[][]} - The generated 3D matrix.\n     * @private\n     */\n    CircularChart3DMatrix.prototype.matrix3D = function (size) {\n        var matrixData = [];\n        for (var i = 0; i < size; i++) {\n            matrixData[i] = this.createArray(size);\n        }\n        return matrixData;\n    };\n    /**\n     * Checks if a matrix is an affine matrix.\n     *\n     * @param {number[][]} matrixData - The matrix to check.\n     * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n     */\n    CircularChart3DMatrix.prototype.isAffine = function (matrixData) {\n        return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n    };\n    /**\n     * Creates a new array with zeros.\n     *\n     * @param {number} initialSize - The size of the array.\n     * @returns {number[]} - The created array.\n     */\n    CircularChart3DMatrix.prototype.createArray = function (initialSize) {\n        var matrixData = [];\n        for (var index = 0; index < initialSize; ++index) {\n            matrixData[index] = 0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the identity matrix.\n     *\n     * @returns {number[][]} - The identity matrix.\n     */\n    CircularChart3DMatrix.prototype.getIdentity = function () {\n        var matrixData = this.matrix3D(this.matrixSize);\n        for (var i = 0; i < this.matrixSize; i++) {\n            matrixData[i][i] = 1.0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the interval of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix to get the interval for.\n     * @returns {number[][]} - The interval matrix.\n     */\n    CircularChart3DMatrix.prototype.getInterval = function (matrix) {\n        var matrixData = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                matrixData[i][j] = this.getMinor(matrix, i, j);\n            }\n        }\n        matrixData = this.transposed(matrixData);\n        matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n        return matrixData;\n    };\n    /**\n     * Multiplies all elements of a matrix by a factor.\n     *\n     * @param {number} factor - The factor to multiply with.\n     * @param {number[][]} matrix - The matrix to multiply.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    CircularChart3DMatrix.prototype.getMatrixMultiple = function (factor, matrix) {\n        for (var i = 0; i < matrix.length; i++) {\n            for (var j = 0; j < matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * factor;\n            }\n        }\n        return matrix;\n    };\n    /**\n     * Multiplies a matrix by a vector.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {CircularChart3DVector} point - The vector to multiply with.\n     * @returns {CircularChart3DVector} - The resulting vector.\n     */\n    CircularChart3DMatrix.prototype.getMatrixVectorMultiple = function (matrix, point) {\n        var x = matrix[0][0] * point.x +\n            matrix[1][0] * point.y +\n            matrix[2][0] * point.z +\n            matrix[3][0];\n        var y = matrix[0][1] * point.x +\n            matrix[1][1] * point.y +\n            matrix[2][1] * point.z +\n            matrix[3][1];\n        var z = matrix[0][2] * point.x +\n            matrix[1][2] * point.y +\n            matrix[2][2] * point.z +\n            matrix[3][2];\n        if (!this.isAffine(matrix)) {\n            var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n            x *= c;\n            y *= c;\n            z *= c;\n        }\n        return { x: x, y: y, z: z };\n    };\n    /**\n     * Multiplies two matrices.\n     *\n     * @param {number[][]} matrix1 - The first matrix.\n     * @param {number[][]} matrix2 - The second matrix.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    CircularChart3DMatrix.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n        var result = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                var value = 0;\n                for (var k = 0; k < this.matrixSize; k++) {\n                    value += matrix1[k][j] * matrix2[i][k];\n                }\n                result[i][j] = value;\n            }\n        }\n        return result;\n    };\n    /**\n     * Gets the minor of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number} - The minor of the matrix.\n     * @private\n     */\n    CircularChart3DMatrix.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n        return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n    };\n    /**\n     * Gets a submatrix of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number[][]} - The submatrix.\n     */\n    CircularChart3DMatrix.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n        var count = matrix.length - 1;\n        var subMatrix = this.createArray(count);\n        for (var i = 0; i < count; i++) {\n            var matrixColumn = i >= columnIndex ? i + 1 : i;\n            subMatrix[i] = this.createArray(count);\n            for (var j = 0; j < count; j++) {\n                var matrixRow = j >= rowIndex ? j + 1 : j;\n                subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n            }\n        }\n        return subMatrix;\n    };\n    /**\n     * Gets the determinant of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @returns {number} - The determinant of the matrix.\n     */\n    CircularChart3DMatrix.prototype.getDeterminant = function (matrix) {\n        var count = matrix.length;\n        var determinant = 0;\n        if (count < 2) {\n            determinant = matrix[0][0];\n        }\n        else {\n            var k = 1;\n            for (var i = 0; i < count; i++) {\n                var submatrix = this.getMatrix(matrix, i, 0);\n                determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n                k = k > 0 ? -1 : 1;\n            }\n        }\n        return determinant;\n    };\n    /**\n     * Transforms a matrix by translation.\n     *\n     * @param {number} x - The x-coordinate of the translation.\n     * @param {number} y - The y-coordinate of the translation.\n     * @param {number} z - The z-coordinate of the translation.\n     * @returns {number[][]} - The transformed matrix.\n     */\n    CircularChart3DMatrix.prototype.transform = function (x, y, z) {\n        var transformedMatrix = this.getIdentity();\n        transformedMatrix[3][0] = x;\n        transformedMatrix[3][1] = y;\n        transformedMatrix[3][2] = z;\n        return transformedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the y-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     * @private\n     */\n    CircularChart3DMatrix.prototype.turn = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[0][0] = Math.cos(angle);\n        rotatedMatrix[2][0] = -Math.sin(angle);\n        rotatedMatrix[0][2] = Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the x-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    CircularChart3DMatrix.prototype.tilt = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[1][1] = Math.cos(angle);\n        rotatedMatrix[2][1] = Math.sin(angle);\n        rotatedMatrix[1][2] = -Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Transposes a matrix.\n     *\n     * @param {number[][]} matrix3D - The matrix to transpose.\n     * @returns {number[][]} - The transposed matrix.\n     */\n    CircularChart3DMatrix.prototype.transposed = function (matrix3D) {\n        var transposedMatrix = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                transposedMatrix[i][j] = matrix3D[j][i];\n            }\n        }\n        return transposedMatrix;\n    };\n    return CircularChart3DMatrix;\n}());\n\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar CircularChart3DTransform = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `ChartTransform` class.\n     */\n    function CircularChart3DTransform() {\n        /** Represents the angle conversion factor from degrees to radians. */\n        this.toRadial = Math.PI / 180;\n        this.vector = new CircularChart3DVectorModule(0, 0, 0);\n        this.matrixObj = new CircularChart3DMatrix();\n    }\n    /**\n     * Creates a 3D transformation based on the specified size.\n     *\n     * @param {Size} size - The size of the viewing area.\n     * @returns {CircularChart3DBasicTransform} - The 3D transformation.\n     */\n    CircularChart3DTransform.prototype.transform3D = function (size) {\n        return {\n            viewingArea: size,\n            rotation: 0,\n            tilt: 0,\n            depth: 0,\n            perspectiveAngle: 0,\n            needUpdate: true,\n            centeredMatrix: this.matrixObj.getIdentity(),\n            perspective: this.matrixObj.getIdentity(),\n            resultMatrix: this.matrixObj.getIdentity(),\n            viewMatrix: this.matrixObj.getIdentity()\n        };\n    };\n    /**\n     * Applies the specified 3D transformation to the current state.\n     *\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation to apply.\n     * @returns {void} - The 3D transformation.\n     */\n    CircularChart3DTransform.prototype.transform = function (transform) {\n        this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n        this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n        this.updatePerspective(transform.perspectiveAngle, transform);\n        transform.needUpdate = true;\n    };\n    /**\n     * Updates the perspective matrix based on the specified angle.\n     *\n     * @param {number} angle - The perspective angle.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    CircularChart3DTransform.prototype.updatePerspective = function (angle, transform) {\n        var width = (((transform.viewingArea.width + transform.viewingArea.height) *\n            Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (transform.depth * 2) / 2);\n        transform.perspective[0][0] = width;\n        transform.perspective[1][1] = width;\n        transform.perspective[2][3] = 1;\n        transform.perspective[3][3] = width;\n    };\n    /**\n     * Converts degrees to radians.\n     *\n     * @param {number} angle - The angle in degrees.\n     * @returns {number} - The angle in radians.\n     * @private\n     */\n    CircularChart3DTransform.prototype.degreeToRadianConverter = function (angle) {\n        return angle * Math.PI / 180;\n    };\n    /**\n     * Transforms a 3D vector to screen coordinates based on the current state.\n     *\n     * @param {CircularChart3DVector} vector3D - The 3D vector to transform.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @param {CircularChart3DMatrix} chartObj - Optional custom matrix object for transformation.\n     * @returns {CircularChart3DLocation} - The screen coordinates.\n     */\n    CircularChart3DTransform.prototype.toScreen = function (vector3D, transform, chartObj) {\n        if (!chartObj) {\n            transform.chartObj = this.matrixObj;\n            vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n        }\n        else {\n            this.matrixObj = chartObj;\n            vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n        }\n        return { x: vector3D.x, y: vector3D.y };\n    };\n    /**\n     * Sets the view matrix in the transformation state.\n     *\n     * @param {number[][]} matrix - The new view matrix.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    CircularChart3DTransform.prototype.setViewMatrix = function (matrix, transform) {\n        if (transform.viewMatrix === matrix) {\n            return;\n        }\n        transform.viewMatrix = matrix;\n        transform.needUpdate = true;\n    };\n    /**\n     * Calculates the final result matrix based on the current state.\n     *\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @param {CircularChart3DMatrix} matrixobj - Optional custom matrix object for transformation.\n     * @returns {number[][]} - The final result matrix.\n     */\n    CircularChart3DTransform.prototype.result = function (transform, matrixobj) {\n        var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n        if (!chartObj) {\n            chartObj = matrixobj;\n        }\n        if (!transform.needUpdate) {\n            return transform.resultMatrix;\n        }\n        var matrixObj = this.matrixObj;\n        transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n        transform.needUpdate = false;\n        return transform.resultMatrix;\n    };\n    /**\n     * Sets the center in the transformation state.\n     *\n     * @param {CircularChart3DVector} center - The new center vector.\n     * @param {CircularChart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    CircularChart3DTransform.prototype.setCenter = function (center, transform) {\n        transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n        transform.needUpdate = true;\n    };\n    return CircularChart3DTransform;\n}());\n\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n */\nvar CircularChart3DGraphics = /** @class */ (function () {\n    function CircularChart3DGraphics() {\n        /** The vector class. */\n        this.vector = new CircularChart3DVectorModule(0, 0, 0);\n    }\n    /**\n     * Prepares the view for rendering based on specified parameters.\n     *\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n        if (arguments.length === 0) {\n            bspTreeObj.build(null, chart);\n        }\n        else {\n            if (circular3DRender.transform == null) {\n                circular3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                circular3DRender.transform.viewingArea = size;\n            }\n            if (!circular3DRender.tree) {\n                circular3DRender.tree = [];\n            }\n            circular3DRender.transform.rotation = rotation;\n            circular3DRender.transform.tilt = tilt;\n            circular3DRender.transform.depth = depth;\n            circular3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(circular3DRender.transform);\n            circular3DRender.tree[chart.groupElement.id] = bspTreeObj.build(null, chart);\n        }\n    };\n    /**\n     * Renders the 3D view on the specified panel element.\n     *\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n        var MaxValue = 32767;\n        if (arguments.length === 2) {\n            if (panel == null) {\n                return;\n            }\n            var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eyeVector, panel, chart);\n        }\n        else {\n            if (panel == null) {\n                return;\n            }\n            if (circular3DRender.transform == null) {\n                circular3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                circular3DRender.transform.viewingArea = size;\n            }\n            circular3DRender.transform.rotation = rotation;\n            circular3DRender.transform.tilt = tilt;\n            circular3DRender.transform.depth = depth;\n            circular3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(circular3DRender.transform);\n            var eye = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(circular3DRender.tree[chart.groupElement.id], eye, panel, chart);\n        }\n    };\n    /**\n     * Draws a 3D element based on the specified Binary Space Partitioning Node.\n     *\n     * @param {CircularChart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.draw3DElement = function (bspElement, chart) {\n        if (bspElement.plane.element) {\n            if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n                polygonObj.drawText(bspElement.plane, chart);\n            }\n            else if (bspElement.plane.element.tag === 'polyline') {\n                polygonObj.drawPolyLine(bspElement.plane, chart);\n            }\n            else if (bspElement.plane.element.tag === 'template') {\n                polygonObj.drawTemplate(bspElement.plane, chart);\n            }\n        }\n        else {\n            polygonObj.draw(bspElement.plane, chart);\n        }\n    };\n    /**\n     * Draws the 3D nodes starting from the root based on the eye vector.\n     *\n     * @param {CircularChart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n     * @param {CircularChart3DVector} eyeVector - The eye vector.\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {CircularChart3D} chart - The instance of the circular 3D chart.\n     * @returns {void}\n     */\n    CircularChart3DGraphics.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n        if (bspElement === null || circular3DRender.transform == null) {\n            return;\n        }\n        var isVector = true;\n        while (isVector) {\n            var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(circular3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n            if (r > bspElement.plane.d) {\n                if (bspElement.front != null) {\n                    this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.back != null) {\n                    bspElement = bspElement.back;\n                    continue;\n                }\n            }\n            else {\n                if (bspElement.back != null) {\n                    this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.front != null) {\n                    bspElement = bspElement.front;\n                    continue;\n                }\n            }\n            break;\n        }\n        return null;\n    };\n    return CircularChart3DGraphics;\n}());\n\n/**\n * Represents a binary tree builder for 3D polygons in a circular 3D chart.\n *\n */\nvar CircularChart3DBinaryTreeBuilder = /** @class */ (function () {\n    function CircularChart3DBinaryTreeBuilder(chart) {\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.0005;\n        this.chart = chart;\n    }\n    /**\n     * Gets the next index considering the array length and the current index.\n     *\n     * @param {number} index - The current index.\n     * @param {number} count - The length of the array.\n     * @returns {number} - The next index.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.getNext = function (index, count) {\n        if (index >= count) {\n            return index - count;\n        }\n        if (index < 0) {\n            return index + count;\n        }\n        return index;\n    };\n    /**\n     * Creates a PolyAttributes object based on the vector, index, and result.\n     *\n     * @param {CircularChart3DVector} point - The vector representing the point.\n     * @param {number} index - The index of the point.\n     * @param {string} result - The result classification.\n     * @returns {CircularChart3DPolyAttributes} - The created PolyAttributes object.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n        return {\n            index: index,\n            result: result,\n            vector: point,\n            isCuttingBackPoint: false,\n            cuttingBackPairIndex: null,\n            alreadyCutBack: false,\n            isCuttingFrontPoint: false,\n            cuttingFrontPairIndex: null,\n            alreadyCutFront: false\n        };\n    };\n    /**\n     * Classifies a point relative to a polygon.\n     *\n     * @param {CircularChart3DVector} point - The point to classify.\n     * @param {CircularChart3DPolygon} polygon - The polygon for classification.\n     * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n        var result = 'OnPlane';\n        var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n        if (signedDistance > this.epsilon) {\n            result = 'OnBack';\n        }\n        else if (signedDistance < -this.epsilon) {\n            result = 'OnFront';\n        }\n        return result;\n    };\n    /**\n     * Classifies a polygon relative to another polygon.\n     *\n     * @param {CircularChart3DPolygon} refPolygon - The reference polygon.\n     * @param {CircularChart3DPolygon} classPolygon - The polygon to classify.\n     * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n        var result = 'Unknown';\n        var points = classPolygon.points;\n        if (points == null) {\n            return result;\n        }\n        var onBack = 0;\n        var onFront = 0;\n        var onPlane = 0;\n        var normal = refPolygon.normal;\n        var polygonValue = refPolygon.d;\n        for (var i = 0, len = points.length; i < len; i++) {\n            var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n            if (value > this.epsilon) {\n                onBack++;\n            }\n            else if (value < -this.epsilon) {\n                onFront++;\n            }\n            else {\n                onPlane++;\n            }\n            if (onBack > 0 && onFront > 0) {\n                break;\n            }\n        }\n        if (onPlane === points.length) {\n            result = 'OnPlane';\n        }\n        else if (onFront + onPlane === points.length) {\n            result = 'ToRight';\n        }\n        else if (onBack + onPlane === points.length) {\n            result = 'ToLeft';\n        }\n        else {\n            result = 'Unknown';\n        }\n        return result;\n    };\n    /**\n     * Splits a polygon into two parts based on another polygon.\n     *\n     * @param {CircularChart3DPolygon} splitPolygon - The polygon to split.\n     * @param {CircularChart3DPolygon} refPolygon - The reference polygon for splitting.\n     * @returns {CircularChart3DPolyCollections} - The resulting back and front parts.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n        var backPoint = [];\n        var frontPoint = [];\n        if (splitPolygon.points != null) {\n            var polyPoints = [];\n            var backPartPoints = [];\n            var frontPartPoints = [];\n            var outputs = void 0;\n            var inputs = void 0;\n            var count = splitPolygon.points.length;\n            for (var i = 0; i < count; i++) {\n                var pointB = splitPolygon.points[i];\n                var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n                var sideB = this.classifyPoint(pointB, refPolygon);\n                var sideC = this.classifyPoint(pointC, refPolygon);\n                var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n                polyPoints.push(attributeB);\n                if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n                    var vectorValue = vector.vector3DMinus(pointB, pointC);\n                    var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n                    var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n                    var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n                    var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n                    var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n                    polyPoints.push(attributeIntersection);\n                    backPartPoints.push(attributeIntersection);\n                    frontPartPoints.push(attributeIntersection);\n                }\n            }\n            if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n                for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n                    var backAttribute1 = backPartPoints[i];\n                    var backAttribute2 = backPartPoints[i + 1];\n                    backAttribute1.cuttingBackPoint = true;\n                    backAttribute2.cuttingBackPoint = true;\n                    backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n                    backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n                    var frontAttribute1 = frontPartPoints[i];\n                    var frontAttribute2 = frontPartPoints[i + 1];\n                    frontAttribute1.cuttingFrontPoint = true;\n                    frontAttribute2.cuttingFrontPoint = true;\n                    frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n                    frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n                }\n                for (var i = 0; i < backPartPoints.length - 1; i++) {\n                    var backAttribute1 = backPartPoints[i];\n                    if (backAttribute1.alreadyCutBack) {\n                        continue;\n                    }\n                    outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n                    if (outputs.length > 2) {\n                        var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n                        backPoint.push(__assign({}, polygon1));\n                    }\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i++) {\n                    var backAttribute2 = frontPartPoints[i];\n                    if (backAttribute2.alreadyCutFront) {\n                        continue;\n                    }\n                    inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n                    if (inputs.length > 2) {\n                        var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n                        frontPoint.push(__assign({}, polygon2));\n                    }\n                }\n            }\n        }\n        else {\n            backPoint.push(splitPolygon);\n            frontPoint.push(splitPolygon);\n        }\n        return { backPolygon: backPoint, frontPolygon: frontPoint };\n    };\n    /**\n     * Cuts out the front part of a polygon based on the PolyAttributes.\n     *\n     * @param {CircularChart3DPolyAttributes[]} polyPoints - The polyAttributes array of the polygon.\n     * @param {CircularChart3DPolyAttributes} initialVertex - The polyAttributes representing the cutting point.\n     * @returns {CircularChart3DVector[]} - The resulting points of the front part.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        var isVector = true;\n        while (isVector) {\n            currentVertex.alreadyCutFront = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n            if (currentVertex.cuttingFrontPoint) {\n                if (!currentVertexPair.alreadyCutFront) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Cuts out the back part of a polygon based on the PolyAttributes.\n     *\n     * @param {CircularChart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {CircularChart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {CircularChart3DVector[]} - The resulting points of the back part.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        var isVector = true;\n        while (isVector) {\n            currentVertex.alreadyCutBack = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n            if (currentVertex.cuttingBackPoint) {\n                if (!currentVertexPair.alreadyCutBack) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Builds a binary space partitioning from a list of polygons.\n     *\n     * @param {CircularChart3DPolygon[]} [points] - The list of polygons to build the tree from.\n     * @param {CircularChart3D} [chart] - The circular 3D chart.\n     * @returns {CircularChart3DBspNode} - The root node of the Binary Space Partitioning tree.\n     */\n    CircularChart3DBinaryTreeBuilder.prototype.build = function (points, chart) {\n        if (!points) {\n            return this.build(chart.circular3DPolygon);\n        }\n        else {\n            var inputPolygons = points;\n            if (inputPolygons.length < 1) {\n                return null;\n            }\n            var bspNode = { back: null, front: null, plane: null };\n            var plane = inputPolygons[0];\n            bspNode.plane = plane;\n            var polygonsToLeft = [];\n            var polygonsToRight = [];\n            for (var i = 1, len = inputPolygons.length; i < len; i++) {\n                var currentPolygon = inputPolygons[i];\n                if (currentPolygon === plane) {\n                    continue;\n                }\n                var classificationResult = this.classifyPolygon(plane, currentPolygon);\n                switch (classificationResult) {\n                    case 'OnPlane':\n                    case 'ToRight':\n                        polygonsToRight.push(currentPolygon);\n                        break;\n                    case 'ToLeft':\n                        polygonsToLeft.push(currentPolygon);\n                        break;\n                    case 'Unknown':\n                        if (currentPolygon.element) {\n                            polygonsToLeft.push(currentPolygon);\n                        }\n                        else {\n                            var result = this.splitPolygon(currentPolygon, plane);\n                            for (var k = 0; k < result.backPolygon.length; k++) {\n                                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                                polygonsToLeft.push(result.backPolygon[k]);\n                            }\n                            for (var j = 0; j < result.frontPolygon.length; j++) {\n                                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                                polygonsToRight.push(result.frontPolygon[j]);\n                            }\n                        }\n                        break;\n                }\n            }\n            if (polygonsToLeft.length > 0) {\n                bspNode.back = this.build(polygonsToLeft);\n            }\n            if (polygonsToRight.length > 0) {\n                bspNode.front = this.build(polygonsToRight);\n            }\n            return bspNode;\n        }\n    };\n    return CircularChart3DBinaryTreeBuilder;\n}());\n\n/**\n * The CircularChart3DSvgRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar CircularChart3DSvgRenderer = /** @class */ (function () {\n    function CircularChart3DSvgRenderer() {\n    }\n    /**\n     * Gets a CircularChart3DStringBuilder instance for constructing strings.\n     *\n     * @returns {CircularChart3DStringBuilder} - The StringBuilder instance.\n     */\n    CircularChart3DSvgRenderer.prototype.getStringBuilder = function () {\n        var data = [];\n        var counter = 0;\n        return {\n            append: function (text) {\n                data[counter++] = text;\n                return this;\n            },\n            toString: function (text) {\n                return data.join(text || '');\n            }\n        };\n    };\n    /**\n     * Parses a hex color code and returns its Red green Blue values.\n     *\n     * @param {string} hexColorCode - The hex color code.\n     * @returns {CircularChart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n     */\n    CircularChart3DSvgRenderer.prototype.hexToValue = function (hexColorCode) {\n        var result;\n        var values;\n        if (hexColorCode.indexOf('rgba(') === 0) {\n            values = hexColorCode.slice(5, -1).split(',');\n            return values ? {\n                red: parseInt(values[0], 10),\n                green: parseInt(values[1], 10),\n                blue: parseInt(values[2], 10),\n                alpha: parseFloat(values[3])\n            } : null;\n        }\n        else if (hexColorCode.indexOf('rgb(') === 0) {\n            values = hexColorCode.slice(4, -1).split(',');\n            return values ? {\n                red: parseInt(values[0], 10),\n                green: parseInt(values[1], 10),\n                blue: parseInt(values[2], 10)\n            } : null;\n        }\n        else {\n            result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n            return result\n                ? {\n                    red: parseInt(result[1], 16),\n                    green: parseInt(result[2], 16),\n                    blue: parseInt(result[3], 16)\n                }\n                : null;\n        }\n    };\n    /**\n     * Draws text on an SVG element.\n     *\n     * @param {SVGCanvasAttributes} options - The options for drawing the text.\n     * @param {string | string[]} label - The text label.\n     * @param {FontModel} font - The font settings for the text.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @returns {Element} - The created SVG text element.\n     */\n    CircularChart3DSvgRenderer.prototype.drawText = function (options, label, font, chart) {\n        var text = document.getElementById(options.id) || chart.groupElement.querySelector('#' + options.id);\n        if (text === null) {\n            text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        }\n        text.textContent = label;\n        text = chart.renderer.setElementAttributes(options, text);\n        return text;\n    };\n    /**\n     * Converts a CircularChart3DColorFormat object to its corresponding color string.\n     *\n     * @param {CircularChart3DColorFormat} color - The color in CircularChart3DColorFormat.\n     * @returns {string} - The color string representation.\n     */\n    CircularChart3DSvgRenderer.prototype.hexColor = function (color) {\n        var redValue = color.red;\n        var greenValue = color.green;\n        var blueValue = color.blue;\n        if (color.alpha) {\n            var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n            return returnColor;\n        }\n        else {\n            var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n            hex_1.forEach(function (val, nr) {\n                if (val.length === 1) {\n                    hex_1[nr] = '0' + val;\n                }\n            });\n            return '#' + hex_1.join('').toUpperCase();\n        }\n    };\n    /**\n     * Checks if a given color string is in a valid format (hex or rgba).\n     *\n     * @param {string} color - The color string to check.\n     * @returns {boolean} - True if the color string is valid, otherwise false.\n     */\n    CircularChart3DSvgRenderer.prototype.checkColorFormat = function (color) {\n        if (color.indexOf('rgba(') === 0 || color.indexOf('rgb(') === 0) {\n            var rgbaValues = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(',');\n            if (rgbaValues.length === 3 || rgbaValues.length === 4) {\n                return rgbaValues.every(function (val) {\n                    var num = parseFloat(val);\n                    return !isNaN(num) && num >= 0 && num <= 255;\n                });\n            }\n        }\n        else if (color.indexOf('#') === 0) {\n            var hex = color.substring(1);\n            return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);\n        }\n        return false;\n    };\n    return CircularChart3DSvgRenderer;\n}());\n\n/**\n * Represents a 3D polygon in a circular 3D chart.\n *\n */\nvar CircularChart3DPolygonModule = /** @class */ (function () {\n    function CircularChart3DPolygonModule() {\n        this.epsilon = 0.00001;\n        this.normal = { x: 0, y: 0, z: 0 };\n        this.vector = new CircularChart3DVectorModule(0, 0, 0);\n        this.vectorPoints = [];\n        this.matrixObj = new CircularChart3DMatrix();\n    }\n    /**\n     * Creates a 3D polygon.\n     *\n     * @param {CircularChart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n     * @param {CircularChart3DPolygon} [tag] - Additional information or metadata for the polygon.\n     * @param {number} [index] - An index associated with the polygon.\n     * @param {string} [stroke] - The stroke color of the polygon.\n     * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n     * @param {number} [opacity] - The opacity of the polygon.\n     * @param {string} [fill] - The fill color of the polygon.\n     * @param {string} [name] - The name or identifier of the polygon.\n     * @param {Element} [parent] - The parent element to which the polygon belongs.\n     * @param {string} [text] - Additional text associated with the polygon.\n     * @returns {CircularChart3DPolygon} - Returns the created polygon.\n     */\n    CircularChart3DPolygonModule.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n        if (arguments.length === 2) {\n            //points = points;\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var polygon = tag;\n            polygon.normal = this.normal;\n            polygon.points = points;\n            polygon.vectorPoints = this.vectorPoints;\n            polygon.isSplit = true;\n            polygon.d = this.d;\n            return polygon;\n        }\n        else {\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var element = { tag: 'path', parent: parent };\n            var polygon = {\n                normal: this.normal,\n                points: points,\n                vectorPoints: this.vectorPoints,\n                index: index,\n                tag: tag,\n                name: name ? name : null,\n                strokeThickness: strokeThickness,\n                opacity: opacity,\n                fill: fill,\n                d: this.d,\n                text: text ? text : '',\n                polygonElement: element\n            };\n            if (arguments.length !== 1) {\n                polygon.polygonElement = element;\n            }\n            return polygon;\n        }\n    };\n    /**\n     * Calculates the normal vector for a 3D polygon based on the provided points.\n     *\n     * @param {...CircularChart3DVector} args - Variable number of vector3D arguments representing points of the polygon.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.calculateNormal = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length >= 3) {\n            // Relative information of the points\n            var vector1 = args[0];\n            var vector2 = args[1];\n            var vector3 = args[2];\n            var vector4 = this.vector.vector3DMinus(vector1, vector2);\n            var vector5 = this.vector.vector3DMinus(vector3, vector2);\n            var normal = this.vector.vector3DMultiply(vector4, vector5);\n            var length_1 = this.vector.getLength(normal); // Get length of the vector\n            if (length_1 < this.epsilon) {\n                length_1 = 1;\n            }\n            this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n            this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n            if (args[3]) {\n                args[3].normal = this.normal;\n                args[3].d = this.d;\n            }\n        }\n        else {\n            var points = args[0];\n            this.calculateNormal(points[0], points[1], points[2], args[1]);\n            for (var i = 3; (i < points.length) && (this.test()); i++) {\n                this.calculateNormal(points[i], points[0], points[i / 2]);\n            }\n        }\n    };\n    /**\n     * Tests whether the calculated normal vector is valid.\n     *\n     * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n     */\n    CircularChart3DPolygonModule.prototype.test = function () {\n        return !this.vector.isValid(this.normal);\n    };\n    /**\n     * Gets the normal vector based on the transformed points using the specified transformation matrix.\n     *\n     * @param {number[][]} transform - The transformation matrix.\n     * @param {CircularChart3DVector[]} [vectorPoints] - The vector points.\n     * @returns {CircularChart3DVector} - Returns the normal vector.\n     * @private\n     */\n    CircularChart3DPolygonModule.prototype.getNormal = function (transform, vectorPoints) {\n        var normal;\n        if (vectorPoints != null) {\n            normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n            for (var i = 3; (i < vectorPoints.length) && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n                var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n                var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n                var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n                normal = this.vector.getNormal(v1, v2, v3);\n            }\n        }\n        return normal;\n    };\n    /**\n     * Creates a text element in the context of a circular 3D chart.\n     *\n     * @param {CircularChart3DVector} position - The position of the text.\n     * @param {CircularChart3DLabelElement} element - The text element to be created.\n     * @param {number} xLength - The x value for the text element.\n     * @param {number} yLength - The y value for the text element.\n     * @returns {CircularChart3DPolygon} - Returns the polygon representing the created text element.\n     */\n    CircularChart3DPolygonModule.prototype.createTextElement = function (position, element, xLength, yLength) {\n        var vectorCollection = [];\n        var x = position.x;\n        var y = position.y;\n        var desiredWidth = element.width;\n        var desiredHeight = element.height;\n        vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n        vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n        vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n        return this.text3D(element, vectorCollection);\n    };\n    /**\n     * Creates a 3D polyline by connecting a series of points in 3D space.\n     *\n     * @param {Array<{ x: number; y: number; z?: number }>} points - An array of points in 3D space, specified by their x, y, and optional z coordinates.\n     * @param {CircularChart3DLabelElement} element - The circular 3D label element associated with the polyline.\n     * @returns {CircularChart3DPolygon} - The resulting 3D polyline with the specified circular 3D label element and vertices.\n     */\n    CircularChart3DPolygonModule.prototype.createPolyline = function (points, element) {\n        if (points.length === 2) {\n            var prePoint = points[1];\n            points.push({ x: prePoint.x, y: prePoint.y, z: prePoint.z });\n        }\n        return this.polyLine3D(element, points);\n    };\n    /**\n     * Creates a 3D polygon by connecting a series of points in 3D space.\n     *\n     * @param {CircularChart3DLabelElement} element - The circular 3D label element associated with the polygon.\n     * @param {Array<{ x: number; y: number; z?: number }>} points - An array of points in 3D space, specified by their x, y, and optional z coordinates.\n     * @returns {CircularChart3DPolygon} - The resulting 3D polygon with the specified circular 3D label element and vertices.\n     */\n    CircularChart3DPolygonModule.prototype.polyLine3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D text polygon based on the given label element and points.\n     *\n     * @param {CircularChart3DLabelElement} element - The label element associated with the text.\n     * @param {CircularChart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n     * @returns {CircularChart3DPolygon} - Returns the created 3D text polygon.\n     */\n    CircularChart3DPolygonModule.prototype.text3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Draws a polyline on the circular 3D chart panel.\n     *\n     * @param {CircularChart3DPolygon} panel - The polygon panel on which to draw the polyline.\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     */\n    CircularChart3DPolygonModule.prototype.drawPolyLine = function (panel, chart) {\n        var transform = circular3DRender.transform;\n        var pathDirection = chart.svg3DRenderer.getStringBuilder();\n        var startPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        pathDirection.append(\"M \" + startPoint.x + \" \" + startPoint.y + \" \");\n        var lineSegment1 = chart.transform3D.toScreen(panel.vectorPoints[1], transform);\n        pathDirection.append(\"L \" + lineSegment1.x + \" \" + lineSegment1.y + \" \");\n        pathDirection.append(\"M \" + lineSegment1.x + \" \" + lineSegment1.y + \" \");\n        var lineSegment2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n        pathDirection.append(\"L \" + lineSegment2.x + \" \" + lineSegment2.y + \" \");\n        var direction = pathDirection.toString();\n        var optionsLine = {\n            id: panel.element.id,\n            'stroke-dasharray': panel.element.dashArray,\n            'stroke-width': panel.element.width,\n            stroke: panel.element.stroke,\n            d: direction\n        };\n        var element = chart.renderer.drawPath(optionsLine);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, chart.groupElement, element, chart.redraw, true, 'x', 'y', null, direction);\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a circular 3D series.\n     *\n     * @param {CircularChart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {CircularChart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.drawText = function (panel, chart) {\n        var element = panel.element;\n        var transform = circular3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var x = actual3DPosition.x;\n        var y = actual3DPosition.y;\n        if (element.tag === 'text') {\n            var options = {\n                'id': element.id,\n                'x': x,\n                'y': y,\n                'fill': element.font.color || element.fill,\n                'font-size': element.font.size,\n                'font-family': element.font.fontFamily || chart.themeStyle.datalabelFont.fontFamily,\n                'font-style': element.font.fontStyle,\n                'font-weight': element.font.fontWeight,\n                'opacity': element.font.opacity,\n                'text-anchor': element.textAnchor,\n                'cursor': 'default',\n                'transform': element.angle ? 'rotate(' + element.angle + ',' + (x) + ',' + y + ')' : ''\n            };\n            var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n            if (element.id.indexOf('text') > -1) {\n                textElement.setAttribute('aria-hidden', 'true');\n            }\n            chart.groupElement.append(textElement);\n            if (chart.previousID && chart.isTouch) {\n                var previousElement = document.getElementById(chart.previousID);\n                var currentElement = document.getElementById(options.id);\n                if (previousElement && currentElement) {\n                    currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n                }\n            }\n            chart.previousID = options.id;\n        }\n        else {\n            var series = element.series;\n            var pointText = element.point.argsData.text;\n            var textOffset = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.measureText)(pointText, element.point.argsData.font, chart.themeStyle.datalabelFont);\n            var padding = 10;\n            var width = textOffset.width + padding + padding;\n            var height = textOffset.height + padding + padding;\n            var location_1 = { x: actual3DPosition.x, y: actual3DPosition.y };\n            var xXalue = location_1.x - (padding) / 2 + (padding) / 2;\n            var yValue = location_1.y - (padding) / 2 - (height / padding) + (padding) / 2;\n            var seriesIndex = series.index;\n            this.dataLabelSymbol(seriesIndex, series, element, xXalue, yValue, width, height, chart);\n        }\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a circular 3D series.\n     *\n     * @param {number} seriesIndex - The index of the series to which the data point belongs.\n     * @param {CircularChart3DSeries} series - The circular 3D series containing the data point.\n     * @param {CircularChart3DLabelElement} dataElement - The index of the data point within the series.\n     * @param {number} x - The x-coordinate of the center of the symbol.\n     * @param {number} y - The y-coordinate of the center of the symbol.\n     * @param {number} width - The width of the symbol.\n     * @param {number} height - The height of the symbol.\n     * @param {CircularChart3D} chart - The circular 3D chart containing the series.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.dataLabelSymbol = function (seriesIndex, series, dataElement, x, y, width, height, chart) {\n        var path = 'M' + ' ' + (x + (-width / 2)) + ' ' +\n            (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (-height / 2)) + ' z';\n        var transform = '';\n        if (series.dataLabel.enableRotation) {\n            var degree = void 0;\n            var angle = degree = series.dataLabel.angle;\n            if (angle === 0) {\n                var toDegrees = function (angle) { return angle * (180 / Math.PI); };\n                var midAngle = toDegrees(dataElement.point.symbolLocation.angle);\n                if (series.dataLabel.position === 'Outside') {\n                    degree = 0;\n                }\n                else if (midAngle >= 90 && midAngle <= 260) {\n                    degree = midAngle + 180;\n                }\n                else {\n                    degree = midAngle;\n                }\n            }\n            else {\n                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\n            }\n            transform = 'rotate(' + degree + ',' + (x) + ',' + (y) + ')';\n        }\n        var rectOptions = {\n            id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-shape-' + dataElement.pointIndex,\n            fill: dataElement.point.argsData.color,\n            'stroke-width': dataElement.point.argsData.border.width,\n            stroke: dataElement.point.argsData.border.color,\n            'stroke-dasharray': dataElement.point.argsData.border.dashArray,\n            opacity: 1,\n            visibility: '',\n            transform: transform,\n            d: path\n        };\n        var element = chart.renderer.drawPath(rectOptions);\n        chart.groupElement.append(element);\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(rectOptions.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = rectOptions.id;\n    };\n    /**\n     * Draws a circular 3D polygon on the specified chart.\n     *\n     * @param {CircularChart3DPolygon} panel - The polygon to be drawn.\n     * @param {CircularChart3D} chart - The circular 3D chart on which the polygon is to be drawn.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.draw = function (panel, chart) {\n        if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n            return;\n        }\n        var transform = circular3DRender.transform;\n        var pathDirection = chart.svg3DRenderer.getStringBuilder();\n        var color = panel.fill;\n        var format = chart.svg3DRenderer.checkColorFormat(color);\n        if (!format) {\n            color = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.colorNameToHex)(color);\n        }\n        var figure = { StartPoint: null };\n        if (transform != null) {\n            figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n            pathDirection.append('M' + ' ' + (figure.StartPoint.x) + ' ' + (figure.StartPoint.y) + ' ');\n            for (var i = 0; i < panel.vectorPoints.length; i++) {\n                var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n                pathDirection.append('L' + ' ' + (lineSegment.x) + ' ' + (lineSegment.y) + ' ');\n            }\n        }\n        var direction = pathDirection.toString();\n        var name = 'Light';\n        var lightCoefficientZ = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1));\n        var lightCoefficientY = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1));\n        var lightCoefficientX = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1));\n        if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n            if (lightCoefficientZ === lightCoefficientX) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else if (((lightCoefficientY === lightCoefficientZ) || (lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ))) {\n                name = 'XLight';\n                color = this.applyXLight(color, chart);\n            }\n            else if (lightCoefficientZ < 0) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else {\n                name = 'Light';\n            }\n        }\n        var options = {\n            'id': chart.element.id + '-svg-' + panel.name,\n            'name': name,\n            'fill': color,\n            'stroke': '',\n            'stroke-width': panel.strokeThickness,\n            'opacity': panel.opacity,\n            'd': direction\n        };\n        var element = chart.renderer.drawPath(options);\n        if (panel.text) {\n            element.setAttribute('aria-label', panel.text);\n            element.setAttribute('role', 'img');\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(options.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = options.id;\n    };\n    /**\n     * Draws text on the specified circular 3D chart panel.\n     *\n     * @param {CircularChart3DPolygon} panel - The circular 3D polygon representing the panel on which the text will be drawn.\n     * @param {CircularChart3D} chart - The circular 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    CircularChart3DPolygonModule.prototype.drawTemplate = function (panel, chart) {\n        var element = panel.element;\n        var transform = circular3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var label = element.label;\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        chart.circularChartDataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.points[label.pointIndex], label.series.points[label.pointIndex].argsData, label.pointIndex, false, actual3DPosition, chart);\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green, and blue components.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {CircularChart3D} chart - The circular 3D chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    CircularChart3DPolygonModule.prototype.applyXLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green, and blue components with a focus on the Z-axis.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {CircularChart3D} chart - The circular 3D chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    CircularChart3DPolygonModule.prototype.applyZLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    return CircularChart3DPolygonModule;\n}());\n\nvar vector = new CircularChart3DVectorModule(0, 0, 0);\nvar matrixObj = new CircularChart3DMatrix();\nvar bspTreeObj = new CircularChart3DBinaryTreeBuilder();\nvar polygonObj = new CircularChart3DPolygonModule();\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/circularchart3d/renderer/3d-renderer.js?");

/***/ })

}]);