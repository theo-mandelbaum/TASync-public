"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_container-interaction_js--375058c5"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addChildToContainer: () => (/* binding */ addChildToContainer),\n/* harmony export */   checkChildNodeInContainer: () => (/* binding */ checkChildNodeInContainer),\n/* harmony export */   checkParentAsContainer: () => (/* binding */ checkParentAsContainer),\n/* harmony export */   createHelper: () => (/* binding */ createHelper),\n/* harmony export */   findBounds: () => (/* binding */ findBounds),\n/* harmony export */   moveChildInStack: () => (/* binding */ moveChildInStack),\n/* harmony export */   removeChildInContainer: () => (/* binding */ removeChildInContainer),\n/* harmony export */   renderContainerHelper: () => (/* binding */ renderContainerHelper),\n/* harmony export */   renderStackHighlighter: () => (/* binding */ renderStackHighlighter),\n/* harmony export */   updateCanvasBounds: () => (/* binding */ updateCanvasBounds),\n/* harmony export */   updateLaneBoundsAfterAddChild: () => (/* binding */ updateLaneBoundsAfterAddChild),\n/* harmony export */   updateLaneBoundsWithSelector: () => (/* binding */ updateLaneBoundsWithSelector),\n/* harmony export */   updateZindex: () => (/* binding */ updateZindex)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _diagram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../diagram */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _utility_dom_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utility/dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utility/swim-lane-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Interaction for Container\n */\n//#region canvas Container interaction\n/**\n * updateCanvasBounds method\\\n *\n * @returns {  void }    updateCanvasBounds method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.\n * @private\n */\nfunction updateCanvasBounds(diagram, obj, position, isBoundsUpdate) {\n    var container;\n    var connectorList = [];\n    var groupAction = false;\n    if (checkParentAsContainer(diagram, obj, true)) {\n        diagram.protectPropertyChange(true);\n        container = diagram.nameTable[obj.parentId];\n        var wrapper = container.wrapper;\n        if (diagram.selectedItems.nodes.length > 1) {\n            diagram.multiselect = true;\n        }\n        else {\n            diagram.multiselect = false;\n        }\n        if (container && container.container.type === 'Canvas') {\n            if ((isBoundsUpdate || (wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x &&\n                (wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y) && !diagram.multiselect))) {\n                var parentWrapper = void 0;\n                var y = wrapper.bounds.y;\n                var x = wrapper.bounds.x;\n                var parent_1 = diagram.nameTable[container.parentId] || container;\n                var shape = parent_1.shape;\n                if (shape.type === 'SwimLane') {\n                    groupAction = updateLaneBoundsAfterAddChild(container, parent_1, obj, diagram, true);\n                }\n                else {\n                    var parent_2 = diagram.nameTable[container.parentId] || container;\n                    var shape_1 = parent_2.shape;\n                    parentWrapper = parent_2.wrapper;\n                    if (wrapper.actualSize.width < wrapper.outerBounds.width &&\n                        (!(wrapper.bounds.x > wrapper.outerBounds.x))) {\n                        if (container.rowIndex !== undefined) {\n                            //const columnIndex:number = parent.columns.length - 1;\n                            parentWrapper.updateColumnWidth(container.columnIndex, wrapper.outerBounds.width, true);\n                            if (shape_1.orientation === 'Horizontal' && shape_1.phaseSize) {\n                                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.updatePhaseMaxWidth)(parent_2, diagram, wrapper, container.columnIndex);\n                            }\n                            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.updateHeaderMaxWidth)(diagram, parent_2);\n                            diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);\n                        }\n                        else {\n                            diagram.scale(container, (1 + ((wrapper.outerBounds.width - wrapper.actualSize.width) / wrapper.actualSize.width)), 1, ((wrapper.outerBounds.x < wrapper.bounds.x) ? { x: 1, y: 0.5 } : { x: 0, y: 0.5 }));\n                        }\n                    }\n                    if (wrapper.actualSize.height < wrapper.outerBounds.height &&\n                        (!(wrapper.bounds.y > wrapper.outerBounds.y))) {\n                        if (container.rowIndex !== undefined) {\n                            parentWrapper.updateRowHeight(container.rowIndex, wrapper.outerBounds.height, true);\n                            diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);\n                        }\n                        else {\n                            diagram.scale(container, 1, (1 + ((wrapper.outerBounds.height - wrapper.actualSize.height) / wrapper.actualSize.height)), ((wrapper.outerBounds.y < wrapper.bounds.y) ? { x: 0.5, y: 1 } : { x: 0.5, y: 0 }));\n                        }\n                    }\n                }\n            }\n            diagram.select([obj]);\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.updateConnectorsProperties)(connectorList, diagram);\n        }\n        diagram.protectPropertyChange(false);\n    }\n    return groupAction;\n}\n/**\n * removeChildInContainer method\\\n *\n * @returns {  void }    removeChildInContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.\n * @private\n */\nfunction removeChildInContainer(diagram, obj, position, isBoundsUpdate) {\n    var container; //let connectorList: string[] = [];\n    if (checkParentAsContainer(diagram, obj, true) && !(diagram.cancelPositionChange)) {\n        var isProtectedOnChange = 'isProtectedOnChange';\n        var propertyChangeValue = diagram[\"\" + isProtectedOnChange];\n        diagram.protectPropertyChange(true);\n        container = diagram.nameTable[obj.parentId];\n        var wrapper = container.wrapper;\n        if (container && container.container.type === 'Canvas') {\n            if ((!isBoundsUpdate && (!(wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x &&\n                (wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y))))) {\n                if (!(obj.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.NodeConstraints.AllowMovingOutsideLane)) {\n                    var undoObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(obj);\n                    diagram.clearSelection();\n                    removeChildrenInLane(diagram, obj);\n                    obj.parentId = '';\n                    //EJ2-65676 - Exception throws on updating node annotation after drag and drop from swimlane to diagram canvas.\n                    obj.parentObj = diagram;\n                    obj.propName = 'nodes';\n                    var entry = {\n                        type: 'ChildCollectionChanged', category: 'Internal',\n                        undoObject: undoObj, redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(obj)\n                    };\n                    diagram.addHistoryEntry(entry);\n                    if (diagram.commandHandler.isContainer) {\n                        diagram.commandHandler.isContainer = false;\n                        diagram.endGroupAction();\n                    }\n                    moveSwinLaneChild(obj, diagram);\n                }\n            }\n        }\n        diagram.protectPropertyChange(propertyChangeValue);\n    }\n}\n/**\n * findBounds method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    findBounds method .\\\n * @param {NodeModel} obj - provide the diagram value.\n * @param {number} columnIndex - provide the isVertical value.\n * @param {boolean} isHeader - provide the isVertical value.\n * @private\n */\nfunction findBounds(obj, columnIndex, isHeader) {\n    var rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_6__.Rect();\n    var rows = (obj.shape.type === 'SwimLane') ?\n        obj.wrapper.children[0].rows : obj.wrapper.rows;\n    for (var i = ((isHeader) ? 1 : 0); i < rows.length; i++) {\n        rect.uniteRect(rows[parseInt(i.toString(), 10)].cells[parseInt(columnIndex.toString(), 10)].bounds);\n    }\n    return rect;\n}\n/**\n * createHelper method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    createHelper method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @private\n */\nfunction createHelper(diagram, obj) {\n    var newObj;\n    var cloneObject = {};\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        cloneObject[\"\" + prop] = obj[\"\" + prop];\n    }\n    if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_5__.getObjectType)(obj) === _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n        newObj = new _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node(diagram, 'nodes', cloneObject, true);\n        newObj.id = obj.id;\n        diagram.initObject(newObj);\n    }\n    diagram.updateDiagramObject(newObj);\n    return newObj;\n}\n/**\n * renderContainerHelper method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    renderContainerHelper method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @private\n */\nfunction renderContainerHelper(diagram, obj) {\n    diagram.enableServerDataBinding(false);\n    var object;\n    var container;\n    var nodes;\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)()) {\n        if (diagram.selectedObject.helperObject) {\n            nodes = diagram.selectedObject.helperObject;\n        }\n        else if (diagram.selectedItems.nodes.length > 0 || diagram.selectedItems.connectors.length > 0) {\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector && obj.nodes.length + obj.connectors.length === 1) {\n                object = (obj.nodes.length > 0) ? obj.nodes[0] : obj.connectors[0];\n                container = diagram.selectedItems.wrapper.children[0];\n            }\n            else {\n                object = obj;\n                //Removed isBlazor code\n                container = diagram.selectedItems.wrapper;\n            }\n            diagram.selectedObject.actualObject = object;\n            // Added below code to render helper object for multiselected nodes inside swimlane to avoid interaction related issues.\n            var dragObject = object instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector\n                ? (object.nodes.length > 0 ? object.nodes[0] : object) : object;\n            diagram.selectedObject.actualObject = object;\n            if ((!diagram.currentSymbol) && (((dragObject.isLane && (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.canLaneInterchange)(dragObject, diagram) &&\n                checkParentAsContainer(diagram, dragObject))\n                || ((!dragObject.isLane) && checkParentAsContainer(diagram, dragObject))) ||\n                ((diagram.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.DiagramConstraints.LineRouting) && diagram.selectedItems.nodes.length > 0))) {\n                var node = {\n                    id: 'helper',\n                    rotateAngle: container.rotateAngle,\n                    offsetX: container.offsetX, offsetY: container.offsetY,\n                    minWidth: container.minWidth, minHeight: container.minHeight,\n                    maxWidth: container.maxWidth, maxHeight: container.maxHeight,\n                    width: container.actualSize.width,\n                    height: container.actualSize.height,\n                    style: { strokeDashArray: '2 2', fill: 'transparent', strokeColor: '#7D7D7D', strokeWidth: 2 }\n                };\n                nodes = createHelper(diagram, node);\n                diagram.selectedObject.helperObject = nodes;\n            }\n        }\n    }\n    diagram.enableServerDataBinding(true);\n    return nodes;\n}\n/**\n * checkParentAsContainer method\\\n *\n * @returns {  void  }    checkParentAsContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {boolean} isChild - provide the isChild value.\n * @private\n */\nfunction checkParentAsContainer(diagram, obj, isChild) {\n    var parentNode = (isChild) ? diagram.nameTable[obj.parentId] :\n        (diagram.nameTable[obj.parentId] || obj);\n    if (parentNode && parentNode.container) {\n        return true;\n    }\n    return false;\n}\n/**\n * checkChildNodeInContainer method\\\n *\n * @returns {  void  }    checkChildNodeInContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel} obj - provide the isVertical value.\n * @private\n */\nfunction checkChildNodeInContainer(diagram, obj) {\n    var parentNode = diagram.nameTable[obj.parentId];\n    obj.laneMargin = { left: obj.margin.left, right: obj.margin.right, top: obj.margin.top, bottom: obj.margin.bottom };\n    //To handle the resize of bpmn node which has text annotation inside swimlane\n    if (obj.hasTextAnnotation) {\n        for (var i = 0; i < obj.outEdges.length; i++) {\n            var connector = diagram.nameTable[obj.outEdges[parseInt(i.toString(), 10)]];\n            if (connector.isBpmnAnnotationConnector) {\n                var textNode = diagram.nameTable[connector.targetID];\n                var oldObject = { width: obj.wrapper.actualSize.width, height: obj.wrapper.actualSize.height,\n                    offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY };\n                var oldX = obj.wrapper.offsetX;\n                var oldY = obj.wrapper.offsetY;\n                var offset = diagram.getTextAnnotationOffset(obj, textNode, oldObject, oldX, oldY);\n                var difX = offset.x - oldX;\n                var difY = offset.y - oldY;\n                if (difX || difY || obj.width !== obj.wrapper.actualSize.width || obj.height !== obj.wrapper.actualSize.height) {\n                    obj.isResized = true;\n                    if (!obj.resizeDif) {\n                        obj.resizeDif = [];\n                    }\n                    obj.resizeDif[textNode.id] = { x: difX, y: difY };\n                }\n            }\n        }\n    }\n    if (parentNode.container.type === 'Canvas') {\n        obj.margin.left = (obj.offsetX - parentNode.wrapper.bounds.x - (obj.width / 2));\n        obj.margin.top = (obj.offsetY - parentNode.wrapper.bounds.y - (obj.height / 2));\n    }\n    diagram.nodePropertyChange(obj, {}, {\n        width: obj.width, height: obj.height,\n        offsetX: obj.offsetX, offsetY: obj.offsetY,\n        margin: {\n            left: obj.margin.left,\n            right: obj.margin.right, top: obj.margin.top,\n            bottom: obj.margin.bottom\n        }, rotateAngle: obj.rotateAngle\n    });\n    //EJ2-913789 - Lane size gets varied upon undo redo the node drop\n    if (diagram.undoRedoModule && parentNode.isLane && diagram.undoRedoModule.checkRedo &&\n        (obj.margin.left < 0 || obj.margin.top < 0)) {\n        removeChildrenInLane(diagram, obj);\n    }\n    if (!parentNode.isLane) {\n        parentNode.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_3__.Size());\n        parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);\n    }\n}\nfunction removeChildrenInLane(diagram, node) {\n    if (node.parentId && node.parentId !== '') {\n        var prevParentNode = diagram.nameTable[node.parentId];\n        if (prevParentNode.isLane && prevParentNode.parentId) {\n            var swimlane = diagram.nameTable[prevParentNode.parentId];\n            var canvasId = (prevParentNode.id.slice(swimlane.id.length));\n            var prevParentId = canvasId.substring(0, canvasId.length - 1);\n            var lanes = swimlane.shape.lanes;\n            var lane = void 0;\n            for (var i = 0; i < lanes.length; i++) {\n                lane = lanes[parseInt(i.toString(), 10)];\n                if (prevParentId === lane.id) {\n                    for (var j = 0; j < lane.children.length; j++) {\n                        if (lane.children[parseInt(j.toString(), 10)].id === node.id) {\n                            lane.children.splice(j, 1);\n                            j--;\n                        }\n                    }\n                }\n            }\n        }\n        diagram.deleteChild(node);\n    }\n}\n/**\n *\n * @param { NodeModel | ConnectorModel} obj - Provide the obj value.\n * @param { NodeModel } swimlane  - Provide the swimlane value.\n * @param { Diagram } diagram - Provide the diagram value.\n * @returns { void } updateZindex method .\\\n * @private\n */\nfunction updateZindex(obj, swimlane, diagram) {\n    var objLayer = diagram.commandHandler.getObjectLayer(obj.id);\n    var zIndexTable = objLayer.zIndexTable;\n    var targetZIndex = swimlane.zIndex + 1;\n    // Find a unique zIndex\n    while (zIndexTable[parseInt(targetZIndex.toString(), 10)] !== undefined) {\n        targetZIndex++;\n    }\n    // Assign the unique zIndex to the node\n    delete objLayer.zIndexTable[obj.zIndex];\n    obj.zIndex = targetZIndex;\n    objLayer.zIndexTable[parseInt(targetZIndex.toString(), 10)] = obj.id;\n}\n/**\n * addChildToContainer method\\\n *\n * @returns {  void  }    addChildToContainer method .\\\n * @param {DiagramElement} diagram - provide the element value.\n * @param {boolean} parent - provide the isVertical value.\n * @param {PointModel} node - provide the node value.\n * @param {Diagram} isUndo - provide the isUndo value.\n * @param {boolean} historyAction - provide the historyAction value.\n * @param {boolean} canUpdateZindex - provide the canUpdateZindex value.\n * @private\n */\nfunction addChildToContainer(diagram, parent, node, isUndo, historyAction, canUpdateZindex) {\n    if (!diagram.currentSymbol) {\n        diagram.protectPropertyChange(true);\n        var swimlane = diagram.nameTable[parent.parentId];\n        node = diagram.getObject(node.id) || node;\n        //Bug 909155: Issue in connecting nodes with ports.\n        //When we add child nodes at runtime and perform undo redo, the child node is not selectable as the zIndex of swimlane is higher than child node.\n        //Added below code to update the zIndex of the child node.\n        if (swimlane && swimlane.zIndex > node.zIndex && canUpdateZindex) {\n            updateZindex(node, swimlane, diagram);\n        }\n        var child = (diagram.nodes.indexOf(node) !== -1) ? node.id : node;\n        if (parent.container.type === 'Canvas' && !historyAction) {\n            var left = (node.wrapper.offsetX - node.wrapper.actualSize.width / 2) -\n                (parent.wrapper.offsetX - parent.wrapper.actualSize.width / 2);\n            var top_1 = (node.wrapper.offsetY - node.wrapper.actualSize.height / 2) -\n                (parent.wrapper.offsetY - parent.wrapper.actualSize.height / 2);\n            node.margin.left = left;\n            node.margin.top = top_1;\n        }\n        else if (swimlane) {\n            var swimLaneBounds = swimlane.wrapper.bounds;\n            var parentBounds = parent.wrapper.bounds;\n            if (swimlane.shape.orientation === 'Horizontal') {\n                node.margin.left -= parentBounds.x - swimLaneBounds.x;\n            }\n            else {\n                var laneHeaderId = parent.parentId + swimlane.shape.lanes[0].id + '_0_header';\n                node.margin.top -= parentBounds.y - swimLaneBounds.y - diagram.nameTable[\"\" + laneHeaderId].wrapper.bounds.height;\n            }\n        }\n        var container = diagram.nameTable[parent.id];\n        if (!container.children) {\n            container.children = [];\n        }\n        if (container.children.indexOf(node.id) === -1) {\n            removeChildrenInLane(diagram, node);\n            if (diagram.getObject(node.id)) {\n                diagram.removeElements(node);\n            }\n            var undoObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(node);\n            diagram.addChild(container, child);\n            node = diagram.getObject(node.id);\n            if (container.isLane && container.parentId) {\n                swimlane = diagram.nameTable[container.parentId];\n                var lanes = swimlane.shape.lanes;\n                var canvasId = (container.id.slice(swimlane.id.length));\n                var currentParentId = canvasId.substring(0, canvasId.length - 1);\n                for (var i = 0; i < lanes.length; i++) {\n                    if (container.isLane && currentParentId === lanes[parseInt(i.toString(), 10)].id) {\n                        // eslint-disable-next-line\n                        if (!(node.parentObj instanceof _diagram__WEBPACK_IMPORTED_MODULE_2__.Diagram)) {\n                            // eslint-disable-next-line\n                            node.parentObj = lanes[parseInt(i.toString(), 10)];\n                        }\n                        // 878719: Resolve ESLint errors\n                        // eslint-disable-next-line no-prototype-builtins\n                        if (!diagram.nameTable.hasOwnProperty(node.id)) {\n                            lanes[parseInt(i.toString(), 10)].children.push(node);\n                        }\n                    }\n                }\n            }\n            diagram.updateDiagramObject(node);\n            moveSwinLaneChild(node, diagram);\n            if (!container.parentId) {\n                diagram.updateDiagramObject(container);\n            }\n            else if (!isUndo) {\n                if (!diagram.multiselect) {\n                    updateLaneBoundsAfterAddChild(container, swimlane, node, diagram);\n                }\n                else {\n                    (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.considerSwimLanePadding)(diagram, node, 20);\n                    diagram.updateDiagramElementQuad();\n                }\n            }\n            if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.DiagramAction.UndoRedo)) {\n                var entry = {\n                    type: 'ChildCollectionChanged', category: 'Internal',\n                    undoObject: undoObj, redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(node), historyAction: historyAction ? 'AddNodeToLane' : undefined\n                };\n                diagram.addHistoryEntry(entry);\n            }\n        }\n        else if (!isUndo && diagram.multiselect) {\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.considerSwimLanePadding)(diagram, node, 20);\n            diagram.updateDiagramElementQuad();\n        }\n        diagram.protectPropertyChange(false);\n    }\n}\nfunction moveSwinLaneChild(node, diagram) {\n    var sourceNode = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_7__.getDiagramElement)(node.id + '_groupElement', diagram.element.id);\n    var targetId = (node.parentId) ? node.parentId + '_groupElement' : diagram.element.id + '_diagramLayer';\n    var targetNode = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_7__.getDiagramElement)(targetId, diagram.element.id);\n    if (sourceNode && targetNode) {\n        targetNode.appendChild(sourceNode);\n    }\n}\nfunction updateLaneBoundsWithSelector(container, selector, diagram, isBoundsUpdate) {\n    var swimLane = diagram.nameTable[container.parentId];\n    var isSelector = true;\n    updateLaneBoundsAfterAddChild(container, swimLane, selector, diagram, isBoundsUpdate, isSelector);\n}\nfunction updateLaneBoundsAfterAddChild(container, swimLane, node, diagram, isBoundsUpdate, isSelector) {\n    var undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(container);\n    var isUpdateRow;\n    var isUpdateColumn;\n    var isGroupAction = false;\n    var padding = swimLane.shape.padding;\n    var containerBounds = container.wrapper.bounds;\n    var containerOuterBounds = container.wrapper.outerBounds;\n    var nodeBounds = node.wrapper.bounds;\n    if (swimLane && swimLane.shape.type === 'SwimLane' &&\n        (containerBounds.right < nodeBounds.right + padding ||\n            containerBounds.bottom < nodeBounds.bottom + padding || (isSelector && containerBounds.top > nodeBounds.top + padding))) {\n        var grid = swimLane.wrapper.children[0];\n        var x = grid.bounds.x;\n        var y = grid.bounds.y;\n        var size = void 0;\n        var headerSize = void 0;\n        // EJ2-913788 Drag and drop a node with more size than lane height and width\n        var isHeader = container.wrapper.children.find(function (child) { return child.id.includes('header'); });\n        var isHorizontal = (swimLane.shape.orientation === 'Horizontal');\n        if (containerBounds.right < nodeBounds.right + padding &&\n            containerOuterBounds.x <= containerBounds.x) {\n            if (isHorizontal && isHeader) {\n                headerSize = isHeader ? isHeader.width : 0;\n                size = (nodeBounds.right - containerBounds.right) + (containerBounds.left - nodeBounds.left) +\n                    headerSize + padding * 2;\n            }\n            else {\n                size = (nodeBounds.right - containerBounds.right) + (containerBounds.left - nodeBounds.left) + padding * 2;\n            }\n            // size = nodeBounds.right - containerBounds.right;\n            isUpdateColumn = true;\n            grid.updateColumnWidth(container.columnIndex, containerBounds.width + size, true, padding);\n        }\n        if (containerBounds.bottom < nodeBounds.bottom + padding &&\n            containerOuterBounds.y <= containerBounds.y) {\n            if (!isHorizontal && isHeader) {\n                headerSize = isHeader ? isHeader.height : 0;\n                size = (nodeBounds.bottom - containerBounds.bottom) + (containerBounds.top - nodeBounds.top) +\n                    headerSize + padding * 2;\n            }\n            else {\n                size = (nodeBounds.bottom - containerBounds.bottom) + (containerBounds.top - nodeBounds.top) + padding * 2;\n            }\n            // size = nodeBounds.bottom - containerBounds.bottom;\n            isUpdateRow = true;\n            grid.updateRowHeight(container.rowIndex, containerBounds.height + size, true, padding);\n        }\n        if (isSelector && containerBounds.top > nodeBounds.top - padding &&\n            containerOuterBounds.y <= containerBounds.y) {\n            if (!isHorizontal && isHeader) {\n                headerSize = isHeader ? isHeader.height : 0;\n                size = (containerBounds.top - nodeBounds.top) + (nodeBounds.bottom - containerBounds.bottom) +\n                    headerSize + padding * 2;\n            }\n            else {\n                size = (containerBounds.top - nodeBounds.top) + (nodeBounds.bottom - containerBounds.bottom) + padding * 2;\n            }\n            // Adjust the size based on the top boundary difference\n            if (size > 0) {\n                isUpdateRow = true;\n                grid.updateRowHeight(container.rowIndex, containerBounds.height + size, true, padding);\n            }\n        }\n        if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.DiagramAction.UndoRedo)) {\n            if (isBoundsUpdate) {\n                diagram.startGroupAction();\n                isGroupAction = true;\n            }\n            if (isUpdateRow) {\n                var entry = {\n                    category: 'Internal',\n                    type: 'RowHeightChanged',\n                    undoObject: undoObject, redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(container)\n                };\n                diagram.addHistoryEntry(entry);\n            }\n            if (isUpdateColumn) {\n                var entry = {\n                    category: 'Internal',\n                    type: 'ColumnWidthChanged',\n                    undoObject: undoObject, redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(container)\n                };\n                diagram.addHistoryEntry(entry);\n            }\n        }\n        swimLane.width = swimLane.wrapper.width = grid.width;\n        swimLane.height = swimLane.wrapper.height = grid.height;\n        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.swimLaneMeasureAndArrange)(swimLane);\n        if (swimLane.shape.orientation === 'Horizontal') {\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.updatePhaseMaxWidth)(swimLane, diagram, container.wrapper, container.columnIndex);\n        }\n        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.updateHeaderMaxWidth)(diagram, swimLane);\n        diagram.drag(swimLane, x - grid.bounds.x, y - grid.bounds.y);\n        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.checkPhaseOffset)(swimLane, diagram);\n        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.checkLaneSize)(swimLane);\n    }\n    if (!isSelector) {\n        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_8__.considerSwimLanePadding)(diagram, node, padding);\n    }\n    diagram.updateDiagramElementQuad();\n    return isGroupAction;\n}\n//#endregion\n//# reginon stack panel interaction\n/**\n * renderStackHighlighter method\\\n *\n * @returns {  void  }    renderStackHighlighter method .\\\n * @param {DiagramElement} element - provide the element value.\n * @param {boolean} isVertical - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {Diagram} diagram - provide the diagram value.\n * @param {boolean} isUml - provide the isUml value.\n * @param {boolean} isSwimlane - provide the isSwimlane value.\n * @private\n */\nfunction renderStackHighlighter(element, isVertical, position, diagram, isUml, isSwimlane) {\n    var adornerSvg = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_7__.getAdornerLayerSvg)(diagram.element.id);\n    diagram.diagramRenderer.renderStackHighlighter(element, adornerSvg, diagram.scroller.transform, isVertical, position, isUml, isSwimlane);\n}\n/**\n * moveChildInStack method\\\n *\n * @returns {  void }    moveChildInStack method .\\\n * @param {Node} sourceNode - provide the sourceNode value.\n * @param {Node} target - provide the target value.\n * @param {Diagram} diagram - provide the diagram value.\n * @param {Actions} action - provide the action value.\n * @private\n */\nfunction moveChildInStack(sourceNode, target, diagram, action) {\n    var obj = sourceNode;\n    var parent = diagram.nameTable[obj.parentId];\n    var sourceParent = diagram.nameTable[obj.parentId];\n    if (target && sourceParent && sourceParent.container && sourceParent.container.type === 'Stack' &&\n        target.container && target.container.type === 'Stack' && (sourceParent.id !== target.parentId)) {\n        var value = sourceParent.wrapper.children.indexOf(obj.wrapper);\n        if (value > -1) {\n            diagram.nameTable[obj.id].parentId = target.id;\n            sourceParent.wrapper.children.splice(value, 1);\n        }\n    }\n    if (target && target.parentId && obj.parentId && action === 'Drag' &&\n        sourceParent.container && sourceParent.container.type === 'Stack') {\n        var targetIndex = parent.wrapper.children.indexOf(target.wrapper);\n        var sourceIndex = parent.wrapper.children.indexOf(obj.wrapper);\n        var undoElement = {\n            targetIndex: targetIndex, target: target,\n            sourceIndex: sourceIndex, source: sourceNode\n        };\n        parent.wrapper.children.splice(sourceIndex, 1);\n        parent.wrapper.children.splice(targetIndex, 0, obj.wrapper);\n        var redoElement = {\n            targetIndex: sourceIndex, target: target,\n            sourceIndex: targetIndex, source: sourceNode\n        };\n        var entry = {\n            type: 'StackChildPositionChanged', redoObject: redoElement,\n            undoObject: undoElement, category: 'Internal'\n        };\n        diagram.commandHandler.addHistoryEntry(entry);\n    }\n}\n//#end region\n//# region Swimlane rendering\n//#end region\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js?");

/***/ })

}]);