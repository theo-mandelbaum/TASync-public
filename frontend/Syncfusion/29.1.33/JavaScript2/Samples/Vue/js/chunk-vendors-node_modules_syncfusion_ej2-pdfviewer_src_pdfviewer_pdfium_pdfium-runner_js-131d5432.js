"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_pdfium_pdfium-runner_js-131d5432"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdfium/pdfium-runner.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdfium/pdfium-runner.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PdfiumRunner: () => (/* binding */ PdfiumRunner)\n/* harmony export */ });\n/**\n *@returns {void}\n */\nfunction PdfiumRunner() {\n    var moduleString = 'Module';\n    var pageLoaded = false;\n    var moduleLoaded = false;\n    var FPDF = {};\n    // eslint-disable-next-line\n    var pdfiumWindow = pdfiumWindow ? pdfiumWindow : {};\n    var documentDetails;\n    var PDFiumModule = typeof (pdfiumWindow[\"\" + moduleString]) !== 'undefined' ? (pdfiumWindow[\"\" + moduleString]) : {};\n    var F64 = Float64Array;\n    var H = function (t, s, d) { return function (f) {\n        var _a = pdfiumWindow.heap(t, s), m = _a[0], a = _a.slice(1);\n        var v = f.apply(void 0, a.map(function (x) { return x.p; }));\n        if (!v) {\n            m.free();\n            return d;\n        }\n        var r = a.map(function (x) { return x.v; });\n        m.free();\n        return r;\n    }; };\n    Object.assign(FPDF, {\n        LCD_TEXT: 0x02,\n        NO_NATIVETEXT: 0x04,\n        GRAYSCALE: 0x08,\n        DEBUG_INFO: 0x80,\n        NO_CATCH: 0x100,\n        RENDER_LIMITEDIMAGECACHE: 0x200,\n        RENDER_FORCEHALFTONE: 0x400,\n        PRINTING: 0x800,\n        REVERSE_BYTE_ORDER: 0x10,\n        // eslint-disable-next-line\n        Bitmap_Gray: 1,\n        // eslint-disable-next-line\n        Bitmap_BGR: 2,\n        // eslint-disable-next-line\n        Bitmap_BGRx: 3,\n        // eslint-disable-next-line\n        Bitmap_BGRA: 4,\n        LAST_ERROR: {\n            SUCCESS: 0,\n            UNKNOWN: 1,\n            FILE: 2,\n            FORMAT: 3,\n            PASSWORD: 4,\n            SECURITY: 5,\n            PAGE: 6\n        }\n    });\n    /**\n     *@returns {void}\n     */\n    function initializeFPDF() {\n        FPDF.Init = PDFiumModule.cwrap('FPDF_InitLibrary');\n        FPDF.RenderPageBitmap = PDFiumModule.cwrap('FPDF_RenderPageBitmap', '', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);\n        // eslint-disable-next-line\n        FPDF.Bitmap_FillRect = PDFiumModule.cwrap('FPDFBitmap_FillRect', '', ['number', 'number', 'number', 'number', 'number', 'number']);\n        // eslint-disable-next-line\n        FPDF.Bitmap_CreateEx = PDFiumModule.cwrap('FPDFBitmap_CreateEx', 'number', ['number', 'number', 'number', 'number', 'number']);\n        // eslint-disable-next-line\n        FPDF.Bitmap_Destroy = PDFiumModule.cwrap('FPDFBitmap_Destroy', '', ['number']);\n        FPDF.LoadPage = PDFiumModule.cwrap('FPDF_LoadPage', 'number', ['number', 'number']);\n        FPDF.ClosePage = PDFiumModule.cwrap('FPDF_ClosePage', '', ['number']);\n        FPDF.LoadMemDocument = PDFiumModule.cwrap('FPDF_LoadMemDocument', 'number', ['number', 'number', 'string']);\n        FPDF.GetPageSizeByIndex = PDFiumModule.cwrap('FPDF_GetPageSizeByIndex', 'number', ['number', 'number', 'number', 'number']);\n        FPDF.GetLastError = PDFiumModule.cwrap('FPDF_GetLastError', 'number');\n        FPDF.GetPageCount = PDFiumModule.cwrap('FPDF_GetPageCount', 'number', ['number']);\n        FPDF.CloseDocument = PDFiumModule.cwrap('FPDF_CloseDocument', '', ['number']);\n        FPDF.DestroyLibrary = PDFiumModule.cwrap('FPDF_DestroyLibrary');\n        FPDF.LoadTextPage = PDFiumModule.cwrap('FPDFText_LoadPage', 'number', ['number']);\n        FPDF.CloseTextPage = PDFiumModule.cwrap('FPDFText_ClosePage', '', ['number']);\n        FPDF.TextCountChars = PDFiumModule.cwrap('FPDFText_CountChars', 'number', ['number']);\n        FPDF.GetUnicodeChar = PDFiumModule.cwrap('FPDFText_GetUnicode', 'number', ['number']);\n        FPDF.GetCharBox = PDFiumModule.cwrap('FPDFText_GetCharBox', 'number', ['number', 'number', 'number', 'number', 'number']);\n        FPDF.GetPageRotation = PDFiumModule.cwrap('FPDFPage_GetRotation', 'number', ['number']);\n        FPDF.GetCharAngle = PDFiumModule.cwrap('FPDFText_GetCharAngle', 'number', ['number']);\n        FPDF.TextFindStart = PDFiumModule.cwrap('FPDFText_FindStart', '', ['number', 'number', 'number', 'number']);\n        FPDF.TextFindClose = PDFiumModule.cwrap('FPDFText_FindClose', '', ['number']);\n        FPDF.TextFindNext = PDFiumModule.cwrap('FPDFText_FindNext', '', ['number']);\n        FPDF.TextFindResultIndex = PDFiumModule.cwrap('FPDFText_GetSchResultIndex', '', ['number']);\n        FPDF.TextFindCount = PDFiumModule.cwrap('FPDFText_GetSchCount', '', ['number']);\n        FPDF.GetPageHeight = PDFiumModule.cwrap('FPDF_GetPageHeight', 'number', ['number']);\n        FPDF.GetPageHeight = PDFiumModule.cwrap('FPDF_GetPageHeight', 'number', ['number']);\n        FPDF.GetPageWidth = PDFiumModule.cwrap('FPDF_GetPageWidth', 'number', ['number']);\n        pdfiumWindow.heap = function (J, s) {\n            var E;\n            switch (J) {\n                case Int8Array:\n                    E = PDFiumModule.HEAP8;\n                    break;\n                case Int16Array:\n                    E = PDFiumModule.HEAP16;\n                    break;\n                case Int32Array:\n                    E = PDFiumModule.HEAP32;\n                    break;\n                case Uint8Array:\n                    E = PDFiumModule.HEAPU8;\n                    break;\n                case Uint16Array:\n                    E = PDFiumModule.HEAPU16;\n                    break;\n                case Uint32Array:\n                    E = PDFiumModule.HEAPU32;\n                    break;\n                case Float32Array:\n                    E = PDFiumModule.HEAPF32;\n                    break;\n                case Float64Array:\n                    E = PDFiumModule.HEAPF64;\n                    break;\n            }\n            var Z = J.BYTES_PER_ELEMENT;\n            var m = PDFiumModule.asm.malloc(s * Z);\n            var a = Array(1 + s);\n            a[0] = ({ s: s, J: J, Z: Z, E: E, m: m, free: function () { return PDFiumModule.asm.free(m); } });\n            var _loop_1 = function (i) {\n                a[i + 1] = ({ p: m + (i * Z), get v() { return E[m / Z + i]; } });\n            };\n            for (var i = 0; i < s; i++) {\n                _loop_1(i);\n            }\n            return a;\n        };\n    }\n    /**\n     *@returns {void}\n     */\n    function checkIfEverythingWasLoaded() {\n        pageLoaded = true;\n        if (pageLoaded || moduleLoaded) {\n            startApp();\n        }\n    }\n    PDFiumModule.onRuntimeInitialized = function () {\n        moduleLoaded = true;\n        checkIfEverythingWasLoaded();\n    };\n    /**\n     *@returns {void}\n     */\n    function startApp() {\n        initializeFPDF();\n        if (pdfiumWindow.loaded) {\n            pdfiumWindow.loaded();\n        }\n    }\n    pdfiumWindow.onload = function () {\n        pageLoaded = true;\n        checkIfEverythingWasLoaded();\n    };\n    pdfiumWindow.loaded = function () {\n        ctx.postMessage({ message: 'loaded' });\n    };\n    var ctx = self;\n    ctx.onmessage = function (event) {\n        if (event.data.message === 'initialLoading') {\n            importScripts(event.data.url + '/pdfium.js');\n            PDFiumModule.url = event.data.url;\n            PDFiumModule.onRuntimeInitialized = function () {\n                moduleLoaded = true;\n                checkIfEverythingWasLoaded();\n                if (event.data.fonts && Object.keys(event.data.fonts).length > 0) {\n                    var filePath = '/usr/share/fonts/';\n                    PDFiumModule.FS.createPath('/', filePath, true, true);\n                    for (var key in event.data.fonts) {\n                        if (event.data.fonts[\"\" + key] && key.indexOf('fallbackfonts') === -1) {\n                            PDFiumModule.FS.createDataFile(filePath + key, null, event.data.fonts[\"\" + key], true, true, true);\n                        }\n                    }\n                }\n            };\n            this['PDFiumModule'](PDFiumModule);\n        }\n        else if (event.data.message === 'LoadPageCollection') {\n            pdfiumWindow.fileByteArray = event.data.uploadedFile;\n            var fileSize = pdfiumWindow.fileByteArray.length;\n            FPDF.Init();\n            var wasmBuffer = PDFiumModule.asm.malloc(fileSize);\n            PDFiumModule.HEAPU8.set(pdfiumWindow.fileByteArray, wasmBuffer);\n            pdfiumWindow.fileByteArray = null;\n            documentDetails = new DocumentInfo({\n                wasm: FPDF.LoadMemDocument(wasmBuffer, fileSize, event.data.password),\n                wasmBuffer: wasmBuffer\n            });\n            var pages = FPDF.GetPageCount(documentDetails.processor.wasmData.wasm);\n            documentDetails.setPages(pages);\n            documentDetails.createAllPages();\n            ctx.postMessage({ message: 'PageLoaded', pageIndex: event.data.pageIndex, isZoomMode: event.data.isZoomMode });\n        }\n        else if (event.data.message === 'LoadPageStampCollection') {\n            var fileSize = event.data.uploadedFile.length;\n            FPDF.Init();\n            var wasmBuffer = PDFiumModule.asm.malloc(fileSize);\n            PDFiumModule.HEAPU8.set(event.data.uploadedFile, wasmBuffer);\n            var documentDetailsNew = new DocumentInfo({\n                wasm: FPDF.LoadMemDocument(wasmBuffer, fileSize, event.data.password),\n                wasmBuffer: wasmBuffer\n            });\n            var pages = FPDF.GetPageCount(documentDetailsNew.processor.wasmData.wasm);\n            documentDetailsNew.setPages(pages);\n            documentDetailsNew.createAllPages();\n            var firstPage = documentDetailsNew.getPage(event.data.pageIndex);\n            var ImageData_1 = event.data;\n            var data = firstPage.render(null, ImageData_1.zoomFactor, false, null, null, null, true);\n            data.message = 'LoadedStamp';\n            data.annotName = event.data.AnnotName;\n            data.rubberStampAnnotationPageNumber = event.data.rubberStampAnnotationPageNumber;\n            data.annotationOrder = event.data.annotationOrder;\n            data.collectionOrder = event.data.collectionOrder;\n            data.isFormField = event.data.isFormField;\n            if (data.isFormField) {\n                data.message = 'LoadedStampForFormFields';\n                data.formFieldName = event.data.formFieldName;\n                data.formFieldList = event.data.formFieldList;\n                data.formFields = event.data.rubberStampAnnotation;\n                data.PageIndex = event.data.PageIndex;\n            }\n            ctx.postMessage(data);\n        }\n        if (documentDetails) {\n            if (event.data.message === 'renderPage') {\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var ImageData_2 = event.data;\n                var data = firstPage.render(null, ImageData_2.zoomFactor, ImageData_2.isTextNeed, null, null, ImageData_2.textDetailsId, null, event.data.cropBoxRect, event.data.mediaBoxRect);\n                ctx.postMessage(data);\n            }\n            else if (event.data.message === 'renderPageSearch') {\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var ImageData_3 = event.data;\n                var data = firstPage.render(null, ImageData_3.zoomFactor, ImageData_3.isTextNeed, null, null, ImageData_3.textDetailsId, null, event.data.cropBoxRect);\n                data.message = 'imageRenderedSearch';\n                ctx.postMessage(data);\n            }\n            else if (event.data.message.indexOf('extractText') !== -1) {\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var ImageData_4 = event.data;\n                var isSkipCharacterBounds = event.data.isSkipCharacterBounds;\n                var data = firstPage.render('extractText', ImageData_4.zoomFactor, ImageData_4.isTextNeed, null, null, ImageData_4.textDetailsId, null, null, null, null, isSkipCharacterBounds);\n                data.message = event.data.message;\n                data.isLayout = event.data.isLayout;\n                data.isRenderText = event.data.isRenderText;\n                data.jsonObject = event.data.jsonObject;\n                data.requestType = event.data.requestType;\n                data.annotationObject = event.data.annotationObject;\n                data.pageIndex = event.data.pageIndex;\n                data.options = event.data.options;\n                data.isAPI = event.data.isAPI;\n                data.isNeedToRender = event.data.isNeedToRender;\n                ctx.postMessage(data);\n            }\n            else if (event.data.message === 'searchText') {\n                var pagesCount = FPDF.GetPageCount(documentDetails.processor.wasmData.wasm);\n                var searchTerm = event.data.searchWord;\n                var buffer = new Uint16Array(searchTerm.length + 1);\n                for (var i = 0; i < searchTerm.length; i++) {\n                    buffer[parseInt(i.toString(), 10)] = searchTerm.charCodeAt(i);\n                }\n                buffer[searchTerm.length] = 0;\n                var pointer = PDFiumModule.asm.malloc(buffer.length * buffer.BYTES_PER_ELEMENT);\n                PDFiumModule.HEAPU16.set(buffer, pointer / Uint16Array.BYTES_PER_ELEMENT);\n                var occurrencesCount = 0;\n                var isMatchCase = (event.data.matchCase === true) ? 1 : 0;\n                var startIndex = event.data.startIndex;\n                var endIndex = event.data.endIndex;\n                var pageSearchCounts = {};\n                var _loop_2 = function (a) {\n                    var pageOccurrence = -1;\n                    var page = FPDF.LoadPage(documentDetails.processor.wasmData.wasm, a);\n                    var textPage = FPDF.LoadTextPage(page);\n                    var searchHandle = FPDF.TextFindStart(textPage, pointer, isMatchCase, 0);\n                    var pageHeight = FPDF.GetPageHeight(page);\n                    var _loop_3 = function () {\n                        occurrencesCount++;\n                        pageOccurrence++;\n                        var charLength = FPDF.TextFindCount(searchHandle);\n                        var startIndex_1 = FPDF.TextFindResultIndex(searchHandle);\n                        if (!pageSearchCounts[parseInt(a.toString(), 10)]) {\n                            pageSearchCounts[parseInt(a.toString(), 10)] = { Indices: [], Bounds: {}, pageOccurrence: 0 };\n                        }\n                        if (!pageSearchCounts[parseInt(a.toString(), 10)].Bounds[parseInt(pageOccurrence.toString(), 10)]) {\n                            pageSearchCounts[parseInt(a.toString(), 10)].Bounds[parseInt(pageOccurrence.toString(), 10)] = [];\n                        }\n                        pageSearchCounts[parseInt(a.toString(), 10)].Indices.push(startIndex_1);\n                        var charLeft = Number.POSITIVE_INFINITY;\n                        var charRight = 0;\n                        var charBottom = Number.POSITIVE_INFINITY;\n                        var charTop = 0;\n                        var _loop_4 = function (i) {\n                            var resultPage = FPDF.GetUnicodeChar(textPage, startIndex_1 + i);\n                            var character = String.fromCharCode(resultPage);\n                            if (character !== '\\r') {\n                                if (character !== '\\n') {\n                                    var result_1 = H(F64, 4, [-1, -1, -1, -1])(function (left, right, bottom, top) {\n                                        return FPDF.GetCharBox(textPage, startIndex_1 + i, left, right, bottom, top);\n                                    });\n                                    charLeft = Math.min(charLeft, result_1[0]);\n                                    charRight = Math.max(charRight, result_1[1]);\n                                    charBottom = Math.min(charBottom, result_1[2]);\n                                    charTop = Math.max(charTop, result_1[3]);\n                                }\n                            }\n                            if (character === '\\r') {\n                                var characterBounds_1 = new RectAngle((charLeft * (96 / 72)), ((pageHeight - (charTop - charBottom) - charBottom) * (96 / 72)), ((charRight - charLeft) * (96 / 72)), ((charTop - charBottom) * (96 / 72)), '', null);\n                                pageSearchCounts[parseInt(a.toString(), 10)].Bounds[parseInt(pageOccurrence.toString(), 10)]\n                                    .push(characterBounds_1);\n                                pageSearchCounts[parseInt(a.toString(), 10)].Bounds[parseInt(pageOccurrence.toString(), 10)].sort(function (a, b) {\n                                    return a.Top === b.Top ? a.Left - b.Left : a.Top - b.Top;\n                                });\n                                charLeft = Number.POSITIVE_INFINITY;\n                                charRight = 0;\n                                charBottom = Number.POSITIVE_INFINITY;\n                                charTop = 0;\n                            }\n                        };\n                        for (var i = 0; i < charLength; i++) {\n                            _loop_4(i);\n                        }\n                        var characterBounds = new RectAngle((charLeft * (96 / 72)), ((pageHeight - (charTop - charBottom) - charBottom) * (96 / 72)), ((charRight - charLeft) * (96 / 72)), ((charTop - charBottom) * (96 / 72)), '', null);\n                        pageSearchCounts[parseInt(a.toString(), 10)].Bounds[parseInt(pageOccurrence.toString(), 10)].push(characterBounds);\n                        pageSearchCounts[parseInt(a.toString(), 10)].Bounds[parseInt(pageOccurrence.toString(), 10)].sort(function (a, b) {\n                            return a.Top === b.Top ? a.Left - b.Left : a.Top - b.Top;\n                        });\n                        pageSearchCounts[parseInt(a.toString(), 10)].pageOccurrence = pageOccurrence + 1;\n                    };\n                    while (FPDF.TextFindNext(searchHandle)) {\n                        _loop_3();\n                    }\n                    FPDF.TextFindClose(searchHandle);\n                    FPDF.ClosePage(page);\n                };\n                for (var a = startIndex; a < endIndex; a++) {\n                    _loop_2(a);\n                }\n                var result = {\n                    totalSearchCount: occurrencesCount,\n                    resultPages: pageSearchCounts,\n                    message: 'textSearched',\n                    searchWord: searchTerm,\n                    matchCase: event.data.matchCase,\n                    isRequestsend: event.data.isRequestsend,\n                    isCompletedSearch: (endIndex === pagesCount) ? true : false,\n                    endIndex: endIndex\n                };\n                ctx.postMessage(result);\n                pageSearchCounts = {};\n                PDFiumModule.asm.free(pointer);\n            }\n            else if (event.data.message === 'renderThumbnail') {\n                // eslint-disable-next-line\n                var thumbnail = new Promise(function (resolve, reject) {\n                    try {\n                        var firstPage = documentDetails.getPage(event.data.pageIndex);\n                        if (firstPage.processor !== null && firstPage.processor !== undefined) {\n                            var data = firstPage.render('thumbnail', null, event.data.isTextNeed, null, null, null, null, null, null, null, event.data.isSkipCharacterBounds);\n                            data.isRenderText = event.data.isRenderText;\n                            data.jsonObject = event.data.jsonObject;\n                            data.requestType = event.data.requestType;\n                            resolve(data);\n                        }\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                });\n                thumbnail.then(function (results) {\n                    ctx.postMessage(results);\n                });\n            }\n            else if (event.data.message === 'renderPreviewTileImage') {\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var data = firstPage.render('thumbnail', null, event.data.isTextNeed, null, null, null, null, null, null, null, event.data.isSkipCharacterBounds);\n                data.message = 'renderPreviewTileImage';\n                data.isRenderText = event.data.isRenderText;\n                data.jsonObject = event.data.jsonObject;\n                data.requestType = event.data.requestType;\n                data.startIndex = event.data.startIndex;\n                data.endIndex = event.data.endIndex;\n                ctx.postMessage(data);\n            }\n            else if (event.data.message === 'printImage') {\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var data = firstPage.render('print', null, false, event.data.printScaleFactor, event.data.printDevicePixelRatio);\n                ctx.postMessage(data);\n            }\n            else if (event.data.message === 'extractImage' || event.data.message === 'extractImages') {\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var ImageData_5 = event.data;\n                var data = firstPage.render(null, ImageData_5.zoomFactor, ImageData_5.isTextNeed, null, null, ImageData_5.textDetailsId, null, null, null, event.data.size);\n                if (event.data.message === 'extractImage') {\n                    data.message = 'imageExtracted';\n                }\n                if (event.data.message === 'extractImages') {\n                    data.message = 'imagesExtracted';\n                }\n                ctx.postMessage(data);\n            }\n            else if (event.data.message === 'renderImageAsTile') {\n                var values = event.data;\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var data = firstPage.renderTileImage(values.tileX, values.tileY, values.tileXCount, values.tileYCount, values.zoomFactor, event.data.isTextNeed, event.data.textDetailsId, event.data.cropBoxRect, event.data.mediaBoxRect);\n                ctx.postMessage(data);\n            }\n            else if (event.data.message === 'renderImageAsTileSearch') {\n                var values = event.data;\n                var firstPage = documentDetails.getPage(event.data.pageIndex);\n                var data = firstPage.renderTileImage(values.tileX, values.tileY, values.tileXCount, values.tileYCount, values.zoomFactor, event.data.isTextNeed, event.data.textDetailsId, event.data.cropBoxRect, event.data.mediaBoxRect);\n                data.message = 'renderTileImageSearch';\n                ctx.postMessage(data);\n            }\n            else if (event.data.message === 'unloadFPDF') {\n                if (documentDetails) {\n                    PDFiumModule.asm.free(documentDetails.processor.wasmData.wasmBuffer);\n                    FPDF.CloseDocument(documentDetails.processor.wasmData.wasm);\n                    FPDF.DestroyLibrary();\n                }\n            }\n        }\n        if (event.data.message === 'unloadFPDF') {\n            ctx.postMessage({ message: '' });\n        }\n    };\n    var Page = /** @class */ (function () {\n        function Page(index, processor) {\n            this.index = index;\n            this.src = null;\n            this.processor = processor;\n        }\n        Page.prototype.render = function (message, zoomFactor, isTextNeed, printScaleFactor, printDevicePixelRatio, textDetailsId, isTransparent, cropBoxRect, mediaBoxRect, size, isSkipCharacterBounds) {\n            return this.processor.render(this.index, message, zoomFactor, isTextNeed, printScaleFactor, printDevicePixelRatio, textDetailsId, isTransparent, cropBoxRect, mediaBoxRect, size, isSkipCharacterBounds);\n        };\n        Page.prototype.renderTileImage = function (x, y, tileX, tileY, zoomFactor, isTextNeed, textDetailsId, cropBoxRect, mediaBoxRect) {\n            return this.processor.renderTileImage(this.index, x, y, tileX, tileY, zoomFactor, isTextNeed, textDetailsId, cropBoxRect, mediaBoxRect);\n        };\n        return Page;\n    }());\n    var RectAngle = /** @class */ (function () {\n        function RectAngle(X, Y, Width, Height, Text, Rotation) {\n            this.X = X;\n            this.Y = Y;\n            this.Width = Width;\n            this.Height = Height;\n            this.Bottom = this.Y + this.Height;\n            this.Right = this.X + this.Width;\n            this.Top = this.Y;\n            this.Left = this.X;\n            this.Rotation = Rotation;\n            this.Text = Text;\n        }\n        return RectAngle;\n    }());\n    var Processor = /** @class */ (function () {\n        function Processor(wasmData) {\n            this.TextBounds = [];\n            this.TextContent = [];\n            this.CharacterBounds = [];\n            this.PageText = '';\n            this.wasmData = wasmData;\n        }\n        Processor.prototype.getPageSize = function (i) {\n            var _this = this;\n            if (i === void 0) { i = 0; }\n            return H(F64, 2, [-1, -1])(function (w, h) { return FPDF.GetPageSizeByIndex(_this.wasmData.wasm, i, w, h); }).\n                map(function (v) { return parseInt((v * (96 / 72)).toString(), 10); });\n        };\n        Processor.prototype.getCharBounds = function (pagePointer, i) {\n            if (i === void 0) { i = 0; }\n            return H(F64, 4, [-1, -1, -1, -1])(function (left, right, bottom, top) { return FPDF.\n                GetCharBox(pagePointer, i, left, right, bottom, top); });\n        };\n        Processor.prototype.getRender = function (i, w, h, isTextNeed, isTransparent, cropBoxRect, mediaBoxRect, isSkipCharacterBounds) {\n            if (i === void 0) { i = 0; }\n            var flag = FPDF.REVERSE_BYTE_ORDER;\n            var heap = PDFiumModule.asm.malloc(w * h * 4);\n            PDFiumModule.HEAPU8.fill(0, heap, heap + (w * h * 4));\n            var bmap = FPDF.Bitmap_CreateEx(w, h, FPDF.Bitmap_BGRA, heap, w * 4);\n            var page = FPDF.LoadPage(this.wasmData.wasm, i);\n            FPDF.Bitmap_FillRect(bmap, 0, 0, w, h, isTransparent ? 0x00FFFFFF : 0xFFFFFFFF);\n            FPDF.RenderPageBitmap(bmap, page, 0, 0, w, h, 0, flag);\n            FPDF.Bitmap_Destroy(bmap);\n            this.textExtraction(page, i, isTextNeed, cropBoxRect, mediaBoxRect, isSkipCharacterBounds);\n            FPDF.ClosePage(page);\n            return heap;\n        };\n        Processor.prototype.textExtraction = function (pagePointer, pageIndex, isTextNeed, cropBoxRect, mediaBoxRect, isSkipCharacterBounds) {\n            var _a;\n            if (isTextNeed) {\n                // eslint-disable-next-line\n                var _b = this.getPageSize(pageIndex), pageWidth = _b[0], pageHeight = _b[1];\n                pageHeight = pageHeight + this.pointerToPixelConverter(mediaBoxRect && mediaBoxRect.y ? mediaBoxRect.y : 0);\n                var textPage = FPDF.LoadTextPage(pagePointer, pageIndex);\n                var pageRotation = FPDF.GetPageRotation(pagePointer);\n                var totalCharacterCount = FPDF.TextCountChars(textPage);\n                this.TextBounds = [];\n                this.TextContent = [];\n                this.CharacterBounds = [];\n                var pageText = '';\n                var minTop = 0;\n                var maxBottom = 0;\n                var minLeft = 0;\n                var maxRight = 0;\n                var top_1 = [];\n                var bottom = [];\n                var left = [];\n                var right = [];\n                var wordBounds = [];\n                var word = '';\n                var wordMinLeft = 0;\n                var wordMaxRight = 0;\n                var wordMinTop = 0;\n                var wordMaxBottom = 0;\n                var wordRotation = 0;\n                var wordStart = true;\n                var isZeroWidthSpace = false;\n                var isPreviousSpace = false;\n                var startNewLine = false;\n                var maximumSpaceForNewLine = 11;\n                for (var charCount = 0; charCount <= totalCharacterCount; charCount++) {\n                    if (!isSkipCharacterBounds) {\n                        var result = FPDF.GetUnicodeChar(textPage, charCount);\n                        var rotationRadian = FPDF.GetCharAngle(textPage, charCount);\n                        var character = String.fromCharCode(result);\n                        var _c = this.getCharBounds(textPage, charCount), charLeft = _c[0], charRight = _c[1], charBottom = _c[2], charTop = _c[3];\n                        var X = this.pointerToPixelConverter(charLeft) -\n                            this.pointerToPixelConverter(cropBoxRect && cropBoxRect.x ? cropBoxRect.x : 0);\n                        var Y = (pageHeight + this.pointerToPixelConverter(cropBoxRect && cropBoxRect.y ? cropBoxRect.y : 0)) -\n                            this.pointerToPixelConverter(charTop);\n                        var Width = this.pointerToPixelConverter(charRight - charLeft);\n                        var Height = this.pointerToPixelConverter(charTop - charBottom);\n                        var rotationAngle = parseInt((rotationRadian * 180 / Math.PI).toString(), 10);\n                        if (charCount < totalCharacterCount) {\n                            pageText += character;\n                            var currentCharacterBounds = new RectAngle(X, Y, Width, Height, character, rotationAngle);\n                            this.CharacterBounds.push(currentCharacterBounds);\n                        }\n                        if (pageRotation === 1 || pageRotation === 3) {\n                            Y = (pageWidth) - this.pointerToPixelConverter(charTop);\n                        }\n                        switch (character) {\n                            case '\\0': {\n                                // eslint-disable-next-line\n                                minTop = Math.min.apply(Math, top_1);\n                                // eslint-disable-next-line\n                                maxBottom = Math.max.apply(Math, bottom);\n                                // eslint-disable-next-line\n                                minLeft = Math.min.apply(Math, left);\n                                // eslint-disable-next-line\n                                maxRight = Math.max.apply(Math, right);\n                                var newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                wordBounds.push(newWordBounds);\n                                this.textBoundsCalculation(wordBounds, minTop, maxBottom, maxRight, minLeft, pageRotation, pageWidth, pageHeight);\n                                wordBounds = [];\n                                wordStart = true;\n                                isPreviousSpace = false;\n                                word = '';\n                                top_1 = [];\n                                left = [];\n                                bottom = [];\n                                right = [];\n                                minTop = 0;\n                                maxBottom = 0;\n                                minLeft = 0;\n                                maxRight = 0;\n                                break;\n                            }\n                            case '\\r':\n                                if (charCount < totalCharacterCount) {\n                                    var characterBounds = new RectAngle(X, Y, Width, Height, '\\r\\n', rotationAngle);\n                                    top_1.push(characterBounds.Top);\n                                    bottom.push(characterBounds.Bottom);\n                                    left.push(characterBounds.Left);\n                                    right.push(characterBounds.Right);\n                                    // eslint-disable-next-line\n                                    minTop = Math.min.apply(Math, top_1);\n                                    // eslint-disable-next-line\n                                    maxBottom = Math.max.apply(Math, bottom);\n                                    // eslint-disable-next-line\n                                    minLeft = Math.min.apply(Math, left);\n                                    // eslint-disable-next-line\n                                    maxRight = Math.max.apply(Math, right);\n                                    var newWordBounds = void 0;\n                                    if (wordStart === false) {\n                                        newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                        wordBounds.push(newWordBounds);\n                                    }\n                                    wordBounds.push(characterBounds);\n                                    this.textBoundsCalculation(wordBounds, minTop, maxBottom, maxRight, minLeft, pageRotation, pageWidth, pageHeight);\n                                    wordBounds = [];\n                                    wordStart = true;\n                                    isPreviousSpace = false;\n                                    word = '';\n                                    top_1 = [];\n                                    left = [];\n                                    bottom = [];\n                                    right = [];\n                                    minTop = 0;\n                                    maxBottom = 0;\n                                    minLeft = 0;\n                                    maxRight = 0;\n                                    pageText += '\\n';\n                                    rotationRadian = FPDF.GetCharAngle(textPage, charCount);\n                                    _a = this.getCharBounds(textPage, charCount), charLeft = _a[0], charRight = _a[1], charBottom = _a[2], charTop = _a[3];\n                                    X = this.pointerToPixelConverter(charLeft);\n                                    Y = (pageHeight) - this.pointerToPixelConverter(charTop);\n                                    Width = this.pointerToPixelConverter(charRight - charLeft);\n                                    Height = this.pointerToPixelConverter(charTop - charBottom);\n                                    rotationAngle = parseInt((rotationRadian * 180 / Math.PI).toString(), 10);\n                                    var currentCharacterBounds = new RectAngle(X, Y, Width, Height, character, rotationAngle);\n                                    this.CharacterBounds.push(currentCharacterBounds);\n                                    charCount++;\n                                }\n                                break;\n                            case '\\u0002':\n                            case '\\ufffe':\n                                {\n                                    var characterBounds = new RectAngle(X, Y, Width, Height, character, rotationAngle);\n                                    top_1.push(characterBounds.Top);\n                                    bottom.push(characterBounds.Bottom);\n                                    left.push(characterBounds.Left);\n                                    right.push(characterBounds.Right);\n                                    // eslint-disable-next-line\n                                    minTop = Math.min.apply(Math, top_1);\n                                    // eslint-disable-next-line\n                                    maxBottom = Math.max.apply(Math, bottom);\n                                    // eslint-disable-next-line\n                                    minLeft = Math.min.apply(Math, left);\n                                    // eslint-disable-next-line\n                                    maxRight = Math.max.apply(Math, right);\n                                    var newWordBounds = void 0;\n                                    if (wordStart === false) {\n                                        newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                        wordBounds.push(newWordBounds);\n                                    }\n                                    if (character === '\\u0002') {\n                                        wordBounds.push(characterBounds);\n                                    }\n                                    this.textBoundsCalculation(wordBounds, minTop, maxBottom, maxRight, minLeft, pageRotation, pageWidth, pageHeight);\n                                    wordBounds = [];\n                                    wordStart = true;\n                                    isPreviousSpace = false;\n                                    word = '';\n                                    top_1 = [];\n                                    left = [];\n                                    bottom = [];\n                                    right = [];\n                                    minTop = 0;\n                                    maxBottom = 0;\n                                    minLeft = 0;\n                                    maxRight = 0;\n                                }\n                                break;\n                            default:\n                                if (Width === 0 || Height === 0) {\n                                    isZeroWidthSpace = true;\n                                    // eslint-disable-next-line\n                                    minTop = Math.min.apply(Math, top_1);\n                                    // eslint-disable-next-line\n                                    maxBottom = Math.max.apply(Math, bottom);\n                                    // eslint-disable-next-line\n                                    minLeft = Math.min.apply(Math, left);\n                                    // eslint-disable-next-line\n                                    maxRight = Math.max.apply(Math, right);\n                                    var newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                    wordBounds.push(newWordBounds);\n                                    var characterBounds = new RectAngle(X, Y, Width, Height, character, rotationAngle);\n                                    wordMinTop = characterBounds.Top;\n                                    wordMaxBottom = characterBounds.Bottom;\n                                    wordMinLeft = characterBounds.Left;\n                                    wordMaxRight = characterBounds.Right;\n                                    word = character;\n                                    wordRotation = wordBounds[wordBounds.length - 1].Rotation;\n                                    newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                    wordBounds.push(newWordBounds);\n                                    wordMinTop = 0;\n                                    wordMaxBottom = 0;\n                                    wordMinLeft = 0;\n                                    wordMaxRight = 0;\n                                    word = '';\n                                    wordRotation = 0;\n                                    wordStart = true;\n                                    isPreviousSpace = true;\n                                }\n                                else {\n                                    if (wordStart === true) {\n                                        wordMinTop = Y;\n                                        wordMaxBottom = Y + Height;\n                                        wordMinLeft = X;\n                                        wordMaxRight = X + Width;\n                                    }\n                                    var characterBounds = new RectAngle(X, Y, Width, Height, character, rotationAngle);\n                                    if (character !== ' ') {\n                                        if (isPreviousSpace && wordBounds.length > 0 && (rotationAngle === wordBounds[0].Rotation)) {\n                                            if ((rotationAngle === 180 || rotationAngle === 0) &&\n                                                (Math.abs(characterBounds.Y - wordBounds[0].Y) > maximumSpaceForNewLine)) {\n                                                startNewLine = true;\n                                            }\n                                            if ((rotationAngle === 270 || rotationAngle === 90) &&\n                                                (Math.abs(characterBounds.X - wordBounds[0].X) > maximumSpaceForNewLine)) {\n                                                startNewLine = true;\n                                            }\n                                        }\n                                        if ((isZeroWidthSpace && wordBounds.length >= 1 &&\n                                            wordBounds[wordBounds.length - 1].Rotation !== characterBounds.Rotation) || startNewLine) {\n                                            isZeroWidthSpace = false;\n                                            startNewLine = false;\n                                            // eslint-disable-next-line\n                                            minTop = Math.min.apply(Math, top_1);\n                                            // eslint-disable-next-line\n                                            maxBottom = Math.max.apply(Math, bottom);\n                                            // eslint-disable-next-line\n                                            minLeft = Math.min.apply(Math, left);\n                                            // eslint-disable-next-line\n                                            maxRight = Math.max.apply(Math, right);\n                                            var newWordBounds = void 0;\n                                            if (wordStart === false) {\n                                                newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                                wordBounds.push(newWordBounds);\n                                            }\n                                            this.textBoundsCalculation(wordBounds, minTop, maxBottom, maxRight, minLeft, pageRotation, pageWidth, pageHeight);\n                                            wordBounds = [];\n                                            wordStart = true;\n                                            word = '';\n                                            top_1 = [];\n                                            left = [];\n                                            bottom = [];\n                                            right = [];\n                                            minTop = 0;\n                                            maxBottom = 0;\n                                            minLeft = 0;\n                                            maxRight = 0;\n                                        }\n                                        top_1.push(characterBounds.Top);\n                                        bottom.push(characterBounds.Bottom);\n                                        left.push(characterBounds.Left);\n                                        right.push(characterBounds.Right);\n                                        wordMinTop = Math.min(wordMinTop, characterBounds.Top);\n                                        wordMaxBottom = Math.max(wordMaxBottom, characterBounds.Bottom);\n                                        wordMinLeft = Math.min(wordMinLeft, characterBounds.Left);\n                                        wordMaxRight = Math.max(wordMaxRight, characterBounds.Right);\n                                        word += character;\n                                        wordRotation = characterBounds.Rotation;\n                                        wordStart = false;\n                                        isPreviousSpace = false;\n                                    }\n                                    else {\n                                        var newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                        wordBounds.push(newWordBounds);\n                                        wordMinTop = characterBounds.Top;\n                                        wordMaxBottom = characterBounds.Bottom;\n                                        wordMinLeft = characterBounds.Left;\n                                        wordMaxRight = characterBounds.Right;\n                                        word = character;\n                                        wordRotation = characterBounds.Rotation;\n                                        newWordBounds = new RectAngle(wordMinLeft, wordMinTop, wordMaxRight - wordMinLeft, wordMaxBottom - wordMinTop, word, wordRotation);\n                                        wordBounds.push(newWordBounds);\n                                        wordMinTop = 0;\n                                        wordMaxBottom = 0;\n                                        wordMinLeft = 0;\n                                        wordMaxRight = 0;\n                                        word = '';\n                                        wordRotation = 0;\n                                        wordStart = true;\n                                        isPreviousSpace = true;\n                                    }\n                                }\n                                break;\n                        }\n                    }\n                    else {\n                        var result = FPDF.GetUnicodeChar(textPage, charCount);\n                        var character = String.fromCharCode(result);\n                        if (charCount < totalCharacterCount) {\n                            pageText += character;\n                        }\n                    }\n                }\n                FPDF.CloseTextPage(textPage);\n                this.Rotation = pageRotation;\n                this.PageText = pageText;\n            }\n        };\n        Processor.prototype.pointerToPixelConverter = function (pointerValue) {\n            return (pointerValue * (96 / 72));\n        };\n        Processor.prototype.textBoundsCalculation = function (wordBounds, minTop, maxBottom, maxRight, minLeft, pageRotation, pageWidth, pageHeight) {\n            var newWordBounds;\n            var hasInBetweenRotation = false;\n            var inBetweenRotatedText = '';\n            var maximumSpaceBetweenWords = 30;\n            var sentence = wordBounds.reduce(function (word, rect) { return word + rect.Text; }, '');\n            var isRTLText = this.checkIsRtlText(sentence);\n            for (var count = 0; count < wordBounds.length; count++) {\n                var textRotation = wordBounds[parseInt(count.toString(), 10)].Rotation;\n                if (textRotation === 0 || textRotation === 180) {\n                    if (hasInBetweenRotation) {\n                        this.TextBounds.push(newWordBounds);\n                        this.TextContent.push(inBetweenRotatedText);\n                        inBetweenRotatedText = '';\n                    }\n                    hasInBetweenRotation = false;\n                    if (pageRotation === 0) {\n                        newWordBounds = new RectAngle(wordBounds[parseInt(count.toString(), 10)].Left, minTop, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 1) {\n                        newWordBounds = new RectAngle(pageWidth - minTop, wordBounds[parseInt(count.toString(), 10)].Left, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 2) {\n                        newWordBounds = new RectAngle(pageWidth - wordBounds[parseInt(count.toString(), 10)].Left, pageHeight - minTop, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 3) {\n                        newWordBounds = new RectAngle(minTop, pageHeight - wordBounds[parseInt(count.toString(), 10)].Left, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                }\n                else if (textRotation === 90 || textRotation === 270) {\n                    if (hasInBetweenRotation) {\n                        this.TextBounds.push(newWordBounds);\n                        this.TextContent.push(inBetweenRotatedText);\n                        inBetweenRotatedText = '';\n                    }\n                    hasInBetweenRotation = false;\n                    if (pageRotation === 0) {\n                        newWordBounds = new RectAngle(minLeft, wordBounds[parseInt(count.toString(), 10)].Top, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 1) {\n                        newWordBounds = new RectAngle(pageWidth - wordBounds[parseInt(count.toString(), 10)].Top, minLeft, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 2) {\n                        newWordBounds = new RectAngle(pageWidth - minLeft, pageHeight - wordBounds[parseInt(count.toString(), 10)].Top, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 3) {\n                        newWordBounds = new RectAngle(wordBounds[parseInt(count.toString(), 10)].Top, pageHeight - minLeft, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                }\n                else if (!hasInBetweenRotation) {\n                    hasInBetweenRotation = true;\n                    inBetweenRotatedText += wordBounds[parseInt(count.toString(), 10)].Text;\n                    if (pageRotation === 0) {\n                        newWordBounds = new RectAngle(wordBounds[parseInt(count.toString(), 10)].Left, minTop, maxRight - minLeft, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 1) {\n                        newWordBounds = new RectAngle(pageWidth - minTop, wordBounds[parseInt(count.toString(), 10)].Left, maxRight - minLeft, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 2) {\n                        newWordBounds = new RectAngle(pageWidth - wordBounds[parseInt(count.toString(), 10)].Left, pageHeight - minTop, maxRight - minLeft, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                    else if (pageRotation === 3) {\n                        newWordBounds = new RectAngle(minTop, pageHeight - wordBounds[parseInt(count.toString(), 10)].Left, maxRight - minLeft, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                    }\n                }\n                else {\n                    inBetweenRotatedText += wordBounds[parseInt(count.toString(), 10)].Text;\n                }\n                if (!hasInBetweenRotation && wordBounds[parseInt(count.toString(), 10)].Text === ' ' && count !== 0 && count + 1 <= wordBounds.length) {\n                    if (!isRTLText) {\n                        if (count + 1 !== wordBounds.length) {\n                            var spaceWidth = 0;\n                            switch (textRotation) {\n                                case 0:\n                                    spaceWidth = wordBounds[count + 1].Left - (wordBounds[count - 1].Left + wordBounds[count - 1].Width);\n                                    if (maximumSpaceBetweenWords < spaceWidth || spaceWidth < 0) {\n                                        spaceWidth = 0;\n                                    }\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(wordBounds[count - 1].Left + wordBounds[count - 1].Width, minTop, spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle(pageWidth - minTop, wordBounds[count - 1].Left + wordBounds[count - 1].Width, spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count - 1].Left +\n                                            wordBounds[count - 1].Width), pageHeight - minTop, spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle(minTop, pageHeight - (wordBounds[count - 1].Left +\n                                            wordBounds[count - 1].Width), spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                                case 90:\n                                    spaceWidth = wordBounds[count + 1].Top - (wordBounds[count - 1].Top + wordBounds[count - 1].Height);\n                                    if (maximumSpaceBetweenWords < spaceWidth || spaceWidth < 0) {\n                                        spaceWidth = 0;\n                                    }\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(minLeft, wordBounds[count - 1].Top + wordBounds[count - 1].Height, maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count - 1].Top +\n                                            wordBounds[count - 1].Height), minLeft, maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - minLeft, pageHeight - (wordBounds[count - 1].Top +\n                                            wordBounds[count - 1].Height), maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle((wordBounds[count - 1].Top + wordBounds[count - 1].Height), pageHeight - minLeft, maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                                case 180:\n                                    spaceWidth = wordBounds[count - 1].Left - (wordBounds[count + 1].Left + wordBounds[count + 1].Width);\n                                    if (maximumSpaceBetweenWords < spaceWidth || spaceWidth < 0) {\n                                        spaceWidth = 0;\n                                    }\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(wordBounds[count + 1].Left + wordBounds[count + 1].Width, minTop, spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle(pageWidth - minTop, wordBounds[count + 1].Left +\n                                            wordBounds[count + 1].Width, spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count + 1].Left +\n                                            wordBounds[count + 1].Width), pageHeight - minTop, spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle(minTop, pageHeight - (wordBounds[count + 1].Left +\n                                            wordBounds[count + 1].Width), spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                                case 270:\n                                    spaceWidth = wordBounds[count - 1].Top - (wordBounds[count + 1].Top + wordBounds[count + 1].Height);\n                                    if (maximumSpaceBetweenWords < spaceWidth || spaceWidth < 0) {\n                                        spaceWidth = 0;\n                                    }\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(minLeft, wordBounds[count + 1].Top + wordBounds[count + 1].Height, maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count + 1].Top +\n                                            wordBounds[count + 1].Height), minLeft, maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - minLeft, pageHeight -\n                                            (wordBounds[count + 1].Top + wordBounds[count + 1].Height), maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle((wordBounds[count + 1].Top + wordBounds[count + 1].Height), pageHeight - minLeft, maxRight - minLeft, spaceWidth, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                            }\n                        }\n                        else {\n                            switch (textRotation) {\n                                case 90:\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(minLeft, wordBounds[count - 1].Top + wordBounds[count - 1].Height, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count - 1].Top +\n                                            wordBounds[count - 1].Height), minLeft, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - minLeft, pageHeight -\n                                            (wordBounds[count - 1].Top + wordBounds[count - 1].Height), maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle((wordBounds[count - 1].Top + wordBounds[count - 1].Height), pageHeight - minLeft, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                                case 270:\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(minLeft, wordBounds[count - 1].Top -\n                                            wordBounds[parseInt(count.toString(), 10)].Height, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count - 1].Top -\n                                            wordBounds[parseInt(count.toString(), 10)].Height), minLeft, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - minLeft, pageHeight -\n                                            wordBounds[count - 1].Top - wordBounds[parseInt(count.toString(), 10)].Height, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle((wordBounds[count - 1].Top -\n                                            wordBounds[parseInt(count.toString(), 10)].Height), pageHeight - minLeft, maxRight - minLeft, wordBounds[parseInt(count.toString(), 10)].Height, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                                case 180:\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(wordBounds[count - 1].Left -\n                                            wordBounds[parseInt(count.toString(), 10)].Width, minTop, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle((pageWidth - minTop), wordBounds[count - 1].Left -\n                                            wordBounds[parseInt(count.toString(), 10)].Width, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count - 1].Left -\n                                            wordBounds[parseInt(count.toString(), 10)].Width), pageHeight - minTop, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle(minTop, pageHeight - (wordBounds[count - 1].Left -\n                                            wordBounds[parseInt(count.toString(), 10)].Width), wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                                case 0:\n                                    if (pageRotation === 0) {\n                                        newWordBounds = new RectAngle(wordBounds[count - 1].Left + wordBounds[count - 1].Width, minTop, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 1) {\n                                        newWordBounds = new RectAngle(pageWidth - minTop, wordBounds[count - 1].Left +\n                                            wordBounds[count - 1].Width, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 2) {\n                                        newWordBounds = new RectAngle(pageWidth - (wordBounds[count - 1].Left +\n                                            wordBounds[count - 1].Width), pageHeight - minTop, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    else if (pageRotation === 3) {\n                                        newWordBounds = new RectAngle(minTop, pageHeight - (wordBounds[count - 1].Left +\n                                            wordBounds[count - 1].Width), wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, textRotation);\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                    else if (isRTLText && count + 1 !== wordBounds.length) {\n                        var spaceWidth = (wordBounds[count - 1].Left - (wordBounds[count + 1].Left + wordBounds[count + 1].Width));\n                        if (maximumSpaceBetweenWords < spaceWidth || spaceWidth < 0) {\n                            spaceWidth = 0;\n                        }\n                        newWordBounds = new RectAngle((wordBounds[count + 1].Left + wordBounds[count + 1].Width), minTop, spaceWidth, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, wordBounds[parseInt(count.toString(), 10)].Rotation);\n                    }\n                    else if (isRTLText) {\n                        newWordBounds = new RectAngle((wordBounds[count - 1].Left -\n                            wordBounds[parseInt(count.toString(), 10)].Width), minTop, wordBounds[parseInt(count.toString(), 10)].Width, maxBottom - minTop, wordBounds[parseInt(count.toString(), 10)].Text, wordBounds[parseInt(count.toString(), 10)].Rotation);\n                    }\n                }\n                if (!hasInBetweenRotation) {\n                    this.TextBounds.push(newWordBounds);\n                    this.TextContent.push(wordBounds[parseInt(count.toString(), 10)].Text);\n                }\n            }\n            if (hasInBetweenRotation) {\n                this.TextBounds.push(newWordBounds);\n                this.TextContent.push(inBetweenRotatedText);\n            }\n        };\n        Processor.prototype.checkIsRtlText = function (text) {\n            var ltrChars = 'A-Za-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02B8\\\\u0300-\\\\u0590\\\\u0800-\\\\u1FFF' + '\\\\u2C00-\\\\uFB1C\\\\uFDFE-\\\\uFE6F\\\\uFEFD-\\\\uFFFF';\n            var rtlChars = '\\\\u0591-\\\\u07FF\\\\uFB1D-\\\\uFDFD\\\\uFE70-\\\\uFEFC';\n            // eslint-disable-next-line\n            var rtlDirCheck = new RegExp('^[^' + ltrChars + ']*[' + rtlChars + ']');\n            return rtlDirCheck.test(text);\n        };\n        Processor.prototype.getPageRender = function (n, w, h, isTextNeed, isTransparent, cropBoxRect, mediaBoxRect, isSkipCharacterBounds) {\n            if (n === void 0) { n = 0; }\n            var pageRenderPtr = this.getRender(n, w, h, isTextNeed, isTransparent, cropBoxRect, mediaBoxRect, isSkipCharacterBounds);\n            var pageRenderData = [];\n            pageRenderData = PDFiumModule.HEAPU8.slice(pageRenderPtr, pageRenderPtr + (w * h * 4));\n            PDFiumModule.asm.free(pageRenderPtr);\n            return pageRenderData;\n        };\n        Processor.prototype.render = function (n, message, zoomFactor, isTextNeed, printScaleFactor, printDevicePixelRatio, textDetailsId, isTransparent, cropBoxRect, mediaBoxRect, size, isSkipCharacterBounds) {\n            if (n === void 0) { n = 0; }\n            var _a = this.getPageSize(n), w = _a[0], h = _a[1];\n            if (isNaN(w) && isNaN(h)) {\n                var page = FPDF.LoadPage(this.wasmData.wasm, n);\n                h = this.pointerToPixelConverter(FPDF.GetPageHeight(page));\n                w = this.pointerToPixelConverter(FPDF.GetPageWidth(page));\n            }\n            var scaleFactor = 1.5;\n            var thumbnailWidth = 99.7;\n            var thumbnailHeight = 141;\n            if (message === 'thumbnail') {\n                var newWidth = Math.round(thumbnailWidth * scaleFactor);\n                var newHeight = Math.round(thumbnailHeight * scaleFactor);\n                var data = this.getPageRender(n, newWidth, newHeight, isTextNeed, null, null, null, isSkipCharacterBounds);\n                return { value: data, width: newWidth, height: newHeight, pageIndex: n, message: 'renderThumbnail', textBounds: this.TextBounds, textContent: this.TextContent, rotation: this.Rotation, pageText: this.PageText, characterBounds: this.CharacterBounds, zoomFactor: zoomFactor, isTextNeed: isTextNeed, textDetailsId: textDetailsId };\n            }\n            else if (message === 'print') {\n                //An A0 piece of paper measures 33.1 × 46.8 inches, with 46.8 inches being the greater dimension. The pixel value of 46.8 inches is 4493px. If the document size is too large, we may not be able to display the image. Therefore, we should consider the maximum size of A0 paper if the page size is greater than 4493 pixels.\n                var maxPageSize = 4493;\n                var scaleFactor_1 = 1.5;\n                var whichIsBigger = (w > h) ? 'Width' : 'Height';\n                var maxWidth = w;\n                var maxHeight = h;\n                if (whichIsBigger === 'Width') {\n                    maxWidth = (w > maxPageSize) ? maxPageSize : w;\n                    if (maxWidth === maxPageSize) {\n                        maxHeight = h / (w / maxPageSize);\n                    }\n                }\n                else {\n                    maxHeight = (h > maxPageSize) ? maxPageSize : h;\n                    if (maxHeight === maxPageSize) {\n                        maxWidth = w / (h / maxPageSize);\n                    }\n                }\n                var newWidth = Math.round(maxWidth * printScaleFactor * scaleFactor_1);\n                var newHeight = Math.round(maxHeight * printScaleFactor * scaleFactor_1);\n                var data = this.getPageRender(n, newWidth, newHeight, false, null, null, null, isSkipCharacterBounds);\n                return { value: data, width: newWidth, height: newHeight, pageIndex: n, pageWidth: w, pageHeight: h, message: 'printImage', printDevicePixelRatio: printDevicePixelRatio };\n            }\n            else {\n                var newWidth = Math.round(((size && size !== null) ? size.width : w) * scaleFactor * zoomFactor);\n                var newHeight = Math.round(((size && size !== null) ? size.height : h) * scaleFactor * zoomFactor);\n                // Reduce the zoom factor if the new image size exceeds the memory limit\n                while (((newWidth * newHeight * 4) * 2) >= 2147483648) {\n                    zoomFactor = zoomFactor - 0.1;\n                    newWidth = Math.round(this.pointerToPixelConverter(w) * zoomFactor);\n                    newHeight = Math.round(this.pointerToPixelConverter(h) * zoomFactor);\n                }\n                var data = null;\n                if (message === 'extractText') {\n                    var page = FPDF.LoadPage(this.wasmData.wasm, n);\n                    this.textExtraction(page, n, isTextNeed, cropBoxRect, mediaBoxRect, isSkipCharacterBounds);\n                    FPDF.ClosePage(page);\n                }\n                else {\n                    data = this.getPageRender(n, newWidth, newHeight, isTextNeed, isTransparent, cropBoxRect, mediaBoxRect, isSkipCharacterBounds);\n                }\n                return { value: data, width: newWidth, height: newHeight, pageWidth: w, pageHeight: h, pageIndex: n, message: 'imageRendered', textBounds: this.TextBounds, textContent: this.TextContent, rotation: this.Rotation, pageText: this.PageText, characterBounds: this.CharacterBounds, zoomFactor: zoomFactor, isTextNeed: isTextNeed, textDetailsId: textDetailsId };\n            }\n        };\n        Processor.prototype.renderTileImage = function (n, tileX, tileY, xCount, yCount, zoomFactor, isTextNeed, textDetailsId, cropBoxRect, mediaBoxRect) {\n            if (n === void 0) { n = 0; }\n            var _a = this.getPageSize(n), w = _a[0], h = _a[1];\n            var newWidth = Math.round(w * 1.5 * zoomFactor);\n            var newHeight = Math.round(h * 1.5 * zoomFactor);\n            var w1 = Math.round(newWidth / xCount);\n            var h1 = Math.round(newHeight / yCount);\n            var flag = FPDF.REVERSE_BYTE_ORDER;\n            var heap = PDFiumModule.asm.malloc(w1 * h1 * 4);\n            PDFiumModule.HEAPU8.fill(0, heap, heap + (w1 * h1 * 4));\n            var bmap = FPDF.Bitmap_CreateEx(w1, h1, 4, heap, w1 * 4);\n            var page = FPDF.LoadPage(this.wasmData.wasm, n);\n            FPDF.Bitmap_FillRect(bmap, 0, 0, w1, h1, 0xFFFFFFFF);\n            FPDF.RenderPageBitmap(bmap, page, -tileX * w1, -tileY * h1, newWidth, newHeight, 0, flag);\n            FPDF.Bitmap_Destroy(bmap);\n            this.textExtraction(page, n, isTextNeed, cropBoxRect, mediaBoxRect);\n            FPDF.ClosePage(page);\n            var pageRenderPtr = heap;\n            var data = [];\n            data = PDFiumModule.HEAPU8.slice(pageRenderPtr, pageRenderPtr + (w1 * h1 * 4));\n            PDFiumModule.asm.free(pageRenderPtr);\n            if (tileX === 0 && tileY === 0) {\n                return {\n                    value: data,\n                    w: w1,\n                    h: h1,\n                    noTileX: xCount,\n                    noTileY: yCount,\n                    x: tileX,\n                    y: tileY,\n                    pageIndex: n,\n                    message: 'renderTileImage',\n                    textBounds: this.TextBounds,\n                    textContent: this.TextContent,\n                    rotation: this.Rotation,\n                    pageText: this.PageText,\n                    characterBounds: this.CharacterBounds,\n                    textDetailsId: textDetailsId,\n                    isTextNeed: isTextNeed,\n                    zoomFactor: zoomFactor\n                };\n            }\n            else {\n                return {\n                    value: data,\n                    w: w1,\n                    h: h1,\n                    noTileX: xCount,\n                    noTileY: yCount,\n                    x: tileX,\n                    y: tileY,\n                    pageIndex: n,\n                    message: 'renderTileImage',\n                    textDetailsId: textDetailsId,\n                    isTextNeed: isTextNeed,\n                    zoomFactor: zoomFactor\n                };\n            }\n        };\n        Processor.prototype.getLastError = function () {\n            var lastError = FPDF.GetLastError();\n            switch (lastError) {\n                case FPDF.LAST_ERROR.SUCCESS:\n                    return 'success';\n                case FPDF.LAST_ERROR.UNKNOWN:\n                    return 'unknown error';\n                case FPDF.LAST_ERROR.FILE:\n                    return 'file not found or could not be opened';\n                case FPDF.LAST_ERROR.FORMAT:\n                    return 'file not in PDF format or corrupted';\n                case FPDF.LAST_ERROR.PASSWORD:\n                    return 'password required or incorrect password';\n                case FPDF.LAST_ERROR.SECURITY:\n                    return 'unsupported security scheme';\n                case FPDF.LAST_ERROR.PAGE:\n                    return 'page not found or content error';\n                default:\n                    return 'unknown error';\n            }\n        };\n        return Processor;\n    }());\n    var DocumentInfo = /** @class */ (function () {\n        function DocumentInfo(wasmData) {\n            this.pages = [];\n            this.processor = new Processor(wasmData);\n        }\n        DocumentInfo.prototype.setPages = function (pagesCount) {\n            this.pages = Array(pagesCount).fill(null);\n        };\n        DocumentInfo.prototype.createAllPages = function () {\n            for (var i = 0; i < this.pages.length; i++) {\n                this.pages[parseInt(i.toString(), 10)] = new Page(parseInt(i.toString(), 10), this.processor);\n            }\n        };\n        DocumentInfo.prototype.getPage = function (index) {\n            var page = this.pages[parseInt(index.toString(), 10)];\n            if (!page) {\n                page = new Page(index);\n                this.pages[parseInt(index.toString(), 10)] = page;\n            }\n            return page;\n        };\n        return DocumentInfo;\n    }());\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdfium/pdfium-runner.js?");

/***/ })

}]);