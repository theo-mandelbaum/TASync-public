"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart3d_s"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-bar-series.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-bar-series.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StackingBarSeries3D: () => (/* binding */ StackingBarSeries3D)\n/* harmony export */ });\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n\nvar StackingBarSeries3D = /** @class */ (function () {\n    function StackingBarSeries3D() {\n    }\n    /**\n     * Draws the stacking bar series on a 3D chart.\n     *\n     * @param {Chart3DSeries} series - The 3D series to be drawn.\n     * @param {Chart3D} chart - The 3D chart on which the series will be drawn.\n     * @returns {void}\n     */\n    StackingBarSeries3D.prototype.draw = function (series, chart) {\n        this.createSegments(series);\n        series.isRectSeries = true;\n        for (var i = 0; i < series.visiblePoints.length; i++) {\n            var point = series.visiblePoints[i];\n            if (point.visible) {\n                var argsData = {\n                    cancel: false, series: series, point: point,\n                    fill: series.setPointColor(point, series.interior)\n                };\n                chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_0__.pointRender, argsData);\n                point.color = argsData.fill;\n                point.plans = null;\n                if (!argsData.cancel) {\n                    this.update(argsData.series, argsData.point, i, chart);\n                }\n                else {\n                    point.symbolLocations = null;\n                }\n            }\n        }\n    };\n    /**\n     * Updates a specific point in a stacking bar series on a 3D chart.\n     *\n     * @param {Chart3DSeries} series - The 3D series to which the point belongs.\n     * @param {Chart3DPoint} point - The point to be updated.\n     * @param {number} pointIndex - The index of the point within the series.\n     * @param {Chart3D} chart - The 3D chart to which the series and point belong.\n     * @returns {void}\n     */\n    StackingBarSeries3D.prototype.update = function (series, point, pointIndex, chart) {\n        var seriesIndex = series.index;\n        var left = point.left;\n        var right = point.right;\n        var bottom = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;\n        var top = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;\n        var xStart = series.xAxis.visibleRange.min;\n        var xEnd = series.xAxis.visibleRange.max;\n        if (!((left >= xStart) && (left <= xEnd)) || !((right >= xStart) && (right <= xEnd))) {\n            return;\n        }\n        var topValue;\n        if (point.top < 0) {\n            topValue = (point.top > bottom) ? point.top : bottom;\n        }\n        else {\n            topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === 'logarithmic') ? point.top : (point.top < top) ? point.top : top;\n        }\n        var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, (point.left > xStart) ? point.left :\n            xStart, topValue, chart);\n        var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, (xEnd > point.right) ? point.right :\n            xEnd, (bottom > point.bottom) ? bottom : point.bottom, chart);\n        var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);\n        var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);\n        var styleOptions = series.setStyle(series);\n        var name = 'region' + '-series-' + seriesIndex + '-point-' + pointIndex;\n        if (series.columnFacet === 'Cylinder') {\n            chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, '', point.color, null, styleOptions.opacity, name, chart.chart3D);\n        }\n        else if (series.columnFacet === 'Rectangle') {\n            chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, '', point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);\n        }\n    };\n    /**\n     * Creates segments for a stacking bar series within a 3D chart.\n     *\n     * @param {Chart3DSeries} series - The 3D series for which segments will be created.\n     * @returns {void}\n     */\n    StackingBarSeries3D.prototype.createSegments = function (series) {\n        var xValues = series.getXValues(series.visiblePoints);\n        if (xValues == null) {\n            return;\n        }\n        var sbsInfo = series.getSideBySideInfo(series);\n        var depthInfo = series.getSegmentDepth(series);\n        var median = sbsInfo.delta / 2;\n        var visiblePoints = series.visiblePoints;\n        var cons = 0.2;\n        for (var i = 0; i < visiblePoints.length; i++) {\n            var x1 = xValues[i] + sbsInfo.start;\n            var x2 = xValues[i] + sbsInfo.end;\n            var y2 = series.stackedValues.startValues[i];\n            var y1 = series.stackedValues.endValues[i];\n            this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);\n            if (!series.dataLabel.visible) {\n                continue;\n            }\n            visiblePoints[i].symbolLocations = { x: 0, y: 0, z: 0 };\n            switch (series.dataLabel.position) {\n                case 'Top':\n                    visiblePoints[i].symbolLocations.x = x1 + median;\n                    visiblePoints[i].symbolLocations.y = y1;\n                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.delta / 2);\n                    break;\n                case 'Bottom':\n                    visiblePoints[i].symbolLocations.x = x1 + median;\n                    visiblePoints[i].symbolLocations.y = y2 - cons;\n                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;\n                    break;\n                default:\n                    visiblePoints[i].symbolLocations.x = x1 + median;\n                    visiblePoints[i].symbolLocations.y = y1 + (y2 - y1) / 2;\n                    visiblePoints[i].symbolLocations.z = depthInfo.start;\n                    break;\n            }\n        }\n    };\n    /**\n     * Sets data for a stacking bar series in a 3D chart.\n     *\n     * @param {number} x1 - The x-coordinate of the starting point of the segment.\n     * @param {number} y1 - The y-coordinate of the starting point of the segment.\n     * @param {number} x2 - The x-coordinate of the ending point of the segment.\n     * @param {number} y2 - The y-coordinate of the ending point of the segment.\n     * @param {number} start - The starting value of the segment on the axis.\n     * @param {number} end - The ending value of the segment on the axis.\n     * @param {Chart3DSeries} series - The 3D series to which the segment belongs.\n     * @param {Chart3DPoint} point - The point associated with the segment.\n     * @returns {void}\n     */\n    StackingBarSeries3D.prototype.setData = function (x1, y1, x2, y2, start, end, series, point) {\n        point.left = x1;\n        point.bottom = y2;\n        point.top = y1;\n        point.right = x2;\n        point.startDepth = start;\n        point.endDepth = end;\n        point.xRange = series.getDoubleRange(point.left, point.right);\n        if (!isNaN(point.top) && !isNaN(point.bottom)) {\n            point.yRange = series.getDoubleRange(point.top, point.bottom);\n        }\n    };\n    /**\n     * To destroy the stacking bar series.\n     *\n     * @returns {void}\n     * @private\n     */\n    StackingBarSeries3D.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    /**\n     * Gets the module name for the  Stacking Bar3D series.\n     *\n     * @returns {void}\n     */\n    StackingBarSeries3D.prototype.getModuleName = function () {\n        return 'StackingBarSeries3D';\n        /**\n         * return the module name\n         */\n    };\n    return StackingBarSeries3D;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-bar-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-column-series.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-column-series.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StackingColumnSeries3D: () => (/* binding */ StackingColumnSeries3D)\n/* harmony export */ });\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n\nvar StackingColumnSeries3D = /** @class */ (function () {\n    function StackingColumnSeries3D() {\n    }\n    /**\n     * Draws the stacking column series on a 3D chart.\n     *\n     * @param {Chart3DSeries} series - The 3D series to be drawn.\n     * @param {Chart3D} chart - The 3D chart on which the series will be drawn.\n     * @returns {void}\n     */\n    StackingColumnSeries3D.prototype.draw = function (series, chart) {\n        this.createSegments(series);\n        for (var i = 0; i < series.visiblePoints.length; i++) {\n            var point = series.visiblePoints[i];\n            if (point.visible) {\n                var argsData = {\n                    cancel: false, series: series, point: point,\n                    fill: series.setPointColor(point, series.interior)\n                };\n                chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_0__.pointRender, argsData);\n                point.color = argsData.fill;\n                point.plans = null;\n                if (!argsData.cancel) {\n                    this.update(argsData.series, argsData.point, i, chart);\n                }\n                else {\n                    point.symbolLocations = null;\n                }\n            }\n        }\n    };\n    /**\n     * Updates a specific point in a stacking column series on a 3D chart.\n     *\n     * @param {Chart3DSeries} series - The 3D series to which the point belongs.\n     * @param {Chart3DPoint} point - The point to be updated.\n     * @param {number} pointIndex - The index of the point within the series.\n     * @param {Chart3D} chart - The 3D chart to which the series and point belong.\n     * @returns {void}\n     */\n    StackingColumnSeries3D.prototype.update = function (series, point, pointIndex, chart) {\n        var seriesIndex = series.index;\n        var left = point.left;\n        var right = point.right;\n        var bottom = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.min) : series.yAxis.visibleRange.min;\n        var top = series.yAxis.valueType === 'Logarithmic' ? Math.pow(series.yAxis.logBase, series.yAxis.visibleRange.max) : series.yAxis.visibleRange.max;\n        var xStart = series.xAxis.visibleRange.min;\n        var xEnd = series.xAxis.visibleRange.max;\n        if (!((left >= xStart) && (left <= xEnd)) || !((right >= xStart) && (right <= xEnd))) {\n            return;\n        }\n        var topValue;\n        if (point.top < 0) {\n            topValue = (point.top > bottom) ? point.top : bottom;\n        }\n        else {\n            topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() === 'logarithmic') ? point.top : (point.top < top) ? point.top : top;\n        }\n        var tlpoint = chart.svg3DRenderer.transform3DToVisible(series, (point.left > xStart) ?\n            point.left : xStart, topValue, chart);\n        var rbpoint = chart.svg3DRenderer.transform3DToVisible(series, (xEnd > point.right) ?\n            point.right : xEnd, (bottom > point.bottom) ? bottom : point.bottom, chart);\n        var tlfVector = chart.vector.vector3D(Math.min(tlpoint.x, rbpoint.x), Math.min(tlpoint.y, rbpoint.y), point.startDepth);\n        var brbVector = chart.vector.vector3D(Math.max(tlpoint.x, rbpoint.x), Math.max(tlpoint.y, rbpoint.y), point.endDepth);\n        var styleOptions = series.setStyle(series);\n        var name = 'region' + '-series-' + seriesIndex + '-point-' + pointIndex;\n        if (series.columnFacet === 'Cylinder') {\n            chart.polygon.createCylinder(tlfVector, brbVector, chart, pointIndex, series.type, '', point.color, null, styleOptions.opacity, name, chart.chart3D);\n        }\n        else if (series.columnFacet === 'Rectangle') {\n            chart.polygon.createBox(tlfVector, brbVector, chart, pointIndex, '', point.color, null, styleOptions.opacity, chart.requireInvertedAxis, name, chart.chart3D);\n        }\n    };\n    /**\n     * Creates segments for a stacking column series within a 3D chart.\n     *\n     * @param {Chart3DSeries} series - The 3D series for which segments will be created.\n     * @returns {void}\n     */\n    StackingColumnSeries3D.prototype.createSegments = function (series) {\n        var xValues = series.getXValues(series.visiblePoints);\n        if (xValues == null) {\n            return;\n        }\n        var sbsInfo = series.getSideBySideInfo(series);\n        var depthInfo = series.getSegmentDepth(series);\n        var median = sbsInfo.delta / 2;\n        var visiblePoints = series.visiblePoints;\n        var cons = 0.2;\n        for (var i = 0; i < visiblePoints.length; i++) {\n            var x1 = xValues[i] + sbsInfo.start;\n            var x2 = xValues[i] + sbsInfo.end;\n            var y1 = series.stackedValues.startValues[i];\n            var y2 = series.stackedValues.endValues[i];\n            this.setData(x1, y1, x2, y2, depthInfo.start, depthInfo.end, series, visiblePoints[i]);\n            if (!series.dataLabel.visible) {\n                continue;\n            }\n            visiblePoints[i].symbolLocations = { x: 0, y: 0, z: 0 };\n            switch (series.dataLabel.position) {\n                case 'Top':\n                    visiblePoints[i].symbolLocations.x = x1 + median;\n                    visiblePoints[i].symbolLocations.y = y1;\n                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.delta / 2);\n                    break;\n                case 'Bottom':\n                    visiblePoints[i].symbolLocations.x = x1 + median;\n                    visiblePoints[i].symbolLocations.y = y2 - cons;\n                    visiblePoints[i].symbolLocations.z = depthInfo.start + (depthInfo.end - depthInfo.start) / 2;\n                    break;\n                default:\n                    visiblePoints[i].symbolLocations.x = x1 + median;\n                    visiblePoints[i].symbolLocations.y = y1 + (y2 - y1) / 2;\n                    visiblePoints[i].symbolLocations.z = depthInfo.start;\n                    break;\n            }\n        }\n    };\n    /**\n     * Sets data for a stacking column series in a 3D chart.\n     *\n     * @param {number} x1 - The x-coordinate of the starting point of the segment.\n     * @param {number} y1 - The y-coordinate of the starting point of the segment.\n     * @param {number} x2 - The x-coordinate of the ending point of the segment.\n     * @param {number} y2 - The y-coordinate of the ending point of the segment.\n     * @param {number} start - The starting value of the segment on the axis.\n     * @param {number} end - The ending value of the segment on the axis.\n     * @param {Chart3DSeries} series - The 3D series to which the segment belongs.\n     * @param {Chart3DPoint} point - The point associated with the segment.\n     * @returns {void}\n     */\n    StackingColumnSeries3D.prototype.setData = function (x1, y1, x2, y2, start, end, series, point) {\n        point.left = x1;\n        point.bottom = y2;\n        point.top = y1;\n        point.right = x2;\n        point.startDepth = start;\n        point.endDepth = end;\n        point.xRange = series.getDoubleRange(point.left, point.right);\n        if (!isNaN(point.top) && !isNaN(point.bottom)) {\n            point.yRange = series.getDoubleRange(point.top, point.bottom);\n        }\n    };\n    /**\n     * To destroy the stacking column series.\n     *\n     * @returns {void}\n     * @private\n     */\n    StackingColumnSeries3D.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    /**\n     * Gets the module name for the Stacking Column3D series.\n     *\n     * @returns {void}\n     */\n    StackingColumnSeries3D.prototype.getModuleName = function () {\n        return 'StackingColumnSeries3D';\n        /**\n         * return the module name.\n         */\n    };\n    return StackingColumnSeries3D;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/series/stacking-column-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/user-interaction/high-light.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/user-interaction/high-light.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Highlight3D: () => (/* binding */ Highlight3D)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/user-interaction/selection.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Highlight src file\n */\n\n\n\n/**\n * The `Highlight` module handles the highlight for chart.\n *\n * @private\n */\nvar Highlight3D = /** @class */ (function (_super) {\n    __extends(Highlight3D, _super);\n    /**\n     * Constructor for selection module.\n     *\n     * @param {Chart3D} chart - Chart3D instance.\n     */\n    function Highlight3D(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.chart = chart;\n        _this.wireEvents();\n        return _this;\n    }\n    /**\n     * Binding events for highlight module.\n     *\n     * @returns {void}\n     */\n    Highlight3D.prototype.wireEvents = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove, this);\n    };\n    /**\n     * Unbinding events for highlight module.\n     *\n     * @returns {void}\n     */\n    Highlight3D.prototype.unWireEvents = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove);\n    };\n    /**\n     * Declares private variables for the highlight modules.\n     *\n     * @param {Chart3D} chart - The 3D chart for which private variables are being declared.\n     * @returns {void}\n     */\n    Highlight3D.prototype.declarePrivateVariables = function (chart) {\n        this.styleId = chart.element.id + '_ej2_chart_highlight';\n        this.unselected = chart.element.id + '_ej2_deselected';\n        this.selectedDataIndexes = [];\n        this.highlightDataIndexes = [];\n        this.isSeriesMode = chart.highlightMode === 'Series';\n    };\n    /**\n     * Invokes the highlighting functionality on a 3D chart.\n     *\n     * @param {Chart3D} chart - The 3D chart on which highlighting is being invoked.\n     * @returns {void}\n     */\n    Highlight3D.prototype.invokeHighlight = function (chart) {\n        this.declarePrivateVariables(chart);\n        this.series = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, chart.visibleSeries, null, true);\n        this.seriesStyles();\n        this.currentMode = chart.highlightMode;\n    };\n    /**\n     * Gets the module name for the highlighting functionality.\n     *\n     * @returns {string} The module name.\n     */\n    Highlight3D.prototype.getModuleName = function () {\n        return 'Highlight3D';\n    };\n    /**\n     * To destroy the highlight module.\n     *\n     * @returns {void}\n     * @private\n     */\n    Highlight3D.prototype.destroy = function () {\n        this.unWireEvents();\n        // Destroy method performed here\n    };\n    return Highlight3D;\n}(_selection__WEBPACK_IMPORTED_MODULE_1__.Selection3D));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/user-interaction/high-light.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/doubleRange.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/doubleRange.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DoubleRange: () => (/* binding */ DoubleRange)\n/* harmony export */ });\n/**\n * Numeric Range.\n *\n * @private\n */\nvar DoubleRange = /** @class */ (function () {\n    function DoubleRange(start, end) {\n        if (start < end) {\n            this.mStart = start;\n            this.mEnd = end;\n        }\n        else {\n            this.mStart = end;\n            this.mEnd = start;\n        }\n    }\n    Object.defineProperty(DoubleRange.prototype, \"start\", {\n        /**\n         * The start value.\n         *\n         * @private\n         * @returns {number} - The start value.\n         */\n        get: function () {\n            return this.mStart;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DoubleRange.prototype, \"end\", {\n        /**\n         * The end value.\n         *\n         * @private\n         * @returns {number} - The end value.\n         */\n        get: function () {\n            return this.mEnd;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DoubleRange.prototype, \"delta\", {\n        /**\n         * The delta between the start and end values.\n         *\n         * @private\n         * @returns {number} - The delta value.\n         */\n        get: function () {\n            return (this.mEnd - this.mStart);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return DoubleRange;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/doubleRange.js?");

/***/ })

}]);