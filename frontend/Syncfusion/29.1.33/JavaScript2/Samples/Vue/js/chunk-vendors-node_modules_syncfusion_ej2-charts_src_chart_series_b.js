"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_b"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/box-and-whisker-series.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/box-and-whisker-series.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoxAndWhiskerSeries: () => (/* binding */ BoxAndWhiskerSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n/**\n * The `BoxAndWhiskerSeries` module is used to render the box and whisker series.\n */\nvar BoxAndWhiskerSeries = /** @class */ (function (_super) {\n    __extends(BoxAndWhiskerSeries, _super);\n    function BoxAndWhiskerSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Renders the BoxAndWhisker series on the chart.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The X-axis associated with the series.\n     * @param {Axis} yAxis - The Y-axis associated with the series.\n     * @param {boolean} isInverted - Indicates whether the chart is inverted or not.\n     * @returns {void}\n     * @private\n     */\n    BoxAndWhiskerSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n        this.sideBySideInfo = this.getSideBySideInfo(series);\n        var argsData;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            this.renderPoint(series, point, this.sideBySideInfo, argsData, xAxis, yAxis, isInverted);\n        }\n        if (series.marker.visible) {\n            series.chart.markerRender.render(series);\n        }\n    };\n    /**\n     * update the tip region fo box plot\n     *\n     * @param {Series} series series\n     * @param {Points} point point\n     * @param {DoubleRange} sideBySideInfo sideBySideInfo\n     * @returns {void}\n     */\n    BoxAndWhiskerSeries.prototype.updateTipRegion = function (series, point, sideBySideInfo) {\n        var tipRegion = this.getRectangle((point.xValue + sideBySideInfo.median), point.maximum, (point.xValue + sideBySideInfo.median), point.minimum, series);\n        this.updateTipSize(series, point, tipRegion, series.chart.requireInvertedAxis);\n    };\n    /**\n     * Update tip size to tip regions\n     *\n     * @param {Series} series Series\n     * @param {Points} point Points\n     * @param {Rect} region rect region\n     * @param {boolean} isInverted isInverted\n     * @returns {void}\n     */\n    BoxAndWhiskerSeries.prototype.updateTipSize = function (series, point, region, isInverted) {\n        var borderWidth = series.border.width || 1;\n        if (!isInverted) {\n            region.x -= borderWidth / 2;\n            region.width = region.width || borderWidth;\n        }\n        else {\n            region.y -= borderWidth / 2;\n            region.height = region.height || borderWidth;\n        }\n        point.regions.push(region);\n    };\n    BoxAndWhiskerSeries.prototype.renderPoint = function (series, point, sideBySideInfo, argsData, xAxis, yAxis, isInverted) {\n        point.symbolLocations = [];\n        point.regions = [];\n        var centerRegion;\n        if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n            this.findBoxPlotValues(point.y, point, series.boxPlotMode, series.showOutliers);\n            //region to cover the top and bottom ticks\n            this.updateTipRegion(series, point, sideBySideInfo);\n            //get middle rect\n            centerRegion = this.getRectangle((point.xValue + sideBySideInfo.start), point.upperQuartile, (point.xValue + sideBySideInfo.end), point.lowerQuartile, series);\n            point.regions.push(centerRegion);\n            argsData = this.triggerEvent(series, point, series.interior, {\n                color: (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(series.border.color) && series.border.color !== 'transparent') ? series.border.color :\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getSaturationColor)(series.interior, -0.6),\n                width: series.border.width ? series.border.width : 1\n            });\n            if (!argsData.cancel) {\n                this.renderBoxAndWhisker(series, point, argsData, this.getPathString(point, series, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.median, xAxis, yAxis, isInverted), (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue + sideBySideInfo.median, point.average, xAxis, yAxis, isInverted)), sideBySideInfo.median);\n            }\n        }\n    };\n    /**\n     * Updates the direction of rendering for the specified series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {number[]} point - The point to be updated.\n     * @param {boolean} isInverted - Specifies the inverted axis.\n     * @returns {void}\n     * @private\n     */\n    BoxAndWhiskerSeries.prototype.updateDirection = function (series, point, isInverted) {\n        var argsData;\n        for (var i = 0; i < point.length; i++) {\n            var visiblePoint = series.points[point[i]];\n            this.renderPoint(series, visiblePoint, this.sideBySideInfo, argsData, series.xAxis, series.yAxis, isInverted);\n            if (visiblePoint.symbolLocations && visiblePoint.symbolLocations.length && series.marker.visible) {\n                series.chart.markerRender.renderMarker(series, visiblePoint, visiblePoint.symbolLocations[0], visiblePoint.symbolLocations.length - 1, true);\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelCollections = [];\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                if (visiblePoint.outliers.length === 0) {\n                    var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(series.chart.dataLabelModule.commonId + visiblePoint.index + '_Text_' + 5);\n                    if (element) {\n                        element.remove();\n                    }\n                }\n                series.chart.dataLabelModule.renderDataLabel(series, visiblePoint, null, series.marker.dataLabel);\n            }\n        }\n        var children = series.seriesElement.children;\n        for (var i = children.length - 1; i >= 0; i--) {\n            if (children[i].children.length === 0) {\n                series.seriesElement.removeChild(children[i]);\n            }\n        }\n    };\n    /**\n     * Calculation for path direction performed here.\n     *\n     * @param {Points} point point\n     * @param {Series} series series\n     * @param {ChartLocation} median median\n     * @param {ChartLocation} average average\n     * @returns {string} direction\n     * @private\n     */\n    BoxAndWhiskerSeries.prototype.getPathString = function (point, series, median, average) {\n        var topRect = point.regions[0];\n        var midRect = point.regions[1];\n        var direction = '';\n        var center = series.chart.requireInvertedAxis ? topRect.y + topRect.height / 2 :\n            topRect.x + topRect.width / 2;\n        var midWidth = midRect.x + midRect.width;\n        var midHeight = midRect.y + midRect.height;\n        var topWidth = topRect.x + topRect.width;\n        var topHeight = topRect.y + topRect.height;\n        if (!series.chart.requireInvertedAxis) {\n            this.updateTipSize(series, point, { x: midRect.x, y: topRect.y, width: midWidth - midRect.x, height: 0 }, true);\n            this.updateTipSize(series, point, { x: midRect.x, y: topHeight, width: midWidth - midRect.x, height: 0 }, true);\n            direction += 'M ' + midRect.x + ' ' + topRect.y + ' ' + 'L ' + midWidth + ' ' + topRect.y;\n            direction += ' M ' + center + ' ' + topRect.y + ' ' + 'L ' + center + ' ' + midRect.y;\n            direction += ' M ' + midRect.x + ' ' + midRect.y + ' ' + 'L ' + midWidth + ' ' + midRect.y +\n                ' L ' + midWidth + ' ' + midHeight + ' L ' + midRect.x + ' ' + midHeight + ' Z';\n            direction += ' M ' + center + ' ' + midHeight + ' L ' + center + ' ' + topHeight;\n            direction += ' M ' + midRect.x + ' ' + topHeight + ' L ' + midWidth + ' ' + topHeight;\n            direction += ' M ' + midRect.x + ' ' + median.y + ' L ' + midWidth + ' ' + median.y;\n            direction += series.showMean ?\n                ' M ' + (average.x - 5) + ' ' + (average.y - 5) + ' L ' + (average.x + 5) + ' ' + (average.y + 5) +\n                    ' M ' + (average.x + 5) + ' ' + (average.y - 5) + ' L ' + (average.x - 5) + ' ' + (average.y + 5) : '';\n        }\n        else {\n            this.updateTipSize(series, point, { x: topRect.x, y: midRect.y, width: 0, height: midHeight - midRect.y }, false);\n            this.updateTipSize(series, point, { x: topWidth, y: midRect.y, width: 0, height: midHeight - midRect.y }, true);\n            direction += 'M ' + topRect.x + ' ' + midRect.y + ' L ' + topRect.x + ' ' + midHeight;\n            direction += 'M ' + topRect.x + ' ' + center + ' ' + 'L ' + midRect.x + ' ' + center;\n            direction += ' M ' + midRect.x + ' ' + midRect.y + ' ' + 'L ' + midWidth + ' ' + midRect.y +\n                ' L ' + midWidth + ' ' + midHeight + ' L ' + midRect.x + ' ' + midHeight + ' Z';\n            direction += ' M ' + midWidth + ' ' + center + ' L ' + topWidth + ' ' + center;\n            direction += ' M ' + topWidth + ' ' + midRect.y + ' L ' + topWidth + ' ' + midHeight;\n            direction += ' M ' + median.x + ' ' + midRect.y + ' ' + 'L ' + median.x + ' ' + midHeight;\n            direction += series.showMean ?\n                'M ' + (average.x + 5) + ' ' + (average.y - 5) + ' L ' + (average.x - 5) + ' ' + (average.y + 5) +\n                    'M ' + (average.x - 5) + ' ' + (average.y - 5) + ' L ' + (average.x + 5) + ' ' + (average.y + 5) : '';\n        }\n        return direction;\n    };\n    /**\n     * Rendering for box and whisker append here.\n     *\n     * @param {Series} series series\n     * @param {Points} point point\n     * @param {IPointRenderEventArgs} argsData argsData\n     * @param {string} direction path direction\n     * @param {number} median median\n     * @returns {void}\n     * @private\n     */\n    BoxAndWhiskerSeries.prototype.renderBoxAndWhisker = function (series, point, argsData, direction, median) {\n        var location;\n        var size;\n        var symbolId = series.chart.element.id + '_Series_' + series.index + '_Point_' + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index);\n        var previusDirection = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(symbolId + '_BoxPath') ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)((symbolId + '_BoxPath')).getAttribute('d') : '';\n        var element = series.chart.renderer.drawPath(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(symbolId + '_BoxPath', argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray, direction), new Int32Array([series.clipRect.x, series.clipRect.y]));\n        element.setAttribute('role', 'img');\n        element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) :\n            (point.x.toString() + ':' + point.maximum.toString() + ':' + point.minimum.toString() + ':' + point.lowerQuartile.toString() + ':' + point.upperQuartile.toString()));\n        var parentElement = series.chart.renderer.createGroup({\n            'id': symbolId\n        });\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(series.chart.enableCanvas, parentElement, element, series.chart.redraw, true, null, null, null, previusDirection, null, null, null, series.chart.duration);\n        if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n            parentElement.id = series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n            element.id = series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index + '_BoxPath';\n        }\n        for (var i = 0; i < point.outliers.length; i++) {\n            location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)((point.xValue + median), point.outliers[i], series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n            size = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Size(series.marker.width, series.marker.height);\n            point.symbolLocations.push(location);\n            this.updateTipSize(series, point, {\n                x: location.x - (size.width / 2), y: location.y - (size.height / 2),\n                width: size.width, height: size.height\n            }, true);\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(series.chart.enableCanvas, series.seriesElement, parentElement, series.chart.redraw, false, null, null, null, null, null, null, null, series.chart.duration, true);\n    };\n    /**\n     * To find the box plot values.\n     *\n     * @param {number[]} yValues yValues\n     * @param {Points} point point\n     * @param {BoxPlotMode} mode mode\n     * @param {boolean} showOutliers - Specifies to show or hide the outliers in a box-and-whisker series type.\n     * @returns {void}\n     * @private\n     */\n    BoxAndWhiskerSeries.prototype.findBoxPlotValues = function (yValues, point, mode, showOutliers) {\n        var yCount = yValues.length;\n        var quartile = {\n            average: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(yValues) / yCount,\n            lowerQuartile: 0, upperQuartile: 0,\n            maximum: 0, minimum: 0,\n            median: 0, outliers: []\n        };\n        if (mode === 'Exclusive') {\n            quartile.lowerQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.25);\n            quartile.upperQuartile = this.getExclusiveQuartileValue(yValues, yCount, 0.75);\n            quartile.median = this.getExclusiveQuartileValue(yValues, yCount, 0.5);\n        }\n        else if (mode === 'Inclusive') {\n            quartile.lowerQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.25);\n            quartile.upperQuartile = this.getInclusiveQuartileValue(yValues, yCount, 0.75);\n            quartile.median = this.getInclusiveQuartileValue(yValues, yCount, 0.5);\n        }\n        else {\n            quartile.median = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getMedian)(yValues);\n            this.getQuartileValues(yValues, yCount, quartile);\n        }\n        this.getMinMaxOutlier(yValues, yCount, quartile, showOutliers);\n        point.minimum = quartile.minimum;\n        point.maximum = quartile.maximum;\n        point.lowerQuartile = quartile.lowerQuartile;\n        point.upperQuartile = quartile.upperQuartile;\n        point.median = quartile.median;\n        point.outliers = quartile.outliers;\n        point.average = quartile.average;\n    };\n    /**\n     * to find the exclusive quartile values\n     *\n     * @param {number[]} yValues yValues\n     * @param {number} count count\n     * @param {number} percentile percentile\n     * @returns {number} exclusive quartile value\n     */\n    BoxAndWhiskerSeries.prototype.getExclusiveQuartileValue = function (yValues, count, percentile) {\n        if (count === 0) {\n            return 0;\n        }\n        else if (count === 1) {\n            return yValues[0];\n        }\n        var value = 0;\n        var rank = percentile * (count + 1);\n        var integerRank = Math.floor(Math.abs(rank));\n        var fractionRank = rank - integerRank;\n        if (integerRank === 0) {\n            value = yValues[0];\n        }\n        else if (integerRank > count - 1) {\n            value = yValues[count - 1];\n        }\n        else {\n            value = fractionRank * (yValues[integerRank] - yValues[integerRank - 1]) + yValues[integerRank - 1];\n        }\n        return value;\n    };\n    /**\n     * to find the inclusive quartile values\n     *\n     * @param {number[]} yValues yValues\n     * @param {number} count count\n     * @param {number} percentile percentile\n     * @returns {number} inclusive quartile value\n     */\n    BoxAndWhiskerSeries.prototype.getInclusiveQuartileValue = function (yValues, count, percentile) {\n        if (count === 0) {\n            return 0;\n        }\n        else if (count === 1) {\n            return yValues[0];\n        }\n        var value = 0;\n        var rank = percentile * (count - 1);\n        var integerRank = Math.floor(Math.abs(rank));\n        var fractionRank = rank - integerRank;\n        value = fractionRank * (yValues[integerRank + 1] - yValues[integerRank]) + yValues[integerRank];\n        return value;\n    };\n    /**\n     * To find the quartile values\n     *\n     * @param {number[]} yValues yValues\n     * @param {number} count count\n     * @param {IBoxPlotQuartile} quartile quartile\n     * @returns {void}\n     */\n    BoxAndWhiskerSeries.prototype.getQuartileValues = function (yValues, count, quartile) {\n        if (count === 1) {\n            quartile.lowerQuartile = yValues[0];\n            quartile.upperQuartile = yValues[0];\n            return null;\n        }\n        var isEvenList = count % 2 === 0;\n        var halfLength = count / 2;\n        var lowerQuartileArray = yValues.slice(0, halfLength);\n        var upperQuartileArray = yValues.slice(isEvenList ? halfLength : halfLength + 1, count);\n        quartile.lowerQuartile = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getMedian)(lowerQuartileArray);\n        quartile.upperQuartile = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getMedian)(upperQuartileArray);\n    };\n    /**\n     * To find the min, max and outlier values\n     *\n     * @param {number[]} yValues yValues\n     * @param {number} count count\n     * @param {IBoxPlotQuartile} quartile quartile\n     * @param {boolean} showOutliers - Specifies to show or hide the outliers in a box-and-whisker series type.\n     * @returns {void}\n     */\n    BoxAndWhiskerSeries.prototype.getMinMaxOutlier = function (yValues, count, quartile, showOutliers) {\n        var interquartile = quartile.upperQuartile - quartile.lowerQuartile;\n        var rangeIQR = 1.5 * interquartile;\n        for (var i = 0; i < count; i++) {\n            if ((yValues[i] < quartile.lowerQuartile - rangeIQR) && showOutliers) {\n                quartile.outliers.push(yValues[i]);\n            }\n            else {\n                quartile.minimum = yValues[i];\n                break;\n            }\n        }\n        for (var i = count - 1; i >= 0; i--) {\n            if ((yValues[i] > quartile.upperQuartile + rangeIQR) && showOutliers) {\n                quartile.outliers.push(yValues[i]);\n            }\n            else {\n                quartile.maximum = yValues[i];\n                break;\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    BoxAndWhiskerSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} module name\n     */\n    BoxAndWhiskerSeries.prototype.getModuleName = function () {\n        return 'BoxAndWhiskerSeries';\n        /**\n         * return the module name\n         */\n    };\n    /**\n     * To destroy the candle series.\n     *\n     * @returns {void}\n     * @private\n     */\n    BoxAndWhiskerSeries.prototype.destroy = function () {\n        /**\n         * Destroys the candle series.\n         */\n    };\n    return BoxAndWhiskerSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_3__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/box-and-whisker-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/bubble-series.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/bubble-series.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleSeries: () => (/* binding */ BubbleSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n\n\n\n\n/**\n * The `BubbleSeries` module is used to render the bubble series.\n */\nvar BubbleSeries = /** @class */ (function () {\n    function BubbleSeries() {\n    }\n    /**\n     * Render the Bubble series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The X-axis associated with the series.\n     * @param {Axis} yAxis - The Y-axis associated with the series.\n     * @param {boolean} isInverted - Indicates whether the chart is inverted or not.\n     * @returns {void}\n     * @private\n     */\n    BubbleSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n        var visiblePoints = series.points;\n        var radius;\n        var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);\n        var percentChange = value / 100;\n        var maxRadius = series.maxRadius * percentChange;\n        var minRadius = series.minRadius * percentChange;\n        var maximumSize = null;\n        var maxValue = null;\n        if ((series.maxRadius === null || series.minRadius === null)) {\n            for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {\n                var value_1 = _a[_i];\n                if (value_1.type === 'Bubble' && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {\n                    maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;\n                }\n            }\n            maxValue = (value / 5) / 2;\n            minRadius = maxRadius = 1;\n            radius = maxValue * maxRadius;\n        }\n        else {\n            maximumSize = series.sizeMax;\n            radius = maxRadius - minRadius;\n        }\n        for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {\n            var bubblePoint = visiblePoints_1[_b];\n            this.renderPoint(series, bubblePoint, isInverted, radius, maximumSize, minRadius, visiblePoints);\n        }\n    };\n    BubbleSeries.prototype.renderPoint = function (series, bubblePoint, isInverted, radius, maximumSize, minRadius, visiblePoints, pointUpdate) {\n        var startLocation = series.chart.redraw && bubblePoint.symbolLocations ? bubblePoint.symbolLocations[0] : null;\n        bubblePoint.symbolLocations = [];\n        bubblePoint.regions = [];\n        var segmentRadius;\n        if (bubblePoint.visible &&\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {\n            if ((series.maxRadius === null || series.minRadius === null)) {\n                segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);\n            }\n            else {\n                segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);\n            }\n            segmentRadius = segmentRadius || minRadius;\n            var argsData = {\n                cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_2__.pointRender, series: series, point: bubblePoint,\n                fill: series.setPointColor(bubblePoint, series.interior),\n                border: series.setBorderColor(bubblePoint, { width: series.border.width, color: series.border.color }),\n                height: 2 * segmentRadius, width: 2 * segmentRadius\n            };\n            series.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_2__.pointRender, argsData);\n            if (!argsData.cancel) {\n                bubblePoint.symbolLocations.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(bubblePoint.xValue, bubblePoint.yValue, series.xAxis, series.yAxis, isInverted));\n                bubblePoint.color = argsData.fill;\n                var shapeOption = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray);\n                if (pointUpdate && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(shapeOption.id)) {\n                    var markerElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(shapeOption.id);\n                    startLocation = {\n                        x: +markerElement.getAttribute('cx'), y: +markerElement.getAttribute('cy')\n                    };\n                }\n                var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.drawSymbol)(bubblePoint.symbolLocations[0], 'Circle', new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Size(argsData.width, argsData.height), series.marker.imageUrl, shapeOption, bubblePoint.x.toString() + ':' + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(series.chart.enableCanvas, series.seriesElement, element, series.chart.redraw, true, 'cx', 'cy', startLocation, null, false, false, null, series.chart.duration, true);\n                bubblePoint.regions.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));\n                bubblePoint.marker = {\n                    border: argsData.border, fill: argsData.fill,\n                    height: argsData.height, visible: true,\n                    shape: 'Circle', width: argsData.width\n                };\n                if (series.chart.enableCanvas) {\n                    series.chart.markerRender.render(series);\n                }\n                startLocation = series.chart.redraw && !startLocation ? bubblePoint.symbolLocations[0] : startLocation;\n                if (series.chart.redraw) {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateRedrawElement)(element, series.chart.duration ? series.chart.duration : 300, startLocation, bubblePoint.symbolLocations[0], 'cx', 'cy');\n                }\n            }\n            else {\n                bubblePoint.marker = { visible: false };\n            }\n        }\n    };\n    BubbleSeries.prototype.updateDirection = function (series, point, isInverted) {\n        var visiblePoints = series.points;\n        var radius;\n        var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);\n        var percentChange = value / 100;\n        var maxRadius = series.maxRadius * percentChange;\n        var minRadius = series.minRadius * percentChange;\n        var maximumSize = null;\n        var maxValue = null;\n        if ((series.maxRadius === null || series.minRadius === null)) {\n            for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {\n                var value_2 = _a[_i];\n                if (value_2.type === 'Bubble' && value_2.visible === true && (value_2.maxRadius === null || value_2.minRadius === null)) {\n                    maximumSize = value_2.sizeMax > maximumSize ? value_2.sizeMax : maximumSize;\n                }\n            }\n            maxValue = (value / 5) / 2;\n            minRadius = maxRadius = 1;\n            radius = maxValue * maxRadius;\n        }\n        else {\n            maximumSize = series.sizeMax;\n            radius = maxRadius - minRadius;\n        }\n        for (var i = 0; i < point.length; i++) {\n            this.renderPoint(series, series.points[point[i]], isInverted, radius, maximumSize, minRadius, visiblePoints, true);\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * To destroy the Bubble.\n     *\n     * @returns {void}\n     * @private\n     */\n    BubbleSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    BubbleSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'BubbleSeries';\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    BubbleSeries.prototype.doAnimation = function (series) {\n        var duration = series.animation.duration;\n        var delay = series.animation.delay;\n        var rectElements = series.seriesElement.childNodes;\n        var count = 1;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var bubblePoint = _a[_i];\n            if (!bubblePoint.symbolLocations.length) {\n                continue;\n            }\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerAnimate)(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);\n            count++;\n        }\n    };\n    return BubbleSeries;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/bubble-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/candle-series.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/candle-series.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CandleSeries: () => (/* binding */ CandleSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `CandleSeries` module is used to render the candle series.\n */\nvar CandleSeries = /** @class */ (function (_super) {\n    __extends(CandleSeries, _super);\n    function CandleSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sideBySideInfo = [];\n        return _this;\n    }\n    /**\n     * Render Candle series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @returns {void}\n     * @private\n     */\n    CandleSeries.prototype.render = function (series) {\n        this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);\n        var borderWidth = Math.max(series.border.width, 1);\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            this.renderPoint(series, point, this.sideBySideInfo[series.index], borderWidth);\n        }\n    };\n    CandleSeries.prototype.renderPoint = function (series, point, sideBySideInfo, borderWidth) {\n        var direction = '';\n        var centerRegion;\n        var tickRegion;\n        //initializing after zooming and also normal initialization\n        point.regions = [];\n        point.symbolLocations = [];\n        if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n            //region to cover the top and bottom ticks\n            tickRegion = this.getRectangle((point.xValue + sideBySideInfo.median), Math.max(point.high, point.low), (point.xValue + sideBySideInfo.median), Math.min(point.high, point.low), series);\n            if (!series.chart.requireInvertedAxis) {\n                tickRegion.x -= borderWidth / 2;\n                tickRegion.width = borderWidth;\n            }\n            else {\n                tickRegion.y -= borderWidth / 2;\n                tickRegion.height = borderWidth;\n            }\n            //get middleRect\n            centerRegion = this.getRectangle((point.xValue + sideBySideInfo.start), Math.max(point.open, point.close), (point.xValue + sideBySideInfo.end), Math.min(point.open, point.close), series);\n            direction = this.getPathString(tickRegion, centerRegion, series);\n            var argsData = this.triggerPointRenderEvent(series, point);\n            if (!argsData.cancel) {\n                this.drawCandle(series, point, centerRegion, argsData, direction);\n                this.updateSymbolLocation(point, tickRegion, series);\n                this.updateSymbolLocation(point, centerRegion, series);\n            }\n        }\n    };\n    CandleSeries.prototype.updateDirection = function (series, point) {\n        var borderWidth = Math.max(series.border.width, 1);\n        for (var i = 0; i < point.length; i++) {\n            this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index], borderWidth);\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * Triggers the point render event for the specified series and point.\n     *\n     * @protected\n     * @param {Series} series - The series associated with the point.\n     * @param {Points} point - The point to be rendered.\n     * @returns {IPointRenderEventArgs} - The event arguments for the point render event.\n     */\n    CandleSeries.prototype.triggerPointRenderEvent = function (series, point) {\n        var fill = this.getCandleColor(point, series);\n        var border = { color: series.border.color, width: Math.max(series.border.width, 1) };\n        return this.triggerEvent(series, point, fill, border);\n    };\n    /**\n     * Find the color of the candle\n     *\n     * @param {Points} point point\n     * @param {Series} series series\n     * @returns {string} color of the candle\n     * @private\n     */\n    CandleSeries.prototype.getCandleColor = function (point, series) {\n        var previousPoint = series.points[point.index - 1];\n        if (series.enableSolidCandles === false) {\n            if (!previousPoint) {\n                return series.bearFillColor || series.chart.themeStyle.bearFillColor;\n            }\n            else {\n                return previousPoint.close > point.close ? series.bullFillColor\n                    || series.chart.themeStyle.bullFillColor : series.bearFillColor || series.chart.themeStyle.bearFillColor;\n            }\n        }\n        else {\n            return point.open > point.close ? series.bullFillColor || series.chart.themeStyle.bullFillColor :\n                series.bearFillColor || series.chart.themeStyle.bearFillColor;\n        }\n    };\n    /**\n     * Generates the SVG path string based on the top and mid rectangles for the specified series.\n     *\n     * @param {Rect} topRect - The top rectangle.\n     * @param {Rect} midRect - The mid rectangle.\n     * @param {Series} series - The series for which the path string is generated.\n     * @returns {string} - The SVG path string.\n     * @private\n     */\n    CandleSeries.prototype.getPathString = function (topRect, midRect, series) {\n        var direction = '';\n        var center = series.chart.requireInvertedAxis ? topRect.y + topRect.height / 2 :\n            topRect.x + topRect.width / 2;\n        //tick 1 segment\n        direction += !series.chart.requireInvertedAxis ?\n            'M' + ' ' + (center) + ' ' + (topRect.y) + ' ' + 'L' + ' ' + (center) + ' ' + midRect.y :\n            'M' + ' ' + (topRect.x) + ' ' + (center) + ' ' + 'L' + ' ' + (midRect.x) + ' ' + center;\n        direction = direction.concat(' M' + ' ' + (midRect.x) + ' ' + (midRect.y) + ' ' +\n            'L' + ' ' + (midRect.x + midRect.width) + ' ' + (midRect.y) + ' ' +\n            'L' + ' ' + (midRect.x + midRect.width) + ' ' +\n            (midRect.y + midRect.height) + ' ' +\n            'L' + ' ' + (midRect.x) + ' ' + (midRect.y + midRect.height) +\n            ' ' + 'Z');\n        direction += !series.chart.requireInvertedAxis ?\n            ' M' + ' ' + (center) + ' ' + (midRect.y + midRect.height) + ' ' + 'L' + ' ' + (center) + ' ' + (topRect.y +\n                topRect.height) :\n            ' M' + ' ' + (midRect.x + midRect.width) + ' ' + (center) + ' ' + 'L' + ' ' +\n                (topRect.x + topRect.width) + ' ' + center;\n        return direction;\n    };\n    /**\n     * Draws the candle shape\n     *\n     * @param {Series} series series\n     * @param {Points} point point\n     * @param {Rect} rect point region\n     * @param {IPointRenderEventArgs} argsData argsData\n     * @param {string} direction path direction\n     * @returns {void}\n     * @private\n     */\n    CandleSeries.prototype.drawCandle = function (series, point, rect, argsData, direction) {\n        var check = series.chart.requireInvertedAxis ? rect.height : rect.width;\n        if (check <= 0) {\n            return null;\n        }\n        var fill = !series.enableSolidCandles ?\n            (point.open > point.close ? argsData.fill : 'transparent') : argsData.fill;\n        argsData.border.color = argsData.fill;\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index), fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);\n        var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(options.id);\n        var previousDirection = element ? element.getAttribute('d') : null;\n        var candleElement = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n            candleElement.id = series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n        }\n        candleElement.setAttribute('role', 'img');\n        candleElement.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : (point.x.toString() + ':' + point.high.toString()\n            + ':' + point.low.toString() + ':' + point.close.toString() + ':' + point.open.toString()));\n        if (!series.chart.enableCanvas) {\n            series.seriesElement.appendChild(candleElement);\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.pathAnimation)(element, direction, series.chart.redraw, previousDirection, series.chart.duration);\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    CandleSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    CandleSeries.prototype.getModuleName = function () {\n        return 'CandleSeries';\n        /**\n         * return the module name.\n         */\n    };\n    /**\n     * To destroy the candle series.\n     *\n     * @returns {void}\n     * @private\n     */\n    CandleSeries.prototype.destroy = function () {\n        /**\n         * Destroys the candle series.\n         */\n    };\n    return CandleSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_2__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/candle-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/column-series.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/column-series.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSeries: () => (/* binding */ ColumnSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `ColumnSeries` module is used to render the column series.\n */\nvar ColumnSeries = /** @class */ (function (_super) {\n    __extends(ColumnSeries, _super);\n    function ColumnSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sideBySideInfo = [];\n        return _this;\n    }\n    ColumnSeries.prototype.render = function (series) {\n        this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var pointColumn = _a[_i];\n            this.renderPoint(series, pointColumn, this.sideBySideInfo[series.index], origin);\n        }\n        this.renderMarker(series);\n    };\n    ColumnSeries.prototype.renderPoint = function (series, pointColumn, sideBySideInfo, origin) {\n        pointColumn.symbolLocations = [];\n        pointColumn.regions = [];\n        if (pointColumn.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(series.points[pointColumn.index - 1], pointColumn, series.points[pointColumn.index + 1], series)) {\n            this.rect = this.getRectangle(pointColumn.xValue + sideBySideInfo.start, pointColumn.yValue, pointColumn.xValue + sideBySideInfo.end, origin, series);\n            this.rect.width = series.columnWidthInPixel ? (series.columnWidthInPixel - (series.chart.enableSideBySidePlacement ?\n                series.columnWidthInPixel * series.columnSpacing : 0)) : this.rect.width;\n            this.rect.x = series.columnWidthInPixel ? this.rect.x - (((series.columnWidthInPixel / 2) * series.rectCount) -\n                (series.columnWidthInPixel * series.index)) : this.rect.x;\n            var color = series.category === 'Indicator' ? pointColumn.color : series.interior;\n            var argsData = this.triggerEvent(series, pointColumn, color, { width: series.border.width, color: series.border.color });\n            if (!argsData.cancel) {\n                var adjustedYPosition = this.rect.y;\n                if (pointColumn.yValue < origin && pointColumn.yValue >= 0 && series.chart.zoomModule &&\n                    series.chart.zoomModule.isAxisZoomed(series.chart.axisCollections)) {\n                    adjustedYPosition = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(pointColumn.xValue + sideBySideInfo.start, pointColumn.yValue, series.xAxis, series.yAxis, series.chart.requireInvertedAxis).y;\n                }\n                this.updateSymbolLocation(pointColumn, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(this.rect.x, adjustedYPosition, this.rect.width, this.rect.height), series);\n                this.drawRectangle(series, pointColumn, this.rect, argsData);\n                if (series.columnFacet === 'Cylinder') {\n                    var cylinderSeriesOption = {\n                        'isColumn': true,\n                        'stacking': false,\n                        'isLastSeries': true\n                    };\n                    this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);\n                }\n            }\n        }\n    };\n    ColumnSeries.prototype.updateDirection = function (series, point) {\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        for (var i = 0; i < point.length; i++) {\n            this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index], origin);\n            if (series.marker && series.marker.visible) {\n                series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    ColumnSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    ColumnSeries.prototype.getModuleName = function () {\n        return 'ColumnSeries';\n        /**\n         * return the module name.\n         */\n    };\n    /**\n     * To destroy the column series.\n     *\n     * @returns {void}\n     * @private\n     */\n    ColumnSeries.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    return ColumnSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_2__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/column-series.js?");

/***/ })

}]);