"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_pdf-base_signature-base_js-98b2150-73cb9bd6"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdf-base/signature-base.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdf-base/signature-base.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignatureBase: () => (/* binding */ SignatureBase)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdf-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_pdf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-pdf */ \"./node_modules/@syncfusion/ej2-pdf/index.js\");\n/* harmony import */ var _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-drawings */ \"./node_modules/@syncfusion/ej2-drawings/index.js\");\n\n\n\n\n/**\n * SignatureBase\n *\n * @hidden\n */\nvar SignatureBase = /** @class */ (function () {\n    function SignatureBase(pdfViewer, pdfViewerBase) {\n        this.pdfViewer = pdfViewer;\n        this.pdfViewerBase = pdfViewerBase;\n    }\n    /**\n     * @private\n     * @param {string} jsonObject - jsonObject\n     * @param {any} loadedDocument - loadedDocument\n     * @returns {void}\n     */\n    SignatureBase.prototype.saveSignatureData = function (jsonObject, loadedDocument) {\n        var formfields = new _index__WEBPACK_IMPORTED_MODULE_1__.FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n        var signatureDetails = JSON.parse(jsonObject.signatureData);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(signatureDetails)) {\n            for (var i = 0; i < signatureDetails.length; i++) {\n                var pageData = signatureDetails[parseInt(i.toString(), 10)];\n                // Save signature as data\n                if (pageData.length > 0) {\n                    for (var p = 0; p < pageData.length; p++) {\n                        var data = pageData[parseInt(p.toString(), 10)];\n                        var signatureType = Object.prototype.hasOwnProperty.call(data, 'shapeAnnotationType') && data['shapeAnnotationType'] !== null\n                            ? data['shapeAnnotationType'].toString()\n                            : null;\n                        if (signatureType !== null && signatureType === 'SignatureText') {\n                            formfields.drawFreeTextAnnotations(data, loadedDocument, true);\n                        }\n                        else if (signatureType !== null && signatureType === 'SignatureImage') {\n                            formfields.drawImage(data, loadedDocument, true);\n                        }\n                        else {\n                            var pageNumber = data.pageIndex;\n                            var page = loadedDocument.getPage(pageNumber);\n                            var rotateAngle = this.getRotateAngle(page.rotation.toString());\n                            var size = page.size;\n                            var pageWidth = size[0];\n                            var pageHeight = size[1];\n                            if (rotateAngle === 1 || rotateAngle === 3) {\n                                pageHeight = size[0];\n                                pageWidth = size[1];\n                            }\n                            else {\n                                pageHeight = size[1];\n                                pageWidth = size[0];\n                            }\n                            var bounds = JSON.parse(data.bounds);\n                            bounds = this.getSignatureBounds(bounds, this.convertPointToPixel(pageHeight), this.convertPointToPixel(pageWidth), rotateAngle);\n                            var stampObjects = JSON.parse(data.data);\n                            var left = this.convertPixelToPoint(bounds.left);\n                            var top_1 = this.convertPixelToPoint(bounds.top);\n                            var width = this.convertPixelToPoint(bounds.width);\n                            var height = this.convertPixelToPoint(bounds.height);\n                            var opacity = data.opacity;\n                            var thickness = data.thickness;\n                            var strokeColor = JSON.parse(data.strokeColor);\n                            var color = [strokeColor.r, strokeColor.g, strokeColor.b];\n                            var minimumX = -1;\n                            var minimumY = -1;\n                            var maximumX = -1;\n                            var maximumY = -1;\n                            for (var p_1 = 0; p_1 < stampObjects.length; p_1++) {\n                                var value = stampObjects[parseInt(p_1.toString(), 10)];\n                                if (minimumX === -1) {\n                                    minimumX = value.x;\n                                    minimumY = value.y;\n                                    maximumX = value.x;\n                                    maximumY = value.x;\n                                }\n                                else {\n                                    var point1 = value.x;\n                                    var point2 = value.y;\n                                    if (minimumX >= point1) {\n                                        minimumX = point1;\n                                    }\n                                    if (minimumY >= point2) {\n                                        minimumY = point2;\n                                    }\n                                    if (maximumX <= point1) {\n                                        maximumX = point1;\n                                    }\n                                    if (maximumY <= point2) {\n                                        maximumY = point2;\n                                    }\n                                }\n                            }\n                            var newDifferenceX = maximumX - minimumX;\n                            var newDifferenceY = maximumY - minimumY;\n                            var newPoint1 = [0, 0];\n                            var loadedPage = loadedDocument.getPage(pageNumber);\n                            var graphics = null;\n                            if (loadedPage != null) {\n                                graphics = loadedPage.graphics;\n                                graphics.save();\n                                graphics.setTransparency(opacity);\n                                graphics.translateTransform(left, top_1);\n                            }\n                            var colors = new _syncfusion_ej2_pdf__WEBPACK_IMPORTED_MODULE_2__.PdfPen(color, width);\n                            colors._width = this.convertPixelToPoint(thickness);\n                            if (stampObjects.length > 0) {\n                                var dataPath = new _syncfusion_ej2_pdf__WEBPACK_IMPORTED_MODULE_2__.PdfPath();\n                                for (var j = 0; j < stampObjects.length; j++) {\n                                    var value = stampObjects[parseInt(j.toString(), 10)];\n                                    var path = value.command.toString();\n                                    var differenceX = ((newDifferenceX) / width);\n                                    var differenceY = ((newDifferenceY) / height);\n                                    var newX = ((value.x - minimumX) / differenceX);\n                                    var currentY = ((value.y - minimumY) / differenceY);\n                                    if (path === 'M') {\n                                        if (j !== 0) {\n                                            page.graphics.drawPath(dataPath, colors, null);\n                                            dataPath = new _syncfusion_ej2_pdf__WEBPACK_IMPORTED_MODULE_2__.PdfPath();\n                                        }\n                                        newPoint1 = [newX, currentY];\n                                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(graphics)) {\n                                            dataPath.addLine(newX, currentY, newX, currentY);\n                                        }\n                                    }\n                                    else if (path === 'L') {\n                                        var newPoint2 = [newX, currentY];\n                                        if (graphics != null) {\n                                            // Removed this line to fix the issue EJ2-60295\n                                            // graphics.DrawLine(colors, newpoint1, newpoint2);\n                                            dataPath.addLine(newPoint1[0], newPoint1[1], newPoint2[0], newPoint2[1]);\n                                        }\n                                        newPoint1 = newPoint2;\n                                    }\n                                    if (j === stampObjects.length - 1) {\n                                        page.graphics.drawPath(dataPath, colors, null);\n                                    }\n                                }\n                            }\n                            if (graphics != null) {\n                                graphics.restore();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * getSignatureBounds\n     *\n     * @param {Rect} bounds - bounds\n     * @param {number} pageHeight - pageHeight\n     * @param {number} pageWidth - pageWidth\n     * @param {number} rotateAngle - rotateAngle\n     * @returns {void}\n     */\n    SignatureBase.prototype.getSignatureBounds = function (bounds, pageHeight, pageWidth, rotateAngle) {\n        var bound;\n        if (rotateAngle === 0) {\n            bound = { 'left': bounds.left, 'top': bounds.top, 'width': bounds.width, 'height': bounds.height };\n        }\n        else if (rotateAngle === 1) {\n            bound = { 'left': (pageWidth - bounds.top - bounds.height), 'top': bounds.left, 'width': bounds.height, 'height': bounds.width };\n        }\n        else if (rotateAngle === 2) {\n            bound = { 'left': (pageWidth - bounds.left - bounds.width), 'top': (pageHeight - bounds.top - bounds.height), 'width': bounds.width, 'height': bounds.height };\n        }\n        else if (rotateAngle === 3) {\n            bound = { 'left': bounds.top, 'top': (pageHeight - bounds.left - bounds.width), 'width': bounds.height, 'height': bounds.width };\n        }\n        return bound;\n    };\n    /**\n     * @private\n     * @param {string} jsonObject - jsonObject\n     * @param {any} loadedDocument - loadedDocument\n     * @returns {void}\n     */\n    SignatureBase.prototype.saveSignatureAsAnnotatation = function (jsonObject, loadedDocument) {\n        var annotationRenderer = new _index__WEBPACK_IMPORTED_MODULE_1__.AnnotationRenderer(this.pdfViewer, this.pdfViewerBase);\n        var signatureDetails = JSON.parse(jsonObject.signatureData);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(signatureDetails)) {\n            for (var i = 0; i < signatureDetails.length; i++) {\n                var pageData = signatureDetails[parseInt(i.toString(), 10)];\n                // Save signature as data\n                if (pageData.length > 0) {\n                    for (var p = 0; p < pageData.length; p++) {\n                        var formfields = new _index__WEBPACK_IMPORTED_MODULE_1__.FormFieldsBase(this.pdfViewer, this.pdfViewerBase);\n                        var signatureAnnotation = pageData[parseInt(p.toString(), 10)];\n                        var signatureType = Object.prototype.hasOwnProperty.call(signatureAnnotation, 'shapeAnnotationType') && signatureAnnotation['shapeAnnotationType'] !== null\n                            ? signatureAnnotation['shapeAnnotationType'].toString()\n                            : null;\n                        if (signatureType !== null && signatureType === 'SignatureText') {\n                            formfields.drawFreeTextAnnotations(signatureAnnotation, loadedDocument, false);\n                        }\n                        else if (signatureType !== null && signatureType === 'SignatureImage') {\n                            formfields.drawImage(signatureAnnotation, loadedDocument, false);\n                        }\n                        else {\n                            var bounds = JSON.parse(signatureAnnotation.bounds);\n                            var stampObjects = JSON.parse(signatureAnnotation.data);\n                            var pageNumber = signatureAnnotation.pageIndex;\n                            var page = loadedDocument.getPage(pageNumber);\n                            var cropValues = annotationRenderer.getCropBoxValue(page, false);\n                            var left = cropValues.x + this.convertPixelToPoint(bounds.left);\n                            var top_2 = this.convertPixelToPoint(bounds.top);\n                            if (!(cropValues.x === 0 && (page.cropBox[2] === page.size[0] && cropValues.y === page.size[1]))) {\n                                top_2 -= cropValues.y;\n                            }\n                            var width = this.convertPixelToPoint(bounds.width);\n                            var height = this.convertPixelToPoint(bounds.height);\n                            // let cropX = 0;\n                            // let cropY = 0;\n                            // if(page.cropBox.x)\n                            var opacity = signatureAnnotation.opacity;\n                            var thickness = signatureAnnotation.thickness;\n                            var strokeColor = JSON.parse(signatureAnnotation.strokeColor);\n                            var color = [strokeColor.r, strokeColor.g, strokeColor.b];\n                            var minimumX = -1;\n                            var minimumY = -1;\n                            var maximumX = -1;\n                            var maximumY = -1;\n                            var rotationAngle = annotationRenderer.getInkRotateAngle(page.rotation.toString());\n                            var drawingPath = new _syncfusion_ej2_pdf__WEBPACK_IMPORTED_MODULE_2__.PdfPath();\n                            for (var p_2 = 0; p_2 < stampObjects.length; p_2++) {\n                                var val = stampObjects[parseInt(p_2.toString(), 10)];\n                                drawingPath.addLine(val.x, val.y, 0, 0);\n                            }\n                            var rotatedPath = annotationRenderer.getRotatedPathForMinMax(drawingPath._points, rotationAngle);\n                            for (var k = 0; k < rotatedPath.points.length; k += 2) {\n                                var value = rotatedPath.points[parseInt(k.toString(), 10)];\n                                if (minimumX === -1) {\n                                    minimumX = value[0];\n                                    minimumY = value[1];\n                                    maximumX = value[0];\n                                    maximumY = value[1];\n                                }\n                                else {\n                                    var point1 = value[0];\n                                    var point2 = value[1];\n                                    if (minimumX >= point1) {\n                                        minimumX = point1;\n                                    }\n                                    if (minimumY >= point2) {\n                                        minimumY = point2;\n                                    }\n                                    if (maximumX <= point1) {\n                                        maximumX = point1;\n                                    }\n                                    if (maximumY <= point2) {\n                                        maximumY = point2;\n                                    }\n                                }\n                            }\n                            var newDifferenceX = (maximumX - minimumX) / width;\n                            var newDifferenceY = (maximumY - minimumY) / height;\n                            if (newDifferenceX === 0) {\n                                newDifferenceX = 1;\n                            }\n                            else if (newDifferenceY === 0) {\n                                newDifferenceY = 1;\n                            }\n                            var linePoints = [];\n                            var isNewValues = 0;\n                            if (rotationAngle !== 0) {\n                                for (var j = 0; j < stampObjects.length; j++) {\n                                    var val = stampObjects[parseInt(j.toString(), 10)];\n                                    var path = val['command'].toString();\n                                    if (path === 'M' && j !== isNewValues) {\n                                        isNewValues = j;\n                                        break;\n                                    }\n                                    linePoints.push((parseFloat(val['x'].toString())));\n                                    linePoints.push((parseFloat(val['y'].toString())));\n                                }\n                                var rotatedPoints = annotationRenderer.getRotatedPath(linePoints, rotationAngle);\n                                linePoints = [];\n                                for (var z = 0; z < rotatedPoints._points.length; z += 2) {\n                                    linePoints.push((rotatedPoints._points[parseInt(z.toString(), 10)][0] - minimumX)\n                                        / newDifferenceX + left);\n                                    linePoints.push(page.size[1] - (rotatedPoints._points[parseInt(z.toString(), 10)][1]\n                                        - minimumY) / newDifferenceY - top_2);\n                                }\n                            }\n                            else {\n                                for (var j = 0; j < stampObjects.length; j++) {\n                                    var val = stampObjects[parseInt(j.toString(), 10)];\n                                    var path = val['command'].toString();\n                                    if (path === 'M' && j !== isNewValues) {\n                                        isNewValues = j;\n                                        break;\n                                    }\n                                    linePoints.push(((val.x - minimumX) / newDifferenceX) + left);\n                                    var newX = ((val.y - minimumY) / newDifferenceY);\n                                    linePoints.push(page.size[1] - newX - top_2);\n                                }\n                            }\n                            var inkAnnotation = new _syncfusion_ej2_pdf__WEBPACK_IMPORTED_MODULE_2__.PdfInkAnnotation([left, top_2, width, height], linePoints);\n                            var bound = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_3__.Rect();\n                            bound = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_3__.Rect(inkAnnotation.bounds.x, (page.size[1] - (inkAnnotation.bounds.y +\n                                inkAnnotation.bounds.height)), inkAnnotation.bounds.width, inkAnnotation.bounds.height);\n                            inkAnnotation.bounds = bound;\n                            inkAnnotation.color = color;\n                            linePoints = [];\n                            if (isNewValues > 0) {\n                                if (rotationAngle !== 0) {\n                                    var pathCollection = [];\n                                    for (var i_1 = isNewValues; i_1 < stampObjects.length; i_1++) {\n                                        var val = stampObjects[parseInt(i_1.toString(), 10)];\n                                        var path = val['command'].toString();\n                                        if (path === 'M' && i_1 !== isNewValues) {\n                                            pathCollection.push(linePoints);\n                                            linePoints = [];\n                                        }\n                                        linePoints.push(val['x']);\n                                        linePoints.push(val['y']);\n                                    }\n                                    if (linePoints.length > 0) {\n                                        pathCollection.push(linePoints);\n                                    }\n                                    for (var g = 0; g < pathCollection.length; g++) {\n                                        var graphicsPoints = [];\n                                        var pointsCollections = pathCollection[parseInt(g.toString(), 10)];\n                                        if (pointsCollections.length > 0) {\n                                            var rotatedPoints = annotationRenderer.getRotatedPath(pointsCollections, rotationAngle);\n                                            for (var z = 0; z < rotatedPoints._points.length; z += 2) {\n                                                graphicsPoints.push((rotatedPoints._points[parseInt(z.toString(), 10)][0] - minimumX)\n                                                    / newDifferenceX + left);\n                                                graphicsPoints.push(page.size[1] - (rotatedPoints._points[parseInt(z.toString(), 10)][1]\n                                                    - minimumY) / newDifferenceY - top_2);\n                                            }\n                                            inkAnnotation.inkPointsCollection.push(graphicsPoints);\n                                        }\n                                        graphicsPoints = [];\n                                    }\n                                }\n                                else {\n                                    for (var i_2 = isNewValues; i_2 < stampObjects.length; i_2++) {\n                                        var val = stampObjects[parseInt(i_2.toString(), 10)];\n                                        var path = val['command'].toString();\n                                        if (path === 'M' && i_2 !== isNewValues) {\n                                            inkAnnotation.inkPointsCollection.push(linePoints);\n                                            linePoints = [];\n                                        }\n                                        linePoints.push((val['x'] - minimumX) / newDifferenceX + left);\n                                        var newX = ((val['y'] - minimumY) / newDifferenceY);\n                                        linePoints.push(page.size[1] - newX - top_2);\n                                    }\n                                    if (linePoints.length > 0) {\n                                        inkAnnotation.inkPointsCollection.push(linePoints);\n                                    }\n                                }\n                            }\n                            inkAnnotation.border.width = thickness;\n                            inkAnnotation.opacity = opacity;\n                            inkAnnotation._dictionary.set('NM', signatureAnnotation.signatureName.toString());\n                            inkAnnotation._annotFlags = _syncfusion_ej2_pdf__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.print;\n                            if (Object.prototype.hasOwnProperty.call(signatureAnnotation, 'author') && signatureAnnotation['author'] !== null) {\n                                var author = signatureAnnotation['author'].toString();\n                                if (author !== 'Guest') {\n                                    inkAnnotation.author = author;\n                                }\n                            }\n                            page.annotations.add(inkAnnotation);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    SignatureBase.prototype.convertPointToPixel = function (number) {\n        return number * 96 / 72;\n    };\n    SignatureBase.prototype.convertPixelToPoint = function (value) {\n        return (value * (72 / 96));\n    };\n    SignatureBase.prototype.getRotateAngle = function (angleString) {\n        var angle = 0;\n        switch (angleString) {\n            case 'RotateAngle0':\n            case '0':\n                angle = 0;\n                break;\n            case 'RotateAngle180':\n            case '2':\n                angle = 2;\n                break;\n            case 'RotateAngle270':\n            case '3':\n                angle = 3;\n                break;\n            case 'RotateAngle90':\n            case '1':\n                angle = 1;\n                break;\n        }\n        return angle;\n    };\n    return SignatureBase;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/pdf-base/signature-base.js?");

/***/ })

}]);