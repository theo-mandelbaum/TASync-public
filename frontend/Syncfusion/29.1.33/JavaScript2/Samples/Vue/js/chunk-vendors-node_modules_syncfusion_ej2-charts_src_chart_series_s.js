"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_s"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/step-area-series.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/step-area-series.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StepAreaSeries: () => (/* binding */ StepAreaSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _line_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `StepAreaSeries` module is used to render the step area series.\n */\nvar StepAreaSeries = /** @class */ (function (_super) {\n    __extends(StepAreaSeries, _super);\n    function StepAreaSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render Step Area series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The x-axis of the chart.\n     * @param {Axis} yAxis - The y-axis of the chart.\n     * @param {boolean} isInverted - Specifies whether the chart is inverted.\n     * @param {boolean} pointAnimate - Specifies whether the point has to be animated or not.\n     * @param {boolean} pointUpdate - Specifies whether the point has to be updated or not.\n     * @returns {void}\n     * @private\n     */\n    StepAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        var currentPoint;\n        var secondPoint;\n        var start = null;\n        var direction = '';\n        var visiblePoints = this.enableComplexProperty(series);\n        var pointsLength = visiblePoints.length;\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        var point;\n        var xValue;\n        var lineLength;\n        var prevPoint = null;\n        var borderDirection = '';\n        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n            lineLength = 0.5;\n        }\n        else {\n            lineLength = 0;\n        }\n        for (var i = 0; i < pointsLength; i++) {\n            point = visiblePoints[i];\n            xValue = point.xValue;\n            point.symbolLocations = [];\n            point.regions = [];\n            if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoints[i - 1], point, visiblePoints[i + 1], series)) {\n                if (start === null) {\n                    start = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(xValue, 0);\n                    // Start point for the current path\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(xValue - lineLength, origin, xAxis, yAxis, isInverted);\n                    direction += ('M' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(xValue - lineLength, point.yValue, xAxis, yAxis, isInverted);\n                    direction += ('L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                    borderDirection += ('M' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                }\n                // First Point to draw the Steparea path\n                if (prevPoint != null) {\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.yValue, xAxis, yAxis, isInverted);\n                    secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(prevPoint.xValue, prevPoint.yValue, xAxis, yAxis, isInverted);\n                    direction = direction.concat(this.GetStepLineDirection(currentPoint, secondPoint, series.step, 'L', series));\n                    borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, 'L', series, true));\n                }\n                else if (series.emptyPointSettings.mode === 'Gap') {\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.yValue, xAxis, yAxis, isInverted);\n                    direction += 'L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';\n                    borderDirection += 'L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';\n                }\n                this.storePointLocation(point, series, isInverted, _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint);\n                prevPoint = point;\n            }\n            if (visiblePoints[i + 1] && !visiblePoints[i + 1].visible && series.emptyPointSettings.mode !== 'Drop') {\n                // current start point\n                currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(xValue + lineLength, origin, xAxis, yAxis, isInverted);\n                direction += ('L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y));\n                start = null;\n                prevPoint = null;\n            }\n        }\n        if ((pointsLength > 1) && direction !== '') {\n            start = { 'x': visiblePoints[pointsLength - 1].xValue + lineLength, 'y': visiblePoints[pointsLength - 1].yValue };\n            secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(start.x, start.y, xAxis, yAxis, isInverted);\n            direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n            borderDirection += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n            start = { 'x': visiblePoints[pointsLength - 1].xValue + lineLength, 'y': origin };\n            secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(start.x, start.y, xAxis, yAxis, isInverted);\n            direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\n        }\n        else {\n            direction = '';\n        }\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);\n        this[pointAnimate ? 'addAreaPath' : 'appendLinePath'](options, series, '');\n        /**\n         * To draw border for the path directions of area\n         */\n        if (series.border.width !== 0) {\n            var options_1 = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', series.border.width, series.border.color ? series.border.color : series.interior, 1, series.border.dashArray, borderDirection);\n            this[pointAnimate ? 'addAreaPath' : 'appendLinePath'](options_1, series, '');\n        }\n        if (!pointUpdate) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * To animate point for step area series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    StepAreaSeries.prototype.updateDirection = function (series, point) {\n        this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n        for (var i = 0; i < point.length; i++) {\n            if (series.marker && series.marker.visible) {\n                series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    StepAreaSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * To destroy the step Area series.\n     *\n     * @returns {void}\n     * @private\n     */\n    StepAreaSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    StepAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'StepAreaSeries';\n    };\n    return StepAreaSeries;\n}(_line_base__WEBPACK_IMPORTED_MODULE_2__.LineBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/step-area-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/step-line-series.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/step-line-series.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StepLineSeries: () => (/* binding */ StepLineSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _line_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `StepLineSeries` module is used to render the step line series.\n */\nvar StepLineSeries = /** @class */ (function (_super) {\n    __extends(StepLineSeries, _super);\n    function StepLineSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render the Step line series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The x-axis of the chart.\n     * @param {Axis} yAxis - The y-axis of the chart.\n     * @param {boolean} isInverted - Specifies whether the chart is inverted.\n     * @param {boolean} pointAnimate - Specifies whether the point has to be animated or not.\n     * @param {boolean} pointUpdate - Specifies whether the point has to be updated or not.\n     * @returns {void}\n     * @private\n     */\n    StepLineSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        var direction = '';\n        var startPoint = 'M';\n        var prevPoint = null;\n        var lineLength;\n        var point1;\n        var point2;\n        var visiblePoints = this.enableComplexProperty(series);\n        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n            lineLength = 0.5;\n        }\n        else {\n            lineLength = 0;\n        }\n        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n            var point = visiblePoints_1[_i];\n            point.symbolLocations = [];\n            point.regions = [];\n            if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n                if (startPoint === 'M' && (!visiblePoints[point.index + 1] || !visiblePoints[point.index + 1].visible)) {\n                    direction = '';\n                }\n                if (prevPoint != null) {\n                    point2 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.yValue, xAxis, yAxis, isInverted);\n                    point1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(prevPoint.xValue, prevPoint.yValue, xAxis, yAxis, isInverted);\n                    direction = direction.concat(startPoint + ' ' + (point1.x) + ' ' + (point1.y) + this.GetStepLineDirection(point2, point1, series.step, 'L', series, true));\n                    startPoint = 'L';\n                }\n                else {\n                    point1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue - lineLength, point.yValue, xAxis, yAxis, isInverted);\n                    direction = direction.concat(startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ');\n                    startPoint = 'L';\n                }\n                this.storePointLocation(point, series, isInverted, _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint);\n                if (direction === '') {\n                    direction = 'M ' + point.symbolLocations[0].x + ' ' + point.symbolLocations[0].y;\n                }\n                prevPoint = point;\n            }\n            else {\n                prevPoint = series.emptyPointSettings.mode === 'Drop' ? prevPoint : null;\n                startPoint = series.emptyPointSettings.mode === 'Drop' ? startPoint : 'M';\n            }\n        }\n        if (visiblePoints.length > 0) {\n            point1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(visiblePoints[visiblePoints.length - 1].xValue + lineLength, visiblePoints[visiblePoints.length - 1].yValue, xAxis, yAxis, isInverted);\n            direction = direction.concat(startPoint + ' ' + (point1.x) + ' ' + (point1.y) + ' ');\n        }\n        var pathOptions = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index, 'transparent', series.width, series.interior, series.opacity, series.dashArray, direction);\n        this[pointAnimate ? 'addPath' : 'appendLinePath'](pathOptions, series, '');\n        if (!pointUpdate) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * To animate point for step line series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    StepLineSeries.prototype.updateDirection = function (series, point) {\n        this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n        for (var i = 0; i < point.length; i++) {\n            if (series.marker && series.marker.visible) {\n                series.chart.markerRender.renderMarker(series, series.points[point[i]], series.points[point[i]].symbolLocations[0], null, true);\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    StepLineSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * To destroy the step line series.\n     *\n     * @returns {void}\n     * @private\n     */\n    StepLineSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    StepLineSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'StepLineSeries';\n    };\n    return StepLineSeries;\n}(_line_base__WEBPACK_IMPORTED_MODULE_2__.LineBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/step-line-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/waterfall-series.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/waterfall-series.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WaterfallSeries: () => (/* binding */ WaterfallSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n/**\n * The `WaterfallSeries` module is used to render the waterfall series.\n */\nvar WaterfallSeries = /** @class */ (function (_super) {\n    __extends(WaterfallSeries, _super);\n    function WaterfallSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * Store the cumulative values of each index.\n         *\n         * @private\n         */\n        _this.cumulativeSums = [];\n        return _this;\n    }\n    /**\n     * Render waterfall series.\n     *\n     * @returns {void}\n     * @private\n     */\n    WaterfallSeries.prototype.render = function (series) {\n        var rect;\n        var sideBySideInfo = this.getSideBySideInfo(series);\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        var argsData;\n        var prevEndValue = 0;\n        var direction = '';\n        var currentEndValue = 0;\n        var originValue;\n        var prevRegion = null;\n        var y;\n        var isInversed = series.chart.requireInvertedAxis;\n        var intermediateOrigin = 0;\n        var redraw = series.chart.redraw;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            point.symbolLocations = [];\n            point.regions = [];\n            if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n                //Calcute the current point value to render waterfall series.\n                var isSum = this.isIntermediateSum(series, point.index);\n                var totalSum = this.isSumIndex(series, point.index);\n                currentEndValue += isSum || totalSum === true ? 0 : point.yValue;\n                //Calcute the origin value for points\n                originValue = (isSum === true ? intermediateOrigin : ((prevEndValue !== null && !totalSum) ? prevEndValue : origin));\n                rect = this.getRectangle(point.xValue + sideBySideInfo.start, currentEndValue, point.xValue + sideBySideInfo.end, originValue, series);\n                argsData = this.triggerPointRenderEvent(series, point);\n                //intermediateOrigin is used only for imtermediate data\n                if (isSum) {\n                    intermediateOrigin = currentEndValue;\n                }\n                prevEndValue = currentEndValue;\n                if (!argsData.cancel) {\n                    this.updateSymbolLocation(point, rect, series);\n                    this.drawRectangle(series, point, rect, argsData);\n                }\n                var currentRegion = point.regions[0];\n                if (prevRegion !== null) {\n                    var prevLeft = isInversed ? prevRegion.x : prevRegion.y;\n                    var currentLeft = isInversed ? currentRegion.x : currentRegion.y;\n                    var prevBottom = void 0;\n                    var currentBottom = void 0;\n                    var currentYValue = currentRegion.y;\n                    var currentXValue = currentRegion.x;\n                    var beforePoint = series.points[(point.index - 1 === -1) ? 1 : point.index - 1];\n                    if (point.yValue === 0) {\n                        prevBottom = isInversed ? prevRegion.x + prevRegion.width : prevRegion.y + prevRegion.height;\n                        currentBottom = isInversed ?\n                            point.symbolLocations[0].x : point.symbolLocations[0].y;\n                    }\n                    else {\n                        prevBottom = isInversed ? (beforePoint.yValue === 0) ?\n                            beforePoint.symbolLocations[0].x : prevRegion.x + prevRegion.width : (beforePoint.yValue === 0) ?\n                            beforePoint.symbolLocations[0].y : prevRegion.y + prevRegion.height;\n                        currentBottom = isInversed ?\n                            currentRegion.x + currentRegion.width : currentRegion.y + currentRegion.height;\n                    }\n                    if (Math.round(prevLeft) === Math.round(currentLeft) ||\n                        Math.round(prevBottom) === Math.round(currentLeft)) {\n                        y = isInversed ? (currentRegion.x === 0 && prevRegion.x === 0) ? currentBottom : currentRegion.x : currentRegion.y;\n                        y = (point.yValue === 0) ?\n                            (isInversed ? point.symbolLocations[0].x : point.symbolLocations[0].y) : y;\n                    }\n                    else {\n                        y = currentBottom;\n                    }\n                    if (isInversed) {\n                        if (beforePoint.yValue === 0) {\n                            prevRegion.y = ((prevRegion.y + prevRegion.height / 2) + (rect.height / 2)) - prevRegion.height;\n                        }\n                        if (point.yValue === 0) {\n                            currentYValue = ((currentRegion.y + currentRegion.height / 2) - (rect.height / 2));\n                        }\n                        direction = direction.concat('M' + ' ' + y + ' ' + (series.xAxis.isInversed ? (prevRegion.y + prevRegion.height) : prevRegion.y) + ' ' +\n                            'L' + ' ' + y + ' ' + (series.xAxis.isInversed ? currentYValue : (currentYValue + currentRegion.height)) + ' ');\n                    }\n                    else {\n                        var connectorX = prevRegion.x;\n                        if (beforePoint.yValue === 0) {\n                            connectorX = ((connectorX + prevRegion.width / 2) + (rect.width / 2)) - prevRegion.width;\n                            currentXValue = ((currentRegion.x + currentRegion.width / 2) + (rect.width / 2)) - currentRegion.width;\n                        }\n                        if (point.yValue === 0) {\n                            currentXValue = ((currentRegion.x + currentRegion.width / 2) - (rect.width / 2));\n                        }\n                        direction = direction.concat('M' + ' ' + (series.xAxis.isInversed ? connectorX : (connectorX + prevRegion.width)) + ' ' + y + ' ' +\n                            'L' + ' ' + (series.xAxis.isInversed ? (currentXValue + currentRegion.width) : currentXValue) + ' ' + y + ' ');\n                    }\n                }\n                prevRegion = point.regions[0];\n            }\n        }\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index + '_Connector_', 'none', series.connector.width, series.connector.color, series.opacity, series.connector.dashArray, direction);\n        if (redraw && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(options.id)) {\n            direction = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(options.id).getAttribute('d');\n        }\n        var element = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.redrawElement)(redraw, options.id, options, series.chart.renderer) ||\n            series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y])));\n        element.style.visibility = (!series.chart.enableCanvas) ? ((((series.animation.enable && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.animationMode !== 'Disable') || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.animationMode === 'Enable') && series.chart.animateSeries) ?\n            'hidden' : 'visible') : null;\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(series.chart.enableCanvas, series.seriesElement, element, redraw, true, null, null, null, direction, null, null, null, series.chart.duration);\n        this.renderMarker(series);\n    };\n    /**\n     * Updates the direction of rendering for the specified series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    WaterfallSeries.prototype.updateDirection = function (series, point) {\n        this.render(series);\n        if (series.marker.visible) {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(series.chart.enableCanvas, series.chart.seriesElements, series.symbolElement, true);\n        }\n        if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n            for (var i = 0; i < point.length; i++) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                var dataLabelElement = series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n                for (var j = 0; j < dataLabelElement.length; j++) {\n                    series.chart.dataLabelModule.doDataLabelAnimation(series, dataLabelElement[j]);\n                }\n            }\n        }\n    };\n    /**\n     * Checks whether the current point in the series is an intermediate sum.\n     *\n     * @param {Series} series - The series to check.\n     * @param {number} index - The index of the point in the series.\n     * @returns {boolean} - Returns true if the current point is an intermediate sum, otherwise false.\n     */\n    WaterfallSeries.prototype.isIntermediateSum = function (series, index) {\n        if (series.intermediateSumIndexes !== undefined && series.intermediateSumIndexes.indexOf(index) !== -1) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Checks whether the current point in the series is a sum index.\n     *\n     * @param {Series} series - The series to check.\n     * @param {number} index - The index of the point in the series.\n     * @returns {boolean} - Returns true if the current point is a sum index, otherwise false.\n     */\n    WaterfallSeries.prototype.isSumIndex = function (series, index) {\n        if (series.sumIndexes !== undefined && series.sumIndexes.indexOf(index) !== -1) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Triggers the point render event for a given series and point.\n     *\n     * @param {Series} series - The series to which the point belongs.\n     * @param {Points} point - The point for which to trigger the event.\n     * @returns {IPointRenderEventArgs} - The event arguments for the point render event.\n     */\n    WaterfallSeries.prototype.triggerPointRenderEvent = function (series, point) {\n        var color;\n        var isSum = this.isIntermediateSum(series, point.index);\n        var totalSum = this.isSumIndex(series, point.index);\n        if (isSum || totalSum) {\n            color = series.summaryFillColor;\n        }\n        else if (point.y < 0) {\n            color = series.negativeFillColor;\n        }\n        else {\n            color = series.interior;\n        }\n        return this.triggerEvent(series, point, color, { color: series.border.color, width: series.border.width });\n    };\n    /**\n     * Processes the internal data for a series.\n     *\n     * @param {Object[]} json - The internal data JSON array.\n     * @param {Series} series - The series for which to process the data.\n     * @returns {Object[]} - The processed internal data array.\n     * @private\n     */\n    WaterfallSeries.prototype.processInternalData = function (json, series) {\n        var data = json;\n        var index;\n        var sumValue = 0;\n        var intermediateSum = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(series.intermediateSumIndexes) && series.intermediateSumIndexes.length > 0) ?\n            series.intermediateSumIndexes.sort(function (a, b) { return a - b; }) : series.intermediateSumIndexes;\n        var sumIndex = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(series.sumIndexes) && series.sumIndexes.length > 0) ?\n            series.sumIndexes.sort(function (a, b) { return a - b; }) : series.sumIndexes;\n        var cumulativeSum = 0;\n        for (var i = 0; i < data.length; i++) {\n            cumulativeSum += data[i][series.yName] !== undefined ? data[i][series.yName] : 0;\n            this.cumulativeSums.push(cumulativeSum);\n        }\n        if (intermediateSum !== undefined && intermediateSum.length > 0) {\n            for (var i = 0; i < intermediateSum.length; i++) {\n                for (var j = 0; j < data.length; j++) {\n                    if (j === intermediateSum[i]) {\n                        if (i === 0) {\n                            index = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArraySum)(data, -1, intermediateSum[i], null, series);\n                        }\n                        else {\n                            index = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArraySum)(data, intermediateSum[i - 1], intermediateSum[i], null, series);\n                        }\n                        data[j][series.yName] = index;\n                    }\n                }\n            }\n        }\n        if (sumIndex !== undefined && sumIndex.length > 0) {\n            var intermediateSumCount = 0;\n            for (var k = 0; k < sumIndex.length; k++) {\n                for (var j = 0; j < data.length; j++) {\n                    if (j === sumIndex[k]) {\n                        if (intermediateSum !== undefined && intermediateSum.length > intermediateSumCount &&\n                            intermediateSum[k] !== sumIndex[k] && intermediateSum[k] <\n                            sumIndex[k]) {\n                            index = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArraySum)(data, intermediateSum.length <= 1 ? intermediateSum[0] - 1 :\n                                intermediateSum[k] - 1, sumIndex[k], sumIndex, series);\n                            intermediateSumCount += 1;\n                        }\n                        else {\n                            if (k === 0) {\n                                index = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArraySum)(data, -1, sumIndex[k], null, series);\n                            }\n                            else {\n                                index = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArraySum)(data, sumIndex[k - 1], sumIndex[k], null, series);\n                            }\n                        }\n                        sumValue += index;\n                        data[j][series.yName] = sumValue;\n                    }\n                }\n            }\n        }\n        return data;\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    WaterfallSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    WaterfallSeries.prototype.getModuleName = function () {\n        return 'WaterfallSeries';\n        /**\n         * return the module name.\n         */\n    };\n    /**\n     * To destroy the waterfall series.\n     *\n     * @returns {void}\n     * @private\n     */\n    WaterfallSeries.prototype.destroy = function () {\n        /**\n         * Destroys the waterfall series.\n         */\n    };\n    return WaterfallSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_2__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/waterfall-series.js?");

/***/ })

}]);