"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdf_src_pdf_core_pdf-cross-reference_js-6fa6ee2e"],{

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-cross-reference.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-cross-reference.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _PdfCrossReference: () => (/* binding */ _PdfCrossReference)\n/* harmony export */ });\n/* harmony import */ var _base_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-stream */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/base-stream.js\");\n/* harmony import */ var _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pdf-primitives */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-primitives.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/utils.js\");\n/* harmony import */ var _pdf_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pdf-parser */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-parser.js\");\n/* harmony import */ var _enumerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enumerator */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/enumerator.js\");\n/* harmony import */ var _security_encryptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./security/encryptor */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/security/encryptor.js\");\n\n\n\n\n\n\n\nvar _PdfCrossReference = /** @class */ (function () {\n    function _PdfCrossReference(document, password) {\n        this._version = '';\n        this._newLine = '\\r\\n';\n        this._password = password;\n        this._document = document;\n        this._stream = document._stream;\n        this._entries = [];\n        this._crossReferencePosition = Object.create(null);\n        this._cacheMap = new Map(); // eslint-disable-line\n        this._offsetReference = new Map(); // eslint-disable-line\n        this._pendingRefs = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReferenceSet();\n        this._offsets = [];\n    }\n    _PdfCrossReference.prototype._setStartXRef = function (startXRef) {\n        this._startXRefQueue = [startXRef];\n        this._prevStartXref = startXRef;\n        if (typeof this._prevXRefOffset === 'undefined' || this._prevXRefOffset === null) {\n            this._prevXRefOffset = startXRef;\n        }\n    };\n    _PdfCrossReference.prototype._parse = function (recoveryMode) {\n        var trailerDictionary;\n        if (!recoveryMode) {\n            trailerDictionary = this._readXRef();\n        }\n        else {\n            trailerDictionary = this._indexObjects();\n        }\n        trailerDictionary.assignXref(this);\n        var entrySize = trailerDictionary.get('Size');\n        if (this._entries.length < entrySize || this._entries.length === entrySize) {\n            this._nextReferenceNumber = entrySize;\n        }\n        else if (this._entries.length > entrySize) {\n            this._nextReferenceNumber = this._entries.length > 0 ? this._entries.length : 1;\n        }\n        this._trailer = trailerDictionary;\n        var encrypt = trailerDictionary.get('Encrypt');\n        if (encrypt) {\n            this._document._isEncrypted = true;\n            this._ids = trailerDictionary.get('ID');\n            this._permissionFlags = encrypt.get('P');\n            var fileId = this._ids && this._ids.length ? this._ids[0] : '';\n            encrypt.suppressEncryption = true;\n            this._encrypt = new _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._PdfEncryptor(encrypt, fileId, this._password);\n            this._document._isUserPassword = this._encrypt._isUserPassword;\n            this._document._encryptOnlyAttachment = this._encrypt._encryptOnlyAttachment;\n            if (this._document.fileStructure.isIncrementalUpdate) {\n                this._document.fileStructure.crossReferenceType = _enumerator__WEBPACK_IMPORTED_MODULE_4__.PdfCrossReferenceType.stream;\n            }\n            else {\n                this._document.fileStructure.crossReferenceType = _enumerator__WEBPACK_IMPORTED_MODULE_4__.PdfCrossReferenceType.table;\n            }\n            if (this._encrypt._encryptOnlyAttachment) {\n                this._document._hasUserPasswordOnly = true;\n                this._document._encryptMetaData = false;\n            }\n            else {\n                this._document._hasUserPasswordOnly = this._encrypt._hasUserPasswordOnly;\n                this._document._encryptMetaData = encrypt.has('EncryptMetadata') ? encrypt.get('EncryptMetadata') : true;\n            }\n        }\n        var hasRoot = false;\n        var root;\n        try {\n            root = trailerDictionary.get('Root');\n        }\n        catch (e) {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException('Invalid cross reference', 'XRefParseException');\n        }\n        if (root) {\n            try {\n                var pagesEntry = root.get('Pages');\n                if (pagesEntry) {\n                    this._root = root;\n                    hasRoot = true;\n                }\n            }\n            catch (ex) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException('Invalid cross reference', 'InvalidXRef');\n            }\n        }\n        if (!hasRoot) {\n            if (!recoveryMode) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException('Invalid cross reference', 'XRefParseException');\n            }\n            else {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException('Invalid cross reference', 'InvalidXRef');\n            }\n        }\n    };\n    _PdfCrossReference.prototype._getEntry = function (i) {\n        var xrefEntry = this._entries[i]; // eslint-disable-line\n        if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {\n            return xrefEntry;\n        }\n        return null;\n    };\n    _PdfCrossReference.prototype._fetch = function (ref, suppressEncryption) {\n        var entry; // eslint-disable-line\n        if (!(ref instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference)) {\n            throw new Error('ref object is not a reference');\n        }\n        var objectNumber = ref.objectNumber;\n        var cacheEntry = this._cacheMap.get(ref); // eslint-disable-line\n        if (typeof cacheEntry !== 'undefined') {\n            if (cacheEntry instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary && !cacheEntry.objId) {\n                cacheEntry.objId = objectNumber;\n            }\n            return cacheEntry;\n        }\n        var xrefEntry = this._getEntry(objectNumber);\n        if (xrefEntry === null) {\n            this._cacheMap.set(ref, xrefEntry);\n            return xrefEntry;\n        }\n        if (this._pendingRefs.has(ref)) {\n            this._pendingRefs.remove(ref);\n            throw new Error('circular reference');\n        }\n        this._pendingRefs.put(ref);\n        try {\n            if (xrefEntry.uncompressed) {\n                entry = this._fetchUncompressed(ref, xrefEntry, suppressEncryption);\n            }\n            else {\n                entry = this._fetchCompressed(ref, xrefEntry);\n            }\n            this._pendingRefs.remove(ref);\n        }\n        catch (ex) {\n            this._pendingRefs.remove(ref);\n            throw ex;\n        }\n        return entry;\n    };\n    _PdfCrossReference.prototype._fetchUncompressed = function (reference, xrefEntry, makeFilter) {\n        var generationNumber = reference.generationNumber;\n        var objectNumber = reference.objectNumber;\n        if (xrefEntry.gen !== generationNumber) {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException(\"Inconsistent generation in XRef: \" + reference, 'XRefEntryException');\n        }\n        var stream = this._stream.makeSubStream(xrefEntry.offset + this._stream.start, undefined);\n        var parser = new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfParser(new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfLexicalOperator(stream), this, true, false, this._encrypt);\n        var obj1 = parser.getObject();\n        var obj2 = parser.getObject();\n        var obj3 = parser.getObject();\n        if (obj1 !== objectNumber || obj2 !== generationNumber || typeof obj3 === 'undefined') {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException(\"Bad (uncompressed) XRef entry: \" + reference, 'XRefEntryException');\n        }\n        var entry; // eslint-disable-line\n        if (this._encrypt && !makeFilter) {\n            entry = parser.getObject(reference.objectNumber, reference.generationNumber, true);\n        }\n        else {\n            entry = parser.getObject(null, makeFilter);\n        }\n        if (!(entry instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream)) {\n            this._cacheMap.set(reference, entry);\n        }\n        if (entry instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n            entry.objId = reference.toString();\n        }\n        else if (entry instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n            entry.dictionary.objId = reference.toString();\n        }\n        return entry;\n    };\n    _PdfCrossReference.prototype._fetchCompressed = function (ref, xrefEntry) {\n        var tableOffset = xrefEntry.offset;\n        var stream = this._fetch(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference.get(tableOffset, 0));\n        if (typeof stream === 'undefined') {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('bad ObjStm stream');\n        }\n        var first = stream.dictionary.get('First');\n        var n = stream.dictionary.get('N');\n        var gen = ref.generationNumber;\n        if (!Number.isInteger(first) || !Number.isInteger(n)) {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('invalid first and n parameters for ObjStm stream');\n        }\n        var parser = new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfParser(new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfLexicalOperator(stream), this, true);\n        var nums = new Array(n);\n        var offsets = new Array(n);\n        for (var i = 0; i < n; ++i) {\n            var value = parser.getObject();\n            if (!Number.isInteger(value)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError(\"invalid object number in the ObjStm stream: \" + value);\n            }\n            var offset = parser.getObject();\n            if (!Number.isInteger(offset)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError(\"invalid object offset in the ObjStm stream: \" + offset);\n            }\n            nums[i] = value; // eslint-disable-line\n            offsets[i] = offset; // eslint-disable-line\n        }\n        var start = (stream.start || 0) + first;\n        var entries = new Array(n); // eslint-disable-line\n        for (var i = 0; i < n; ++i) {\n            var length_1 = (i < n - 1 ? (offsets[i + 1] - offsets[i]) : undefined); // eslint-disable-line\n            if (length_1 < 0) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Invalid offset in the ObjStm stream.');\n            }\n            parser = new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfParser(new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfLexicalOperator(stream.makeSubStream(start + offsets[i], length_1, stream.dictionary)), this, true); // eslint-disable-line\n            var obj = parser.getObject(); // eslint-disable-line\n            entries[i] = obj; // eslint-disable-line\n            if (obj instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n                continue;\n            }\n            var value = nums[i]; // eslint-disable-line\n            var entry = this._entries[value]; // eslint-disable-line\n            if (entry && entry.offset === tableOffset && entry.gen === i) {\n                var objId = value + \" \" + gen;\n                this._cacheMap.set(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference.get(value, gen), obj);\n                if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                    obj.objId = objId;\n                }\n            }\n        }\n        var result = entries[xrefEntry.gen]; // eslint-disable-line\n        if (typeof result === 'undefined') {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException(\"Bad (compressed) XRef entry: \" + ref, 'XRefEntryException');\n        }\n        return result;\n    };\n    _PdfCrossReference.prototype._readXRef = function (recoveryMode) {\n        if (recoveryMode === void 0) { recoveryMode = false; }\n        var stream = this._stream;\n        var startXRefParsedCache = new Set();\n        try {\n            while (this._startXRefQueue.length) {\n                var startXRef = this._startXRefQueue[0];\n                if (this._prevStartXref < startXRef) {\n                    this._prevStartXref = startXRef;\n                }\n                if (startXRefParsedCache.has(startXRef)) {\n                    this._startXRefQueue.shift();\n                    continue;\n                }\n                startXRefParsedCache.add(startXRef);\n                stream.position = startXRef + stream.start;\n                var parser = new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfParser(new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfLexicalOperator(stream), this, true);\n                var obj = parser.getObject(); // eslint-disable-line\n                var dictionary = void 0;\n                if ((0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._isCommand)(obj, 'xref')) {\n                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {\n                        this._document._fileStructure._crossReferenceType = _enumerator__WEBPACK_IMPORTED_MODULE_4__.PdfCrossReferenceType.table;\n                    }\n                    dictionary = this._processXRefTable(parser);\n                    if (!this._topDictionary) {\n                        this._topDictionary = dictionary;\n                    }\n                    obj = dictionary.get('XRefStm');\n                    if (Number.isInteger(obj)) {\n                        var position = obj; // eslint-disable-line\n                        if (!(position in this._crossReferencePosition)) {\n                            this._crossReferencePosition[position] = 1; // eslint-disable-line\n                            this._startXRefQueue.push(position);\n                        }\n                    }\n                }\n                else if (Number.isInteger(obj)) {\n                    if (typeof this._document._fileStructure._crossReferenceType === 'undefined') {\n                        this._document._fileStructure._crossReferenceType = _enumerator__WEBPACK_IMPORTED_MODULE_4__.PdfCrossReferenceType.stream;\n                    }\n                    var gen = parser.getObject();\n                    var command = parser.getObject();\n                    obj = parser.getObject();\n                    if (typeof gen === 'undefined' ||\n                        !Number.isInteger(gen) ||\n                        !(0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._isCommand)(command, 'obj') ||\n                        !(obj instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream)) {\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Invalid cross reference stream');\n                    }\n                    dictionary = this._processXRefStream(obj);\n                    if (!this._topDictionary) {\n                        this._topDictionary = dictionary;\n                    }\n                    if (!dictionary) {\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Failed to read XRef stream');\n                    }\n                }\n                else {\n                    throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Invalid XRef stream header');\n                }\n                obj = dictionary.get('Prev');\n                if (Number.isInteger(obj)) {\n                    this._startXRefQueue.push(obj);\n                }\n                else if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                    this._startXRefQueue.push(obj.objectNumber);\n                }\n                this._startXRefQueue.shift();\n            }\n            return this._topDictionary;\n        }\n        catch (e) {\n            this._startXRefQueue.shift();\n        }\n        if (recoveryMode) {\n            return undefined;\n        }\n        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException('Invalid cross reference', 'XRefParseException');\n    };\n    _PdfCrossReference.prototype._readToken = function (data, offset) {\n        var lf = 0xa;\n        var cr = 0xd;\n        var lt = 0x3c;\n        var token = '';\n        var ch = data[offset]; // eslint-disable-line\n        while (ch !== lf && ch !== cr && ch !== lt) {\n            if (++offset >= data.length) {\n                break;\n            }\n            token += String.fromCharCode(ch);\n            ch = data[offset]; // eslint-disable-line\n        }\n        return token;\n    };\n    _PdfCrossReference.prototype._skipUntil = function (data, offset, what) {\n        var length = what.length;\n        var dataLength = data.length;\n        var skipped = 0;\n        while (offset < dataLength) {\n            var i = 0;\n            while (i < length && data[offset + i] === what[i]) { // eslint-disable-line\n                ++i;\n            }\n            if (i >= length) {\n                break;\n            }\n            offset++;\n            skipped++;\n        }\n        return skipped;\n    };\n    _PdfCrossReference.prototype._indexObjects = function () {\n        var tab = 0x9;\n        var lf = 0xa;\n        var cr = 0xd;\n        var space = 0x20;\n        var percent = 0x25;\n        var objRegExp = /^(\\d+)\\s+(\\d+)\\s+obj\\b/;\n        var endobjRegExp = /\\bendobj[\\b\\s]$/;\n        var nestedObjRegExp = /\\s+(\\d+\\s+\\d+\\s+obj[\\b\\s<])$/;\n        var checkContentLength = 25;\n        var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);\n        var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);\n        var objBytes = new Uint8Array([111, 98, 106]);\n        var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);\n        this._entries.length = 0;\n        this._cacheMap.clear();\n        var stream = this._stream;\n        stream.position = 0;\n        var buffer = stream.getBytes();\n        var length = buffer.length;\n        var position = stream.start;\n        var trailers = [];\n        var crossReferencePosition = [];\n        while (position < length) {\n            var ch = buffer[position]; // eslint-disable-line\n            if (ch === tab || ch === lf || ch === cr || ch === space) {\n                ++position;\n                continue;\n            }\n            if (ch === percent) {\n                do {\n                    ++position;\n                    if (position >= length) {\n                        break;\n                    }\n                    ch = buffer[position]; // eslint-disable-line\n                } while (ch !== lf && ch !== cr);\n                continue;\n            }\n            var token = this._readToken(buffer, position);\n            var m = void 0; // eslint-disable-line\n            if (token.startsWith('xref') && (token.length === 4 || /\\s/.test(token[4]))) {\n                position += this._skipUntil(buffer, position, trailerBytes);\n                trailers.push(position);\n                position += this._skipUntil(buffer, position, startxrefBytes);\n            }\n            else {\n                m = objRegExp.exec(token);\n                if (m) {\n                    var objectNumber = Number.parseInt(m[1]) | 0; // eslint-disable-line\n                    var gen = Number.parseInt(m[2]) | 0; // eslint-disable-line\n                    var contentLength = void 0;\n                    var startPos = position + token.length;\n                    var updateEntries = false;\n                    if (!this._entries[objectNumber]) { // eslint-disable-line\n                        updateEntries = true;\n                    }\n                    else if (this._entries[objectNumber].gen === gen) { // eslint-disable-line\n                        try {\n                            var subStream = stream.makeSubStream(startPos, stream.length - startPos);\n                            var lexicalOperator = new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfLexicalOperator(subStream);\n                            var parser = new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfParser(lexicalOperator, null);\n                            parser.getObject();\n                            updateEntries = true;\n                        }\n                        catch (ex) {\n                            updateEntries = !(ex instanceof _utils__WEBPACK_IMPORTED_MODULE_2__.ParserEndOfFileException);\n                        }\n                    }\n                    if (updateEntries) {\n                        var info = new _PdfObjectInformation();\n                        info.offset = position - stream.start;\n                        info.gen = gen;\n                        info.uncompressed = true;\n                        this._entries[objectNumber] = info; // eslint-disable-line\n                    }\n                    while (startPos < buffer.length) {\n                        var endPos = startPos + this._skipUntil(buffer, startPos, objBytes) + 4;\n                        contentLength = endPos - position;\n                        var checkPos = Math.max(endPos - checkContentLength, startPos);\n                        var tokenStr = (0,_utils__WEBPACK_IMPORTED_MODULE_2__._bytesToString)(buffer.subarray(checkPos, endPos));\n                        if (endobjRegExp.test(tokenStr)) {\n                            break;\n                        }\n                        else {\n                            var objToken = nestedObjRegExp.exec(tokenStr); // eslint-disable-line\n                            if (objToken && objToken[1]) {\n                                contentLength -= objToken[1].length;\n                                break;\n                            }\n                        }\n                        startPos = endPos;\n                    }\n                    var content = buffer.subarray(position, position + contentLength);\n                    var xrefTagOffset = this._skipUntil(content, 0, xrefBytes);\n                    if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {\n                        crossReferencePosition.push(position - stream.start);\n                        this._crossReferencePosition[position - stream.start] = 1;\n                    }\n                    position += contentLength;\n                }\n                else if (token.startsWith('trailer') && (token.length === 7 || /\\s/.test(token[7]))) {\n                    trailers.push(position);\n                    position += this._skipUntil(buffer, position, startxrefBytes);\n                }\n                else {\n                    position += token.length + 1;\n                }\n            }\n        }\n        for (var i = 0; i < crossReferencePosition.length; ++i) {\n            this._startXRefQueue.push(crossReferencePosition[i]); // eslint-disable-line\n            this._readXRef(true);\n        }\n        var trailerDict;\n        for (var i = 0; i < trailers.length; ++i) {\n            stream.position = trailers[i]; // eslint-disable-line\n            var parser = new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfParser(new _pdf_parser__WEBPACK_IMPORTED_MODULE_3__._PdfLexicalOperator(stream), this, true, true);\n            var obj = parser.getObject(); // eslint-disable-line\n            if (!(0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._isCommand)(obj, 'trailer')) {\n                continue;\n            }\n            var dictionary = parser.getObject(); // eslint-disable-line\n            if (!(dictionary instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary)) {\n                continue;\n            }\n            try {\n                var rootDict = dictionary.get('Root'); // eslint-disable-line\n                if (!(rootDict instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary)) {\n                    continue;\n                }\n                var pagesDict = rootDict.get('Pages'); // eslint-disable-line\n                if (!(pagesDict instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary)) {\n                    continue;\n                }\n                var pagesCount = pagesDict.get('Count');\n                if (typeof pagesCount === 'undefined' || !Number.isInteger(pagesCount)) {\n                    continue;\n                }\n            }\n            catch (ex) {\n                continue;\n            }\n            if (dictionary.has('ID')) {\n                return dictionary;\n            }\n            trailerDict = dictionary;\n        }\n        if (trailerDict) {\n            return trailerDict;\n        }\n        if (this._topDictionary) {\n            return this._topDictionary;\n        }\n        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.BaseException('Invalid PDF structure.', 'InvalidPDFException');\n    };\n    _PdfCrossReference.prototype._processXRefTable = function (parser) {\n        if (typeof this._tableState === 'undefined') {\n            var tableState = new _PdfCrossTableState();\n            tableState.entryNum = 0;\n            tableState.streamPos = parser.lexicalOperator.stream.position;\n            tableState.parserBuf1 = parser.first;\n            tableState.parserBuf2 = parser.second;\n            this._tableState = tableState;\n        }\n        var obj = this._readXRefTable(parser);\n        if (!(0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._isCommand)(obj, 'trailer')) {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Invalid XRef table: could not find trailer dictionary');\n        }\n        var topDictionary = parser.getObject(); // eslint-disable-line\n        var dictionary;\n        if (topDictionary) {\n            if (topDictionary instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                dictionary = topDictionary;\n            }\n            else if (topDictionary instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream && topDictionary.dictionary) {\n                dictionary = topDictionary.dictionary;\n            }\n        }\n        if (!dictionary) {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Invalid cross reference: could not parse trailer dictionary');\n        }\n        this._tableState = undefined;\n        return dictionary;\n    };\n    _PdfCrossReference.prototype._readXRefTable = function (parser) {\n        var stream = parser.lexicalOperator.stream;\n        stream.position = this._tableState.streamPos;\n        parser.first = this._tableState.parserBuf1;\n        parser.second = this._tableState.parserBuf2;\n        var obj; // eslint-disable-line\n        while (true) { // eslint-disable-line\n            if (typeof this._tableState.firstEntryNum === 'undefined' || typeof this._tableState.entryCount === 'undefined') {\n                obj = parser.getObject();\n                if ((0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._isCommand)(obj, 'trailer')) {\n                    break;\n                }\n                this._tableState.firstEntryNum = obj;\n                this._tableState.entryCount = parser.getObject();\n            }\n            var first = this._tableState.firstEntryNum;\n            var count = this._tableState.entryCount;\n            if (!Number.isInteger(first) || !Number.isInteger(count)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Invalid cross reference: wrong types in subsection header');\n            }\n            for (var i = this._tableState.entryNum; i < count; i++) {\n                this._tableState.streamPos = stream.position;\n                this._tableState.entryNum = i;\n                this._tableState.parserBuf1 = parser.first;\n                this._tableState.parserBuf2 = parser.second;\n                var entry = new _PdfObjectInformation();\n                entry.offset = parser.getObject();\n                entry.gen = parser.getObject();\n                var type = parser.getObject();\n                if (type) {\n                    switch (type.command) {\n                        case 'f':\n                            entry.free = true;\n                            break;\n                        case 'n':\n                            entry.uncompressed = true;\n                            break;\n                    }\n                }\n                if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {\n                    throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError(\"Invalid entry in cross reference subsection: \" + first + \", \" + count);\n                }\n                if (i === 0 && entry.free && first === 1) {\n                    first = 0;\n                }\n                if (!this._entries[i + first]) {\n                    this._entries[i + first] = entry;\n                }\n            }\n            this._tableState.entryNum = 0;\n            this._tableState.streamPos = stream.position;\n            this._tableState.parserBuf1 = parser.first;\n            this._tableState.parserBuf2 = parser.second;\n            this._tableState.firstEntryNum = undefined;\n            this._tableState.entryCount = undefined;\n        }\n        if (this._entries[0] && !this._entries[0].free) {\n            throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('Invalid XRef table: unexpected first object');\n        }\n        return obj;\n    };\n    _PdfCrossReference.prototype._processXRefStream = function (stream) {\n        if (typeof this._streamState === 'undefined') {\n            var streamParameters = stream.dictionary;\n            var streamState = new _PdfStreamState();\n            var index = streamParameters.getArray('Index');\n            if (!index) {\n                index = [0, streamParameters.get('Size')];\n            }\n            streamState.entryRanges = index;\n            streamState.byteWidths = streamParameters.getArray('W');\n            streamState.entryNum = 0;\n            streamState.streamPos = stream.position;\n            this._streamState = streamState;\n        }\n        this._readXRefStream(stream);\n        this._streamState = undefined;\n        return stream.dictionary;\n    };\n    _PdfCrossReference.prototype._readXRefStream = function (stream) {\n        stream.position = this._streamState.streamPos;\n        var typeFieldWidth = this._streamState.byteWidths[0];\n        var offsetFieldWidth = this._streamState.byteWidths[1];\n        var generationFieldWidth = this._streamState.byteWidths[2];\n        var entryRanges = this._streamState.entryRanges;\n        while (entryRanges.length > 0) {\n            var first = entryRanges[0];\n            var n = entryRanges[1];\n            if (!Number.isInteger(first) || !Number.isInteger(n)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError(\"Invalid XRef range fields: \" + first + \", \" + n);\n            }\n            if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError(\"Invalid XRef entry fields length: \" + first + \", \" + n);\n            }\n            for (var i = this._streamState.entryNum; i < n; ++i) {\n                this._streamState.entryNum = i;\n                this._streamState.streamPos = stream.position;\n                var type = 0;\n                var offset = 0;\n                var generation = 0;\n                for (var j = 0; j < typeFieldWidth; ++j) {\n                    var typeByte = stream.getByte();\n                    if (typeByte === -1) {\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('invalid cross reference byte width type.');\n                    }\n                    type = (type << 8) | typeByte;\n                }\n                if (typeFieldWidth === 0) {\n                    type = 1;\n                }\n                for (var j = 0; j < offsetFieldWidth; ++j) {\n                    var offsetByte = stream.getByte();\n                    if (offsetByte === -1) {\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('invalid cross reference byte width offset.');\n                    }\n                    offset = (offset << 8) | offsetByte;\n                }\n                for (var j = 0; j < generationFieldWidth; ++j) {\n                    var generationByte = stream.getByte();\n                    if (generationByte === -1) {\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError('invalid cross reference byte width generation.');\n                    }\n                    generation = (generation << 8) | generationByte;\n                }\n                var entry = new _PdfObjectInformation();\n                entry.offset = offset;\n                entry.gen = generation;\n                switch (type) {\n                    case 0:\n                        entry.free = true;\n                        break;\n                    case 1:\n                        entry.uncompressed = true;\n                        break;\n                    case 2:\n                        break;\n                    default:\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_2__.FormatError(\"Invalid XRef entry type: \" + type);\n                }\n                if (!this._entries[first + i]) {\n                    this._entries[first + i] = entry;\n                }\n            }\n            this._streamState.entryNum = 0;\n            this._streamState.streamPos = stream.position;\n            entryRanges.splice(0, 2);\n        }\n    };\n    _PdfCrossReference.prototype._getCatalogObj = function () {\n        return this._root;\n    };\n    _PdfCrossReference.prototype._save = function () {\n        var buffer = [37, 80, 68, 70, 45];\n        this._writeString(\"\" + this._version + this._newLine, buffer);\n        buffer.push(0x25, 0x83, 0x92, 0xfa, 0xfe);\n        this._writeString(this._newLine, buffer);\n        if (!this._document.fileStructure.isIncrementalUpdate) {\n            this._currentLength = 0;\n            var objectCollection = new _PdfMainObjectCollection(this);\n            this._writeObjectCollection(objectCollection._mainObjectCollection, buffer);\n            var stream = new _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfStream(buffer);\n            this._stream = stream;\n            this._document._stream = stream;\n            var array = new Uint8Array(this._stream.length);\n            array.set(this._stream.bytes);\n            array.set(buffer, 0);\n            return array;\n        }\n        else {\n            this._currentLength = this._stream.length;\n            var buffer_1 = [37, 80, 68, 70, 45];\n            this._writeString(\"\" + this._version + this._newLine, buffer_1);\n            buffer_1.push(0x25, 0x83, 0x92, 0xfa, 0xfe);\n            this._writeString(this._newLine, buffer_1);\n            if (this._document._fileStructure._crossReferenceType === _enumerator__WEBPACK_IMPORTED_MODULE_4__.PdfCrossReferenceType.stream) {\n                this._saveAsStream(this._currentLength, buffer_1);\n            }\n            else {\n                this._saveAsTable(this._currentLength, buffer_1);\n            }\n            var array = new Uint8Array(this._stream.length + buffer_1.length);\n            array.set(this._stream.bytes);\n            array.set(buffer_1, this._stream.length);\n            return array;\n        }\n    };\n    _PdfCrossReference.prototype._saveAsStream = function (currentLength, buffer) {\n        var _this = this;\n        var objectStreamCollection = new Map();\n        this._indexes = [];\n        this._indexes.push(0, 1);\n        this._cacheMap.forEach(function (value, key) {\n            var dictionary;\n            if (value instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n                dictionary = value.dictionary;\n            }\n            if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n                var cipher = void 0;\n                if (_this._encrypt) {\n                    cipher = _this._encrypt._createCipherTransform(key.objectNumber, key.generationNumber);\n                }\n                _this._updatedDictionary(currentLength, key, buffer, value, cipher);\n            }\n        });\n        this._cacheMap.forEach(function (value, key) {\n            if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                if (value._updated && (!value.isCatalog || _this._allowCatalog)) {\n                    _this._writeArchiveStream(objectStreamCollection, key, value);\n                }\n            }\n            else if (value instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n                var dictionary = value.dictionary;\n                if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n                    _this._updatedDictionary(currentLength, key, buffer, value);\n                }\n            }\n        });\n        this._objectStream = undefined;\n        this._objectStreamCollection = objectStreamCollection;\n        this._writeXrefStream(buffer);\n    };\n    _PdfCrossReference.prototype._updatedDictionary = function (currentLength, key, buffer, value, // eslint-disable-line\n    cipher) {\n        this._indexes.push(key.objectNumber, 1);\n        this._offsets.push(currentLength + buffer.length);\n        this._writeObject(value, buffer, key, cipher);\n        value._updated = false;\n    };\n    _PdfCrossReference.prototype._writeXrefStream = function (buffer) {\n        var _this = this;\n        this._objectStreamCollection.forEach(function (value, key) {\n            value._save(buffer, _this._currentLength);\n            for (var i = 0; i < value._collection.length; i++) {\n                _this._indexes.push(value._collection[Number.parseInt(i.toString(), 10)]);\n            }\n            _this._indexes.push(key.objectNumber, 1);\n        });\n        var formatValue = Math.max((0,_utils__WEBPACK_IMPORTED_MODULE_2__._getSize)(this._currentLength + buffer.length), (0,_utils__WEBPACK_IMPORTED_MODULE_2__._getSize)(this._nextReferenceNumber));\n        var newRef = this._getNextReference();\n        this._indexes.push(newRef.objectNumber, 1);\n        var newStartXref = this._currentLength + buffer.length;\n        var newXref = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this);\n        newXref.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('XRef'));\n        newXref.set('Index', this._indexes);\n        newXref.set('W', [1, formatValue, 1]);\n        this._copyTrailer(newXref);\n        if (this._ids && this._ids.length > 0) {\n            newXref.update('ID', [this._ids[0], this._computeMessageDigest(newStartXref)]);\n        }\n        var newXrefData = [];\n        this._writeLong(0, 1, newXrefData);\n        this._writeLong(0, formatValue, newXrefData);\n        this._writeLong(-1, 1, newXrefData);\n        if (this._offsets.length > 0) {\n            for (var index = 0; index < this._offsets.length; index++) {\n                this._writeLong(1, 1, newXrefData);\n                this._writeLong(this._offsets[index], formatValue, newXrefData); // eslint-disable-line\n                this._writeLong(0, 1, newXrefData);\n            }\n        }\n        if (this._objectStreamCollection.size > 0) {\n            this._objectStreamCollection.forEach(function (value, key) {\n                for (var index = 0; index < value._length; index++) {\n                    _this._writeLong(2, 1, newXrefData);\n                    _this._writeLong(key.objectNumber, formatValue, newXrefData);\n                    _this._writeLong(index, 1, newXrefData);\n                }\n                _this._writeLong(1, 1, newXrefData);\n                _this._writeLong(value._archiveOffset, formatValue, newXrefData);\n                _this._writeLong(0, 1, newXrefData);\n            });\n        }\n        this._writeLong(1, 1, newXrefData);\n        this._writeLong(newStartXref, formatValue, newXrefData);\n        this._writeLong(0, 1, newXrefData);\n        newXref.set('Length', newXrefData.length);\n        var newXrefStream = new _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfStream(newXrefData, newXref, 0, newXrefData.length);\n        var cipher;\n        if (this._encrypt) {\n            cipher = this._encrypt._createCipherTransform(newRef.objectNumber, newRef.generationNumber);\n        }\n        this._writeObject(newXrefStream, buffer, newRef, cipher, true);\n        this._writeString(\"startxref\" + this._newLine + newStartXref + this._newLine + \"%%EOF\" + this._newLine, buffer);\n    };\n    _PdfCrossReference.prototype._saveAsTable = function (currentLength, buffer) {\n        var _this = this;\n        var tempBuffer = '';\n        this._cacheMap.forEach(function (value, key) {\n            var dictionary;\n            if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                dictionary = value;\n            }\n            else if (value instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n                dictionary = value.dictionary;\n            }\n            if (dictionary && dictionary._updated && (!dictionary.isCatalog || _this._allowCatalog)) {\n                var offsetString = _this._processString((currentLength + buffer.length).toString(), 10);\n                var genString = _this._processString(key.generationNumber.toString(), 5);\n                tempBuffer += key.objectNumber + \" 1\" + _this._newLine + offsetString + \" \" + genString + \" n\" + _this._newLine;\n                _this._writeObject(value, buffer, key);\n            }\n        });\n        var newStartXref = buffer.length + currentLength;\n        this._writeString(\"xref\" + this._newLine + \"0 1\" + this._newLine + \"0000000000 65535 f\" + this._newLine, buffer);\n        this._writeXref(buffer, tempBuffer, newStartXref);\n    };\n    _PdfCrossReference.prototype._writeXref = function (buffer, tempBuffer, newStartXref) {\n        this._writeString(tempBuffer, buffer);\n        this._writeString(\"trailer\" + this._newLine, buffer);\n        var newXref = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this);\n        this._copyTrailer(newXref);\n        this._writeDictionary(newXref, buffer, this._newLine);\n        this._writeString(\"startxref\" + this._newLine + newStartXref + this._newLine + \"%%EOF\" + this._newLine, buffer);\n    };\n    _PdfCrossReference.prototype._writeXrefTable = function (buffer) {\n        var _this = this;\n        var tempBuffer = '';\n        var collection = this._getSortedReferences(this._offsetReference); // eslint-disable-line\n        collection.forEach(function (value, key) {\n            var offsetString = _this._processString(value.toString(), 10);\n            var genString = _this._processString(key.generationNumber ? '0' : '', 5);\n            if (value !== 0) {\n                tempBuffer += offsetString + \" \" + genString + \" n\" + _this._newLine;\n            }\n            else {\n                tempBuffer += offsetString + \" \" + genString + \" f\" + _this._newLine;\n            }\n        });\n        var newStartXref = buffer.length;\n        var xrefHeader = \"xref\" + this._newLine;\n        var xrefEntry = \"0 \" + (collection.size + 1) + this._newLine;\n        var initialEntry = \"0000000000 65535 f\" + this._newLine;\n        this._writeString(xrefHeader + xrefEntry + initialEntry, buffer);\n        this._writeXref(buffer, tempBuffer, newStartXref);\n    };\n    _PdfCrossReference.prototype._processString = function (value, length) {\n        while (value.length < length) {\n            value = '0' + value;\n        }\n        return value;\n    };\n    _PdfCrossReference.prototype._copyTrailer = function (newXref) {\n        var reference = this._getNextReference();\n        newXref.set('Size', reference.objectNumber);\n        if (this._document.fileStructure.isIncrementalUpdate) {\n            newXref.set('Prev', this._prevXRefOffset);\n        }\n        var root = this._trailer.getRaw('Root'); // eslint-disable-line\n        if (typeof root !== 'undefined' && root !== null) {\n            newXref.set('Root', root);\n        }\n        var info = this._trailer.getRaw('Info'); // eslint-disable-line\n        if (typeof info !== 'undefined' && info !== null) {\n            newXref.set('Info', info);\n        }\n        var encrypt = this._trailer.getRaw('Encrypt'); // eslint-disable-line\n        if (typeof encrypt !== 'undefined' && encrypt !== null) {\n            newXref.set('Encrypt', encrypt);\n        }\n    };\n    _PdfCrossReference.prototype._computeMessageDigest = function (size) {\n        var _this = this;\n        var time = Math.floor(Date.now() / 1000);\n        var buffer = [time.toString(), '', size.toString()];\n        var info = this._trailer.getRaw('Info');\n        var crossReferenceInfo = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        if (info && info instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n            info.forEach(function (key, value) {\n                if (value && typeof value === 'string') {\n                    crossReferenceInfo.set(key, (0,_utils__WEBPACK_IMPORTED_MODULE_2__._stringToPdfString)(value));\n                }\n            });\n        }\n        crossReferenceInfo.forEach(function (key, value) {\n            buffer.push(value);\n        });\n        var array = [];\n        buffer.forEach(function (str) {\n            _this._writeString(str, array);\n        });\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_2__._bytesToString)((new _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._MD5().hash(new Uint8Array(array))));\n    };\n    _PdfCrossReference.prototype._getNextReference = function () {\n        var reference = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference(this._nextReferenceNumber++, 0);\n        reference._isNew = true;\n        return reference;\n    };\n    _PdfCrossReference.prototype._writeObject = function (obj, // eslint-disable-line\n    buffer, reference, transform, isCrossReference) {\n        var _this = this;\n        if (reference && reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n            this._writeString(reference.objectNumber + \" \" + reference.generationNumber + \" obj\" + this._newLine, buffer);\n        }\n        if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n            this._writeDictionary(obj, buffer, this._newLine, transform, isCrossReference);\n        }\n        else if (obj instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n            this._writeStream(obj, buffer, transform, isCrossReference);\n        }\n        else if (Array.isArray(obj) && obj.length > 0) {\n            this._writeString('[ ', buffer);\n            obj.forEach(function (value, index) {\n                if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                    _this._writeString(value.objectNumber + \" \" + value.generationNumber + \" R\", buffer);\n                }\n                else if (Array.isArray(value)) {\n                    _this._writeString('[ ', buffer);\n                    value.forEach(function (nestedValue) {\n                        if (nestedValue instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                            _this._writeString(nestedValue.objectNumber + \" \" + nestedValue.generationNumber + \" R\", buffer);\n                        }\n                        else if (nestedValue instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName) {\n                            _this._writeString(\"/\" + nestedValue.name, buffer);\n                        }\n                        else {\n                            _this._writeString(nestedValue + \" \", buffer);\n                        }\n                    });\n                    _this._writeString(']', buffer);\n                }\n                else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName) {\n                    _this._writeString(\"/\" + value.name, buffer);\n                }\n                else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                    _this._writeDictionary(value, buffer, _this._newLine, transform, isCrossReference);\n                }\n                else {\n                    _this._writeString(value + \"\\n\", buffer);\n                }\n                if (index < obj.length - 1) {\n                    _this._writeString(' ', buffer);\n                }\n            });\n            this._writeString(']', buffer);\n            this._writeString('\\n', buffer);\n        }\n        else if (typeof obj === 'number') {\n            this._writeString(obj + \"\\n\", buffer);\n        }\n        if (reference && reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n            this._writeString(\"endobj\" + this._newLine, buffer);\n        }\n    };\n    _PdfCrossReference.prototype._writeDictionary = function (dictionary, buffer, spaceChar, transform, isCrossReference) {\n        var _this = this;\n        if (dictionary._currentObj) {\n            dictionary._currentObj._beginSave();\n        }\n        if (dictionary._isFont) {\n            this._writeFontDictionary(dictionary);\n        }\n        this._writeString(\"<<\" + spaceChar, buffer);\n        dictionary.forEach(function (key, value) {\n            _this._writeString(\"/\" + (0,_utils__WEBPACK_IMPORTED_MODULE_2__._escapePdfName)(key) + \" \", buffer);\n            _this._writeValue(value, buffer, transform, isCrossReference);\n            _this._writeString(spaceChar, buffer);\n        });\n        this._writeString(\">>\" + this._newLine, buffer);\n    };\n    _PdfCrossReference.prototype._writeFontDictionary = function (dictionary) {\n        if (dictionary.has('DescendantFonts')) {\n            var fonts = dictionary.get('DescendantFonts'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('DescendantFonts', [reference]);\n        }\n        if (dictionary.has('ToUnicode')) {\n            var fonts = dictionary.get('ToUnicode'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('ToUnicode', reference);\n        }\n        if (dictionary.has('FontFile2')) {\n            var fonts = dictionary.get('FontFile2'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('FontFile2', reference);\n        }\n        if (dictionary.has('FontDescriptor')) {\n            var fonts = dictionary.get('FontDescriptor'); // eslint-disable-line\n            var reference = this._getNextReference();\n            this._cacheMap.set(reference, fonts);\n            dictionary.update('FontDescriptor', reference);\n        }\n    };\n    _PdfCrossReference.prototype._writeStream = function (stream, buffer, transform, isCrossReference) {\n        var value;\n        var streamBuffer = [];\n        if (!isCrossReference) {\n            if (stream._isCompress && !stream._isImage) {\n                value = (0,_utils__WEBPACK_IMPORTED_MODULE_2__._compressStream)(stream);\n            }\n            else {\n                value = stream.getString();\n            }\n            if (transform) {\n                value = transform.encryptString(value);\n            }\n        }\n        else {\n            value = stream.getString();\n        }\n        this._writeString(value, streamBuffer);\n        stream.dictionary.update('Length', streamBuffer.length);\n        this._writeDictionary(stream.dictionary, buffer, this._newLine, transform, isCrossReference);\n        this._writeString(\"stream\" + this._newLine, buffer);\n        this._writeBytes(streamBuffer, buffer);\n        this._writeString(this._newLine + \"endstream\" + this._newLine, buffer);\n    };\n    _PdfCrossReference.prototype._writeValue = function (value, buffer, transform, isCrossReference) {\n        if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName) {\n            if (value.name.indexOf(' ') !== -1) {\n                value.name = value.name.replace(/ /g, '#20'); // eslint-disable-line\n            }\n            this._writeString(\"/\" + value.name, buffer);\n        }\n        else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n            this._writeString(value.toString() + \" R\", buffer);\n        }\n        else if (Array.isArray(value)) {\n            this._writeString('[', buffer);\n            var first = true;\n            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                var val = value_1[_i];\n                if (!first) {\n                    this._writeString(' ', buffer);\n                }\n                else {\n                    first = false;\n                }\n                this._writeValue(val, buffer, transform, isCrossReference);\n            }\n            this._writeString(']', buffer);\n        }\n        else if (typeof value === 'string') {\n            if (!isCrossReference && transform) {\n                value = transform.encryptString(value);\n            }\n            var isUnicode = false;\n            for (var i = 0; i < value.length; i++) {\n                if (value.charCodeAt([i]) > 255) {\n                    isUnicode = true;\n                    break;\n                }\n            }\n            if (isUnicode) {\n                this._writeUnicodeString(value, buffer);\n            }\n            else {\n                this._writeString(\"(\" + this._escapeString(value) + \")\", buffer);\n            }\n        }\n        else if (typeof value === 'number') {\n            this._writeString((0,_utils__WEBPACK_IMPORTED_MODULE_2__._numberToString)(value), buffer);\n        }\n        else if (typeof value === 'boolean') {\n            this._writeString(value.toString(), buffer);\n        }\n        else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n            this._writeDictionary(value, buffer, this._newLine, transform, isCrossReference);\n        }\n        else if (value instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n            this._writeStream(value, buffer, transform, isCrossReference);\n        }\n        else if (value === null) {\n            this._writeString('null', buffer);\n        }\n    };\n    _PdfCrossReference.prototype._writeUnicodeString = function (value, buffer) {\n        var byteValues = (0,_utils__WEBPACK_IMPORTED_MODULE_2__._stringToBigEndianBytes)(value);\n        byteValues.unshift(254, 255);\n        var data = [];\n        for (var i = 0; i < byteValues.length; i++) {\n            var byte = byteValues[Number.parseInt(i.toString(), 10)];\n            switch (byte) {\n                case 40:\n                case 41:\n                    data.push(92);\n                    data.push(byte);\n                    break;\n                case 13:\n                    data.push(92);\n                    data.push(114);\n                    break;\n                case 92:\n                    data.push(92);\n                    data.push(byte);\n                    break;\n                default:\n                    data.push(byte);\n                    break;\n            }\n        }\n        buffer.push('('.charCodeAt(0) & 0xff);\n        for (var i = 0; i < data.length; i++) {\n            buffer.push(data[Number.parseInt(i.toString(), 10)] & 0xff);\n        }\n        buffer.push(')'.charCodeAt(0) & 0xff);\n    };\n    _PdfCrossReference.prototype._writeString = function (value, buffer) {\n        for (var i = 0; i < value.length; i++) {\n            buffer.push(value.charCodeAt(i) & 0xff);\n        }\n    };\n    _PdfCrossReference.prototype._writeBytes = function (data, buffer) {\n        for (var i = 0; i < data.length; i++) {\n            buffer.push(data[i]); // eslint-disable-line\n        }\n    };\n    _PdfCrossReference.prototype._writeLong = function (value, count, buffer) {\n        for (var i = count - 1; i >= 0; --i) {\n            buffer.push(value >> (i << 3) & 0xff);\n        }\n    };\n    _PdfCrossReference.prototype._escapeString = function (value) {\n        return value.replace(/([()\\\\\\n\\r])/g, function (substring) {\n            if (substring === '\\n') {\n                return '\\\\n';\n            }\n            else if (substring === '\\r') {\n                return '\\\\r';\n            }\n            return \"\\\\\" + substring;\n        });\n    };\n    _PdfCrossReference.prototype._destroy = function () {\n        this._entries = undefined;\n        if (this._pendingRefs) {\n            this._pendingRefs.clear();\n            this._pendingRefs = undefined;\n        }\n        if (this._cacheMap) {\n            this._cacheMap.clear();\n        }\n        if (this._offsetReference) {\n            this._offsetReference.clear();\n        }\n        if (this._objectStreamCollection) {\n            this._objectStreamCollection.clear();\n        }\n        this._offsets = [];\n        this._startXRefQueue = [];\n        this._root = undefined;\n        this._startXRefQueue = undefined;\n        this._stream = undefined;\n        this._streamState = undefined;\n        this._tableState = undefined;\n        this._topDictionary = undefined;\n        this._trailer = undefined;\n        this._version = undefined;\n        this._crossReferencePosition = undefined;\n    };\n    _PdfCrossReference.prototype._writeObjectCollection = function (objectCollection, buffer) {\n        var _this = this;\n        var objectStreamCollection = new Map();\n        this._indexes = [];\n        this._indexes.push(0, 1);\n        objectCollection.forEach(function (value, key) {\n            _this._writeObjectToBuffer(key, value, buffer, objectStreamCollection);\n        });\n        if (this._cacheMap.size > objectCollection.size) {\n            this._cacheMap.forEach(function (value, key) {\n                if (!objectCollection.has(key)) {\n                    _this._writeObjectToBuffer(key, value, buffer, objectStreamCollection);\n                }\n            });\n        }\n        if (this._document.fileStructure._crossReferenceType === _enumerator__WEBPACK_IMPORTED_MODULE_4__.PdfCrossReferenceType.stream) {\n            this._objectStream = undefined;\n            this._objectStreamCollection = objectStreamCollection;\n            this._writeXrefStream(buffer);\n        }\n        else {\n            this._writeXrefTable(buffer);\n        }\n    };\n    _PdfCrossReference.prototype._writeArchiveStream = function (objectStreamCollection, key, value) {\n        if (typeof this._objectStream === 'undefined' || this._objectStream._length === 100) {\n            var archiveObj = new _PdfArchievedStream(this);\n            objectStreamCollection.set(archiveObj._reference, archiveObj);\n            this._objectStream = archiveObj;\n        }\n        this._objectStream._writeObject(key, value);\n    };\n    _PdfCrossReference.prototype._writeObjectToBuffer = function (key, value, buffer, // eslint-disable-line\n    objectStreamCollection) {\n        var cipher;\n        if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary && value.isCatalog) {\n            this._writeToBuffer(buffer, key, value);\n        }\n        else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n            var type = value.get('Filter');\n            var typeIsFilter = type && type.name === 'Standard';\n            if (this._document.fileStructure._crossReferenceType === _enumerator__WEBPACK_IMPORTED_MODULE_4__.PdfCrossReferenceType.stream) {\n                if (!typeIsFilter) {\n                    this._writeArchiveStream(objectStreamCollection, key, value);\n                }\n                else {\n                    this._writeToBuffer(buffer, key, value);\n                }\n            }\n            else {\n                this._offsetReference.set(key, buffer.length);\n                this._indexes.push(key.objectNumber, 1);\n                this._writeObject(value, buffer, key);\n            }\n        }\n        else {\n            if (value instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n                var dictionary = value.dictionary;\n                if (dictionary && dictionary._updated && !dictionary.isCatalog) {\n                    if (this._encrypt) {\n                        cipher = this._encrypt._createCipherTransform(key.objectNumber, key.generationNumber);\n                    }\n                    dictionary._updated = false;\n                }\n            }\n            else if ((!Array.isArray(value) || value.length === 0) && typeof value !== 'number') {\n                return;\n            }\n            this._writeToBuffer(buffer, key, value, cipher);\n        }\n    };\n    _PdfCrossReference.prototype._writeToBuffer = function (buffer, key, value, cipher) {\n        this._offsets.push(buffer.length);\n        this._offsetReference.set(key, buffer.length);\n        this._indexes.push(key.objectNumber, 1);\n        this._writeObject(value, buffer, key, cipher);\n    };\n    _PdfCrossReference.prototype._getSortedReferences = function (collection) {\n        var entriesArray = []; // eslint-disable-line\n        collection.forEach(function (value, key) {\n            entriesArray.push([key, value]);\n        });\n        entriesArray.sort(function (a, b) {\n            return a[0].objectNumber - b[0].objectNumber;\n        });\n        var sortedCollection = new Map(); // eslint-disable-line\n        var lastObjectNumber = 1;\n        for (var _i = 0, entriesArray_1 = entriesArray; _i < entriesArray_1.length; _i++) {\n            var _a = entriesArray_1[_i], key = _a[0], value = _a[1];\n            var currentObjectNumber = key.objectNumber;\n            while (lastObjectNumber < currentObjectNumber) {\n                sortedCollection.set({ objectNumber: lastObjectNumber }, 0);\n                lastObjectNumber++;\n            }\n            sortedCollection.set(key, value);\n            lastObjectNumber = currentObjectNumber + 1;\n        }\n        return sortedCollection;\n    };\n    return _PdfCrossReference;\n}());\n\nvar _PdfObjectInformation = /** @class */ (function () {\n    function _PdfObjectInformation() {\n    }\n    return _PdfObjectInformation;\n}());\nvar _PdfCrossTableState = /** @class */ (function () {\n    function _PdfCrossTableState() {\n    }\n    return _PdfCrossTableState;\n}());\nvar _PdfStreamState = /** @class */ (function () {\n    function _PdfStreamState() {\n    }\n    return _PdfStreamState;\n}());\nvar _PdfArchievedStream = /** @class */ (function () {\n    function _PdfArchievedStream(crossReference) {\n        this._indexes = '';\n        this._length = 0;\n        this._crossReference = crossReference;\n        this._reference = crossReference._getNextReference();\n        this._archiveXRef = '';\n        this._updatedStream = [];\n        this._collection = [];\n    }\n    _PdfArchievedStream.prototype._writeObject = function (key, value) {\n        this._archiveXRef += key.objectNumber + \" \" + this._updatedStream.length + this._crossReference._newLine;\n        this._collection.push(key.objectNumber, 1);\n        this._crossReference._writeObject(value, this._updatedStream);\n        this._length++;\n    };\n    _PdfArchievedStream.prototype._save = function (buffer, currentLength) {\n        var data = [];\n        this._crossReference._writeString(this._archiveXRef, data);\n        this._crossReference._writeBytes(this._updatedStream, data);\n        var newDict = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n        newDict.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('ObjStm'));\n        newDict.set('N', this._length);\n        newDict.set('First', this._archiveXRef.length);\n        newDict.set('Length', data.length);\n        var archiveStream = new _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfStream(data, newDict, 0, data.length);\n        this._archiveOffset = currentLength + buffer.length;\n        var cipher;\n        if (this._crossReference._encrypt) {\n            cipher = this._crossReference._encrypt._createCipherTransform(this._reference.objectNumber, this._reference.generationNumber);\n        }\n        this._crossReference._writeObject(archiveStream, buffer, this._reference, cipher);\n    };\n    return _PdfArchievedStream;\n}());\nvar _PdfMainObjectCollection = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `_PdfMainObjectCollection` class.\n     *\n     * @private\n     * @param { _PdfCrossReference } collection - The cross-reference collection containing the PDF objects.\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data);\n     * // Create a new object collection instance\n     * let mainObjectCollection = new _PdfMainObjectCollection(document._crossReference);\n     * // Access the main object collection\n     * let objects = mainObjectCollection._mainObjectCollection;\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     */\n    function _PdfMainObjectCollection(collection) {\n        var _this = this;\n        this._pointer = 0;\n        if (!(collection._cacheMap instanceof Map)) {\n            throw new Error('Expected _cacheMap to be a Map.');\n        }\n        this._reference = [];\n        this._cache = collection._cacheMap;\n        this._mainObjectCollection = new Map(); // eslint-disable-line\n        var foundCatalog = false;\n        this._crossReference = collection;\n        this._cache.forEach(function (value, key) {\n            if (!foundCatalog && value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary && value.isCatalog) {\n                _this._addToMainObjectCollection(key, value);\n                foundCatalog = true;\n            }\n        });\n        this._parseObjectCollection();\n    }\n    _PdfMainObjectCollection.prototype._parseObjectCollection = function () {\n        var _this = this;\n        var _loop_1 = function () {\n            var collection = new Map(); // eslint-disable-line\n            var currentIndex = 0;\n            this_1._mainObjectCollection.forEach(function (value, key) {\n                if (currentIndex === _this._pointer) {\n                    collection.set(key, value);\n                    _this._parse(key, value);\n                }\n                currentIndex++;\n            });\n            this_1._pointer++;\n        };\n        var this_1 = this;\n        while (this._pointer < this._mainObjectCollection.size) {\n            _loop_1();\n        }\n        this._addReferencesToMainCollection();\n        return this._mainObjectCollection;\n    };\n    _PdfMainObjectCollection.prototype._addToMainObjectCollection = function (key, value) {\n        this._reference.push(key);\n        this._mainObjectCollection.set(key, value);\n    };\n    _PdfMainObjectCollection.prototype._parseFetchValue = function (reference) {\n        var fetchvalue = this._crossReference._fetch(reference); // eslint-disable-line\n        this._parse(reference, fetchvalue);\n    };\n    _PdfMainObjectCollection.prototype._parse = function (key, value) {\n        var _this = this;\n        if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n            this._parseDictionary(value);\n        }\n        else if (value instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n            this._parseStream(key, value);\n        }\n        else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n            this._parseFetchValue(value);\n        }\n        else if (Array.isArray(value) && value.length > 0) {\n            var isPdfReferenceArray = value.every(function (value) { return value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference; }); // eslint-disable-line\n            if (isPdfReferenceArray) {\n                value.forEach(function (ref) { return _this._parseFetchValue(ref); }); // eslint-disable-line\n            }\n            else {\n                value.forEach(function (item) {\n                    if (item instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                        _this._parseFetchValue(item);\n                    }\n                });\n                if (this._reference.indexOf(key) === -1 && !this._mainObjectCollection.has(key)) {\n                    this._addToMainObjectCollection(key, value);\n                }\n            }\n        }\n        else if (typeof value === 'number') {\n            if (this._reference.indexOf(key) === -1 && !this._mainObjectCollection.has(key)) {\n                this._addToMainObjectCollection(key, value);\n            }\n        }\n    };\n    _PdfMainObjectCollection.prototype._addReferencesToMainCollection = function () {\n        var _this = this;\n        var objectsToWrite = []; // eslint-disable-line\n        this._cache.forEach(function (value, key) {\n            if (!_this._mainObjectCollection.has(key)) {\n                objectsToWrite.push({ key: key, value: value });\n            }\n        });\n        objectsToWrite.forEach(function (_a) {\n            var key = _a.key, value = _a.value;\n            _this._addToMainObjectCollection(key, value);\n        });\n    };\n    _PdfMainObjectCollection.prototype._parseDictionary = function (element) {\n        var _this = this;\n        element.forEach(function (key, value) {\n            var processReference = function (ref) {\n                if (!_this._mainObjectCollection.has(ref) && _this._reference.indexOf(ref) === -1) {\n                    var fetchValue = _this._crossReference._fetch(ref); // eslint-disable-line\n                    if (fetchValue instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                        fetchValue = _this._crossReference._fetch(fetchValue);\n                    }\n                    if (fetchValue instanceof _base_stream__WEBPACK_IMPORTED_MODULE_0__._PdfBaseStream) {\n                        _this._parseStream(ref, fetchValue);\n                    }\n                    else {\n                        _this._addToMainObjectCollection(ref, fetchValue);\n                    }\n                }\n            };\n            if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                processReference(value);\n            }\n            else if (Array.isArray(value)) {\n                value.forEach(function (item) {\n                    if (item instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                        processReference(item);\n                    }\n                    else if (item instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                        _this._parseDictionary(item);\n                    }\n                });\n            }\n            else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                _this._parseDictionary(value);\n            }\n        });\n    };\n    _PdfMainObjectCollection.prototype._parseStream = function (key, element) {\n        this._parseDictionary(element.dictionary);\n        if (this._reference.indexOf(key) === -1 && !this._mainObjectCollection.has(key)) {\n            var type = element.dictionary.get('Type');\n            var subtype = element.dictionary.get('Subtype');\n            var isUpdated = element.dictionary._updated;\n            var uncompressedValue = void 0;\n            if (isUpdated || (type && (type.name === 'XObject' || type.name === 'Metadata') &&\n                (subtype.name === 'Form' || subtype.name === 'XML'))) {\n                uncompressedValue = this._crossReference._fetch(key);\n            }\n            else {\n                uncompressedValue = this._crossReference._fetch(key, true);\n                uncompressedValue._isCompress = false;\n            }\n            this._addToMainObjectCollection(key, uncompressedValue);\n        }\n    };\n    return _PdfMainObjectCollection;\n}());\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-cross-reference.js?");

/***/ })

}]);