"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-image-editor_src_image-editor_action_shape_js-3536cfe3"],{

/***/ "./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/shape.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/shape.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shape: () => (/* binding */ Shape)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-image-editor/src/image-editor/index.js\");\n/* eslint-disable no-constant-condition */\n\n\nvar Shape = /** @class */ (function () {\n    function Shape(parent) {\n        this.textSettings = { text: 'Enter Text', fontFamily: '', fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };\n        this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, radius: null, outlineColor: '', outlineWidth: null };\n        this.keyHistory = ''; // text history\n        this.preventFrameAnnotation = false;\n        this.redactType = 'blur';\n        this.parent = parent;\n        this.addEventListener();\n    }\n    Shape.prototype.destroy = function () {\n        if (this.parent.isDestroyed) {\n            return;\n        }\n        this.removeEventListener();\n    };\n    Shape.prototype.addEventListener = function () {\n        this.parent.on('shape', this.shape, this);\n        this.parent.on('destroyed', this.destroy, this);\n    };\n    Shape.prototype.removeEventListener = function () {\n        this.parent.off('shape', this.shape);\n        this.parent.off('destroyed', this.destroy);\n    };\n    Shape.prototype.shape = function (args) {\n        var parent = this.parent;\n        this.initShapePvtProps();\n        var uploader;\n        switch (args.prop) {\n            case 'drawEllipse':\n                this.drawEllipse(args.value['x'], args.value['y'], args.value['radiusX'], args.value['radiusY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor'], args.value['degree'], args.value['isSelected']);\n                break;\n            case 'drawLine':\n                this.drawLine(args.value['startX'], args.value['startY'], args.value['endX'], args.value['endY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['isSelected']);\n                break;\n            case 'drawArrow':\n                this.drawArrow(args.value['startX'], args.value['startY'], args.value['endX'], args.value['endY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['arrowStart'], args.value['arrowEnd'], args.value['isSelected']);\n                break;\n            case 'drawPath':\n                this.drawPath(args.value['pointColl'], args.value['strokeWidth'], args.value['strokeColor'], args.value['isSelected']);\n                break;\n            case 'drawRectangle':\n                this.drawRectangle(args.value['x'], args.value['y'], args.value['width'], args.value['height'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor'], args.value['degree'], args.value['isSelected'], args.value['radius']);\n                break;\n            case 'drawText':\n                this.drawText(args.value['x'], args.value['y'], args.value['text'], args.value['fontFamily'], args.value['fontSize'], args.value['bold'], args.value['italic'], args.value['color'], args.value['isSelected'], args.value['degree'], args.value['fillColor'], args.value['outlineColor'], args.value['outlineWidth'], args.value['transformCollection']);\n                break;\n            case 'redrawActObj':\n                this.redrawActObj(args.value['x'], args.value['y'], args.value['isMouseDown']);\n                break;\n            case 'apply':\n                this.apply(args.value['shape'], args.value['obj'], args.value['canvas']);\n                break;\n            case 'updateShapeChangeEventArgs':\n                this.updateShapeChangeEventArgs(args.value['shapeSettings'], args.value['allowShapeOverflow']);\n                break;\n            case 'updSelChangeEventArgs':\n                this.updSelChangeEventArgs(args.value['selectionSettings']);\n                break;\n            case 'iterateObjColl':\n                this.iterateObjColl();\n                break;\n            case 'updImgRatioForActObj':\n                this.updImgRatioForActObj();\n                break;\n            case 'redrawObj':\n                this.redrawObj(args.value['degree']);\n                break;\n            case 'redraw-text':\n                this.redrawText();\n                break;\n            case 'draw-shape':\n                this.drawShape(args.value['obj'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor'], args.value['start'], args.value['width'], args.value['height']);\n                break;\n            case 'renderTextArea':\n                this.renderTextArea(args.value['x'], args.value['y'], args.value['actObj']);\n                break;\n            case 'setTextBoxWidth':\n                this.setTextBoxWidth(args.value['e']);\n                break;\n            case 'findTextTarget':\n                this.findTextTarget(args.value['e']);\n                break;\n            case 'updateFontStyles':\n                this.updateFontStyles(args.value['isTextBox']);\n                break;\n            case 'applyFontStyle':\n                this.applyFontStyle(args.value['item']);\n                break;\n            case 'updateFontRatio':\n                this.updateFontRatio(args.value['obj'], args.value['isTextArea']);\n                break;\n            case 'updateFontSize':\n                this.updateFontSize(args.value['obj']);\n                break;\n            case 'pushActItemIntoObj':\n                this.pushActItemIntoObj();\n                break;\n            case 'clearActObj':\n                this.clearActObj();\n                break;\n            case 'refreshActiveObj':\n                this.refreshActiveObj();\n                break;\n            case 'applyActObj':\n                this.applyActObj(args.value['isMouseDown']);\n                break;\n            case 'wireEvent':\n                _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(parent.upperCanvas, 'dblclick', this.findTextTarget, this);\n                _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(parent.textArea, 'mousedown', this.findTextTarget, this);\n                uploader = document.getElementById(parent.element.id + '_fileUpload');\n                if (uploader) {\n                    _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(uploader, 'change', this.fileChanged, this);\n                }\n                break;\n            case 'unWireEvent':\n                _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(parent.upperCanvas, 'dblclick', this.findTextTarget);\n                _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(parent.textArea, 'mousedown', this.findTextTarget);\n                uploader = document.getElementById(parent.element.id + '_fileUpload');\n                if (uploader) {\n                    _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(uploader, 'change', this.fileChanged);\n                }\n                break;\n            case 'getShapeSetting':\n                this.getShapeSetting(args.value['id'], args.value['obj']);\n                break;\n            case 'getShapeSettings':\n                this.getShapeSettings(args.value['obj']);\n                break;\n            case 'getRedactSettings':\n                this.getRedactSettings(args.value['obj']);\n                break;\n            case 'isPointsInRange':\n                this.isPointsInRange(args.value['x'], args.value['y'], args.value['obj']);\n                break;\n            case 'alignRotateFlipColl':\n                this.alignRotateFlipColl(args.value['collection'], args.value['isRotateFlipCollection'], args.value['obj']);\n                break;\n            case 'selectShape':\n                this.selectShape(args.value['id'], args.value['obj']);\n                break;\n            case 'deleteShape':\n                this.deleteShape(args.value['id']);\n                break;\n            case 'getMaxText':\n                this.getMaxText(args.value['isTextBox'], args.value['text'], args.value['obj']);\n                break;\n            case 'setPointCollForLineArrow':\n                args.value['obj'].pointColl = this.getLinePoints(args.value['obj'].activePoint.startX, args.value['obj'].activePoint.startY, args.value['obj'].activePoint.endX, args.value['obj'].activePoint.endY);\n                break;\n            case 'setPointCollForShapeRotation':\n                this.setPointCollForShapeRotation(args.value['obj']);\n                break;\n            case 'setTextSettings':\n                if (args.value['textSettings']) {\n                    this.textSettings = args.value['textSettings'];\n                }\n                else if (args.value['fontFamily']) {\n                    this.textSettings.fontFamily = args.value['fontFamily'];\n                }\n                else if (args.value['fontSize']) {\n                    this.textSettings.fontSize = args.value['fontSize'];\n                }\n                else if (args.value['radius']) {\n                    this.strokeSettings.radius = args.value['radius'];\n                }\n                break;\n            case 'setStrokeSettings':\n                if (args.value['strokeSettings']) {\n                    this.strokeSettings = args.value['strokeSettings'];\n                }\n                else if (args.value['strokeColor']) {\n                    this.strokeSettings.strokeColor = args.value['strokeColor'];\n                }\n                else if (args.value['fillColor']) {\n                    this.strokeSettings.fillColor = args.value['fillColor'];\n                }\n                else if (args.value['strokeWidth']) {\n                    this.strokeSettings.strokeWidth = args.value['strokeWidth'];\n                }\n                else if (args.value['outlineColor']) {\n                    this.strokeSettings.outlineColor = args.value['outlineColor'];\n                }\n                else if (args.value['radius']) {\n                    this.strokeSettings.radius = args.value['radius'];\n                }\n                else if (args.value['outlineWidth']) {\n                    this.strokeSettings.outlineWidth = args.value['outlineWidth'];\n                }\n                break;\n            case 'getStrokeSettings':\n                args.value['obj']['strokeSettings'] = this.strokeSettings;\n                break;\n            case 'setKeyHistory':\n                this.keyHistory = args.value['keyHistory'];\n                break;\n            case 'getKeyHistory':\n                args.value['obj']['keyHistory'] = this.keyHistory;\n                break;\n            case 'setTextBoxPos':\n                this.setTextBoxPos(args.value['actObj'], args.value['degree'], args.value['flip'], args.value['x'], args.value['y']);\n                break;\n            case 'setTextBoxPoints':\n                this.setTextBoxPoints(args.value['actObj'], args.value['degree'], args.value['flip'], args.value['x'], args.value['y']);\n                break;\n            case 'alignTextAreaIntoCanvas':\n                this.alignTextAreaIntoCanvas();\n                break;\n            case 'initializeTextShape':\n                this.initializeTextShape(args.value['text'], args.value['fontFamily'], args.value['fontSize'], args.value['bold'], args.value['italic'], args.value['strokeColor'], args.value['fillColor'], args.value['outlineColor'], args.value['outlineWidth']);\n                break;\n            case 'stopPathDrawing':\n                this.stopPathDrawing(args.value['e'], args.value['isApply']);\n                break;\n            case 'updateArrowRatio':\n                this.updateArrowRatio(args.value['obj']);\n                break;\n            case 'getSquarePointForRotatedShape':\n                this.getSquarePointForRotatedShape(args.value['obj'], args.value['object']);\n                break;\n            case 'drawImage':\n                this.drawImage(args.value['x'], args.value['y'], args.value['width'], args.value['height'], args.value['src'], args.value['degree'], args.value['isAspectRatio'], args.value['opacity'], args.value['isSelected']);\n                break;\n            case 'reset':\n                this.reset();\n                break;\n            case 'updateObj':\n                this.updateObj(args.value['dimObj'], args.value['x'], args.value['y']);\n                break;\n            case 'straightenShapes':\n                this.straightenShapes();\n                break;\n            case 'straightenShapePoints':\n                this.straightenShapePoints(args.value['obj'], args.value['isReverse']);\n                break;\n            case 'straightenPath':\n                this.straightenPath(args.value['obj']);\n                break;\n            case 'straightenFHD':\n                this.straightenFHD();\n                break;\n            case 'getTextBoxPosition':\n                this.getTextBoxPosition(args.value['obj'], args.value['object']);\n                break;\n            case 'setFlipState':\n                this.setFlipState(args.value['x'], args.value['y'], args.value['obj'], args.value['object']);\n                break;\n            case 'getNewShapeId':\n                args.value['obj']['id'] = this.getNewShapeId();\n                break;\n            case 'z-order':\n                this.updateZOrder(args.value['obj'], args.value['value']);\n                break;\n            case 'getSmallestIndex':\n                args.value['obj']['index'] = this.getSmallestIndex();\n                break;\n            case 'isIndexInObjColl':\n                args.value['obj']['bool'] = this.isIndexInObjColl(args.value['index']);\n                break;\n            case 'drawAnnotations':\n                this.drawAnnotations(args.value['ctx'], args.value['shape'], args.value['pen'], args.value['isPreventApply'], args.value['x'], args.value['y'], args.value['panRegion']);\n                break;\n            case 'updateShapeColl':\n                this.updateShapeColl();\n                break;\n            case 'getNewOrder':\n                args.value['obj']['order'] = this.getNewOrder();\n                break;\n            case 'getHighestOrder':\n                args.value['obj']['order'] = this.getHighestOrder();\n                break;\n            case 'getLowestOrder':\n                args.value['obj']['order'] = this.getLowestOrder();\n                break;\n            case 'drawRedact':\n                this.drawRedact(args.value['x'], args.value['y'], args.value['width'], args.value['height'], args.value['type'], args.value['value']);\n                break;\n            case 'setRedactType':\n                this.redactType = args.value['redactType'];\n                break;\n        }\n    };\n    Shape.prototype.getModuleName = function () {\n        return 'shape';\n    };\n    Shape.prototype.initShapePvtProps = function () {\n        var parent = this.parent;\n        if (parent.lowerCanvas) {\n            this.lowerContext = parent.lowerCanvas.getContext('2d');\n        }\n        if (parent.upperCanvas) {\n            this.upperContext = parent.upperCanvas.getContext('2d');\n        }\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.shapeImg)) {\n            this.shapeImg = parent.createElement('img', {\n                id: parent.element.id + '_shapeImg', attrs: { name: 'Image', crossorigin: 'anonymous' }\n            });\n        }\n        if (this.textSettings.fontFamily === '') {\n            this.textSettings.fontFamily = parent.fontFamily.default;\n        }\n    };\n    Shape.prototype.reset = function () {\n        this.textSettings =\n            { text: 'Enter Text', fontFamily: this.parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };\n        this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null, radius: null, outlineColor: '', outlineWidth: null };\n        this.preventFrameAnnotation = false;\n    };\n    Shape.prototype.drawEllipse = function (x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {\n        this.initializeShape('ellipse');\n        var start = x && y ? { x: x, y: y } : null;\n        this.drawShape('ellipse', strokeWidth, strokeColor, fillColor, start, radiusX, radiusY, null, null, null, degree, null, isSelected);\n    };\n    Shape.prototype.drawLine = function (startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {\n        this.initializeShape('line');\n        var start = startX && startY ? { x: startX, y: startY } : null;\n        var width = endX - startX;\n        var height = endY - startY;\n        this.drawShape('line', strokeWidth, strokeColor, null, start, width, height, null, null, null, null, null, isSelected);\n    };\n    Shape.prototype.drawPath = function (pointColl, strokeWidth, strokeColor, isSelected) {\n        this.initializeShape('path');\n        if (pointColl) {\n            this.drawShape('path', strokeWidth, strokeColor, null, null, null, null, pointColl, null, null, null, null, isSelected);\n        }\n    };\n    Shape.prototype.drawArrow = function (startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {\n        this.initializeShape('arrow');\n        var start = startX && startY ? { x: startX, y: startY } : null;\n        var width = endX - startX;\n        var height = endY - startY;\n        this.drawShape('arrow', strokeWidth, strokeColor, null, start, width, height, null, arrowStart, arrowEnd, null, null, isSelected);\n    };\n    Shape.prototype.drawRectangle = function (x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected, radius) {\n        this.initializeShape('rectangle');\n        var start = x && y ? { x: x, y: y } : null;\n        this.drawShape('rectangle', strokeWidth, strokeColor, fillColor, start, width, height, null, null, null, degree, null, isSelected, radius);\n    };\n    // eslint-disable-next-line @typescript-eslint/tslint/config\n    Shape.prototype.drawRedact = function (x, y, width, height, type, value) {\n        this.initializeShape('redact');\n        var start = x && y ? { x: x, y: y } : null;\n        this.drawShape('redact', null, null, null, start, width, height, null, null, null, null, null, null, null, type, value);\n    };\n    Shape.prototype.drawText = function (x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection) {\n        this.drawShapeText(text, fontFamily, fontSize, bold, italic, color, x, y, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection);\n    };\n    Shape.prototype.initializeShape = function (type) {\n        var parent = this.parent;\n        this.redrawActObj();\n        parent.activeObj.shape = type;\n        parent.currObjType.isCustomCrop = false;\n    };\n    Shape.prototype.updateWidthHeight = function (obj) {\n        obj.activePoint.width = obj.activePoint.endX - obj.activePoint.startX;\n        obj.activePoint.height = obj.activePoint.endY - obj.activePoint.startY;\n        return obj;\n    };\n    Shape.prototype.setDimension = function (width, height) {\n        var parent = this.parent;\n        var shape = parent.activeObj.shape;\n        if ((width && height) || ((shape === 'line' || shape === 'arrow') && (width || height))) {\n            parent.activeObj.activePoint.width = width;\n            parent.activeObj.activePoint.height = height;\n            if (parent.currObjType.shape.toLowerCase() === 'ellipse') {\n                parent.activeObj.activePoint.width = 2 * width;\n                parent.activeObj.activePoint.height = 2 * height;\n            }\n        }\n    };\n    Shape.prototype.getArrowType = function (type) {\n        var arrowType = type;\n        if (type) {\n            var typeToArrowType = { 'None': 'none', 'Arrow': 'arrow', 'SolidArrow': 'arrowSolid',\n                'Circle': 'circle', 'SolidCircle': 'circleSolid', 'Square': 'square', 'SolidSquare': 'squareSolid', 'Bar': 'bar' };\n            arrowType = typeToArrowType[\"\" + type];\n        }\n        return arrowType;\n    };\n    Shape.prototype.drawShape = function (type, strokeWidth, strokeColor, fillColor, start, width, height, pointColl, arrowStart, arrowEnd, degree, opacity, isSelected, radius, redactType, value) {\n        var parent = this.parent;\n        if (!parent.disabled && parent.isImageLoaded) {\n            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });\n            this.redrawActObj();\n            var objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n            parent.togglePen = false;\n            this.keyHistory = '';\n            parent.upperCanvas.style.display = 'block';\n            this.refreshActiveObj();\n            parent.currObjType.shape = type = type.toLowerCase();\n            if (type !== 'freehanddraw' && type !== '') {\n                parent.activeObj.shape = type;\n                var strokeSettings = parent.activeObj.strokeSettings;\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(strokeSettings)) {\n                    strokeSettings = this.strokeSettings;\n                }\n                if (type === 'path' && pointColl) {\n                    parent.activeObj.pointColl = pointColl;\n                }\n                if (opacity !== null && opacity !== undefined) {\n                    parent.activeObj.opacity = opacity;\n                }\n                strokeSettings.strokeWidth = strokeWidth ? strokeWidth : strokeSettings.strokeWidth;\n                var shape = parent.activeObj.shape;\n                if ((shape === 'rectangle' || shape === 'ellipse') && strokeWidth === 0) {\n                    strokeSettings.strokeWidth = 0;\n                }\n                strokeSettings.strokeColor = strokeColor ? strokeColor : strokeSettings.strokeColor;\n                strokeSettings.fillColor = fillColor || fillColor === '' ? fillColor : strokeSettings.fillColor;\n                strokeSettings.radius = radius ? radius : strokeSettings.radius;\n                var tempWidth = parent.img.destWidth > 100 ? 100 : parent.img.destWidth / 2;\n                var tempHeight = parent.img.destHeight > 100 ? 100 : parent.img.destHeight / 2;\n                parent.activeObj.activePoint.width = tempWidth;\n                parent.activeObj.activePoint.height = tempHeight;\n                if (type === 'line' || type === 'arrow') {\n                    parent.activeObj.lineDraw = 'horizontal';\n                    parent.activeObj.activePoint.height = 0;\n                    if (type === 'arrow') {\n                        parent.activeObj.activePoint.width += 50;\n                        parent.activeObj.start = this.getArrowType(arrowStart);\n                        parent.activeObj.end = this.getArrowType(arrowEnd);\n                    }\n                }\n                else if (type === 'rectangle') {\n                    parent.activeObj.activePoint.width += parent.activeObj.activePoint.width / 2;\n                }\n                else if (type === 'redact') {\n                    if (redactType) {\n                        parent.activeObj.redactType = redactType.toLowerCase();\n                        if (redactType === _index__WEBPACK_IMPORTED_MODULE_1__.RedactType.Blur) {\n                            if (value) {\n                                parent.activeObj.redactBlur = value;\n                            }\n                        }\n                        else {\n                            if (value) {\n                                parent.activeObj.redactPixelate = value;\n                            }\n                        }\n                        parent.activeObj.redactImage = parent.createElement('canvas');\n                    }\n                }\n                this.setDimension(width, height);\n                if (start) {\n                    parent.activeObj.activePoint.startX = start.x;\n                    parent.activeObj.activePoint.startY = start.y;\n                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX +\n                        parent.activeObj.activePoint.width;\n                    parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY +\n                        parent.activeObj.activePoint.height;\n                }\n                else {\n                    this.setCenterPoints();\n                }\n                this.setPointCollForLineAndArrow();\n                if (type === 'arrow') {\n                    parent.activeObj.triangleDirection = 'right';\n                }\n                parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;\n                this.initShapeProps();\n                var obj = { shapeSettingsObj: {} };\n                parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });\n                var shapeSettings = obj['shapeSettingsObj'];\n                var shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,\n                    currentShapeSettings: shapeSettings };\n                parent.trigger('shapeChanging', shapeChangingArgs);\n                parent.editCompleteArgs = shapeChangingArgs;\n                this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);\n                this.setDimension(width, height);\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });\n                if (degree) {\n                    parent.activeObj.rotatedAngle = degree * (Math.PI / 180);\n                    parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });\n                }\n                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });\n                parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });\n                parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });\n                if (type === 'redact') {\n                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',\n                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                }\n                else {\n                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',\n                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                }\n                parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n                if (parent.isPublicMethod && !isSelected) {\n                    parent.notify('undo-redo', { prop: 'updateUndoRedo', value: { operation: 'shapeInsert' }, onPropertyChange: false });\n                }\n                parent.isPublicMethod = false;\n            }\n        }\n    };\n    Shape.prototype.initShapeProps = function () {\n        var parent = this.parent;\n        parent.activeObj.shapeDegree = parent.transform.degree;\n        parent.activeObj.shapeFlip = parent.transform.currFlipState;\n        parent.activeObj.textFlip = parent.transform.currFlipState;\n        parent.activeObj.flipObjColl = [];\n        parent.activeObj.order = this.getNewOrder();\n    };\n    Shape.prototype.setPointCollForLineAndArrow = function () {\n        var parent = this.parent;\n        var shape = parent.activeObj.shape;\n        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;\n        if (shape === 'line' || shape === 'arrow') {\n            parent.activeObj.pointColl = this.getLinePoints(startX, startY, endX, endY);\n            if (parent.activeObj.pointColl) {\n                for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {\n                    parent.activeObj.pointColl[i].ratioX = (parent.activeObj.pointColl[i].x -\n                        parent.img.destLeft) / parent.img.destWidth;\n                    parent.activeObj.pointColl[i].ratioY = (parent.activeObj.pointColl[i].y -\n                        parent.img.destTop) / parent.img.destHeight;\n                }\n            }\n        }\n    };\n    Shape.prototype.prevObjColl = function () {\n        var parent = this.parent;\n        var object = { currObj: {} };\n        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n        this.prevObj = object['currObj'];\n        this.prevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n        this.prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n        this.prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n        var selPointCollObj = { selPointColl: null };\n        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n            value: { obj: selPointCollObj } });\n        this.prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n    };\n    Shape.prototype.drawShapeText = function (text, fontFamily, fontSize, bold, italic, strokeColor, x, y, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection) {\n        var parent = this.parent;\n        if (!parent.disabled && parent.isImageLoaded) {\n            if (parent.currObjType.shape === 'freehanddraw') {\n                this.apply();\n                parent.upperCanvas.style.cursor = parent.cursor = 'default';\n                parent.currObjType.shape = '';\n            }\n            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });\n            parent.togglePen = false;\n            this.redrawActObj();\n            this.prevObjColl();\n            this.refreshActiveObj();\n            parent.activeObj.shape = parent.currObjType.shape = 'text';\n            parent.currObjType.isCustomCrop = false;\n            this.initializeTextShape(text, fontFamily, fontSize, bold, italic, strokeColor, fillColor, outlineColor, outlineWidth);\n            parent.currObjType.isText = parent.currObjType.isInitialText = true;\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.textSettings.fontSize)) {\n                parent.getFontSizes();\n                parent.activeObj.textSettings.fontSize = parseInt(parent.fontSizeColl[(parseInt('3', 10) - 1)].text, 10);\n            }\n            if (parent.img.destWidth < 100) {\n                parent.activeObj.textSettings.fontSize = Math.floor((parent.img.destWidth / 20));\n            }\n            else if (parent.img.destHeight < 100) {\n                parent.activeObj.textSettings.fontSize = Math.floor((parent.img.destHeight / 20));\n            }\n            parent.activeObj.shapeDegree = parent.transform.degree;\n            parent.activeObj.shapeFlip = parent.transform.currFlipState;\n            parent.activeObj.flipObjColl = [];\n            this.updateFontStyles();\n            parent.activeObj.order = this.getNewOrder();\n            var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width +\n                parent.activeObj.textSettings.fontSize * 0.5;\n            var height = parent.activeObj.textSettings.fontSize;\n            if (text) {\n                parent.activeObj.keyHistory = text;\n                var maxText = this.getMaxText();\n                maxText = maxText ? maxText : parent.activeObj.textSettings.text;\n                width = this.upperContext.measureText(maxText).width + parent.activeObj.textSettings.fontSize * 0.5;\n                var rows = text.split('\\n');\n                if (rows.length > 1) {\n                    height = rows.length * parent.activeObj.textSettings.fontSize;\n                    height += (fontSize * 0.25);\n                }\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(x) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(y)) {\n                parent.activeObj.activePoint.startX = x;\n                parent.activeObj.activePoint.startY = y;\n                parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + width;\n                parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + height;\n            }\n            else {\n                this.setCenterPoints(true, width, height);\n            }\n            if (transformCollection) {\n                parent.notify('selection', { prop: 'setTransformedShape', onPropertyChange: false, value: { bool: true } });\n                this.setTransformColl(transformCollection);\n                var actObj = parent.activeObj;\n                actObj.shapeDegree = 0;\n                actObj.shapeFlip = '';\n                var tempDegree = 0;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var coll = actObj.rotateFlipColl;\n                for (var i = 0; i < coll.length; i++) {\n                    if (typeof (coll[i]) === 'number') {\n                        tempDegree += coll[i];\n                    }\n                }\n                if (tempDegree % 90 === 0 && Math.abs(tempDegree) % 180 === 90) {\n                    actObj.activePoint.endX = actObj.activePoint.startX + height;\n                    actObj.activePoint.endY = actObj.activePoint.startY + width;\n                    actObj.activePoint.width = actObj.activePoint.endX - actObj.activePoint.startX;\n                    actObj.activePoint.height = actObj.activePoint.endY - actObj.activePoint.startY;\n                }\n            }\n            var obj = { shapeSettingsObj: {} };\n            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });\n            var shapeSettings = obj['shapeSettingsObj'];\n            var shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,\n                currentShapeSettings: shapeSettings };\n            parent.trigger('shapeChanging', shapeChangingArgs);\n            parent.editCompleteArgs = shapeChangingArgs;\n            this.drawShapeTextEvent(shapeChangingArgs);\n            if (degree) {\n                parent.activeObj.rotatedAngle = degree * (Math.PI / 180);\n                parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,\n                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });\n                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });\n                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });\n            }\n            if (text && text.indexOf('\\n') > -1 && parent.isPublicMethod) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var fontSizeInd = String(parent.fontSizeColl.findIndex(function (item) { return item.text === String(parent.activeObj.textSettings.fontSize); }) + 1);\n                parent.noPushUndo = true;\n                parent.updateFontSize('5');\n                if (parseInt(fontSizeInd, 10) > 0) {\n                    parent.updateFontSize(fontSizeInd);\n                }\n                parent.noPushUndo = false;\n            }\n            if (parent.isPublicMethod && !isSelected) {\n                parent.notify('undo-redo', { prop: 'updateUndoRedo', value: { operation: 'shapeInsert' }, onPropertyChange: false });\n            }\n            parent.isPublicMethod = false;\n        }\n    };\n    Shape.prototype.drawShapeImageEvent = function (shapeChangingArgs, isSelect) {\n        var parent = this.parent;\n        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);\n        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });\n        parent.objColl.push(parent.activeObj);\n        var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n            value: { operation: 'shapeInsert', previousObj: this.prevObj, previousObjColl: this.prevObj.objColl,\n                previousPointColl: this.prevObj.pointColl, previousSelPointColl: this.prevObj.selPointColl, previousCropObj: prevCropObj,\n                previousText: null, currentText: null, previousFilter: null, isCircleCrop: null } });\n        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,\n            value: { obj: parent.objColl[parent.objColl.length - 1] } });\n        if (isSelect) {\n            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',\n                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n            parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n            parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });\n        }\n        else {\n            parent.okBtn(null, true);\n        }\n        parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });\n    };\n    Shape.prototype.setTransformColl = function (transformCollection) {\n        var parent = this.parent;\n        parent.activeObj.rotateFlipColl = [];\n        if (transformCollection) {\n            for (var i = 0; i < transformCollection.length; i++) {\n                if (transformCollection[i].degree) {\n                    parent.activeObj.rotateFlipColl.push(transformCollection[i].degree);\n                }\n                else {\n                    parent.activeObj.rotateFlipColl.push(transformCollection[i].flip.toLowerCase());\n                }\n            }\n        }\n    };\n    Shape.prototype.drawShapeTextEvent = function (shapeChangingArgs) {\n        var parent = this.parent;\n        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);\n        this.addLetter(parent.activeObj.textSettings.text);\n        parent.activeObj.textFlip = parent.transform.currFlipState;\n        this.updateFontRatio(parent.activeObj);\n        parent.objColl.push(parent.activeObj);\n        var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n            value: { operation: 'shapeInsert', previousObj: this.prevObj, previousObjColl: this.prevObj.objColl,\n                previousPointColl: this.prevObj.pointColl, previousSelPointColl: this.prevObj.selPointColl,\n                previousCropObj: prevCropObj, previousText: null, currentText: null, previousFilter: null, isCircleCrop: null } });\n        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,\n            value: { obj: parent.objColl[parent.objColl.length - 1] } });\n        parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });\n        parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });\n        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',\n                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n    };\n    Shape.prototype.initializeTextShape = function (text, fontFamily, fontSize, bold, italic, strokeColor, fillColor, outlineColor, outlineWidth) {\n        var parent = this.parent;\n        this.keyHistory = '';\n        parent.upperCanvas.style.display = 'block';\n        parent.activeObj.strokeSettings.strokeColor = strokeColor || parent.activeObj.strokeSettings.strokeColor;\n        parent.activeObj.strokeSettings.fillColor = fillColor || parent.activeObj.strokeSettings.fillColor;\n        parent.activeObj.textSettings.text = text || parent.activeObj.textSettings.text;\n        parent.activeObj.textSettings.fontFamily = fontFamily || parent.activeObj.textSettings.fontFamily;\n        parent.activeObj.textSettings.fontSize = fontSize || parent.activeObj.textSettings.fontSize;\n        parent.activeObj.textSettings.bold = bold || parent.activeObj.textSettings.bold;\n        parent.activeObj.textSettings.italic = italic || parent.activeObj.textSettings.italic;\n        parent.activeObj.strokeSettings.outlineColor = outlineColor || parent.activeObj.strokeSettings.outlineColor;\n        parent.activeObj.strokeSettings.outlineWidth = outlineWidth || parent.activeObj.strokeSettings.outlineWidth;\n    };\n    Shape.prototype.drawImage = function (x, y, width, height, src, degree, isAspectRatio, opacity, isSelected) {\n        this.initializeShape('image');\n        this.onLoadImgShape(x, y, width, height, src, null, degree, isAspectRatio, opacity, isSelected);\n    };\n    Shape.prototype.redrawActObj = function (x, y, isMouseDown) {\n        var splitWords;\n        var parent = this.parent;\n        if (parent.activeObj.shape) {\n            splitWords = parent.activeObj.shape.split('-');\n        }\n        if (parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] !== 'crop')) {\n            if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {\n                parent.notify('selection', { prop: 'setTextBoxStylesToActObj', onPropertyChange: false });\n                this.updateFontRatio(parent.activeObj, true);\n                if (x && y) {\n                    if ((x !== parent.activeObj.activePoint.startX) && (y !== parent.activeObj.activePoint.startY)) {\n                        this.updateTextFromTextArea();\n                    }\n                }\n                else {\n                    this.updateTextFromTextArea();\n                    parent.textArea.style.transform = '';\n                    parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n                }\n                this.refreshActiveObj();\n            }\n            else {\n                this.applyActObj(isMouseDown);\n            }\n        }\n    };\n    Shape.prototype.apply = function (shape, obj, canvas) {\n        var parent = this.parent;\n        if (!parent.disabled) {\n            if (parent.togglePen && !parent.currObjType.isCustomCrop) {\n                var destLeft = parent.img.destLeft;\n                var destTop = parent.img.destTop;\n                var destWidth = parent.img.destWidth;\n                var destHeight = parent.img.destHeight;\n                parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });\n                var temp = this.lowerContext.filter;\n                this.lowerContext.filter = 'none';\n                parent.togglePen = false;\n                if (parent.isCircleCrop || (parent.currSelectionPoint &&\n                    parent.currSelectionPoint.shape === 'crop-circle')) {\n                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,\n                        value: { context: this.lowerContext, isSave: null, isFlip: null } });\n                }\n                parent.img.destLeft = destLeft;\n                parent.img.destTop = destTop;\n                parent.img.destWidth = destWidth;\n                parent.img.destHeight = destHeight;\n                this.lowerContext.filter = temp;\n            }\n            else {\n                canvas = canvas ? canvas : 'original';\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.shape) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shape)) {\n                    parent.currObjType.shape = '';\n                }\n                else {\n                    parent.currObjType.shape = shape || parent.currObjType.shape;\n                }\n                if (parent.currObjType.shape !== '') {\n                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                    if (parent.activeObj.shape === 'text') {\n                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: canvas, obj: obj, isCropRatio: null,\n                                points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });\n                    }\n                    else {\n                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: canvas, obj: obj } });\n                    }\n                    parent.activeObj.shape = parent.currObjType.shape.toLowerCase();\n                    if (!shape && parent.currObjType.shape !== '' && !parent.currObjType.isCustomCrop) {\n                        parent.objColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true));\n                    }\n                    this.keyHistory = '';\n                }\n            }\n        }\n    };\n    Shape.prototype.setCenterPoints = function (text, width, height) {\n        var parent = this.parent;\n        var renderWidth;\n        var renderHeight;\n        if (text && width && height) {\n            renderWidth = width;\n            renderHeight = height;\n        }\n        else {\n            renderWidth = parent.activeObj.activePoint.width;\n            renderHeight = parent.activeObj.activePoint.height;\n        }\n        parent.activeObj.activePoint.startX = (parent.lowerCanvas.width / 2) - renderWidth / 2;\n        parent.activeObj.activePoint.startY = (parent.lowerCanvas.height / 2) - renderHeight / 2;\n        parent.activeObj.activePoint.endX = (parent.lowerCanvas.width / 2) + renderWidth / 2;\n        parent.activeObj.activePoint.endY = (parent.lowerCanvas.height / 2) + renderHeight / 2;\n    };\n    Shape.prototype.updSelChangeEventArgs = function (selectionSettings) {\n        var parent = this.parent;\n        parent.activeObj.activePoint = { startX: selectionSettings.startX, startY: selectionSettings.startY,\n            endX: parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width,\n            endY: parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height,\n            width: selectionSettings.width, height: selectionSettings.height };\n        parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;\n        parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;\n    };\n    Shape.prototype.updateShapeChangeEventArgs = function (shapeSettings, allowShapeOverflow) {\n        var parent = this.parent;\n        var shapeId;\n        if (shapeSettings.id && shapeSettings.id.indexOf('shape_') === -1 &&\n            shapeSettings.id.indexOf('pen_') === -1) {\n            if (parent.activeObj.currIndex) {\n                parent.activeObj.currIndex = 'shape_' + shapeSettings.id;\n            }\n            else {\n                parent.pointColl[shapeId].id = 'pen_' + shapeSettings.id;\n            }\n        }\n        if (shapeSettings.id && shapeSettings.id.split('_')[0] && shapeSettings.id.split('_')[0] === 'pen') {\n            shapeId = parseInt(shapeSettings.id.split('_')[1], 10) - 1;\n            parent.pointColl[shapeId].points = shapeSettings.points;\n            parent.pointColl[shapeId].strokeColor = shapeSettings.strokeColor;\n            parent.pointColl[shapeId].strokeWidth = shapeSettings.strokeWidth;\n            parent.pointColl[shapeId].opacity = shapeSettings.opacity;\n            parent.pointColl[shapeId].order = shapeSettings.index;\n        }\n        else {\n            parent.activeObj.activePoint.startX = shapeSettings.startX;\n            parent.activeObj.activePoint.startY = shapeSettings.startY;\n            if (shapeSettings.width && shapeSettings.height) {\n                parent.activeObj.activePoint.width = shapeSettings.width;\n                parent.activeObj.activePoint.height = shapeSettings.height;\n                parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;\n                parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;\n            }\n            if (parent.activeObj.shape !== 'text') {\n                parent.activeObj.strokeSettings.strokeColor = shapeSettings.strokeColor;\n                parent.activeObj.strokeSettings.strokeWidth = shapeSettings.strokeWidth;\n            }\n            parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;\n            parent.activeObj.opacity = shapeSettings.opacity;\n            parent.activeObj.order = shapeSettings.index;\n            parent.activeObj.preventShapeDragOut = !allowShapeOverflow;\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shapeSettings.degree)) {\n                shapeSettings.degree = 0;\n            }\n            switch (parent.activeObj.shape) {\n                case 'ellipse':\n                    parent.activeObj.activePoint.width = shapeSettings.radiusX * 2;\n                    parent.activeObj.activePoint.height = shapeSettings.radiusY * 2;\n                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;\n                    parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;\n                    if (shapeSettings.degree) {\n                        parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);\n                    }\n                    break;\n                case 'line':\n                case 'arrow':\n                    parent.activeObj.activePoint.width = shapeSettings.length;\n                    parent.activeObj.activePoint.endX = shapeSettings.endX;\n                    parent.activeObj.activePoint.endY = shapeSettings.endY;\n                    parent.activeObj.activePoint.width = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;\n                    parent.activeObj.activePoint.height = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;\n                    if (parent.activeObj.shape === 'arrow') {\n                        parent.activeObj.start = this.getArrowType(shapeSettings.arrowHead);\n                        parent.activeObj.end = this.getArrowType(shapeSettings.arrowTail);\n                    }\n                    break;\n                case 'text':\n                    parent.activeObj.keyHistory = parent.activeObj.textSettings.text = shapeSettings.text;\n                    parent.activeObj.textSettings.fontSize = shapeSettings.fontSize;\n                    parent.activeObj.strokeSettings.strokeColor = shapeSettings.color;\n                    parent.activeObj.strokeSettings.outlineColor = shapeSettings.strokeColor;\n                    parent.activeObj.strokeSettings.outlineWidth = shapeSettings.strokeWidth;\n                    parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;\n                    parent.activeObj.textSettings.fontFamily = shapeSettings.fontFamily;\n                    this.setTransformColl(shapeSettings.transformCollection);\n                    if (shapeSettings.degree) {\n                        parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);\n                    }\n                    this.updateFontRatio(parent.activeObj);\n                    break;\n                case 'rectangle':\n                case 'image':\n                    if (shapeSettings.degree) {\n                        parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);\n                    }\n                    // Prevented setting image src as it cannot be set in canvas\n                    break;\n                case 'path':\n                    parent.activeObj.pointColl = shapeSettings.points;\n                    break;\n            }\n            if (parent.activeObj.shape === 'text' && parent.activeObj.textSettings) {\n                parent.activeObj.textSettings.bold = false;\n                parent.activeObj.textSettings.italic = false;\n                parent.activeObj.textSettings.underline = false;\n                for (var i = 0; i < shapeSettings.fontStyle.length; i++) {\n                    switch (shapeSettings.fontStyle[i]) {\n                        case 'bold':\n                            parent.activeObj.textSettings.bold = true;\n                            break;\n                        case 'italic':\n                            parent.activeObj.textSettings.italic = true;\n                            break;\n                    }\n                }\n            }\n        }\n    };\n    Shape.prototype.addLetter = function (letter) {\n        var parent = this.parent;\n        if (parent.textArea.style.display === 'none' && (parent.currObjType.isText || parent.activeObj.shape === 'text')) {\n            var fontSize = parent.activeObj.textSettings.fontSize;\n            if (letter === 'Backspace') {\n                this.keyHistory = this.keyHistory.slice(0, -1);\n            }\n            else {\n                this.keyHistory += letter;\n            }\n            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            this.updateFontStyles();\n            var width = this.upperContext.measureText(this.keyHistory).width + fontSize * 0.5;\n            var height = fontSize;\n            this.upperContext.fillText(this.keyHistory, parent.activeObj.activePoint.startX, parent.activeObj.activePoint.startY + fontSize);\n            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            parent.currObjType.isText = true;\n            parent.notify('selection', { prop: 'setActivePoint', onPropertyChange: false,\n                value: { startX: width, startY: height } });\n        }\n    };\n    Shape.prototype.redrawText = function () {\n        var parent = this.parent;\n        var _a = parent.activeObj.textSettings, fontSize = _a.fontSize, fontFamily = _a.fontFamily, bold = _a.bold, italic = _a.italic;\n        var fontStyle = '';\n        if (bold) {\n            fontStyle += 'bold ';\n        }\n        if (italic) {\n            fontStyle += 'italic ';\n        }\n        this.upperContext.font = fontStyle + fontSize + 'px ' + fontFamily;\n        var rows = parent.activeObj.keyHistory.split('\\n');\n        var text = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') ?\n            this.getMaxText(true) : this.getMaxText();\n        var width = this.upperContext.measureText(text).width + fontSize * 0.5;\n        var height = rows.length * fontSize;\n        if (rows.length > 1) {\n            height += (fontSize * 0.50);\n        }\n        parent.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,\n            value: { width: width, height: height } });\n        parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,\n                isMouseMove: null, x: null, y: null } });\n        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,\n            value: { obj: parent.activeObj } });\n    };\n    Shape.prototype.updateTextFromTextArea = function () {\n        var parent = this.parent;\n        var allowUndoRedo = false;\n        var fontSize = parent.activeObj.textSettings.fontSize;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n        var object = { currObj: {} };\n        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n        var prevObj = object['currObj'];\n        prevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n        prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n        prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n        var selPointCollObj = { selPointColl: null };\n        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n            value: { obj: selPointCollObj } });\n        prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n        if (parent.activeObj.keyHistory !== parent.textArea.value) {\n            allowUndoRedo = true;\n        }\n        parent.activeObj.keyHistory = parent.textArea.value;\n        parent.textArea.style.display = 'none';\n        parent.textArea.value = '';\n        this.updateFontStyles();\n        var width = this.upperContext.measureText(parent.activeObj.keyHistory).width + fontSize * 0.5;\n        var height = fontSize;\n        var rows = parent.activeObj.keyHistory.split('\\n');\n        if (rows.length > 1) {\n            height *= rows.length;\n            height += (fontSize * 0.1 * rows.length);\n            var widthColl = [];\n            for (var i = 0, len = rows.length; i < len; i++) {\n                widthColl.push(this.upperContext.measureText(rows[i]).width + fontSize * 0.5);\n            }\n            width = Math.max.apply(Math, widthColl);\n        }\n        parent.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,\n            value: { width: width, height: height } });\n        if (parent.activeObj.rotatedAngle !== 0) {\n            var width_1 = parent.activeObj.activePoint.width - tempActiveObj.activePoint.width;\n            var height_1 = parent.activeObj.activePoint.height - tempActiveObj.activePoint.height;\n            var value = '';\n            if (width_1 > 0 && height_1 > 0) {\n                value = 'widthHeight';\n            }\n            else if (width_1 !== 0) {\n                value = 'width';\n            }\n            else if (height_1 !== 0) {\n                value = 'height';\n            }\n            parent.activeObj.activePoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, tempActiveObj.activePoint, {}, true);\n            parent.notify('selection', { prop: 'adjustRotationPoints', onPropertyChange: false, value: { rectangle: parent.activeObj.activePoint,\n                    x: width_1, y: height_1, angle: parent.activeObj.rotatedAngle, type: 'text', elem: value } });\n            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,\n                value: { obj: parent.activeObj } });\n        }\n        parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,\n                isMouseMove: null, x: null, y: null } });\n        this.updImgRatioForActObj();\n        if (parent.activeObj.rotatedAngle !== 0) {\n            parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });\n        }\n        if (allowUndoRedo) {\n            this.apply(parent.activeObj.shape, parent.activeObj);\n            parent.objColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true));\n            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                value: { operation: 'text', previousObj: prevObj, previousObjColl: prevObj.objColl,\n                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                    previousCropObj: prevCropObj, previousText: parent.activeObj.keyHistory,\n                    currentText: parent.textArea.value, previousFilter: null, isCircleCrop: null } });\n        }\n        else {\n            this.apply(parent.activeObj.shape, parent.activeObj);\n            parent.objColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true));\n        }\n    };\n    Shape.prototype.iterateObjColl = function () {\n        var parent = this.parent;\n        if (parent.objColl.length > 0) {\n            var index = this.getSmallestIndex();\n            var objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n            while (objColl.length > 0) {\n                var found = false;\n                for (var i = 0; i < objColl.length; i++) {\n                    var currentObj = objColl[i];\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentObj.order)) {\n                        objColl.splice(i, 1);\n                        i--;\n                        continue;\n                    }\n                    if (currentObj.order === index) {\n                        this.apply(currentObj.shape, currentObj);\n                        if (currentObj.shape === 'redact' && JSON.stringify(currentObj.activePoint) === JSON.stringify(parent.activeObj.activePoint) &&\n                            currentObj.redactImage !== parent.activeObj.redactImage) {\n                            currentObj.redactImage = parent.activeObj.redactImage;\n                            if (parent.objColl[i] && JSON.stringify(parent.objColl[i].activePoint) ===\n                                JSON.stringify(currentObj.activePoint)) {\n                                parent.objColl[i].redactImage = parent.activeObj.redactImage;\n                            }\n                        }\n                        this.refreshActiveObj();\n                        index++;\n                        if (!this.isIndexInObjColl(index)) {\n                            index++;\n                        }\n                        objColl.splice(i, 1);\n                        found = true;\n                        break; // Exit the loop to start from the beginning\n                    }\n                }\n                if (!found) {\n                    break; // If no matching order was found, exit the loop\n                }\n            }\n        }\n    };\n    Shape.prototype.getSmallestIndex = function () {\n        var parent = this.parent;\n        var smallestIndex;\n        for (var i = 0, len = parent.objColl.length; i < len; i++) {\n            var currentObj = parent.objColl[i];\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentObj.order)) {\n                continue;\n            }\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(smallestIndex) || currentObj.order < smallestIndex) {\n                smallestIndex = currentObj.order;\n            }\n        }\n        return smallestIndex;\n    };\n    Shape.prototype.isIndexInObjColl = function (index) {\n        var parent = this.parent;\n        for (var i = 0, len = parent.objColl.length; i < len; i++) {\n            var currentObj = parent.objColl[i];\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentObj.order)) {\n                continue;\n            }\n            if (currentObj.order === index) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Shape.prototype.updImgRatioForActObj = function () {\n        var parent = this.parent;\n        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,\n            width: parent.img.destWidth, height: parent.img.destHeight };\n        this.straightenShapes();\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        var activePoint = parent.activeObj.activePoint;\n        parent.activeObj.imageRatio = { startX: ((activePoint.startX - destLeft) /\n                destWidth), startY: ((activePoint.startY - destTop) / destHeight),\n            endX: ((activePoint.endX - destLeft) / destWidth),\n            endY: ((activePoint.endY - destTop) / destHeight),\n            width: destWidth / activePoint.width, height: destHeight / activePoint.height };\n        if (parent.activeObj.rotationCirclePointColl) {\n            parent.activeObj.rotationCirclePointColl.ratioX = (parent.activeObj.rotationCirclePointColl.x -\n                destLeft) / destWidth;\n            parent.activeObj.rotationCirclePointColl.ratioY = (parent.activeObj.rotationCirclePointColl.y -\n                destTop) / destHeight;\n        }\n        if (parent.activeObj.shape === 'path') {\n            this.updatePathRatio(parent.activeObj);\n        }\n        else if (parent.activeObj.shape === 'arrow') {\n            this.updateArrowRatio(parent.activeObj);\n        }\n        parent.img.destLeft = destPoints.startX;\n        parent.img.destTop = destPoints.startY;\n        parent.img.destWidth = destPoints.width;\n        parent.img.destHeight = destPoints.height;\n    };\n    Shape.prototype.zoomObjColl = function (preventApply) {\n        var parent = this.parent;\n        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,\n            width: parent.img.destWidth, height: parent.img.destHeight };\n        this.straightenShapes();\n        if (parent.objColl.length > 0) {\n            for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                var currObj = parent.objColl[i];\n                if (currObj.imageRatio) {\n                    currObj.activePoint.startX = (currObj.imageRatio.startX * parent.img.destWidth) + parent.img.destLeft;\n                    currObj.activePoint.startY = (currObj.imageRatio.startY * parent.img.destHeight) + parent.img.destTop;\n                    currObj.activePoint.endX = (currObj.imageRatio.endX * parent.img.destWidth) + parent.img.destLeft;\n                    currObj.activePoint.endY = (currObj.imageRatio.endY * parent.img.destHeight) + parent.img.destTop;\n                }\n                currObj = this.updateWidthHeight(currObj);\n                if (currObj.shape === 'text') {\n                    this.updateFontSize(currObj);\n                }\n                else if (currObj.shape === 'line' || currObj.shape === 'arrow') {\n                    currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);\n                    for (var n = 0, len_1 = currObj.pointColl.length; n < len_1; n++) {\n                        currObj.pointColl[n].ratioX =\n                            (currObj.pointColl[n].x - parent.img.destLeft) / parent.img.destWidth;\n                        currObj.pointColl[n].ratioY =\n                            (currObj.pointColl[n].y - parent.img.destTop) / parent.img.destHeight;\n                    }\n                    if (currObj.shape === 'arrow') {\n                        this.updateArrowSize(currObj);\n                    }\n                    if (parent.transform.straighten !== 0 && (currObj.shape === 'line' || currObj.shape === 'arrow')) {\n                        this.straightenShapePoints(currObj);\n                    }\n                }\n                else if (currObj.shape === 'path') {\n                    for (var l = 0, len_2 = currObj.pointColl.length; l < len_2; l++) {\n                        currObj.pointColl[l].x = (currObj.pointColl[l].ratioX * parent.img.destWidth) +\n                            parent.img.destLeft;\n                        currObj.pointColl[l].y = (currObj.pointColl[l].ratioY * parent.img.destHeight) +\n                            parent.img.destTop;\n                    }\n                    this.updatePathRatio(currObj);\n                    if (parent.transform.straighten !== 0) {\n                        this.straightenPath(currObj);\n                    }\n                }\n                parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,\n                        obj: currObj } });\n                if (currObj.shape !== 'line' && currObj.shape !== 'arrow' && currObj.shape !== 'path' && currObj.rotatedAngle !== 0) {\n                    this.setPointCollForShapeRotation(currObj);\n                    currObj.rotationCirclePoint.x =\n                        (currObj.rotationCirclePoint.ratioX * parent.img.destWidth) + parent.img.destLeft;\n                    currObj.rotationCirclePoint.y =\n                        (currObj.rotationCirclePoint.ratioY * parent.img.destHeight) + parent.img.destTop;\n                    if (currObj.rotationCirclePointColl) {\n                        currObj.rotationCirclePointColl.x =\n                            (currObj.rotationCirclePointColl.ratioX * parent.img.destWidth) + parent.img.destLeft;\n                        currObj.rotationCirclePointColl.y =\n                            (currObj.rotationCirclePointColl.ratioY * parent.img.destHeight) + parent.img.destTop;\n                    }\n                }\n            }\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(preventApply)) {\n                var temp = this.lowerContext.filter;\n                this.lowerContext.filter = 'none';\n                this.iterateObjColl();\n                this.lowerContext.filter = temp;\n            }\n        }\n        parent.img.destLeft = destPoints.startX;\n        parent.img.destTop = destPoints.startY;\n        parent.img.destWidth = destPoints.width;\n        parent.img.destHeight = destPoints.height;\n    };\n    Shape.prototype.straightenPath = function (obj) {\n        var point;\n        for (var j = 0, len = obj.pointColl.length; j < len; j++) {\n            point = this.straightenPoints(obj.pointColl[j].x, obj.pointColl[j].y);\n            obj.pointColl[j].x = point.x;\n            obj.pointColl[j].y = point.y;\n        }\n    };\n    Shape.prototype.straightenFHD = function () {\n        var parent = this.parent;\n        for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {\n            parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[i].points, []);\n            var len = parent.points.length;\n            var point = void 0;\n            for (var l = 0; l < len; l++) {\n                point = this.straightenPoints(parent.points[l].x, parent.points[l].y);\n                parent.points[l].x = point.x;\n                parent.points[l].y = point.y;\n            }\n        }\n        var selPointCollObj = { selPointColl: null };\n        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });\n        for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {\n            if (selPointCollObj['selPointColl'][i] && selPointCollObj['selPointColl'][i].points) {\n                var len = selPointCollObj['selPointColl'][i].points.length;\n                var point = void 0;\n                for (var l = 0; l < len; l++) {\n                    point = this.straightenPoints(selPointCollObj['selPointColl'][i].points[l].x, selPointCollObj['selPointColl'][i].points[l].y);\n                    selPointCollObj['selPointColl'][i].points[l].x = point.x;\n                    selPointCollObj['selPointColl'][i].points[l].y = point.y;\n                }\n            }\n        }\n        var straightenObj = { straightenPoint: null };\n        parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false, value: { obj: straightenObj } });\n        if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {\n            var obj = { angle: 0 };\n            parent.notify('freehand-draw', { prop: 'getStraightenPointAngle', onPropertyChange: false, value: { obj: obj } });\n            var angle = (((parent.transform.straighten === 360 ? 0 : parent.transform.straighten) - obj['angle']) * (Math.PI / 180));\n            var point = this.straightenPoints(straightenObj['straightenPoint']['x'], straightenObj['straightenPoint']['y'], angle);\n            if (angle === 0) {\n                point.x = straightenObj['straightenPoint']['x'];\n                point.y = straightenObj['straightenPoint']['y'];\n            }\n            parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false, value: { x: point.x, y: point.y } });\n        }\n    };\n    Shape.prototype.straightenPoints = function (x, y, angle) {\n        var parent = this.parent;\n        var center = { x: parent.img.destLeft + (parent.img.destWidth / 2), y: parent.img.destTop + (parent.img.destHeight / 2) };\n        angle = angle ? angle : ((parent.transform.straighten) * (Math.PI / 180));\n        var point = { x: Math.cos(angle) * (x - center.x) - Math.sin(angle) * (y - center.y) + center.x,\n            y: Math.sin(angle) * (x - center.x) + Math.cos(angle) * (y - center.y) + center.y };\n        return point;\n    };\n    Shape.prototype.straightenShapes = function () {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        var straightenObj = { bool: parent.isStraightening };\n        if (!straightenObj['bool'] || parent.transform.straighten === 0) {\n            return;\n        }\n        parent.notify('draw', { prop: 'updateImgCanvasPoints' });\n        var object = { points: null };\n        parent.notify('draw', { prop: 'getImageCanvasPoints', value: { obj: object } });\n        var center = { x: destLeft + (destWidth / 2), y: destTop + (destHeight / 2) };\n        var angle = -((parent.transform.straighten) * (Math.PI / 180));\n        var p1 = { x: Math.cos(angle) * (object['points'][0]['x'] - center.x) - Math.sin(angle) *\n                (object['points'][0]['y'] - center.y) + center.x,\n            y: Math.sin(angle) * (object['points'][0]['x'] - center.x) + Math.cos(angle) *\n                (object['points'][0]['y'] - center.y) + center.y };\n        var p2 = { x: Math.cos(angle) * (object['points'][1]['x'] - center.x) - Math.sin(angle) *\n                (object['points'][1]['y'] - center.y) + center.x,\n            y: Math.sin(angle) * (object['points'][1]['x'] - center.x) + Math.cos(angle) * (object['points'][1]['y']\n                - center.y) + center.y };\n        var p3 = { x: Math.cos(angle) * (object['points'][2]['x'] - center.x) - Math.sin(angle) *\n                (object['points'][2]['y'] - center.y) + center.x,\n            y: Math.sin(angle) * (object['points'][2]['x'] - center.x) + Math.cos(angle) * (object['points'][2]['y']\n                - center.y) + center.y };\n        parent.img.destWidth = p2.x - p1.x;\n        parent.img.destHeight = p3.y - p2.y;\n        parent.img.destLeft = p1.x;\n        parent.img.destTop = p1.y;\n    };\n    Shape.prototype.straightenShapePoints = function (obj, isReverse) {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        var straightenObj = { bool: parent.isStraightening };\n        if (!straightenObj['bool']) {\n            return;\n        }\n        if (obj.shape === 'line' || obj.shape === 'arrow') {\n            obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX -\n                obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;\n            obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY -\n                obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;\n            var center = { x: destLeft + (destWidth / 2), y: destTop + (destHeight / 2) };\n            var angle = (isReverse ? -parent.transform.straighten : parent.transform.straighten) * (Math.PI / 180);\n            var start = { x: Math.cos(angle) * (obj.activePoint.startX - center.x) - Math.sin(angle) *\n                    (obj.activePoint.startY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.startX - center.x) + Math.cos(angle)\n                    * (obj.activePoint.startY - center.y) + center.y };\n            var end = { x: Math.cos(angle) * (obj.activePoint.endX - center.x) -\n                    Math.sin(angle) * (obj.activePoint.endY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.endX - center.x) +\n                    Math.cos(angle) * (obj.activePoint.endY - center.y) + center.y };\n            obj.activePoint.startX = start.x;\n            obj.activePoint.startY = start.y;\n            obj.activePoint.endX = end.x;\n            obj.activePoint.endY = end.y;\n            obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX -\n                obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;\n            obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY -\n                obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;\n            parent.notify('selection', { prop: 'adjustActObjForLineArrow', onPropertyChange: false, value: { obj: obj } });\n        }\n    };\n    Shape.prototype.redrawObj = function (degree) {\n        var parent = this.parent;\n        var isShape = false;\n        if (parent.objColl.length > 0) {\n            if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical' ||\n                degree === 'horizontalVertical' || degree === 'verticalHorizontal') {\n                this.updateCurrentActiveObjPoint(degree.toLowerCase());\n            }\n            else if (typeof (degree) === 'number') {\n                this.updateCurrentActiveObjPoint(degree);\n                var tempFilter = this.lowerContext.filter;\n                this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +\n                    'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';\n                for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                    var splitWords = parent.objColl[i].shape.split('-');\n                    if (splitWords[0] !== 'crop') {\n                        this.apply(parent.objColl[i].shape, parent.objColl[i]);\n                        isShape = true;\n                    }\n                }\n                if (isShape) {\n                    parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });\n                }\n                this.lowerContext.filter = tempFilter;\n            }\n        }\n    };\n    Shape.prototype.updateCurrentActiveObjPoint = function (degree) {\n        var parent = this.parent;\n        var currActObjIndex;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        for (var index = 0, len = parent.objColl.length; index < len; index++) {\n            var currObj = parent.objColl[index];\n            if (parent.activeObj.shape === currObj.shape &&\n                parent.activeObj.activePoint.startX === currObj.activePoint.startX &&\n                parent.activeObj.activePoint.startY === currObj.activePoint.startY &&\n                parent.activeObj.activePoint.endX === currObj.activePoint.endX &&\n                parent.activeObj.activePoint.endY === currObj.activePoint.endY &&\n                parent.activeObj.currIndex === currObj.currIndex) {\n                currActObjIndex = index;\n                break;\n            }\n        }\n        if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical' ||\n            degree === 'horizontalvertical' || degree === 'verticalhorizontal') {\n            if (degree === 'horizontal' || degree === 'Horizontal') {\n                for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                    var currObj = parent.objColl[i];\n                    if (currObj.shapeFlip !== parent.transform.currFlipState) {\n                        if (currObj.activePoint.startX <= destLeft + (destWidth / 2)) {\n                            currObj.activePoint.endX = (destLeft + destWidth) - (currObj.activePoint.startX - destLeft);\n                            currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });\n                        }\n                        else if (currObj.activePoint.startX >= destLeft + (destWidth / 2)) {\n                            currObj.activePoint.startX = destLeft + (destLeft + destWidth - currObj.activePoint.endX);\n                            currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });\n                        }\n                        if (currObj.shape === 'line' || currObj.shape === 'arrow' || currObj.shape === 'path') {\n                            this.flipLineArrowObj(currObj, 'horizontal');\n                        }\n                        else if (currObj.rotatedAngle !== 0) {\n                            currObj.rotatedAngle = currObj.rotatedAngle + (Math.PI - currObj.rotatedAngle) * 2;\n                            if (currObj.rotationCirclePointColl.x <= destLeft + (destWidth / 2)) {\n                                currObj.rotationCirclePointColl.x = (destLeft + destWidth) -\n                                    (currObj.rotationCirclePointColl.x - destLeft);\n                            }\n                            else if (currObj.rotationCirclePointColl.x >= destLeft + (destWidth / 2)) {\n                                currObj.rotationCirclePointColl.x = destLeft +\n                                    (destLeft + destWidth - currObj.rotationCirclePointColl.x);\n                            }\n                            currObj.rotationCirclePointColl.ratioX =\n                                (currObj.rotationCirclePointColl.x - destLeft) / destWidth;\n                        }\n                        currObj.shapeFlip = parent.transform.currFlipState;\n                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),\n                            startY: ((currObj.activePoint.startY - destTop) / destHeight),\n                            endX: ((currObj.activePoint.endX - destLeft) / destWidth),\n                            endY: ((currObj.activePoint.endY - destTop) / destHeight),\n                            width: destWidth / currObj.activePoint.width,\n                            height: destHeight / currObj.activePoint.height };\n                    }\n                }\n            }\n            else if (degree === 'vertical' || degree === 'Vertical') {\n                for (var i = 0; i < parent.objColl.length; i++) {\n                    var currObj = parent.objColl[i];\n                    if (currObj.shapeFlip !== parent.transform.currFlipState) {\n                        if (currObj.activePoint.startY <= destTop + (destHeight / 2)) {\n                            currObj.activePoint.endY = (destTop + destHeight) - (currObj.activePoint.startY - destTop);\n                            currObj.activePoint.startY = currObj.activePoint.endY - currObj.activePoint.height;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,\n                                    obj: currObj } });\n                        }\n                        else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {\n                            currObj.activePoint.startY = destTop + (destTop + destHeight - currObj.activePoint.endY);\n                            currObj.activePoint.endY = currObj.activePoint.startY + currObj.activePoint.height;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,\n                                    obj: currObj } });\n                        }\n                        if (currObj.shape === 'line' || currObj.shape === 'arrow' ||\n                            currObj.shape === 'path') {\n                            this.flipLineArrowObj(currObj, 'vertical');\n                        }\n                        else if (currObj.rotatedAngle !== 0) {\n                            currObj.rotatedAngle = -currObj.rotatedAngle;\n                            if (currObj.rotationCirclePointColl.y <= destTop + (destHeight / 2)) {\n                                currObj.rotationCirclePointColl.y = (destTop + destHeight) - (currObj.rotationCirclePointColl.y - destTop);\n                            }\n                            else if (currObj.rotationCirclePointColl.y >= destTop +\n                                (destHeight / 2)) {\n                                currObj.rotationCirclePointColl.y = destTop + (destTop + destHeight - currObj.rotationCirclePointColl.y);\n                            }\n                            currObj.rotationCirclePointColl.ratioY =\n                                (currObj.rotationCirclePointColl.y - destTop) / destHeight;\n                        }\n                        currObj.shapeFlip = parent.transform.currFlipState;\n                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),\n                            startY: ((currObj.activePoint.startY - destTop) / destHeight),\n                            endX: ((currObj.activePoint.endX - destLeft) / destWidth),\n                            endY: ((currObj.activePoint.endY - destTop) / destHeight),\n                            width: destWidth / currObj.activePoint.width,\n                            height: destHeight / currObj.activePoint.height };\n                    }\n                }\n            }\n            else if (degree === 'verticalhorizontal' || degree === 'horizontalvertical') {\n                for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                    var currObj = parent.objColl[i];\n                    if (currObj.shapeFlip !== parent.transform.currFlipState) {\n                        if (currObj.activePoint.startX <= destLeft + (destWidth / 2)) {\n                            currObj.activePoint.endX = (destLeft + destWidth) - (currObj.activePoint.startX -\n                                destLeft);\n                            currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });\n                        }\n                        else if (currObj.activePoint.startX >= destLeft + (destWidth / 2)) {\n                            currObj.activePoint.startX = destLeft + (destLeft +\n                                destWidth - currObj.activePoint.endX);\n                            currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });\n                        }\n                        if (currObj.activePoint.startY <= destTop + (destHeight / 2)) {\n                            currObj.activePoint.endY = (destTop + destHeight) -\n                                (currObj.activePoint.startY - destTop);\n                            currObj.activePoint.startY = currObj.activePoint.endY -\n                                currObj.activePoint.height;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });\n                        }\n                        else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {\n                            currObj.activePoint.startY = destTop + (destTop +\n                                destHeight - currObj.activePoint.endY);\n                            currObj.activePoint.endY = currObj.activePoint.startY +\n                                currObj.activePoint.height;\n                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });\n                        }\n                        if (currObj.shape === 'line' || currObj.shape === 'arrow' || currObj.shape === 'path') {\n                            this.flipLineArrowObj(currObj, degree);\n                        }\n                        currObj.shapeFlip = parent.transform.currFlipState;\n                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),\n                            startY: ((currObj.activePoint.startY - destTop) / destHeight),\n                            endX: ((currObj.activePoint.endX - destLeft) / destWidth),\n                            endY: ((currObj.activePoint.endY - destTop) / destHeight),\n                            width: destWidth / currObj.activePoint.width,\n                            height: destHeight / currObj.activePoint.height };\n                    }\n                }\n            }\n            if (currActObjIndex !== undefined) {\n                parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[currActObjIndex], {}, true);\n            }\n        }\n        else if (degree === 90) {\n            this.rotateObjColl();\n        }\n        else if (degree === -90) {\n            for (var i = 0; i < 3; i++) {\n                this.rotateObjColl();\n            }\n        }\n        else if (typeof (degree) === 'number') {\n            if (degree > 0) {\n                this.rotateObjColl();\n            }\n            else {\n                for (var i = 0; i < 3; i++) {\n                    this.rotateObjColl();\n                }\n            }\n        }\n    };\n    Shape.prototype.rotateObjColl = function () {\n        var parent = this.parent;\n        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;\n        for (var i = 0, len = parent.objColl.length; i < len; i++) {\n            var currObj = parent.objColl[i];\n            var shape = currObj.shape;\n            currObj.activePoint.startY = destTop + (destHeight * currObj.imageRatio.startX);\n            currObj.activePoint.endY = destTop + (destHeight * currObj.imageRatio.endX);\n            currObj.activePoint.startX = (destLeft + destWidth) - (destWidth * currObj.imageRatio.endY);\n            currObj.activePoint.endX = (destLeft + destWidth) - (destWidth * currObj.imageRatio.startY);\n            currObj = this.updateWidthHeight(parent.objColl[i]);\n            this.updateFontSize(currObj);\n            if (shape === 'line' || shape === 'arrow' || shape === 'path') {\n                this.rotateLineArrowObj(currObj);\n                if (shape === 'arrow') {\n                    this.updateArrowSize(currObj);\n                }\n            }\n            else if (currObj.rotatedAngle !== 0) {\n                currObj.rotationCirclePointColl.y = destTop + (destHeight * currObj.rotationCirclePointColl.ratioX);\n                currObj.rotationCirclePointColl.x = (destLeft + destWidth) -\n                    (destWidth * currObj.rotationCirclePointColl.ratioY);\n                currObj.rotationCirclePointColl.ratioX = (currObj.rotationCirclePointColl.x - destLeft) / destWidth;\n                currObj.rotationCirclePointColl.ratioY = (currObj.rotationCirclePointColl.y - destTop) / destHeight;\n            }\n        }\n        for (var i = 0, len = parent.objColl.length; i < len; i++) {\n            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.objColl[i].activePoint, obj: parent.objColl[i] } });\n        }\n        for (var i = 0, len = parent.objColl.length; i < len; i++) {\n            var currObj = parent.objColl[i];\n            currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) / destWidth),\n                startY: ((currObj.activePoint.startY - destTop) / destHeight),\n                endX: ((currObj.activePoint.endX - destLeft) / destWidth),\n                endY: ((currObj.activePoint.endY - destTop) / destHeight),\n                width: destWidth / currObj.activePoint.width,\n                height: destHeight / currObj.activePoint.height };\n        }\n    };\n    Shape.prototype.rotateLineArrowObj = function (obj) {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj.pointColl)) {\n            return;\n        }\n        var parent = this.parent;\n        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;\n        if (obj.pointColl.length > 0) {\n            for (var n = 0; n < obj.pointColl.length; n++) {\n                obj.pointColl[n].y = destTop + (destHeight * obj.pointColl[n].ratioX);\n                obj.pointColl[n].x = (destLeft + destWidth) - (destWidth *\n                    obj.pointColl[n].ratioY);\n            }\n            for (var n = 0; n < obj.pointColl.length; n++) {\n                obj.pointColl[n].ratioX = (obj.pointColl[n].x - destLeft) / destWidth;\n                obj.pointColl[n].ratioY = (obj.pointColl[n].y - destTop) / destHeight;\n            }\n            var prevPoint = void 0;\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj.pointColl[obj.pointColl.length - 2])) {\n                prevPoint = { x: 0, y: 0 };\n            }\n            else {\n                prevPoint = { x: obj.pointColl[obj.pointColl.length - 2].x, y: obj.pointColl[obj.pointColl.length - 2].y };\n            }\n            var diffX = obj.pointColl[obj.pointColl.length - 1].x - prevPoint.x;\n            var diffY = obj.pointColl[obj.pointColl.length - 1].y - prevPoint.y;\n            obj.activePoint.startX = obj.pointColl[0].x;\n            obj.activePoint.startY = obj.pointColl[0].y;\n            obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x + (diffX / 2);\n            obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y + (diffY / 2);\n            obj = this.updateWidthHeight(obj);\n        }\n    };\n    Shape.prototype.flipLineArrowObj = function (obj, value) {\n        value = value.toLowerCase();\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj.pointColl)) {\n            return;\n        }\n        if (value === 'horizontal') {\n            this.lineArrowHorizontalFlip(obj);\n        }\n        else if (value === 'vertical') {\n            this.lineArrowVerticalFlip(obj);\n        }\n        else {\n            this.lineArrowHorizontalFlip(obj);\n            obj.shapeFlip = '';\n            this.lineArrowVerticalFlip(obj);\n        }\n        obj.activePoint.startX = obj.pointColl[0].x;\n        obj.activePoint.startY = obj.pointColl[0].y;\n        obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x;\n        obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y;\n        if (obj.activePoint.startX > obj.activePoint.endX) {\n            var temp = obj.activePoint.startX;\n            obj.activePoint.startX = obj.activePoint.endX;\n            obj.activePoint.endX = temp;\n            temp = obj.activePoint.startY;\n            obj.activePoint.startY = obj.activePoint.endY;\n            obj.activePoint.endY = temp;\n        }\n    };\n    Shape.prototype.lineArrowHorizontalFlip = function (obj) {\n        var parent = this.parent;\n        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;\n        if (obj.shapeFlip !== parent.transform.currFlipState) {\n            for (var l = 0, len = obj.pointColl.length; l < len; l++) {\n                var currPoint = obj.pointColl[l];\n                if (currPoint.x <= destLeft + (destWidth / 2)) {\n                    currPoint.x = (destLeft + destWidth) - (currPoint.x - destLeft);\n                }\n                else if (currPoint.x >= destLeft + (destWidth / 2)) {\n                    currPoint.x = destLeft + (destLeft + destWidth - currPoint.x);\n                }\n                currPoint.ratioX = (currPoint.x - destLeft) / destWidth;\n                currPoint.ratioY = (currPoint.y - destTop) / destHeight;\n            }\n            if (obj.shape === 'arrow') {\n                var value = obj.start;\n                obj.start = obj.end;\n                obj.end = value;\n            }\n            obj.shapeFlip = parent.transform.currFlipState;\n        }\n    };\n    Shape.prototype.lineArrowVerticalFlip = function (obj) {\n        var parent = this.parent;\n        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;\n        if (obj.shapeFlip !== parent.transform.currFlipState) {\n            for (var l = 0, len = obj.pointColl.length; l < len; l++) {\n                var currPoint = obj.pointColl[l];\n                if (currPoint.y <= destTop + (destHeight / 2)) {\n                    currPoint.y = (destTop + destHeight) - (currPoint.y - destTop);\n                }\n                else if (currPoint.y >= destTop + (destHeight / 2)) {\n                    currPoint.y = destTop + (destTop + destHeight - currPoint.y);\n                }\n                currPoint.ratioX = (currPoint.x - destLeft) / destWidth;\n                currPoint.ratioY = (currPoint.y - destTop) / destHeight;\n            }\n            obj.shapeFlip = parent.transform.currFlipState;\n        }\n    };\n    Shape.prototype.getRotDegOfShape = function (obj, value) {\n        var parent = this.parent;\n        var degree;\n        if (obj.shapeDegree === 0) {\n            degree = this.parent.transform.degree;\n        }\n        else {\n            degree = this.parent.transform.degree - obj.shapeDegree;\n        }\n        if (degree < 0) {\n            degree = 360 + degree;\n        }\n        var transformObj = { bool: false };\n        parent.notify('selection', { prop: 'getTransformedShape', onPropertyChange: false, value: { obj: transformObj } });\n        if (transformObj['bool'] && !value && parent.activeObj.rotateFlipColl) {\n            degree = 0;\n            for (var i = 0; i < parent.activeObj.rotateFlipColl.length; i++) {\n                if (typeof (parent.activeObj.rotateFlipColl[i]) === 'number') {\n                    degree += (parent.activeObj.rotateFlipColl[i]);\n                }\n            }\n        }\n        return degree;\n    };\n    Shape.prototype.renderTextArea = function (x, y, actObj) {\n        var parent = this.parent;\n        var shapeObj = { shapeSettingsObj: {} };\n        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: shapeObj } });\n        var shapeSettings = shapeObj['shapeSettingsObj'];\n        var shapeChangingArgs = { cancel: false, action: 'text-edit', previousShapeSettings: shapeSettings,\n            currentShapeSettings: shapeSettings };\n        parent.trigger('shapeChanging', shapeChangingArgs);\n        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);\n        var degree = this.getRotDegOfShape(parent.activeObj);\n        this.transformTextArea();\n        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });\n        var zOrderElem = parent.element.querySelector('#' + parent.element.id + '_zOrderBtn');\n        var dupElem = parent.element.querySelector('#' + parent.element.id + '_duplicate');\n        var removeElem = parent.element.querySelector('#' + parent.element.id + '_remove');\n        var editTextElem = parent.element.querySelector('#' + parent.element.id + '_editText');\n        var shadowColor = actObj.strokeSettings.outlineColor;\n        var outlineWidth = actObj.strokeSettings.outlineWidth;\n        var shadows = [];\n        if (zOrderElem) {\n            zOrderElem.classList.add('e-overlay');\n        }\n        if (dupElem) {\n            dupElem.classList.add('e-overlay');\n        }\n        if (removeElem) {\n            removeElem.classList.add('e-overlay');\n        }\n        if (editTextElem) {\n            editTextElem.classList.add('e-overlay');\n        }\n        if (actObj.strokeSettings.fillColor !== '') {\n            parent.textArea.style.backgroundColor = actObj.strokeSettings.fillColor;\n        }\n        else {\n            parent.textArea.style.backgroundColor = 'transparent';\n        }\n        parent.textArea.style.display = 'block';\n        parent.textArea.style.left = x + 'px';\n        parent.textArea.style.top = y + 'px';\n        parent.textArea.style.fontFamily = actObj.textSettings.fontFamily;\n        parent.textArea.style.fontSize = actObj.textSettings.fontSize + 'px';\n        parent.textArea.style.color = actObj.strokeSettings.strokeColor;\n        var fontSize = actObj.textSettings.fontSize;\n        var baseWidth = Math.max(1, outlineWidth / 2);\n        var adjustedOutlineWidth = baseWidth * (Math.floor((fontSize - 1) / 16) * 0.5 + 0.5);\n        if (/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$|^[a-zA-Z]+$/.test(actObj.strokeSettings.outlineColor)) {\n            for (var x_1 = -adjustedOutlineWidth; x_1 <= adjustedOutlineWidth; x_1++) {\n                for (var y_1 = -adjustedOutlineWidth; y_1 <= adjustedOutlineWidth; y_1++) {\n                    if (x_1 !== 0 || y_1 !== 0) {\n                        shadows.push(x_1 / 2 + \"px \" + y_1 / 2 + \"px 0 \" + shadowColor);\n                    }\n                }\n            }\n            parent.textArea.style.textShadow = shadows.join(', ');\n        }\n        else {\n            parent.textArea.style.textShadow = null;\n        }\n        parent.textArea.style.fontWeight = actObj.textSettings.bold ? 'bold' : 'normal';\n        parent.textArea.style.fontStyle = actObj.textSettings.italic ? 'italic' : 'normal';\n        parent.textArea.style.border = '2px solid ' + parent.themeColl[parent.theme]['primaryColor'];\n        parent.textArea.value = actObj.keyHistory;\n        parent.textArea.style.overflow = 'hidden';\n        parent.textArea.style.width = 'auto';\n        parent.textArea.style.height = 'auto';\n        parent.textArea.focus();\n        var _a = actObj.activePoint, width = _a.width, height = _a.height;\n        if (degree % 90 === 0 && degree % 180 !== 0 && degree !== 0) {\n            parent.textArea.style.width = height + (height * 0.25) + 'px';\n            parent.textArea.style.height = width + (width * 0.25) + 'px';\n        }\n        else {\n            parent.textArea.style.width = width + (width * 0.25) + 'px';\n            parent.textArea.style.height = height + (height * 0.25) + 'px';\n        }\n        this.setTextBoxWidth();\n        var obj = { flipColl: null };\n        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });\n        if (obj['flipColl'].length <= 1) {\n            this.setTextBoxHeight();\n        }\n        if (parseFloat(parent.textArea.style.maxHeight) < parent.activeObj.textSettings.fontSize) {\n            parent.textArea.style.maxHeight = parent.activeObj.textSettings.fontSize + 'px';\n        }\n        if (degree % 90 === 0 && degree % 180 !== 0) {\n            if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destTop +\n                parent.img.destHeight) {\n                this.alignTextAreaIntoCanvas();\n            }\n        }\n        else {\n            if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destLeft +\n                parent.img.destWidth) {\n                this.alignTextAreaIntoCanvas();\n            }\n        }\n        // Limit text area\n        if (actObj.rotatedAngle !== 0) {\n            var tempLeft = parseFloat(parent.textArea.style.left);\n            var tempTop = parseFloat(parent.textArea.style.top);\n            if (actObj.flipObjColl.length > 0) {\n                var panObj = { panRegion: '' };\n                var _b = parent.lowerCanvas, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;\n                var center_1 = { x: 0, y: 0 };\n                parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,\n                    value: { panObj: panObj } });\n                if (panObj['panRegion'] !== '') {\n                    if (panObj['panRegion'] === 'horizontal') {\n                        center_1.x = clientWidth - (clientWidth / 2);\n                        tempLeft = (center_1.x - tempLeft) + center_1.x;\n                    }\n                    else if (panObj['panRegion'] === 'vertical') {\n                        center_1.y = clientHeight - (clientHeight / 2);\n                        tempTop = (center_1.y - tempTop) + center_1.y;\n                    }\n                    else {\n                        center_1 = { x: clientWidth - (clientWidth / 2), y: clientHeight - (clientHeight / 2) };\n                        tempLeft = (center_1.x - tempLeft) + center_1.x;\n                        tempTop = (center_1.y - tempTop) + center_1.y;\n                    }\n                }\n            }\n            var left = tempLeft + parseFloat(parent.textArea.style.width);\n            var top_1 = tempTop + parseFloat(parent.textArea.style.height);\n            var width1 = parseFloat(parent.textArea.style.width);\n            var height1 = parseFloat(parent.textArea.style.height);\n            var center = { x: left - (width1 / 2), y: top_1 - (height1 / 2) };\n            var cosAngle = Math.cos(actObj.rotatedAngle);\n            var sinAngle = Math.sin(actObj.rotatedAngle);\n            var p1 = { x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,\n                y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y };\n            if (p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth &&\n                // eslint-disable-next-line max-len\n                p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight) {\n                // eslint-disable-next-line no-self-assign\n                parent.textArea.style.width = parent.textArea.style.width;\n            }\n            else {\n                var count = 0;\n                var width2 = parseFloat(parent.textArea.style.width);\n                while (true) {\n                    count++;\n                    width1 -= 1;\n                    left = tempLeft + width1;\n                    center = { x: left - (width1 / 2), y: top_1 - (height1 / 2) };\n                    p1 = { x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,\n                        y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y };\n                    if ((p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth &&\n                        // eslint-disable-next-line max-len\n                        p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight) ||\n                        count === width2) {\n                        parent.textArea.style.width = width1 + 'px';\n                        break;\n                    }\n                }\n            }\n        }\n        parent.notify('selection', { prop: 'clearUpperCanvas', onPropertyChange: false });\n    };\n    Shape.prototype.setTextBoxWidth = function (e) {\n        var parent = this.parent;\n        if (parent.activeObj.rotatedAngle !== 0) {\n            parent.textArea.style.whiteSpace = 'nowrap';\n            parent.textArea.style.textOverflow = 'ellipsis';\n            parent.textArea.style.display = 'inline-block';\n            return;\n        }\n        else {\n            parent.textArea.style.whiteSpace = '';\n            parent.textArea.style.textOverflow = '';\n            if (parent.textArea.style.display === 'inline-block') {\n                parent.textArea.style.display = 'block';\n            }\n        }\n        var text = this.getMaxText(true);\n        if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {\n            this.updateFontStyles(true);\n        }\n        else {\n            this.updateFontStyles();\n        }\n        var textAreaWidth = (this.upperContext.measureText(text).width + (parseFloat(parent.textArea.style.fontSize) / 2));\n        var letterWidth = e ? this.upperContext.measureText(String.fromCharCode(e.which)).width : 0;\n        var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        var flip = '';\n        var degree = this.getRotDegOfShape(actObj);\n        if (actObj.shapeFlip !== parent.transform.currFlipState) {\n            flip = '';\n        }\n        else {\n            flip = parent.transform.currFlipState;\n        }\n        if ((e && parseFloat(parent.textArea.style.width) < (textAreaWidth + letterWidth)) || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(e)) {\n            if (degree === 0) {\n                if (flip.toLowerCase() === 'horizontal') {\n                    if ((parseFloat(parent.textArea.style.left) - parent.img.destLeft) - textAreaWidth - letterWidth > 0) {\n                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                    }\n                }\n                else if ((parent.img.destWidth - (parseFloat(parent.textArea.style.left) -\n                    parent.img.destLeft)) > (textAreaWidth + letterWidth)) {\n                    parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                }\n            }\n            else if (degree === 90) {\n                if (flip.toLowerCase() === 'vertical') {\n                    if ((parseFloat(parent.textArea.style.top) - parent.img.destTop) - textAreaWidth - letterWidth > 0) {\n                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                    }\n                }\n                else if ((parent.img.destHeight - (parseFloat(parent.textArea.style.top) -\n                    parent.img.destTop)) > (textAreaWidth + letterWidth)) {\n                    parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                }\n            }\n            else if (degree === 180) {\n                var textAreaLeft = parseFloat(parent.textArea.style.left);\n                var destLeft = parent.img.destLeft;\n                if (flip.toLowerCase() === 'horizontal') {\n                    var remainingWidth = parent.img.destWidth - (textAreaLeft - destLeft);\n                    if (remainingWidth > textAreaWidth + letterWidth) {\n                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                    }\n                }\n                else {\n                    var distanceToLeft = textAreaLeft - destLeft;\n                    if (distanceToLeft - textAreaWidth - letterWidth > 0) {\n                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                    }\n                }\n            }\n            else if (degree === 270) {\n                var textAreaTop = parseFloat(parent.textArea.style.top);\n                var destTop = parent.img.destTop;\n                if (flip.toLowerCase() === 'vertical') {\n                    var remainingHeight = parent.img.destHeight - (textAreaTop - destTop);\n                    if (remainingHeight > textAreaWidth + letterWidth) {\n                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                    }\n                }\n                else {\n                    var distanceToTop = textAreaTop - destTop;\n                    if (distanceToTop - textAreaWidth - letterWidth > 0) {\n                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';\n                    }\n                }\n            }\n        }\n    };\n    Shape.prototype.setTextBoxHeight = function () {\n        var parent = this.parent;\n        var textAreaTop;\n        var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        var flip = '';\n        var degree = this.getRotDegOfShape(actObj);\n        if (actObj.textFlip === parent.transform.currFlipState) {\n            flip = '';\n        }\n        else if (actObj.textFlip === '') {\n            flip = parent.transform.currFlipState;\n        }\n        else {\n            flip = actObj.textFlip;\n        }\n        switch (degree) {\n            case 0:\n                if (flip.toLowerCase() === 'vertical') {\n                    parent.textArea.style.maxHeight = (parent.img.destHeight - (parent.img.destHeight -\n                        parseFloat(parent.textArea.style.top))) + 'px';\n                }\n                else {\n                    textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;\n                    parent.textArea.style.maxHeight = (parent.img.destHeight - textAreaTop) + 'px';\n                }\n                break;\n            case 90:\n                if (flip.toLowerCase() === 'horizontal') {\n                    parent.textArea.style.maxHeight = (parent.img.destWidth - (parseFloat(parent.textArea.style.left) -\n                        parent.img.destLeft)) + 'px';\n                }\n                else {\n                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + 'px';\n                }\n                break;\n            case 180:\n                if (flip.toLowerCase() === 'vertical') {\n                    textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;\n                    parent.textArea.style.maxHeight = (parent.img.destHeight - textAreaTop) + 'px';\n                }\n                else {\n                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.top) - parent.img.destTop) + 'px';\n                }\n                break;\n            case 270:\n                if (flip.toLowerCase() === 'horizontal') {\n                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + 'px';\n                }\n                else {\n                    parent.textArea.style.maxHeight = parent.img.destWidth - (parseFloat(parent.textArea.style.left)\n                        - parent.img.destLeft) + 'px';\n                }\n                break;\n        }\n    };\n    Shape.prototype.updatePathRatio = function (obj) {\n        var parent = this.parent;\n        for (var i = 0, len = obj.pointColl.length; i < len; i++) {\n            var currPoint = obj.pointColl[i];\n            currPoint.ratioX = (currPoint.x - parent.img.destLeft) / parent.img.destWidth;\n            currPoint.ratioY = (currPoint.y - parent.img.destTop) / parent.img.destHeight;\n        }\n    };\n    Shape.prototype.stopPathDrawing = function (e, isApply) {\n        var parent = this.parent;\n        if (parent.activeObj.shape === 'path') {\n            var obj = { shape: null };\n            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });\n            if (obj['shape'] === 'path') {\n                var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n                var object = { currObj: {} };\n                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n                var prevObj = object['currObj'];\n                prevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n                prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n                prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n                var selPointCollObj = { selPointColl: null };\n                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n                    value: { obj: selPointCollObj } });\n                prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n                parent.notify('selection', { prop: 'setCurrentDrawingShape', value: { value: '' } });\n                parent.currObjType.isDragging = false;\n                if (e && e.type !== 'touchstart' && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isApply)) {\n                    parent.activeObj.pointColl.pop();\n                }\n                this.updatePathRatio(parent.activeObj);\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.imageRatio)) {\n                    parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n                }\n                parent.objColl.push(parent.activeObj);\n                parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,\n                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                        previousCropObj: prevCropObj, previousText: null,\n                        currentText: null, previousFilter: null, isCircleCrop: null } });\n                parent.objColl.pop();\n                if (e) {\n                    parent.notify('selection', { prop: 'mouseUpEventHandler', value: { e: e } });\n                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n                    parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });\n                    if (parent.objColl.length > 0) {\n                        var obj1 = parent.activeObj.activePoint;\n                        var obj2 = parent.objColl[parent.objColl.length - 1].activePoint;\n                        if (Math.floor(obj1.startX) === Math.floor(obj2.startX) &&\n                            Math.floor(obj1.startY) === Math.floor(obj2.startY) &&\n                            Math.floor(obj1.endX) === Math.floor(obj2.endX) &&\n                            Math.floor(obj1.endY) === Math.floor(obj2.endY)) {\n                            this.refreshActiveObj();\n                        }\n                    }\n                }\n                parent.notify('draw', { prop: 'setNewPath', value: { bool: true } });\n                if (parent.objColl[parent.objColl.length - 1]) {\n                    var shape = parent.drawingShape;\n                    parent.notify('selection', { prop: 'setCurrentDrawingShape', value: { value: '' } });\n                    parent.noRedact = true;\n                    parent.selectShape(parent.objColl[parent.objColl.length - 1].currIndex);\n                    parent.notify('selection', { prop: 'setCurrentDrawingShape', value: { value: 'path' } });\n                    parent.drawingShape = shape;\n                }\n                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });\n                var obj_1 = { shapeSettingsObj: {} };\n                parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj_1 } });\n                var shapeSettings = obj_1['shapeSettingsObj'];\n                var shapeResizingArgs = { cancel: false, action: 'draw-end', previousShapeSettings: shapeSettings };\n                var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: shapeSettings };\n                parent.notify('selection', { prop: 'triggerShapeChange', onPropertyChange: false,\n                    value: { shapeResizingArgs: shapeResizingArgs, shapeMovingArgs: shapeMovingArgs, type: 'mouse-up' } });\n                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });\n            }\n        }\n    };\n    Shape.prototype.findTextTarget = function (e) {\n        var parent = this.parent;\n        if (!e) {\n            return;\n        }\n        if (parent.activeObj.shape !== 'text') {\n            if (parent.activeObj.shape === 'path') {\n                this.stopPathDrawing(e, null);\n                return;\n            }\n            else if (e.type === 'dblclick') {\n                parent.notify('selection', { prop: 'setPanDown', onPropertyChange: false, value: { panDown: null } });\n                var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n                var objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n                var obj = { bool: null };\n                parent.notify('selection', { prop: 'findTargetObj', onPropertyChange: false,\n                    value: { x: e.clientX, y: e.clientY, isCrop: false, obj: obj } });\n                parent.objColl = objColl;\n                if (!obj['bool'] || parent.activeObj.shape !== 'text') {\n                    parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, activeObj, {}, true);\n                    return;\n                }\n            }\n            else {\n                return;\n            }\n        }\n        var x;\n        var y;\n        if (e.type === 'dblclick') {\n            x = e.clientX;\n            y = e.clientY;\n        }\n        else if (e.type === 'touchstart') {\n            x = e.touches[0].clientX;\n            y = e.touches[0].clientY;\n            parent.notify('selection', { prop: 'setTouchEndPoint', onPropertyChange: false,\n                value: { x: e.touches[0].clientX, y: e.touches[0].clientY } });\n        }\n        parent.notify('toolbar', { prop: 'setPreventZoomBtn', onPropertyChange: false, value: { isPrevent: true } });\n        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',\n                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n        parent.notify('toolbar', { prop: 'setPreventZoomBtn', onPropertyChange: false, value: { isPrevent: false } });\n        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(x) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(y)) {\n            var bbox = parent.lowerCanvas.getBoundingClientRect();\n            x -= bbox.left;\n            y -= bbox.top;\n            var flip = '';\n            var degree = this.getRotDegOfShape(parent.activeObj);\n            if (parent.activeObj.textFlip === '') {\n                if (parent.activeObj.textFlip === parent.transform.currFlipState) {\n                    flip = '';\n                }\n                else {\n                    flip = parent.transform.currFlipState;\n                }\n            }\n            else {\n                if (parent.activeObj.textFlip === parent.transform.currFlipState) {\n                    flip = '';\n                }\n                else if (parent.transform.currFlipState === '') {\n                    flip = parent.activeObj.textFlip;\n                }\n                else {\n                    flip = parent.transform.currFlipState;\n                }\n            }\n            var temp = void 0;\n            if (parent.textArea.style.display === 'none') {\n                temp = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n                for (var i = 0; i < parent.objColl.length; i++) {\n                    if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {\n                        parent.objColl.splice(i, 1);\n                    }\n                }\n                this.refreshActiveObj();\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });\n                parent.notify('draw', { prop: 'redrawDownScale' });\n                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });\n                if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {\n                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,\n                        value: { context: this.lowerContext, isSave: null, isFlip: null } });\n                }\n                parent.activeObj = temp;\n                this.updateFontStyles();\n                var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n                var radius = actObj.topLeftCircle.radius;\n                var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;\n                var center = { x: startX + (width / 2), y: startY +\n                        (height / 2) };\n                var cosAngle = Math.cos(actObj.rotatedAngle);\n                var sinAngle = Math.sin(actObj.rotatedAngle);\n                var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,\n                    y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };\n                var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,\n                    y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };\n                var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,\n                    y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };\n                var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,\n                    y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };\n                var obj = { position: null, x: x, y: y, x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,\n                    x3: p3.x, y3: p3.y, x4: p4.x, y4: p4.y };\n                parent.notify('draw', { prop: 'checkPointPosition', onPropertyChange: false, value: { obj: obj } });\n                if ((actObj.rotatedAngle !== 0 && (obj['position'] === 'inside' || obj['position'] === 'on')) ||\n                    (actObj.rotatedAngle === 0 && x >= (actObj.activePoint.startX - (radius * 2)) &&\n                        x <= (actObj.activePoint.endX + (radius * 2)) &&\n                        y >= (actObj.activePoint.startY - (radius * 2)) &&\n                        y <= (actObj.activePoint.endY + (radius * 2)))) {\n                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                    if (actObj.flipObjColl.length === 4) {\n                        actObj.flipObjColl = [];\n                        flip = '';\n                        actObj.shapeFlip = '';\n                    }\n                    if (flip === '' && actObj.flipObjColl.length > 1) {\n                        flip = actObj.flipObjColl[actObj.flipObjColl.length - 1];\n                    }\n                    if (actObj.flipObjColl.length <= 1) {\n                        var points = this.setTextBoxPos(actObj, degree, flip, x, y);\n                        x = points.x;\n                        y = points.y;\n                    }\n                    else {\n                        var points = this.setTextBoxPoints(actObj, degree, flip, x, y);\n                        x = points.x;\n                        y = points.y;\n                    }\n                    if (parent.activeObj.rotatedAngle !== 0) {\n                        var point = this.getTextBoxPosition(parent.activeObj);\n                        x = point.x;\n                        y = point.y;\n                        point = this.setFlipState(x, y, parent.activeObj);\n                        x = point.x;\n                        y = point.y;\n                    }\n                    this.renderTextArea(x, y, actObj);\n                }\n                else {\n                    this.applyActObj();\n                }\n            }\n        }\n        else if ((parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')\n            && this.selectedText() !== '' && e.type === 'mousedown') {\n            var temp = parent.textArea.value;\n            parent.textArea.value += 'a';\n            parent.textArea.value = temp;\n        }\n        else if (parent.textArea.style.display === 'none') {\n            parent.textArea.style.display = 'block';\n        }\n    };\n    Shape.prototype.getTextBoxPosition = function (obj, object) {\n        var point = { x: 0, y: 0 };\n        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;\n        var center = { x: startX + (width / 2), y: startY + (height / 2) };\n        var cosAngle = Math.cos(obj.rotatedAngle);\n        var sinAngle = Math.sin(obj.rotatedAngle);\n        var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,\n            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };\n        var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,\n            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };\n        var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,\n            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };\n        var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,\n            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };\n        var degree = this.getRotDegOfShape(obj);\n        if (degree === 0 || degree === 360) {\n            point = { x: p1.x, y: p1.y };\n        }\n        else if (degree === 90 || degree === -270) {\n            point = { x: p2.x, y: p2.y };\n        }\n        else if (degree === 180 || degree === -180) {\n            point = { x: p4.x, y: p4.y };\n        }\n        else if (degree === 270 || degree === -90) {\n            point = { x: p3.x, y: p3.y };\n        }\n        if (object) {\n            object['x'] = point.x;\n            object['y'] = point.y;\n        }\n        return point;\n    };\n    Shape.prototype.setFlipState = function (x, y, obj, object) {\n        var parent = this.parent;\n        var panObj = { panRegion: '' };\n        var _a = parent.lowerCanvas, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight;\n        var center = { x: 0, y: 0 };\n        parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,\n            value: { panObj: panObj } });\n        if (panObj['panRegion'] !== '') {\n            if (panObj['panRegion'] === 'horizontal') {\n                center.x = clientWidth - (clientWidth / 2);\n                x = (center.x - x) + center.x;\n            }\n            else if (panObj['panRegion'] === 'vertical') {\n                center.y = clientHeight - (clientHeight / 2);\n                y = (center.y - y) + center.y;\n            }\n            else {\n                center = { x: clientWidth - (clientWidth / 2), y: clientHeight - (clientHeight / 2) };\n                x = (center.x - x) + center.x;\n                y = (center.y - y) + center.y;\n            }\n        }\n        if (object) {\n            object['x'] = x;\n            object['y'] = y;\n        }\n        return { x: x, y: y };\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Shape.prototype.fileChanged = function (e) {\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        var filesData = e.target.files[0];\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        var fileData = filesData;\n        var fileExtension = fileData.name && fileData.name.split('.').pop().toLowerCase();\n        if (fileExtension && ['jpg', 'jpeg', 'png', 'svg', 'webp'].indexOf(fileExtension) === -1) {\n            this.refreshActiveObj();\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/tslint/config, @typescript-eslint/no-explicit-any\n        var URL = window.URL;\n        var url = URL.createObjectURL(e.target.files[0]);\n        this.onLoadImgShape(null, null, null, null, url.toString(), true);\n        document.getElementById(this.parent.element.id + '_fileUpload').value = '';\n    };\n    Shape.prototype.onLoadImgShape = function (x, y, width, height, url, isSelect, degree, isAspectRatio, opacity, isSelected) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        var proxy = this;\n        var parent = this.parent;\n        if (typeof (url) === 'string') {\n            this.shapeImg.src = url;\n        }\n        else {\n            parent.inMemoryCanvas.width = url.width;\n            parent.inMemoryCanvas.height = url.height;\n            parent.inMemoryCanvas.getContext('2d').putImageData(url, 0, 0);\n            this.shapeImg.src = parent.inMemoryCanvas.toDataURL();\n        }\n        this.prevObjColl();\n        parent.activeObj.shape = 'image';\n        this.initShapeProps();\n        this.shapeImg.onload = function () {\n            proxy.upperContext.drawImage(proxy.shapeImg, 0, 0, proxy.shapeImg.width, proxy.shapeImg.height);\n            proxy.updateImgCanvas(isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected);\n        };\n    };\n    Shape.prototype.updateImgCanvas = function (isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected) {\n        var parent = this.parent;\n        parent.activeObj.imageElement = this.shapeImg;\n        parent.activeObj.imageCanvas = parent.createElement('canvas');\n        var dimObj = { width: 0, height: 0 };\n        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,\n            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: null } });\n        if (width && height) {\n            if (isAspectRatio) {\n                var obj_2 = { ratio: null };\n                parent.notify('selection', { prop: 'findImageRatio', onPropertyChange: false,\n                    value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_2 } });\n                dimObj = this.resizeImage(width, obj_2['ratio']);\n            }\n            else {\n                dimObj = { width: width, height: height };\n            }\n        }\n        this.updateObj(dimObj, x, y);\n        parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,\n            value: { ctx: parent.activeObj.imageCanvas.getContext('2d'), isImgAnnotation: true, isHFlip: null, isVFlip: null } });\n        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,\n            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: true } });\n        if (width && height) {\n            if (isAspectRatio) {\n                var obj_3 = { ratio: null };\n                parent.notify('selection', { prop: 'findImageRatio', onPropertyChange: false,\n                    value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_3 } });\n                dimObj = this.resizeImage(width, obj_3['ratio']);\n            }\n            else {\n                dimObj = { width: width, height: height };\n            }\n        }\n        if (opacity !== null && opacity !== undefined) {\n            parent.activeObj.opacity = opacity;\n        }\n        this.updateObj(dimObj, x, y);\n        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });\n        this.shapeImg = null;\n        if (degree) {\n            parent.activeObj.rotatedAngle = degree * (Math.PI / 180);\n            parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });\n        }\n        var obj = { shapeSettingsObj: {} };\n        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });\n        var shapeSettings = obj['shapeSettingsObj'];\n        var shapeChangingArgs = { cancel: false, action: 'insert', previousShapeSettings: shapeSettings,\n            currentShapeSettings: shapeSettings };\n        parent.trigger('shapeChanging', shapeChangingArgs);\n        parent.editCompleteArgs = shapeChangingArgs;\n        isSelect = isSelect ? isSelect : isSelected;\n        this.drawShapeImageEvent(shapeChangingArgs, isSelect);\n        if (parent.isPublicMethod && !isSelected) {\n            parent.notify('undo-redo', { prop: 'updateUndoRedo', onPropertyChange: false });\n        }\n        else if (!parent.isPublicMethod) {\n            parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });\n        }\n        parent.isPublicMethod = false;\n    };\n    Shape.prototype.updateObj = function (dimObj, x, y) {\n        var parent = this.parent;\n        parent.activeObj.activePoint.width = dimObj['width'];\n        parent.activeObj.activePoint.height = dimObj['height'];\n        parent.activeObj.activePoint.startX = x ? x : (parent.lowerCanvas.width / 2) - (dimObj['width'] / 2);\n        parent.activeObj.activePoint.startY = y ? y : (parent.lowerCanvas.height / 2) - (dimObj['height'] / 2);\n        parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + dimObj['width'];\n        parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + dimObj['height'];\n    };\n    Shape.prototype.resizeImage = function (newWidth, aspectRatio) {\n        var aspectRatioArray = aspectRatio.split(':');\n        var aspectRatioWidth = parseInt(aspectRatioArray[0], 10);\n        var aspectRatioHeight = parseInt(aspectRatioArray[1], 10);\n        var newHeight = Math.round((newWidth * aspectRatioHeight) / aspectRatioWidth);\n        return { width: newWidth, height: newHeight };\n    };\n    Shape.prototype.setTextBoxPos = function (actObj, degree, flip, x, y) {\n        var point = { x: x, y: y };\n        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;\n        flip = flip.toLowerCase();\n        switch (degree) {\n            case 0:\n                if (flip === 'horizontal') {\n                    point.x = endX;\n                    point.y = startY;\n                }\n                else if (flip === 'vertical') {\n                    point.x = startX;\n                    point.y = endY;\n                }\n                else {\n                    point.x = startX;\n                    point.y = startY;\n                }\n                break;\n            case 90:\n                if (flip === 'horizontal') {\n                    point.x = startX;\n                    point.y = startY;\n                }\n                else if (flip === 'vertical') {\n                    point.x = endX;\n                    point.y = endY;\n                }\n                else {\n                    point.x = endX;\n                    point.y = startY;\n                }\n                break;\n            case 180:\n                if (flip === 'horizontal') {\n                    point.x = startX;\n                    point.y = endY;\n                }\n                else if (flip === 'vertical') {\n                    point.x = endX;\n                    point.y = startY;\n                }\n                else {\n                    point.x = endX;\n                    point.y = endY;\n                }\n                break;\n            case 270:\n                if (flip === 'horizontal') {\n                    point.x = endX;\n                    point.y = endY;\n                }\n                else if (flip === 'vertical') {\n                    point.x = startX;\n                    point.y = startY;\n                }\n                else {\n                    point.x = startX;\n                    point.y = endY;\n                }\n                break;\n        }\n        return point;\n    };\n    Shape.prototype.setTextBoxPoints = function (actObj, degree, flip, x, y) {\n        var point = { x: x, y: y };\n        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;\n        flip = flip.toLowerCase();\n        switch (degree) {\n            case 0:\n                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {\n                    if (flip === 'horizontal') {\n                        point.x = startX;\n                        point.y = startY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = endX;\n                        point.y = endY;\n                    }\n                }\n                else {\n                    if (flip === 'horizontal') {\n                        point.x = endX;\n                        point.y = endY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = endX;\n                        point.y = startY;\n                    }\n                }\n                break;\n            case 90:\n                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {\n                    if (flip === 'horizontal') {\n                        point.x = endX;\n                        point.y = endY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = startX;\n                        point.y = endY;\n                    }\n                }\n                else {\n                    if (flip === 'horizontal') {\n                        point.x = startX;\n                        point.y = endY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = startX;\n                        point.y = startY;\n                    }\n                }\n                break;\n            case 180:\n                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {\n                    if (flip === 'horizontal') {\n                        point.x = startX;\n                        point.y = startY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = startX;\n                        point.y = startY;\n                    }\n                }\n                else {\n                    if (flip === 'horizontal') {\n                        point.x = startX;\n                        point.y = startY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = startX;\n                        point.y = endY;\n                    }\n                }\n                break;\n            case 270:\n                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {\n                    if (flip === 'horizontal') {\n                        point.x = startX;\n                        point.y = startY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = endX;\n                        point.y = startY;\n                    }\n                }\n                else {\n                    if (flip === 'horizontal') {\n                        point.x = endX;\n                        point.y = startY;\n                    }\n                    else if (flip === 'vertical') {\n                        point.x = endX;\n                        point.y = endY;\n                    }\n                }\n                break;\n        }\n        return point;\n    };\n    Shape.prototype.selectedText = function () {\n        var parent = this.parent;\n        var start = parent.textArea.selectionStart;\n        var finish = parent.textArea.selectionEnd;\n        return parent.textArea.value.substring(start, finish);\n    };\n    Shape.prototype.panObjColl = function (xDiff, yDiff, panRegion) {\n        var parent = this.parent;\n        if (parent.objColl.length > 0) {\n            for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                var currObj = parent.objColl[i];\n                if (panRegion === '') {\n                    currObj.activePoint.startX += xDiff;\n                    currObj.activePoint.endX += xDiff;\n                    if (currObj.rotationCirclePointColl) {\n                        currObj.rotationCirclePointColl.x += xDiff;\n                    }\n                    if (currObj.shape === 'path') {\n                        for (var l = 0, len_3 = currObj.pointColl.length; l < len_3; l++) {\n                            currObj.pointColl[l].x += xDiff;\n                        }\n                    }\n                    currObj.activePoint.startY += yDiff;\n                    currObj.activePoint.endY += yDiff;\n                    if (currObj.rotationCirclePointColl) {\n                        currObj.rotationCirclePointColl.y += yDiff;\n                    }\n                    if (currObj.shape === 'path') {\n                        for (var l = 0; l < currObj.pointColl.length; l++) {\n                            currObj.pointColl[l].y += yDiff;\n                        }\n                    }\n                }\n                currObj = this.updateWidthHeight(currObj);\n                parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,\n                        obj: currObj } });\n                if (currObj.shape === 'line' || currObj.shape === 'arrow') {\n                    currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);\n                    for (var j = 0, len_4 = currObj.pointColl.length; j < len_4; j++) {\n                        currObj.pointColl[j].ratioX =\n                            (currObj.pointColl[j].x - parent.img.destLeft) / parent.img.destWidth;\n                        currObj.pointColl[j].ratioY =\n                            (currObj.pointColl[j].y - parent.img.destTop) / parent.img.destHeight;\n                    }\n                }\n                this.refreshActiveObj();\n            }\n            var temp = this.lowerContext.filter;\n            this.lowerContext.filter = 'none';\n            this.iterateObjColl();\n            this.lowerContext.filter = temp;\n            this.refreshActiveObj();\n            parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });\n        }\n    };\n    Shape.prototype.updateFontStyles = function (isTextBox) {\n        var parent = this.parent;\n        this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;\n        this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;\n        var textStyle = '';\n        if (parent.activeObj.textSettings.bold) {\n            textStyle = 'bold ';\n        }\n        if (parent.activeObj.textSettings.italic) {\n            textStyle = 'italic ';\n        }\n        if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {\n            textStyle = 'italic bold ';\n        }\n        var fontSize = isTextBox ? parseFloat(parent.textArea.style.fontSize) : parent.activeObj.textSettings.fontSize;\n        var fontFamily = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') ?\n            parent.textArea.style.fontFamily : parent.activeObj.textSettings.fontFamily;\n        this.upperContext.font = textStyle + fontSize + 'px' + ' ' + fontFamily;\n    };\n    Shape.prototype.applyFontStyle = function (item) {\n        var parent = this.parent;\n        var obj = { shapeSettingsObj: {} };\n        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });\n        var shapeSettings = obj['shapeSettingsObj'];\n        this.pushActItemIntoObj();\n        var objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n        parent.objColl.pop();\n        if (parent.textArea.style.display === 'none') {\n            this.updateFontRatio(parent.activeObj);\n        }\n        else {\n            this.updateFontRatio(parent.activeObj, true);\n        }\n        switch (item) {\n            case 'default':\n                this.updateFontStyle(item, objColl, 'normal', 'normal');\n                break;\n            case 'bold':\n                this.updateFontStyle(item, objColl, 'bold', 'normal');\n                break;\n            case 'italic':\n                this.updateFontStyle(item, objColl, 'normal', 'italic');\n                break;\n            case 'bolditalic':\n                this.updateFontStyle(item, objColl, 'bold', 'italic');\n                break;\n        }\n        var shapeChangedArgs = { action: 'font-style', currentShapeSettings: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, shapeSettings, {}, true) };\n        shapeChangedArgs.currentShapeSettings.fontStyle = [item];\n        parent.trigger('shapeChange', shapeChangedArgs);\n        parent.editCompleteArgs = shapeChangedArgs;\n    };\n    Shape.prototype.updateFontStyle = function (item, objColl, fontWeight, fontStyle) {\n        var parent = this.parent;\n        var style = parent.textArea.style;\n        if (style.display === 'block' || style.display === 'inline-block') {\n            if (style.fontWeight === 'normal' && fontWeight === 'bold') {\n                style.fontWeight = 'bold';\n            }\n            else if (style.fontWeight === 'bold' && fontWeight === 'bold') {\n                style.fontWeight = 'normal';\n            }\n            if (style.fontStyle === 'normal' && fontStyle === 'italic') {\n                style.fontStyle = 'italic';\n            }\n            else if (style.fontStyle === 'italic' && fontStyle === 'italic') {\n                style.fontStyle = 'normal';\n            }\n            var value = (style.fontWeight === 'normal' && style.fontStyle === 'normal' ? 'default' :\n                (style.fontWeight === 'bold' && style.fontStyle === 'normal' ? 'bold' :\n                    (style.fontWeight === 'normal' && style.fontStyle === 'italic' ? 'italic' : 'bolditalic')));\n            var width = this.getTextAreaWidth(value);\n            style.width = width + 'px';\n            this.updateObjColl(item, objColl);\n        }\n        else {\n            this.textSettings.bold = parent.activeObj.textSettings.bold = fontWeight === 'normal' ? false : true;\n            this.textSettings.italic = parent.activeObj.textSettings.italic = fontStyle === 'normal' ? false : true;\n            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {\n                this.redrawText();\n            }\n            parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });\n        }\n    };\n    Shape.prototype.updateArrowRatio = function (obj) {\n        var parent = this.parent;\n        var object = { arrowDimension: null };\n        parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: object } });\n        var length;\n        if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {\n            length = Math.abs(obj.activePoint.width);\n        }\n        else {\n            length = Math.abs(obj.activePoint.height);\n        }\n        var dimension;\n        var dimensions = ['bar', 'arrow', 'arrowSolid', 'circle', 'square'];\n        for (var _i = 0, dimensions_1 = dimensions; _i < dimensions_1.length; _i++) {\n            dimension = dimensions_1[_i];\n            var ratioX = length / object['arrowDimension'][dimension]['width'];\n            var ratioY = length / object['arrowDimension'][dimension]['height'];\n            object['arrowDimension'][dimension]['ratioX'] = ratioX;\n            object['arrowDimension'][dimension]['ratioY'] = ratioY;\n        }\n    };\n    Shape.prototype.updateArrowSize = function (obj) {\n        var object = { arrowDimension: null };\n        this.parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: object } });\n        var length;\n        if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {\n            length = Math.abs(obj.activePoint.width);\n        }\n        else {\n            length = Math.abs(obj.activePoint.height);\n        }\n        var dimension;\n        var dimensions = ['bar', 'arrow', 'arrowSolid', 'circle', 'square'];\n        for (var _i = 0, dimensions_2 = dimensions; _i < dimensions_2.length; _i++) {\n            dimension = dimensions_2[_i];\n            var ratioX = object['arrowDimension'][dimension]['ratioX'];\n            var ratioY = object['arrowDimension'][dimension]['ratioY'];\n            object['arrowDimension'][dimension]['width'] = length / ratioX;\n            object['arrowDimension'][dimension]['height'] = length / ratioY;\n        }\n    };\n    Shape.prototype.updateFontRatio = function (obj, isTextArea) {\n        var parent = this.parent;\n        var text = this.getMaxText(isTextArea);\n        var width = this.upperContext.measureText(text).width +\n            parent.activeObj.textSettings.fontSize * 0.5;\n        var height = parent.activeObj.textSettings.fontSize;\n        var degree = this.getRotDegOfShape(obj);\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isTextArea)) {\n            if (degree === 0 || Math.abs(degree) === 180) {\n                obj.textSettings.fontRatio = width / obj.textSettings.fontSize;\n            }\n            else {\n                obj.textSettings.fontRatio = height / obj.textSettings.fontSize;\n            }\n        }\n        else if (isTextArea) {\n            var transformObj = { bool: false };\n            parent.notify('selection', { prop: 'getTransformedShape', onPropertyChange: false, value: { obj: transformObj } });\n            if (!transformObj['bool'] || degree === 0 || Math.abs(degree) === 180) {\n                obj.textSettings.fontRatio = width / parseFloat(parent.textArea.style.fontSize);\n            }\n            else {\n                obj.textSettings.fontRatio = height / parseFloat(parent.textArea.style.fontSize);\n            }\n        }\n    };\n    Shape.prototype.updateFontSize = function (obj) {\n        var degree = this.getRotDegOfShape(obj, true);\n        if (degree === 0 || Math.abs(degree) === 180) {\n            obj.textSettings.fontSize = (obj.activePoint.width / obj.textSettings.fontRatio);\n        }\n        else {\n            obj.textSettings.fontSize = (obj.activePoint.height / obj.textSettings.fontRatio);\n        }\n    };\n    Shape.prototype.updateObjColl = function (item, objColl) {\n        var parent = this.parent;\n        var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n        var object = { currObj: {} };\n        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n        var prevObj = object['currObj'];\n        prevObj.objColl = objColl;\n        prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n        prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n        var selPointCollObj = { selPointColl: null };\n        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n            value: { obj: selPointCollObj } });\n        prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n        var tempBold = parent.activeObj.textSettings.bold;\n        var tempItalic = parent.activeObj.textSettings.italic;\n        switch (item) {\n            case 'default':\n                parent.activeObj.textSettings.bold = false;\n                parent.activeObj.textSettings.italic = false;\n                break;\n            case 'bold':\n                parent.activeObj.textSettings.bold = true;\n                parent.activeObj.textSettings.italic = false;\n                break;\n            case 'italic':\n                parent.activeObj.textSettings.bold = false;\n                parent.activeObj.textSettings.italic = true;\n                break;\n            case 'bolditalic':\n                parent.activeObj.textSettings.bold = true;\n                parent.activeObj.textSettings.italic = true;\n                break;\n        }\n        parent.objColl.push(parent.activeObj);\n        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n            value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,\n                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                previousCropObj: prevCropObj, previousText: null,\n                currentText: null, previousFilter: null, isCircleCrop: null } });\n        parent.objColl.pop();\n        parent.activeObj.textSettings.bold = tempBold;\n        parent.activeObj.textSettings.italic = tempItalic;\n    };\n    Shape.prototype.pushActItemIntoObj = function () {\n        var parent = this.parent;\n        if (parent.textArea.style.display === 'none') {\n            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {\n                parent.objColl.push(parent.activeObj);\n            }\n        }\n        else {\n            var temp = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n            parent.notify('selection', { prop: 'setTextBoxStylesToActObj', onPropertyChange: false });\n            parent.objColl.push(parent.activeObj);\n            parent.activeObj = temp;\n        }\n    };\n    Shape.prototype.clearActObj = function () {\n        var parent = this.parent;\n        if (parent.textArea.style.display === 'none') {\n            this.refreshActiveObj();\n            this.applyActObj();\n            this.refreshActiveObj();\n            parent.currObjType.isCustomCrop = false;\n        }\n    };\n    Shape.prototype.refreshActiveObj = function () {\n        var parent = this.parent;\n        parent.activeObj = {};\n        parent.activeObj.activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };\n        parent.activeObj.triangle = [];\n        parent.activeObj.triangleRatio = [];\n        parent.activeObj.order = null;\n        parent.activeObj.flipObjColl = [];\n        parent.activeObj.strokeSettings = this.strokeSettings;\n        parent.activeObj.textSettings = this.textSettings;\n        parent.activeObj.rotatedAngle = 0;\n        parent.activeObj.opacity = 1;\n        parent.activeObj.redactType = this.redactType;\n        parent.activeObj.redactBlur = parent.tempRedactBlur;\n        parent.activeObj.redactPixelate = parent.tempRedactPixel;\n    };\n    Shape.prototype.applyActObj = function (isMouseDown) {\n        var parent = this.parent;\n        var isActObj = false;\n        if (parent.activeObj.shape !== undefined && parent.activeObj.shape === 'text' && parent.activeObj.keyHistory === '') {\n            this.refreshActiveObj();\n            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        }\n        else {\n            var splitWords = void 0;\n            var isCropSelection = false;\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (splitWords === undefined && parent.currObjType.isCustomCrop) {\n                isCropSelection = true;\n            }\n            else if (splitWords !== undefined && splitWords[0] === 'crop') {\n                isCropSelection = true;\n            }\n            if (parent.activeObj.shape && !isCropSelection && parent.activeObj.shape !== 'shape') {\n                for (var i = 0; i < parent.objColl.length; i++) {\n                    if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {\n                        isActObj = true;\n                        break;\n                    }\n                }\n                if (!isActObj) {\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.currIndex)) {\n                        parent.activeObj.currIndex = this.getNewShapeId();\n                    }\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.order)) {\n                        parent.activeObj.order = this.getNewOrder();\n                    }\n                    this.updImgRatioForActObj();\n                    var splitWords_1 = parent.activeObj.currIndex.split('_');\n                    var tempObjColl = parent.objColl.splice(0, parseInt(splitWords_1[1], 10) - 1);\n                    tempObjColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true));\n                    for (var i = 0; i < parent.objColl.length; i++) {\n                        tempObjColl.push(parent.objColl[i]);\n                    }\n                    parent.objColl = tempObjColl;\n                    tempObjColl = [];\n                    this.refreshActiveObj();\n                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n                    parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });\n                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });\n                    parent.currObjType.shape = '';\n                    this.refreshActiveObj();\n                    if (parent.isCircleCrop) {\n                        parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,\n                            value: { context: this.lowerContext, isSave: null, isFlip: null } });\n                    }\n                    parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isMouseDown)) {\n                        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n                        parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });\n                    }\n                }\n            }\n        }\n    };\n    Shape.prototype.getNewShapeId = function () {\n        var parent = this.parent;\n        var value = parent.objColl.length + 1;\n        for (var i = 0; i < parent.objColl.length; i++) {\n            if (parent.objColl[i].currIndex === 'shape_' + value) {\n                value++;\n                i = -1;\n            }\n        }\n        return 'shape_' + value;\n    };\n    Shape.prototype.getNewOrder = function () {\n        var parent = this.parent;\n        this.updateShapeColl();\n        var value = parent.shapeColl.length + 1;\n        for (var i = 0; i < parent.shapeColl.length; i++) {\n            if (parent.shapeColl[i].order === value) {\n                value++;\n                i = -1;\n            }\n        }\n        return value;\n    };\n    Shape.prototype.getHighestOrder = function () {\n        var parent = this.parent;\n        this.updateShapeColl();\n        var value = 0;\n        for (var i = 0; i < parent.shapeColl.length; i++) {\n            if (parent.shapeColl[i].order > value) {\n                value = parent.shapeColl[i].order;\n            }\n        }\n        return value;\n    };\n    Shape.prototype.getLowestOrder = function () {\n        var parent = this.parent;\n        this.updateShapeColl();\n        var value = 1;\n        for (var i = 0; i < parent.shapeColl.length; i++) {\n            if (parent.shapeColl[i].order < value) {\n                value = parent.shapeColl[i].order;\n            }\n        }\n        return value;\n    };\n    Shape.prototype.alignTextAreaIntoCanvas = function () {\n        var parent = this.parent;\n        var letters = parent.textArea.value;\n        parent.textArea.value = '';\n        for (var i = 0, len = letters.length; i < len; i++) {\n            parent.textArea.value += letters[i];\n            parent.textArea.style.height = 'auto';\n            parent.textArea.style.height = parent.textArea.scrollHeight + 'px';\n            this.setTextBoxWidth();\n        }\n    };\n    Shape.prototype.transformTextArea = function () {\n        var parent = this.parent;\n        if (parent.activeObj.shape === 'text') {\n            parent.textArea.style.transformOrigin = '0 0';\n            var rotatedDegree = parent.activeObj.rotatedAngle * (180 / Math.PI);\n            var scale = '';\n            var degree = this.getRotDegOfShape(parent.activeObj);\n            if (parent.activeObj.flipObjColl.length > 0) {\n                for (var i = 0; i < parent.activeObj.flipObjColl.length; i++) {\n                    if (degree !== 0 && degree % 90 === 0 && degree !== 180) {\n                        scale += parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(1, -1)' :\n                            'scale(-1, 1)';\n                    }\n                    else {\n                        scale += parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(-1, 1)' :\n                            'scale(1, -1)';\n                    }\n                    degree += rotatedDegree;\n                    if (parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {\n                        parent.textArea.style.transform = 'rotate(' + degree + 'deg)' + scale;\n                    }\n                    else if (parent.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {\n                        parent.textArea.style.transform = 'rotate(' + degree + 'deg)' + scale;\n                    }\n                }\n            }\n            else {\n                degree += rotatedDegree;\n                parent.textArea.style.transform = 'rotate(' + degree + 'deg)';\n            }\n        }\n    };\n    Shape.prototype.getTextAreaWidth = function (item) {\n        var parent = this.parent;\n        var tempBold = parent.activeObj.textSettings.bold;\n        var tempItalic = parent.activeObj.textSettings.italic;\n        switch (item) {\n            case 'default':\n                parent.activeObj.textSettings.bold = false;\n                parent.activeObj.textSettings.italic = false;\n                break;\n            case 'bold':\n                parent.activeObj.textSettings.bold = true;\n                parent.activeObj.textSettings.italic = false;\n                break;\n            case 'italic':\n                parent.activeObj.textSettings.bold = false;\n                parent.activeObj.textSettings.italic = true;\n                break;\n            case 'bolditalic':\n                parent.activeObj.textSettings.bold = true;\n                parent.activeObj.textSettings.italic = true;\n                break;\n        }\n        var isTextArea = parent.textArea.style.display === 'none' ? false : true;\n        this.updateFontStyles(isTextArea);\n        var width;\n        if (!isTextArea) {\n            width = this.upperContext.measureText(parent.activeObj.keyHistory).width +\n                parent.activeObj.textSettings.fontSize * 0.5;\n        }\n        else {\n            width = this.upperContext.measureText(parent.textArea.value).width +\n                parent.activeObj.textSettings.fontSize * 0.5;\n        }\n        parent.activeObj.textSettings.bold = tempBold;\n        parent.activeObj.textSettings.italic = tempItalic;\n        return width;\n    };\n    Shape.prototype.getRedactObjDetails = function (obj) {\n        var parent = this.parent;\n        var redactDetails = {};\n        redactDetails.id = obj.currIndex;\n        redactDetails.type = parent.toPascalCase(obj.redactType);\n        redactDetails.startX = obj.activePoint.startX;\n        redactDetails.startY = obj.activePoint.startY;\n        redactDetails.width = obj.activePoint.width;\n        redactDetails.height = obj.activePoint.height;\n        switch (obj.redactType) {\n            case 'blur':\n                redactDetails.blurIntensity = obj.redactBlur;\n                break;\n            case 'pixelate':\n                redactDetails.pixelSize = obj.redactPixelate;\n                break;\n        }\n        return redactDetails;\n    };\n    Shape.prototype.getObjDetails = function (obj) {\n        var parent = this.parent;\n        var shapeDetails = {};\n        shapeDetails.id = obj.currIndex;\n        shapeDetails.type = parent.toPascalCase(obj.shape);\n        shapeDetails.startX = obj.activePoint.startX;\n        shapeDetails.startY = obj.activePoint.startY;\n        shapeDetails.index = obj.order;\n        var transformObj = { coll: null };\n        switch (obj.shape) {\n            case 'rectangle':\n                shapeDetails.width = obj.activePoint.width;\n                shapeDetails.height = obj.activePoint.height;\n                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;\n                shapeDetails.fillColor = obj.strokeSettings.fillColor;\n                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;\n                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);\n                break;\n            case 'ellipse':\n                shapeDetails.radius = obj.activePoint.width / 2;\n                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;\n                shapeDetails.fillColor = obj.strokeSettings.fillColor;\n                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;\n                shapeDetails.radiusX = obj.activePoint.width / 2;\n                shapeDetails.radiusY = obj.activePoint.height / 2;\n                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);\n                break;\n            case 'line':\n            case 'arrow':\n                shapeDetails.length = obj.activePoint.width;\n                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;\n                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;\n                shapeDetails.endX = obj.activePoint.endX;\n                shapeDetails.endY = obj.activePoint.endY;\n                if (obj.shape === 'arrow') {\n                    var arrowObj = { type: null };\n                    parent.notify('selection', { prop: 'getArrowType', onPropertyChange: false, value: { type: obj.start, obj: arrowObj } });\n                    shapeDetails.arrowHead = arrowObj['type'];\n                    parent.notify('selection', { prop: 'getArrowType', onPropertyChange: false, value: { type: obj.end, obj: arrowObj } });\n                    shapeDetails.arrowTail = arrowObj['type'];\n                }\n                break;\n            case 'text':\n                shapeDetails.text = obj.keyHistory;\n                shapeDetails.fontSize = obj.textSettings.fontSize;\n                shapeDetails.fontFamily = obj.textSettings.fontFamily;\n                shapeDetails.color = obj.strokeSettings.strokeColor;\n                shapeDetails.strokeColor = obj.strokeSettings.outlineColor;\n                shapeDetails.fillColor = obj.strokeSettings.fillColor;\n                shapeDetails.strokeWidth = obj.strokeSettings.outlineWidth;\n                shapeDetails.fontStyle = [];\n                if (obj.textSettings.bold) {\n                    shapeDetails.fontStyle.push('bold');\n                }\n                if (obj.textSettings.italic) {\n                    shapeDetails.fontStyle.push('italic');\n                }\n                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);\n                parent.notify('selection', { prop: 'updateTransColl', onPropertyChange: false, value: { obj: transformObj, object: obj } });\n                shapeDetails.transformCollection = transformObj['coll'];\n                break;\n            case 'path':\n                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;\n                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;\n                shapeDetails.points = obj.pointColl;\n                break;\n            case 'image':\n                shapeDetails.imageData = obj.imageCanvas.toDataURL();\n                shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);\n                shapeDetails.width = obj.activePoint.width;\n                shapeDetails.height = obj.activePoint.height;\n                shapeDetails.opacity = obj.opacity;\n                break;\n        }\n        return shapeDetails;\n    };\n    Shape.prototype.getFreehandDrawDetails = function (index) {\n        var parent = this.parent;\n        var shapeDetails = {};\n        shapeDetails.id = parent.pointColl[index].id;\n        shapeDetails.type = _index__WEBPACK_IMPORTED_MODULE_1__.ShapeType.FreehandDraw;\n        shapeDetails.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[index].points);\n        shapeDetails.strokeColor = parent.pointColl[index].strokeColor;\n        shapeDetails.strokeWidth = parent.pointColl[index].strokeWidth;\n        shapeDetails.index = parent.pointColl[index].order;\n        return shapeDetails;\n    };\n    Shape.prototype.getShapeSetting = function (id, obj) {\n        var parent = this.parent;\n        var shapeDetails;\n        if (!parent.disabled && parent.isImageLoaded) {\n            if (parent.textArea.style.display !== 'none') {\n                parent.okBtn(null, true);\n            }\n            else {\n                this.applyActObj(true);\n            }\n            if (id.split('_')[0] === 'shape') {\n                var obj_4;\n                for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                    if (parent.objColl[i].currIndex === id) {\n                        obj_4 = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[i], {}, true);\n                        break;\n                    }\n                }\n                shapeDetails = this.getObjDetails(obj_4);\n            }\n            else if (id.split('_')[0] === 'pen') {\n                shapeDetails = this.getFreehandDrawDetails(parseInt(id.split('_')[1], 10) - 1);\n            }\n        }\n        obj['shapeDetails'] = shapeDetails;\n    };\n    Shape.prototype.getShapeSettings = function (obj) {\n        var parent = this.parent;\n        var shapeDetailsColl = [];\n        if (!parent.disabled && parent.isImageLoaded) {\n            if (parent.textArea.style.display !== 'none') {\n                parent.okBtn(null, true);\n            }\n            else {\n                this.applyActObj(true);\n            }\n            for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                var shapeDetails = this.getObjDetails(parent.objColl[i]);\n                shapeDetailsColl.push(shapeDetails);\n            }\n            for (var i = 0; i < parent.freehandCounter; i++) {\n                var shapeDetails = this.getFreehandDrawDetails(i);\n                shapeDetailsColl.push(shapeDetails);\n            }\n        }\n        obj['shapeDetailsColl'] = shapeDetailsColl;\n    };\n    Shape.prototype.getRedactSettings = function (obj) {\n        var parent = this.parent;\n        var RedactDetailsColl = [];\n        if (!parent.disabled && parent.isImageLoaded) {\n            if (parent.textArea.style.display !== 'none') {\n                parent.okBtn(null, true);\n            }\n            else {\n                this.applyActObj(true);\n            }\n            for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                var redactDetails = this.getRedactObjDetails(parent.objColl[i]);\n                RedactDetailsColl.push(redactDetails);\n            }\n        }\n        obj['shapeDetailsColl'] = RedactDetailsColl;\n    };\n    Shape.prototype.isPointsInRange = function (x, y, obj) {\n        var inRange = false;\n        var parent = this.parent;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(x) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(y) && x >= parent.img.destLeft && y >= parent.img.destTop &&\n            x <= parent.img.destLeft + parent.img.destWidth && y <= parent.img.destTop + parent.img.destHeight) {\n            inRange = true;\n        }\n        obj['inRange'] = inRange;\n    };\n    Shape.prototype.alignRotateFlipColl = function (collection, isRotateFlipCollection, obj) {\n        collection = this.popForDefaultTransformedState(collection);\n        collection = this.popForDefaultFlipState(collection);\n        collection = this.popForDefaultRotateState(collection);\n        if (collection.length === 0 && isRotateFlipCollection) {\n            this.parent.transform.degree = 0;\n            this.parent.transform.currFlipState = '';\n        }\n        obj['collection'] = collection;\n        return collection;\n    };\n    Shape.prototype.popForDefaultTransformedState = function (collection) {\n        var rotateRight = 0;\n        var rotateleft = 0;\n        var horizontal = 0;\n        var vertical = 0;\n        for (var i = 0; i < collection.length; i++) {\n            if (collection[i] === 90 || collection[i] === 'rotateRight') {\n                rotateRight++;\n                rotateleft = 0;\n                horizontal = 0;\n                vertical = 0;\n                if (rotateRight === 4) {\n                    collection.pop();\n                    collection.pop();\n                    collection.pop();\n                    collection.pop();\n                }\n            }\n            else if (collection[i] === -90 || collection[i] === 'rotateLeft') {\n                rotateleft++;\n                rotateRight = 0;\n                horizontal = 0;\n                vertical = 0;\n                if (rotateleft === 4) {\n                    collection.pop();\n                    collection.pop();\n                    collection.pop();\n                    collection.pop();\n                }\n            }\n            else if (collection[i] === 'horizontal' || collection[i] === 'Horizontal'\n                || collection[i] === 'horizontalflip') {\n                horizontal++;\n                rotateleft = 0;\n                rotateRight = 0;\n                vertical = 0;\n                if (horizontal === 2) {\n                    collection.pop();\n                    collection.pop();\n                }\n            }\n            else if (collection[i] === 'vertical' || collection[i] === 'Vertical'\n                || collection[i] === 'verticalflip') {\n                vertical++;\n                horizontal = 0;\n                rotateleft = 0;\n                rotateRight = 0;\n                if (vertical === 2) {\n                    collection.pop();\n                    collection.pop();\n                }\n            }\n        }\n        return collection;\n    };\n    Shape.prototype.popForDefaultFlipState = function (collection) {\n        for (var i = 0, iLen = collection.length - 3; i < iLen; i++) {\n            var isHorizontal = collection[i] === 'horizontal' || collection[i] === 'Horizontal'\n                || collection[i] === 'horizontalFlip';\n            var isVertical = collection[i] === 'vertical' || collection[i] === 'Vertical' ||\n                collection[i] === 'verticalFlip';\n            var isNextHorizontal = collection[i + 1] === 'horizontal' || collection[i + 1] === 'Horizontal' ||\n                collection[i + 1] === 'horizontalFlip';\n            var isNextVertical = collection[i + 1] === 'vertical' || collection[i + 1] === 'Vertical' ||\n                collection[i + 1] === 'verticalFlip';\n            var isNextToNextHorizontal = collection[i + 2] === 'horizontal' || collection[i + 2] === 'Horizontal' ||\n                collection[i + 2] === 'horizontalFlip';\n            var isNextToNextVertical = collection[i + 2] === 'vertical' || collection[i + 2] === 'Vertical' ||\n                collection[i + 2] === 'verticalFlip';\n            var isNextToNextToNextHorizontal = collection[i + 3] === 'horizontal' || collection[i + 3] === 'Horizontal' ||\n                collection[i + 3] === 'horizontalFlip';\n            if ((isHorizontal && isNextVertical && isNextToNextHorizontal && isNextToNextVertical) ||\n                (isVertical && isNextHorizontal && isNextToNextVertical && isNextToNextToNextHorizontal)) {\n                collection.splice(i, 4);\n                i -= 4;\n            }\n        }\n        return collection;\n    };\n    Shape.prototype.popForDefaultRotateState = function (collection) {\n        for (var i = 0; i < collection.length - 1; i++) {\n            var curr = collection[i];\n            var next = collection[i + 1];\n            if ((curr === 90 || curr === 'rotateRight') && (next === -90 || next === 'rotateLeft')) {\n                collection.splice(i, 2);\n                i -= 2;\n            }\n            else if ((curr === -90 || curr === 'rotateLeft') && (next === 90 || next === 'rotateRight')) {\n                collection.splice(i, 2);\n                i -= 2;\n            }\n        }\n        return collection;\n    };\n    Shape.prototype.selectShape = function (id, obj) {\n        var parent = this.parent;\n        var isSelected = false;\n        if (!parent.disabled && parent.isImageLoaded) {\n            this.applyActObj();\n            if (id.split('_')[0] === 'shape') {\n                var obj_5;\n                for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                    if (parent.objColl[i].currIndex === id) {\n                        obj_5 = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[i], {}, true);\n                        break;\n                    }\n                }\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj_5)) {\n                    isSelected = false;\n                }\n                else {\n                    isSelected = true;\n                    parent.activeObj = obj_5;\n                    var object = { canvasFilter: null };\n                    parent.notify('toolbar', { prop: 'getCanvasFilter', onPropertyChange: false, value: { obj: object } });\n                    this.lowerContext.filter = object['canvasFilter'];\n                    parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,\n                        value: { obj: parent.activeObj } });\n                    if (parent.activeObj.shape === 'text') {\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',\n                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    }\n                    else if (parent.activeObj.shape === 'pen') {\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',\n                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    }\n                    else if (parent.activeObj.shape === 'redact') {\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',\n                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    }\n                    else {\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',\n                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    }\n                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });\n                }\n            }\n            else if (id.split('_')[0] === 'pen') {\n                var object = { bool: false };\n                parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: object } });\n                if (object['bool']) {\n                    parent.okBtn(null, true);\n                }\n                var obj_6 = { isIndex: false };\n                parent.notify('freehand-draw', { prop: 'isFHDIdx', value: { index: parseInt(id.split('_')[1], 10) - 1, obj: obj_6 } });\n                if (obj_6['isIndex']) {\n                    isSelected = true;\n                    parent.notify('freehand-draw', { prop: 'selectFhd', value: { id: id } });\n                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });\n                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n                }\n                else {\n                    isSelected = false;\n                }\n            }\n        }\n        obj['isSelected'] = isSelected;\n    };\n    Shape.prototype.deleteShape = function (id) {\n        var parent = this.parent;\n        if (!parent.disabled && parent.isImageLoaded) {\n            if (parent.activeObj.currIndex && parent.activeObj.currIndex === id) {\n                parent.notify('selection', { prop: 'deleteItem', onPropertyChange: false });\n            }\n            else {\n                this.applyActObj();\n                if (id.split('_')[0] === 'shape') {\n                    for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                        if (parent.objColl[i].currIndex === id) {\n                            parent.objColl.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n                else if (id.split('_')[0] === 'pen') {\n                    parent.notify('freehand-draw', { prop: 'handle-freehand-draw', value: { id: id } });\n                }\n            }\n            var object = { canvasFilter: null };\n            parent.notify('toolbar', { prop: 'getCanvasFilter', onPropertyChange: false, value: { obj: object } });\n            this.lowerContext.filter = object['canvasFilter'];\n            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n            parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });\n            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n        }\n    };\n    Shape.prototype.getMaxText = function (isTextBox, text, obj) {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(text)) {\n            text = isTextBox ? this.parent.textArea.value : this.parent.activeObj.keyHistory;\n            if (!text) {\n                return text;\n            }\n        }\n        var maxi;\n        var rows = text.split('\\n');\n        var maxStr = rows[0].length;\n        var maxText = rows[0];\n        for (var i = 1; i < rows.length; i++) {\n            maxi = rows[i].length;\n            if (maxi > maxStr) {\n                maxText = rows[i];\n                maxStr = maxi;\n            }\n        }\n        if (obj) {\n            obj['maxText'] = maxText;\n        }\n        return maxText;\n    };\n    Shape.prototype.getLinePoints = function (x1, y1, x2, y2) {\n        var points = [];\n        var i;\n        var j;\n        if (x1 === x2) {\n            if (y1 < y2) {\n                i = [x1, y1];\n                j = [x2, y2];\n            }\n            else {\n                j = [x1, y1];\n                i = [x2, y2];\n            }\n            var m = this.getSlope(i, j, true);\n            var b = this.getIntercept(i, m);\n            for (var y = i[1]; y <= j[1]; y++) {\n                var x = m * y + b;\n                points.push({ x: x, y: y });\n            }\n        }\n        else {\n            if (x1 < x2) {\n                i = [x1, y1];\n                j = [x2, y2];\n            }\n            else {\n                j = [x1, y1];\n                i = [x2, y2];\n            }\n            var m = this.getSlope(i, j, false);\n            var b = this.getIntercept(i, m);\n            for (var x = i[0]; x <= j[0]; x++) {\n                var y = m * x + b;\n                points.push({ x: x, y: y });\n            }\n        }\n        if (Math.floor(x1) === Math.floor(x2) || (points.length < 10 && (y2 - y1 > 10 || y1 - y2 > 10))) {\n            points = [];\n            var lesserY = Math.min(y1, y2);\n            for (var i_1 = 0; i_1 < Math.abs(Math.floor(y2) - Math.floor(y1)); i_1++) {\n                points.push({ x: x1, y: lesserY + i_1 });\n            }\n            if (points.length > 1) {\n                var prev = void 0;\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(points[points.length - 2])) {\n                    prev = { x: 0, y: 0 };\n                }\n                else {\n                    prev = points[points.length - 2];\n                }\n                var diffX = points[points.length - 1]['x'] - prev.x;\n                var diffY = points[points.length - 1]['y'] - prev.y;\n                points.push({ x: points[points.length - 1]['x'] + (diffX / 2), y: points[points.length - 1]['y'] + (diffY / 2) });\n            }\n        }\n        else if (Math.floor(y1) === Math.floor(y2) || (points.length < 10 && (x2 - x1 > 10 || x1 - x2 > 10))) {\n            points = [];\n            var lesserX = Math.min(x1, x2);\n            for (var i_2 = 0; i_2 < Math.abs(Math.floor(x2) - Math.floor(x1)); i_2++) {\n                points.push({ x: lesserX + i_2, y: y1 });\n            }\n            if (points.length > 1) {\n                var prev = void 0;\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(points[points.length - 2])) {\n                    prev = { x: 0, y: 0 };\n                }\n                else {\n                    prev = points[points.length - 2];\n                }\n                var diffX = points[points.length - 1]['x'] - prev.x;\n                var diffY = points[points.length - 1]['y'] - prev.y;\n                points.push({ x: points[points.length - 1]['x'] + (diffX / 2), y: points[points.length - 1]['y'] + (diffY / 2) });\n            }\n        }\n        return points;\n    };\n    Shape.prototype.getSlope = function (a, b, isSameAxis) {\n        var slope;\n        if (isSameAxis) {\n            if (a[1] === b[1]) {\n                return null;\n            }\n            slope = (b[0] - a[0]) / (b[1] - a[1]);\n        }\n        else {\n            if (a[0] === b[0]) {\n                return null;\n            }\n            slope = (b[1] - a[1]) / (b[0] - a[0]);\n        }\n        return slope;\n    };\n    Shape.prototype.getIntercept = function (point, getSlope) {\n        if (getSlope === null) {\n            return point[0];\n        }\n        return point[1] - getSlope * point[0];\n    };\n    Shape.prototype.setPointCollForShapeRotation = function (obj) {\n        var parent = this.parent;\n        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;\n        var center = { x: startX + (width / 2), y: startY +\n                (height / 2) };\n        var cosAngle = Math.cos(obj.rotatedAngle);\n        var sinAngle = Math.sin(obj.rotatedAngle);\n        var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,\n            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };\n        var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,\n            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };\n        var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,\n            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };\n        var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,\n            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };\n        obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);\n        obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);\n        obj.horBottomLinePointColl = this.getLinePoints(p3.x, p3.y, p4.x, p4.y);\n        obj.verLeftLinePointColl = this.getLinePoints(p1.x, p1.y, p3.x, p3.y);\n        obj.verRightLinePointColl = this.getLinePoints(p2.x, p2.y, p4.x, p4.y);\n        obj.verLeftLinePointColl.reverse();\n        obj.verRightLinePointColl.reverse();\n        for (var i = 0; i < obj.horTopLinePointColl.length; i++) {\n            obj.horTopLinePointColl[i].ratioX = (obj.horTopLinePointColl[i].x -\n                this.parent.img.destLeft) / this.parent.img.destWidth;\n            obj.horTopLinePointColl[i].ratioY = (obj.horTopLinePointColl[i].y -\n                this.parent.img.destTop) / this.parent.img.destHeight;\n        }\n        for (var i = 0; i < obj.horBottomLinePointColl.length; i++) {\n            obj.horBottomLinePointColl[i].ratioX = (obj.horBottomLinePointColl[i].x -\n                this.parent.img.destLeft) / this.parent.img.destWidth;\n            obj.horBottomLinePointColl[i].ratioY = (obj.horBottomLinePointColl[i].y -\n                this.parent.img.destTop) / this.parent.img.destHeight;\n        }\n        for (var i = 0; i < obj.verLeftLinePointColl.length; i++) {\n            obj.verLeftLinePointColl[i].ratioX = (obj.verLeftLinePointColl[i].x -\n                this.parent.img.destLeft) / this.parent.img.destWidth;\n            obj.verLeftLinePointColl[i].ratioY = (obj.verLeftLinePointColl[i].y -\n                this.parent.img.destTop) / this.parent.img.destHeight;\n        }\n        for (var i = 0; i < obj.verRightLinePointColl.length; i++) {\n            obj.verRightLinePointColl[i].ratioX = (obj.verRightLinePointColl[i].x -\n                this.parent.img.destLeft) / this.parent.img.destWidth;\n            obj.verRightLinePointColl[i].ratioY = (obj.verRightLinePointColl[i].y -\n                this.parent.img.destTop) / this.parent.img.destHeight;\n        }\n        if (parent.upperCanvas.style.cursor !== 'move') {\n            var object = { rotationCirclePoint: null };\n            parent.notify('selection', { prop: 'getTransRotationPoint', value: { obj: obj, object: object } });\n            var rotationCirclePoint = object['rotationCirclePoint'];\n            if (rotationCirclePoint) {\n                obj.rotationCirclePointColl = { x: cosAngle * (rotationCirclePoint.x - center.x) -\n                        sinAngle * (rotationCirclePoint.y - center.y) + center.x,\n                    y: sinAngle * (rotationCirclePoint.x - center.x) + cosAngle\n                        * (rotationCirclePoint.y - center.y) + center.y };\n                obj.rotationCirclePointColl.ratioX = (obj.rotationCirclePointColl.x - parent.img.destLeft) /\n                    parent.img.destWidth;\n                obj.rotationCirclePointColl.ratioY = (obj.rotationCirclePointColl.y - parent.img.destTop) /\n                    parent.img.destHeight;\n            }\n        }\n    };\n    Shape.prototype.getSquarePointForRotatedShape = function (obj, object) {\n        var point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };\n        var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;\n        var center = { x: startX + (width / 2), y: startY + (height / 2) };\n        var cosAngle = Math.cos(obj.rotatedAngle);\n        var sinAngle = Math.sin(obj.rotatedAngle);\n        var p1 = { x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,\n            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y };\n        var p2 = { x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,\n            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y };\n        var p3 = { x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,\n            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y };\n        var p4 = { x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,\n            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y };\n        point.startX = p1.x;\n        point.startY = p1.y;\n        point.endX = p1.x;\n        point.endY = p1.y;\n        if (point.startX > p2.x) {\n            point.startX = p2.x;\n        }\n        if (point.startX > p3.x) {\n            point.startX = p3.x;\n        }\n        if (point.startX > p4.x) {\n            point.startX = p4.x;\n        }\n        if (point.startY > p2.y) {\n            point.startY = p2.y;\n        }\n        if (point.startY > p3.y) {\n            point.startY = p3.y;\n        }\n        if (point.startY > p4.y) {\n            point.startY = p4.y;\n        }\n        if (point.endX < p2.x) {\n            point.endX = p2.x;\n        }\n        if (point.endX < p3.x) {\n            point.endX = p3.x;\n        }\n        if (point.endX < p4.x) {\n            point.endX = p4.x;\n        }\n        if (point.endY < p2.y) {\n            point.endY = p2.y;\n        }\n        if (point.endY < p3.y) {\n            point.endY = p3.y;\n        }\n        if (point.endY < p4.y) {\n            point.endY = p4.y;\n        }\n        point.width = point.endX - point.startX;\n        point.height = point.endY - point.startY;\n        if (object) {\n            object['activePoint'] = point;\n        }\n        return point;\n    };\n    Shape.prototype.updateZOrder = function (obj, value) {\n        var parent = this.parent;\n        value = value.toLowerCase();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var object = obj;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(object.order)) {\n            return;\n        }\n        var index;\n        var prevIndex;\n        var highestOrder = this.getHighestOrder();\n        this.updateShapeColl();\n        if (parent.shapeColl.length === 0) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var coll;\n        for (var i = 0; i < parent.shapeColl.length; i++) {\n            coll = parent.shapeColl[i];\n            if (object.id && object.id.indexOf('pen') > -1) {\n                if (coll.id && coll.id === object.id) {\n                    parent.shapeColl.splice(i, 1);\n                }\n            }\n            else if (coll.shape && coll.shape.indexOf('crop-') > -1) {\n                parent.shapeColl.splice(i, 1);\n            }\n        }\n        switch (value) {\n            case 'sendtoback':\n                prevIndex = object.order;\n                index = object.order;\n                object.order = 1;\n                break;\n            case 'sendbackward':\n                object.order -= 1;\n                index = object.order;\n                break;\n            case 'bringtofront':\n                prevIndex = object.order;\n                index = highestOrder;\n                object.order = index;\n                break;\n            case 'bringforward':\n                object.order += 1;\n                index = object.order;\n                break;\n        }\n        this.reArrangeObjColl(index, value, prevIndex);\n        if (object.id && object.id.indexOf('pen') > -1) {\n            this.reUpdateShapeColl(object);\n        }\n    };\n    Shape.prototype.reArrangeObjColl = function (index, value, prevIndex) {\n        var parent = this.parent;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var obj;\n        switch (value) {\n            case 'sendtoback':\n                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {\n                    obj = parent.shapeColl[i];\n                    if (obj.order < prevIndex && obj.order <= index) {\n                        obj.order += 1;\n                        this.reUpdateShapeColl(obj);\n                    }\n                }\n                break;\n            case 'sendbackward':\n                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {\n                    obj = parent.shapeColl[i];\n                    if (obj.order === index) {\n                        obj.order += 1;\n                        this.reUpdateShapeColl(obj);\n                        break;\n                    }\n                }\n                break;\n            case 'bringtofront':\n                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {\n                    obj = parent.shapeColl[i];\n                    if (obj.order > prevIndex && obj.order <= index) {\n                        obj.order -= 1;\n                        this.reUpdateShapeColl(obj);\n                    }\n                }\n                break;\n            case 'bringforward':\n                for (var i = 0, len = parent.shapeColl.length; i < len; i++) {\n                    obj = parent.shapeColl[i];\n                    if (obj.order === index) {\n                        obj.order -= 1;\n                        this.reUpdateShapeColl(obj);\n                        break;\n                    }\n                }\n                break;\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Shape.prototype.reorderRedact = function (tempObjColl) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var nonRedact = tempObjColl.filter(function (item) { return item.shape !== 'redact'; });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var redact = tempObjColl.filter(function (item) { return item.shape === 'redact'; });\n        return redact.concat(nonRedact);\n    };\n    Shape.prototype.updateShapeColl = function () {\n        var parent = this.parent;\n        var isOrdered = false;\n        var tempOrder = 1;\n        var tempObjColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n        tempObjColl = this.reorderRedact(tempObjColl);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var tempPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n        if (parent.shapeColl.length > 0 &&\n            parent.shapeColl.length === parent.objColl.length + parent.pointColl.length) {\n            for (var i = 0; i < parent.shapeColl.length; i++) {\n                if (parent.shapeColl[i].order === tempOrder) {\n                    isOrdered = true;\n                    tempOrder++;\n                }\n                else {\n                    isOrdered = false;\n                    break;\n                }\n            }\n            if (isOrdered) {\n                for (var i = 0; i < parent.shapeColl.length; i++) {\n                    if (parent.shapeColl[i].currIndex &&\n                        parent.shapeColl[i].currIndex.indexOf('shape') > -1) {\n                        for (var j = 0; j < tempObjColl.length; j++) {\n                            if (parent.shapeColl[i].currIndex === tempObjColl[j].currIndex) {\n                                parent.shapeColl[i] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, tempObjColl[j], {}, true);\n                                tempObjColl.splice(j, 1);\n                                break;\n                            }\n                        }\n                    }\n                    else if (parent.shapeColl[i].id && parent.shapeColl[i].id.indexOf('pen') > -1) {\n                        for (var j = 0; j < tempPointColl.length; j++) {\n                            if (parent.shapeColl[i].id === tempPointColl[j].id) {\n                                parent.shapeColl[i] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], tempPointColl[j], [], true);\n                                tempPointColl.splice(j, 1);\n                                break;\n                            }\n                        }\n                    }\n                }\n                return;\n            }\n        }\n        tempObjColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n        tempPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n        parent.shapeColl = [];\n        var order = 1;\n        var isBreak;\n        var isCrop = false;\n        while (tempObjColl.length !== 0 || tempPointColl.length !== 0) {\n            isBreak = isCrop = false;\n            for (var i = 0; i < tempObjColl.length; i++) {\n                if (tempObjColl[i].order === order ||\n                    (!tempObjColl[i].order && tempObjColl[i].shape &&\n                        tempObjColl[i].shape.indexOf('crop-') > -1)) {\n                    parent.shapeColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, tempObjColl[i], {}, true));\n                    if (tempObjColl[i].shape && tempObjColl[i].shape.indexOf('crop-') > -1) {\n                        isCrop = true;\n                    }\n                    tempObjColl.splice(i, 1);\n                    isBreak = true;\n                    break;\n                }\n            }\n            if (!isBreak) {\n                for (var i = 0; i < tempPointColl.length; i++) {\n                    if (tempPointColl[i].order === order) {\n                        parent.shapeColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], tempPointColl[i], [], true));\n                        tempPointColl.splice(i, 1);\n                        isBreak = true;\n                        break;\n                    }\n                }\n            }\n            if (!isCrop) {\n                order++;\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Shape.prototype.reUpdateShapeColl = function (obj) {\n        var parent = this.parent;\n        if (obj.id && obj.id.indexOf('pen') > -1) {\n            if (parent.freehandCounter > 0) {\n                for (var i = 0; i < parent.freehandCounter; i++) {\n                    if (parent.pointColl[i].id === obj.id) {\n                        parent.pointColl[i].order = obj.order;\n                    }\n                }\n            }\n        }\n        else if (obj.currIndex && obj.currIndex.indexOf('shape') > -1) {\n            for (var i = 0; i < parent.objColl.length; i++) {\n                if (parent.objColl[i].currIndex === obj.currIndex) {\n                    parent.objColl[i].order = obj.order;\n                }\n            }\n        }\n    };\n    Shape.prototype.drawAnnotations = function (ctx, shape, pen, isPreventApply, x, y, panRegion) {\n        var parent = this.parent;\n        var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        var tempObjColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var tempPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n        var tempSelPointCollObj = { selPointColl: null };\n        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n            value: { obj: tempSelPointCollObj } });\n        var selPointCollObj = { selPointColl: null };\n        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n            value: { obj: selPointCollObj } });\n        this.updateShapeColl();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var tempShapeColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.shapeColl, [], true);\n        tempShapeColl = this.reorderRedact(tempShapeColl);\n        var isPrevented = false;\n        if (!this.preventFrameAnnotation) {\n            this.preventFrameAnnotation = isPrevented = true;\n        }\n        for (var i = 0; i < tempShapeColl.length; i++) {\n            var isPenId = tempShapeColl[i].id;\n            if ((tempShapeColl[i].order) ||\n                (!tempShapeColl[i].order && tempShapeColl[i].shape && tempShapeColl[i].shape.indexOf('crop-') > -1) ||\n                (!tempShapeColl[i].order && tempShapeColl[i].shape === 'path' && parent.drawingShape === 'path')) {\n                if (tempShapeColl[i].currIndex && tempShapeColl[i].currIndex.indexOf('shape') > -1) {\n                    parent.objColl = [];\n                    parent.objColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, tempShapeColl[i], {}, true));\n                    if (shape === 'iterate') {\n                        var temp = this.lowerContext.filter;\n                        this.lowerContext.filter = 'none';\n                        this.iterateObjColl();\n                        this.lowerContext.filter = temp;\n                    }\n                    else if (shape === 'zoom' || shape === 'pan') {\n                        var tempObjCollIndex = -1;\n                        for (var i_3 = 0; i_3 < tempObjColl.length; i_3++) {\n                            if (JSON.stringify(tempObjColl[i_3]) === JSON.stringify(parent.objColl[0])) {\n                                tempObjCollIndex = i_3;\n                                break;\n                            }\n                        }\n                        if (shape === 'zoom') {\n                            this.zoomObjColl(isPreventApply);\n                        }\n                        else {\n                            this.panObjColl(x, y, panRegion);\n                        }\n                        if (tempObjCollIndex > -1) {\n                            tempObjColl[tempObjCollIndex] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[0], {}, true);\n                        }\n                    }\n                }\n                else if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf('pen') > -1) {\n                    parent.pointColl = [];\n                    parent.freehandCounter = 0;\n                    parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false, value: { obj: { selPointColl: [] } } });\n                    parent.pointColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, tempShapeColl[i], {}, true));\n                    parent.notify('freehand-draw', { prop: 'pushSelPointColl', onPropertyChange: false,\n                        value: { obj: { selPointColl: selPointCollObj['selPointColl'][i] } } });\n                    parent.freehandCounter = parent.pointColl.length;\n                    if (pen === 'iterate') {\n                        parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,\n                            value: { context: ctx, points: null } });\n                    }\n                    else if (pen === 'zoom' || pen === 'pan') {\n                        if (pen === 'zoom') {\n                            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false,\n                                value: { isPreventApply: isPreventApply } });\n                        }\n                        else {\n                            parent.notify('freehand-draw', { prop: 'panFHDColl', onPropertyChange: false,\n                                value: { xDiff: x, yDiff: y, panRegion: panRegion } });\n                        }\n                        for (var i_4 = 0; i_4 < tempPointColl.length; i_4++) {\n                            if (tempPointColl[i_4].id === parent.pointColl[0].id) {\n                                tempPointColl[i_4] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.pointColl[0], {}, true);\n                                break;\n                            }\n                        }\n                        for (var i_5 = 0, len = tempSelPointCollObj['selPointColl'].length; i_5 < len; i_5++) {\n                            if (tempSelPointCollObj['selPointColl'][i_5].id === selPointCollObj['selPointColl'][i_5].id) {\n                                tempSelPointCollObj['selPointColl'][i_5] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, selPointCollObj['selPointColl'][i_5], {}, true);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else if ((!tempShapeColl[i].shape && !isPenId) ||\n                (!tempShapeColl[i].currIndex && !isPenId)) {\n                tempShapeColl.splice(i, 1);\n            }\n        }\n        if (pen && pen === 'zoom') {\n            parent.pointColl = [];\n            parent.freehandCounter = 0;\n            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: isPreventApply } });\n        }\n        parent.objColl = tempObjColl;\n        parent.pointColl = tempPointColl;\n        parent.freehandCounter = parent.pointColl.length;\n        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false, value: { obj: { selPointColl: tempSelPointCollObj['selPointColl'] } } });\n        if (isPrevented && this.preventFrameAnnotation) {\n            parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });\n            this.preventFrameAnnotation = false;\n        }\n        parent.activeObj = activeObj;\n    };\n    return Shape;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/shape.js?");

/***/ })

}]);