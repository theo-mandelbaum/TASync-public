"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart3d_axis_date-time-axis_js-b045fe36"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-axis.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-axis.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime3D: () => (/* binding */ DateTime3D)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/doubleRange */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/doubleRange.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _axis_axis_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../axis/axis-helper */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/axis-helper.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n/**\n * The `DateTime` module is used to render datetime axis.\n */\nvar DateTime3D = /** @class */ (function (_super) {\n    __extends(DateTime3D, _super);\n    /**\n     * Constructor for the dateTime module.\n     *\n     * @param {Chart3D} chart - Chart3D instance.\n     * @private\n     */\n    function DateTime3D(chart) {\n        return _super.call(this, chart) || this;\n    }\n    /**\n     * Calculates the range and interval for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used for range and interval calculation.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {void}\n     */\n    DateTime3D.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.applyRangePadding(axis, size);\n        this.calculateVisibleLabels(axis, this.chart);\n    };\n    /**\n     * Retrieves the actual range for the specified axis based on the provided size.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the actual range is calculated.\n     * @param {Size} size - The size of the chart area used in the range calculation.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getActualRange = function (axis, size) {\n        var option = {\n            skeleton: 'full',\n            type: 'dateTime'\n        };\n        var dateParser = this.chart.intl.getDateParser(option);\n        var dateFormatter = this.chart.intl.getDateFormat(option);\n        // Axis min\n        if ((axis.minimum) !== null) {\n            this.min = Date.parse(dateParser(dateFormatter(new Date(_syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_2__.DataUtil.parse.parseJson({ val: axis.minimum }).val))));\n        }\n        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n            this.min = Date.parse(dateParser(dateFormatter(new Date(1970, 1, 1))));\n        }\n        // Axis Max\n        if ((axis.maximum) !== null) {\n            this.max = Date.parse(dateParser(dateFormatter(new Date(_syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_2__.DataUtil.parse.parseJson({ val: axis.maximum }).val))));\n        }\n        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n            this.max = Date.parse(dateParser(dateFormatter(new Date(1970, 5, 1))));\n        }\n        if (this.min === this.max) {\n            this.max = this.max + 2592000000;\n            this.min = this.min - 2592000000;\n        }\n        axis.actualRange = {};\n        axis.doubleRange = new _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(this.min, this.max);\n        var datetimeInterval = this.calculateDateTimeNiceInterval(axis, size, axis.doubleRange.start, axis.doubleRange.end);\n        if (!axis.interval) {\n            axis.actualRange.interval = datetimeInterval;\n        }\n        else {\n            axis.actualRange.interval = axis.interval;\n        }\n        axis.actualRange.min = axis.doubleRange.start;\n        axis.actualRange.max = axis.doubleRange.end;\n    };\n    /**\n     * Applies range padding to the specified axis based on the provided size.\n     *\n     * @param {Chart3DAxis} axis - The axis to which range padding is applied.\n     * @param {Size} size - The size of the chart area used in the padding calculation.\n     * @returns {void}\n     */\n    DateTime3D.prototype.applyRangePadding = function (axis, size) {\n        this.min = (axis.actualRange.min);\n        this.max = (axis.actualRange.max);\n        var minimum;\n        var maximum;\n        var interval = axis.actualRange.interval;\n        if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.setRange)(axis)) {\n            var rangePadding = axis.getRangePadding(this.chart);\n            minimum = new Date(this.min);\n            maximum = new Date(this.max);\n            var intervalType = axis.actualIntervalType;\n            if (rangePadding === 'None') {\n                this.min = minimum.getTime();\n                this.max = maximum.getTime();\n            }\n            else if (rangePadding === 'Additional' || rangePadding === 'Round') {\n                switch (intervalType) {\n                    case 'Years':\n                        this.getYear(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Months':\n                        this.getMonth(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Days':\n                        this.getDay(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Hours':\n                        this.getHour(minimum, maximum, rangePadding, interval);\n                        break;\n                    case 'Minutes': {\n                        var minute = (minimum.getMinutes() / interval) * interval;\n                        var endMinute = maximum.getMinutes() + (minimum.getMinutes() - minute);\n                        if (rangePadding === 'Round') {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute, 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute, 59)).getTime();\n                        }\n                        else {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minute + (-interval), 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), endMinute + (interval), 0)).getTime();\n                        }\n                        break;\n                    }\n                    case 'Seconds': {\n                        var second = (minimum.getSeconds() / interval) * interval;\n                        var endSecond = maximum.getSeconds() + (minimum.getSeconds() - second);\n                        if (rangePadding === 'Round') {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second, 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond, 0)).getTime();\n                        }\n                        else {\n                            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), minimum.getHours(), minimum.getMinutes(), second + (-interval), 0)).getTime();\n                            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), maximum.getHours(), maximum.getMinutes(), endSecond + (interval), 0)).getTime();\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        axis.actualRange.min = (axis.minimum != null) ? this.min : this.min;\n        axis.actualRange.max = (axis.maximum != null) ? this.max : this.max;\n        axis.actualRange.delta = (axis.actualRange.max - axis.actualRange.min);\n        axis.doubleRange = new _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(axis.actualRange.min, axis.actualRange.max);\n        this.calculateVisibleRange(size, axis);\n    };\n    /**\n     * Determines the year values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between years.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getYear = function (minimum, maximum, rangePadding, interval) {\n        var startYear = minimum.getFullYear();\n        var endYear = maximum.getFullYear();\n        if (rangePadding === 'Additional') {\n            this.min = (new Date(startYear - interval, 1, 1, 0, 0, 0)).getTime();\n            this.max = (new Date(endYear + interval, 1, 1, 0, 0, 0)).getTime();\n        }\n        else {\n            this.min = new Date(startYear, 0, 0, 0, 0, 0).getTime();\n            this.max = new Date(endYear, 11, 30, 23, 59, 59).getTime();\n        }\n    };\n    /**\n     * Determines the month values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between months.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getMonth = function (minimum, maximum, rangePadding, interval) {\n        var month = minimum.getMonth();\n        var endMonth = maximum.getMonth();\n        if (rangePadding === 'Round') {\n            this.min = (new Date(minimum.getFullYear(), month, 0, 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), endMonth, new Date(maximum.getFullYear(), maximum.getMonth(), 0).getDate(), 23, 59, 59)).getTime();\n        }\n        else {\n            this.min = (new Date(minimum.getFullYear(), month + (-interval), 1, 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), endMonth + (interval), endMonth === 2 ? 28 : 30, 0, 0, 0)).getTime();\n        }\n    };\n    /**\n     * Determines the day values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between days.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getDay = function (minimum, maximum, rangePadding, interval) {\n        var day = minimum.getDate();\n        var endDay = maximum.getDate();\n        if (rangePadding === 'Round') {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day, 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay, 23, 59, 59)).getTime();\n        }\n        else {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), day + (-interval), 0, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), endDay + (interval), 0, 0, 0)).getTime();\n        }\n    };\n    /**\n     * Determines the hour values within the specified date range with consideration for range padding and interval.\n     *\n     * @param {Date} minimum - The minimum date of the range.\n     * @param {Date} maximum - The maximum date of the range.\n     * @param {ChartRangePadding} rangePadding - The type of range padding to apply.\n     * @param {number} interval - The desired interval between hours.\n     * @returns {void}\n     */\n    DateTime3D.prototype.getHour = function (minimum, maximum, rangePadding, interval) {\n        var hour = (minimum.getHours() / interval) * interval;\n        var endHour = maximum.getHours() + (minimum.getHours() - hour);\n        if (rangePadding === 'Round') {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour, 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour, 59, 59)).getTime();\n        }\n        else {\n            this.min = (new Date(minimum.getFullYear(), minimum.getMonth(), minimum.getDate(), hour + (-interval), 0, 0)).getTime();\n            this.max = (new Date(maximum.getFullYear(), maximum.getMonth(), maximum.getDate(), endHour + (interval), 0, 0)).getTime();\n        }\n    };\n    /**\n     * Calculates the visible range for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used in the visible range calculation.\n     * @param {Chart3DAxis} axis - The axis for which the visible range is calculated.\n     * @returns {void}\n     */\n    DateTime3D.prototype.calculateVisibleRange = function (size, axis) {\n        axis.visibleRange = {\n            min: axis.actualRange.min,\n            max: axis.actualRange.max,\n            interval: axis.actualRange.interval,\n            delta: axis.actualRange.delta\n        };\n        axis.dateTimeInterval = this.increaseDateTimeInterval(axis, axis.visibleRange.min, axis.visibleRange.interval).getTime()\n            - axis.visibleRange.min;\n        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n    };\n    /**\n     * Calculate visible labels for the axis.\n     *\n     * @param {Chart3DAxis} axis -  The axis for which the labels are calculated.\n     * @param {Chart3D} chart chart\n     * @returns {void}\n     * @private\n     */\n    DateTime3D.prototype.calculateVisibleLabels = function (axis, chart) {\n        axis.visibleLabels = [];\n        var tempInterval = axis.visibleRange.min;\n        var labelStyle;\n        if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.setRange)(axis)) {\n            tempInterval = this.alignRangeStart(axis, tempInterval, axis.visibleRange.interval).getTime();\n        }\n        while (tempInterval <= axis.visibleRange.max) {\n            labelStyle = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.getValue)('properties', axis.labelStyle), null, true));\n            axis.format = chart.intl.getDateFormat({\n                format: this.findCustomFormats(axis) || '',\n                type: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.firstToLowerCase)(axis.skeletonType),\n                skeleton: this.getSkeleton(axis)\n            });\n            axis.startLabel = axis.format(new Date(axis.visibleRange.min));\n            axis.endLabel = axis.format(new Date(axis.visibleRange.max));\n            if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withIn)(tempInterval, axis.visibleRange)) {\n                var interval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();\n                if (interval > axis.visibleRange.max) {\n                    axis.endLabel = axis.format(new Date(tempInterval));\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.triggerLabelRender)(chart, tempInterval, axis.format(new Date(tempInterval)), labelStyle, axis);\n            }\n            var actualInterval = tempInterval;\n            tempInterval = this.increaseDateTimeInterval(axis, tempInterval, axis.visibleRange.interval).getTime();\n            if (actualInterval === tempInterval) {\n                break;\n            }\n        }\n        if ((axis.actualIntervalType === 'Months' || axis.actualIntervalType === 'Days')) {\n            axis.format = chart.intl.getDateFormat({\n                format: axis.labelFormat || (axis.actualIntervalType === 'Months' && !axis.skeleton ? 'y MMM' : ''),\n                type: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.firstToLowerCase)(axis.skeletonType), skeleton: axis.skeleton || (axis.actualIntervalType === 'Days' ? 'MMMd' : '')\n            });\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * Increases a date-time interval by the specified value for the given axis.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the date-time interval is increased.\n     * @param {number} value - The value by which to increase the interval.\n     * @param {number} interval - The original interval to be adjusted.\n     * @returns {Date} - The adjusted date-time interval.\n     * @private\n     */\n    DateTime3D.prototype.increaseDateTimeInterval = function (axis, value, interval) {\n        var result = new Date(value);\n        if (axis.interval) {\n            axis.isIntervalInDecimal = (interval % 1) === 0;\n            axis.visibleRange.interval = interval;\n        }\n        else {\n            interval = Math.ceil(interval);\n            axis.visibleRange.interval = interval;\n        }\n        var intervalType = axis.actualIntervalType;\n        if (axis.isIntervalInDecimal) {\n            switch (intervalType) {\n                case 'Years':\n                    result.setFullYear(result.getFullYear() + interval);\n                    return result;\n                case 'Months':\n                    result.setMonth(result.getMonth() + interval);\n                    return result;\n                case 'Days':\n                    result.setDate(result.getDate() + interval);\n                    return result;\n                case 'Hours':\n                    result.setHours(result.getHours() + interval);\n                    return result;\n                case 'Minutes':\n                    result.setMinutes(result.getMinutes() + interval);\n                    return result;\n                case 'Seconds':\n                    result.setSeconds(result.getSeconds() + interval);\n                    return result;\n            }\n        }\n        return result;\n    };\n    /**\n     * Aligns the starting date of the range for the specified axis based on the provided date and interval size.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the range start is aligned.\n     * @param {number} sDate - The date in numerical format to be aligned.\n     * @param {number} intervalSize - The size of the interval used for alignment.\n     * @returns {Date} - The aligned date for the range start.\n     * @private\n     */\n    DateTime3D.prototype.alignRangeStart = function (axis, sDate, intervalSize) {\n        var sResult = new Date(sDate);\n        switch (axis.actualIntervalType) {\n            case 'Years': {\n                var year = Math.floor(Math.floor(sResult.getFullYear() / intervalSize) * intervalSize);\n                sResult = new Date(year, sResult.getMonth(), sResult.getDate(), 0, 0, 0);\n                return sResult;\n            }\n            case 'Months': {\n                var month = Math.floor(Math.floor((sResult.getMonth()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), month, sResult.getDate(), 0, 0, 0);\n                return sResult;\n            }\n            case 'Days': {\n                var day = Math.floor(Math.floor((sResult.getDate()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), day, 0, 0, 0);\n                return sResult;\n            }\n            case 'Hours': {\n                var hour = Math.floor(Math.floor((sResult.getHours()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), hour, 0, 0);\n                return sResult;\n            }\n            case 'Minutes': {\n                var minutes = Math.floor(Math.floor((sResult.getMinutes()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), minutes, 0, 0);\n                return sResult;\n            }\n            case 'Seconds': {\n                var seconds = Math.floor(Math.floor((sResult.getSeconds()) / intervalSize) * intervalSize);\n                sResult = new Date(sResult.getFullYear(), sResult.getMonth(), sResult.getDate(), sResult.getHours(), sResult.getMinutes(), seconds, 0);\n                return sResult;\n            }\n        }\n        return sResult;\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    DateTime3D.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'DateTime3D';\n    };\n    /**\n     * To destroy the date time axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    DateTime3D.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return DateTime3D;\n}(_axis_axis_helper__WEBPACK_IMPORTED_MODULE_3__.NiceIntervals));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-axis.js?");

/***/ })

}]);