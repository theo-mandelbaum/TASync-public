"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_stacking-a"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-area-series.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-area-series.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StackingAreaSeries: () => (/* binding */ StackingAreaSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _line_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `StackingAreaSeries` module is used to render the stacking area series.\n */\nvar StackingAreaSeries = /** @class */ (function (_super) {\n    __extends(StackingAreaSeries, _super);\n    function StackingAreaSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render the Stacking area series.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The x-axis of the chart.\n     * @param {Axis} yAxis - The y-axis of the chart.\n     * @param {boolean} isInverted - Specifies whether the chart is inverted.\n     * @param {boolean} pointAnimate - Specifies whether the point has to be animated or not.\n     * @param {boolean} pointUpdate - Specifies whether the point has to be updated or not.\n     * @returns {void}\n     * @private\n     */\n    StackingAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        var polarAreaType = series.chart.chartAreaType === 'PolarRadar';\n        var getCoordinate = polarAreaType ? _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.TransformToVisible : _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint;\n        var lineDirection = '';\n        var visiblePoints = this.enableComplexProperty(series);\n        var pointsLength = visiblePoints.length;\n        var stackedvalue = series.stackedValues;\n        var pointIndex;\n        var nextPointIndex;\n        var origin = polarAreaType ?\n            Math.max(series.yAxis.visibleRange.min, stackedvalue.endValues[0]) :\n            Math.max(series.yAxis.visibleRange.min, stackedvalue.startValues[0]);\n        var startPoint = 0;\n        var point1;\n        var point2;\n        var emptyPointDirection = '';\n        if (pointsLength > 0) {\n            point1 = getCoordinate(visiblePoints[0].xValue, origin, xAxis, yAxis, isInverted, series);\n            lineDirection = lineDirection.concat('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');\n        }\n        var isPolar = (series.chart && series.chart.chartAreaType === 'PolarRadar');\n        var index;\n        for (var i = series.index; i >= 0; i--) {\n            if (series.chart.visibleSeries[i].visible) {\n                index = series.chart.visibleSeries[i].index;\n                break;\n            }\n        }\n        for (var i = 0; i < pointsLength; i++) {\n            pointIndex = visiblePoints[i].index;\n            visiblePoints[i].symbolLocations = [];\n            visiblePoints[i].regions = [];\n            if (visiblePoints[i].visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoints[i - 1], visiblePoints[i], visiblePoints[i + 1], series)) {\n                var startvalue = series.index > 0 && index !== undefined ?\n                    this.chart.visibleSeries[index].stackedValues.endValues[pointIndex] :\n                    stackedvalue.startValues[pointIndex];\n                point1 = getCoordinate(visiblePoints[i].xValue, (!series.visible && series.isLegendClicked) ? startvalue :\n                    stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series);\n                lineDirection = lineDirection.concat('L' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');\n                visiblePoints[i].symbolLocations.push(getCoordinate(visiblePoints[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted, series));\n                visiblePoints[i].regions.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(visiblePoints[i].symbolLocations[0].x - series.marker.width, visiblePoints[i].symbolLocations[0].y - series.marker.height, 2 * series.marker.width, 2 * series.marker.height));\n            }\n            else {\n                if (!isPolar && series.emptyPointSettings.mode !== 'Drop') {\n                    for (var j = i - 1; j >= startPoint; j--) {\n                        pointIndex = visiblePoints[j].index;\n                        point2 = getCoordinate(visiblePoints[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, series);\n                        lineDirection = lineDirection.concat('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');\n                    }\n                    if (visiblePoints[i + 1] && (visiblePoints[i + 1].visible &&\n                        (!isPolar || (isPolar && this.withinYRange(visiblePoints[i + 1], yAxis))))) {\n                        nextPointIndex = visiblePoints[i + 1].index;\n                        point1 = getCoordinate(visiblePoints[i + 1].xValue, stackedvalue.startValues[nextPointIndex], xAxis, yAxis, isInverted, series);\n                        lineDirection = lineDirection.concat('M' + ' ' + (point1.x) + ' ' + (point1.y) + ' ');\n                    }\n                    startPoint = i + 1;\n                }\n            }\n        }\n        if (series.chart.chartAreaType === 'PolarRadar' && visiblePoints.length > 1) {\n            var connectPoints = this.getFirstLastVisiblePoint(series.points);\n            var chart = this.chart;\n            point1 = { 'x': connectPoints.first.xValue, 'y': stackedvalue.endValues[connectPoints.first.index] };\n            point2 = getCoordinate(point1.x, point1.y, xAxis, yAxis, isInverted, series);\n            lineDirection += ('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');\n            if (this.chart.visible === 1 && (xAxis.isAxisInverse || yAxis.isAxisInverse)) {\n                this.chart.enableAnimation = false;\n                lineDirection = (series.type === 'Polar' ? chart.polarSeriesModule.getPolarIsInversedPath(xAxis, lineDirection) :\n                    chart.radarSeriesModule.getRadarIsInversedPath(xAxis, lineDirection));\n            }\n        }\n        if (!isPolar || (isPolar && series.index !== this.getFirstSeriesIndex(series.chart.visibleSeries))) {\n            for (var j = pointsLength - 1; j >= startPoint; j--) {\n                pointIndex = visiblePoints[j].index;\n                if (isPolar && !visiblePoints[j].visible) {\n                    continue;\n                }\n                var previousSeries = this.getPreviousSeries(series);\n                if (previousSeries.emptyPointSettings.mode !== 'Drop' || !previousSeries.points[j].isEmpty) {\n                    point2 = getCoordinate(visiblePoints[j].xValue, (!series.visible && series.isLegendClicked && series.index > 0\n                        && index !== undefined) ? this.chart.visibleSeries[index].stackedValues.endValues[pointIndex]\n                        : stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted, series);\n                    if (stackedvalue.startValues[pointIndex] === stackedvalue.endValues[pointIndex]) {\n                        point2.y = Math.floor(point2.y);\n                    }\n                    lineDirection = lineDirection.concat(((j === (pointsLength - 1) && polarAreaType) ? 'M' : 'L')\n                        + ' ' + (point2.x) + ' ' + (point2.y) + ' ');\n                }\n            }\n        }\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, lineDirection);\n        this[pointAnimate ? 'addAreaPath' : 'appendLinePath'](options, series, '');\n        /**\n         * To draw border for the path directions of area\n         */\n        if (series.border.width !== 0 && series.visible) {\n            emptyPointDirection = this.removeEmptyPointsBorder(this.getBorderDirection(lineDirection));\n            var options_1 = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', series.visible ? series.border.width : 0, series.border.color ? series.border.color : series.interior, 1, series.border.dashArray, emptyPointDirection);\n            this[pointAnimate ? 'addAreaPath' : 'appendLinePath'](options_1, series, '');\n        }\n        if (!pointUpdate && series.visible) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * To animate point for stacking area series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    StackingAreaSeries.prototype.updateDirection = function (series, point) {\n        for (var i = 0; i < series.xAxis.series.length; i++) {\n            var stackSeries = series.xAxis.series[i];\n            this.render(stackSeries, stackSeries.xAxis, stackSeries.yAxis, stackSeries.chart.requireInvertedAxis, false, true);\n            for (var j = 0; j < point.length; j++) {\n                if (stackSeries.marker && stackSeries.marker.visible) {\n                    stackSeries.chart.markerRender.renderMarker(stackSeries, stackSeries.points[point[j]], stackSeries.points[point[j]].symbolLocations[0], null, true);\n                }\n                if (stackSeries.marker.dataLabel.visible && stackSeries.chart.dataLabelModule) {\n                    stackSeries.chart.dataLabelModule.commonId = stackSeries.chart.element.id + '_Series_' + stackSeries.index + '_Point_';\n                    stackSeries.chart.dataLabelModule.\n                        renderDataLabel(stackSeries, stackSeries.points[point[j]], null, stackSeries.marker.dataLabel);\n                }\n            }\n        }\n    };\n    /**\n     * Adds a area path to equate the start and end paths.\n     *\n     * @param {PathOption} options - The options for the path.\n     * @param {Series} series - The series to which the path belongs.\n     * @param {string} clipRect - The clip rectangle for the path.\n     * @returns {void}\n     * @private\n     */\n    StackingAreaSeries.prototype.addAreaPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = startPathCommands.length; i < endPathCommands.length; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.splice((startPathCommands.length + 1) / 2, 0, startPathCommands.slice((startPathCommands.length - 1) / 2)[0], startPathCommands.slice((startPathCommands.length - 1) / 2)[1]);\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        endPathCommands.splice(1, 0, endPathCommands[1]);\n                        endPathCommands.splice(endPathCommands.length - 1, 0, endPathCommands[endPathCommands.length - 1]);\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    StackingAreaSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * To destroy the stacking area.\n     *\n     * @returns {void}\n     * @private\n     */\n    StackingAreaSeries.prototype.destroy = function () {\n        /**\n         * Destroy method calling here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    StackingAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'StackingAreaSeries';\n    };\n    /**\n     * Retrieves the previous series from the provided series.\n     *\n     * @param {Series} series - The current series.\n     * @returns {Series} - The previous series.\n     */\n    StackingAreaSeries.prototype.getPreviousSeries = function (series) {\n        var seriesCollection = series.chart.visibleSeries;\n        for (var i = 0, length_1 = seriesCollection.length; i < length_1; i++) {\n            if (series.index === seriesCollection[i].index && i !== 0) {\n                return seriesCollection[i - 1];\n            }\n        }\n        return seriesCollection[0];\n    };\n    /**\n     * To find the first visible series index.\n     *\n     * @param {Series[]} seriesCollection - The first visible series index.\n     * @returns {number} - Returns the first visible series index.\n     */\n    StackingAreaSeries.prototype.getFirstSeriesIndex = function (seriesCollection) {\n        for (var _i = 0, seriesCollection_1 = seriesCollection; _i < seriesCollection_1.length; _i++) {\n            var series = seriesCollection_1[_i];\n            if (series.visible) {\n                return series.index;\n            }\n        }\n        return 0;\n    };\n    return StackingAreaSeries;\n}(_line_base__WEBPACK_IMPORTED_MODULE_2__.LineBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-area-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-bar-series.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-bar-series.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StackingBarSeries: () => (/* binding */ StackingBarSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n/**\n * The `StackingBarSeries` module is used to render the stacking bar series.\n */\nvar StackingBarSeries = /** @class */ (function (_super) {\n    __extends(StackingBarSeries, _super);\n    function StackingBarSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sideBySideInfo = [];\n        return _this;\n    }\n    StackingBarSeries.prototype.render = function (series) {\n        this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);\n        var stackedValue = series.stackedValues;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var pointStack = _a[_i];\n            this.renderPoint(series, pointStack, this.sideBySideInfo[series.index], stackedValue);\n        }\n        if (series.visible) {\n            this.renderMarker(series);\n        }\n    };\n    StackingBarSeries.prototype.renderPoint = function (series, pointStack, sideBySideInfo, stackedValue) {\n        pointStack.symbolLocations = [];\n        pointStack.regions = [];\n        if (pointStack.visible &&\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(series.points[pointStack.index - 1], pointStack, series.points[pointStack.index + 1], series)) {\n            var index = void 0;\n            var startvalue = void 0;\n            if (!series.visible && series.isLegendClicked) {\n                for (var i = series.index; i >= 0; i--) {\n                    if (series.chart.visibleSeries[i].visible) {\n                        index = series.chart.visibleSeries[i].index;\n                        break;\n                    }\n                }\n                startvalue = series.index > 0 && index !== undefined ?\n                    series.chart.visibleSeries[index].stackedValues.endValues[pointStack.index] :\n                    series.stackedValues.startValues[pointStack.index];\n            }\n            this.rect = this.getRectangle(pointStack.xValue + sideBySideInfo.start, (!series.visible && series.isLegendClicked) ?\n                startvalue : stackedValue.endValues[pointStack.index], pointStack.xValue + sideBySideInfo.end, (!series.visible\n                && series.isLegendClicked) ? startvalue : stackedValue.startValues[pointStack.index], series);\n            if (series.chart.isTransposed && series.columnWidthInPixel) {\n                this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;\n                this.rect.x -= series.columnWidthInPixel / 2;\n            }\n            else {\n                this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.height;\n            }\n            this.rect.y = series.columnWidthInPixel ? series.chart.isTransposed ? this.rect.y : this.rect.y -\n                (series.columnWidthInPixel / 2) : this.rect.y;\n            var argsData = this.triggerEvent(series, pointStack, series.interior, { width: series.visible ? series.border.width : 0, color: series.visible ? series.border.color : '' });\n            if (!argsData.cancel) {\n                this.drawRectangle(series, pointStack, this.rect, argsData);\n                this.updateSymbolLocation(pointStack, this.rect, series);\n                if (series.columnFacet === 'Cylinder') {\n                    var cylinderSeriesOption = {\n                        'isColumn': false,\n                        'stacking': series.type === 'StackingBar100',\n                        'isLastSeries': true\n                    };\n                    this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);\n                }\n            }\n        }\n    };\n    StackingBarSeries.prototype.updateDirection = function (series, point) {\n        var seriesCollection = [];\n        for (var i = 0; i < series.yAxis.series.length; i++) {\n            var stackSeries = series.yAxis.series[i];\n            if (stackSeries.stackingGroup === series.stackingGroup) {\n                seriesCollection.push(stackSeries);\n            }\n        }\n        for (var j = 0; j < seriesCollection.length; j++) {\n            for (var i = 0; i < point.length; i++) {\n                this.renderPoint(seriesCollection[j], seriesCollection[j].points[point[i]], this.sideBySideInfo[series.index], seriesCollection[j].stackedValues);\n                if (series.marker && series.marker.visible) {\n                    seriesCollection[j].chart.markerRender.renderMarker(seriesCollection[j], seriesCollection[j].points[point[i]], seriesCollection[j].points[point[i]].symbolLocations[0], null, true);\n                }\n                if (seriesCollection[j].marker.dataLabel.visible && seriesCollection[j].chart.dataLabelModule) {\n                    seriesCollection[j].chart.dataLabelModule.commonId = seriesCollection[j].chart.element.id + '_Series_' + seriesCollection[j].index + '_Point_';\n                    seriesCollection[j].chart.dataLabelModule.renderDataLabel(seriesCollection[j], seriesCollection[j].points[point[i]], null, seriesCollection[j].marker.dataLabel);\n                }\n            }\n        }\n    };\n    /**\n     * To destroy the stacking bar.\n     *\n     * @returns {void}\n     * @private\n     */\n    StackingBarSeries.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    StackingBarSeries.prototype.getModuleName = function () {\n        return 'StackingBarSeries';\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    StackingBarSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    return StackingBarSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_1__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-bar-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-column-series.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-column-series.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StackingColumnSeries: () => (/* binding */ StackingColumnSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n/**\n * The `StackingColumnSeries` module is used to render the stacking column series.\n */\nvar StackingColumnSeries = /** @class */ (function (_super) {\n    __extends(StackingColumnSeries, _super);\n    function StackingColumnSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sideBySideInfo = [];\n        return _this;\n    }\n    StackingColumnSeries.prototype.render = function (series) {\n        series.isRectSeries = true;\n        this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);\n        var stackedValue = series.stackedValues;\n        var visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getVisiblePoints)(series);\n        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n            var point = visiblePoints_1[_i];\n            this.renderPoint(series, point, this.sideBySideInfo[series.index], stackedValue, visiblePoints);\n        }\n        if (series.visible) {\n            this.renderMarker(series);\n        }\n    };\n    StackingColumnSeries.prototype.renderPoint = function (series, point, sideBySideInfo, stackedValue, visiblePoints) {\n        point.symbolLocations = [];\n        point.regions = [];\n        if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n            var index = void 0;\n            var startvalue = void 0;\n            if (!series.visible && series.isLegendClicked) {\n                for (var i = series.index; i >= 0; i--) {\n                    if (series.chart.visibleSeries[i].visible) {\n                        index = series.chart.visibleSeries[i].index;\n                        break;\n                    }\n                }\n                startvalue = series.index > 0 && index !== undefined ?\n                    series.chart.visibleSeries[index].stackedValues.endValues[point.index] :\n                    series.stackedValues.startValues[point.index];\n            }\n            this.rect = this.getRectangle(point.xValue + sideBySideInfo.start, (!series.visible && series.isLegendClicked) ? startvalue :\n                stackedValue.endValues[point.index], point.xValue + sideBySideInfo.end, (!series.visible && series.isLegendClicked) ?\n                startvalue : stackedValue.startValues[point.index], series);\n            if (series.chart.isTransposed && series.columnWidthInPixel) {\n                this.rect.height = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.width;\n                this.rect.y -= series.columnWidthInPixel / 2;\n            }\n            else {\n                this.rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : this.rect.width;\n            }\n            this.rect.x = series.columnWidthInPixel ? series.chart.isTransposed ? this.rect.x : this.rect.x -\n                (((series.columnWidthInPixel / 2) * series.rectCount) - (series.columnWidthInPixel * series.position)) : this.rect.x;\n            var argsData = this.triggerEvent(series, point, series.interior, { width: series.visible ?\n                    series.border.width : 0, color: series.visible ? series.border.color : '' });\n            if (!argsData.cancel) {\n                this.drawRectangle(series, point, this.rect, argsData);\n                this.updateSymbolLocation(point, this.rect, series);\n                if (series.columnFacet === 'Cylinder') {\n                    var cylinderSeriesOption = {\n                        'isColumn': true,\n                        'stacking': series.type === 'StackingColumn100',\n                        'isLastSeries': true\n                    };\n                    this.drawCylinder(this.options, this.element, cylinderSeriesOption, this.rect, series);\n                }\n            }\n        }\n    };\n    StackingColumnSeries.prototype.updateDirection = function (series, point) {\n        var seriesCollection = [];\n        for (var i = 0; i < series.xAxis.series.length; i++) {\n            var stackSeries = series.xAxis.series[i];\n            if (stackSeries.stackingGroup === series.stackingGroup) {\n                seriesCollection.push(stackSeries);\n            }\n        }\n        for (var j = 0; j < seriesCollection.length; j++) {\n            var visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getVisiblePoints)(seriesCollection[j]);\n            for (var i = 0; i < point.length; i++) {\n                this.renderPoint(seriesCollection[j], seriesCollection[j].points[point[i]], this.sideBySideInfo[series.index], seriesCollection[j].stackedValues, visiblePoints);\n                if (series.marker && series.marker.visible) {\n                    seriesCollection[j].chart.markerRender.renderMarker(seriesCollection[j], seriesCollection[j].points[point[i]], seriesCollection[j].points[point[i]].symbolLocations[0], null, true);\n                }\n                if (seriesCollection[j].marker.dataLabel.visible && seriesCollection[j].chart.dataLabelModule) {\n                    seriesCollection[j].chart.dataLabelModule.commonId = seriesCollection[j].chart.element.id + '_Series_' + seriesCollection[j].index + '_Point_';\n                    seriesCollection[j].chart.dataLabelModule.renderDataLabel(seriesCollection[j], seriesCollection[j].points[point[i]], null, seriesCollection[j].marker.dataLabel);\n                }\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    StackingColumnSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * To destroy the stacking column.\n     *\n     * @returns {void}\n     * @private\n     */\n    StackingColumnSeries.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    StackingColumnSeries.prototype.getModuleName = function () {\n        return 'StackingColumnSeries';\n    };\n    return StackingColumnSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_1__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-column-series.js?");

/***/ })

}]);