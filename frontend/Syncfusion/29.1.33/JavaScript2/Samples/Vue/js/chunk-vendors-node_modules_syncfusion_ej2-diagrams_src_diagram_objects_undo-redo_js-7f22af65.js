"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_objects_undo-redo_js-7f22af65"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/undo-redo.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/undo-redo.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UndoRedo: () => (/* binding */ UndoRedo)\n/* harmony export */ });\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/index.js\");\n/* harmony import */ var _utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utility/swim-lane-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Undo redo function used for revert and restore the changes\n */\nvar UndoRedo = /** @class */ (function () {\n    /**\n     * Constructor for the undo redo module\n     *\n     * @private\n     */\n    function UndoRedo() {\n        this.groupUndo = false;\n        this.childTable = [];\n        this.historyCount = 0;\n        this.hasGroup = false;\n        this.groupCount = 0;\n        this.undoOffsets = [];\n        this.checkRedo = false;\n        //constructs the undo redo module\n    }\n    /**\n     * initHistory method \\\n     *\n     * @returns { void } initHistory method .\\\n     * @param {Diagram} diagram - provide the points value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.initHistory = function (diagram) {\n        diagram.historyManager = {\n            canRedo: false, canUndo: false, currentEntry: null,\n            push: diagram.addHistoryEntry.bind(diagram), undo: Function, redo: Function,\n            startGroupAction: diagram.startGroupAction.bind(diagram), endGroupAction: diagram.endGroupAction.bind(diagram),\n            canLog: null, undoStack: [], redoStack: [], stackLimit: diagram.historyManager ? diagram.historyManager.stackLimit : undefined\n        };\n    };\n    /**\n     * addHistoryEntry method \\\n     *\n     * @returns { void } addHistoryEntry method .\\\n     * @param {HistoryEntry} entry - provide the points value.\n     * @param {Diagram} diagram - provide the points value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.addHistoryEntry = function (entry, diagram) {\n        // Bug: 903791-remove StartGroup & EndGroup entry when no actual changes wrapped between them.\n        if (entry.type === 'EndGroup' && diagram.historyManager.currentEntry.type === 'StartGroup') {\n            if (diagram.historyManager.currentEntry.previous) {\n                diagram.historyManager.currentEntry.previous.next = undefined;\n            }\n            diagram.historyManager.currentEntry = diagram.historyManager.currentEntry.previous;\n            // when cancelled change startGroup is only entry in history manager\n            if (!diagram.historyManager.currentEntry) {\n                diagram.historyManager.canUndo = false;\n            }\n            return false;\n        }\n        var entryObject = null;\n        var nextEntry = null;\n        if (diagram.historyManager.canLog) {\n            var hEntry = diagram.historyManager.canLog(entry);\n            if (hEntry.cancel === true) {\n                return false;\n            }\n        }\n        if (diagram.historyManager && diagram.historyManager.canUndo && diagram.historyManager.currentEntry) {\n            entryObject = diagram.historyManager.currentEntry;\n            if (entryObject.next) {\n                if (entryObject.previous) {\n                    nextEntry = entryObject.next;\n                    nextEntry.previous = null;\n                    entryObject.next = entry;\n                    entry.previous = entryObject;\n                }\n            }\n            else {\n                entryObject.next = entry;\n                entry.previous = entryObject;\n            }\n        }\n        diagram.historyManager.currentEntry = entry;\n        if (diagram.historyManager.stackLimit) {\n            if (entry.type === 'StartGroup' || entry.type === 'EndGroup') {\n                var value = entry.type === 'EndGroup' ? true : false;\n                this.setEntryLimit(value);\n            }\n            if (!this.hasGroup && this.groupCount === 0) {\n                if (this.historyCount < diagram.historyManager.stackLimit) {\n                    this.historyCount++;\n                }\n                else {\n                    this.applyLimit(diagram.historyManager.currentEntry, diagram.historyManager.stackLimit, diagram);\n                }\n            }\n        }\n        this.getHistoryList(diagram);\n        diagram.historyManager.canUndo = true;\n        diagram.historyManager.canRedo = false;\n        return true;\n    };\n    /**\n     * applyLimit method \\\n     *\n     * @returns { void } applyLimit method .\\\n     * @param {HistoryEntry} list - provide the list value.\n     * @param {number} stackLimit - provide the list value.\n     * @param {Diagram} diagram - provide the list value.\n     * @param {boolean} limitHistory - provide the list value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.applyLimit = function (list, stackLimit, diagram, limitHistory) {\n        if (list && list.previous) {\n            if (list.type === 'StartGroup' || list.type === 'EndGroup') {\n                var value = list.type === 'StartGroup' ? true : false;\n                this.setEntryLimit(value);\n            }\n            if (!this.hasGroup && this.groupCount === 0) {\n                stackLimit--;\n            }\n            if (stackLimit === 0) {\n                if (limitHistory) {\n                    this.limitHistoryStack(list.previous, diagram);\n                }\n                if (diagram.historyManager.stackLimit < this.historyCount) {\n                    this.historyCount = diagram.historyManager.stackLimit;\n                }\n                delete list.previous;\n            }\n            else if (list.previous) {\n                this.applyLimit(list.previous, stackLimit, diagram, limitHistory);\n            }\n        }\n        this.groupCount = 0;\n    };\n    /**\n     * clearHistory method \\\n     *\n     * @returns { void } clearHistory method .\\\n     * @param {Diagram} diagram - provide the points value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.clearHistory = function (diagram) {\n        var hList = diagram.historyManager;\n        hList.currentEntry = undefined;\n        hList.canUndo = false;\n        hList.canRedo = false;\n        this.historyCount = 0;\n        this.groupCount = 0;\n        diagram.historyManager.undoStack = [];\n        diagram.historyManager.redoStack = [];\n    };\n    UndoRedo.prototype.setEntryLimit = function (value) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        value ? this.groupCount-- : this.groupCount++;\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        value ? this.hasGroup = !value : this.hasGroup = value;\n    };\n    UndoRedo.prototype.limitHistoryStack = function (list, diagram) {\n        if (list.type !== 'StartGroup' && list.type !== 'EndGroup') {\n            this.removeFromStack(diagram.historyManager.undoStack, list);\n            this.removeFromStack(diagram.historyManager.redoStack, list);\n        }\n        if (list.previous) {\n            this.limitHistoryStack(list.previous, diagram);\n        }\n    };\n    UndoRedo.prototype.removeFromStack = function (entyList, list) {\n        if (entyList.length) {\n            for (var i = 0; i <= entyList.length; i++) {\n                if (entyList[parseInt(i.toString(), 10)].undoObject === list.undoObject\n                    && entyList[parseInt(i.toString(), 10)].redoObject === list.redoObject) {\n                    entyList.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * undo method \\\n     *\n     * @returns { void } undo method .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.undo = function (diagram) {\n        var entry = this.getUndoEntry(diagram);\n        var endGroupActionCount = 0;\n        if (entry) {\n            if (entry.category === 'Internal') {\n                if (entry.type === 'EndGroup') {\n                    endGroupActionCount++;\n                    this.groupUndo = true;\n                    //Removed isBlazor code\n                }\n                else {\n                    this.undoEntry(entry, diagram);\n                }\n                if (this.groupUndo) {\n                    this.undoGroupAction(entry, diagram, endGroupActionCount);\n                    this.groupUndo = false;\n                }\n            }\n            else {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_7__.isBlazor)()) {\n                    diagram.historyManager.undo(entry);\n                }\n                var arg = {\n                    entryType: 'undo', oldValue: entry.undoObject, newValue: entry.redoObject\n                };\n                // Removed isBlazor code\n                diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramEvent.historyStateChange, arg);\n            }\n        }\n    };\n    // Removed getHistoryChangeEvent method as it is not used anywhere\n    UndoRedo.prototype.getHistoryList = function (diagram) {\n        var undoStack = [];\n        var redoStack = [];\n        var currEntry = diagram.historyManager.currentEntry;\n        var undoObj;\n        var redoObj;\n        currEntry = diagram.historyManager.currentEntry;\n        if (diagram.historyManager.canUndo || diagram.historyManager.undoStack.length === 0) {\n            this.getHistroyObject(undoStack, currEntry);\n        }\n        else {\n            this.getHistroyObject(redoStack, currEntry);\n        }\n        while (currEntry && currEntry.previous) {\n            undoObj = currEntry.previous;\n            this.getHistroyObject(undoStack, undoObj);\n            currEntry = currEntry.previous;\n        }\n        currEntry = diagram.historyManager.currentEntry;\n        while (currEntry && currEntry.next) {\n            redoObj = currEntry.next;\n            this.getHistroyObject(redoStack, redoObj);\n            currEntry = currEntry.next;\n        }\n        diagram.historyManager.undoStack = undoStack;\n        diagram.historyManager.redoStack = redoStack;\n    };\n    UndoRedo.prototype.getHistroyObject = function (list, obj) {\n        if (obj && obj.type !== 'StartGroup' && obj.type !== 'EndGroup') {\n            list.push({\n                redoObject: obj.redoObject ? obj.redoObject : null,\n                undoObject: obj.undoObject ? obj.undoObject : null,\n                type: obj.type ? obj.type : null,\n                category: obj.category ? obj.category : null\n            });\n        }\n    };\n    UndoRedo.prototype.undoGroupAction = function (entry, diagram, endGroupActionCount) {\n        while (endGroupActionCount !== 0) {\n            this.undoEntry(entry, diagram);\n            entry = this.getUndoEntry(diagram);\n            if (entry.type === 'StartGroup') {\n                endGroupActionCount--;\n            }\n            else if (entry.type === 'EndGroup') {\n                endGroupActionCount++;\n            }\n        }\n        endGroupActionCount = 0;\n    };\n    UndoRedo.prototype.undoEntry = function (entry, diagram) {\n        var obj;\n        var nodeObject;\n        if (entry.type !== 'PropertyChanged' && entry.type !== 'CollectionChanged' && entry.type !== 'LabelCollectionChanged') {\n            obj = entry.undoObject ? entry.undoObject : (entry.previous.undoObject);\n            nodeObject = obj;\n        }\n        if (entry.type !== 'StartGroup' && entry.type !== 'EndGroup') {\n            if (diagram.historyManager.undoStack.length > 0) {\n                var addObject = diagram.historyManager.undoStack.splice(0, 1);\n                diagram.historyManager.redoStack.splice(0, 0, addObject[0]);\n                nodeObject = (entry.undoObject);\n            }\n        }\n        diagram.protectPropertyChange(true);\n        diagram.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n        //Removed isBlazor code\n        switch (entry.type) {\n            case 'PositionChanged':\n            case 'Align':\n            case 'Distribute':\n                this.recordPositionChanged(obj, diagram);\n                break;\n            case 'SizeChanged':\n            case 'Sizing':\n                this.recordSizeChanged(obj, diagram, entry);\n                break;\n            case 'RotationChanged':\n                this.recordRotationChanged(obj, diagram, entry, 'undo');\n                break;\n            case 'ConnectionChanged':\n                this.recordConnectionChanged(obj, diagram);\n                break;\n            case 'PropertyChanged':\n                this.recordPropertyChanged(entry, diagram, false);\n                break;\n            case 'CollectionChanged':\n                if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {\n                    var group = diagram.getObject(entry.next.undoObject.id);\n                    diagram.insertValue((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(group), true);\n                }\n                entry.isUndo = true;\n                this.recordCollectionChanged(entry, diagram);\n                entry.isUndo = false;\n                if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {\n                    var group = diagram.getObject(entry.next.undoObject.id);\n                    group.wrapper.measure(new _index__WEBPACK_IMPORTED_MODULE_5__.Size());\n                    group.wrapper.arrange(group.wrapper.desiredSize);\n                    diagram.updateDiagramObject(group);\n                }\n                break;\n            case 'LabelCollectionChanged':\n                entry.isUndo = true;\n                this.recordLabelCollectionChanged(entry, diagram);\n                entry.isUndo = false;\n                break;\n            case 'PortCollectionChanged':\n                entry.isUndo = true;\n                this.recordPortCollectionChanged(entry, diagram);\n                entry.isUndo = false;\n                break;\n            case 'Group':\n                this.unGroup(entry, diagram);\n                break;\n            case 'UnGroup':\n                this.group(entry, diagram);\n                break;\n            case 'SegmentChanged':\n                this.recordSegmentChanged(obj, diagram);\n                break;\n            case 'PortPositionChanged':\n                this.recordPortChanged(entry, diagram, false);\n                break;\n            case 'AnnotationPropertyChanged':\n                this.recordAnnotationChanged(entry, diagram, false);\n                break;\n            case 'ChildCollectionChanged':\n                this.recordChildCollectionChanged(entry, diagram, false);\n                break;\n            case 'StackChildPositionChanged':\n                this.recordStackPositionChanged(entry, diagram, false);\n                break;\n            case 'RowHeightChanged':\n                this.recordGridSizeChanged(entry, diagram, false, true);\n                break;\n            case 'ColumnWidthChanged':\n                this.recordGridSizeChanged(entry, diagram, false, false);\n                break;\n            case 'LanePositionChanged':\n                this.recordLanePositionChanged(entry, diagram, false);\n                break;\n            case 'LaneCollectionChanged':\n            case 'PhaseCollectionChanged':\n                entry.isUndo = true;\n                this.recordLaneOrPhaseCollectionChanged(entry, diagram, false);\n                entry.isUndo = false;\n                break;\n            case 'SendToBack':\n            case 'SendForward':\n            case 'SendBackward':\n            case 'BringToFront':\n                this.recordOrderCommandChanged(entry, diagram, false);\n                break;\n            case 'AddChildToGroupNode':\n                this.recordAddChildToGroupNode(entry, diagram, false);\n                break;\n            case 'RemoveChildFromGroupNode':\n                this.recordRemoveChildFromGroupNode(entry, diagram, false);\n                break;\n            case 'ExternalEntry':\n                //EJ2-848643 - Need to consider custom entries in start and end group action\n                diagram.historyManager.undo(entry);\n                break;\n        }\n        diagram.diagramActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n        diagram.protectPropertyChange(false);\n        diagram.historyChangeTrigger(entry, 'Undo');\n        if (nodeObject) {\n            var object = this.checkNodeObject(nodeObject, diagram);\n            if (object) {\n                var getnodeDefaults = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.getFunction)(diagram.updateSelection);\n                if (getnodeDefaults) {\n                    getnodeDefaults(object, diagram);\n                }\n            }\n        }\n    };\n    UndoRedo.prototype.checkNodeObject = function (value, diagram) {\n        var object;\n        if (!value.id) {\n            if ((value.nodes && value.nodes.length > 0) ||\n                (value.connectors && value.connectors.length > 0)) {\n                var undoNode = value.nodes.length > 0 ?\n                    value.nodes : value.connectors;\n                for (var _i = 0, undoNode_1 = undoNode; _i < undoNode_1.length; _i++) {\n                    object = undoNode_1[_i];\n                    object = diagram.nameTable[object.id];\n                }\n            }\n            else {\n                var knownNode = value.nodes ?\n                    value.nodes : value.connectors;\n                if (knownNode) {\n                    for (var _a = 0, _b = Object.keys(knownNode); _a < _b.length; _a++) {\n                        var key = _b[_a];\n                        var index = Number(key);\n                        object = value.nodes ? diagram.nodes[parseInt(index.toString(), 10)]\n                            : diagram.connectors[parseInt(index.toString(), 10)];\n                    }\n                }\n            }\n        }\n        else {\n            object = diagram.nameTable[value.id];\n        }\n        return object;\n    };\n    UndoRedo.prototype.group = function (historyEntry, diagram) {\n        diagram.add(historyEntry.undoObject);\n    };\n    UndoRedo.prototype.unGroup = function (entry, diagram) {\n        //const i: number = 0;\n        entry.redoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(entry.undoObject);\n        var node = entry.undoObject;\n        diagram.commandHandler.unGroup(node);\n    };\n    UndoRedo.prototype.ignoreProperty = function (key) {\n        if (key === 'zIndex' || key === 'wrapper' || key === 'parentObj' || key === 'controlParent') {\n            return true;\n        }\n        return false;\n    };\n    UndoRedo.prototype.getProperty = function (collection, property) {\n        for (var _i = 0, _a = Object.keys(property); _i < _a.length; _i++) {\n            var key = _a[_i];\n            if (collection) {\n                if (!this.ignoreProperty(key)) {\n                    if (property[\"\" + key] instanceof Object) {\n                        this.getProperty(collection[\"\" + key], property[\"\" + key]);\n                    }\n                    else {\n                        collection[\"\" + key] = property[\"\" + key];\n                    }\n                }\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UndoRedo.prototype.recordLaneOrPhaseCollectionChanged = function (entry, diagram, isRedo) {\n        var node = entry.redoObject;\n        var obj = entry.undoObject;\n        var changeType;\n        if (entry.isUndo) {\n            if (entry.changeType === 'Insert') {\n                changeType = 'Remove';\n            }\n            else {\n                changeType = 'Insert';\n            }\n        }\n        else {\n            changeType = entry.changeType;\n        }\n        if (changeType === 'Remove') {\n            diagram.remove(node);\n        }\n        else {\n            if (node.isPhase) {\n                var swimlane = diagram.nameTable[node.parentId];\n                diagram.addPhases(swimlane, [obj]);\n            }\n            else {\n                var swimlane = diagram.nameTable[node.parentId];\n                var laneIndex = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_6__.findLaneIndex)(swimlane, node);\n                diagram.addLanes(swimlane, [obj], laneIndex);\n            }\n        }\n        diagram.clearSelection();\n    };\n    UndoRedo.prototype.recordAnnotationChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        if (diagram.canEnableBlazorObject) {\n            var node = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(diagram.nameTable[entryObject.id]);\n            diagram.insertValue(node, node instanceof _node__WEBPACK_IMPORTED_MODULE_0__.Node ? true : false);\n        }\n        var oldElement = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.findAnnotation)(entryObject, entry.objectId);\n        var undoChanges = diagram.commandHandler.getAnnotationChanges(diagram.nameTable[entryObject.id], oldElement);\n        var currentObject = diagram.nameTable[entryObject.id];\n        var currentElement = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.findAnnotation)(currentObject, entry.objectId);\n        currentElement.offset = oldElement.offset;\n        currentElement.margin = oldElement.margin;\n        currentElement.width = oldElement.width;\n        currentElement.height = oldElement.height;\n        currentElement.rotateAngle = oldElement.rotateAngle;\n        currentElement.margin = oldElement.margin;\n        if (currentObject instanceof _node__WEBPACK_IMPORTED_MODULE_0__.Node) {\n            diagram.nodePropertyChange(currentObject, {}, undoChanges);\n        }\n        else {\n            diagram.connectorPropertyChange(currentObject, {}, undoChanges);\n        }\n    };\n    UndoRedo.prototype.recordChildCollectionChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        var parentNode = diagram.nameTable[entryObject.parentId];\n        var actualObject = diagram.nameTable[entryObject.id];\n        if (parentNode) {\n            (0,_index__WEBPACK_IMPORTED_MODULE_5__.addChildToContainer)(diagram, parentNode, actualObject, !isRedo, entry.historyAction === 'AddNodeToLane', isRedo);\n        }\n        else {\n            if (actualObject.parentId) {\n                parentNode = diagram.nameTable[actualObject.parentId];\n                if (parentNode) {\n                    //929543: To remove the child node from lane children collection.\n                    this.removeChildFromLane(diagram, parentNode, actualObject);\n                    parentNode.children.splice(parentNode.children.indexOf(actualObject.id), 1);\n                    parentNode.wrapper.children.splice(parentNode.wrapper.children.indexOf(actualObject.wrapper), 1);\n                }\n            }\n            if (entryObject.parentId && entryObject.parentId !== '') {\n                parentNode = diagram.nameTable[entryObject.parentId];\n                parentNode.children.push(entryObject.id);\n                parentNode.wrapper.children.push(actualObject.wrapper);\n            }\n            actualObject.parentId = entryObject.parentId;\n            diagram.removeElements(actualObject);\n            diagram.updateDiagramObject(actualObject);\n        }\n    };\n    /**\n     * removeChildFromLane method \\\n     *\n     * @returns { void } undo method .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     * @param {NodeModel} parentNode - provide the lane obj.\n     * @param {Node} actualObject - provide the node value.\n     * @private\n     */\n    UndoRedo.prototype.removeChildFromLane = function (diagram, parentNode, actualObject) {\n        var swimlane = diagram.nameTable[parentNode.parentId];\n        if (swimlane && swimlane.shape && swimlane.shape.lanes.length > 0) {\n            var isHorizontal = swimlane.shape.orientation === 'Horizontal';\n            var hasPhases = (swimlane.shape.phases.length > 0) && (swimlane.shape.phaseSize > 0);\n            var phaseIndex = 0;\n            if (!hasPhases) {\n                phaseIndex = 1;\n            }\n            var index = isHorizontal\n                ? (swimlane.shape.hasHeader ? (parentNode.rowIndex - (2 - phaseIndex))\n                    : (parentNode.rowIndex - (1 - phaseIndex)))\n                : parentNode.columnIndex - (1 - phaseIndex);\n            var lane = swimlane.shape.lanes[parseInt(index.toString(), 10)];\n            if (lane && lane.children && lane.children.length > 0) {\n                for (var i = lane.children.length - 1; i >= 0; i--) {\n                    if (lane.children[parseInt(i.toString(), 10)].id === actualObject.id) {\n                        lane.children.splice(i, 1);\n                    }\n                }\n            }\n        }\n    };\n    UndoRedo.prototype.recordStackPositionChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        if (entryObject.source) {\n            var parent_1 = diagram.nameTable[entryObject.source.parentId];\n            if (parent_1) {\n                if (entryObject.target) {\n                    parent_1.wrapper.children.splice(entryObject.targetIndex, 1);\n                    parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, entryObject.source.wrapper);\n                }\n                else {\n                    if (entryObject.sourceIndex !== undefined) {\n                        if (!diagram.nameTable[entryObject.source.id]) {\n                            diagram.add(entryObject.source);\n                        }\n                        parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, diagram.nameTable[entryObject.source.id].wrapper);\n                        diagram.nameTable[entryObject.source.id].parentId = parent_1.id;\n                    }\n                    else {\n                        parent_1.wrapper.children.splice(parent_1.wrapper.children.indexOf(diagram.nameTable[entryObject.source.id].wrapper), 1);\n                        diagram.nameTable[entryObject.source.id].parentId = '';\n                    }\n                }\n                if (isRedo && parent_1.shape.type === 'UmlClassifier') {\n                    diagram.remove(entryObject.source);\n                }\n                parent_1.wrapper.measure(new _index__WEBPACK_IMPORTED_MODULE_5__.Size());\n                parent_1.wrapper.arrange(parent_1.wrapper.desiredSize);\n                diagram.updateDiagramObject(parent_1);\n                diagram.updateSelector();\n            }\n        }\n    };\n    UndoRedo.prototype.recordGridSizeChanged = function (entry, diagram, isRedo, isRow) {\n        var obj = (isRedo) ? entry.redoObject : entry.undoObject;\n        var node = (!isRedo) ? entry.redoObject : entry.undoObject;\n        if (obj.parentId) {\n            var swimlane = diagram.nameTable[obj.parentId];\n            var actualObject = diagram.nameTable[obj.id];\n            var x = swimlane.wrapper.bounds.x;\n            var y = swimlane.wrapper.bounds.y;\n            if (swimlane.shape.type === 'SwimLane') {\n                var grid = swimlane.wrapper.children[0];\n                var padding = swimlane.shape.padding;\n                var isUndoRedo = false;\n                if (diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo) {\n                    isUndoRedo = true;\n                }\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_6__.updateSwimLaneObject)(diagram, node, swimlane, obj);\n                if (isRow) {\n                    grid.updateRowHeight(obj.rowIndex, obj.wrapper.actualSize.height, true, padding, isUndoRedo);\n                    swimlane.height = swimlane.wrapper.height = grid.height;\n                }\n                else {\n                    grid.updateColumnWidth(obj.columnIndex, obj.wrapper.actualSize.width, true, padding, isUndoRedo);\n                    swimlane.width = swimlane.wrapper.width = grid.width;\n                    if (obj.isPhase) {\n                        actualObject.maxWidth = actualObject.wrapper.maxWidth = obj.wrapper.actualSize.width;\n                    }\n                }\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_6__.swimLaneMeasureAndArrange)(swimlane);\n                var tx = x - swimlane.wrapper.bounds.x;\n                var ty = y - swimlane.wrapper.bounds.y;\n                diagram.drag(swimlane, tx, ty);\n                diagram.clearSelection();\n                diagram.updateDiagramObject(swimlane);\n            }\n        }\n    };\n    UndoRedo.prototype.recordLanePositionChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        if (entryObject.source) {\n            var parent_2 = diagram.nameTable[entryObject.source.parentId];\n            if (parent_2 && parent_2.shape.type === 'SwimLane') {\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_6__.laneInterChanged)(diagram, entryObject.target, entryObject.source);\n                diagram.clearSelection();\n            }\n        }\n    };\n    UndoRedo.prototype.recordPortChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject.nodes[0] :\n            entry.undoObject.nodes[0]);\n        if (diagram.canEnableBlazorObject) {\n            var node = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(diagram.nameTable[entryObject.id]);\n            diagram.insertValue(node, true);\n        }\n        var oldElement = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.findPort)(entryObject, entry.objectId);\n        var undoChanges = diagram.commandHandler.getPortChanges(diagram.nameTable[entryObject.id], oldElement);\n        var currentObject = diagram.nameTable[entryObject.id];\n        var currentElement = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.findPort)(currentObject, entry.objectId);\n        currentElement.offset = oldElement.offset;\n        diagram.nodePropertyChange(currentObject, {}, undoChanges);\n        if (currentObject.parentId) {\n            diagram.updateConnectorEdges(diagram.nameTable[currentObject.parentId]);\n        }\n    };\n    UndoRedo.prototype.recordPropertyChanged = function (entry, diagram, isRedo) {\n        var redoObject = entry.redoObject;\n        var undoObject = entry.undoObject;\n        //Removed isBlazor code\n        this.getProperty(diagram, (isRedo ? redoObject : undoObject));\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        isRedo ? diagram.onPropertyChanged(redoObject, undoObject) : diagram.onPropertyChanged(undoObject, redoObject);\n        diagram.diagramActions = diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n    };\n    UndoRedo.prototype.recordOrderCommandChanged = function (entry, diagram, isRedo) {\n        var redoObject = entry.redoObject;\n        var undoObject = entry.undoObject;\n        diagram.commandHandler.orderCommands(isRedo, (isRedo ? redoObject : undoObject), entry.type);\n        diagram.diagramActions = diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n    };\n    UndoRedo.prototype.recordAddChildToGroupNode = function (entry, diagram, isRedo) {\n        var group = diagram.nameTable[entry.undoObject.id];\n        var child = diagram.nameTable[entry.objectId];\n        if (isRedo && entry.changeType === 'Insert') {\n            diagram.addChildToGroup(group, child.id);\n        }\n        else {\n            diagram.removeChildFromGroup(group, child.id);\n        }\n    };\n    UndoRedo.prototype.recordRemoveChildFromGroupNode = function (entry, diagram, isRedo) {\n        var group = diagram.nameTable[entry.undoObject.id];\n        var child = diagram.nameTable[entry.objectId];\n        if (isRedo && entry.changeType === 'Remove') {\n            diagram.removeChildFromGroup(group, child.id);\n        }\n        else {\n            diagram.addChildToGroup(group, child.id);\n        }\n    };\n    UndoRedo.prototype.recordSegmentChanged = function (obj, diagram) {\n        var i = 0;\n        //let node: NodeModel;\n        var connector;\n        if (obj.connectors && obj.connectors.length > 0) {\n            for (i = 0; i < obj.connectors.length; i++) {\n                connector = obj.connectors[parseInt(i.toString(), 10)];\n                this.segmentChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.segmentChanged = function (connector, diagram) {\n        var conn = diagram.nameTable[connector.id];\n        conn.segments = connector.segments;\n        diagram.commandHandler.updateEndPoint(conn);\n    };\n    UndoRedo.prototype.recordPositionChanged = function (obj, diagram) {\n        var i = 0;\n        var node;\n        var connector;\n        if (obj.nodes && obj.nodes.length > 0) {\n            for (i = 0; i < obj.nodes.length; i++) {\n                if (diagram.bpmnModule) {\n                    diagram.isPositionUndo = true;\n                }\n                node = obj.nodes[parseInt(i.toString(), 10)];\n                this.positionChanged(node, diagram);\n            }\n            diagram.isPositionUndo = false;\n        }\n        if (obj.connectors && obj.connectors.length > 0) {\n            for (i = 0; i < obj.connectors.length; i++) {\n                connector = obj.connectors[parseInt(i.toString(), 10)];\n                // 927019: Undo/Redo Does Not Restore Connector Segment Changes\n                this.segmentChanged(connector, diagram);\n                this.connectionChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.positionChanged = function (obj, diagram) {\n        var node = diagram.nameTable[obj.id];\n        if (obj.processId && !node.processId) {\n            diagram.addProcess(obj, obj.processId);\n        }\n        if (!obj.processId && node.processId) {\n            diagram.removeProcess(obj.id);\n        }\n        if (node.processId) {\n            var tx = obj.margin.left - node.margin.left;\n            var ty = obj.margin.top - node.margin.top;\n            diagram.drag(node, tx, ty);\n        }\n        else {\n            if (node.parentId) {\n                var parent_3 = diagram.nameTable[node.parentId];\n                if (parent_3.isLane) {\n                    obj.wrapper.offsetX = (obj.width / 2) + (parent_3.wrapper.bounds.x + obj.margin.left);\n                    obj.wrapper.offsetY = (obj.height / 2) + (parent_3.wrapper.bounds.y + obj.margin.top);\n                }\n            }\n            var tx = obj.wrapper.offsetX - node.offsetX;\n            var ty = obj.wrapper.offsetY - node.offsetY;\n            diagram.drag(node, tx, ty);\n        }\n        if (diagram.bpmnModule) {\n            diagram.bpmnModule.updateDocks(node, diagram);\n        }\n    };\n    UndoRedo.prototype.recordSizeChanged = function (obj, diagram, entry) {\n        var i = 0;\n        var connector;\n        var node;\n        if (obj && obj.nodes && obj.nodes.length > 0) {\n            for (i = 0; i < obj.nodes.length; i++) {\n                node = obj.nodes[parseInt(i.toString(), 10)];\n                if (node.children && !node.container) {\n                    var elements = [];\n                    var nodes = diagram.commandHandler.getAllDescendants(node, elements);\n                    for (var i_1 = 0; i_1 < nodes.length; i_1++) {\n                        var tempNode = entry.childTable[nodes[parseInt(i_1.toString(), 10)].id];\n                        if (((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.getObjectType)(tempNode) === _node__WEBPACK_IMPORTED_MODULE_0__.Node)) {\n                            this.sizeChanged(tempNode, diagram, entry);\n                            this.positionChanged(tempNode, diagram);\n                        }\n                        else {\n                            this.connectionChanged(tempNode, diagram, entry);\n                        }\n                    }\n                }\n                else {\n                    if (diagram.bpmnModule) {\n                        diagram.sizeUndo = true;\n                    }\n                    this.sizeChanged(node, diagram);\n                    this.positionChanged(node, diagram);\n                    if (diagram.bpmnModule) {\n                        diagram.sizeUndo = false;\n                    }\n                }\n            }\n        }\n        if (obj && obj.connectors && obj.connectors.length > 0) {\n            var connectors = obj.connectors;\n            for (i = 0; i < connectors.length; i++) {\n                connector = connectors[parseInt(i.toString(), 10)];\n                this.connectionChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.sizeChanged = function (obj, diagram, entry) {\n        var node = diagram.nameTable[obj.id];\n        var scaleWidth = obj.wrapper.actualSize.width / node.wrapper.actualSize.width;\n        var scaleHeight = obj.wrapper.actualSize.height / node.wrapper.actualSize.height;\n        if (entry && entry.childTable) {\n            entry.childTable[obj.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(node);\n        }\n        diagram.scale(node, scaleWidth, scaleHeight, {\n            x: obj.wrapper.offsetX / node.wrapper.offsetX,\n            y: obj.wrapper.offsetY / node.wrapper.offsetY\n        });\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UndoRedo.prototype.recordRotationChanged = function (obj, diagram, entry, type) {\n        var i = 0;\n        var node;\n        var connector;\n        var selectorObj = diagram.selectedItems;\n        selectorObj.rotateAngle = obj.rotateAngle;\n        if (selectorObj && selectorObj.wrapper) {\n            selectorObj.wrapper.rotateAngle = obj.rotateAngle;\n        }\n        diagram.fromUndo = true;\n        if (obj && obj.nodes && obj.nodes.length > 0) {\n            for (i = 0; i < obj.nodes.length; i++) {\n                node = obj.nodes[parseInt(i.toString(), 10)];\n                // Bug 832864: Undo redo not working properly for group node with connectors.\n                // This code is executed only for group nodes with connectors when the connector is not connected to a node either as a source or target.\n                var isConnect = false;\n                if (node.children && node.children.length > 0) {\n                    for (var j = 0; j < node.children.length; j++) {\n                        var child = diagram.nameTable[node.children[parseInt(j.toString(), 10)]];\n                        if (!((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.getObjectType)(child) === _node__WEBPACK_IMPORTED_MODULE_0__.Node)) {\n                            if (child.sourceID === '' || child.targetID === '') {\n                                isConnect = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (isConnect && Object.keys(entry.childTable).length > 0) {\n                        var elements = [];\n                        var nodes = diagram.commandHandler.getAllDescendants(node, elements);\n                        for (var i2 = 0; i2 < nodes.length; i2++) {\n                            var tempNode = entry.childTable[nodes[parseInt(i2.toString(), 10)].id];\n                            if (((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.getObjectType)(tempNode) === _node__WEBPACK_IMPORTED_MODULE_0__.Node)) {\n                                var object = { id: '', rotateAngle: 0, wrapper: { offsetX: 0, offsetY: 0 } };\n                                if (type === 'redo') {\n                                    object.id = tempNode.id;\n                                    object.rotateAngle = node.rotateAngle;\n                                }\n                                else {\n                                    object = tempNode;\n                                }\n                                this.rotationChanged(object, diagram);\n                                if (type === 'undo') {\n                                    var offNode = diagram.nameTable[object.id];\n                                    this.undoOffsets.push({ id: offNode.id, offsetX: offNode.offsetX, offsetY: offNode.offsetY });\n                                }\n                                else {\n                                    var lastIndex = -1;\n                                    for (var i_2 = this.undoOffsets.length - 1; i_2 >= 0; i_2--) {\n                                        if (this.undoOffsets[parseInt(i_2.toString(), 10)].id === object.id) {\n                                            object.wrapper = this.undoOffsets[parseInt(i_2.toString(), 10)];\n                                            lastIndex = i_2;\n                                            break;\n                                        }\n                                    }\n                                    if (lastIndex !== -1) {\n                                        this.undoOffsets.splice(lastIndex, 1);\n                                    }\n                                }\n                                this.positionChanged(object, diagram);\n                            }\n                            else {\n                                this.connectionChanged(tempNode, diagram, entry);\n                            }\n                        }\n                        var nd = diagram.nameTable[node.id];\n                        nd.rotateAngle = obj.rotateAngle;\n                        diagram.updateSelector();\n                        this.rotationChanged(node, diagram);\n                    }\n                    else {\n                        this.rotationChanged(node, diagram);\n                        this.positionChanged(node, diagram);\n                    }\n                }\n                else {\n                    this.rotationChanged(node, diagram);\n                    this.positionChanged(node, diagram);\n                }\n            }\n        }\n        diagram.fromUndo = false;\n        if (obj && obj.connectors && obj.connectors.length > 0) {\n            for (i = 0; i < obj.connectors.length; i++) {\n                connector = obj.connectors[parseInt(i.toString(), 10)];\n                this.connectionChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.rotationChanged = function (obj, diagram) {\n        var node = diagram.nameTable[obj.id];\n        diagram.rotate(node, obj.rotateAngle - node.rotateAngle);\n    };\n    UndoRedo.prototype.recordConnectionChanged = function (obj, diagram) {\n        var connector;\n        if (obj && obj.connectors) {\n            connector = obj.connectors[0];\n        }\n        else {\n            connector = obj;\n        }\n        if (connector.sourceID && diagram.nameTable[connector.sourceID]) {\n            diagram.insertValue(diagram.nameTable[connector.sourceID], true);\n        }\n        if (connector.targetID && diagram.nameTable[connector.targetID]) {\n            diagram.insertValue(diagram.nameTable[connector.targetID], true);\n        }\n        if (connector instanceof _connector__WEBPACK_IMPORTED_MODULE_1__.Connector || connector.shape.type === 'None' || connector.shape.type === 'Bpmn') {\n            this.connectionChanged(connector, diagram);\n        }\n    };\n    UndoRedo.prototype.connectionChanged = function (obj, diagram, entry) {\n        var connector = diagram.nameTable[obj.id];\n        var node;\n        if (obj.sourcePortID !== connector.sourcePortID) {\n            diagram.removePortEdges(diagram.nameTable[connector.sourceID], connector.sourcePortID, connector.id, false);\n            connector.sourcePortID = obj.sourcePortID;\n            diagram.connectorPropertyChange(connector, {}, { sourcePortID: obj.sourcePortID });\n        }\n        if (obj.targetPortID !== connector.targetPortID) {\n            diagram.removePortEdges(diagram.nameTable[connector.targetID], connector.targetPortID, connector.id, true);\n            connector.targetPortID = obj.targetPortID;\n            diagram.connectorPropertyChange(connector, {}, { targetPortID: obj.targetPortID });\n        }\n        if (obj.sourceID !== connector.sourceID) {\n            if (obj.sourceID === '') {\n                node = diagram.nameTable[connector.sourceID];\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.removeItem)(node.outEdges, obj.id);\n            }\n            else {\n                node = diagram.nameTable[obj.sourceID];\n                node.outEdges.push(obj.id);\n                diagram.updatePortEdges(node, obj, false);\n            }\n            connector.sourceID = obj.sourceID;\n            diagram.connectorPropertyChange(connector, {}, { sourceID: obj.sourceID });\n        }\n        if (obj.targetID !== connector.targetID) {\n            if (obj.targetID === '') {\n                node = diagram.nameTable[connector.targetID];\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.removeItem)(node.inEdges, obj.id);\n            }\n            else {\n                node = diagram.nameTable[obj.targetID];\n                node.inEdges.push(obj.id);\n                diagram.updatePortEdges(node, obj, true);\n            }\n            connector.targetID = obj.targetID;\n            diagram.connectorPropertyChange(connector, {}, { targetID: obj.targetID });\n        }\n        if (entry && entry.childTable) {\n            entry.childTable[obj.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.cloneObject)(connector);\n        }\n        var sx = obj.sourcePoint.x - connector.sourcePoint.x;\n        var sy = obj.sourcePoint.y - connector.sourcePoint.y;\n        if (sx !== 0 || sy !== 0) {\n            diagram.dragSourceEnd(connector, sx, sy);\n        }\n        var tx = obj.targetPoint.x - connector.targetPoint.x;\n        var ty = obj.targetPoint.y - connector.targetPoint.y;\n        if (tx !== 0 || ty !== 0) {\n            diagram.dragTargetEnd(connector, tx, ty);\n        }\n        diagram.updateSelector();\n        if (diagram.mode !== 'SVG') {\n            diagram.refreshDiagramLayer();\n        }\n    };\n    UndoRedo.prototype.recordCollectionChanged = function (entry, diagram) {\n        var obj = entry.undoObject;\n        if (entry && entry.changeType) {\n            var changeType = void 0;\n            if (entry.isUndo) {\n                if (entry.changeType === 'Insert') {\n                    changeType = 'Remove';\n                }\n                else {\n                    changeType = 'Insert';\n                }\n            }\n            else {\n                changeType = entry.changeType;\n            }\n            if (changeType === 'Remove') {\n                if (obj.nodeId) {\n                    diagram.remove(diagram.nameTable[obj.nodeId + '_textannotation_' + obj.id]);\n                }\n                else {\n                    diagram.remove(obj);\n                    if (obj.parentId) {\n                        var parentNode = diagram.nameTable[obj.parentId];\n                        if (parentNode) {\n                            this.removeChildFromLane(diagram, parentNode, obj);\n                        }\n                    }\n                    diagram.clearSelectorLayer();\n                }\n            }\n            else {\n                diagram.clearSelectorLayer();\n                if (obj.parentId) {\n                    var parentNode = diagram.nameTable[obj.parentId];\n                    if (parentNode) {\n                        diagram.addChild(parentNode, obj);\n                    }\n                    else {\n                        diagram.add(obj);\n                    }\n                }\n                else if (obj.nodeId) {\n                    diagram.addTextAnnotation(obj, diagram.nameTable[obj.nodeId]);\n                }\n                else {\n                    if (!diagram.nameTable[obj.id]) {\n                        if (obj && obj.shape && obj.shape.type === 'SwimLane' && entry.isUndo) {\n                            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_6__.pasteSwimLane)(obj, undefined, undefined, undefined, undefined, true);\n                        }\n                        //Bug 909155: Issue in connecting nodes with ports.\n                        // When we add child nodes at runtime and connect them with connector at runtime and perform undo redo, the connector is not visible after undo redo.\n                        //Added below code to update the zIndex of the connector to make it visible above the swimlane.\n                        this.updateConnectorZindex(obj, diagram);\n                        diagram.add(obj);\n                    }\n                }\n                if (obj.processId && diagram.nameTable[obj.processId]) {\n                    diagram.addProcess(obj, obj.processId);\n                }\n            }\n            if (diagram.mode !== 'SVG') {\n                diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * updateConnectorZindex method \\\n     *\n     * @returns { void }\n     * @param {NodeModel | ConnectorModel} obj - provide the diagram value.\n     * @param {Diagram} diagram - provide the diagram value.\n     * @private\n     */\n    UndoRedo.prototype.updateConnectorZindex = function (obj, diagram) {\n        if (obj.sourceID || obj.targetID) {\n            var sourceNode = diagram.nameTable[obj.sourceID];\n            var targetNode = diagram.nameTable[obj.targetID];\n            if (sourceNode && sourceNode.parentId) {\n                var sourceParent = diagram.nameTable[sourceNode.parentId];\n                if (sourceParent && sourceParent.isLane) {\n                    var parentSwimlane = diagram.nameTable[sourceParent.parentId];\n                    (0,_index__WEBPACK_IMPORTED_MODULE_5__.updateZindex)(obj, parentSwimlane, diagram);\n                }\n            }\n            else if (targetNode && targetNode.parentId) {\n                var targetParent = diagram.nameTable[targetNode.parentId];\n                if (targetParent && targetParent.isLane) {\n                    var parentSwimlane = diagram.nameTable[targetParent.parentId];\n                    (0,_index__WEBPACK_IMPORTED_MODULE_5__.updateZindex)(obj, parentSwimlane, diagram);\n                }\n            }\n        }\n    };\n    UndoRedo.prototype.recordLabelCollectionChanged = function (entry, diagram) {\n        var label = entry.undoObject;\n        var obj = entry.redoObject;\n        var node = diagram.nameTable[obj.id];\n        if (entry && entry.changeType) {\n            var changeType = void 0;\n            if (entry.isUndo) {\n                changeType = (entry.changeType === 'Insert') ? 'Remove' : 'Insert';\n            }\n            else {\n                changeType = entry.changeType;\n            }\n            if (changeType === 'Remove') {\n                diagram.removeLabels(node, [label]);\n                diagram.clearSelectorLayer();\n            }\n            else {\n                diagram.clearSelectorLayer();\n                diagram.addLabels(node, [label]);\n            }\n            if (diagram.mode !== 'SVG') {\n                diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    UndoRedo.prototype.recordPortCollectionChanged = function (entry, diagram) {\n        var port = entry.undoObject;\n        var obj = entry.redoObject;\n        var node = diagram.nameTable[obj.id];\n        if (entry && entry.changeType) {\n            var changeType = void 0;\n            if (entry.isUndo) {\n                changeType = (entry.changeType === 'Insert') ? 'Remove' : 'Insert';\n            }\n            else {\n                changeType = entry.changeType;\n            }\n            if (changeType === 'Remove') {\n                diagram.removePorts(node, [port]);\n                diagram.clearSelectorLayer();\n            }\n            else {\n                diagram.clearSelectorLayer();\n                diagram.addPorts(node, [port]);\n            }\n            if (diagram.mode !== 'SVG') {\n                diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * redo method \\\n     *\n     * @returns { void } redo method .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.redo = function (diagram) {\n        this.checkRedo = true;\n        var entry = this.getRedoEntry(diagram);\n        var startGroupActionCount = 0;\n        if (entry) {\n            if (entry.category === 'Internal') {\n                if (entry.type === 'StartGroup') {\n                    startGroupActionCount++;\n                    this.groupUndo = true;\n                    //Removed isBlazor code\n                }\n                else {\n                    this.redoEntry(entry, diagram);\n                }\n                if (this.groupUndo) {\n                    this.redoGroupAction(entry, diagram, startGroupActionCount);\n                    this.groupUndo = false;\n                }\n            }\n            else {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_7__.isBlazor)()) {\n                    diagram.historyManager.redo(entry);\n                }\n                var arg = {\n                    entryType: 'redo', oldValue: entry.redoObject, newValue: entry.undoObject\n                };\n                //Removed isBlazor code\n                diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramEvent.historyStateChange, arg);\n            }\n        }\n        this.checkRedo = false;\n    };\n    UndoRedo.prototype.redoGroupAction = function (entry, diagram, startGroupActionCount) {\n        while (startGroupActionCount !== 0) {\n            this.redoEntry(entry, diagram);\n            entry = this.getRedoEntry(diagram);\n            if (entry.type === 'EndGroup') {\n                startGroupActionCount--;\n            }\n            else if (entry.type === 'StartGroup') {\n                startGroupActionCount++;\n            }\n        }\n        startGroupActionCount = 0;\n    };\n    UndoRedo.prototype.redoEntry = function (historyEntry, diagram) {\n        var redoObject;\n        var redovalue;\n        if (historyEntry.type !== 'PropertyChanged' && historyEntry.type !== 'CollectionChanged') {\n            redoObject = (historyEntry.redoObject);\n            redovalue = (historyEntry.redoObject);\n        }\n        diagram.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n        if (historyEntry.type !== 'StartGroup' && historyEntry.type !== 'EndGroup') {\n            if (diagram.historyManager.redoStack.length > 0) {\n                var addObject = diagram.historyManager.redoStack.splice(0, 1);\n                diagram.historyManager.undoStack.splice(0, 0, addObject[0]);\n                redovalue = (historyEntry.redoObject);\n            }\n        }\n        diagram.protectPropertyChange(true);\n        //Removed isBlazor code\n        switch (historyEntry.type) {\n            case 'PositionChanged':\n            case 'Align':\n            case 'Distribute':\n                this.recordPositionChanged(redoObject, diagram);\n                break;\n            case 'SizeChanged':\n            case 'Sizing':\n                this.recordSizeChanged(redoObject, diagram, historyEntry);\n                break;\n            case 'RotationChanged':\n                this.recordRotationChanged(redoObject, diagram, historyEntry, 'redo');\n                break;\n            case 'ConnectionChanged':\n                this.recordConnectionChanged(redoObject, diagram);\n                break;\n            case 'PropertyChanged':\n                this.recordPropertyChanged(historyEntry, diagram, true);\n                break;\n            case 'CollectionChanged':\n                this.recordCollectionChanged(historyEntry, diagram);\n                break;\n            case 'LabelCollectionChanged':\n                this.recordLabelCollectionChanged(historyEntry, diagram);\n                break;\n            case 'PortCollectionChanged':\n                this.recordPortCollectionChanged(historyEntry, diagram);\n                break;\n            case 'Group':\n                this.group(historyEntry, diagram);\n                break;\n            case 'UnGroup':\n                this.unGroup(historyEntry, diagram);\n                break;\n            case 'SegmentChanged':\n                this.recordSegmentChanged(redoObject, diagram);\n                break;\n            case 'PortPositionChanged':\n                this.recordPortChanged(historyEntry, diagram, true);\n                break;\n            case 'AnnotationPropertyChanged':\n                this.recordAnnotationChanged(historyEntry, diagram, true);\n                break;\n            case 'ChildCollectionChanged':\n                this.recordChildCollectionChanged(historyEntry, diagram, true);\n                break;\n            case 'StackChildPositionChanged':\n                this.recordStackPositionChanged(historyEntry, diagram, true);\n                break;\n            case 'RowHeightChanged':\n                this.recordGridSizeChanged(historyEntry, diagram, true, true);\n                break;\n            case 'ColumnWidthChanged':\n                this.recordGridSizeChanged(historyEntry, diagram, true, false);\n                break;\n            case 'LanePositionChanged':\n                this.recordLanePositionChanged(historyEntry, diagram, true);\n                break;\n            case 'LaneCollectionChanged':\n            case 'PhaseCollectionChanged':\n                this.recordLaneOrPhaseCollectionChanged(historyEntry, diagram, true);\n                break;\n            case 'SendToBack':\n            case 'SendForward':\n            case 'SendBackward':\n            case 'BringToFront':\n                this.recordOrderCommandChanged(historyEntry, diagram, true);\n                break;\n            case 'AddChildToGroupNode':\n                this.recordAddChildToGroupNode(historyEntry, diagram, true);\n                break;\n            case 'RemoveChildFromGroupNode':\n                this.recordRemoveChildFromGroupNode(historyEntry, diagram, true);\n                break;\n            case 'ExternalEntry':\n                //EJ2-848643 - Need to consider custom entries in start and end group action\n                diagram.historyManager.redo(historyEntry);\n                break;\n        }\n        diagram.protectPropertyChange(false);\n        diagram.diagramActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n        diagram.historyChangeTrigger(historyEntry, 'Redo');\n        if (redovalue) {\n            var value = this.checkNodeObject(redovalue, diagram);\n            if (value) {\n                var getnodeDefaults = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_4__.getFunction)(diagram.updateSelection);\n                if (getnodeDefaults) {\n                    getnodeDefaults(value, diagram);\n                }\n            }\n        }\n    };\n    UndoRedo.prototype.getUndoEntry = function (diagram) {\n        var undoEntry = null;\n        var currentObject;\n        var hList = diagram.historyManager;\n        if (hList.canUndo) {\n            undoEntry = hList.currentEntry;\n            currentObject = hList.currentEntry.previous;\n            if (currentObject) {\n                hList.currentEntry = currentObject;\n                if (!hList.canRedo) {\n                    hList.canRedo = true;\n                }\n            }\n            else {\n                hList.canRedo = true;\n                hList.canUndo = false;\n            }\n        }\n        return undoEntry;\n    };\n    UndoRedo.prototype.getRedoEntry = function (diagram) {\n        var redoEntry = null;\n        var entryCurrent;\n        var hList = diagram.historyManager;\n        if (hList.canRedo) {\n            if (!hList.currentEntry.previous && !hList.canUndo) {\n                entryCurrent = hList.currentEntry;\n            }\n            else {\n                entryCurrent = hList.currentEntry.next;\n            }\n            if (entryCurrent) {\n                hList.currentEntry = entryCurrent;\n                if (!hList.canUndo) {\n                    hList.canUndo = true;\n                }\n                if (!entryCurrent.next) {\n                    hList.canRedo = false;\n                    hList.canUndo = true;\n                }\n            }\n            redoEntry = hList.currentEntry;\n        }\n        return redoEntry;\n    };\n    /**\n     * To destroy the undo redo module\n     *\n     * @returns {void}\n     * @private\n     */\n    UndoRedo.prototype.destroy = function () {\n        /**\n         * Destroys the undo redo module\n         */\n    };\n    /**\n     * @returns { string } toBounds method .\\\n     * Get getModuleName name.\n     */\n    UndoRedo.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'UndoRedo';\n    };\n    return UndoRedo;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/undo-redo.js?");

/***/ })

}]);