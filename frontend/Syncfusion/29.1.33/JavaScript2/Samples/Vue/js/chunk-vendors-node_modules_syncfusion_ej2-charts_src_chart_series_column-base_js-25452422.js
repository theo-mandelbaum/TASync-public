"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_column-base_js-25452422"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnBase: () => (/* binding */ ColumnBase)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _utils_double_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/double-range */ \"./node_modules/@syncfusion/ej2-charts/src/chart/utils/double-range.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n\n\n\n\n\n\n/**\n * Base class for column series.\n * This class provides common properties and methods for column series in the chart.\n *\n * @private\n */\nvar ColumnBase = /** @class */ (function () {\n    function ColumnBase() {\n    }\n    ColumnBase.prototype.getSideBySideInfo = function (series) {\n        series.isRectSeries = true;\n        if ((series.chart.enableSideBySidePlacement && !series.position) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series.columnWidthInPixel)) {\n            this.getSideBySidePositions(series);\n        }\n        if (series.columnWidthInPixel) {\n            return new _utils_double_range__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(0, 0);\n        }\n        var position = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 0 : series.position;\n        var rectCount = series.type === 'Histogram' || !series.chart.enableSideBySidePlacement ? 1 : series.rectCount;\n        var visibleSeries = series.chart.visibleSeries;\n        var seriesSpacing = series.chart.enableSideBySidePlacement ? series.columnSpacing : 0; // Column Spacing\n        var pointSpacing = (series.columnWidth === null || isNaN(+series.columnWidth)) ? ((series.type === 'Histogram') ? 1 : 0.7) :\n            Math.min(series.columnWidth, 1); // Column width\n        var minimumPointDelta = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getMinPointsDelta)(series.xAxis, visibleSeries);\n        var width = minimumPointDelta * pointSpacing;\n        var radius;\n        var location = (position) / rectCount - 0.5;\n        var doubleRange = new _utils_double_range__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(location, location + (1 / rectCount));\n        if (!(isNaN(doubleRange.start) || isNaN(doubleRange.end))) {\n            if (series.groupName && series.type.indexOf('Stacking') === -1) {\n                var mainColumnWidth_1 = 0.7;\n                series.chart.series.filter(function (series) {\n                    if (series.columnWidth > mainColumnWidth_1) {\n                        mainColumnWidth_1 = series.columnWidth;\n                    }\n                });\n                var mainWidth = minimumPointDelta * mainColumnWidth_1;\n                var mainDoubleRange = new _utils_double_range__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(doubleRange.start * mainWidth, doubleRange.end * mainWidth);\n                var difference = ((mainDoubleRange.delta) - (doubleRange.end * width - doubleRange.start * width)) / 2;\n                doubleRange = new _utils_double_range__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(mainDoubleRange.start + difference, mainDoubleRange.end - difference);\n            }\n            else {\n                doubleRange = new _utils_double_range__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(doubleRange.start * width, doubleRange.end * width);\n            }\n            radius = seriesSpacing * doubleRange.delta;\n            doubleRange = new _utils_double_range__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(doubleRange.start + radius / 2, doubleRange.end - radius / 2);\n        }\n        return doubleRange;\n    };\n    /**\n     * Gets the rectangle bounds based on two points.\n     *\n     * @param {number} x1 - The x-coordinate of the first point.\n     * @param {number} y1 - The y-coordinate of the first point.\n     * @param {number} x2 - The x-coordinate of the second point.\n     * @param {number} y2 - The y-coordinate of the second point.\n     * @param {Series} series - The series associated with the rectangle.\n     * @returns {Rect} - The rectangle bounds.\n     */\n    ColumnBase.prototype.getRectangle = function (x1, y1, x2, y2, series) {\n        var point1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getPoint)(x1, y1, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n        var point2 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getPoint)(x2, y2, series.xAxis, series.yAxis, series.chart.requireInvertedAxis);\n        return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y), Math.abs(point2.x - point1.x), Math.abs(point2.y - point1.y));\n    };\n    /**\n     * Draws a cylinder using the provided options and element.\n     *\n     * @param {PathOption} options - The path options for drawing the cylinder.\n     * @param {HTMLElement} element - The HTML element to which the cylinder is drawn.\n     * @param {CylinderSeriesOption} cylinderSeriesOption - The options specific to the cylinder series.\n     * @param {Rect} rect - The rectangle bounds within which the cylinder is drawn.\n     * @param {Series} series - The series associated with the cylinder.\n     * @returns {void}\n     */\n    ColumnBase.prototype.drawCylinder = function (options, element, cylinderSeriesOption, rect, series) {\n        var width = rect.width;\n        var height = rect.height;\n        if (series.chart.enableCanvas) {\n            var ctx = series.chart.canvasRender.ctx;\n            var canvasCtx = ctx;\n            ctx.save();\n            var gradientColor = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.colorNameToHex)(options.fill);\n            var x = rect.x + series.clipRect.x;\n            var y = rect.y + series.clipRect.y;\n            var arc = 2 * Math.PI + 0.1;\n            var rx = void 0;\n            var ry = void 0;\n            var cx1 = void 0;\n            var cx2 = void 0;\n            var cy1 = void 0;\n            var cy2 = void 0;\n            var x1 = void 0;\n            var x2 = void 0;\n            var y1 = void 0;\n            var y2 = void 0;\n            var cx = void 0;\n            var cy = void 0;\n            var xl = void 0;\n            var yl = void 0;\n            var xPos = void 0;\n            var yPos = void 0;\n            var step = void 0;\n            var rxt = void 0;\n            var ryt = void 0;\n            var gx1 = 0;\n            var gx2 = 0;\n            var gy1 = 0;\n            var gy2 = 0;\n            var ini = 0;\n            ctx.fillStyle = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.applyZLight)(gradientColor, 0.9);\n            ctx.lineWidth = 0;\n            ctx.strokeStyle = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.applyZLight)(gradientColor, 0.9);\n            ctx.globalAlpha = options.opacity;\n            if (cylinderSeriesOption.isColumn) {\n                gx1 = x;\n                gx2 = width + x;\n                rx = width / 2;\n                ry = rx / 4;\n                cx2 = cx1 = x + rx;\n                y2 = cy1 = y - ry;\n                x2 = x;\n                x1 = x + width;\n                cy2 = y1 = y + height - ry;\n                step = Math.PI;\n                rxt = -rx;\n                ryt = ry;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        y2 = cy1 = y + ry;\n                    }\n                }\n            }\n            else {\n                gy2 = height + y;\n                gy1 = y;\n                ry = height / 2;\n                rx = ry / 4;\n                x2 = cx1 = x + rx;\n                x1 = cx2 = x + width + rx;\n                y1 = y + height;\n                y2 = y;\n                cy2 = cy1 = y + ry;\n                ini = Math.PI / 2;\n                step = Math.PI * 1.5;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        x1 = cx2 = x + width - rx;\n                    }\n                }\n                ry = -ry;\n                rx = -rx;\n                rxt = rx;\n                ryt = -ry;\n            }\n            var color = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.applyZLight)(gradientColor, 0.7);\n            var gradient = ctx.createLinearGradient(gx1, gy1, gx2, gy2);\n            gradient.addColorStop(0, gradientColor);\n            gradient.addColorStop(0.3, color);\n            gradient.addColorStop(0.7, color);\n            gradient.addColorStop(1, gradientColor);\n            for (var j = 1; j <= 4; j++) {\n                var i = 0;\n                if (j < 4) {\n                    ctx.beginPath();\n                }\n                if (j % 2 === 0) {\n                    cx = cx2;\n                    cy = cy2;\n                    xl = x2;\n                    yl = y2;\n                }\n                else {\n                    cx = cx1;\n                    cy = cy1;\n                    xl = x1;\n                    yl = y1;\n                }\n                if (j === 4) {\n                    rx = rxt;\n                    ry = ryt;\n                    ctx.fillStyle = gradient;\n                }\n                if (j > 2) {\n                    i = ini;\n                    arc = step;\n                }\n                for (; i <= arc; i += 0.1) {\n                    xPos = cx - (rx * Math.cos(i));\n                    yPos = cy + (ry * Math.sin(i));\n                    if (i === 0) {\n                        ctx.moveTo(xPos, yPos);\n                    }\n                    else {\n                        ctx.lineTo(xPos, yPos);\n                    }\n                }\n                if (j > 2) {\n                    ctx.lineTo(xl, yl);\n                }\n                if (j !== 3) {\n                    ctx.stroke();\n                    ctx.fill();\n                }\n            }\n            if (options.id.indexOf('Series') >= 0) {\n                ctx.clip();\n                ctx.restore();\n                ctx = canvasCtx;\n            }\n        }\n        else {\n            var chart = series.chart;\n            var x = rect.x;\n            var y = rect.y;\n            var id = options.id;\n            var gradientColor = options.fill;\n            var fillColor = gradientColor;\n            var format = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.checkColorFormat)(gradientColor);\n            if (!format) {\n                gradientColor = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.colorNameToHex)(gradientColor);\n            }\n            var AEx = 0;\n            var AEy = 0;\n            var LX = 0;\n            var LY = 0;\n            var GX = 0;\n            var GY = 0;\n            var X = void 0;\n            var Y = void 0;\n            var X1 = void 0;\n            var Y1 = void 0;\n            var X2 = void 0;\n            var Y2 = void 0;\n            var rx = void 0;\n            var ry = void 0;\n            var i = 2;\n            if (cylinderSeriesOption.isColumn) {\n                rx = width / 2;\n                ry = rx / 4;\n                X = X1 = x;\n                Y = ry < y ? y - ry : cylinderSeriesOption.stacking ? y + ry : (y - ry);\n                Y1 = Y;\n                AEx = 2 * rx;\n                LY = ry < y ? height : (height < 2 * ry ? height : cylinderSeriesOption.stacking ? height - (2 * ry) : height);\n                X2 = X;\n                Y2 = ry < y ? Y + height : (height < Y ? height + Y : cylinderSeriesOption.stacking ? height + (y - ry) : height + Y);\n                GX = 100;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        Y = Y1 = y + ry;\n                        LY = height < rx / 2 ? height : height - rx / 2;\n                    }\n                }\n            }\n            else {\n                ry = height / 2;\n                rx = ry / 4;\n                Y = Y1 = y;\n                X = X1 = Math.abs(x - rx);\n                AEy = 2 * ry;\n                LX = width;\n                X2 = X + width;\n                Y2 = Y;\n                GY = 100;\n                if (cylinderSeriesOption.stacking) {\n                    if (!cylinderSeriesOption.isLastSeries) {\n                        X2 = (X + width - rx * 2);\n                        LX = width - rx * 2;\n                    }\n                }\n            }\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(this.element);\n            while (i--) {\n                options.d = 'M' + X.toString() + ',' + Y.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString();\n                options.id = id + '_' + 'Region_' + i;\n                options.fill = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.applyZLight)(gradientColor, 0.9);\n                if (i % 2 === 0 && series.type !== 'StackingBar100' && series.type !== 'StackingBar' && series.type !== 'Bar') {\n                    options.fill = options.fill + '10';\n                }\n                this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n                X = X2;\n                Y = Y2;\n            }\n            options.d = 'M' + X1.toString() + ',' + Y1.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,0 ' + AEx.toString() + ',' + AEy.toString() + 'l' + LX.toString() + ' ' + LY.toString() + 'a' + rx.toString() + ',' + ry.toString() + ' 0 1,1 ' + (-1 * AEx).toString() + ',' + (-1 * AEy).toString() + ' z';\n            options.id = id + '_' + 'Region_2';\n            options.fill = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.applyZLight)(gradientColor, 0.7);\n            var optiong = void 0;\n            if (fillColor.indexOf('url') === -1) {\n                if (!document.getElementById(id)) {\n                    optiong = { 'id': id, x1: '0%', y1: '0%', x2: GX.toString() + '%', y2: GY.toString() + '%' };\n                    var gradientElement = [{ colorStop: '0%', color: gradientColor }, { colorStop: '30%', color: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.applyZLight)(gradientColor, 0.7) }, { colorStop: '70%', color: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.applyZLight)(gradientColor, 0.7) }, { colorStop: '100%', color: gradientColor }];\n                    this.drawGradient(optiong, gradientElement, series);\n                }\n                options.fill = 'url(#' + optiong.id + ')';\n            }\n            this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n        }\n    };\n    /**\n     * Draws a gradient using the provided options and gradient element.\n     *\n     * @param {OptionGradient} optiong - The gradient options for drawing the gradient.\n     * @param {Object} gradientElement - The gradient element to which the gradient is applied.\n     * @param {Series} series - The series associated with the gradient.\n     * @returns {void}\n     */\n    ColumnBase.prototype.drawGradient = function (optiong, gradientElement, series) {\n        var chart = series.chart;\n        var defElement = chart.renderer.createDefs();\n        var xmlns = 'http://www.w3.org/2000/svg';\n        var linearGradientElement = document.createElementNS(xmlns, 'linearGradient');\n        linearGradientElement.setAttribute('id', optiong.id);\n        linearGradientElement.setAttribute('x1', optiong.x1);\n        linearGradientElement.setAttribute('y1', optiong.y1);\n        linearGradientElement.setAttribute('x2', optiong.x2);\n        linearGradientElement.setAttribute('y2', optiong.y2);\n        for (var i = 0; i < gradientElement.length; i++) {\n            var stopElement = document.createElementNS(xmlns, 'stop');\n            stopElement.setAttribute('offset', gradientElement[i].colorStop);\n            stopElement.setAttribute('stop-color', gradientElement[i].color);\n            stopElement.setAttribute('stop-opacity', '1');\n            linearGradientElement.appendChild(stopElement);\n        }\n        series.seriesElement.appendChild(defElement);\n        defElement.appendChild(linearGradientElement);\n    };\n    /**\n     * To get the position of each series.\n     *\n     * @param {Series} series - The series for which side-by-side positions are calculated.\n     * @returns {void}\n     * @private\n     */\n    ColumnBase.prototype.getSideBySidePositions = function (series) {\n        var chart = series.chart;\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var columnItem = _a[_i];\n            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n                var item = _c[_b];\n                this.findRectPosition(series.findSeriesCollection(columnItem, item, false));\n            }\n        }\n    };\n    ColumnBase.prototype.findRectPosition = function (seriesCollection) {\n        var groupingValues = [];\n        var vSeries = { rectCount: 0, position: null };\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            if (value.type.indexOf('Stacking') !== -1 || value.groupName !== '') {\n                var groupName = value.type.indexOf('Stacking') !== -1 ? value.stackingGroup : value.type + value.groupName;\n                if (groupName) {\n                    if (groupingValues[groupName] === undefined) {\n                        value.position = vSeries.rectCount;\n                        groupingValues[groupName] = vSeries.rectCount++;\n                    }\n                    else {\n                        value.position = groupingValues[groupName];\n                    }\n                }\n                else {\n                    if (vSeries.position === null) {\n                        value.position = vSeries.rectCount;\n                        vSeries.position = vSeries.rectCount++;\n                    }\n                    else {\n                        value.position = vSeries.position;\n                    }\n                }\n            }\n            else {\n                value.position = vSeries.rectCount++;\n            }\n        }\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            value.rectCount = vSeries.rectCount;\n        }\n    };\n    /**\n     * Updates the location of the symbol based on the point and rect coordinates.\n     *\n     * @param {Points} point - The point for which the symbol location is updated.\n     * @param {Rect} rect - The rect representing the symbol location.\n     * @param {Series} series - The series to which the point belongs.\n     * @returns {void}\n     */\n    ColumnBase.prototype.updateSymbolLocation = function (point, rect, series) {\n        if (!series.chart.requireInvertedAxis) {\n            this.updateXRegion(point, rect, series);\n        }\n        else {\n            this.updateYRegion(point, rect, series);\n        }\n        if (series.type === 'Histogram') {\n            point.minimum = +point.x - series.histogramValues.binWidth / 2;\n            point.maximum = +point.x + series.histogramValues.binWidth / 2;\n        }\n    };\n    /**\n     * Updates the x-region of the symbol based on the point and rect coordinates.\n     *\n     * @param {Points} point - The point for which the x-region is updated.\n     * @param {Rect} rect - The rect representing the x-region.\n     * @param {Series} series - The series to which the point belongs.\n     * @returns {void}\n     */\n    ColumnBase.prototype.updateXRegion = function (point, rect, series) {\n        point.symbolLocations.push({\n            x: rect.x + (rect.width) / 2,\n            y: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||\n                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.y : (rect.y + rect.height)\n        });\n        this.getRegion(point, rect, series);\n        if (series.type === 'RangeColumn') {\n            point.symbolLocations.push({\n                x: rect.x + (rect.width) / 2,\n                y: rect.y + rect.height\n            });\n        }\n    };\n    /**\n     * Updates the y-region of the symbol based on the point and rect coordinates.\n     *\n     * @param {Points} point - The point for which the y-region is updated.\n     * @param {Rect} rect - The rect representing the y-region.\n     * @param {Series} series - The series to which the point belongs.\n     * @returns {void}\n     */\n    ColumnBase.prototype.updateYRegion = function (point, rect, series) {\n        point.symbolLocations.push({\n            x: (series.seriesType === 'BoxPlot' || series.seriesType.indexOf('HighLow') !== -1 ||\n                (point.yValue >= 0 === !series.yAxis.isAxisInverse)) ? rect.x + rect.width : rect.x,\n            y: rect.y + rect.height / 2\n        });\n        this.getRegion(point, rect, series);\n        if (series.type === 'RangeColumn') {\n            point.symbolLocations.push({\n                x: rect.x,\n                y: rect.y + rect.height / 2\n            });\n        }\n    };\n    /**\n     * To render the marker for the series.\n     *\n     * @param {Series} series - The series for which markers are rendered.\n     * @returns {void}\n     * @private\n     */\n    ColumnBase.prototype.renderMarker = function (series) {\n        if (series.marker && series.marker.visible) {\n            series.chart.markerRender.render(series);\n        }\n    };\n    /**\n     * To get the marker region when Y value is 0\n     *\n     * @param {Points} point point\n     * @param {rect} rect rect\n     * @param {Series} series series\n     * @returns {void}\n     */\n    ColumnBase.prototype.getRegion = function (point, rect, series) {\n        if (point.y === 0) {\n            var markerWidth = (series.marker && series.marker.width) ? series.marker.width : 0;\n            var markerHeight = (series.marker && series.marker.height) ? series.marker.height : 0;\n            point.regions.push(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(point.symbolLocations[0].x - markerWidth, point.symbolLocations[0].y - markerHeight, 2 * markerWidth, 2 * markerHeight));\n        }\n        else {\n            point.regions.push(rect);\n        }\n    };\n    /**\n     * Triggers the point render event.\n     *\n     * @param {Series} series - The series associated with the point.\n     * @param {Points} point - The data point for which the event is triggered.\n     * @param {string} fill - The fill color of the point.\n     * @param {BorderModel} border - The border settings of the point.\n     * @returns {IPointRenderEventArgs} - The event arguments.\n     */\n    ColumnBase.prototype.triggerEvent = function (series, point, fill, border) {\n        var argsData = {\n            cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.pointRender, series: series, point: point,\n            fill: series.setPointColor(point, fill),\n            border: series.setBorderColor(point, border),\n            cornerRadius: series.cornerRadius\n        };\n        series.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.pointRender, argsData);\n        point.color = argsData.fill;\n        return argsData;\n    };\n    /**\n     * Draws a rectangle for the data point.\n     *\n     * @param {Series} series - The series associated with the point.\n     * @param {Points} point - The data point for which the rectangle is drawn.\n     * @param {Rect} rect - The rect bounds.\n     * @param {IPointRenderEventArgs} argsData - The event arguments.\n     * @returns {void}\n     */\n    ColumnBase.prototype.drawRectangle = function (series, point, rect, argsData) {\n        var chart = series.chart;\n        var check = chart.requireInvertedAxis ? rect.height : rect.width;\n        if (check <= 0) {\n            return null;\n        }\n        var direction;\n        if (point.y === 0) {\n            // For 0 values corner radius will not calculate\n            direction = this.calculateRoundedRectPath(rect, 0, 0, 0, 0);\n        }\n        else {\n            var topLeft = void 0;\n            var topRight = void 0;\n            var bottomLeft = void 0;\n            var bottomRight = void 0;\n            var isNegative = point.y < 0;\n            if (chart.requireInvertedAxis) {\n                topLeft = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.topLeft;\n                topRight = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.topRight;\n                bottomLeft = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.bottomLeft;\n                bottomRight = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.bottomRight;\n            }\n            else {\n                topLeft = isNegative ? argsData.cornerRadius.bottomLeft : argsData.cornerRadius.topLeft;\n                topRight = isNegative ? argsData.cornerRadius.bottomRight : argsData.cornerRadius.topRight;\n                bottomLeft = isNegative ? argsData.cornerRadius.topLeft : argsData.cornerRadius.bottomLeft;\n                bottomRight = isNegative ? argsData.cornerRadius.topRight : argsData.cornerRadius.bottomRight;\n            }\n            direction = this.calculateRoundedRectPath(rect, topLeft, topRight, bottomLeft, bottomRight, chart.requireInvertedAxis);\n        }\n        var name = series.category === 'Indicator' ? chart.element.id + '_Indicator_' + series.index + '_' + series.name +\n            '_Point_' + point.index : chart.element.id + '_Series_' + series.index + '_Point_' + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index);\n        var previousElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.redrawElement)(chart.redraw, name);\n        var previousDirection = previousElement ? previousElement.getAttribute('d') : '';\n        this.options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.PathOption(name, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.border.dashArray, (series.columnFacet === 'Cylinder') ? '' : direction);\n        this.element = chart.renderer.drawPath(this.options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n            this.element.id = chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n        }\n        switch (series.seriesType) {\n            case 'XY':\n                this.element.setAttribute('role', 'img');\n                this.element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : (point.x + ':' + point.yValue + ', ' + series.name));\n                break;\n            case 'HighLow':\n                this.element.setAttribute('role', 'img');\n                this.element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : (point.x + ':' + point.high + ', ' + point.low + ', ' + series.name));\n                break;\n        }\n        if (!(series.columnFacet === 'Cylinder' && (chart.redraw || !chart.enableAnimation) && series.seriesElement.querySelector('#' + this.element.id))) {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(series.chart.enableCanvas, series.seriesElement, this.element, chart.redraw);\n        }\n        if (!series.chart.enableCanvas) {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.pathAnimation)(this.element, (series.columnFacet === 'Cylinder') ? '' : direction, chart.redraw, previousDirection, chart.duration);\n        }\n    };\n    /**\n     * To animate the series.\n     *\n     * @param {Series} series - The series to be animated.\n     * @returns {void}\n     * @private\n     */\n    ColumnBase.prototype.animate = function (series) {\n        var rectElements = series.seriesElement.childNodes;\n        var count = series.category === 'Indicator' ? 0 : 1;\n        var visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getVisiblePoints)(series);\n        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n            var point = visiblePoints_1[_i];\n            if (!point.symbolLocations.length && !(series.type === 'BoxAndWhisker' && point.regions.length)) {\n                continue;\n            }\n            if ((series.type === 'Column' || series.type === 'Bar' || series.type === 'StackingColumn' || series.type === 'StackingColumn100' || series.type === 'StackingBar' || series.type === 'StackingBar100') && series.columnFacet === 'Cylinder') {\n                for (var j = 0; j < rectElements.length; j++) {\n                    this.animateRect(rectElements[j], series, point);\n                }\n            }\n            else {\n                this.animateRect(rectElements[count], series, point);\n                count++;\n            }\n        }\n    };\n    /**\n     * Animates the rect element.\n     *\n     * @param {HTMLElement} element - The rect element to be animated.\n     * @param {Series} series - The series associated with the rect.\n     * @param {Points} point - The data point associated with the rect.\n     * @returns {void}\n     */\n    ColumnBase.prototype.animateRect = function (element, series, point) {\n        var option = series.animation;\n        var duration = series.chart.animated ? series.chart.duration : option.duration;\n        var effect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getAnimationFunction)('Linear');\n        var isPlot = point.yValue < 0;\n        var x;\n        var y;\n        var elementHeight = +point.regions[0].height;\n        var elementWidth = +point.regions[0].width;\n        var centerX;\n        var centerY;\n        if (!series.chart.requireInvertedAxis) {\n            x = +point.regions[0].x;\n            if (series.type.indexOf('Stacking') > -1) {\n                y = (1 - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(0, series.yAxis)) * (series.yAxis.rect.height);\n                centerX = x;\n                centerY = y;\n            }\n            else {\n                y = +point.regions[0].y;\n                centerY = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? y + elementHeight / 2 :\n                    (isPlot !== series.yAxis.isAxisInverse) ? y : y + elementHeight;\n                centerX = isPlot ? x : x + elementWidth;\n            }\n        }\n        else {\n            y = +point.regions[0].y;\n            if (series.type.indexOf('Stacking') > -1) {\n                x = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(0, series.yAxis)) * series.yAxis.rect.width;\n                centerX = x;\n                centerY = y;\n            }\n            else {\n                x = +point.regions[0].x;\n                centerY = isPlot ? y : y + elementHeight;\n                centerX = (series.seriesType.indexOf('HighLow') !== -1 || series.type.indexOf('Waterfall') !== -1) ? x + elementWidth / 2 :\n                    (isPlot !== series.yAxis.isAxisInverse) ? x + elementWidth : x;\n            }\n        }\n        var value;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(element)) {\n            element.style.visibility = 'hidden';\n            new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n                duration: (duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 1000 : duration,\n                delay: option.delay,\n                progress: function (args) {\n                    if (args.timeStamp >= args.delay) {\n                        element.style.visibility = 'visible';\n                        if (!series.chart.requireInvertedAxis) {\n                            elementHeight = elementHeight ? elementHeight : 1;\n                            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);\n                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +\n                                ') scale(1,' + (value / elementHeight) + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');\n                        }\n                        else {\n                            elementWidth = elementWidth ? elementWidth : 1;\n                            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);\n                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +\n                                ') scale(' + (value / elementWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');\n                        }\n                    }\n                },\n                end: function () {\n                    var annotations = document.getElementById(series.chart.element.id + '_Annotation_Collections');\n                    if (annotations) {\n                        annotations.style.visibility = 'visible';\n                    }\n                    var stackLabelGroup = document.getElementById(series.chart.element.id + '_StackLabelGroup');\n                    if (stackLabelGroup) {\n                        stackLabelGroup.setAttribute('visibility', 'visible');\n                    }\n                    element.setAttribute('transform', 'translate(0,0)');\n                    var seriesElement = series.seriesElement;\n                    if (element === seriesElement.lastElementChild || point.index === series.points.length - 1 ||\n                        (series.type === 'Waterfall' && element === seriesElement.children[seriesElement.childElementCount - 2])) {\n                        series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n                        if (series.type === 'Waterfall') {\n                            var rectElements = seriesElement.childNodes;\n                            for (var i = 0; i < rectElements.length; i++) {\n                                if (rectElements[i].id.indexOf('Connector') !== -1) {\n                                    rectElements[i].style.visibility = 'visible';\n                                    rectElements[i].setAttribute('transform', 'translate(0,0)');\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * Calculates the path for a rounded rectangle.\n     *\n     * @param {Rect} rect - The bounding rectangle.\n     * @param {number} topLeft - The radius of the top-left corner.\n     * @param {number} topRight - The radius of the top-right corner.\n     * @param {number} bottomLeft - The radius of the bottom-left corner.\n     * @param {number} bottomRight - The radius of the bottom-right corner.\n     * @param {boolean} inverted - Indicates whether the rectangle is inverted.\n     * @returns {string} The SVG path string representing the rounded rectangle.\n     */\n    ColumnBase.prototype.calculateRoundedRectPath = function (rect, topLeft, topRight, bottomLeft, bottomRight, inverted) {\n        if (inverted === void 0) { inverted = false; }\n        var halfValue = inverted ? rect.width / 2 : rect.height / 2;\n        topLeft = Math.min(topLeft, halfValue);\n        topRight = Math.min(topRight, halfValue);\n        bottomLeft = Math.min(bottomLeft, halfValue);\n        bottomRight = Math.min(bottomRight, halfValue);\n        return 'M' + ' ' + rect.x + ' ' + (topLeft + rect.y) +\n            ' Q ' + rect.x + ' ' + rect.y + ' ' + (rect.x + topLeft) + ' ' +\n            rect.y + ' ' + 'L' + ' ' + (rect.x + rect.width - topRight) + ' ' + rect.y +\n            ' Q ' + (rect.x + rect.width) + ' ' + rect.y + ' ' +\n            (rect.x + rect.width) + ' ' + (rect.y + topRight) + ' ' + 'L ' +\n            (rect.x + rect.width) + ' ' + (rect.y + rect.height - bottomRight)\n            + ' Q ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height) + ' ' + (rect.x + rect.width - bottomRight) + ' ' +\n            (rect.y + rect.height) + ' ' + 'L ' + (rect.x + bottomLeft) + ' ' + (rect.y + rect.height) + ' Q ' + rect.x + ' ' +\n            (rect.y + rect.height) + ' ' + rect.x + ' ' + (rect.y + rect.height - bottomLeft) + ' ' + 'L' + ' ' + rect.x + ' ' +\n            (topLeft + rect.y) + ' ' + 'Z';\n    };\n    return ColumnBase;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js?");

/***/ })

}]);