"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-circulargauge_src_circular-gauge_axes_axis-panel_js-a45cb7-4ccb860d"],{

/***/ "./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/axes/axis-panel.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/axes/axis-panel.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AxisLayoutPanel: () => (/* binding */ AxisLayoutPanel)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _utils_helper_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/helper-common */ \"./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/utils/helper-common.js\");\n/* harmony import */ var _utils_helper_axis_panel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/helper-axis-panel */ \"./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/utils/helper-axis-panel.js\");\n/* harmony import */ var _model_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/constants */ \"./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/model/constants.js\");\n/* harmony import */ var _axis_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./axis-renderer */ \"./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/axes/axis-renderer.js\");\n/* harmony import */ var _pointer_renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pointer-renderer */ \"./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/axes/pointer-renderer.js\");\n/* harmony import */ var _utils_helper_pointer_renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/helper-pointer-renderer */ \"./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/utils/helper-pointer-renderer.js\");\n\n\n\n\n\n\n\n/**\n * Specifies the CircularGauge Axis Layout.\n */\nvar AxisLayoutPanel = /** @class */ (function () {\n    function AxisLayoutPanel(gauge) {\n        this.axisOption = [];\n        this.prevAnimatedMajorTickValue = [];\n        this.prevAnimatedMajorTickIndex = [];\n        this.prevAnimatedMinorTickValue = [];\n        this.prevAnimatedMinorTickIndex = [];\n        this.allowAxisCount = [];\n        this.rangeAnimationCount = 0;\n        this.gauge = gauge;\n        this.axisRenderer = new _axis_renderer__WEBPACK_IMPORTED_MODULE_4__.AxisRenderer(gauge);\n        this.pointerRenderer = new _pointer_renderer__WEBPACK_IMPORTED_MODULE_5__.PointerRenderer(gauge);\n    }\n    /**\n     * Measure the calculate the axis size and radius.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.measureAxis = function (rect) {\n        this.measureAxisSize(this.gauge, rect);\n        this.calculateAxesRadius();\n    };\n    /**\n     * Measure to calculate the axis radius of the circular gauge.\n     *\n     * @returns {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.calculateAxesRadius = function () {\n        var _this = this;\n        var totalRadius;\n        var currentRadius;\n        var rangeMaximumRadius = 0;\n        var xMarginDiff = this.gauge.margin.left + this.gauge.margin.right;\n        var yMarginDiff = this.gauge.margin.top + this.gauge.margin.bottom;\n        var _loop_1 = function (axis) {\n            totalRadius = (Math.min(axis.rect.width, axis.rect.height) / 2);\n            currentRadius = axis.radius != null ? (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(axis.radius, totalRadius) : totalRadius;\n            // eslint-disable-next-line prefer-spread\n            rangeMaximumRadius = Math.max.apply(Math, axis.ranges.map(function (value) {\n                return value.radius ?\n                    (value.radius.indexOf('%') < 0 ? 100 : parseInt(value.radius, 10)) : 0;\n            }));\n            currentRadius = (rangeMaximumRadius > 100 && axis.radius == null) ?\n                (currentRadius * 100) / rangeMaximumRadius : currentRadius;\n            axis.currentRadius = currentRadius - axis.nearSize;\n            if (this_1.gauge.moveToCenter && this_1.gauge.axes.length === 1 &&\n                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this_1.gauge.centerXpoint) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this_1.gauge.centerYpoint)) {\n                var endAngle = void 0;\n                var startAngle = axis.startAngle;\n                var startPoint = (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(startAngle - 90, currentRadius, this_1.gauge.midPoint);\n                endAngle = axis.endAngle;\n                endAngle -= (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.isCompleteAngle)(startAngle, endAngle) ? 0.0001 : 0;\n                var endPoint = (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(endAngle - 90, currentRadius, this_1.gauge.midPoint);\n                var xDiff = void 0;\n                var yDiff = void 0;\n                var startXDiff = void 0;\n                var endXDiff = void 0;\n                var startYDiff = void 0;\n                var endYDiff = void 0;\n                var newPoint = void 0;\n                if (startAngle > endAngle ? Math.abs(startAngle - endAngle) > 90 ? true : false : true) {\n                    if ((startAngle >= 270 && startAngle <= 360) && ((endAngle > 270 && endAngle <= 360) ||\n                        (endAngle >= 0 && endAngle <= 180))) {\n                        startXDiff = Math.abs(this_1.gauge.gaugeRect.x - Math.abs(startPoint.x - this_1.gauge.gaugeRect.x));\n                        newPoint = (endAngle <= 360 && endAngle >= 270) ? this_1.gauge.midPoint : (endAngle <= 90) ? endPoint :\n                            (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(90 - 90, currentRadius, this_1.gauge.midPoint);\n                        endXDiff = Math.abs(newPoint.x - this_1.gauge.gaugeRect.width);\n                        startPoint = (endAngle <= 360 && endAngle >= 270) ? endPoint :\n                            (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(360 - 90, currentRadius, this_1.gauge.midPoint);\n                        startYDiff = Math.abs(startPoint.y - this_1.gauge.gaugeRect.y);\n                        endPoint = (endAngle <= 360 && endAngle >= 270 || (endAngle >= 0 && endAngle < 90)) ?\n                            this_1.gauge.midPoint : (endAngle >= 90 && endAngle <= 180) ? endPoint :\n                            (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(180 - 90, currentRadius, this_1.gauge.midPoint);\n                        endYDiff = Math.abs(endPoint.y - (this_1.gauge.gaugeRect.y + this_1.gauge.gaugeRect.height));\n                    }\n                    else if ((startAngle >= 0 && startAngle < 90) && (endAngle >= 0 && endAngle <= 270)) {\n                        startYDiff = Math.abs(startPoint.y - this_1.gauge.gaugeRect.y);\n                        newPoint = (endAngle >= 180) ? (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(180 - 90, currentRadius, this_1.gauge.midPoint) :\n                            endPoint;\n                        endYDiff = Math.abs(newPoint.y - (this_1.gauge.gaugeRect.y + this_1.gauge.gaugeRect.height));\n                        startPoint = (endAngle >= 180) ? endPoint : this_1.gauge.midPoint;\n                        startXDiff = Math.abs(this_1.gauge.gaugeRect.x - Math.abs(startPoint.x - this_1.gauge.gaugeRect.x));\n                        endPoint = (endAngle >= 90) ? (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(90 - 90, currentRadius, this_1.gauge.midPoint) : endPoint;\n                        endXDiff = Math.abs(endPoint.x - this_1.gauge.gaugeRect.width);\n                    }\n                    else if ((startAngle >= 90 && startAngle < 180) && (endAngle > 90 && endAngle <= 360)) {\n                        newPoint = (endAngle <= 180) ? this_1.gauge.midPoint : (endAngle >= 270) ?\n                            (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(270 - 90, currentRadius, this_1.gauge.midPoint) : endPoint;\n                        startXDiff = Math.abs(newPoint.x - this_1.gauge.gaugeRect.x);\n                        endXDiff = Math.abs(startPoint.x - this_1.gauge.gaugeRect.width);\n                        startPoint = (endAngle > 270) ? (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(endAngle - 90, currentRadius, this_1.gauge.midPoint) :\n                            this_1.gauge.midPoint;\n                        startYDiff = Math.abs(this_1.gauge.gaugeRect.y - startPoint.y);\n                        endPoint = (endAngle >= 180) ? (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(180 - 90, currentRadius, this_1.gauge.midPoint) : endPoint;\n                        endYDiff = Math.abs(endPoint.y - (this_1.gauge.gaugeRect.y + this_1.gauge.gaugeRect.height));\n                    }\n                    else if ((startAngle >= 180 && startAngle <= 270) && ((endAngle <= 360 && endAngle >= 270) ||\n                        (endAngle <= 180 && endAngle >= 0))) {\n                        newPoint = (endAngle > 180 && endAngle < 270) ? endPoint :\n                            (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(270 - 90, currentRadius, this_1.gauge.midPoint);\n                        startXDiff = Math.abs(this_1.gauge.gaugeRect.x - Math.abs(newPoint.x - this_1.gauge.gaugeRect.x));\n                        newPoint = (endAngle >= 180 && endAngle <= 360) ? this_1.gauge.midPoint : (endAngle <= 90) ? endPoint :\n                            (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(0, currentRadius, this_1.gauge.midPoint);\n                        endXDiff = Math.abs(newPoint.x - this_1.gauge.gaugeRect.width);\n                        newPoint = (endAngle > 180 && endAngle < 270) ? this_1.gauge.midPoint : (endAngle >= 270 && endAngle <= 360) ?\n                            endPoint : (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLocationFromAngle)(360 - 90, currentRadius, this_1.gauge.midPoint);\n                        startYDiff = Math.abs(newPoint.y - this_1.gauge.gaugeRect.y);\n                        endPoint = (endAngle <= 360 && endAngle >= 270 || (endAngle >= 0 && endAngle < 90)) ?\n                            startPoint : ((270 - startAngle) < (endAngle - 90)) ? endPoint : startPoint;\n                        endYDiff = Math.abs(endPoint.y - (this_1.gauge.gaugeRect.y + this_1.gauge.gaugeRect.height));\n                    }\n                    if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(startXDiff) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(endXDiff) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(startYDiff) &&\n                        !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(endYDiff)) && ((startXDiff > 0 || endXDiff > 0) && (startYDiff > 0 || endYDiff > 0))) {\n                        xDiff = Math.abs((startXDiff + endXDiff) - xMarginDiff);\n                        yDiff = Math.abs((startYDiff + endYDiff) - yMarginDiff);\n                        this_1.gauge.midPoint.x = this_1.gauge.midPoint.x - (startXDiff / 2) + (endXDiff / 2);\n                        this_1.gauge.midPoint.y = this_1.gauge.midPoint.y - (startYDiff / 2) + (endYDiff / 2);\n                        totalRadius = (Math.min(this_1.gauge.gaugeRect.width, this_1.gauge.gaugeRect.height) / 2) +\n                            (Math.min(xDiff, yDiff) / 2);\n                        axis.currentRadius = (axis.radius != null ? (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(axis.radius, totalRadius) : totalRadius) - axis.nearSize;\n                    }\n                }\n            }\n            axis.visibleRange.interval = this_1.calculateNumericInterval(axis, axis.rect);\n            var args = {\n                cancel: false, name: _model_constants__WEBPACK_IMPORTED_MODULE_3__.radiusCalculate, currentRadius: axis.currentRadius, gauge: this_1.gauge,\n                midPoint: this_1.gauge.midPoint, axis: axis\n            };\n            this_1.gauge.trigger('radiusCalculate', args, function () {\n                axis.currentRadius = args.currentRadius;\n                _this.gauge.midPoint = args.midPoint;\n                _this.calculateVisibleLabels(axis);\n            });\n        };\n        var this_1 = this;\n        for (var _i = 0, _a = this.gauge.axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            _loop_1(axis);\n        }\n    };\n    /**\n     * Measure to calculate the axis size.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.measureAxisSize = function (gauge, rect) {\n        var _this = this;\n        var sum;\n        this.computeSize(gauge.axes, rect);\n        gauge.axes.map(function (axis, index) {\n            sum = (0,_utils_helper_axis_panel__WEBPACK_IMPORTED_MODULE_2__.calculateSum)(index, _this.farSizes.length - 1, _this.farSizes);\n            axis.rect = new _utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x + sum, rect.y + sum, rect.width - (sum * 2), rect.height - (sum * 2));\n        });\n    };\n    /**\n     * Calculate the axis values of the circular gauge.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.calculateAxisValues = function (rect) {\n        for (var _i = 0, _a = this.gauge.axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            this.calculateVisibleRange(axis, rect);\n            this.calculateVisibleLabels(axis);\n        }\n    };\n    /**\n     * Calculate the visible range of an axis.\n     *\n     * @param {Axis} axis - Specifies the axis.\n     * @param {Rect} rect - Specifies the rect.\n     * @returns {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.calculateVisibleRange = function (axis, rect) {\n        var interval = axis.majorTicks.interval;\n        var minimumValue = Math.min(axis.minimum === null ? 0 : axis.minimum, axis.maximum !== null ? axis.maximum : 100);\n        var maximumValue = Math.max(axis.minimum, axis.maximum === null ? 100 : axis.maximum);\n        axis.pointers.map(function (pointer) {\n            pointer.currentValue = pointer.value !== null ?\n                pointer.value < minimumValue ? minimumValue : pointer.value > maximumValue ? maximumValue : pointer.value\n                : minimumValue;\n            minimumValue = axis.minimum === null ? Math.min(pointer.currentValue, minimumValue) : minimumValue;\n            maximumValue = axis.maximum === null ? Math.max(pointer.currentValue, maximumValue) : maximumValue;\n        });\n        minimumValue = (minimumValue === maximumValue) ?\n            (interval !== null ? minimumValue - interval : minimumValue - 1) : minimumValue;\n        axis.visibleRange = { min: minimumValue, max: maximumValue, interval: interval };\n        axis.visibleRange.interval = this.calculateNumericInterval(axis, rect);\n    };\n    /**\n     * Calculate the numeric intervals of an axis range.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.calculateNumericInterval = function (axis, rect) {\n        var allowComponentRender = ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.minimum) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.maximum)\n            && axis.minimum !== axis.maximum) || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.minimum) || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.maximum)));\n        if (!allowComponentRender) {\n            return 0;\n        }\n        else if (axis.majorTicks.interval !== null) {\n            return axis.majorTicks.interval;\n        }\n        var totalAngle = axis.endAngle - axis.startAngle;\n        totalAngle = totalAngle <= 0 ? (totalAngle + 360) : totalAngle;\n        return this.calculateNiceInterval(axis.visibleRange.max, axis.visibleRange.min, axis.currentRadius ? axis.currentRadius : (rect.width / 2), totalAngle);\n    };\n    /**\n     * Calculate the nice interval of an axis range.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.calculateNiceInterval = function (maxValue, minValue, radius, degree) {\n        var delta = maxValue - minValue;\n        var circumference = 2 * Math.PI * radius * (degree / 360);\n        var desiredIntervalsCount = Math.max((circumference * ((0.533 * 3) / 100)), 1);\n        var niceInterval = delta / desiredIntervalsCount;\n        var minInterval = Math.pow(10, Math.floor(Math.log(niceInterval) / Math.log(10)));\n        for (var _i = 0, _a = [10, 5, 2, 1]; _i < _a.length; _i++) {\n            var interval = _a[_i];\n            var currentInterval = minInterval * interval;\n            if (desiredIntervalsCount < (delta / currentInterval)) {\n                break;\n            }\n            niceInterval = currentInterval;\n        }\n        return niceInterval;\n    };\n    /**\n     * Calculate the visible labels of an axis.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.calculateVisibleLabels = function (axis) {\n        var style = axis.labelStyle;\n        var customLabelFormat = style.format && style.format.match('{value}') !== null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var format = this.gauge.intl.getNumberFormat({\n            format: (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getLabelFormat)(style.format), useGrouping: this.gauge.useGroupingSeparator\n        });\n        var argsData;\n        axis.visibleLabels = [];\n        var roundValue;\n        var interval = axis.visibleRange.interval;\n        var max = axis.visibleRange.max;\n        if (((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.minimum) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.maximum)) || axis.minimum !== axis.maximum) {\n            var _loop_2 = function (i) {\n                roundValue = axis.roundingPlaces ? parseFloat(i.toFixed(axis.roundingPlaces)) : i;\n                argsData = {\n                    cancel: false, name: _model_constants__WEBPACK_IMPORTED_MODULE_3__.axisLabelRender, axis: axis,\n                    text: customLabelFormat ? style.format.replace(new RegExp('{value}', 'g'), format(roundValue)) :\n                        format(roundValue),\n                    value: roundValue\n                };\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var axisLabelRenderSuccess = function (argsData) {\n                    if (!argsData.cancel) {\n                        axis.visibleLabels.push(new _utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.VisibleLabels(argsData.text, i));\n                    }\n                };\n                axisLabelRenderSuccess.bind(this_2);\n                this_2.gauge.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_3__.axisLabelRender, argsData, axisLabelRenderSuccess);\n            };\n            var this_2 = this;\n            for (var i = axis.visibleRange.min; (i <= max && interval); i += interval) {\n                _loop_2(i);\n            }\n        }\n        var lastLabel = axis.visibleLabels.length ? axis.visibleLabels[axis.visibleLabels.length - 1].value : null;\n        var maxVal = axis.visibleRange.max;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(lastLabel) && lastLabel !== maxVal && axis.showLastLabel === true) {\n            argsData = {\n                cancel: false, name: _model_constants__WEBPACK_IMPORTED_MODULE_3__.axisLabelRender, axis: axis,\n                text: customLabelFormat ? style.format.replace(new RegExp('{value}', 'g'), format(maxVal)) :\n                    format(maxVal),\n                value: maxVal\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var axisLabelRenderSuccess = function (argsData) {\n                if (!argsData.cancel) {\n                    axis.visibleLabels.push(new _utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.VisibleLabels(argsData.text, maxVal));\n                }\n            };\n            axisLabelRenderSuccess.bind(this);\n            this.gauge.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_3__.axisLabelRender, argsData, axisLabelRenderSuccess);\n        }\n        this.getMaxLabelWidth(this.gauge, axis);\n    };\n    /**\n     * Measure the axes available size.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.computeSize = function (axes, rect) {\n        var lineSize;\n        var outerHeight;\n        var innerHeight;\n        var heightForCross;\n        var axisPadding = 5;\n        var majorTickOffset = 0;\n        var minorTickOffset = 0;\n        var labelOffset = 0;\n        var labelPadding = 10;\n        this.farSizes = [];\n        this.calculateAxisValues(rect);\n        for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\n            var axis = axes_1[_i];\n            lineSize = (axis.lineStyle.width / 2);\n            outerHeight = 0;\n            innerHeight = 0;\n            heightForCross = axis.majorTicks.position === 'Cross' ? axis.majorTicks.height / 2 : heightForCross;\n            heightForCross = (axis.minorTicks.position === 'Cross' && heightForCross < axis.minorTicks.height / 2) ?\n                axis.minorTicks.height / 2 : heightForCross;\n            heightForCross = (axis.labelStyle.position === 'Cross' && heightForCross < axis.maxLabelSize.height / 2) ?\n                axis.maxLabelSize.height / 2 : heightForCross;\n            lineSize = lineSize < heightForCross ? heightForCross : lineSize;\n            majorTickOffset = axis.majorTicks.offset;\n            minorTickOffset = axis.minorTicks.offset;\n            labelOffset = axis.labelStyle.offset;\n            labelPadding = axis.labelStyle.shouldMaintainPadding ? 10 : 0;\n            // Calculating the outer space of the axis\n            outerHeight += !(axis.majorTicks.position === 'Outside' && axis.minorTicks.position === 'Outside' &&\n                axis.labelStyle.position === 'Outside') ? axisPadding : 0;\n            outerHeight += (axis.majorTicks.position === 'Outside' ? (axis.majorTicks.height + lineSize) : 0) +\n                (axis.labelStyle.position === 'Outside' ? (axis.maxLabelSize.height + labelOffset + labelPadding) : 0) +\n                ((axis.minorTicks.position === 'Outside' && !(axis.majorTicks.position === 'Outside')) ?\n                    (axis.minorTicks.height + lineSize) : 0) + lineSize;\n            outerHeight += (axis.majorTicks.position === 'Outside' && axis.minorTicks.position === 'Outside') ?\n                Math.max(majorTickOffset, minorTickOffset) : (axis.majorTicks.position === 'Outside' ?\n                majorTickOffset : axis.minorTicks.position === 'Outside' ? minorTickOffset : 0);\n            // Calculating the inner space of the axis\n            innerHeight += ((axis.majorTicks.position === 'Inside') ? (axis.majorTicks.height + lineSize) : 0) +\n                ((axis.labelStyle.position === 'Inside') ? (axis.maxLabelSize.height + labelOffset + labelPadding) : 0) +\n                ((axis.minorTicks.position === 'Inside' && axis.majorTicks.position === 'Outside') ?\n                    (axis.minorTicks.height + lineSize) : 0) + lineSize;\n            innerHeight += ((axis.majorTicks.position === 'Inside') && (axis.minorTicks.position === 'Inside')) ?\n                Math.max(majorTickOffset, minorTickOffset) : ((axis.majorTicks.position === 'Inside') ?\n                majorTickOffset : (axis.minorTicks.position === 'Inside') ? minorTickOffset : 0);\n            if (this.farSizes[this.farSizes.length - 1]) {\n                this.farSizes[this.farSizes.length - 1] += (innerHeight + outerHeight);\n            }\n            axis.nearSize = outerHeight - axisPadding;\n            axis.farSize = innerHeight;\n            outerHeight = (this.gauge.axes.length === (this.farSizes.length + 1)) ? 0 : outerHeight;\n            this.farSizes.push(outerHeight);\n        }\n    };\n    /**\n     * To render the Axis element of the circular gauge.\n     *\n     * @return {void}\n     * @private\n     */\n    AxisLayoutPanel.prototype.renderAxes = function (animate) {\n        var _this = this;\n        if (animate === void 0) { animate = true; }\n        var gauge = this.gauge;\n        var renderer = this.axisRenderer;\n        var element;\n        var axesElements = gauge.renderer.createGroup({\n            'id': gauge.element.id + '_AxesCollection',\n            'clip-path': 'url(#' + gauge.element.id + '_GaugeAreaClipRect_' + ')'\n        });\n        // To append the secondary element for annotation and tooltip\n        var annotationElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n            id: gauge.element.id + '_Secondary_Element'\n        });\n        annotationElement.style.position = 'relative';\n        gauge.element.appendChild(annotationElement);\n        gauge.axes.map(function (axis, index) {\n            element = gauge.renderer.createGroup({\n                id: gauge.element.id + '_Axis_Group_' + index\n            });\n            _this.gauge.allowComponentRender = ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.minimum) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.maximum)\n                && axis.minimum !== axis.maximum) || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.minimum) || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.maximum)));\n            renderer.checkAngles(axis);\n            renderer.drawAxisOuterLine(axis, index, element, gauge);\n            if (gauge.allowRangePreRender) {\n                renderer.drawAxisRange(axis, index, element);\n            }\n            renderer.drawAxisLine(axis, index, element, gauge);\n            if (!gauge.allowRangePreRender) {\n                renderer.drawAxisRange(axis, index, element);\n            }\n            renderer.drawMajorTickLines(axis, index, element, gauge);\n            renderer.drawMinorTickLines(axis, index, element, gauge);\n            renderer.drawAxisLabels(axis, index, element, gauge);\n            _this.pointerRenderer.drawPointers(axis, index, element, gauge, animate);\n            if (gauge.annotationsModule) {\n                gauge.annotationsModule.renderAnnotation(axis, index, gauge);\n            }\n            axesElements.appendChild(element);\n        });\n        // For append clip rect for axes\n        gauge.svgObject.appendChild(gauge.renderer.drawClipPath({\n            'id': gauge.element.id + '_GaugeAreaClipRect_',\n            'x': 0, 'y': 0,\n            'width': gauge.availableSize.width,\n            'height': gauge.availableSize.height,\n            'fill': 'transparent', 'stroke': 'transparent'\n        }));\n        gauge.svgObject.appendChild(axesElements);\n        if (gauge.allowLoadingAnimation) {\n            this.durationSplitUp((gauge.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 3000 : gauge.animationDuration, axesElements);\n        }\n    };\n    AxisLayoutPanel.prototype.labelElementAnimation = function (element, axisIndex) {\n        var _this = this;\n        if (element) {\n            new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n                duration: this.gauge.loadingAnimationDuration[axisIndex],\n                progress: function () {\n                    element.style.visibility = 'visible';\n                },\n                end: function () {\n                    element.style.visibility = 'visible';\n                    var axisElement = document.getElementById(_this.gauge.element.id + '_Axis_Labels_' + axisIndex);\n                    if (_this.gauge.axes[axisIndex].showLastLabel && parseInt(element.id.split('Label_')[1], 10) === (axisElement.childElementCount - 2)) {\n                        axisElement.style.visibility = 'visible';\n                        element = document.getElementById(_this.gauge.element.id + '_Axis_' + axisIndex + '_Label_' + (axisElement.childElementCount - 1));\n                        if (element) {\n                            element.style.visibility = 'visible';\n                        }\n                    }\n                }\n            });\n        }\n    };\n    AxisLayoutPanel.prototype.elementLabelAnimation = function (element, axisIndex, tickIndex, gauge) {\n        var _this = this;\n        if (element) {\n            new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n                duration: gauge.axes[axisIndex].labelStyle.font.size != null &&\n                    (gauge.axes[axisIndex].labelStyle.font.size === '0px' || gauge.axes[axisIndex].labelStyle.font.size === '0') ? 0 :\n                    ((gauge.loadingAnimationDuration[axisIndex] / this.axisOption[axisIndex].axisLabelCount)),\n                progress: function () {\n                    element.style.visibility = 'visible';\n                },\n                end: function () {\n                    tickIndex += 1;\n                    _this.elementLabelAnimation(document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + tickIndex), axisIndex, tickIndex, gauge);\n                    var axisElement = document.getElementById(_this.gauge.element.id + '_Axis_Labels_' + axisIndex);\n                    if (_this.gauge.axes[axisIndex].showLastLabel && parseInt(element.id.split('Label_')[1], 10) === (axisElement.childElementCount - 2)) {\n                        element = document.getElementById(_this.gauge.element.id + '_Axis_' + axisIndex + '_Label_' + (axisElement.childElementCount - 1));\n                        if (element) {\n                            element.style.visibility = 'visible';\n                        }\n                        axisElement.style.visibility = 'visible';\n                    }\n                    if (_this.rangeAnimationCount === 0 && (_this.axisOption[axisIndex].axisLabelCount - 1) === tickIndex) {\n                        axisElement.style.visibility = 'visible';\n                        _this.rangeAnimationCount++;\n                        _this.rangeAnimation(gauge);\n                    }\n                }\n            });\n        }\n    };\n    AxisLayoutPanel.prototype.axisLineCalculation = function (axisElement, axis, value, gauge) {\n        var checkMinValue = value === axis.visibleRange.min;\n        var location = gauge.midPoint;\n        var isClockWise = axis.direction === 'ClockWise';\n        var axisWidth = axis.lineStyle.width / 2;\n        var startAngle = (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getAngleFromValue)(axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.min, axis.startAngle, axis.endAngle, isClockWise);\n        var endAngle = (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getAngleFromValue)(value, axis.visibleRange.max, axis.visibleRange.min, axis.startAngle, axis.endAngle, isClockWise);\n        if (isClockWise) {\n            if (startAngle > endAngle) {\n                endAngle = Math.round(startAngle) === Math.round(endAngle) && !checkMinValue ?\n                    Math.round(endAngle) - 0.5 : Math.round(endAngle);\n            }\n            else {\n                endAngle = startAngle === endAngle && !checkMinValue ? endAngle + 1 : endAngle;\n            }\n        }\n        else {\n            endAngle = Math.round(startAngle) === Math.round(endAngle) && !checkMinValue ?\n                [startAngle, startAngle = (endAngle > startAngle ? endAngle + 0.5 : endAngle - 1)][0]\n                : [startAngle, startAngle = endAngle][0];\n        }\n        axisElement.setAttribute('d', (0,_utils_helper_pointer_renderer__WEBPACK_IMPORTED_MODULE_6__.getCompleteArc)(location, startAngle, endAngle, (axis.currentRadius + axisWidth), (axis.currentRadius - axisWidth), checkMinValue));\n    };\n    AxisLayoutPanel.prototype.axisLineAnimation = function (axisIndex, duration, gauge) {\n        var _this = this;\n        // eslint-disable-next-line\n        var axis = gauge.axes[axisIndex];\n        this.prevAnimatedMajorTickValue.push(axis.minimum);\n        this.prevAnimatedMinorTickValue.push(axis.minimum);\n        this.prevAnimatedMinorTickIndex.push(0);\n        this.prevAnimatedMajorTickIndex.push(0);\n        this.prevAnimatedTickType = 'major';\n        if (this.axisOption[axisIndex].isAxisLine) {\n            var axisElement_1 = document.getElementById(gauge.element.id + '_AxisLine_' + axisIndex);\n            var start_1 = axis.visibleRange.min;\n            var end_1 = axis.visibleRange.max;\n            var pointerValue_1;\n            var timeStamp_1;\n            var val_1 = Math.abs(start_1 - end_1);\n            new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(axisElement_1, {\n                duration: duration,\n                progress: function (arg) {\n                    axisElement_1.style.visibility = 'visible';\n                    axisElement_1.setAttribute('fill', axis.lineStyle.color);\n                    axisElement_1.setAttribute('stroke-width', '0');\n                    timeStamp_1 = (arg.timeStamp / arg.duration);\n                    pointerValue_1 = end_1 > start_1 ? start_1 + (timeStamp_1 * val_1) : start_1 - (timeStamp_1 * val_1);\n                    _this.axisLineCalculation(axisElement_1, axis, pointerValue_1, gauge);\n                },\n                end: function () {\n                    axisElement_1.setAttribute('fill', 'transparent');\n                    axisElement_1.setAttribute('stroke-width', axis.lineStyle.width.toString());\n                    axisElement_1.setAttribute('d', (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.getPathArc)(gauge.midPoint, axis.startAngle - 90, axis.endAngle - 90, axis.currentRadius));\n                    axisElement_1.style.visibility = 'visible';\n                    _this.axisAnimation(axisIndex, duration, gauge);\n                }\n            });\n        }\n        else if (this.axisOption[axisIndex].isMajorTick || this.axisOption[axisIndex].isMinorTick) {\n            if (this.axisOption[axisIndex].isMajorTick || (this.axisOption[axisIndex].isMajorTick &&\n                this.axisOption[axisIndex].isMinorTick)) {\n                this.tickElementAnimation(document.getElementById(gauge.element.id + '_Axis_Major_TickLine_' + axisIndex + '_' + 0), document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + 0), duration, axisIndex, this.axisOption[axisIndex].isMajorTick &&\n                    this.axisOption[axisIndex].isMinorTick\n                    ? 0 : -1, 'major', this.axisOption[axisIndex], gauge);\n            }\n            else if (this.axisOption[axisIndex].isMinorTick) {\n                this.tickElementAnimation(document.getElementById(gauge.element.id + '_Axis_Minor_TickLine_' + axisIndex + '_' + 0), document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + 0), duration, axisIndex, -1, 'minor', this.axisOption[axisIndex], gauge);\n            }\n        }\n        else if (!this.axisOption[axisIndex].isAxisLine) {\n            this.labelRangeAnimation(gauge, axisIndex);\n        }\n    };\n    AxisLayoutPanel.prototype.axisAnimation = function (axisIndex, duration, gauge) {\n        var _this = this;\n        var axisElement = document.getElementById(gauge.element.id + '_AxisLine_' + axisIndex);\n        var axisOption = this.axisOption[axisIndex];\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(axisElement, {\n            duration: (this.axisOption[axisIndex].majorTickCount === 0 ? 0\n                : duration / this.axisOption[axisIndex].majorTickCount),\n            progress: function () {\n                axisElement.style.visibility = 'visible';\n            },\n            end: function () {\n                if (axisOption.isMajorTick) {\n                    _this.tickElementAnimation(document.getElementById(gauge.element.id + '_Axis_Major_TickLine_' + axisIndex + '_' + 0), document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + 0), duration, axisIndex, axisOption.isMajorTick && axisOption.isMinorTick ? 0 : -1, 'major', axisOption, gauge);\n                }\n                else if (axisOption.isMinorTick) {\n                    _this.tickElementAnimation(document.getElementById(gauge.element.id + '_Axis_Minor_TickLine_' + axisIndex + '_' + 0), document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + 0), duration, axisIndex, -1, 'minor', axisOption, gauge);\n                }\n                _this.labelRangeAnimation(gauge, axisIndex);\n            }\n        });\n    };\n    AxisLayoutPanel.prototype.tickElementAnimation = function (tickElement, labelElement, duration, axisIndex, \n    // eslint-disable-next-line\n    tickIndex, type, axis, gauge) {\n        var _this = this;\n        if (tickElement && this.gauge.isAnimationProgress) {\n            new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(tickElement, {\n                duration: (axis.isMinorTick ? axis.minorTickCount === 0 ? 0\n                    : (duration / axis.minorTickCount) / this.allowAxisCount[axisIndex] :\n                    axis.majorTickCount === 0 ? 0 : (duration / axis.majorTickCount) / this.allowAxisCount[axisIndex]),\n                progress: function () {\n                    tickElement.style.visibility = 'visible';\n                },\n                end: function () {\n                    if (axis.isMajorTick && axis.isMinorTick && gauge.allowLoadingAnimation && _this.gauge.isAnimationProgress) {\n                        tickElement.style.visibility = 'visible';\n                        var currentTickValue = parseFloat(tickElement.getAttribute('data-interval'));\n                        _this.prevAnimatedTickType = type;\n                        if (type === 'major') {\n                            _this.prevAnimatedMajorTickValue[axisIndex] = currentTickValue;\n                            _this.prevAnimatedMajorTickIndex[axisIndex] = tickIndex;\n                        }\n                        else {\n                            _this.prevAnimatedMinorTickValue[axisIndex] = currentTickValue;\n                            _this.prevAnimatedMinorTickIndex[axisIndex] = tickIndex;\n                        }\n                        var minorTickInterval = (gauge.axes[axisIndex].minorTicks.interval != null\n                            ? gauge.axes[axisIndex].minorTicks.interval :\n                            (gauge.axes[axisIndex].visibleRange.interval / 2));\n                        var minorTickValue = minorTickInterval < gauge.axes[axisIndex].visibleRange.interval ? currentTickValue +\n                            minorTickInterval : _this.prevAnimatedMinorTickValue[axisIndex] + minorTickInterval;\n                        var majorTickValue = _this.prevAnimatedMajorTickValue[axisIndex]\n                            + gauge.axes[axisIndex].visibleRange.interval;\n                        type = minorTickValue < majorTickValue ? 'minor' : 'major';\n                        if (type === 'major' && axis.majorTickCount !== axis.minorTickCount && tickIndex !== 0 && _this.prevAnimatedTickType === 'minor') {\n                            tickIndex = _this.prevAnimatedMajorTickIndex[axisIndex];\n                        }\n                        if (type === 'minor' && axis.majorTickCount !== axis.minorTickCount && tickIndex !== 0 && _this.prevAnimatedTickType === 'major') {\n                            tickIndex = _this.prevAnimatedMinorTickIndex[axisIndex];\n                        }\n                        tickIndex = type === 'minor' ? axis.majorTickCount === axis.minorTickCount ? tickIndex : (currentTickValue ===\n                            _this.prevAnimatedMajorTickValue[axisIndex] ? tickIndex : tickIndex + 1) : tickIndex + 1;\n                        tickElement = type === 'minor' ? document.getElementById(gauge.element.id + '_Axis_Minor_TickLine_' + axisIndex + '_' + tickIndex) :\n                            document.getElementById(gauge.element.id + '_Axis_Major_TickLine_' + axisIndex + '_' + tickIndex);\n                        labelElement = type === 'minor' ? null : document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + tickIndex);\n                        if (type === 'major' || tickIndex === 0) {\n                            _this.labelElementAnimation(document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + tickIndex), axisIndex);\n                        }\n                        _this.tickElementAnimation(tickElement, labelElement, duration, axisIndex, tickIndex, type, axis, gauge);\n                        if (_this.rangeAnimationCount === 0 && type === 'minor' && (tickIndex === axis.minorTickCount - 1 || tickIndex === axis.minorTickCount) && (gauge.axes.length - 1) === axisIndex) {\n                            _this.rangeAnimationCount++;\n                            _this.rangeAnimation(gauge);\n                        }\n                    }\n                    else if (gauge.allowLoadingAnimation && axis.isMajorTick && _this.gauge.isAnimationProgress) {\n                        tickElement.style.visibility = 'visible';\n                        type = 'major';\n                        tickIndex = tickIndex + 1;\n                        tickElement = document.getElementById(gauge.element.id + '_Axis_Major_TickLine_' + axisIndex + '_' + tickIndex);\n                        labelElement = document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + tickIndex);\n                        _this.tickElementAnimation(tickElement, labelElement, duration, axisIndex, tickIndex, type, axis, gauge);\n                        if (type === 'major' || tickIndex === 0) {\n                            _this.labelElementAnimation(document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + tickIndex), axisIndex);\n                        }\n                        if (_this.rangeAnimationCount === 0 && type === 'major' && tickIndex === axis.majorTickCount - 1 && (gauge.axes.length - 1) === axisIndex) {\n                            _this.rangeAnimationCount++;\n                            _this.rangeAnimation(gauge);\n                        }\n                    }\n                    else if (gauge.allowLoadingAnimation && _this.gauge.isAnimationProgress && axis.isMinorTick) {\n                        tickElement.style.visibility = 'visible';\n                        type = 'minor';\n                        tickIndex = tickIndex + 1;\n                        tickElement = document.getElementById(gauge.element.id + '_Axis_Minor_TickLine_' + axisIndex + '_' + tickIndex);\n                        labelElement = document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + tickIndex);\n                        _this.tickElementAnimation(tickElement, labelElement, duration, axisIndex, tickIndex, type, axis, gauge);\n                        if (type === 'minor') {\n                            _this.labelElementAnimation(document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + tickIndex), axisIndex);\n                        }\n                        if (_this.rangeAnimationCount === 0 && type === 'minor' && tickIndex === axis.minorTickCount - 1 && (gauge.axes.length - 1) === axisIndex) {\n                            _this.rangeAnimationCount++;\n                            _this.rangeAnimation(gauge);\n                        }\n                    }\n                }\n            });\n        }\n        this.labelRangeAnimation(gauge, axisIndex);\n    };\n    AxisLayoutPanel.prototype.labelRangeAnimation = function (gauge, axisIndex) {\n        var options = this.axisOption[axisIndex];\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(options)) {\n            if (!options.isMajorTick && !options.isMinorTick && options.isAxisLabel) {\n                if (options.axisLabelCount > 0) {\n                    if (gauge.axes[axisIndex].labelStyle.hiddenLabel === 'First') {\n                        this.elementLabelAnimation(document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + 1), axisIndex, 0, gauge);\n                    }\n                    else {\n                        this.elementLabelAnimation(document.getElementById(gauge.element.id + '_Axis_' + axisIndex + '_Label_' + 0), axisIndex, 0, gauge);\n                    }\n                }\n            }\n            else if ((this.rangeAnimationCount === 0 && !options.isMajorTick &&\n                !options.isMinorTick && !options.isAxisLabel && options.isRange)\n                || this.rangeAnimationCount === 0 && this.gauge.isAnimationProgress\n                    && !options.isMajorTick && !options.isMinorTick && !options.isAxisLabel && options.isRange) {\n                this.rangeAnimationCount++;\n                this.rangeAnimation(gauge);\n            }\n        }\n    };\n    AxisLayoutPanel.prototype.rangeAnimation = function (gauge) {\n        for (var j = 0; j < gauge.axes.length; j++) {\n            var rangesElement = document.getElementById(gauge.element.id + '_Axis_Ranges_' + j);\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rangesElement) && gauge.allowLoadingAnimation) {\n                this.rangeElementAnimation(rangesElement, j, gauge);\n            }\n        }\n    };\n    AxisLayoutPanel.prototype.rangeElementAnimation = function (rangeElement, axisIndex, gauge) {\n        var _this = this;\n        var height = 0;\n        var opacity = 1;\n        var isRangeAbsent = rangeElement.childElementCount > 0 &&\n            gauge.axes[axisIndex].ranges[0].start !== gauge.axes[axisIndex].ranges[0].end;\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(rangeElement, {\n            duration: isRangeAbsent ? gauge.loadingAnimationDuration[axisIndex] : 0,\n            progress: function (args) {\n                if (args.timeStamp > args.delay) {\n                    height = ((args.timeStamp - args.delay) / args.duration);\n                    rangeElement['style']['opacity'] = (opacity * height);\n                }\n            },\n            end: function () {\n                rangeElement['style']['opacity'] = opacity;\n                var axisElement = document.getElementById(_this.gauge.element.id + '_Axis_Labels_' + axisIndex);\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axisElement)) {\n                    axisElement.style.visibility = 'visible';\n                }\n                if (gauge.allowLoadingAnimation && axisIndex === 0) {\n                    _this.axisOption = [];\n                    gauge.axes.map(function (axis, axisindex) {\n                        axis.pointers.map(function (pointer, pointerIndex) {\n                            var pointerElement = document.getElementById(gauge.element.id + '_Axis_' + axisindex + '_Pointer_' + pointerIndex);\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointerElement) && _this.gauge.isAnimationProgress) {\n                                pointer.previousValue = !_this.gauge.isPropertyChange ? axis.minimum : pointer.previousValue;\n                                gauge.gaugeAxisLayoutPanel.pointerRenderer.doPointerAnimation(pointerElement, pointer, axis, axisIndex);\n                            }\n                        });\n                        if (axis.pointers.length === 0 && _this.gauge.isAnimationProgress) {\n                            if (_this.gauge.loadingAnimationDuration[axisIndex] > 0 &&\n                                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(_this.gauge.annotationsModule)) {\n                                _this.gauge.annotationsModule.annotationAnimation(_this.gauge);\n                            }\n                        }\n                        else {\n                            _this.gauge.isOverAllAnimationComplete = true;\n                        }\n                    });\n                }\n            }\n        });\n    };\n    AxisLayoutPanel.prototype.durationSplitUp = function (duration, axesElements) {\n        var splitUpCount = 0;\n        this.gauge.loadingAnimationDuration = [];\n        for (var i = 0; i < axesElements.childElementCount; i++) {\n            splitUpCount = 0;\n            var axisCount = 0;\n            var element = axesElements.children[i];\n            var isAxisLine = false;\n            var isMajorTick = false;\n            var majorTickCount = 0;\n            var labelCount = 0;\n            var isMinorTick = false;\n            var minorTickCount = 0;\n            var isLabel = false;\n            var isrange = false;\n            var isPointer = false;\n            for (var j = 0; j < element.childElementCount; j++) {\n                var elementId = element.children[j]['id'];\n                if (elementId.indexOf('_AxisLine_') > 0) {\n                    isAxisLine = true;\n                    splitUpCount++;\n                }\n                else if (elementId.indexOf('MajorTickLines') > 0) {\n                    isMajorTick = true;\n                    axisCount++;\n                    majorTickCount = element.children[j].childElementCount;\n                    splitUpCount++;\n                }\n                else if (elementId.indexOf('MinorTickLines') > 0) {\n                    isMinorTick = true;\n                    axisCount++;\n                    minorTickCount = element.children[j].childElementCount;\n                    if (!isMajorTick) {\n                        splitUpCount++;\n                    }\n                }\n                else if (elementId.indexOf('_Axis_Labels_') > 0) {\n                    isLabel = true;\n                    axisCount++;\n                    labelCount = element.children[j].childElementCount;\n                    if (!isMajorTick && !isMinorTick && this.gauge.axes[i].labelStyle.font.size != null &&\n                        (this.gauge.axes[i].labelStyle.font.size !== '0px' && this.gauge.axes[i].labelStyle.font.size !== '0')) {\n                        splitUpCount++;\n                    }\n                }\n                else if (elementId.indexOf('_Axis_Ranges_') > 0) {\n                    isrange = true;\n                    if (this.gauge.axes[i].ranges.length === 1\n                        && (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.gauge.axes[i].ranges)\n                            && this.gauge.axes[i].ranges[0].start === 0\n                            && this.gauge.axes[i].ranges[0].end === 0)) {\n                        splitUpCount++;\n                    }\n                }\n                else if (elementId.indexOf('_Axis_Pointers_') > 0) {\n                    isPointer = true;\n                    if (this.gauge.axes[i].pointers.length > 0 && this.gauge.axes[i].pointers.length !== 1 &&\n                        this.gauge.axes[i].pointers[0].value !== this.gauge.axes[i].minimum) {\n                        splitUpCount++;\n                    }\n                }\n            }\n            this.allowAxisCount.push(axisCount === 0 ? 1 : axisCount);\n            this.axisOption.push({\n                isAxisLine: isAxisLine, isMajorTick: isMajorTick, isMinorTick: isMinorTick,\n                isAxisLabel: isLabel, isPointer: isPointer, isRange: isrange,\n                axisLabelCount: labelCount, majorTickCount: majorTickCount, minorTickCount: minorTickCount\n            });\n            isAxisLine = false;\n            isMajorTick = false;\n            majorTickCount = 0;\n            isMinorTick = false;\n            labelCount = 0;\n            minorTickCount = 0;\n            isLabel = false;\n            isrange = false;\n            isPointer = false;\n            if (this.gauge.axes[i].annotations != null\n                && this.gauge.axes[i].annotations.length > 0\n                && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.gauge.annotationsModule)) {\n                splitUpCount++;\n            }\n            this.gauge.loadingAnimationDuration.push(splitUpCount === 0 ? duration : duration / splitUpCount);\n        }\n    };\n    /**\n     * Calculate maximum label width for the axis.\n     *\n     * @param {CircularGauge} gauge - Specifies the instance of the gauge.\n     * @param {Axis} axis - Specifies the axis.\n     * @returns {void}\n     */\n    AxisLayoutPanel.prototype.getMaxLabelWidth = function (gauge, axis) {\n        axis.maxLabelSize = new _utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.Size(0, 0);\n        var textStyle = {\n            size: axis.labelStyle.font.size || this.gauge.themeStyle.fontSize,\n            color: axis.labelStyle.font.color || this.gauge.themeStyle.labelColor,\n            fontFamily: axis.labelStyle.font.fontFamily || this.gauge.themeStyle.labelFontFamily,\n            fontWeight: axis.labelStyle.font.fontWeight || this.gauge.themeStyle.fontWeight,\n            fontStyle: axis.labelStyle.font.fontStyle,\n            opacity: axis.labelStyle.font.opacity\n        };\n        for (var _i = 0, _a = axis.visibleLabels; _i < _a.length; _i++) {\n            var label = _a[_i];\n            label.size = (0,_utils_helper_common__WEBPACK_IMPORTED_MODULE_1__.measureText)(label.text, textStyle);\n            axis.maxLabelSize.width = label.size.width > axis.maxLabelSize.width ?\n                label.size.width : axis.maxLabelSize.width;\n            axis.maxLabelSize.height = label.size.height > axis.maxLabelSize.height ?\n                label.size.height : axis.maxLabelSize.height;\n        }\n    };\n    AxisLayoutPanel.prototype.destroy = function () {\n        this.gauge = null;\n        this.farSizes = [];\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.axisRenderer)) {\n            this.axisRenderer.destroy();\n        }\n        this.axisRenderer = null;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.pointerRenderer)) {\n            this.pointerRenderer.destroy();\n        }\n        this.pointerRenderer = null;\n        this.axisOption = null;\n        this.prevAnimatedMajorTickValue = null;\n        this.prevAnimatedMajorTickIndex = null;\n        this.prevAnimatedMinorTickIndex = null;\n        this.prevAnimatedMinorTickValue = null;\n        this.allowAxisCount = null;\n    };\n    return AxisLayoutPanel;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-circulargauge/src/circular-gauge/axes/axis-panel.js?");

/***/ })

}]);