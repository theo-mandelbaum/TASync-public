"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_circularchart3d_legend_legend_js-bde3bd0a"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/circularchart3d/legend/legend.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/circularchart3d/legend/legend.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CircularChart3DLegendSettings: () => (/* binding */ CircularChart3DLegendSettings),\n/* harmony export */   CircularChartLegend3D: () => (/* binding */ CircularChartLegend3D)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_model_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/model/base */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/base.js\");\n/* harmony import */ var _common_legend_legend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/legend/legend */ \"./node_modules/@syncfusion/ej2-charts/src/common/legend/legend.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/**\n * Circular 3D chart legend.\n */\n\n\n\n\n\n\n\n\n/**\n * Configures the legends in circular 3D charts.\n */\nvar CircularChart3DLegendSettings = /** @class */ (function (_super) {\n    __extends(CircularChart3DLegendSettings, _super);\n    function CircularChart3DLegendSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], CircularChart3DLegendSettings.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DLegendSettings.prototype, \"height\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DLegendSettings.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _common_model_base__WEBPACK_IMPORTED_MODULE_1__.Location)\n    ], CircularChart3DLegendSettings.prototype, \"location\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Auto')\n    ], CircularChart3DLegendSettings.prototype, \"position\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(8)\n    ], CircularChart3DLegendSettings.prototype, \"padding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DLegendSettings.prototype, \"itemPadding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Center')\n    ], CircularChart3DLegendSettings.prototype, \"alignment\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ fontFamily: null, size: null, fontStyle: null, fontWeight: null, color: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_1__.Font)\n    ], CircularChart3DLegendSettings.prototype, \"textStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], CircularChart3DLegendSettings.prototype, \"shapeHeight\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], CircularChart3DLegendSettings.prototype, \"shapeWidth\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _common_model_base__WEBPACK_IMPORTED_MODULE_1__.Border)\n    ], CircularChart3DLegendSettings.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ left: 0, right: 0, top: 0, bottom: 0 }, _common_model_base__WEBPACK_IMPORTED_MODULE_1__.Margin)\n    ], CircularChart3DLegendSettings.prototype, \"margin\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ left: 0, right: 0, top: 0, bottom: 0 }, _common_model_base__WEBPACK_IMPORTED_MODULE_1__.ContainerPadding)\n    ], CircularChart3DLegendSettings.prototype, \"containerPadding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(8)\n    ], CircularChart3DLegendSettings.prototype, \"shapePadding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('transparent')\n    ], CircularChart3DLegendSettings.prototype, \"background\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], CircularChart3DLegendSettings.prototype, \"opacity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], CircularChart3DLegendSettings.prototype, \"toggleVisibility\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], CircularChart3DLegendSettings.prototype, \"enableHighlight\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DLegendSettings.prototype, \"description\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(3)\n    ], CircularChart3DLegendSettings.prototype, \"tabIndex\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DLegendSettings.prototype, \"title\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ fontFamily: null, size: null, fontStyle: null, fontWeight: null, color: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_1__.Font)\n    ], CircularChart3DLegendSettings.prototype, \"titleStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Top')\n    ], CircularChart3DLegendSettings.prototype, \"titlePosition\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Normal')\n    ], CircularChart3DLegendSettings.prototype, \"textWrap\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Ellipsis')\n    ], CircularChart3DLegendSettings.prototype, \"textOverflow\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(100)\n    ], CircularChart3DLegendSettings.prototype, \"maximumTitleWidth\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], CircularChart3DLegendSettings.prototype, \"maximumLabelWidth\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], CircularChart3DLegendSettings.prototype, \"enablePages\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], CircularChart3DLegendSettings.prototype, \"isInversed\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], CircularChart3DLegendSettings.prototype, \"reverse\", void 0);\n    return CircularChart3DLegendSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `CircularChartLegend3D` module used to render the legend for a circular 3D chart.\n */\nvar CircularChartLegend3D = /** @class */ (function (_super) {\n    __extends(CircularChartLegend3D, _super);\n    /**\n     * Constructor for CircularChart3D legend.\n     *\n     * @param {CircularChart3D} chart - The chart instance to which the legend belongs.\n     */\n    function CircularChartLegend3D(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.library = _this;\n        _this.titleRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(0, chart.margin.top, 0, 0);\n        _this.addEventListener();\n        return _this;\n    }\n    /**\n     * Binds events for the legend module.\n     *\n     * @returns {void}\n     */\n    CircularChartLegend3D.prototype.addEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseEnd, this);\n        this.chart.on('click', this.click, this);\n    };\n    /**\n     * Unbinds events for the legend module.\n     *\n     * @returns {void}\n     */\n    CircularChartLegend3D.prototype.removeEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove);\n        this.chart.off('click', this.click);\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseEnd);\n    };\n    /**\n     * Handles mouse movement for the legend module.\n     *\n     * @param {MouseEvent} e - The mouse event.\n     * @returns {void}\n     */\n    CircularChartLegend3D.prototype.mouseMove = function (e) {\n        if (this.chart.legendSettings.visible && !this.chart.isTouch) {\n            this.move(e);\n            if (this.chart.circularChartHighlight3DModule && (this.chart.highlightMode !== 'None' || this.chart.legendSettings.enableHighlight)) {\n                var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_marker_',\n                    this.legendID + '_shape_', this.legendID + '_g_'];\n                var targetId = e.target.id;\n                for (var _i = 0, legendItemsId_1 = legendItemsId; _i < legendItemsId_1.length; _i++) {\n                    var id = legendItemsId_1[_i];\n                    if (targetId.indexOf(id) > -1) {\n                        if (this.chart.circularChartSelection3DModule) {\n                            this.chart.circularChartSelection3DModule.legendSelection(this.chart, e.target, e.type);\n                        }\n                        else if (this.chart.circularChartHighlight3DModule) {\n                            this.chart.circularChartHighlight3DModule.legendSelection(this.chart, e.target, e.type);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Handles mouse end for the legend module.\n     *\n     * @param {MouseEvent} e - The mouse event.\n     * @returns {void}\n     */\n    CircularChartLegend3D.prototype.mouseEnd = function (e) {\n        if (this.chart.legendSettings.visible && this.chart.isTouch) {\n            this.move(e);\n        }\n    };\n    /**\n     * Retrieves the legend options for the circular 3D chart.\n     *\n     * @param {CircularChart3D} chart - The circular 3D chart instance.\n     * @param {CircularChart3DSeries[]} series - The array of circular 3D series in the chart.\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.getLegendOptions = function (chart, series) {\n        this.legendCollections = [];\n        this.isRtlEnable = chart.enableRtl;\n        this.isReverse = !this.isRtlEnable && chart.legendSettings.reverse;\n        for (var i = 0; i < 1; i++) {\n            for (var _i = 0, _a = series[i].points; _i < _a.length; _i++) {\n                var point = _a[_i];\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y)) {\n                    this.legendCollections.push(new _common_legend_legend__WEBPACK_IMPORTED_MODULE_2__.LegendOptions(point.x.toString(), point.color, series[i].legendShape, point.visible, 'Pie', series[0].legendImageUrl, null, null, point.index, series[i].index));\n                }\n            }\n            if (this.isReverse) {\n                this.legendCollections.reverse();\n            }\n        }\n    };\n    /**\n     * Calculates the legend bounds based on the available size, existing legend bounds, and legend settings.\n     *\n     * @param {Size} availableSize - The available size for the legend.\n     * @param {Rect} legendBounds - The existing bounds of the legend.\n     * @param {LegendSettingsModel} legend - The legend settings model.\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.getLegendBounds = function (availableSize, legendBounds, legend) {\n        this.calculateLegendTitle(legend, legendBounds);\n        this.isTitle = legend.title ? true : false;\n        var extraWidth = 0;\n        var extraHeight = 0;\n        var legendOption;\n        this.chartRowCount = 1;\n        this.rowHeights = [];\n        this.columnHeights = [];\n        this.pageHeights = [];\n        var padding = legend.padding;\n        var titlePosition = legend.titlePosition;\n        var titlePlusArrowSpace = 0;\n        var arrowWidth = this.arrowWidth;\n        var arrowHeight = legend.enablePages ? 0 : this.arrowHeight;\n        if (!this.isVertical) {\n            extraHeight = !legend.height ? ((availableSize.height / 100) * 5) : 0;\n        }\n        else {\n            extraWidth = !legend.width ? ((availableSize.width / 100) * 5) : 0;\n        }\n        legendBounds.width += extraWidth;\n        legendBounds.height += extraHeight;\n        var shapePadding = legend.shapePadding;\n        var maximumWidth = legend.maximumLabelWidth ? legend.maximumLabelWidth : 0;\n        var shapeWidth = legend.shapeWidth;\n        var rowWidth = 0;\n        var columnCount = 0;\n        var rowCount = 0;\n        var columnWidth = [];\n        var pageWidth = [];\n        var pageRowWidth = 0;\n        var previousRowCount = 0;\n        var columnHeight = 0;\n        var legendWidth = 0;\n        var titleHeight = 0;\n        this.maxItemHeight = Math.max((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)('MeasureText', legend.textStyle, this.chart.themeStyle.legendLabelFont).height, legend.shapeHeight);\n        var legendEventArgs;\n        var render = false;\n        for (var i = 0; i < this.legendCollections.length; i++) {\n            legendOption = this.legendCollections[i];\n            legendEventArgs = {\n                fill: legendOption.fill, text: legendOption.text, shape: legendOption.shape,\n                name: 'legendRender', cancel: false\n            };\n            this.chart.trigger('legendRender', legendEventArgs);\n            legendOption.render = !legendEventArgs.cancel;\n            legendOption.text = ((legendEventArgs.text.indexOf('&') > -1) ?\n                this.convertHtmlEntities(legendEventArgs.text) : legendEventArgs.text);\n            legendOption.fill = legendEventArgs.fill;\n            legendOption.shape = legendEventArgs.shape;\n            legendOption.textSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(legendOption.text, legend.textStyle, this.chart.themeStyle.legendLabelFont);\n            if (legendOption.render && legendOption.text !== '') {\n                render = true;\n                legendWidth = shapeWidth + shapePadding + (legend.maximumLabelWidth ? legend.maximumLabelWidth :\n                    legendOption.textSize.width) + (!this.isVertical ? (i === 0) ? padding : this.itemPadding : padding);\n                this.getLegendHeight(legendOption, legend, legendBounds, rowWidth, this.maxItemHeight, padding);\n                if (this.isVertical) {\n                    columnHeight += legendOption.textSize.height + ((i === 0) ? padding : this.itemPadding);\n                    if (columnHeight + this.itemPadding + (arrowHeight / this.pageButtonSize) > (legendBounds.height)) {\n                        rowWidth = rowWidth + maximumWidth;\n                        pageRowWidth = this.getPageWidth(pageWidth);\n                        this.totalPages = Math.max(rowCount, this.totalPages || 1);\n                        if ((rowWidth - pageRowWidth + legendWidth) > legendBounds.width) {\n                            pageWidth.push(rowWidth - pageRowWidth);\n                            rowCount = this.rowHeights.length;\n                            previousRowCount = rowCount;\n                        }\n                        else {\n                            rowCount = previousRowCount;\n                        }\n                        columnWidth.push(maximumWidth);\n                        maximumWidth = 0;\n                        columnHeight = legendOption.textSize.height + padding;\n                        columnCount++;\n                    }\n                    this.columnHeights[columnCount] = (this.columnHeights[columnCount] ?\n                        this.columnHeights[columnCount] : 0) +\n                        legendOption.textSize.height + ((i === 0) ? padding : this.itemPadding);\n                    maximumWidth = Math.max(legendWidth, maximumWidth);\n                    this.rowHeights[rowCount] = Math.max((this.rowHeights[rowCount] ?\n                        this.rowHeights[rowCount] : 0), legendOption.textSize.height);\n                    rowCount++;\n                }\n                else {\n                    if (!legend.enablePages) { // For new legend navigation support\n                        titlePlusArrowSpace = this.isTitle && titlePosition !== 'Top' ? this.legendTitleSize.width + this.fivePixel : 0;\n                        titlePlusArrowSpace += arrowWidth;\n                    }\n                    rowWidth = rowWidth + legendWidth;\n                    if (legendBounds.width < (padding + rowWidth + titlePlusArrowSpace)) {\n                        maximumWidth = Math.max(maximumWidth, (rowWidth + padding + titlePlusArrowSpace - legendWidth));\n                        if (rowCount === 0 && (legendWidth !== rowWidth)) {\n                            rowCount = 1;\n                        }\n                        rowWidth = legendWidth;\n                        rowCount++;\n                        columnCount = 0;\n                    }\n                    var len = rowCount ? (rowCount - 1) : rowCount;\n                    this.rowHeights[len] = Math.max((this.rowHeights[len] ? this.rowHeights[len] : 0), legendOption.textSize.height);\n                    this.columnHeights[columnCount] = (this.columnHeights[columnCount] ?\n                        this.columnHeights[columnCount] : 0) +\n                        legendOption.textSize.height + padding;\n                    columnCount++;\n                }\n            }\n        }\n        titleHeight = titlePosition === 'Top' ? this.legendTitleSize.height : 0;\n        if (this.isVertical) {\n            rowWidth = rowWidth + maximumWidth;\n            this.isPaging = legendBounds.width < (rowWidth + padding);\n            columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;\n            columnHeight = Math.max(columnHeight, ((this.totalPages || 1) * (this.maxItemHeight + padding)) + padding + arrowHeight);\n            this.isPaging = this.isPaging && (this.totalPages > 1);\n            columnWidth.push(maximumWidth);\n        }\n        else {\n            this.totalPages = rowCount;\n            columnHeight = Math.max.apply(null, this.columnHeights) + padding + arrowHeight + titleHeight;\n            this.isPaging = legendBounds.height < columnHeight;\n            columnHeight = !legend.enablePages && this.isPaging ? (this.maxItemHeight + padding) + padding + titleHeight : columnHeight;\n            columnHeight = Math.max(columnHeight, (this.maxItemHeight + padding) + padding + titleHeight);\n            if (!this.isPaging) { // For title left and right position\n                rowWidth += this.isTitle && titlePosition !== 'Top' ? (this.fivePixel + this.legendTitleSize.width + this.fivePixel) : 0;\n            }\n        }\n        this.maxColumns = 0; // initialization for max columns\n        var width = this.isVertical ? this.getMaxColumn(columnWidth, legendBounds.width, padding, rowWidth + padding) :\n            Math.max(rowWidth + padding, maximumWidth);\n        if (render) { // if any legends not skipped in event check\n            this.setBounds(width, columnHeight, legend, legendBounds);\n        }\n        else {\n            this.setBounds(0, 0, legend, legendBounds);\n        }\n    };\n    /**\n     * Calculates the total width by summing up the values in the provided array of page widths.\n     *\n     * @param {number[]} pageWidth - An array containing individual page widths.\n     * @returns {number} - The total width calculated as the sum of page widths.\n     * @private\n     */\n    CircularChartLegend3D.prototype.getPageWidth = function (pageWidth) {\n        var sum = 0;\n        for (var i = 0; i < pageWidth.length; i++) {\n            sum += pageWidth[i];\n        }\n        return sum;\n    };\n    /**\n     * Calculates the legend height based on the provided legend options, legend settings, bounds, row width,\n     * legend height, and padding values.\n     *\n     * @param {LegendOptions} option - The legend options containing necessary information.\n     * @param {LegendSettingsModel} legend - The legend settings model.\n     * @param {Rect} bounds - The bounds of the legend.\n     * @param {number} rowWidth - The width of the legend row.\n     * @param {number} legendHeight - The height of the legend.\n     * @param {number} padding - The padding value for additional space.\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.getLegendHeight = function (option, legend, bounds, rowWidth, legendHeight, padding) {\n        var legendWidth = option.textSize.width;\n        var textPadding = legend.shapePadding + (padding * 2) + legend.shapeWidth;\n        switch (legend.textWrap) {\n            case 'Wrap':\n            case 'AnyWhere':\n                if (legendWidth > legend.maximumLabelWidth || legendWidth + rowWidth > bounds.width) {\n                    option.textCollection = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.textWrap)(option.text, (legend.maximumLabelWidth ? Math.min(legend.maximumLabelWidth, (bounds.width - textPadding)) :\n                        (bounds.width - textPadding)), legend.textStyle, this.chart.enableRtl, null, null, this.chart.themeStyle.legendLabelFont);\n                }\n                else {\n                    option.textCollection.push(option.text);\n                }\n                option.textSize.height = (legendHeight * option.textCollection.length);\n                break;\n        }\n    };\n    /**\n     * Converts HTML entities in the given legend text to their corresponding normal string values.\n     *\n     * @param {string} legendText - The legend text containing HTML entities.\n     * @returns {string} - The string with HTML entities converted to their normal values.\n     * @private\n     */\n    CircularChartLegend3D.prototype.convertHtmlEntities = function (legendText) {\n        var text = (legendText).replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>').replace('&quot;', '\"').replace('&nbsp;', ' ').replace('&cent;', '¢').replace('&pound;', '£').replace('&yen;', '¥').replace('&euro;', '€').replace('&copy;', '©').replace('&reg;', '®');\n        text = (text).replace('&#38;', '&').replace('&#60;', '<').replace('&#62;', '>').replace('&#34;', '\"').replace('&#160;', ' ').\n            replace('&#162;', '¢').replace('&#163;', '£').replace('&#165;', '¥').replace('&#8364;', '€').replace('&#169;', '©').replace('&#174;', '®');\n        return text;\n    };\n    /**\n     * Retrieves the maximum column value for a given set of columns based on the specified width, padding, and row width.\n     *\n     * @param {number[]} columns - The array of column values to find the maximum from.\n     * @param {number} width - The width parameter used in the calculation.\n     * @param {number} padding - The padding value for additional space.\n     * @param {number} rowWidth - The width of the legend row.\n     * @returns {number} - The maximum column value calculated from the provided array.\n     * @private\n     */\n    CircularChartLegend3D.prototype.getMaxColumn = function (columns, width, padding, rowWidth) {\n        var maxPageColumn = padding;\n        this.maxColumnWidth = Math.max.apply(null, columns);\n        for (var i = 0; i < columns.length; i++) {\n            maxPageColumn += this.maxColumnWidth;\n            this.maxColumns++;\n            if (maxPageColumn + padding > width) {\n                maxPageColumn -= this.maxColumnWidth;\n                this.maxColumns--;\n                break;\n            }\n        }\n        this.isPaging = (maxPageColumn < rowWidth) && (this.totalPages > 1);\n        if (maxPageColumn === padding) {\n            maxPageColumn = width;\n        }\n        this.maxColumns = Math.max(1, this.maxColumns);\n        this.maxWidth = maxPageColumn;\n        var columnWidth = this.maxColumnWidth + padding;\n        var prevPage = 0;\n        var columnCount = this.columnHeights.length;\n        if (this.isPaging && this.isVertical) {\n            for (var i = 1; i < columnCount; i++) {\n                columnWidth += (this.maxColumnWidth + padding);\n                if (columnWidth > width) {\n                    this.pageHeights.push(((prevPage !== i - 1) ? Math.max.apply(null, this.columnHeights.slice(prevPage, i - 1)) :\n                        this.columnHeights[prevPage]));\n                    columnWidth = this.maxColumnWidth + padding;\n                    prevPage = i;\n                }\n            }\n            this.pageHeights.push(((prevPage !== columnCount - 1) ?\n                Math.max.apply(null, this.columnHeights.slice(prevPage, columnCount - 1)) : this.columnHeights[prevPage]));\n            this.totalPages = this.pageHeights.length;\n        }\n        return maxPageColumn;\n    };\n    /**\n     * Calculates the available width from the legend's x position.\n     *\n     * @param {number} tx - The x position of the legend.\n     * @param {number} width - The width of the legend.\n     * @returns {number} - The available width of the legend.\n     */\n    CircularChartLegend3D.prototype.getAvailWidth = function (tx, width) {\n        if (this.isVertical) {\n            width = this.maxWidth;\n        }\n        else if (!this.isVertical && this.isPaging && !this.legend.enablePages) {\n            return width - tx - this.fivePixel;\n        }\n        return width - ((this.legend.padding * 2) + this.legend.shapeWidth + this.legend.shapePadding);\n    };\n    /**\n     * Determines the legend rendering locations from legend items.\n     *\n     * @param {LegendOptions} legendOption - The current legend option.\n     * @param {ChartLocation} start - The start location of the legend.\n     * @param {number} textPadding - The text padding of the legend text.\n     * @param {LegendOptions} prevLegend - The previous legend option.\n     * @param {Rect} rect - The legend bounds.\n     * @param {number} count - The legend index.\n     * @param {number} firstLegend - The current legend location.\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.getRenderPoint = function (legendOption, start, textPadding, prevLegend, rect, count, firstLegend) {\n        var padding = this.legend.padding;\n        var previousLocation = prevLegend.location.y + this.maxItemHeight / 4 + (prevLegend.textCollection.length > 0 ?\n            ((prevLegend.textCollection.length - 1) * this.maxItemHeight) : 0);\n        if (this.isVertical) {\n            if (count === firstLegend || (previousLocation + legendOption.textSize.height + padding > (rect.y + rect.height))) {\n                legendOption.location.x = prevLegend.location.x + ((count === firstLegend) ? 0 : (!this.isRtlEnable) ?\n                    this.maxColumnWidth : -this.maxColumnWidth);\n                legendOption.location.y = start.y;\n                var textStartLoc = (this.legend.shapeWidth / 2) + padding;\n                this.pageXCollections.push(legendOption.location.x + ((!this.isRtlEnable) ? -textStartLoc : textStartLoc));\n            }\n            else {\n                legendOption.location.x = prevLegend.location.x;\n                legendOption.location.y = prevLegend.location.y + prevLegend.textSize.height + this.itemPadding;\n            }\n        }\n        else {\n            var textWidth = textPadding + (this.legend.maximumLabelWidth ?\n                this.legend.maximumLabelWidth : prevLegend.textSize.width);\n            var previousBound = prevLegend.location.x + ((!this.isRtlEnable) ? textWidth : -textWidth);\n            if (this.isWithinBounds(previousBound, (this.legend.maximumLabelWidth ? this.legend.maximumLabelWidth :\n                legendOption.textSize.width) + textPadding - this.itemPadding, rect, this.legend.shapeWidth / 2)) {\n                if (count !== firstLegend) {\n                    this.chartRowCount++;\n                }\n                legendOption.location.y = (count === firstLegend) ? prevLegend.location.y :\n                    prevLegend.location.y + this.rowHeights[(this.chartRowCount - 2)] + padding;\n                legendOption.location.x = start.x;\n            }\n            else {\n                legendOption.location.y = prevLegend.location.y;\n                legendOption.location.x = (count === firstLegend) ? prevLegend.location.x : previousBound;\n            }\n        }\n        var availablewidth = this.getAvailWidth(legendOption.location.x, this.legendBounds.width);\n        availablewidth = this.legend.maximumLabelWidth ? Math.min(this.legend.maximumLabelWidth, availablewidth) : availablewidth;\n        if (this.legend.textOverflow === 'Ellipsis' && this.legend.textWrap === 'Normal') {\n            legendOption.text = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.textTrim)(+availablewidth.toFixed(4), legendOption.text, this.legend.textStyle, this.chart.enableRtl, this.chart.themeStyle.legendLabelFont);\n        }\n    };\n    /**\n     * Checks whether the legend group is within the specified legend bounds, considering RTL (Right-to-Left) rendering.\n     *\n     * @param {number} previousBound - The previous legend bound value.\n     * @param {number} textWidth - The width of the legend text.\n     * @param {Rect} legendBounds - The bounds of the legend.\n     * @param {number} shapeWidth - The width of the legend shape.\n     * @returns {boolean} - Returns true if the legend group is within bounds; otherwise, returns false.\n     * @private\n     */\n    CircularChartLegend3D.prototype.isWithinBounds = function (previousBound, textWidth, legendBounds, shapeWidth) {\n        if (!this.isRtlEnable) {\n            return (previousBound + textWidth) > (legendBounds.x + legendBounds.width + shapeWidth);\n        }\n        else {\n            return (previousBound - textWidth) < (legendBounds.x - shapeWidth);\n        }\n    };\n    /**\n     * Determines the smart legend placement based on specified label bounds, legend bounds, and margin settings.\n     *\n     * @param {Rect} labelBound - The bounds of the legend label.\n     * @param {Rect} legendBound - The bounds of the legend.\n     * @param {MarginModel} margin - The margin settings for additional space.\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.getSmartLegendLocation = function (labelBound, legendBound, margin) {\n        var space;\n        switch (this.position) {\n            case 'Left':\n                space = ((labelBound.x - legendBound.width) - margin.left) / 2;\n                legendBound.x = (labelBound.x - legendBound.width) < margin.left ? legendBound.x :\n                    (labelBound.x - legendBound.width) - space;\n                break;\n            case 'Right':\n                space = ((this.chart.availableSize.width - margin.right) - (labelBound.x + labelBound.width + legendBound.width)) / 2;\n                legendBound.x = (labelBound.x + labelBound.width + legendBound.width) > (this.chart.availableSize.width - margin.right) ?\n                    legendBound.x : (labelBound.x + labelBound.width + space);\n                break;\n            case 'Top':\n                this.getTitleRect(this.chart);\n                space = ((labelBound.y - legendBound.height) - (this.titleRect.y + this.titleRect.height)) / 2;\n                legendBound.y = (labelBound.y - legendBound.height) < margin.top ? legendBound.y :\n                    (labelBound.y - legendBound.height) - space;\n                break;\n            case 'Bottom':\n                space = ((this.chart.availableSize.height - margin.bottom) - (labelBound.y + labelBound.height + legendBound.height)) / 2;\n                legendBound.y = labelBound.y + labelBound.height + legendBound.height > (this.chart.availableSize.height - margin.bottom) ?\n                    legendBound.y : (labelBound.y + labelBound.height) + space;\n                break;\n        }\n    };\n    /**\n     * Retrieves the title rectangle for the circular 3D chart.\n     *\n     * @param {CircularChart3D} circular - The circular 3D chart instance.\n     * @returns {Rect | null} - The title rectangle or null if no title is present.\n     * @private\n     */\n    CircularChartLegend3D.prototype.getTitleRect = function (circular) {\n        if (!circular.title) {\n            return null;\n        }\n        var titleSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(circular.title, circular.titleStyle, this.chart.themeStyle.legendTitleFont);\n        this.titleRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(circular.availableSize.width / 2 - titleSize.width / 2, circular.margin.top, titleSize.width, titleSize.height);\n    };\n    /**\n     * Retrieves the legend options based on the specified index from the given legend collections.\n     *\n     * @param {number} index - The index used to find the corresponding legend in the legend collections.\n     * @param {LegendOptions[]} legendCollections - The array of legend options containing legend information.\n     * @returns {LegendOptions | undefined} - The legend options corresponding to the specified index, or null if not found.\n     * @private\n     */\n    CircularChartLegend3D.prototype.legendByIndex = function (index, legendCollections) {\n        for (var _i = 0, legendCollections_1 = legendCollections; _i < legendCollections_1.length; _i++) {\n            var legend = legendCollections_1[_i];\n            if (legend.pointIndex === index) {\n                return legend;\n            }\n        }\n        return null;\n    };\n    /**\n     * Handles the click event to show or hide the legend.\n     *\n     * @param {Event} event - The event object representing the click event.\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.click = function (event) {\n        var targetId = event.target.id.indexOf('_chart_legend_g_') > -1 ?\n            event.target.firstChild['id'] : event.target.id;\n        var chart = this.chart;\n        var legendItemsId = [this.legendID + '_text_', this.legendID + '_shape_', this.legendID + '_shape_marker_'];\n        this.chart.animateSeries = false;\n        for (var _i = 0, legendItemsId_2 = legendItemsId; _i < legendItemsId_2.length; _i++) {\n            var id = legendItemsId_2[_i];\n            if (targetId.indexOf(id) > -1) {\n                var pointIndex = parseInt(targetId.split(id)[1], 10);\n                if (this.chart.legendSettings.toggleVisibility && !isNaN(pointIndex)) {\n                    var currentSeries = this.chart.visibleSeries[0];\n                    var point = currentSeries.points[pointIndex];\n                    var legendOption = this.legendByIndex(pointIndex, this.legendCollections);\n                    var legendClickArgs = {\n                        legendText: legendOption.text, legendShape: legendOption.shape,\n                        chart: chart,\n                        series: currentSeries, point: point,\n                        name: _common_model_constants__WEBPACK_IMPORTED_MODULE_5__.legendClick, cancel: false\n                    };\n                    this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_5__.legendClick, legendClickArgs);\n                    if (!legendClickArgs.cancel) {\n                        point.visible = !point.visible;\n                        legendOption.visible = point.visible;\n                        currentSeries.sumOfPoints += point.visible ? point.y : -point.y;\n                        chart.redraw = chart.enableAnimation;\n                        this.sliceVisibility(pointIndex, point.visible);\n                        chart.removeSeriesElements(chart);\n                        chart.removeSvg();\n                        var svgObject = document.getElementById(this.chart.element.id + '-svg-chart-3d');\n                        if (svgObject) {\n                            while (svgObject.childNodes.length > 0) {\n                                svgObject.removeChild(svgObject.firstChild);\n                            }\n                        }\n                        this.chart.circular3DPolygon = [];\n                        this.chart.visibleSeries[0].segments = [];\n                        this.chart.animateSeries = false;\n                        this.chart.calculateBounds();\n                        this.chart.renderElements();\n                        if (chart.circularChartHighlight3DModule && (chart.highlightMode !== 'None' || chart.legendSettings.enableHighlight)) {\n                            chart.circularChartHighlight3DModule.redrawSelection(chart);\n                        }\n                    }\n                }\n                else {\n                    if (this.chart.circularChartSelection3DModule && !isNaN(pointIndex)) {\n                        this.chart.circularChartSelection3DModule.legendSelection(this.chart, event.target, event.type);\n                    }\n                    else if (this.chart.circularChartHighlight3DModule && !isNaN(pointIndex)) {\n                        this.chart.circularChartHighlight3DModule.legendSelection(this.chart, event.target, event.type);\n                    }\n                }\n            }\n        }\n        if (targetId.indexOf(this.legendID + '_pageup') > -1) {\n            this.changePage(event, true);\n        }\n        else if (targetId.indexOf(this.legendID + '_pagedown') > -1) {\n            this.changePage(event, false);\n        }\n        chart.redraw = false;\n    };\n    /**\n     * Updates the visibility of a slice in the circular 3D chart based on the specified index and visibility status.\n     *\n     * @param {number} index - The index of the slice to be updated.\n     * @param {boolean} isVisible - The visibility status to be set for the slice.\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.sliceVisibility = function (index, isVisible) {\n        var sliceId = this.chart.element.id + '_Series_0_Point_';\n        if (this.chart.visibleSeries[0].dataLabel.visible) {\n            sliceId = this.chart.element.id + '_datalabel_Series_0_';\n            this.sliceAnimate((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(sliceId + 'g_' + index), isVisible);\n        }\n    };\n    /**\n     * Performs animation on the specified slice elements based on the visibility of a slice.\n     *\n     * @param {Element} element - The slice element to be animated.\n     * @param {boolean} isVisible - A boolean value indicating the visibility of the slice.\n     * @returns {void}\n     */\n    CircularChartLegend3D.prototype.sliceAnimate = function (element, isVisible) {\n        if (!element) {\n            return null;\n        }\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n            duration: 300,\n            delay: 0,\n            name: isVisible ? 'FadeIn' : 'FadeOut',\n            end: function (args) {\n                args.element.style.visibility = isVisible ? 'visible' : 'hidden';\n            }\n        });\n    };\n    /**\n     * Retrieves the module name for the circular 3D chart legend.\n     *\n     * @returns {string} - The module name.\n     */\n    CircularChartLegend3D.prototype.getModuleName = function () {\n        return 'CircularChartLegend3D';\n    };\n    /**\n     * Destroys the circular 3D chart legend.\n     *\n     * @returns {void}\n     * @private\n     */\n    CircularChartLegend3D.prototype.destroy = function () {\n        this.removeEventListener();\n    };\n    return CircularChartLegend3D;\n}(_common_legend_legend__WEBPACK_IMPORTED_MODULE_2__.BaseLegend));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/circularchart3d/legend/legend.js?");

/***/ })

}]);