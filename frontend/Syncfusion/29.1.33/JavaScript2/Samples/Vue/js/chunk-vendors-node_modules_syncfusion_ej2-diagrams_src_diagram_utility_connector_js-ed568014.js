"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_utility_connector_js-ed568014"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAngle: () => (/* binding */ findAngle),\n/* harmony export */   findConnectorPoints: () => (/* binding */ findConnectorPoints),\n/* harmony export */   findMargin: () => (/* binding */ findMargin),\n/* harmony export */   findPoint: () => (/* binding */ findPoint),\n/* harmony export */   getIntersection: () => (/* binding */ getIntersection),\n/* harmony export */   getIntersectionPoints: () => (/* binding */ getIntersectionPoints),\n/* harmony export */   getOppositeDirection: () => (/* binding */ getOppositeDirection),\n/* harmony export */   getOuterBounds: () => (/* binding */ getOuterBounds),\n/* harmony export */   getPortDirection: () => (/* binding */ getPortDirection),\n/* harmony export */   orthoConnection2Segment: () => (/* binding */ orthoConnection2Segment),\n/* harmony export */   swapBounds: () => (/* binding */ swapBounds)\n/* harmony export */ });\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _diagram_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _base_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* eslint-disable jsdoc/require-returns-check */\n\n\n\n\n\n\n\n/**\n * Connector modules are used to dock and update the connectors\n */\n/**\n * intermeditatePoints method\\\n *\n * @returns {  Function }    getFunction method .\\\n * @param {PointModel} element - provide the angle value.\n * @param {PointModel} layoutOrientation - provide the angle value.\n * @param {PointModel} lineDistribution - provide the angle value.\n * @private\n */\nfunction findConnectorPoints(element, layoutOrientation, lineDistribution) {\n    //const intermeditatePoints: PointModel[];\n    var sourcePoint;\n    if (element.type === 'Straight' || !element.sourceWrapper) {\n        sourcePoint = getSourcePoint(element);\n    }\n    else {\n        sourcePoint = element.sourceWrapper.corners.center;\n    }\n    // eslint-disable-next-line\n    var intermeditatePoints = terminateConnection(element, sourcePoint, element.targetPoint, layoutOrientation, lineDistribution);\n    setLineEndPoint(element, intermeditatePoints[0], false);\n    setLineEndPoint(element, intermeditatePoints[intermeditatePoints.length - 1], true);\n    return intermeditatePoints;\n}\n/**\n * getSourcePoint method\\\n *\n * @returns {  PointModel }    getFunction method .\\\n * @param {PointModel} element - provide the angle value.\n * @private\n */\nfunction getSourcePoint(element) {\n    var srcPoint;\n    if (element.sourcePortWrapper) {\n        var srcPort = element.sourcePortWrapper;\n        //const srcNode: DiagramElement = element.sourceWrapper;\n        var pt = { x: srcPort.offsetX, y: srcPort.offsetY };\n        //const direction: string = getPortDirection(pt, cornersPointsBeforeRotation(srcNode), srcNode.bounds, false);\n        srcPoint = pt;\n    }\n    else if (element.sourceID && element.sourceWrapper) {\n        if (element.targetWrapper) {\n            var sPoint = element.sourceWrapper.corners.center;\n            var tPoint = element.targetWrapper.corners.center;\n            srcPoint = getIntersection(element, element.sourceWrapper, sPoint, tPoint, false);\n        }\n        else {\n            srcPoint = element.sourcePoint;\n        }\n    }\n    else {\n        srcPoint = element.sourcePoint;\n    }\n    return srcPoint;\n}\n/**\n * getDirection method \\\n *\n * @returns { void }     getDirection method .\\\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.\n *\n * @private\n */\nfunction getDirection(source, target, layoutOrientation) {\n    if (layoutOrientation === 'LeftToRight') {\n        source.direction = source.direction ? source.direction : 'Right';\n        target.direction = target.direction ? target.direction : 'Left';\n    }\n    else if (layoutOrientation === 'RightToLeft') {\n        source.direction = source.direction ? source.direction : 'Left';\n        target.direction = target.direction ? target.direction : 'Right';\n    }\n    else if (layoutOrientation === 'TopToBottom') {\n        source.direction = source.direction ? source.direction : 'Bottom';\n        target.direction = target.direction ? target.direction : 'Top';\n    }\n    else if (layoutOrientation === 'BottomToTop') {\n        source.direction = source.direction ? source.direction : 'Top';\n        target.direction = target.direction ? target.direction : 'Bottom';\n    }\n}\n/**\n * terminateConnection method \\\n *\n * @returns { PointModel[] }     terminateConnection method .\\\n * @param {Connector} element - provide the element value.\n * @param {PointModel} srcPoint - provide the srcPoint value.\n * @param {PointModel} tarPoint - provide the tarPoint value.\n * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.\n * @param {boolean} lineDistribution - provide the lineDistribution value.\n *\n * @private\n */\nfunction terminateConnection(element, srcPoint, tarPoint, layoutOrientation, lineDistribution) {\n    var sourceNode = element.sourceWrapper;\n    var targetNode = element.targetWrapper;\n    var sourcePort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var srcCorner;\n    var tarCorner;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    var intermeditatePoints = [];\n    var segPoint;\n    var srcDir;\n    var tarDir;\n    var minSpace = findMargin(element);\n    var sourceMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var targetMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var source = { corners: srcCorner, point: srcPoint, direction: srcDir, margin: sourceMargin };\n    var target = { corners: tarCorner, point: tarPoint, direction: tarDir, margin: targetMargin };\n    var sourceCorners;\n    var targetCorners;\n    if (sourceNode !== undefined && targetNode !== undefined) {\n        sourceCorners = (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(sourceNode);\n        targetCorners = (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(targetNode);\n        source.corners = sourceNode.corners;\n        target.corners = targetNode.corners;\n    }\n    if (sourcePort !== undefined) {\n        var port = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n        if (sourcePort.connectionDirection === 'Left' || sourcePort.connectionDirection === 'Top' || sourcePort.connectionDirection === 'Bottom' || sourcePort.connectionDirection === 'Right') {\n            source.direction = sourcePort.connectionDirection;\n        }\n        else {\n            source.direction = getPortDirection(port, sourceCorners, sourceNode.bounds, false);\n        }\n    }\n    if (targetPort !== undefined) {\n        var tarPortPt = { x: targetPort.offsetX, y: targetPort.offsetY };\n        if (targetPort.connectionDirection === 'Left' || targetPort.connectionDirection === 'Right' || targetPort.connectionDirection === 'Bottom' || targetPort.connectionDirection === 'Top') {\n            target.direction = targetPort.connectionDirection;\n        }\n        else {\n            target.direction = getPortDirection(tarPortPt, targetCorners, targetNode.bounds, false);\n        }\n    }\n    if (element.type === 'Bezier') {\n        if (!element.isBezierEditing) {\n            if (element.segments.length > 0) {\n                var i = element.segments.length - 1;\n                while (i >= 0) {\n                    var seg = element.segments[parseInt(i.toString(), 10)];\n                    if (seg.isInternalSegment) {\n                        element.segments.pop();\n                    }\n                    i--;\n                }\n            }\n        }\n    }\n    if (sourceNode !== undefined && targetNode !== undefined) {\n        if (source.direction === undefined || target.direction === undefined) {\n            if (layoutOrientation) {\n                getDirection(source, target, layoutOrientation);\n            }\n            else {\n                if (source.corners.top > target.corners.bottom &&\n                    Math.abs(source.corners.top - target.corners.bottom) > minSpace) {\n                    source.direction = source.direction ? source.direction : 'Top';\n                    target.direction = target.direction ? target.direction : 'Bottom';\n                }\n                else if (source.corners.bottom < target.corners.top &&\n                    Math.abs(source.corners.bottom - target.corners.top) > minSpace) {\n                    source.direction = source.direction ? source.direction : 'Bottom';\n                    target.direction = target.direction ? target.direction : 'Top';\n                }\n                else if ((source.corners.right < target.corners.left &&\n                    Math.abs(source.corners.right - target.corners.left) > minSpace) ||\n                    ((source.corners.right + minSpace < target.corners.left) ||\n                        (target.corners.right >= source.corners.left - minSpace && source.corners.left > target.corners.left))) {\n                    source.direction = source.direction ? source.direction : 'Right';\n                    target.direction = target.direction ? target.direction : 'Left';\n                }\n                else if ((source.corners.left > target.corners.right &&\n                    Math.abs(source.corners.left - target.corners.right) > (source.margin.left + source.margin.right)) ||\n                    ((target.corners.right + minSpace < source.corners.left ||\n                        (source.corners.right >= target.corners.left - minSpace\n                            && source.corners.left < target.corners.left)))) {\n                    source.direction = source.direction ? source.direction : 'Left';\n                    target.direction = target.direction ? target.direction : 'Right';\n                }\n                else {\n                    if (sourceNode.id !== targetNode.id && (!sourceCorners.equals(sourceCorners, targetCorners)) &&\n                        targetCorners.containsPoint(sourceCorners.topCenter, source.margin.top)) {\n                        source.direction = source.direction ? source.direction : 'Bottom';\n                        target.direction = target.direction ? target.direction : 'Top';\n                    }\n                    else {\n                        source.direction = source.direction ? source.direction : 'Top';\n                        target.direction = target.direction ? target.direction : 'Bottom';\n                    }\n                }\n            }\n        }\n        return defaultOrthoConnection(element, source.direction, target.direction, source.point, target.point, lineDistribution);\n    }\n    //It will be called only when there is only one end node\n    checkLastSegmentasTerminal(element);\n    if (element.sourceWrapper || element.targetWrapper) {\n        connectToOneEnd(element, source, target);\n    }\n    if (element.type === 'Straight' || element.type === 'Bezier') {\n        intermeditatePoints = intermeditatePointsForStraight(element, source, target);\n    }\n    else {\n        if (element.type === 'Orthogonal' && element.segments && element.segments.length > 0 &&\n            element.segments[0].length !== null &&\n            element.segments[0].direction !== null) {\n            intermeditatePoints = findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort);\n        }\n        else {\n            var extra = void 0;\n            if (!source.direction) {\n                source.direction = (target.direction) ? ((element.targetPortWrapper !== undefined) ? target.direction : getOppositeDirection(target.direction)) :\n                    _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(source.point, target.point);\n            }\n            else {\n                extra = adjustSegmentLength(sourceNode.bounds, source, 20);\n            }\n            element.segments[0].points = intermeditatePoints = orthoConnection3Segment(element, source, target, extra);\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * updateSegmentPoints method \\\n *\n * @returns { PointModel[] }     updateSegmentPoints method .\\\n * @param {End} source - provide the source value.\n * @param {OrthogonalSegment} segment - provide the segment value.\n *\n * @private\n */\nfunction updateSegmentPoints(source, segment) {\n    //let segPoint: PointModel; //let angle: number; //let extra: number;\n    source.direction = segment.direction;\n    segment.points = [];\n    segment.points.push(source.point);\n    var extra = (segment.direction === 'Left' || segment.direction === 'Top') ? -(segment.length) : segment.length;\n    var angle = (segment.direction === 'Left' || segment.direction === 'Right') ? 0 : 90;\n    var segPoint = addLineSegment(source.point, extra, angle);\n    segment.points.push(segPoint);\n    return segPoint;\n}\n/**\n * pointToPoint method \\\n *\n * @returns { void }     pointToPoint method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction pointToPoint(element, source, target) {\n    var point;\n    var direction;\n    var portdirection;\n    source.corners = (element.sourceWrapper) ? element.sourceWrapper.corners : undefined;\n    if (element.sourcePortWrapper) {\n        var port = { x: element.sourcePortWrapper.offsetX, y: element.sourcePortWrapper.offsetY };\n        portdirection = getPortDirection(port, (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.sourceWrapper), element.sourceWrapper.bounds, false);\n        if (source.corners && (source.direction === 'Bottom' || source.direction === 'Top')) {\n            if (target.point.x > source.corners.left && target.point.x < source.corners.right) {\n                direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (source.corners && (source.direction === 'Left' || source.direction === 'Right')) {\n            if (target.point.y > source.corners.top && target.point.y < source.corners.bottom) {\n                direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n            }\n        }\n    }\n    if (element.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {\n        var length_1;\n        if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y >= source.corners.top\n            && source.point.y <= source.corners.center.y) &&\n            (target.point.y >= source.corners.top && target.point.y <= source.corners.center.y)) {\n            source.direction = 'Top';\n            length_1 = source.point.y - source.corners.top + 20;\n        }\n        else if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y > source.corners.center.y\n            && source.point.y <= source.corners.bottom) &&\n            (target.point.y > source.corners.center.y && target.point.y <= source.corners.bottom)) {\n            source.direction = 'Bottom';\n            length_1 = source.corners.bottom - source.point.y + 20;\n        }\n        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x >= source.corners.left\n            && source.point.x <= source.corners.center.x) &&\n            (target.point.x >= source.corners.left && target.point.x <= source.corners.center.x)) {\n            source.direction = 'Left';\n            length_1 = source.point.x - source.corners.left + 20;\n        }\n        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x <= source.corners.right\n            && source.point.x > source.corners.center.x) &&\n            (target.point.x <= source.corners.right && target.point.x < source.corners.center.x)) {\n            source.direction = 'Right';\n            length_1 = source.corners.right - source.point.x + 20;\n        }\n        if (source.direction && length_1) {\n            point = orthoConnection3Segment(element, source, target, length_1, true);\n        }\n    }\n    else {\n        source.direction = (direction) ? direction : findSourceDirection(source.direction, source.point, target.point);\n        point = orthoConnection2Segment(source, target);\n    }\n    return point;\n}\n/**\n * pointToNode method \\\n *\n * @returns { void }     pointToNode method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction pointToNode(element, source, target) {\n    var point;\n    target.corners = element.targetWrapper.corners;\n    findDirection(element.targetWrapper, source, target, element);\n    var direction = findSourceDirection(target.direction, source.point, target.point);\n    if (source.direction === target.direction && (source.direction === 'Left' || source.direction === 'Right')) {\n        source.direction = direction;\n        point = orthoConnection3Segment(element, source, target, element.targetWrapper.width / 2 + 20);\n        var source1 = source;\n        source1.point = point[1];\n        findDirection(element.targetWrapper, source, target, element);\n        point = orthoConnection3Segment(element, source, target);\n    }\n    else {\n        source.direction = direction;\n        point = orthoConnection2Segment(source, target);\n    }\n    return point;\n}\n/**\n * addPoints method \\\n *\n * @returns { void }     addPoints method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction addPoints(element, source, target) {\n    target.corners = element.targetWrapper.corners;\n    var direction;\n    var length;\n    if (source.direction !== 'Left' && source.direction !== 'Right') {\n        if (target.corners.center.y === source.point.y &&\n            (!(target.corners.left <= source.point.x && source.point.x <= target.corners.right))) {\n            direction = 'Top';\n            length = target.corners.height / 2 + 20;\n        }\n        else if ((target.corners.center.y === source.point.y &&\n            element.segments[element.segments.length - 2].direction === 'Bottom') ||\n            (target.corners.center.y > source.point.y && source.point.y >= target.corners.top)) {\n            direction = 'Top';\n            length = (source.point.y - target.corners.top) + 20;\n        }\n        else if ((target.corners.center.y === source.point.y &&\n            element.segments[element.segments.length - 2].direction === 'Top') ||\n            (target.corners.center.y < source.point.y && source.point.y <= target.corners.bottom)) {\n            direction = 'Bottom';\n            length = (target.corners.bottom - source.point.y) + 20;\n        }\n        else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n            source.corners.top <= source.point.y && source.point.y <= source.corners.bottom) {\n            direction = source.direction;\n            length = (source.point.y > target.point.y) ? (source.point.y - source.corners.top + 20) :\n                (source.corners.bottom - source.point.y + 20);\n        }\n    }\n    else {\n        if (target.corners.center.x === source.point.x &&\n            (!(target.corners.top < source.point.y && source.point.y <= target.corners.bottom))) {\n            direction = 'Left';\n            length = target.corners.width / 2 + 20;\n        }\n        else if ((target.corners.center.x === source.point.x &&\n            element.segments[element.segments.length - 2].direction === 'Right')\n            || (target.corners.center.x > source.point.x && source.point.x >= target.corners.left)) {\n            direction = 'Left';\n            length = (source.point.x - target.corners.left) + 20;\n        }\n        else if ((target.corners.center.x === source.point.x &&\n            element.segments[element.segments.length - 2].direction === 'Left') ||\n            (target.corners.center.x <= source.point.x && source.point.x <= target.corners.right)) {\n            direction = 'Right';\n            length = (target.corners.right - source.point.x) + 20;\n        }\n        else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n            source.corners.left <= source.point.x && source.point.x <= source.corners.right) {\n            direction = source.direction;\n            length = (source.point.x > target.point.x) ? (source.point.x - source.corners.left + 20) :\n                (source.corners.right - source.point.x + 20);\n        }\n    }\n    var extra = (direction === 'Left' || direction === 'Top') ? -(length) : length;\n    var angle = (direction === 'Left' || direction === 'Right') ? 0 : 90;\n    var refPoint = source.point;\n    source.point = addLineSegment(source.point, extra, angle);\n    source.direction = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(source.point, target.point);\n    if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n        (source.corners.center.x === target.corners.center.x || source.corners.center.y === target.corners.center.y)) {\n        source.direction = target.direction;\n    }\n    var point = orthoConnection3Segment(element, source, target);\n    point.splice(0, 0, refPoint);\n    return point;\n}\n/**\n * findSegmentDirection method \\\n *\n * @returns { void }     findSegmentDirection method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {Direction} portDir - provide the target value.\n *\n * @private\n */\nfunction findSegmentDirection(element, source, target, portDir) {\n    var update = false;\n    switch (target.direction) {\n        case 'Left':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (portDir === 'Right' &&\n                source.point.x > target.point.x && source.point.y >= source.corners.top &&\n                source.point.y <= source.corners.bottom)\n                || (((portDir === 'Bottom' && source.point.y > target.point.y) ||\n                    (portDir === 'Top' && source.point.y < target.point.y)) &&\n                    source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {\n                source.direction = (portDir === 'Right') ? ((source.point.y > target.point.y) ? 'Top' : 'Bottom') :\n                    (source.point.x < target.point.x ? 'Right' : 'Left');\n                update = true;\n            }\n            else if (source.point.x > target.point.x && (source.point.y > target.point.y || source.point.y < target.point.y)\n                && (!(target.corners.top > source.point.y && target.corners.bottom < source.point.y))) {\n                source.direction = 'Left';\n            }\n            else if ((source.point.x < target.point.x && source.point.y > target.point.y) ||\n                (source.point.x > target.point.x && (source.point.y <= target.point.y)\n                    && ((target.corners.top < source.point.y && target.corners.center.y >= source.point.y)))) {\n                source.direction = 'Top';\n            }\n            else if ((source.point.x < target.point.x && source.point.y < target.point.y) ||\n                (source.point.x > target.point.x && (source.point.y > target.point.y)\n                    && ((target.corners.bottom < source.point.y && target.corners.center.y > source.point.y)))) {\n                source.direction = 'Bottom';\n            }\n            else if (source.point.y === target.point.y && source.point.x < target.point.x) {\n                source.direction = 'Right';\n            }\n            break;\n        case 'Right':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n                ((portDir === 'Bottom' && source.point.y > target.point.y) ||\n                    (portDir === 'Top' && source.point.y < target.point.y)) && source.point.x > target.point.x &&\n                (source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {\n                source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n                update = true;\n            }\n            else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n                portDir === 'Left' && source.point.x < target.point.x && (source.point.y >= source.corners.top &&\n                source.point.y <= source.corners.bottom)) {\n                source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n                update = true;\n            }\n            else if (source.point.x < target.point.x && target.corners.top <= source.point.y\n                && target.corners.bottom >= source.point.y && source.point.y === target.point.y) {\n                source.direction = 'Top';\n            }\n            else if (source.point.y > target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Top';\n            }\n            else if (source.point.y < target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Bottom';\n            }\n            else if (source.point.x < target.point.x && (source.point.y > target.point.y ||\n                source.point.y < target.point.y)) {\n                source.direction = 'Right';\n            }\n            else if (source.point.y === target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Left';\n            }\n            break;\n        case 'Top':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (portDir === 'Bottom' &&\n                source.point.y > target.point.y && source.point.x >= source.corners.left &&\n                source.point.x <= source.corners.right) || (((portDir === 'Right' && source.point.x > target.point.x) ||\n                (portDir === 'Left' && target.point.y > source.point.y && target.point.x > source.point.x)) &&\n                (source.point.y >= source.corners.top && source.point.y <= source.corners.bottom))) {\n                source.direction = (portDir === 'Bottom') ? ((source.point.x > target.point.x) ? 'Left' : 'Right') :\n                    (source.point.y < target.point.y) ? 'Bottom' : 'Top';\n                update = true;\n            }\n            else if (source.point.x === target.point.x && source.point.y < target.point.y) {\n                source.direction = 'Bottom';\n            }\n            else if (source.point.y > target.point.y && source.point.x > target.corners.left &&\n                source.point.x < target.corners.right) {\n                source.direction = 'Left';\n            }\n            else if (source.point.y >= target.point.y) {\n                source.direction = 'Top';\n            }\n            else if (source.point.y < target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Left';\n            }\n            else if (source.point.y < target.point.y && source.point.x < target.point.x) {\n                source.direction = 'Right';\n            }\n            break;\n        case 'Bottom':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && ((((portDir === 'Right') ||\n                (portDir === 'Left' && target.point.x > source.point.x)) && (source.point.y > target.point.y) &&\n                source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) ||\n                (((portDir === 'Top' && source.point.y < target.point.y)) &&\n                    (source.point.x >= source.corners.left && source.point.x <= source.corners.right)))) {\n                if (portDir === 'Right' || portDir === 'Left') {\n                    source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n                }\n                else {\n                    source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n                }\n                update = true;\n            }\n            else if (source.point.y < target.point.y && source.point.x > target.corners.left &&\n                target.corners.right > source.point.x) {\n                if (source.point.y < target.point.y && source.point.x > target.corners.left &&\n                    target.corners.center.x >= source.point.x) {\n                    source.direction = 'Left';\n                }\n                else if (source.point.y < target.point.y && source.point.x < target.corners.right &&\n                    target.corners.center.x < source.point.x) {\n                    source.direction = 'Right';\n                }\n            }\n            else if (source.point.y > target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Left';\n            }\n            else if (source.point.y > target.point.y && source.point.x < target.point.x) {\n                source.direction = 'Right';\n            }\n            else if (source.point.y <= target.point.y && (source.point.x > target.point.x || target.point.x > source.point.x)) {\n                source.direction = 'Bottom';\n            }\n            break;\n    }\n    return update;\n}\n/**\n * pointToPort method \\\n *\n * @returns { void }     pointToPort method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction pointToPort(element, source, target) {\n    var point;\n    target.corners = element.targetWrapper.corners;\n    var portdirection;\n    var length;\n    if (element.sourcePortWrapper !== undefined) {\n        var port = { x: element.sourcePortWrapper.offsetX, y: element.sourcePortWrapper.offsetY };\n        portdirection = getPortDirection(port, (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.sourceWrapper), element.sourceWrapper.bounds, false);\n    }\n    var update = findSegmentDirection(element, source, target, portdirection);\n    // EJ2-65063 - Added below condition !selectedSegmentIndex to prevent the connector segment to split from two points into four points\n    if ((!element.selectedSegmentIndex) && element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n        target.direction === getOppositeDirection(portdirection) &&\n        ((((target.direction === 'Left' && source.point.x > target.point.x) || (target.direction === 'Right' &&\n            source.point.x < target.point.x)) && source.point.y >= source.corners.top &&\n            source.point.y <= source.corners.bottom) || (target.direction === 'Bottom' && source.point.y < target.point.y &&\n            (source.point.x >= source.corners.left && source.point.x <= source.corners.right)))) {\n        point = addPoints(element, source, target);\n    }\n    else if ((!element.selectedSegmentIndex) && source.direction === target.direction) {\n        point = orthoConnection3Segment(element, source, target);\n    }\n    else if ((!element.selectedSegmentIndex) && (((target.direction === 'Left' && source.point.x > target.point.x) ||\n        (target.direction === 'Right' && source.point.x < target.point.x)) && (source.direction === 'Top' || source.direction === 'Bottom')\n        && ((source.point.y <= target.point.y) &&\n            ((target.corners.top <= source.point.y && target.corners.bottom >= source.point.y)))) ||\n        ((target.direction === 'Top' && source.point.y > target.point.y) ||\n            (target.direction === 'Bottom' && source.point.y < target.point.y) &&\n                ((target.corners.left <= source.point.x && target.corners.right >= source.point.x)))) {\n        // EJ2-69304 - Return the 2 segment points if allowNodeOverlap is set as true.\n        if (!element.selectedSegmentIndex) {\n            point = addPoints(element, source, target);\n        }\n        else {\n            point = orthoConnection2Segment(source, target);\n        }\n    }\n    else {\n        if ((!element.selectedSegmentIndex) && element.sourceWrapper !== undefined && element.targetWrapper !== undefined\n            && element.targetPortWrapper !== undefined && ((source.direction === 'Left' || source.direction === 'Right')\n            && (source.point.y >= source.corners.top && source.point.y <= source.corners.bottom)\n            && (target.direction === 'Top' || target.direction === 'Bottom') &&\n            (target.corners.center.x === source.corners.center.x))) {\n            source.direction = (target.direction === 'Top') ? 'Bottom' : 'Top';\n            length = (target.direction === 'Top') ? (source.corners.bottom - source.point.y + 20) :\n                (source.point.y - source.corners.top + 20);\n            point = orthoConnection3Segment(element, source, target, length);\n        }\n        else if ((!element.selectedSegmentIndex) && element.sourceWrapper !== undefined && element.targetWrapper !== undefined\n            && element.targetPortWrapper !== undefined && ((source.direction === 'Top' || source.direction === 'Bottom') &&\n            (source.point.x >= source.corners.left && source.point.x <= source.corners.right) &&\n            (target.direction === 'Left' || target.direction === 'Right') && (target.corners.center.y === source.corners.center.y))) {\n            source.direction = (target.direction === 'Left') ? 'Right' : 'Left';\n            length = (target.direction === 'Left') ? (source.corners.right - source.point.x + 20) :\n                (source.point.x - source.corners.left + 20);\n            point = orthoConnection3Segment(element, source, target, length);\n        }\n        else if (update) {\n            if (source.direction === 'Left' || source.direction === 'Right') {\n                length = (source.direction === 'Left') ? (source.point.x - source.corners.left + 20) :\n                    (source.corners.right - source.point.x + 20);\n            }\n            else {\n                length = (source.direction === 'Top') ? (source.point.y - source.corners.top + 20) :\n                    (source.corners.bottom - source.point.y + 20);\n            }\n            point = orthoConnection3Segment(element, source, target, length);\n        }\n        else {\n            point = orthoConnection2Segment(source, target);\n        }\n    }\n    return point;\n}\n/**\n * findPointToPointOrtho method \\\n *\n * @returns { void }     findPointToPointOrtho method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the source value.\n * @param {DiagramElement} target - provide the target value.\n * @param {DiagramElement} sourceNode - provide the target value.\n * @param {DiagramElement} targetNode - provide the target value.\n * @param {DiagramElement} sourcePort - provide the sourcePort value.\n * @param {DiagramElement} targetPort - provide the targetPort value.\n *\n * @private\n */\nfunction findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort) {\n    var j;\n    var point;\n    var intermeditatePoints = [];\n    var direction;\n    var port; //let seg: OrthogonalSegment;\n    checkLastSegmentasTerminal(element);\n    var removeSegment;\n    if (element.segments.length > 0) {\n        for (var i = 0; i < element.segments.length; i++) {\n            var seg = element.segments[parseInt(i.toString(), 10)];\n            if (i === 0 && element.sourcePortWrapper !== undefined) {\n                port = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n                direction = getPortDirection(port, (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(sourceNode), sourceNode.bounds, false);\n                if (seg.direction === getOppositeDirection(direction)) {\n                    seg.direction = direction;\n                }\n            }\n            if (i > 0 && element.segments[i - 1].direction === seg.direction) {\n                i = checkConsectiveSegmentAsSame(element, i, source);\n            }\n            else {\n                var lastSegment = element.segments[i - 1];\n                source.point = (seg.direction) ? updateSegmentPoints(source, seg) :\n                    lastSegment.points[lastSegment.points.length - 1];\n            }\n            if (i === element.segments.length - 1) {\n                if (!targetPort && !targetNode) {\n                    point = pointToPoint(element, source, target);\n                }\n                else if (element.targetWrapper && element.targetPortWrapper === undefined) {\n                    checkSourcePointInTarget(element, source);\n                    point = pointToNode(element, source, target);\n                }\n                else {\n                    point = pointToPort(element, source, target);\n                }\n                if (point) {\n                    checkPreviousSegment(point, element, source);\n                    seg.points = [];\n                    if (point.length >= 2) {\n                        for (j = 0; j < point.length; j++) {\n                            seg.points.push(point[parseInt(j.toString(), 10)]);\n                        }\n                    }\n                    else {\n                        removeSegment = i;\n                    }\n                }\n            }\n            if (sourcePort && i === 0) {\n                var sourcePoint = checkPortdirection(element, sourcePort, sourceNode);\n                if (sourcePoint) {\n                    source.point = sourcePoint;\n                }\n            }\n        }\n        if (removeSegment !== undefined) {\n            if (removeSegment === element.segments.length - 1) {\n                element.segments[removeSegment - 1].direction = null;\n                element.segments[removeSegment - 1].length = null;\n            }\n            element.segments.splice(removeSegment, 1);\n        }\n        intermeditatePoints = returnIntermeditatePoints(element, intermeditatePoints);\n    }\n    return intermeditatePoints;\n}\n/**\n * checkPortdirection method \\\n *\n * @returns { PointModel }     checkPortdirection method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} sourcePort - provide the target value.\n * @param {DiagramElement} sourceNode - provide the target value.\n *\n * @private\n */\nfunction checkPortdirection(element, sourcePort, sourceNode) {\n    var port = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n    var point;\n    var bounds = (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(sourceNode);\n    var direction = getPortDirection(port, bounds, sourceNode.bounds, false);\n    var seg = element.segments[0];\n    if (seg.direction !== direction) {\n        pointsFromNodeToPoint(seg, direction, bounds, seg.points[0], seg.points[seg.points.length - 1], false);\n        point = seg.points[seg.points.length - 1];\n        seg.direction = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(seg.points[seg.points.length - 2], seg.points[seg.points.length - 1]);\n    }\n    return point;\n}\n/**\n * checkPreviousSegment method \\\n *\n * @returns { PointModel }     checkPreviousSegment method .\\\n * @param {Connector} tPoints - provide the element value.\n * @param {DiagramElement} connector - provide the target value.\n * @param {DiagramElement} source - provide the target value.\n *\n * @private\n */\nfunction checkPreviousSegment(tPoints, connector, source) {\n    var actualSegment = connector.segments[connector.segments.length - 2];\n    var actualLastPoint = actualSegment.points[actualSegment.points.length - 1];\n    var direction;\n    if (((actualSegment.direction === 'Top' || actualSegment.direction === 'Bottom') && (actualLastPoint.x === tPoints[1].x)) ||\n        ((actualSegment.direction === 'Left' || actualSegment.direction === 'Right') && (actualLastPoint.y === tPoints[1].y))) {\n        actualSegment.points[actualSegment.points.length - 1] = tPoints[1];\n        direction = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);\n        if (connector.sourceWrapper !== undefined && connector.sourcePortWrapper === undefined &&\n            direction === getOppositeDirection(actualSegment.direction)) {\n            if (actualSegment.direction === 'Left' || actualSegment.direction === 'Right') {\n                actualSegment.points[0].x = (actualSegment.direction === 'Right') ?\n                    actualSegment.points[0].x - connector.sourceWrapper.corners.width :\n                    actualSegment.points[0].x + connector.sourceWrapper.corners.width;\n            }\n            else {\n                actualSegment.points[0].y = (actualSegment.direction === 'Bottom') ?\n                    actualSegment.points[0].y - connector.sourceWrapper.corners.height :\n                    actualSegment.points[0].y + connector.sourceWrapper.corners.height;\n            }\n        }\n        actualSegment.direction = direction;\n        actualSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);\n        tPoints.splice(0, 1);\n    }\n}\n/**\n * connectToOneEnd method \\\n *\n * @returns { void }     connectToOneEnd method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the target value.\n * @param {DiagramElement} target - provide the target value.\n *\n * @private\n */\nfunction connectToOneEnd(element, source, target) {\n    var sourcePort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var node = element.sourceWrapper;\n    var fixedPoint = source.point;\n    var nodeMargin = { left: 0, right: 0, top: 0, bottom: 0 };\n    var nodeConnectingPoint = { x: 0, y: 0 };\n    var refPoint;\n    var nodeDirection = 'Top';\n    if (!node) {\n        node = element.targetWrapper;\n        nodeMargin = target.margin;\n    }\n    else {\n        fixedPoint = target.point;\n        nodeMargin = source.margin;\n    }\n    if (element.type === 'Orthogonal') {\n        if ((element.segments && element.segments.length > 0) && element.sourceWrapper &&\n            element.segments[0].direction) {\n            source.direction = element.segments[0].direction;\n            nodeConnectingPoint = findPoint(node.corners, source.direction);\n            refPoint = findPoint(node.corners, getOppositeDirection(source.direction));\n            nodeConnectingPoint = getIntersection(element, node, nodeConnectingPoint, refPoint, false);\n        }\n        else {\n            var source_1 = { corners: null, direction: null, point: fixedPoint, margin: nodeMargin };\n            var target_1 = { corners: null, direction: null, point: null, margin: null };\n            findDirection(node, source_1, target_1, element);\n            nodeConnectingPoint = target_1.point;\n            nodeDirection = target_1.direction;\n        }\n    }\n    else {\n        var segmentPoint = void 0;\n        if (element.segments && element.segments.length > 1) {\n            if (node === element.sourceWrapper) {\n                segmentPoint = element.segments[0].point;\n            }\n            else {\n                segmentPoint = element.segments[element.segments.length - 2].point;\n            }\n        }\n        nodeConnectingPoint = getIntersection(element, node, node.bounds.center, (element.segments && element.segments.length > 1) ? segmentPoint : fixedPoint, node === element.targetWrapper);\n    }\n    if (node === element.sourceWrapper) {\n        source.direction = source.direction || nodeDirection;\n        source.point = nodeConnectingPoint;\n        if (element.sourcePortWrapper) {\n            source.point = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n            if (element.sourcePadding) {\n                source.point = addPaddingToConnector(element, source, target, false);\n            }\n        }\n    }\n    else {\n        target.direction = target.direction || nodeDirection;\n        target.point = nodeConnectingPoint;\n        if (element.targetPortWrapper) {\n            target.point = { x: targetPort.offsetX, y: targetPort.offsetY };\n            if (element.targetPadding) {\n                target.point = addPaddingToConnector(element, source, target, true);\n            }\n        }\n    }\n}\n/**\n * addPaddingToConnector method \\\n *\n * @returns { void }     addPaddingToConnector method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the target value.\n * @param {DiagramElement} target - provide the target value.\n * @param {DiagramElement} isTarget - provide the target value.\n *\n * @private\n */\nfunction addPaddingToConnector(element, source, target, isTarget) {\n    var sourcePort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var padding = (isTarget) ? element.targetPadding : element.sourcePadding;\n    var paddingPort = (isTarget) ? targetPort : sourcePort;\n    var rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(paddingPort.bounds.x - padding, paddingPort.bounds.y - padding, paddingPort.actualSize.width + 2 * padding, paddingPort.actualSize.height + 2 * padding);\n    var segmentPoints = [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft];\n    segmentPoints[segmentPoints.length] = segmentPoints[0];\n    //const length: number = segmentPoints.length;\n    var thisSegment = { x1: source.point.x, y1: source.point.y, x2: target.point.x, y2: target.point.y };\n    var point = (isTarget) ? target.point : source.point;\n    return getIntersectionPoints(thisSegment, segmentPoints, true, point) || point;\n}\n/**\n * checkSourceAndTargetIntersect method \\\n *\n * @returns { void }     checkSourceAndTargetIntersect method .\\\n * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.\n * @param {DiagramElement} targetWrapper - provide the targetWrapper value.\n * @param {Connector} connector - provide the Connector value.\n *\n * @private\n */\nfunction checkSourceAndTargetIntersect(sourceWrapper, targetWrapper, connector) {\n    var sourceSegment = createSegmentsCollection(sourceWrapper, connector.sourcePadding);\n    var targetSegment = createSegmentsCollection(targetWrapper, connector.targetPadding);\n    for (var i = 0; i < sourceSegment.length - 1; i++) {\n        var srcSegment = sourceSegment[parseInt(i.toString(), 10)];\n        for (var j = 0; j < targetSegment.length - 1; j++) {\n            var tarSegmet = targetSegment[parseInt(j.toString(), 10)];\n            if ((0,_diagram_util__WEBPACK_IMPORTED_MODULE_2__.intersect3)(srcSegment, tarSegmet).enabled) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * createSegmentsCollection method \\\n *\n * @returns { Segment[] }     createSegmentsCollection method .\\\n * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.\n * @param {number} padding - provide the padding value.\n *\n * @private\n */\nfunction createSegmentsCollection(sourceWrapper, padding) {\n    var segments = [];\n    var points = (0,_diagram_util__WEBPACK_IMPORTED_MODULE_2__.getPoints)(sourceWrapper, sourceWrapper.corners, padding);\n    points.push(points[0]);\n    for (var i = 0; i < points.length - 1; i++) {\n        segments.push(createLineSegment(points[parseInt(i.toString(), 10)], points[i + 1]));\n    }\n    return segments;\n}\n/**\n * createLineSegment method \\\n *\n * @returns { Segment }     createLineSegment method .\\\n * @param {PointModel} sPt - provide the sourceWrapper value.\n * @param {PointModel} tPt - provide the padding value.\n *\n * @private\n */\nfunction createLineSegment(sPt, tPt) {\n    var line = { x1: sPt.x, y1: sPt.y, x2: tPt.x, y2: tPt.y };\n    return line;\n}\n/**\n * swapBounds method \\\n *\n * @returns { Corners }     swapBounds method .\\\n * @param {PointModel} object - provide the sourceWrapper value.\n * @param {PointModel} bounds - provide the padding value.\n * @param {Rect} outerBounds - provide the padding value.\n *\n * @private\n */\nfunction swapBounds(object, bounds, outerBounds) {\n    var rectBounds;\n    var rotateAngle = object.rotateAngle + object.parentTransform;\n    if (rotateAngle) {\n        if (rotateAngle < 45) {\n            return bounds;\n        }\n        else if (rotateAngle <= 135) {\n            rectBounds = {\n                width: bounds.width, height: bounds.height,\n                topLeft: bounds.bottomLeft, topCenter: bounds.middleLeft, topRight: bounds.topLeft,\n                middleLeft: bounds.bottomCenter, center: outerBounds.center, middleRight: bounds.topCenter,\n                bottomLeft: bounds.bottomRight, bottomCenter: bounds.middleRight, bottomRight: bounds.topRight,\n                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top, bottom: outerBounds.bottom\n            };\n        }\n        else if (rotateAngle <= 225) {\n            rectBounds = {\n                width: bounds.width, height: bounds.height,\n                topLeft: bounds.bottomLeft, topCenter: bounds.bottomCenter, topRight: bounds.bottomRight,\n                middleLeft: bounds.middleRight, center: outerBounds.center, middleRight: bounds.middleLeft,\n                bottomLeft: bounds.topLeft, bottomCenter: bounds.topCenter, bottomRight: bounds.topRight,\n                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top,\n                bottom: outerBounds.bottom\n            };\n        }\n        else if (rotateAngle <= 315) {\n            rectBounds = {\n                width: bounds.width, height: bounds.height,\n                topLeft: bounds.topRight, topCenter: bounds.middleRight, topRight: bounds.bottomRight,\n                middleLeft: bounds.topCenter, center: outerBounds.center, middleRight: bounds.bottomCenter,\n                bottomLeft: bounds.topLeft, bottomCenter: bounds.middleLeft, bottomRight: bounds.bottomLeft,\n                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top, bottom: outerBounds.bottom\n            };\n        }\n        else {\n            return bounds;\n        }\n        return rectBounds;\n    }\n    return bounds;\n}\n/**\n * defaultOrthoConnection method \\\n *\n * @returns { PointModel[] }     defaultOrthoConnection method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {Direction} srcDir - provide the srcDir value.\n * @param {Direction} tarDir - provide the srcDir value.\n * @param {PointModel} sPt - provide the sPt value.\n * @param {PointModel} tPt - provide the tPt value.\n * @param {Rect} lineDistribution - provide the padding value.\n *\n * @private\n */\n/* tslint:disable */\n// eslint-disable-next-line\nfunction defaultOrthoConnection(ele, srcDir, tarDir, sPt, tPt, lineDistribution) {\n    var sourceEle = ele.sourceWrapper;\n    var targetEle = ele.targetWrapper;\n    var srcPort = ele.sourcePortWrapper;\n    var tarPort = ele.targetPortWrapper;\n    var intermeditatePoints = [];\n    var refPoint;\n    var srcCor = sourceEle.corners;\n    // eslint-disable-next-line\n    var tarCor = targetEle.corners;\n    var point = tarCor.center; //const i: number;\n    var sourceMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var targetMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var source = { corners: srcCor, point: sPt, direction: srcDir, margin: sourceMargin };\n    // eslint-disable-next-line\n    var target = { corners: tarCor, point: tPt, direction: tarDir, margin: targetMargin };\n    var srcBounds = swapBounds(sourceEle, srcCor, ele.sourceWrapper.bounds);\n    var tarBounds = swapBounds(targetEle, tarCor, ele.targetWrapper.bounds);\n    var isInterSect = false;\n    if (ele.sourceWrapper && ele.targetWrapper) {\n        isInterSect = checkSourceAndTargetIntersect(ele.sourceWrapper, ele.targetWrapper, ele);\n    }\n    if (srcPort !== undefined) {\n        source.point = { x: srcPort.offsetX, y: srcPort.offsetY };\n        switch (source.direction) {\n            case 'Bottom':\n            case 'Top':\n                // eslint-disable-next-line\n                source.point.y = source.point.y;\n                break;\n            case 'Left':\n            case 'Right':\n                // eslint-disable-next-line\n                source.point.x = source.point.x;\n                break;\n        }\n        if (ele.sourcePadding && !isInterSect) {\n            if (tarPort) {\n                target.point = {\n                    x: tarPort.offsetX,\n                    y: tarPort.offsetY\n                };\n            }\n            source.point = addPaddingToConnector(ele, source, target, false);\n        }\n    }\n    else {\n        if (ele.type === 'Orthogonal' || ele.type === 'Bezier') {\n            if (ele.segments && ele.segments.length > 0 && ele.segments[0].direction) {\n                source.direction = ele.segments[0].direction;\n            }\n            source.point = findPoint(srcBounds, source.direction);\n            refPoint = findPoint(srcBounds, getOppositeDirection(source.direction));\n            source.point = getIntersection(ele, sourceEle, source.point, refPoint, false);\n        }\n        else {\n            source.point = sourceEle.corners.center;\n        }\n    }\n    if (tarPort !== undefined) {\n        target.point = {\n            x: tarPort.offsetX,\n            y: tarPort.offsetY\n        };\n        switch (target.direction) {\n            case 'Bottom':\n            case 'Top':\n                // eslint-disable-next-line\n                target.point.y = target.point.y;\n                break;\n            case 'Left':\n            case 'Right':\n                // eslint-disable-next-line\n                target.point.x = target.point.x;\n                break;\n        }\n        if (ele.targetPadding && !isInterSect) {\n            target.point = addPaddingToConnector(ele, source, target, true);\n        }\n    }\n    else {\n        if (ele.type === 'Orthogonal' || ele.type === 'Bezier') {\n            target.point = findPoint(tarBounds, target.direction);\n            refPoint = findPoint(tarBounds, getOppositeDirection(target.direction));\n            target.point = getIntersection(ele, targetEle, target.point, refPoint, true);\n        }\n        else {\n            target.point = targetEle.corners.center;\n        }\n    }\n    if (ele.type !== 'Orthogonal') {\n        var segment = void 0;\n        var first = void 0;\n        if (ele.type === 'Bezier') {\n            //EJ2-67651 - Bezier segment points are static when we move the connector's source or target node.\n            if ((ele.bezierSettings.allowSegmentsReset || (ele.segments.length === 0 ||\n                (!_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.isEmptyPoint(ele.segments[ele.segments.length - 1].point))))) {\n                intermeditatePoints = findOrthoSegments(ele, source, target, undefined, lineDistribution);\n                intermeditatePoints = intermeditatePointsForStraight(ele, source, target);\n                return intermeditatePoints;\n            }\n            else {\n                checkLastSegmentasTerminal(ele);\n            }\n        }\n        else {\n            checkLastSegmentasTerminal(ele);\n        }\n        if (ele.sourcePortWrapper === undefined) {\n            source.point = source.corners.center;\n            if (ele.segments && ele.segments.length > 0) {\n                first = ele.segments[0];\n                segment = (!_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.isEmptyPoint(first.point)) ? first : undefined;\n            }\n            var tarPoint = (segment !== undefined) ? segment.point : target.point;\n            if (ele.type === 'Bezier' && ele.segments.length > 0 &&\n                ele.segments[0].vector1.angle && ele.segments[0].vector1.distance) {\n                var value = Math.max(source.corners.width, source.corners.height);\n                tarPoint = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.transform(source.point, ele.segments[0].vector1.angle, value / 2);\n            }\n            source.point = isInterSect ? ele.sourceWrapper.bounds.center : getIntersection(ele, sourceEle, source.point, tarPoint, false);\n        }\n        if (ele.targetPortWrapper === undefined) {\n            target.point = target.corners.center;\n            if (ele.segments && ele.segments.length > 1) {\n                first = ele.segments[ele.segments.length - 2];\n                segment = (!_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.isEmptyPoint(first.point)) ? first : undefined;\n            }\n            var srcPoint = (segment) ? segment.point : source.point;\n            if (ele.type === 'Bezier' && ele.segments.length > 0 &&\n                ele.segments[ele.segments.length - 1].vector2.angle &&\n                ele.segments[ele.segments.length - 1].vector2.distance) {\n                var value = Math.max(source.corners.width, source.corners.height);\n                srcPoint = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.transform(target.point, ele.segments[0].vector2.angle, value / 2);\n            }\n            target.point = isInterSect ? ele.targetWrapper.bounds.center : getIntersection(ele, targetEle, srcPoint, target.point, true);\n        }\n        intermeditatePoints = intermeditatePointsForStraight(ele, source, target);\n    }\n    else {\n        if (ele.type === 'Orthogonal' && (ele.segments && ele.segments.length > 0) &&\n            ele.segments[0].direction !== null) {\n            intermeditatePoints = findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle, targetEle);\n        }\n        else {\n            if (!ele.segments[0]) {\n                var segment = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.OrthogonalSegment(ele, 'segments', { type: 'Orthogonal' }, true);\n                ele.segments.push(segment);\n            }\n            // eslint-disable-next-line\n            ele.segments[0].points = intermeditatePoints = findOrthoSegments(ele, source, target, undefined, lineDistribution);\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * intermeditatePointsForStraight method \\\n *\n * @returns { PointModel[] }     intermeditatePointsForStraight method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction intermeditatePointsForStraight(element, source, target) {\n    var intermeditatePoints = [];\n    if (element.segments && element.segments.length > 0) {\n        var i = void 0;\n        var segPoint = [];\n        var srcPoint = source.point;\n        for (i = 0; i < element.segments.length; i++) {\n            var seg = element.segments[parseInt(i.toString(), 10)];\n            segPoint = [];\n            segPoint.push(srcPoint);\n            if (i !== element.segments.length - 1) {\n                segPoint.push(seg.point);\n                srcPoint = seg.point;\n            }\n            else {\n                segPoint.push(target.point);\n            }\n            element.segments[parseInt(i.toString(), 10)].points = segPoint;\n            if (element.segments.length > 1 && _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.equals(seg.points[0], seg.points[1])) {\n                (element.segments).splice(i, 1);\n            }\n            if (seg) {\n                for (var j = 0; j < seg.points.length; j++) {\n                    if (j > 0 || i === 0) {\n                        intermeditatePoints.push(seg.points[parseInt(j.toString(), 10)]);\n                    }\n                }\n            }\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * findSourceDirection method \\\n *\n * @returns { PointModel[] }     findSourceDirection method .\\\n * @param {Direction} dir - provide the dir value.\n * @param {PointModel} srcPoint - provide the srcPoint value.\n * @param {PointModel} tarPoint - provide the tarPoint value.\n *\n * @private\n */\nfunction findSourceDirection(dir, srcPoint, tarPoint) {\n    var direction = (dir === 'Top' || dir === 'Bottom') ?\n        ((tarPoint.x > srcPoint.x) ? 'Right' : 'Left') :\n        ((tarPoint.y > srcPoint.y) ? 'Bottom' : 'Top');\n    return direction;\n}\n/**\n * checkLastSegmentasTerminal method \\\n *\n * @returns { void }     checkLastSegmentasTerminal method .\\\n * @param {Connector} ele - provide the Connector value.\n *\n * @private\n */\nfunction checkLastSegmentasTerminal(ele) {\n    if (ele.type === 'Straight' || ele.type === 'Bezier') {\n        if ((ele.segments.length === 0 || (ele.segments.length > 0 &&\n            (!_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.isEmptyPoint(ele.segments[ele.segments.length - 1].point))))) {\n            //let segment: BezierSegmentModel | StraightSegmentModel;\n            if (ele.type === 'Bezier') {\n                var segment = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(ele, 'segments', { type: 'Bezier', isInternalSegment: true }, true);\n                (ele.segments).push(segment);\n            }\n            else {\n                var segment = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.StraightSegment(ele, 'segments', { type: 'Straight' }, true);\n                (ele.segments).push(segment);\n            }\n        }\n    }\n    else {\n        if (ele.segments.length > 0) {\n            var isInvalid = false;\n            var i = 0;\n            while (i < ele.segments.length) {\n                var seg = ele.segments[parseInt(i.toString(), 10)];\n                if (isInvalid ||\n                    (seg && !(seg instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_4__.OrthogonalSegment || seg instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_4__.StraightSegment || seg instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment))) {\n                    ele.segments.splice(i, 1);\n                    isInvalid = true;\n                }\n                else {\n                    i++;\n                }\n            }\n        }\n        if (ele.segments.length === 0 || ele.segments[ele.segments.length - 1].direction) {\n            var segment = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.OrthogonalSegment(ele, 'segments', { type: 'Orthogonal' }, true);\n            ele.segments.push(segment);\n        }\n    }\n}\n/**\n * checkConsectiveSegmentAsSame method \\\n *\n * @returns { number }     checkConsectiveSegmentAsSame method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {Connector} i - provide the Connector value.\n * @param {Connector} source - provide the Connector value.\n *\n * @private\n */\nfunction checkConsectiveSegmentAsSame(ele, i, source) {\n    var seg = ele.segments[parseInt(i.toString(), 10)];\n    var extra = (seg.direction === 'Left' || seg.direction === 'Top') ? -(seg.length) : seg.length;\n    var angle = (seg.direction === 'Left' || seg.direction === 'Right') ? 0 : 90;\n    var segPoint = addLineSegment(source.point, extra, angle);\n    ele.segments[i - 1].length += seg.length;\n    ele.segments[i - 1].points[1] = source.point = segPoint;\n    ele.segments.splice(i, 1);\n    i--;\n    return i;\n}\n/**\n * nodeOrPortToNode method \\\n *\n * @returns { PointModel[] }     nodeOrPortToNode method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {End} source - provide the Connector value.\n * @param {End} target - provide the Connector value.\n *\n * @private\n */\nfunction nodeOrPortToNode(ele, source, target) {\n    var point;\n    var portdirection;\n    if (ele.sourcePortWrapper) {\n        var port = { x: ele.sourcePortWrapper.offsetX, y: ele.sourcePortWrapper.offsetY };\n        portdirection = getPortDirection(port, (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(ele.sourceWrapper), ele.sourceWrapper.bounds, false);\n    }\n    findDirection(ele.targetWrapper, source, target, ele);\n    var direction = findSourceDirection(target.direction, source.point, target.point);\n    if (ele.sourcePortWrapper !== undefined && source.direction === target.direction &&\n        ((source.direction === 'Top' || source.direction === 'Bottom') && (source.corners.center.x === target.corners.center.x)\n            || (source.direction === 'Left' || source.direction === 'Right') && (source.corners.center.y === target.corners.center.y))) {\n        source.direction = direction;\n        point = (direction === 'Top' || direction === 'Bottom') ?\n            orthoConnection3Segment(ele, source, target, ele.sourceWrapper.height / 2 + 20) :\n            orthoConnection3Segment(ele, source, target, ele.sourceWrapper.width / 2 + 20);\n        var source1 = source;\n        source1.point = point[1];\n        if (direction === 'Left' || direction === 'Right') {\n            target.direction = direction;\n            target.point = (direction === 'Left') ? target.corners.middleLeft : target.corners.middleRight;\n        }\n        else {\n            findDirection(ele.targetWrapper, source, target, ele);\n        }\n        point = orthoConnection3Segment(ele, source, target);\n    }\n    else if (target.point.x >= source.corners.left && target.point.x <= source.corners.right &&\n        source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) {\n        source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';\n        var length_2 = (source.direction === 'Top') ? (source.point.y - source.corners.top + 20) :\n            (source.corners.bottom - source.point.y + 20);\n        point = orthoConnection3Segment(ele, source, target, length_2);\n    }\n    else if (ele.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {\n        var length_3;\n        if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y >= source.corners.top\n            && source.point.y <= source.corners.bottom)) {\n            source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';\n            length_3 = source.corners.height / 2 + 20;\n        }\n        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x >= source.corners.left\n            && source.point.x <= source.corners.right)) {\n            source.direction = (target.point.x > source.point.x) ? 'Right' : 'Left';\n            length_3 = source.corners.width / 2 + 20;\n        }\n        if (source.direction && length_3) {\n            point = orthoConnection3Segment(ele, source, target, length_3, true);\n        }\n        else {\n            source.direction = direction;\n            point = orthoConnection2Segment(source, target);\n        }\n    }\n    else if (ele.sourcePortWrapper && portdirection === target.direction && (portdirection === 'Top' || portdirection === 'Bottom') &&\n        (source.corners.center.x === target.corners.center.x)) {\n        source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';\n        var len = (source.direction === 'Bottom') ? (source.corners.bottom - source.point.y + 20) :\n            (source.point.y - source.corners.top + 20);\n        point = orthoConnection3Segment(ele, source, target, len);\n    }\n    else { //901771- Connector routing is not proper while setting the segment direction as \"Left\"\n        if (source.direction === target.direction) {\n            if (((source.direction === 'Left' || source.direction === 'Right') &&\n                target.point.y > source.corners.top - 20 && target.point.y < source.corners.bottom + 20) ||\n                ((source.direction === 'Top' || source.direction === 'Bottom') &&\n                    target.point.x > source.corners.left - 20 && target.point.x < source.corners.right + 20)) {\n                var prevdirection = source.direction;\n                source.direction = direction;\n                point = orthoConnection4Segment(source, target, prevdirection, point, 20, false);\n            }\n            else {\n                source.direction = direction;\n                point = orthoConnection2Segment(source, target);\n            }\n        }\n        else {\n            source.direction = direction;\n            point = orthoConnection2Segment(source, target);\n        }\n    }\n    return point;\n}\n/**\n * checkSourcePointInTarget method \\\n *\n * @returns { void } checkSourcePointInTarget method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {End} source - provide the Connector value.\n *\n * @private\n */\nfunction checkSourcePointInTarget(ele, source) {\n    if (ele.targetWrapper !== undefined && ele.targetPortWrapper === undefined) {\n        var padding = 1;\n        if ((0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(ele.targetWrapper).containsPoint(source.point, padding)) {\n            var target = ele.targetWrapper;\n            var segment = ele.segments[ele.segments.length - 2];\n            var lastPoint = segment.points[segment.points.length - 1];\n            var direction = getOppositeDirection(segment.direction);\n            if (direction === 'Bottom') {\n                if (lastPoint.y < target.corners.bottom + padding) {\n                    segment.points[segment.points.length - 1].y = target.corners.bottom + 20;\n                    segment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            else if (direction === 'Top') {\n                if (lastPoint.y > target.corners.top - padding) {\n                    segment.points[segment.points.length - 1].y = target.corners.top - 20;\n                    segment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            else if (direction === 'Left') {\n                if (lastPoint.x > target.corners.left - padding) {\n                    segment.points[segment.points.length - 1].x = target.corners.left - 20;\n                    segment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            else if (direction === 'Right') {\n                if (lastPoint.x < target.corners.right + padding) {\n                    segment.points[segment.points.length - 1].x = target.corners.right + 20;\n                    segment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            source.point = segment.points[segment.points.length - 1];\n        }\n    }\n}\n/**\n * findIntermeditatePoints method \\\n *\n * @returns { void } findIntermeditatePoints method .\\\n * @param {Connector} ele - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the source value.\n * @param {DiagramElement} srcPort - provide the srcPort value.\n * @param {DiagramElement} tarPort - provide the tarPort value.\n * @param {DiagramElement} sourceEle - provide the sourceEle value.\n * @param {DiagramElement} targetEle - provide the targetEle value.\n * @private\n */\nfunction findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle, targetEle) {\n    var point;\n    var intermeditatePoints = [];\n    var seg;\n    var j;\n    var removeSegment;\n    checkLastSegmentasTerminal(ele);\n    for (var i = 0; i < ele.segments.length; i++) {\n        seg = ele.segments[parseInt(i.toString(), 10)];\n        if (srcPort && source.direction === getOppositeDirection(seg.direction)) {\n            seg.direction = source.direction;\n        }\n        if (i > 0 && ele.segments[i - 1].direction === seg.direction) {\n            i = checkConsectiveSegmentAsSame(ele, i, source);\n        }\n        else {\n            if (seg.direction) {\n                source.point = updateSegmentPoints(source, ele.segments[parseInt(i.toString(), 10)]);\n            }\n            else {\n                var segment = ele.segments[i - 1];\n                if (segment && segment.points && segment.points.length > 0) {\n                    source.point = segment.points[segment.points.length - 1];\n                }\n            }\n        }\n        if (i === ele.segments.length - 1) {\n            checkSourcePointInTarget(ele, source);\n            if (tarPort === undefined) {\n                point = nodeOrPortToNode(ele, source, target);\n            }\n            else {\n                point = pointToPort(ele, source, target);\n            }\n            checkPreviousSegment(point, ele, source);\n            seg.points = [];\n            if (point.length >= 2) {\n                for (j = 0; j < point.length; j++) {\n                    if (!ele.selectedSegmentIndex) {\n                        seg.points.push(point[parseInt(j.toString(), 10)]);\n                    }\n                    else {\n                        // EJ2-65063 - If point length is greater then 2 means then empty the last segment points and set it as two points instead of four points\n                        if (j === point.length - 1 && point.length > 2 && ele.segments.length > 2) {\n                            // EJ2-69304 - Change the point calculation to work for all port combination\n                            var point2 = { x: point[parseInt(j.toString(), 10)].x, y: source.point.y };\n                            // EJ2 - 65063 - Empty the segment points\n                            seg.points = [];\n                            // EJ2-69304 - Calculate the point for segment and manually push the point in segment point calculation\n                            seg.points.push(point2);\n                            seg.points.push(point[parseInt(j.toString(), 10)]);\n                            var segment = ele.segments[i - 1];\n                            //EJ2 - Orthogonal connector gets broken when dragging segment thumb\n                            if (ele.segments.length < 4) {\n                                segment.points.pop();\n                            }\n                            // Bug 834713: Orthogonal connector routing is not proper, When allowNodeOverlap is Set to true.\n                            segment.points = segment.points.concat(seg.points);\n                        }\n                        else {\n                            seg.points.push(point[parseInt(j.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n            else {\n                removeSegment = i;\n            }\n        }\n        // EJ2-65063 - Added below condition !selectedSegmentIndex to restrict the connector segment to remove from its collection.\n        if (removeSegment !== undefined && !ele.selectedSegmentIndex) {\n            if (removeSegment === ele.segments.length - 1) {\n                ele.segments[removeSegment - 1].direction = null;\n                ele.segments[removeSegment - 1].length = null;\n            }\n            ele.segments.splice(removeSegment, 1);\n        }\n        if (srcPort && i === 0) {\n            var sourcePoint = checkPortdirection(ele, srcPort, sourceEle);\n            if (sourcePoint) {\n                source.point = sourcePoint;\n            }\n        }\n    }\n    return returnIntermeditatePoints(ele, intermeditatePoints);\n}\n/**\n * returnIntermeditatePoints method \\\n *\n * @returns { PointModel[] } returnIntermeditatePoints method .\\\n * @param {Connector} element - provide the ele value.\n * @param {PointModel[]} intermeditatePoints - provide the source value.\n * @private\n */\nfunction returnIntermeditatePoints(element, intermeditatePoints) {\n    for (var i = 0; i < element.segments.length; i++) {\n        var seg = element.segments[parseInt(i.toString(), 10)];\n        for (var j = 0; j < seg.points.length; j++) {\n            if (j > 0 || i === 0) {\n                intermeditatePoints.push(seg.points[parseInt(j.toString(), 10)]);\n            }\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * findDirection method \\\n *\n * @returns { void } findDirection method .\\\n * @param {DiagramElement} node - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the source value.\n * @param {Connector} ele - provide the source value.\n * @private\n */\nfunction findDirection(node, source, target, ele) {\n    var nodeDirection;\n    var nodeConnectingPoint = { x: 0, y: 0 };\n    var nodeCorners = swapBounds(node, node.corners, node.bounds);\n    var nodeMargin = source.margin;\n    var fixedPoint = source.point;\n    if (nodeCorners.bottomCenter.y + nodeMargin.bottom < fixedPoint.y) {\n        nodeDirection = 'Bottom';\n        nodeConnectingPoint = nodeCorners.bottomCenter;\n    }\n    else if (nodeCorners.topCenter.y - nodeMargin.top > fixedPoint.y) {\n        nodeDirection = 'Top';\n        nodeConnectingPoint = nodeCorners.topCenter;\n    }\n    else if (nodeCorners.middleLeft.x - nodeMargin.left > fixedPoint.x) {\n        nodeDirection = 'Left';\n        nodeConnectingPoint = nodeCorners.middleLeft;\n    }\n    else if (nodeCorners.middleRight.x + nodeMargin.right < fixedPoint.x) {\n        nodeDirection = 'Right';\n        nodeConnectingPoint = nodeCorners.middleRight;\n    }\n    else {\n        var top_1 = Math.abs(fixedPoint.y - nodeCorners.topCenter.y);\n        var right = Math.abs(fixedPoint.x - nodeCorners.middleRight.x);\n        var bottom = Math.abs(fixedPoint.y - nodeCorners.bottomCenter.y);\n        var left = Math.abs(fixedPoint.x - nodeCorners.middleLeft.x);\n        var shortes = Number.MAX_VALUE;\n        shortes = top_1;\n        nodeDirection = 'Top';\n        nodeConnectingPoint = nodeCorners.topCenter;\n        if (shortes > right) {\n            shortes = right;\n            nodeDirection = 'Right';\n            nodeConnectingPoint = nodeCorners.middleRight;\n        }\n        if (shortes > bottom) {\n            shortes = bottom;\n            nodeDirection = 'Bottom';\n            nodeConnectingPoint = nodeCorners.bottomCenter;\n        }\n        if (shortes > left) {\n            //shortes = left;\n            nodeDirection = 'Left';\n            nodeConnectingPoint = nodeCorners.middleLeft;\n        }\n    }\n    target.point = nodeConnectingPoint;\n    target.direction = nodeDirection;\n    var refPoint = findPoint(nodeCorners, getOppositeDirection(target.direction));\n    target.point = getIntersection(ele, node, target.point, refPoint, node === ele.targetWrapper);\n}\n/**\n * findOrthoSegments method \\\n *\n * @returns { PointModel[] } findOrthoSegments method .\\\n * @param {DiagramElement} ele - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {Connector} extra - provide the extra value.\n * @param {boolean} lineDistribution - provide the lineDistribution value.\n * @private\n */\nfunction findOrthoSegments(ele, source, target, extra, lineDistribution) {\n    var swap = false;\n    var intermeditatePoints = [];\n    var seg;\n    swap = getSwapping(source.direction, target.direction);\n    if (swap) {\n        swapPoints(source, target);\n    }\n    if (source.direction === 'Right' && target.direction === 'Left') {\n        seg = getRightToLeftSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Right' && target.direction === 'Right') {\n        seg = getRightToRightSegmentCount(ele, source, target);\n    }\n    else if (source.direction === 'Right' && target.direction === 'Top') {\n        seg = getRightToTopSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Right' && target.direction === 'Bottom') {\n        seg = getRightToBottomSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Bottom' && target.direction === 'Top') {\n        seg = getBottomToTopSegmentCount(ele, source, target);\n    }\n    else if (source.direction === 'Bottom' && target.direction === 'Bottom') {\n        /**\n         * EJ2-56920-Option to adjust the distance between source node and target node.\n         */\n        var margin = findMargin(ele);\n        source.margin = { left: margin, right: margin, top: margin, bottom: margin };\n        target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n        seg = getBottomToBottomSegmentCount(ele, source, target);\n    }\n    else if (source.direction === 'Bottom' && target.direction === 'Left') {\n        seg = getBottomToLeftSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Left' && target.direction === 'Left') {\n        seg = getLeftToLeftSegmentCount(ele, source, target);\n    }\n    else if (source.direction === 'Left' && target.direction === 'Top') {\n        seg = getLeftToTopSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Top' && target.direction === 'Top') {\n        seg = getTopToTopSegmentCount(ele, source, target);\n    }\n    if (swap) {\n        swapPoints(source, target);\n    }\n    intermeditatePoints = addOrthoSegments(ele, seg, source, target, extra, lineDistribution);\n    if (ele.type === 'Bezier') {\n        convertPointToBezierSegment(ele, seg, intermeditatePoints);\n    }\n    return intermeditatePoints;\n}\n/**\n * Returns the margin of source node and the target node\n *\n * @returns { number } - findMargin method .\\\n * @param { Connector } element - provide the element value\n * @private\n */\nfunction findMargin(element) {\n    var margin;\n    if (element.connectorSpacing >= 13) {\n        margin = 13;\n    }\n    else if (element.connectorSpacing <= 1) {\n        margin = 1;\n    }\n    else {\n        margin = element.connectorSpacing;\n    }\n    return margin;\n}\n/**\n * findAngle method \\\n *\n * @returns { number } findAngle method .\\\n * @param {DiagramElement} s - provide the s value.\n * @param {End} e - provide the e value.\n * @private\n */\nfunction findAngle(s, e) {\n    var r = { x: e.x, y: s.y };\n    //const sr: number = Point.findLength(s, r);\n    var re = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(r, e);\n    var es = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(e, s);\n    var ang = Math.asin(re / es);\n    ang = ang * 180 / Math.PI;\n    if (s.x < e.x) {\n        if (s.y > e.y) {\n            ang = 360 - ang;\n        }\n    }\n    else {\n        if (s.y < e.y) {\n            ang = 180 - ang;\n        }\n        else {\n            ang = 180 + ang;\n        }\n    }\n    return ang;\n}\n/**\n * findPoint method \\\n *\n * @returns { number } findPoint method .\\\n * @param {Corners} cor - provide the cor value.\n * @param {string} direction - provide the direction value.\n * @private\n */\nfunction findPoint(cor, direction) {\n    var point;\n    switch (direction) {\n        case 'Left':\n            point = cor.middleLeft;\n            break;\n        case 'Top':\n            point = cor.topCenter;\n            break;\n        case 'Right':\n            point = cor.middleRight;\n            break;\n        case 'Bottom':\n            point = cor.bottomCenter;\n            break;\n    }\n    return point;\n}\n/**\n * pointsFromNodeToPoint method \\\n *\n * @returns { number } pointsFromNodeToPoint method .\\\n * @param {OrthogonalSegment} seg - provide the seg value.\n * @param {string} direction - provide the direction value.\n * @param {Rect} bounds - provide the bounds value.\n * @param {PointModel} point - provide the point value.\n * @param {PointModel} endPoint - provide the endPoint value.\n * @param {boolean} isTarget - provide the isTarget value.\n * @private\n */\nfunction pointsFromNodeToPoint(seg, direction, bounds, point, endPoint, isTarget) {\n    var minSpace = 13;\n    var x;\n    var points = [];\n    var y;\n    points.push(point);\n    //let straight: boolean;\n    var straight = (point.y === endPoint.y && (direction === 'Left' && endPoint.x < point.x ||\n        direction === 'Right' && endPoint.x > point.x)) ||\n        (point.x === endPoint.x && (direction === 'Top' && endPoint.y < point.y ||\n            direction === 'Bottom' && endPoint.y > point.y));\n    if (!straight) {\n        if (direction === 'Top' || direction === 'Bottom') {\n            if (direction === 'Top' && endPoint.y < point.y && endPoint.y > point.y - minSpace ||\n                direction === 'Bottom' && endPoint.y > point.y && endPoint.y < point.y + minSpace) {\n                y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;\n                points.push({ x: point.x, y: y });\n                points.push({ x: point.x + (endPoint.x - point.x) / 2, y: y });\n                points.push({ x: point.x + (endPoint.x - point.x) / 2, y: endPoint.y });\n            }\n            else if (Math.abs(point.x - endPoint.x) > minSpace &&\n                (direction === 'Top' && endPoint.y < point.y || direction === 'Bottom' && endPoint.y > point.y)) {\n                //twosegments\n                points.push({ x: point.x, y: endPoint.y });\n            }\n            else {\n                y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;\n                x = (endPoint.x < point.x) ? bounds.left - minSpace : bounds.right + minSpace;\n                points.push({ x: point.x, y: y });\n                points.push({ x: endPoint.x, y: y });\n            }\n        }\n        else {\n            if (direction === 'Left' && endPoint.x < point.x && endPoint.x > point.x - minSpace || direction === 'right' &&\n                endPoint.x > point.x && endPoint.x < point.x + minSpace) {\n                x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;\n                points.push({ x: x, y: point.y });\n                points.push({ x: x, y: point.y + (endPoint.y - point.y) / 2 });\n                points.push({ x: endPoint.x, y: point.y + (endPoint.y - point.y) / 2 });\n            }\n            else if (Math.abs(point.y - endPoint.y) > minSpace &&\n                (direction === 'Left' && endPoint.x < point.x || direction === 'Right' && endPoint.x > point.x)) {\n                points.push({ x: endPoint.x, y: point.y });\n                //twosegments\n            }\n            else {\n                x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;\n                points.push({ x: x, y: point.y });\n                points.push({ x: x, y: endPoint.y });\n            }\n        }\n        if (isTarget) {\n            points.push(seg.points[0]);\n            points.reverse();\n        }\n        seg.points = points;\n    }\n}\n/**\n * addLineSegment method \\\n *\n * @returns { PointModel } addLineSegment method .\\\n * @param {PointModel} point - provide the seg value.\n * @param {number} extra - provide the direction value.\n * @param {number} angle - provide the bounds value.\n * @private\n */\nfunction addLineSegment(point, extra, angle) {\n    var segEnd = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.transform(point, angle, extra);\n    return segEnd;\n}\n/**\n * getIntersection method \\\n *\n * @returns { PointModel } getIntersection method .\\\n * @param {PointModel} ele - provide the ele value.\n * @param {number} bounds - provide the bounds value.\n * @param {number} sPt - provide the sPt value.\n * @param {number} tPt - provide the tPt value.\n * @param {number} isTar - provide the isTar value.\n * @private\n */\nfunction getIntersection(ele, bounds, sPt, tPt, isTar) {\n    sPt = { x: sPt.x, y: sPt.y };\n    tPt = { x: tPt.x, y: tPt.y };\n    //const angle: number = Point.findAngle(tPt, sPt); ///let child: PathElement;// let intersection: PointModel;\n    var wrapper = isTar ? ele.targetWrapper : ele.sourceWrapper;\n    var padding = (isTar ? ele.targetPadding : ele.sourcePadding);\n    var rect;\n    var segmentPoints;\n    var point = isTar || (ele.type === 'Orthogonal' || ele.type === 'Bezier') ? sPt : tPt;\n    //const sourcePoint: PointModel = Point.transform(sPt, angle, Math.max(wrapper.actualSize.height / 2, wrapper.actualSize.width / 2));\n    var child = wrapper;\n    var sPt1 = (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.rotatePoint)(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt);\n    var tPt1 = (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.rotatePoint)(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, tPt);\n    if (ele.type === 'Orthogonal' || ele.type === 'Bezier') {\n        var constValue = 5;\n        if (sPt1.x === tPt1.x) {\n            if (sPt1.y < tPt1.y) {\n                sPt1.y -= constValue;\n            }\n            else {\n                sPt1.y += constValue;\n            }\n        }\n        if (sPt1.y === tPt1.y) {\n            if (sPt1.x < tPt1.x) {\n                sPt1.x -= constValue;\n            }\n            else {\n                sPt1.x += constValue;\n            }\n        }\n        sPt = (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.rotatePoint)(wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt1);\n    }\n    else {\n        //const angle: number = isTar ? Point.findAngle(sPt, tPt) : Point.findAngle(tPt, sPt);\n        if (isTar) {\n            var angle = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(sPt, tPt);\n            tPt = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.transform({ x: tPt.x, y: tPt.y }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));\n        }\n        else {\n            var angle = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(tPt, sPt);\n            sPt = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.transform({ x: sPt.x, y: sPt.y }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));\n        }\n    }\n    if ((ele.sourcePadding || ele.targetPadding)) {\n        rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(wrapper.bounds.x - padding, wrapper.bounds.y - padding, wrapper.actualSize.width + 2 * padding, wrapper.actualSize.height + 2 * padding);\n    }\n    if (wrapper instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_5__.PathElement && wrapper.data) {\n        segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : child.getPoints();\n        if (((child.data.split('m').length - 1) + (child.data.split('M').length - 1)) === 1) {\n            segmentPoints[segmentPoints.length] = segmentPoints[0];\n        }\n    }\n    else {\n        segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : (0,_diagram_util__WEBPACK_IMPORTED_MODULE_2__.getPoints)(wrapper, wrapper.corners);\n        segmentPoints[segmentPoints.length] = segmentPoints[0];\n    }\n    //const length: number = segmentPoints.length;\n    var thisSegment = { x1: sPt.x, y1: sPt.y, x2: tPt.x, y2: tPt.y };\n    return getIntersectionPoints(thisSegment, segmentPoints, true, point) || sPt;\n}\n/**\n * setLineEndPoint method \\\n *\n * @returns { PointModel } setLineEndPoint method .\\\n * @param {PointModel} element - provide the ele value.\n * @param {number} point - provide the bounds value.\n * @param {number} isTarget - provide the sPt value.\n * @private\n */\nfunction setLineEndPoint(element, point, isTarget) {\n    point.x = Math.round(point.x * 100) / 100;\n    point.y = Math.round(point.y * 100) / 100;\n    if (isTarget) {\n        element.targetPoint = point;\n    }\n    else {\n        element.sourcePoint = point;\n    }\n    return point;\n}\n/**\n * getIntersectionPoints method \\\n *\n * @returns { PointModel } getIntersectionPoints method .\\\n * @param {Segment} thisSegment - provide the ele value.\n * @param {Object[]} pts - provide the bounds value.\n * @param {boolean} minimal - provide the sPt value.\n * @param {PointModel} point - provide the sPt value.\n * @private\n */\nfunction getIntersectionPoints(thisSegment, pts, minimal, point) {\n    var length = pts.length;\n    var min;\n    var segment = {\n        x1: pts[0].x, y1: pts[0].y, x2: pts[1].x,\n        y2: pts[1].y\n    };\n    var intersection = intersectSegment(thisSegment, segment);\n    if (intersection) {\n        // if (!minimal) { return intersection; } //commented because minimal is always true\n        min = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(intersection, point);\n    }\n    if (isNaN(min) || min > 0) {\n        for (var i = 1; i < length - 1; i++) {\n            segment = {\n                x1: pts[parseInt(i.toString(), 10)].x, y1: pts[parseInt(i.toString(), 10)].y,\n                x2: pts[i + 1].x, y2: pts[i + 1].y\n            };\n            var intersect = intersectSegment(thisSegment, segment);\n            if (intersect) {\n                // if (!minimal) { return intersect; }//commented because minimal is always true\n                var dist = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(intersect, point);\n                if (isNaN(min) || min > dist) {\n                    min = dist;\n                    intersection = intersect;\n                }\n                if (min >= 0 && min <= 1) {\n                    break;\n                }\n            }\n        }\n    }\n    return intersection;\n}\n/**\n * intersectSegment method \\\n *\n * @returns { PointModel } intersectSegment method .\\\n * @param {Segment} segment1 - provide the ele value.\n * @param {Segment} segment2 - provide the bounds value.\n * @private\n */\nfunction intersectSegment(segment1, segment2) {\n    var x1 = segment1.x1;\n    var y1 = segment1.y1;\n    var x2 = segment1.x2;\n    var y2 = segment1.y2;\n    var x3 = segment2.x1;\n    var y3 = segment2.y1;\n    var x4 = segment2.x2;\n    var y4 = segment2.y2;\n    var a1;\n    var a2;\n    var b1;\n    var b2;\n    var c1;\n    var c2;\n    var x;\n    var y;\n    var r1;\n    var r2;\n    var r3;\n    var r4;\n    var offset;\n    var num;\n    // eslint-disable-next-line\n    a1 = y2 - y1;\n    b1 = x1 - x2;\n    c1 = (x2 * y1) - (x1 * y2);\n    // eslint-disable-next-line\n    r3 = ((a1 * x3) + (b1 * y3) + c1);\n    r4 = ((a1 * x4) + (b1 * y4) + c1);\n    if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {\n        return null;\n    }\n    // eslint-disable-next-line\n    a2 = y4 - y3;\n    b2 = x3 - x4;\n    c2 = (x4 * y3) - (x3 * y4);\n    // eslint-disable-next-line\n    r1 = (a2 * x1) + (b2 * y1) + c2;\n    r2 = (a2 * x2) + (b2 * y2) + c2;\n    if ((r1 !== 0) && (r2 !== 0) && (sameSign(r1, r2))) {\n        return null;\n    }\n    var denom = (a1 * b2) - (a2 * b1);\n    if (denom === 0) {\n        return null;\n    }\n    if (denom < 0) {\n        offset = -denom / 2;\n    }\n    else {\n        offset = denom / 2;\n    }\n    offset = 0;\n    num = (b1 * c2) - (b2 * c1);\n    if (num < 0) {\n        x = (num - offset) / denom;\n    }\n    else {\n        x = (num + offset) / denom;\n    }\n    num = (a2 * c1) - (a1 * c2);\n    if (num < 0) {\n        y = (num - offset) / denom;\n    }\n    else {\n        y = (num + offset) / denom;\n    }\n    return { x: x, y: y };\n}\n/**\n * sameSign method \\\n *\n * @returns { boolean } sameSign method .\\\n * @param {Connector} a - provide the Connector value.\n * @param {End} b - provide the source End value.\n * @private\n */\nfunction sameSign(a, b) {\n    return ((a * b) >= 0);\n}\n/**\n * getRightToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToLeftSegmentCount method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} source - provide the source End value.\n * @param {End} target - provide the target  End value.\n * @param {boolean} swap - provide the swap value.\n * @private\n */\nfunction getRightToLeftSegmentCount(element, source, target, swap) {\n    var srcPort = element.sourcePortWrapper;\n    //let targetPort: DiagramElement = element.targetPortWrapper;\n    var pts;\n    var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n    //let diffX: number = Math.round(Math.abs(source.point.x - target.point.x));\n    var right = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };\n    var left = { x: Math.min(target.point.x, target.corners.left), y: target.point.y };\n    var margin = findMargin(element);\n    if (swap) {\n        //let point: PointModel;\n        var point = left;\n        left = right;\n        right = point;\n    }\n    if (!(source.corners.bottom + margin < target.corners.top - margin ||\n        source.corners.top - margin > target.corners.bottom + margin)) {\n        if (element.type !== 'Bezier') {\n            margin = 0;\n        }\n        else if (target.corners.left - source.corners.right <= margin * 2 && target.corners.left - source.corners.right >= 5) {\n            margin = 0;\n        }\n    }\n    source.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    if (diffY === 0 && (source.corners.right < target.corners.left\n        || (swap && source.corners.right < target.corners.left))) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n    }\n    else if (source.point.x + source.margin.right < target.point.x - target.margin.left) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if (element.sourceWrapper !== element.targetWrapper &&\n        ((0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.sourceWrapper).containsPoint(left) ||\n            (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.targetWrapper).containsPoint(right))) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if (source.corners.bottom <= target.corners.top) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if (source.corners.top >= target.corners.top) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY <= target.corners.top) ||\n        (srcPort === undefined && source.corners.right <= target.corners.top)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY >= target.corners.bottom) ||\n        (srcPort === undefined && source.corners.right >= target.corners.bottom)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    return pts;\n}\n/**\n * getRightToRightSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToRightSegmentCount method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} sourceObj - provide the source End value.\n * @param {End} targetObj - provide the target  End value.\n * @private\n */\nfunction getRightToRightSegmentCount(element, sourceObj, targetObj) {\n    var sourcePort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    var pts;\n    var diffX = sourceObj.point.x - targetObj.point.x;\n    var diffY = sourceObj.point.y - targetObj.point.y;\n    var margin = findMargin(element);\n    targetObj.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    sourceObj.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    if (sourceObj.corners.right >= targetObj.corners.right) {\n        if ((sourcePort !== undefined && (sourcePort.offsetY < targetObj.corners.top - targetObj.margin.top ||\n            sourcePort.offsetY > targetObj.corners.bottom + targetObj.margin.bottom)) ||\n            (sourcePort === undefined && sourceObj.corners.middleRight.y < targetObj.corners.top)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if ((sourcePort !== undefined && sourcePort.offsetY > targetObj.corners.bottom + targetObj.margin.bottom\n            && sourceObj.corners.top > targetObj.corners.bottom) ||\n            (sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if ((sourcePort !== undefined && sourcePort.offsetY < targetObj.corners.top - targetObj.margin.top\n            && sourceObj.corners.bottom > targetObj.corners.top) ||\n            (sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if (sourceObj.corners.right < targetObj.corners.left ||\n            targetObj.corners.right < sourceObj.corners.left) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n        }\n        else if (diffX === 0 || diffY === 0) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n    }\n    else if ((tarPort !== undefined && sourceObj.corners.bottom < tarPort.offsetY - targetObj.margin.top) ||\n        (tarPort === undefined && sourceObj.corners.bottom < targetObj.corners.middleRight.y)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if ((tarPort !== undefined && sourceObj.corners.top > tarPort.offsetY + targetObj.margin.right) ||\n        (tarPort === undefined && sourceObj.corners.top > targetObj.corners.middleRight.y)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if ((tarPort !== undefined && ((sourcePort !== undefined && sourcePort.offsetX < targetObj.corners.left &&\n        sourcePort.offsetX !== tarPort.offsetX && (Math.abs(sourceObj.corners.right - targetObj.corners.left) <= 20)) ||\n        (sourcePort === undefined && sourceObj.corners.right < targetObj.corners.left &&\n            sourceObj.corners.center.x !== targetObj.corners.center.x && sourceObj.corners.center.y !== targetObj.corners.center.y)))) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if (sourceObj.corners.right < targetObj.corners.left) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if (diffX === 0 || diffY === 0) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * getRightToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToTopSegmentCount method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap value.\n * @private\n */\nfunction getRightToTopSegmentCount(element, source, target, swap) {\n    var tarPort = element.targetPortWrapper;\n    var srcPort = element.sourcePortWrapper;\n    var right = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };\n    var top = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };\n    var margin = findMargin(element);\n    var pts;\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    source.margin = { top: margin, bottom: margin, left: margin, right: margin };\n    if (swap) {\n        //let port: DiagramElement;\n        var port = srcPort;\n        srcPort = tarPort;\n        tarPort = port;\n        var point = right;\n        right = top;\n        top = point;\n    }\n    if ((srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top) ||\n        (srcPort === undefined && source.corners.bottom < target.corners.top - target.margin.top)) {\n        if (source.corners.bottom < target.corners.top) {\n            if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||\n                (tarPort === undefined && source.corners.right + source.margin.right < target.corners.topCenter.x)) {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n            }\n            else {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.left > tarPort.offsetX) ||\n            (tarPort === undefined && source.corners.left > target.corners.topCenter.x)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n        }\n    }\n    else if (srcPort !== undefined && Math.abs(source.corners.right - target.corners.left) <= 5 &&\n        Math.abs(srcPort.offsetY - target.corners.top) <= 5) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n    }\n    else if (tarPort !== undefined && source.corners.right < target.corners.left\n        && Math.abs(tarPort.offsetX - source.corners.topCenter.x) >= 25\n        && source.corners.middleRight.y + source.margin.right < tarPort.offsetY) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n    }\n    else if (source.corners.right < target.corners.left) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n    }\n    else if (element.sourceWrapper !== element.targetWrapper &&\n        ((0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.sourceWrapper).containsPoint(top) ||\n            (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.targetWrapper).containsPoint(right))) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getRightToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToTopSegmentCount method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap value.\n * @private\n */\nfunction getRightToBottomSegmentCount(element, source, target, swap) {\n    var margin = findMargin(element);\n    source.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    var pts;\n    var srcPort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    //let right: PointModel = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };\n    //let bottom: PointModel = { x: target.point.x, y: Math.max(target.point.y, target.corners.bottom) };\n    if (swap) {\n        //let port: DiagramElement;\n        var port = srcPort;\n        srcPort = tarPort;\n        tarPort = port;\n    }\n    if ((srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom) ||\n        (srcPort === undefined && source.corners.middleRight.y > target.corners.bottom + target.margin.bottom)) {\n        if (source.corners.top > target.corners.bottom) {\n            if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||\n                (tarPort === undefined && source.corners.right + source.margin.right < target.corners.bottomCenter.x)) {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n            }\n            else {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.left > tarPort.offsetX) ||\n            (tarPort === undefined && source.corners.left > target.corners.bottomCenter.x)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n        }\n    }\n    else if (srcPort !== undefined &&\n        Math.abs(source.corners.right - target.corners.left) <= 25 &&\n        Math.abs(srcPort.offsetY - target.corners.bottom) <= 25) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n    }\n    else if (source.corners.right < target.corners.left) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getBottomToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToTopSegmentCount method .\\\n * @param {Connector} element - provide the connector value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getBottomToTopSegmentCount(element, source, target) {\n    var pts;\n    var diffX = source.point.x - target.point.x;\n    //const diffY: number = source.point.y - target.point.y;\n    //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };\n    //let top: PointModel = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };\n    var margin = findMargin(element);\n    if (!(source.corners.right + margin < target.corners.left - margin ||\n        source.corners.left - margin > target.corners.right + margin)) {\n        if (element.type !== 'Bezier') {\n            margin = 0;\n        }\n        else if (target.corners.top - source.corners.bottom <= margin * 2 && target.corners.top - source.corners.bottom >= 5) {\n            margin = 0;\n        }\n    }\n    source.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    if (diffX === 0 && source.corners.bottom < target.corners.top) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n    }\n    else if (source.corners.bottom + source.margin.bottom < target.corners.top - target.margin.top) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if (source.corners.right + source.margin.right < target.corners.left - target.margin.left) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if (source.corners.left - source.margin.left > target.corners.right + target.margin.right) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    return pts;\n}\n/**\n * getBottomToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToLeftSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap  value.\n * @private\n */\nfunction getBottomToLeftSegmentCount(element, source, target, swap) {\n    var srcPort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };\n    //let left: PointModel = { x: Math.min(target.point.x, target.corners.left), y: target.point.y };\n    var margin = findMargin(element);\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    source.margin = { top: margin, bottom: margin, left: margin, right: margin };\n    var pts;\n    if (swap) {\n        //let port: DiagramElement;\n        var port = srcPort;\n        srcPort = tarPort;\n        tarPort = port;\n    }\n    if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||\n        (srcPort === undefined && source.corners.bottomCenter.x < target.corners.bottomLeft.x - target.margin.left)) {\n        if (source.corners.right < target.corners.left) {\n            if ((tarPort !== undefined && source.corners.bottom + source.margin.bottom < tarPort.offsetY) ||\n                (tarPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y)) {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n            }\n            else {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.top > tarPort.offsetY) ||\n            (tarPort === undefined && source.corners.top > target.corners.middleLeft.y)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n        }\n    }\n    else if (tarPort !== undefined &&\n        Math.abs(source.corners.right - target.corners.left) <= 25 &&\n        Math.abs(tarPort.offsetY - source.corners.bottom) <= 25) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getBottomToBottomSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToBottomSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getBottomToBottomSegmentCount(element, source, target) {\n    var srcPort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    var difX = Math.round(Math.abs(source.point.x - target.point.x));\n    var diffY = Math.round(Math.abs(target.point.y - target.point.y));\n    var pts;\n    if (source.corners.bottom < target.corners.bottom) {\n        if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||\n            (srcPort === undefined && source.corners.bottomCenter.x < target.corners.left - target.margin.left)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if ((srcPort !== undefined && srcPort.offsetX > target.corners.right + target.margin.right) ||\n            (srcPort === undefined && source.corners.bottomCenter.x > target.corners.right + target.margin.right)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if (source.corners.bottom < target.corners.top) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n        }\n        else if (difX === 0 || diffY === 0) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n    }\n    else if ((tarPort !== undefined && source.corners.left - source.margin.left > tarPort.offsetX) ||\n        (tarPort === undefined && source.corners.left > target.corners.left)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||\n        (tarPort === undefined &&\n            source.corners.right < target.corners.right)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if (source.corners.top > target.corners.bottom) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if (difX === 0 || diffY === 0) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * getLeftToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getLeftToTopSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap  value.\n * @private\n */\nfunction getLeftToTopSegmentCount(element, source, target, swap) {\n    var pts;\n    var sourcePort = element.sourcePortWrapper;\n    var margin = findMargin(element);\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    source.margin = { top: margin, bottom: margin, left: margin, right: margin };\n    var tarPort = element.targetPortWrapper;\n    var left = { x: Math.min(source.point.x, source.corners.left), y: source.point.y };\n    var top = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };\n    if (swap) {\n        //let port: DiagramElement;\n        var port = sourcePort;\n        sourcePort = tarPort;\n        tarPort = port;\n        var point = left;\n        left = top;\n        top = point;\n    }\n    if ((sourcePort !== undefined && sourcePort.offsetY < target.corners.top - target.margin.top) ||\n        (sourcePort === undefined && (source.corners.bottom < target.corners.top - target.margin.top ||\n            source.corners.middleLeft.y < target.corners.top - target.margin.top))) {\n        if (source.corners.bottom < target.corners.top) {\n            if ((tarPort !== undefined && source.corners.left - source.margin.left > tarPort.offsetX) ||\n                (tarPort === undefined && source.corners.left - source.margin.left > target.corners.topCenter.x)) {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n            }\n            else {\n                pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.right < tarPort.offsetX) ||\n            (tarPort === undefined && source.corners.right < target.corners.topCenter.x)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n        }\n    }\n    else if (sourcePort !== undefined &&\n        Math.abs(source.corners.left - target.corners.right) <= 25 &&\n        Math.abs(sourcePort.offsetY - target.corners.top) <= 25) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n    }\n    else if (element.sourceWrapper !== element.targetWrapper &&\n        ((0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.sourceWrapper).containsPoint(top) ||\n            (0,_base_util__WEBPACK_IMPORTED_MODULE_6__.cornersPointsBeforeRotation)(element.targetWrapper).containsPoint(left))) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two;\n    }\n    else if (source.corners.left > target.corners.right) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getLeftToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getLeftToLeftSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getLeftToLeftSegmentCount(element, source, target) {\n    var srcPort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var margin = findMargin(element);\n    source.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    var diffX = Math.round(Math.abs(source.point.x - target.point.x));\n    var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n    var pts;\n    if (source.corners.left < target.corners.left) {\n        if ((targetPort !== undefined && source.corners.bottom + source.margin.bottom < targetPort.offsetY) ||\n            (targetPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if ((targetPort !== undefined && source.corners.top - source.margin.top > targetPort.offsetY) ||\n            (targetPort === undefined && source.corners.top - source.margin.top > target.corners.middleLeft.y)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if (source.corners.right < target.corners.left ||\n            target.corners.right < source.corners.left) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n        }\n        else if (diffX === 0 || diffY === 0) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top) ||\n        (srcPort === undefined && source.corners.middleLeft.y < target.corners.top)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom) ||\n        (srcPort === undefined && source.corners.middleLeft.y > target.corners.bottom + target.margin.bottom)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if (source.corners.left > target.corners.right) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if (diffX === 0 || diffY === 0) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * getTopToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getTopToTopSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getTopToTopSegmentCount(element, source, target) {\n    var srcPort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var diffX = Math.round(Math.abs(source.point.x - target.point.x));\n    var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n    var margin = findMargin(element);\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    source.margin = { top: margin, bottom: margin, left: margin, right: margin };\n    var pts;\n    if (source.corners.top < target.corners.top) {\n        if ((targetPort !== undefined && source.corners.left - source.margin.left > targetPort.offsetX) ||\n            (targetPort === undefined && source.corners.left > target.corners.left)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if ((targetPort !== undefined && source.corners.right + source.margin.right < targetPort.offsetX) ||\n            (targetPort === undefined && source.corners.right < target.corners.right)) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n        else if (source.corners.bottom < target.corners.top) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n        }\n        else if (diffX === 0 || diffY === 0) {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n        }\n        else {\n            pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n        }\n    }\n    else if ((srcPort !== undefined && srcPort.offsetX > target.corners.right + target.margin.right) ||\n        (srcPort === undefined && source.corners.left > target.corners.right)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||\n        (srcPort === undefined && source.corners.bottomRight.x < target.corners.left)) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    else if (source.corners.top > target.corners.bottom) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five;\n    }\n    else if (diffX === 0 || diffY === 0) {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One;\n    }\n    else {\n        pts = _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * addOrthoSegments method \\\n *\n * @returns {  PointModel[] } addOrthoSegments method .\\\n * @param {Connector} element - provide the element value.\n * @param {NoOfSegments} seg - provide the seg  value.\n * @param {End} sourceEnd - provide the source  value.\n * @param {End} targetEnd - provide the target  value.\n * @param {number} segLength - provide the segLength  value.\n * @param {boolean} lineDistribution - provide the lineDistribution  value.\n * @private\n */\nfunction addOrthoSegments(element, seg, sourceEnd, targetEnd, segLength, lineDistribution) {\n    var src = element.sourceWrapper;\n    var tar = element.targetWrapper;\n    //let tarPort: DiagramElement = element.targetPortWrapper;\n    var intermeditatePoints;\n    var srcCorner = src.corners;\n    var tarCorner = tar.corners;\n    var value;\n    var extra = 20;\n    var source = { corners: sourceEnd.corners, point: sourceEnd.point, direction: sourceEnd.direction, margin: sourceEnd.margin };\n    var target = { corners: targetEnd.corners, point: targetEnd.point, direction: targetEnd.direction, margin: targetEnd.margin };\n    if (source.direction !== target.direction || seg === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five) {\n        if (source.direction === getOppositeDirection(target.direction) || seg === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three) {\n            switch (source.direction) {\n                case 'Left':\n                    if (srcCorner.middleLeft.x > tarCorner.middleRight.x) {\n                        value = (srcCorner.middleLeft.x - tarCorner.middleRight.x) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n                case 'Right':\n                    if (srcCorner.middleRight.x < tarCorner.middleLeft.x) {\n                        value = (tarCorner.middleLeft.x - srcCorner.middleRight.x) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n                case 'Top':\n                    if (srcCorner.topCenter.y > tarCorner.bottomCenter.y) {\n                        value = (srcCorner.topCenter.y - tarCorner.bottomCenter.y) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n                case 'Bottom':\n                    if (srcCorner.bottomCenter.y < tarCorner.topCenter.y) {\n                        value = (tarCorner.topCenter.y - srcCorner.bottomCenter.y) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n            }\n        }\n    }\n    extra = adjustSegmentLength(srcCorner, source, extra);\n    var isBezier = element.type === 'Bezier';\n    if (segLength) {\n        extra = Math.max(extra, segLength);\n    }\n    if (seg === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One) {\n        intermeditatePoints = [source.point, target.point];\n    }\n    if (seg === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two) {\n        intermeditatePoints = orthoConnection2Segment(source, target);\n    }\n    if (seg === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three) {\n        intermeditatePoints = orthoConnection3Segment(element, source, target, extra, undefined, isBezier);\n    }\n    if (seg === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four) {\n        var prevDir = undefined;\n        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, extra, isBezier);\n    }\n    if (seg === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five) {\n        intermeditatePoints = orthoConnection5Segment(source, target, extra, isBezier);\n    }\n    return intermeditatePoints;\n}\n/**\n * adjustSegmentLength method \\\n *\n * @returns {  PointModel[] } adjustSegmentLength method .\\\n * @param {Rect | Corners} bounds - provide the element value.\n * @param {End} source - provide the seg  value.\n * @param {number} extra - provide the source  value.\n * @private\n */\nfunction adjustSegmentLength(bounds, source, extra) {\n    switch (source.direction) {\n        case 'Left':\n            if (source.point.x > bounds.left) {\n                extra = (source.point.x - bounds.left) > extra ? ((source.point.x - bounds.left) + extra) : extra;\n            }\n            break;\n        case 'Right':\n            if (source.point.x < bounds.right) {\n                extra = (bounds.right - source.point.x) > extra ? ((bounds.right - source.point.x) + extra) : extra;\n            }\n            break;\n        case 'Top':\n            if (source.point.y > bounds.top) {\n                extra = (source.point.y - bounds.top) > extra ? ((source.point.y - bounds.top) + extra) : extra;\n            }\n            break;\n        case 'Bottom':\n            if (source.point.y < bounds.bottom) {\n                extra = (bounds.bottom - source.point.y) > extra ? ((bounds.bottom - source.point.y) + extra) : extra;\n            }\n            break;\n    }\n    return extra;\n}\n/**\n * orthoConnection2Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection2Segment method .\\\n * @param {Rect | Corners} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction orthoConnection2Segment(source, target) {\n    var intermeditatePoints;\n    switch (source.direction) {\n        case 'Left':\n        case 'Right':\n            // eslint-disable-next-line\n            var point1 = { x: target.point.x, y: source.point.y };\n            intermeditatePoints = (_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.equals(source.point, point1) || _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.equals(target.point, point1)) ?\n                [source.point, target.point] : [source.point, point1, target.point];\n            break;\n        case 'Top':\n        case 'Bottom':\n            // eslint-disable-next-line no-case-declarations\n            var point2 = { x: source.point.x, y: target.point.y };\n            intermeditatePoints = (_primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.equals(source.point, point2) || _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.equals(target.point, point2)) ?\n                [source.point, target.point] : [source.point, point2, target.point];\n            break;\n    }\n    return intermeditatePoints;\n}\n/**\n * orthoConnection3Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection2Segment method .\\\n * @param {Connector} element - provide the source value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {number} extra - provide the target  value.\n * @param {boolean} allow - provide the target  value.\n * @param {boolean} isBezier - provide the isBezier boolean value.\n * @private\n */\nfunction orthoConnection3Segment(element, source, target, extra, allow, isBezier) {\n    if (isBezier === void 0) { isBezier = false; }\n    if (!extra) {\n        extra = 20;\n    }\n    if (isBezier) {\n        if (source.direction !== target.direction) {\n            if (source.direction === 'Left' || source.direction === 'Right') {\n                extra = Math.floor(Math.abs(source.point.x - target.point.x) * 0.5);\n            }\n            else {\n                extra = Math.floor(Math.abs(source.point.y - target.point.y) * 0.5);\n            }\n        }\n    }\n    var srcPort = element.sourcePortWrapper;\n    var intermeditatePoints;\n    var segmentValue;\n    var next;\n    var diffx = target.point.x - source.point.x;\n    var diffy = target.point.y - source.point.y;\n    var temp;\n    if (!allow && (Math.abs(diffx) < 0.001 || Math.abs(diffy) < 0.001)) {\n        if (target.direction === undefined) {\n            intermeditatePoints = [source.point, target.point];\n            return intermeditatePoints;\n        }\n    }\n    if (element.targetWrapper === undefined && Math.abs(diffx) <= 31 && Math.abs(diffy) <= 31) {\n        if ((source.direction === 'Left' || source.direction === 'Right')) {\n            if (Math.abs(diffy) < 12) {\n                source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n            }\n        }\n        else {\n            if (Math.abs(diffx) < 12) {\n                source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n            }\n        }\n        if (Math.abs(diffx) > 12 || Math.abs(diffy) > 12) {\n            return orthoConnection2Segment(source, target);\n        }\n        else {\n            extra += 5;\n        }\n    }\n    if (source.direction === 'Left' || source.direction === 'Right') {\n        if (source.direction === 'Right') {\n            if (target.direction !== undefined && target.direction === 'Right') {\n                extra = Math.max(source.point.x, target.point.x) - source.point.x + extra;\n            }\n            if (source.point.x > target.point.x && srcPort === undefined) {\n                extra = -extra;\n            }\n        }\n        else {\n            if (target.direction !== undefined && target.direction === 'Left') {\n                extra = source.point.x - Math.min(source.point.x, target.point.x) + extra;\n            }\n            if (source.point.x > target.point.x || srcPort !== undefined || source.direction === 'Left') {\n                extra = -extra;\n            }\n        }\n        temp = target.point.y - source.point.y;\n        segmentValue = addLineSegment(source.point, extra, 0);\n        temp = target.point.y - segmentValue.y;\n        if (temp !== 0) {\n            next = addLineSegment(segmentValue, target.point.y - segmentValue.y, 90);\n        }\n    }\n    else if (source.direction === 'Top' || source.direction === 'Bottom') {\n        if (source.direction === 'Bottom') {\n            if (target.direction !== undefined && target.direction === 'Bottom') {\n                extra = Math.max(source.point.y, target.point.y) - source.point.y + extra;\n            }\n        }\n        else {\n            if (target.direction !== undefined && target.direction === 'Top') {\n                extra = source.point.y - Math.min(source.point.y, target.point.y) + extra;\n            }\n            if (source.point.y > target.point.y || (srcPort !== undefined) || source.direction === 'Top') {\n                extra = -extra;\n            }\n        }\n        temp = target.point.x - source.point.x;\n        if (source.direction === 'Top') {\n            segmentValue = addLineSegment(source.point, extra, 90);\n        }\n        else {\n            segmentValue = addLineSegment(source.point, extra, 90);\n        }\n        temp = target.point.x - segmentValue.x;\n        if (temp !== 0) {\n            next = addLineSegment(segmentValue, target.point.x - segmentValue.x, 0);\n        }\n    }\n    if (temp === 0) {\n        return intermeditatePoints = [\n            source.point,\n            target.point\n        ];\n    }\n    intermeditatePoints = [\n        source.point,\n        segmentValue,\n        next,\n        target.point\n    ];\n    return intermeditatePoints;\n}\n/**\n * orthoConnection5Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection5Segment method .\\\n * @param {Connector} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @param {End} extra - provide the extra  value.\n * @param {boolean} isBezier - provide the isBezier  value.\n * @private\n */\nfunction orthoConnection5Segment(source, target, extra, isBezier) {\n    if (extra === void 0) { extra = 20; }\n    if (isBezier === void 0) { isBezier = false; }\n    if (isBezier) {\n        extra = 20;\n    }\n    var intermeditatePoints;\n    var length = extra;\n    var sLeft = source.corners.left - source.margin.left;\n    var sRight = source.corners.right + source.margin.right;\n    var sBottom = source.corners.bottom + source.margin.bottom;\n    var sTop = source.corners.top - source.margin.top;\n    var tLeft = target.corners.left - target.margin.left;\n    var tRight = target.corners.right + target.margin.right;\n    var tBottom = target.corners.bottom + target.margin.bottom;\n    var tTop = target.corners.top - target.margin.top;\n    var segmentValue;\n    switch (source.direction) {\n        case 'Left':\n            if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) &&\n                sLeft > tLeft && sLeft <= tRight && extra >= 20) {\n                length = source.point.x - target.corners.left + length;\n            }\n            if (isBezier && source.direction === target.direction) {\n                if (source.corners.left > target.corners.left && source.corners.left - target.corners.right >= 20) {\n                    length = (source.corners.left - target.corners.right) / 2;\n                }\n            }\n            segmentValue = addLineSegment(source.point, length, 180);\n            break;\n        case 'Top':\n            if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) &&\n                sTop > tTop && sTop <= tBottom && extra >= 20) {\n                length = source.point.y - target.corners.top + length;\n            }\n            if (isBezier && source.direction === target.direction) {\n                if (source.corners.top > target.corners.top && source.corners.top - target.corners.bottom >= 20) {\n                    length = (source.corners.top - target.corners.bottom) / 2;\n                }\n            }\n            segmentValue = addLineSegment(source.point, length, 270);\n            break;\n        case 'Right':\n            if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) &&\n                sRight < tRight && sRight >= tLeft && extra >= 20) {\n                length = target.corners.right - source.point.x + length;\n            }\n            if (isBezier && source.direction === target.direction) {\n                if (source.corners.right < target.corners.right && target.corners.left - source.corners.right >= 20) {\n                    length = (target.corners.left - source.corners.right) / 2;\n                }\n            }\n            segmentValue = addLineSegment(source.point, length, 0);\n            break;\n        case 'Bottom':\n            if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) &&\n                sBottom < tBottom && sBottom >= tTop && extra >= 20) {\n                length = target.corners.bottom - source.point.y + length;\n            }\n            if (isBezier && source.direction === target.direction) {\n                if (source.corners.bottom < target.corners.bottom && target.corners.top - source.corners.bottom >= 20) {\n                    length = (target.corners.top - source.corners.bottom) / 2;\n                }\n            }\n            segmentValue = addLineSegment(source.point, length, 90);\n            break;\n    }\n    intermeditatePoints = [\n        source.point,\n        segmentValue\n    ];\n    var newExtra = undefined;\n    if (source.direction === 'Top' || source.direction === 'Bottom') {\n        var prevDir = source.direction;\n        source.direction = segmentValue.x > target.point.x ? 'Left' : 'Right';\n        source.point = segmentValue;\n        newExtra = isBezier ? Math.abs(segmentValue.x - target.point.x) * 0.5 : newExtra;\n        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, newExtra, isBezier);\n    }\n    else {\n        var prevDir = source.direction;\n        source.direction = segmentValue.y > target.point.y ? 'Top' : 'Bottom';\n        source.point = segmentValue;\n        newExtra = isBezier ? Math.abs(segmentValue.y - target.point.y) * 0.5 : newExtra;\n        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, newExtra, isBezier);\n    }\n    return intermeditatePoints;\n}\n/**\n * orthoConnection4Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection4Segment method .\\\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {string} prevDir - provide the target  value.\n * @param {PointModel[]} interPt - provide the target  value.\n * @param {number} e - provide the target  value.\n * @param {boolean} isBezier - provide the target  value.\n * @private\n */\nfunction orthoConnection4Segment(source, target, prevDir, interPt, e, isBezier) {\n    if (e === void 0) { e = 20; }\n    if (isBezier === void 0) { isBezier = false; }\n    var segmentValue;\n    if (prevDir === undefined) {\n        source.margin = { left: 2, right: 2, top: 2, bottom: 2 };\n        target.margin = { left: 0, right: 5, top: 0, bottom: 5 };\n        if (isBezier) {\n            source.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n            target.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n            if (source.direction === 'Left') {\n                e = getLeftLength(source, target, prevDir, e);\n                if (source.corners.left - target.corners.right >= 5) {\n                    e = Math.abs(source.point.x - source.corners.left) + Math.floor(source.corners.left - target.corners.right) * 0.5;\n                }\n            }\n            else if (source.direction === 'Right') {\n                e = getRightLength(source, target, e, prevDir);\n                if (target.corners.left - source.corners.right >= 5) {\n                    e = Math.abs(source.point.x - source.corners.right) + Math.floor(target.corners.left - source.corners.right) * 0.5;\n                }\n            }\n            else if (source.direction === 'Top') {\n                e = getTopLength(source, target, prevDir, e);\n                if (source.corners.top - target.corners.bottom >= 5) {\n                    e = Math.abs(source.point.y - source.corners.top) + Math.floor(source.corners.top - target.corners.bottom) * 0.5;\n                }\n            }\n            else if (source.direction === 'Bottom') {\n                e = getBottomLength(source, target, e, prevDir);\n                if (target.corners.top - source.corners.bottom >= 5) {\n                    e = Math.abs(source.point.y - source.corners.bottom) + Math.floor(target.corners.top - source.corners.bottom) * 0.5;\n                }\n            }\n        }\n    }\n    else {\n        if (source.direction === 'Bottom') {\n            if (isBezier) {\n                if (target.corners.top - source.corners.bottom < 20) {\n                    e = (target.corners.bottom - source.point.y) + 25;\n                }\n            }\n            else {\n                if (target.corners.top > source.corners.bottom && target.corners.top - source.corners.bottom < 20) {\n                    e = (target.corners.top - source.corners.bottom) / 2;\n                }\n            }\n        }\n        else if (source.direction === 'Top') {\n            if (isBezier) {\n                if (source.corners.top - target.corners.bottom < 20) {\n                    e = (source.point.y - target.corners.top) + 25;\n                }\n            }\n            else {\n                if (target.corners.bottom < source.corners.top && source.corners.top - target.corners.bottom < 20) {\n                    e = (source.corners.top - target.corners.bottom) / 2;\n                }\n            }\n        }\n        else if (source.direction === 'Right') {\n            if (isBezier) {\n                if (target.corners.left - source.corners.right < 20) {\n                    e = (target.corners.right - source.point.x) + 25;\n                }\n            }\n            else {\n                if (target.corners.left > source.corners.right && target.corners.left - source.corners.right < 20) {\n                    e = (target.corners.left - source.corners.right) / 2;\n                }\n            }\n        }\n        else if (source.direction === 'Left') {\n            if (isBezier) {\n                if (source.corners.left - target.corners.right < 20) {\n                    e = (source.point.x - target.corners.left) + 25;\n                }\n            }\n            else {\n                if (target.corners.right < source.corners.left && source.corners.left - target.corners.right < 20) {\n                    e = (source.corners.left - target.corners.right) / 2;\n                }\n            }\n        }\n        if (prevDir === target.direction && isBezier) {\n            if ((target.direction === 'Bottom' && source.point.y > target.point.y) ||\n                (target.direction === 'Top' && source.point.y < target.point.y)) {\n                if (source.direction === 'Left') {\n                    e = getLeftLength(source, target, prevDir, 20);\n                }\n                else if (source.direction === 'Right') {\n                    e = getRightLength(source, target, 20, prevDir);\n                }\n            }\n            else if ((target.direction === 'Right' && source.point.x > target.point.x) ||\n                (target.direction === 'Left' && source.point.x < target.point.x)) {\n                if (source.direction === 'Top') {\n                    e = getTopLength(source, target, prevDir, 20);\n                }\n                else if (source.direction === 'Bottom') {\n                    e = getBottomLength(source, target, 20, prevDir);\n                }\n            }\n        }\n    }\n    switch (source.direction) {\n        case 'Left':\n            e = isBezier ? e : getLeftLength(source, target, prevDir, e);\n            segmentValue = addLineSegment(source.point, e, 180);\n            break;\n        case 'Right':\n            e = isBezier ? e : getRightLength(source, target, e, prevDir);\n            segmentValue = addLineSegment(source.point, e, 0);\n            break;\n        case 'Top':\n            e = isBezier ? e : getTopLength(source, target, prevDir, e);\n            segmentValue = addLineSegment(source.point, e, 270);\n            break;\n        case 'Bottom':\n            e = isBezier ? e : getBottomLength(source, target, e, prevDir);\n            segmentValue = addLineSegment(source.point, e, 90);\n    }\n    if (interPt !== undefined) {\n        interPt.push(segmentValue);\n    }\n    else {\n        interPt = [\n            source.point,\n            segmentValue\n        ];\n    }\n    if (source.direction === 'Top' || source.direction === 'Bottom') {\n        getOrtho3Seg(segmentValue, 'horizontal', source, target, interPt, isBezier);\n    }\n    else if (source.direction === 'Right' || source.direction === 'Left') {\n        getOrtho3Seg(segmentValue, 'vertical', source, target, interPt, isBezier);\n    }\n    return interPt;\n}\n/**\n * getOrtho3Seg method \\\n *\n * @returns {  void } getOrtho3Seg method .\\\n * @param {PointModel} sPt - provide the sPt  value.\n * @param {string} orientation - provide the orientation  value.\n * @param {End} src - provide the src  value.\n * @param {End} tar - provide the tar  value.\n * @param {PointModel[]} points - provide the points  value.\n * @param {boolean} isBezier - provide the isBezier  value.\n * @private\n */\nfunction getOrtho3Seg(sPt, orientation, src, tar, points, isBezier) {\n    var point1;\n    var point2;\n    var point3;\n    if (orientation === 'horizontal') {\n        src.margin = { left: 0, right: 10, top: 0, bottom: 10 };\n        tar.margin = { left: 0, right: 10, top: 0, bottom: 10 };\n    }\n    else if (orientation === 'vertical') {\n        src.margin = { left: 10, right: 0, top: 10, bottom: 0 };\n        tar.margin = { left: 10, right: 0, top: 10, bottom: 0 };\n    }\n    var extra = 20;\n    if (orientation === 'horizontal') {\n        switch (tar.direction) {\n            case 'Left':\n                if (src.corners.right + src.margin.right < tar.corners.left - tar.margin.left &&\n                    (tar.corners.left - src.margin.right - src.corners.right > extra || (src.corners.top - src.margin.top <= tar.point.y &&\n                        src.corners.bottom + src.margin.bottom >= tar.point.y))) {\n                    if (isBezier && (src.direction === 'Top' || src.direction === 'Bottom')) {\n                        var gap = Math.abs(tar.corners.left - src.corners.right) / 2;\n                        extra = src.corners.right - sPt.x + gap;\n                    }\n                    else {\n                        var gap = Math.min(Math.abs(tar.corners.left - src.corners.right) / 2, 20);\n                        extra = src.corners.right - sPt.x + gap;\n                    }\n                }\n                else {\n                    if ((src.direction === 'Top' && sPt.y > tar.point.y) || (src.direction === 'Bottom' && sPt.y < tar.point.y)) {\n                        extra = Math.min(tar.corners.left, sPt.x) - sPt.x - 20;\n                    }\n                    else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {\n                        extra = Math.min(tar.corners.left, src.corners.left) - sPt.x - 20;\n                    }\n                    else {\n                        extra = tar.corners.left - sPt.x - 20;\n                    }\n                }\n                break;\n            case 'Right':\n                if (src.corners.left - src.margin.left > tar.corners.right + tar.margin.right &&\n                    (src.corners.left - src.margin.right - tar.corners.right > extra || (src.corners.top - src.margin.top <= tar.point.y &&\n                        src.corners.bottom + src.margin.bottom >= tar.point.y))) {\n                    if (isBezier && (src.direction === 'Top' || src.direction === 'Bottom')) {\n                        var gap = Math.abs(src.corners.left - tar.corners.right) / 2;\n                        extra = src.corners.left - sPt.x - gap;\n                    }\n                    else {\n                        var gap = Math.min(Math.abs(src.corners.left - tar.corners.right) / 2, 20);\n                        extra = src.corners.left - sPt.x - gap;\n                    }\n                }\n                else {\n                    if ((src.direction === 'Top' && sPt.y > tar.point.y) || (src.direction === 'Bottom' && sPt.y < tar.point.y)) {\n                        extra = Math.max(tar.corners.right, sPt.x) - sPt.x + 20;\n                    }\n                    else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {\n                        extra = Math.max(tar.corners.right, src.corners.right) - sPt.x + 20;\n                    }\n                    else {\n                        extra = tar.corners.right - sPt.x + 20;\n                    }\n                }\n                break;\n        }\n        point1 = addLineSegment(sPt, extra, 0);\n        point2 = addLineSegment(point1, tar.point.y - sPt.y, 90);\n        point3 = tar.point;\n    }\n    else if (orientation === 'vertical') {\n        switch (tar.direction) {\n            case 'Top':\n                if (src.corners.bottom + src.margin.bottom < tar.corners.top - tar.margin.top &&\n                    (tar.corners.top - src.margin.top - src.corners.bottom > extra || (src.corners.left - src.margin.left <= tar.point.x &&\n                        src.corners.right + src.margin.right >= tar.point.x))) {\n                    if (isBezier && (src.direction === 'Right' || src.direction === 'Left')) {\n                        var gap = Math.abs(tar.corners.top - src.corners.bottom) / 2;\n                        extra = src.corners.bottom - sPt.y + gap;\n                    }\n                    else {\n                        var gap = Math.min(Math.abs(tar.corners.top - src.corners.bottom) / 2, 20);\n                        extra = src.corners.bottom - sPt.y + gap;\n                    }\n                }\n                else {\n                    if ((src.direction === 'Left' && sPt.x > tar.point.x) || (src.direction === 'Right' && sPt.x < tar.point.x)) {\n                        extra = Math.min(tar.corners.top, sPt.y) - sPt.y - 20;\n                    }\n                    else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {\n                        extra = Math.min(tar.corners.top, src.corners.top) - sPt.y - 20;\n                    }\n                    else {\n                        extra = tar.corners.top - sPt.y - 20;\n                    }\n                }\n                break;\n            case 'Bottom':\n                if (src.corners.top - src.margin.top > tar.corners.bottom + tar.margin.bottom &&\n                    (src.corners.top - src.margin.top - tar.corners.bottom > extra || (src.corners.left - src.margin.left <= tar.point.x &&\n                        src.corners.right + src.margin.right >= tar.point.x))) {\n                    if (isBezier && (src.direction === 'Right' || src.direction === 'Left')) {\n                        var gap = Math.abs(src.corners.top - tar.corners.bottom) / 2;\n                        extra = src.corners.top - sPt.y - gap;\n                    }\n                    else {\n                        var gap = Math.min(Math.abs(src.corners.top - tar.corners.bottom) / 2, 20);\n                        extra = src.corners.top - sPt.y - gap;\n                    }\n                }\n                else {\n                    if ((src.direction === 'Left' && sPt.x > tar.point.x) || (src.direction === 'Right' && sPt.x < tar.point.x)) {\n                        extra = Math.max(tar.corners.bottom, sPt.y) - sPt.y + 20;\n                    }\n                    else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {\n                        extra = Math.max(tar.corners.bottom, src.corners.bottom) - sPt.y + 20;\n                    }\n                    else {\n                        extra = tar.corners.bottom - sPt.y + 20;\n                    }\n                }\n                break;\n        }\n        point1 = addLineSegment(sPt, extra, 90);\n        point2 = addLineSegment(point1, tar.point.x - sPt.x, 0);\n        point3 = tar.point;\n    }\n    points.push(point1);\n    points.push(point2);\n    points.push(point3);\n}\n/**\n * getTopLength method \\\n *\n * @returns {  number } getTopLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the sPt  value.\n * @param {string} preDir - provide the orientation  value.\n * @param {number} length - provide the src  value.\n * @private\n */\nfunction getTopLength(source, target, preDir, length) {\n    if (source.corners.top - source.margin.top > target.corners.top + target.margin.top &&\n        source.corners.top - source.margin.top <= target.corners.bottom + target.margin.bottom) {\n        if (target.direction === 'Right' && source.point.x < target.point.x) {\n            length += source.corners.top - target.corners.top;\n        }\n        else if (target.direction === 'Left' && source.point.x > target.point.x) {\n            length += source.corners.top - target.corners.top;\n        }\n        length += source.point.y - source.corners.top;\n    }\n    else {\n        if ((preDir !== undefined && preDir !== 'Left') && target.direction === 'Right' && source.point.x < target.point.x) {\n            length += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else if ((preDir !== undefined && preDir !== 'Right') && target.direction === 'Left'\n            && target.point.x < source.point.x) {\n            length += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else {\n            length += source.point.y - source.corners.top;\n        }\n    }\n    return length;\n}\n/**\n * getLeftLength method \\\n *\n * @returns {  number } getLeftLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the sPt  value.\n * @param {string} prevDir - provide the orientation  value.\n * @param {number} segLength - provide the src  value.\n * @private\n */\nfunction getLeftLength(source, target, prevDir, segLength) {\n    if (source.corners.left - source.margin.left > target.corners.left - target.margin.left &&\n        source.corners.left - source.margin.left <= target.corners.right + target.margin.right) {\n        if (target.direction === 'Bottom' && source.point.y < target.point.y) {\n            segLength += source.corners.left - target.corners.left;\n        }\n        else if (target.direction === 'Top' && source.point.y > target.point.y) {\n            segLength += source.corners.left - target.corners.left;\n        }\n        segLength += source.point.x - source.corners.left;\n    }\n    else {\n        if ((prevDir !== undefined && prevDir !== 'Top') && target.direction === 'Bottom' && source.point.y < target.point.y) {\n            segLength += Math.abs(source.point.x - target.corners.right);\n        }\n        else if ((prevDir !== undefined && prevDir !== 'Bottom') &&\n            target.direction === 'Top' && target.point.y < source.point.y) {\n            segLength += Math.abs(source.point.x - target.corners.right);\n        }\n        else {\n            segLength += source.point.x - source.corners.left;\n        }\n    }\n    return segLength;\n}\n/**\n * getRightLength method \\\n *\n * @returns {  number } getRightLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the orientation  value.\n * @param {number} length - provide the src  value.\n * @param {string} prevDir - provide the src  value.\n * @private\n */\nfunction getRightLength(source, target, length, prevDir) {\n    if (source.corners.right + source.margin.right < target.corners.right + target.margin.right &&\n        source.corners.right + source.margin.right >= target.corners.left - target.margin.left) {\n        if (target.direction === 'Bottom' && source.point.y < target.point.y) {\n            length += target.corners.right - source.corners.right;\n        }\n        else if (target.direction === 'Top' && source.point.y > target.point.y) {\n            length += target.corners.right - source.corners.right;\n        }\n        length += source.corners.right - source.point.x;\n    }\n    else {\n        if ((prevDir !== undefined && prevDir !== 'Top') && target.direction === 'Bottom' && source.point.y < target.point.y) {\n            length += Math.abs(source.point.x - target.corners.right);\n        }\n        else if ((prevDir !== undefined && prevDir !== 'Bottom') && target.direction === 'Top' && target.point.y < source.point.y) {\n            length += Math.abs(source.point.x - target.corners.right);\n        }\n        else {\n            length += source.corners.right - source.point.x;\n        }\n    }\n    return length;\n}\n/**\n * getBottomLength method \\\n *\n * @returns {  number } getBottomLength method .\\\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {number} segLength - provide the segLength  value.\n * @param {string} prevDir - provide the src  value.\n * @private\n */\nfunction getBottomLength(source, target, segLength, prevDir) {\n    if (source.corners.bottom + source.margin.bottom < target.corners.bottom + target.margin.bottom &&\n        source.corners.bottom + source.margin.bottom >= target.corners.top - target.margin.top) {\n        if (target.direction === 'Right' && source.point.x < target.point.x) {\n            segLength += target.corners.bottom - source.corners.bottom;\n        }\n        else if (target.direction === 'Left' && source.point.x > target.point.x) {\n            segLength += target.corners.bottom - source.corners.bottom;\n        }\n        segLength += source.corners.bottom - source.point.y;\n    }\n    else {\n        if ((prevDir !== undefined && prevDir !== 'Left') &&\n            target.direction === 'Right' && source.point.x < target.point.x) {\n            segLength += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else if ((prevDir !== undefined && prevDir !== 'Right') &&\n            target.direction === 'Left' && target.point.x < source.point.x) {\n            segLength += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else {\n            segLength += source.corners.bottom - source.point.y;\n        }\n    }\n    return segLength;\n}\nfunction convertPointToBezierSegment(element, segCount, pts) {\n    if (element.type === 'Bezier') {\n        if (element.segments.length === 0) {\n            var start = pts[0];\n            var end = pts[pts.length - 1];\n            if (segCount === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.One) {\n                var distance = Math.min(20, _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(start, end) * 0.5);\n                var vector1 = { angle: findAngle(start, end), distance: distance };\n                var vector2 = { angle: findAngle(end, start), distance: distance };\n                var dir = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(start, end);\n                var ori = dir === 'Left' || dir === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, orientation: ori }, true);\n                (element.segments).push(segment);\n            }\n            else if (segCount === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Two) {\n                var mid = pts[1];\n                var vector1 = { angle: findAngle(start, mid), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(start, mid) * 0.5 };\n                var vector2 = { angle: findAngle(end, mid), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(end, mid) * 0.5 };\n                var dir = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(start, mid);\n                var ori = dir === 'Left' || dir === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, orientation: ori }, true);\n                (element.segments).push(segment);\n            }\n            else if (segCount === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Three) {\n                var mid1 = pts[1];\n                var mid2 = pts[pts.length - 2];\n                var mid = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };\n                var vector1 = { angle: findAngle(start, mid1), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(start, mid1) * 0.5 };\n                var vector2 = { angle: findAngle(mid, mid1), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(mid, mid1) * 0.5 };\n                var dir1 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(start, mid1);\n                var ori1 = dir1 === 'Left' || dir1 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment1 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, point: mid, orientation: ori1 }, true);\n                (element.segments).push(segment1);\n                var vector3 = { angle: findAngle(mid, mid2), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(mid, mid2) * 0.5 };\n                var vector4 = { angle: findAngle(end, mid2), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(end, mid2) * 0.5 };\n                var dir2 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(mid, mid2);\n                var ori2 = dir2 === 'Left' || dir2 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment2 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector3, vector2: vector4, orientation: ori2 }, true);\n                (element.segments).push(segment2);\n            }\n            else if (segCount === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Four) {\n                var mid1 = pts[1];\n                var mid2 = pts[2];\n                var mid3 = pts[3];\n                var center1 = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };\n                var center2 = { x: (mid2.x + mid3.x) * 0.5, y: (mid2.y + mid3.y) * 0.5 };\n                var vector1 = { angle: findAngle(start, mid1), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(start, mid1) * 0.5 };\n                var vector2 = { angle: findAngle(center1, mid1), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center1, mid1) * 0.5 };\n                var dir1 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(start, mid1);\n                var ori1 = dir1 === 'Left' || dir1 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment1 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, point: center1, orientation: ori1 }, true);\n                (element.segments).push(segment1);\n                var vector3 = { angle: findAngle(center1, mid2), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center1, mid2) * 0.5 };\n                var vector4 = { angle: findAngle(center2, mid2), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center2, mid2) * 0.5 };\n                var dir2 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(center1, mid2);\n                var ori2 = dir2 === 'Left' || dir2 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment2 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector3, vector2: vector4, point: center2, orientation: ori2 }, true);\n                (element.segments).push(segment2);\n                var vector5 = { angle: findAngle(center2, mid3), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center2, mid3) * 0.5 };\n                var vector6 = { angle: findAngle(end, mid3), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(end, mid3) * 0.5 };\n                var dir3 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(center2, mid3);\n                var ori3 = dir3 === 'Left' || dir3 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment3 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector5, vector2: vector6, orientation: ori3 }, true);\n                (element.segments).push(segment3);\n            }\n            else if (segCount === _enum_enum__WEBPACK_IMPORTED_MODULE_3__.NoOfSegments.Five) {\n                var mid1 = pts[1];\n                var mid2 = pts[2];\n                var mid3 = pts[3];\n                var mid4 = pts[4];\n                var center1 = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };\n                var center2 = { x: (mid2.x + mid3.x) * 0.5, y: (mid2.y + mid3.y) * 0.5 };\n                var center3 = { x: (mid3.x + mid4.x) * 0.5, y: (mid3.y + mid4.y) * 0.5 };\n                var vector1 = { angle: findAngle(start, mid1), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(start, mid1) * 0.5 };\n                var vector2 = { angle: findAngle(center1, mid1), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center1, mid1) * 0.5 };\n                var dir1 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(start, mid1);\n                var ori1 = dir1 === 'Left' || dir1 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment1 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector1, vector2: vector2, point: center1, orientation: ori1 }, true);\n                (element.segments).push(segment1);\n                var vector3 = { angle: findAngle(center1, mid2), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center1, mid2) * 0.5 };\n                var vector4 = { angle: findAngle(center2, mid2), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center2, mid2) * 0.5 };\n                var dir2 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(center1, mid2);\n                var ori2 = dir2 === 'Left' || dir2 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment2 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector3, vector2: vector4, point: center2, orientation: ori2 }, true);\n                (element.segments).push(segment2);\n                var vector5 = { angle: findAngle(center2, mid3), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center2, mid3) * 0.5 };\n                var vector6 = { angle: findAngle(center3, mid3), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center3, mid3) * 0.5 };\n                var dir3 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(center2, mid3);\n                var ori3 = dir3 === 'Left' || dir3 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment3 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector5, vector2: vector6, point: center3, orientation: ori3 }, true);\n                (element.segments).push(segment3);\n                var vector7 = { angle: findAngle(center3, mid4), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(center3, mid4) * 0.5 };\n                var vector8 = { angle: findAngle(end, mid4), distance: _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(end, mid4) * 0.5 };\n                var dir4 = _primitives_point__WEBPACK_IMPORTED_MODULE_0__.Point.direction(center3, mid4);\n                var ori4 = dir4 === 'Left' || dir4 === 'Right' ? 'Horizontal' : 'Vertical';\n                var segment4 = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier', isInternalSegment: true, vector1: vector7, vector2: vector8, orientation: ori4 }, true);\n                (element.segments).push(segment4);\n            }\n            else {\n                var segment = new _objects_connector__WEBPACK_IMPORTED_MODULE_4__.BezierSegment(element, 'segments', { type: 'Bezier' }, true);\n                (element.segments).push(segment);\n            }\n        }\n        else {\n            for (var i = 0; i < element.segments.length; i++) {\n                if (element.bezierSettings.allowSegmentsReset) {\n                    element.segments[parseInt(i.toString(), 10)].isInternalSegment = true;\n                }\n            }\n        }\n    }\n}\n/**\n * getSwapping method \\\n *\n * @returns {  boolean } getSwapping method .\\\n * @param {string} srcDir - provide the source  value.\n * @param {string} tarDir - provide the target  value.\n * @private\n */\nfunction getSwapping(srcDir, tarDir) {\n    var swap = false;\n    switch (srcDir) {\n        case 'Left':\n            switch (tarDir) {\n                case 'Right':\n                case 'Bottom':\n                    swap = true;\n                    break;\n            }\n            break;\n        case 'Top':\n            switch (tarDir) {\n                case 'Left':\n                case 'Right':\n                case 'Bottom':\n                    swap = true;\n                    break;\n            }\n            break;\n        case 'Bottom':\n            switch (tarDir) {\n                case 'Right':\n                    swap = true;\n                    break;\n            }\n            break;\n    }\n    return swap;\n}\n/**\n * swapPoints method \\\n *\n * @returns {  void } swapPoints method .\\\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction swapPoints(source, target) {\n    var direction = source.direction;\n    source.direction = target.direction;\n    target.direction = direction;\n    var point = source.point;\n    source.point = target.point;\n    target.point = point;\n    var corner = source.corners;\n    source.corners = target.corners;\n    target.corners = corner;\n}\n/**\n * getPortDirection method \\\n *\n * @returns {  boolean } getPortDirection method .\\\n * @param {PointModel} point - provide the point  value.\n * @param {Corners} corner - provide the corner  value.\n * @param {Rect} bounds - provide the bounds  value.\n * @param {boolean} closeEdge - provide the closeEdge  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getPortDirection(point, corner, bounds, closeEdge) {\n    var direction;\n    var boundsValue = corner === undefined ? bounds : corner;\n    var one = boundsValue.topLeft;\n    var two = boundsValue.topRight;\n    var three = boundsValue.bottomRight;\n    var four = boundsValue.bottomLeft;\n    var center = boundsValue.center;\n    var angle = findAngle(center, point);\n    var fourty5 = findAngle(center, three);\n    var one35 = findAngle(center, four);\n    var two25 = findAngle(center, one);\n    var three15 = findAngle(center, two);\n    if (angle > two25 && angle < three15) {\n        direction = 'Top';\n        // if (bounds.width < bounds.height && closeEdge) {\n        //     let height: number = (bounds.height - bounds.width) / 2;\n        //     let width: number = bounds.width;\n        //     if (Math.abs(point.x - one.x) < Math.abs(point.x - two.x)) {\n        //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Left');\n        //     } else {\n        //         direction = checkCloseEdge(direction, new Rect(two.x - bounds.width, two.y, width, height), point, 'Right');\n        //     }\n        // }\n    }\n    else if (angle >= fourty5 && angle < one35) {\n        direction = 'Bottom';\n        // if (bounds.width < bounds.height && closeEdge) {\n        //     let height: number = (bounds.height - bounds.width) / 2;\n        //     let width: number = bounds.width;\n        //     if (Math.abs(point.x - four.x) < Math.abs(point.x - three.x)) {\n        //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Left');\n        //     } else {\n        //         let value: Rect = new Rect(three.x - bounds.width, three.y - bounds.height / 4, bounds.width, bounds.height / 4);\n        //         direction = checkCloseEdge(direction, value, point, 'Right');\n        //     }\n        // }\n    }\n    else if (angle >= one35 && angle <= two25) {\n        direction = 'Left';\n        // if (bounds.width > bounds.height && closeEdge) {\n        //     let width: number = (bounds.width - bounds.height) / 2;\n        //     let height: number = bounds.height;\n        //     if (Math.abs(point.y - one.y) < Math.abs(point.y - four.y)) {\n        //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Top');\n        //     } else {\n        //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Bottom');\n        //     }\n        // }\n    }\n    else if (angle >= three15 || angle < fourty5) {\n        direction = 'Right';\n        // if (bounds.width > bounds.height && closeEdge) {\n        //     let width: number = (bounds.width - bounds.height) / 2;\n        //     let height: number = bounds.height;\n        //     if (Math.abs(point.y - two.y) < Math.abs(point.y - three.y)) {\n        //         direction = checkCloseEdge(direction, new Rect(two.x - width, two.y, width, height), point, 'Top');\n        //     } else {\n        //         direction = checkCloseEdge(direction,\n        //new Rect(three.x - width, three.y - height, width, height), point, 'Bottom');\n        //     }\n        // }\n    }\n    else {\n        direction = 'Right';\n    }\n    return direction;\n}\n// function checkCloseEdge(direction: string, threshold: Rect, port: PointModel, nearest: string): string {\n// if (threshold) {\n//     switch (direction) {\n//         case 'Bottom':\n//         case 'Top':\n//             let left: number = Math.abs(threshold.left - port.x);\n//             let right: number = Math.abs(threshold.right - port.x);\n//             let ver: number = direction === 'Top' ? Math.abs(threshold.top - port.y) : Math.abs(threshold.bottom - port.y);\n//             if (left < right) {\n//                 if (left < ver) {\n//                     return 'Left';\n//                 }\n//             } else {\n//                 if (right < ver) {\n//                     return 'Right';\n//                 }\n//             }\n//             break;\n//         case 'Left':\n//         case 'Right':\n//             let top: number = Math.abs(threshold.top - port.y);\n//             let bottom: number = Math.abs(threshold.bottom - port.y);\n//             let hor: number = direction === 'Left' ? Math.abs(threshold.left - port.x) : Math.abs(threshold.right - port.x);\n//             if (top < bottom) {\n//                 if (top < hor) {\n//                     return 'Top';\n//                 }\n//             } else {\n//                 if (bottom < hor) {\n//                     return 'Bottom';\n//                 }\n//             }\n//             break;\n//     }\n// }\n//Meant for dock port\n//    return direction;\n//  }\n/**\n * getOuterBounds method \\\n *\n * @returns {  Rect } getOuterBounds method .\\\n * @param {Connector} obj - provide the point  value.\n * @private\n */\nfunction getOuterBounds(obj) {\n    //let outerBounds: Rect;\n    var outerBounds = obj.wrapper.children[0].bounds;\n    if (obj.sourceDecorator.shape !== 'None') {\n        outerBounds.uniteRect(obj.wrapper.children[1].bounds);\n    }\n    if (obj.targetDecorator.shape !== 'None') {\n        outerBounds.uniteRect(obj.wrapper.children[2].bounds);\n    }\n    return outerBounds;\n}\n/**\n * getOppositeDirection method \\\n *\n * @returns {  string } getOppositeDirection method .\\\n * @param {string} direction - provide the direction  value.\n * @private\n */\nfunction getOppositeDirection(direction) {\n    switch (direction) {\n        case 'Top':\n            return 'Bottom';\n        case 'Bottom':\n            return 'Top';\n        case 'Left':\n            return 'Right';\n        case 'Right':\n            return 'Left';\n    }\n    return 'auto';\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js?");

/***/ })

}]);