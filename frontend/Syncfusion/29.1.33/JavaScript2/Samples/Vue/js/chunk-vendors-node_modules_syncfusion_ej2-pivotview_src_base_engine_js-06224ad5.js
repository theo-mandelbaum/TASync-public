"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pivotview_src_base_engine_js-06224ad5"],{

/***/ "./node_modules/@syncfusion/ej2-pivotview/src/base/engine.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pivotview/src/base/engine.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PivotEngine: () => (/* binding */ PivotEngine)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/@syncfusion/ej2-pivotview/src/base/util.js\");\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n\n/**\n * PivotEngine is used to manipulate the relational or Multi-Dimensional data as pivoting values.\n */\n/** @hidden */\nvar PivotEngine = /** @class */ (function () {\n    function PivotEngine() {\n        /** @hidden */\n        this.aggregatedValueMatrix = [];\n        /** @hidden */\n        this.valueContent = [];\n        /** @hidden */\n        this.formatFields = {};\n        /** @hidden */\n        this.groupingFieldsInfo = {};\n        /** @hidden */\n        this.dateFormatFunction = {};\n        /** @hidden */\n        this.calculatedFields = {};\n        /** @hidden */\n        this.calculatedFormulas = {};\n        /** @hidden */\n        this.valueAxis = 0;\n        /** @hidden */\n        this.saveDataHeaders = {};\n        /** @hidden */\n        this.columnCount = 0;\n        /** @hidden */\n        this.rowCount = 0;\n        /** @hidden */\n        this.columnPageCount = 0;\n        /** @hidden */\n        this.rowPageCount = 0;\n        /** @hidden */\n        this.colFirstLvl = 0;\n        /** @hidden */\n        this.rowFirstLvl = 0;\n        /** @hidden */\n        this.rowStartPos = 0;\n        /** @hidden */\n        this.colStartPos = 0;\n        /** @hidden */\n        this.enableValueSorting = false;\n        /** @hidden */\n        this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };\n        /** @hidden */\n        this.rMembers = [];\n        /** @hidden */\n        this.cMembers = [];\n        /** @hidden */\n        this.groupingFields = {};\n        /** @hidden */\n        this.isLastHeaderHasMeasures = true;\n        /** @hidden */\n        this.measureIndex = -1;\n        /** @hidden */\n        this.isPagingOrVirtualizationEnabled = false;\n        /** @hidden */\n        this.rowMaxLevel = 0;\n        this.valueMatrix = [];\n        this.memberCnt = -1;\n        this.pageInLimit = false;\n        this.endPos = 0;\n        this.removeCount = 0;\n        this.colHdrBufferCalculated = false;\n        this.colValuesLength = 1;\n        this.rowValuesLength = 1;\n        this.slicedHeaders = [];\n        this.fieldFilterMem = {};\n        this.filterPosObj = {};\n        this.selectedHeaders = { selectedHeader: [], values: [] };\n        this.rowGrandTotal = null;\n        this.columnGrandTotal = null;\n        this.removeRowGrandTotal = false;\n        this.removeColumnGrandTotal = false;\n        this.isValueHasAdvancedAggregate = false;\n        this.rawIndexObject = {};\n        this.reformAxisCount = 0;\n        this.isEditing = false;\n        /** @hidden */\n        this.valueAxisFields = {};\n        /** @hidden */\n        this.data = [];\n        /** @hidden */\n        this.actualData = [];\n        /** @hidden */\n        this.groupRawIndex = {};\n        /** @hidden */\n        this.fieldKeys = {};\n        this.allowDataCompression = false;\n        this.dataSourceSettings = {};\n        this.frameHeaderObjectsCollection = false;\n        this.headerObjectsCollection = {};\n        this.columnKeys = {};\n        this.fieldDrillCollection = {};\n        this.formatRegex = /^(?:[ncpae])(?:([0-9]|1[0-9]|20))?$/i;\n        this.measureNames = {};\n        this.enablePaging = false;\n        this.enableVirtualization = false;\n        this.enableHtmlSanitizer = false;\n        this.enableOptimizedRendering = false;\n        this.groupedDataType = {};\n        this.emptyRowsLength = 0;\n        this.tabularPivotValues = [];\n        /* private makeMirrorObject(elements: number[], obj: NumberIndex): void {\n             for (let lp: number = 0, end: number = elements.length; lp < end; lp++) {\n                 obj[elements[lp]] = elements[lp];\n             }\n         } */\n    }\n    /**\n     * It is used to clear properties.\n     *\n     * @param {boolean} isExport - It indicates whether it is triggered after the export or not.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.clearProperties = function (isExport) {\n        if (!this.isPagingOrVirtualizationEnabled && !isExport) {\n            this.columnKeys = {};\n            this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };\n        }\n        if (this.enableValueSorting) {\n            this.valueContent = [];\n        }\n        this.saveDataHeaders = this.allowValueFilter ? this.saveDataHeaders : {};\n        this.rMembers = [];\n        this.cMembers = [];\n        this.slicedHeaders = [];\n        this.fieldFilterMem = {};\n        this.filterPosObj = {};\n        this.selectedHeaders = { selectedHeader: [], values: [] };\n        this.rowGrandTotal = null;\n        this.columnGrandTotal = null;\n        this.rawIndexObject = {};\n        if (this.dataSourceSettings.valueIndex > -1) {\n            this.valueAxisFields = {};\n        }\n        this.headerObjectsCollection = {};\n        this.fieldDrillCollection = {};\n    };\n    /**\n     * It is used to render the pivot engine.\n     *\n     * @param {IDataOptions} dataSource -  It contains the dataSourceSettings.\n     * @param {ICustomProperties} customProperties -  It contains the custom Properties.\n     * @param {Function} fn - It contains aggreagateCellnInfo method.\n     * @param {Function} onHeadersSort -  It contains onHeaderSort method.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.renderEngine = function (dataSource, customProperties, fn, onHeadersSort) {\n        this.getValueCellInfo = fn;\n        this.getHeaderSortInfo = onHeadersSort;\n        this.customProperties = customProperties;\n        if (this.fieldList) {\n            for (var i = 0, j = dataSource.formatSettings; i < j.length; i++) {\n                if (!this.formatFields[j[i].name] && this.fieldList[j[i].name]) {\n                    this.fieldList[j[i].name].members = {};\n                    this.fieldList[j[i].name].formattedMembers = {};\n                    this.fieldList[j[i].name].dateMember = [];\n                }\n            }\n        }\n        this.formatFields = {};\n        this.dateFormatFunction = {};\n        this.calculatedFields = {};\n        this.calculatedFormulas = {};\n        this.valueAxis = 0;\n        this.saveDataHeaders = {};\n        this.columnCount = 0;\n        this.rowCount = 0;\n        this.columnPageCount = 0;\n        this.rowPageCount = 0;\n        this.colFirstLvl = 0;\n        this.rowFirstLvl = 0;\n        this.rowStartPos = 0;\n        this.colStartPos = 0;\n        this.dataSourceSettings.excludeFields = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.excludeFields) ? [] : dataSource.excludeFields;\n        this.enableValueSorting = false;\n        this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };\n        this.aggregatedValueMatrix = [];\n        this.rMembers = [];\n        this.cMembers = [];\n        this.memberCnt = -1;\n        this.pageInLimit = false;\n        this.endPos = 0;\n        this.removeCount = 0;\n        this.colHdrBufferCalculated = false;\n        this.colValuesLength = 1;\n        this.rowValuesLength = 1;\n        this.slicedHeaders = [];\n        this.fieldFilterMem = {};\n        this.filterPosObj = {};\n        this.selectedHeaders = { selectedHeader: [], values: [] };\n        this.rowGrandTotal = null;\n        this.columnGrandTotal = null;\n        this.removeRowGrandTotal = false;\n        this.removeColumnGrandTotal = false;\n        this.isValueHasAdvancedAggregate = false;\n        this.rawIndexObject = {};\n        this.isLastHeaderHasMeasures = true;\n        this.isEditing = false;\n        var fields;\n        this.globalize = (customProperties && customProperties.globalize) ? customProperties.globalize : new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Internationalization();\n        this.currencyCode = (customProperties && customProperties.currenyCode) ? customProperties.currenyCode : undefined;\n        this.localeObj = customProperties ? customProperties.localeObj : undefined;\n        this.fieldsType = customProperties ? customProperties.fieldsType : {};\n        this.clonedReport = customProperties ? (customProperties.clonedReport &&\n            customProperties.clonedReport.properties ?\n            customProperties.clonedReport.properties :\n            customProperties.clonedReport) : {};\n        this.enablePaging = customProperties.enablePaging;\n        this.enableVirtualization = customProperties.enableVirtualization;\n        this.enableOptimizedRendering = customProperties.enableOptimizedRendering;\n        this.enableHtmlSanitizer = customProperties.enableHtmlSanitizer;\n        this.isPagingOrVirtualizationEnabled = this.enablePaging || this.enableVirtualization;\n        this.enableSort = dataSource.enableSorting;\n        this.dataSourceSettings.alwaysShowValueHeader = dataSource.alwaysShowValueHeader;\n        this.dataSourceSettings.showHeaderWhenEmpty = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showHeaderWhenEmpty) ? true :\n            dataSource.showHeaderWhenEmpty;\n        this.dataSourceSettings.showSubTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showSubTotals) ? true : dataSource.showSubTotals;\n        this.dataSourceSettings.showRowSubTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showRowSubTotals) ? true : dataSource.showRowSubTotals;\n        this.dataSourceSettings.showColumnSubTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showColumnSubTotals) ? true :\n            dataSource.showColumnSubTotals;\n        this.dataSourceSettings.showGrandTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showGrandTotals) ? true : dataSource.showGrandTotals;\n        this.dataSourceSettings.grandTotalsPosition = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.grandTotalsPosition) ? 'Bottom' :\n            dataSource.grandTotalsPosition;\n        this.dataSourceSettings.showRowGrandTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showRowGrandTotals) ? true :\n            dataSource.showRowGrandTotals;\n        this.dataSourceSettings.showColumnGrandTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showColumnGrandTotals) ? true :\n            dataSource.showColumnGrandTotals;\n        this.showSubTotalsAtTop = (this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals &&\n            dataSource.subTotalsPosition === 'Top') && !customProperties.isTabularLayout;\n        this.showSubTotalsAtBottom = (this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showRowSubTotals &&\n            dataSource.subTotalsPosition === 'Bottom') || customProperties.isTabularLayout;\n        this.allowValueFilter = dataSource.allowValueFilter;\n        this.isValueFilterEnabled = false;\n        this.enableValueSorting = customProperties ? customProperties.enableValueSorting : false;\n        this.isDrillThrough = customProperties ? (customProperties.isDrillThrough ? customProperties.isDrillThrough : false) : false;\n        this.valueContent = [];\n        this.dataSourceSettings = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getClonedDataSourceSettings(dataSource);\n        if (!(dataSource.dataSource instanceof _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__.DataManager)) {\n            if (dataSource.type === 'CSV') {\n                this.data = dataSource.dataSource.map(function (innerArray) { return innerArray.slice(); });\n                if (this.fieldList) {\n                    this.data.shift();\n                }\n            }\n            else {\n                this.data = dataSource.dataSource;\n            }\n        }\n        if (this.data && this.data[0]) {\n            if (!this.fieldList) {\n                if (dataSource.type === 'CSV') {\n                    this.fields = this.data.shift();\n                }\n                else {\n                    this.fields = Object.keys(this.data[0]);\n                }\n                this.fieldKeys = {};\n                for (var i = 0; i < this.fields.length; i++) {\n                    this.fieldKeys[this.fields[i]] = dataSource.type === 'CSV' ? i : this.fields[i];\n                }\n            }\n            if (customProperties && customProperties.pageSettings && customProperties.allowDataCompression) {\n                this.actualData = this.data;\n                this.data = this.getGroupedRawData(dataSource);\n            }\n            this.dataSourceSettings.rows = dataSource.rows ? dataSource.rows : [];\n            this.dataSourceSettings.columns = dataSource.columns ? dataSource.columns : [];\n            this.dataSourceSettings.filters = dataSource.filters ? dataSource.filters : [];\n            this.dataSourceSettings.values = dataSource.values ? dataSource.values : [];\n            this.dataSourceSettings.formatSettings = dataSource.formatSettings ? dataSource.formatSettings : [];\n            this.dataSourceSettings.groupSettings = dataSource.groupSettings ? dataSource.groupSettings : [];\n            this.dataSourceSettings.calculatedFieldSettings = dataSource.calculatedFieldSettings ? dataSource.calculatedFieldSettings : [];\n            this.enableSort = dataSource.enableSorting === undefined ? true : dataSource.enableSorting;\n            this.dataSourceSettings.fieldMapping = dataSource.fieldMapping ? dataSource.fieldMapping : [];\n            this.valueAxisFields = {};\n            for (var _i = 0, _a = this.dataSourceSettings.values; _i < _a.length; _i++) {\n                var value = _a[_i];\n                this.valueAxisFields[value.name] = value;\n            }\n            fields = this.getGroupData(this.data);\n            this.validateFilters(dataSource);\n            this.isExpandAll = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? true : dataSource.expandAll;\n            this.drilledMembers =\n                dataSource.drilledMembers ? (this.isValueFiltersAvail && dataSource.allowValueFilter) ? [] : dataSource.drilledMembers : [];\n            this.isMultiMeasures = this.dataSourceSettings.values.length > 1 ? true : false;\n            this.valueAxis = dataSource.valueAxis === 'row' ? 1 : 0;\n            this.measureIndex = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.valueIndex) ? dataSource.valueIndex : -1;\n            this.emptyCellTextContent = dataSource.emptyCellsTextContent ? dataSource.emptyCellsTextContent : '';\n            this.rowValuesLength = this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1;\n            this.colValuesLength = this.valueAxis === 0 ? this.dataSourceSettings.values.length : 1;\n            this.valueSortSettings = dataSource.valueSortSettings ||\n                { sortOrder: 'None', headerDelimiter: '.', headerText: '', columnIndex: undefined };\n            this.valueSortData = [];\n            this.pageSettings = customProperties ? (customProperties.pageSettings ? customProperties.pageSettings : this.pageSettings)\n                : undefined;\n            this.allowDataCompression = customProperties && customProperties.allowDataCompression;\n            this.savedFieldList = customProperties ? customProperties.savedFieldList : undefined;\n            this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);\n            this.removeIrrelevantFields(Object.keys(this.fieldList));\n            this.fillFieldMembers();\n            this.updateSortSettings(dataSource.sortSettings, this.enableSort);\n            this.filterMembers = [];\n            var columnLength = this.dataSourceSettings.columns.length - 1;\n            this.columnKeys = {};\n            while (columnLength > -1) {\n                this.columnKeys[this.dataSourceSettings.columns[columnLength].name] = this.dataSourceSettings\n                    .columns[columnLength];\n                columnLength--;\n            }\n            this.updateFilterMembers(dataSource);\n            this.generateGridData(dataSource);\n        }\n    };\n    PivotEngine.prototype.removeIrrelevantFields = function (fields) {\n        var report = {};\n        report[0] = this.dataSourceSettings.rows;\n        report[1] = this.dataSourceSettings.columns;\n        report[2] = this.dataSourceSettings.values;\n        report[3] = this.dataSourceSettings.filters;\n        var pos = 0;\n        while (pos < 4) {\n            if (report[pos]) {\n                for (var cnt = 0; cnt < report[pos].length; cnt++) {\n                    var fieldName = report[pos][cnt].name;\n                    if ((this.dataSourceSettings.excludeFields.indexOf(fieldName) > -1) || (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(fields)\n                        && fields.indexOf(fieldName) === -1)) {\n                        report[pos].splice(cnt, 1);\n                        cnt--;\n                    }\n                    else if (pos === 2) {\n                        this.measureNames[fieldName] =\n                            report[pos][cnt].caption ? report[pos][cnt].caption : fieldName;\n                        this.measureNames[report[pos][cnt].caption ?\n                            report[pos][cnt].caption : fieldName] = fieldName;\n                    }\n                }\n            }\n            pos++;\n        }\n        this.isMultiMeasures = this.dataSourceSettings.values.length > 1 ? true : false;\n        this.measureIndex = this.measureIndex === -1 ? (this.valueAxis ? report[0].length : report[1].length) : this.measureIndex;\n    };\n    PivotEngine.prototype.updateDataSourceSettings = function (dataSource, requireDatasourceUpdate) {\n        if (requireDatasourceUpdate) {\n            this.emptyCellTextContent = dataSource.emptyCellsTextContent ? dataSource.emptyCellsTextContent : '';\n            this.valueAxis = dataSource.valueAxis === 'row' ? 1 : 0;\n            this.rowValuesLength = this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1;\n            this.colValuesLength = this.valueAxis === 0 ? this.dataSourceSettings.values.length : 1;\n            this.measureIndex = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.valueIndex) ? dataSource.valueIndex : -1;\n            this.enableSort = dataSource.enableSorting;\n            this.dataSourceSettings.alwaysShowValueHeader = dataSource.alwaysShowValueHeader;\n            this.dataSourceSettings.showHeaderWhenEmpty = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showHeaderWhenEmpty) ? true :\n                dataSource.showHeaderWhenEmpty;\n            this.dataSourceSettings.showSubTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showSubTotals) ? true : dataSource.showSubTotals;\n            this.dataSourceSettings.showRowSubTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showRowSubTotals) ? true : dataSource.showRowSubTotals;\n            this.dataSourceSettings.showColumnSubTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showColumnSubTotals) ? true :\n                dataSource.showColumnSubTotals;\n            this.dataSourceSettings.showGrandTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showGrandTotals) ? true : dataSource.showGrandTotals;\n            this.dataSourceSettings.grandTotalsPosition = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.grandTotalsPosition) ? 'Bottom' :\n                dataSource.grandTotalsPosition;\n            this.dataSourceSettings.showRowGrandTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showRowGrandTotals) ? true :\n                dataSource.showRowGrandTotals;\n            this.dataSourceSettings.showColumnGrandTotals = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(dataSource.showColumnGrandTotals) ? true :\n                dataSource.showColumnGrandTotals;\n            this.showSubTotalsAtTop = this.dataSourceSettings.showSubTotals && dataSource.subTotalsPosition === 'Top' &&\n                dataSource.showColumnSubTotals;\n            this.showSubTotalsAtBottom = this.customProperties.isTabularLayout ? true : this.dataSourceSettings.showSubTotals && dataSource.subTotalsPosition === 'Bottom' && dataSource.showRowSubTotals;\n            this.allowValueFilter = dataSource.allowValueFilter;\n            this.dataSourceSettings.formatSettings = dataSource.formatSettings ? dataSource.formatSettings : [];\n            this.dataSourceSettings.groupSettings = dataSource.groupSettings ? dataSource.groupSettings : [];\n            this.dataSourceSettings.calculatedFieldSettings = dataSource.calculatedFieldSettings ? dataSource.calculatedFieldSettings : [];\n            this.enableSort = dataSource.enableSorting === undefined ? true : dataSource.enableSorting;\n            this.dataSourceSettings.fieldMapping = dataSource.fieldMapping ? dataSource.fieldMapping : [];\n            this.dataSourceSettings.values = dataSource.values ? dataSource.values : [];\n            this.dataSourceSettings.rows = dataSource.rows ? dataSource.rows : [];\n            this.dataSourceSettings.columns = dataSource.columns ? dataSource.columns : [];\n            this.dataSourceSettings.filters = dataSource.filters ? dataSource.filters : [];\n            this.dataSourceSettings.filterSettings = dataSource.filterSettings ? dataSource.filterSettings : [];\n            this.dataSourceSettings.sortSettings = dataSource.sortSettings ? dataSource.sortSettings : [];\n            this.dataSourceSettings.conditionalFormatSettings = dataSource.conditionalFormatSettings ?\n                dataSource.conditionalFormatSettings : [];\n            this.dataSourceSettings.valueSortSettings = dataSource.valueSortSettings ? dataSource.valueSortSettings : {};\n            this.removeIrrelevantFields(Object.keys(this.fieldList));\n        }\n    };\n    PivotEngine.prototype.getGroupedRawData = function (dataSourceSettings) {\n        this.data = [];\n        for (var _i = 0, _a = this.actualData; _i < _a.length; _i++) {\n            var data = _a[_i];\n            this.data[this.data.length] = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(data);\n        }\n        var countFields = dataSourceSettings.values.filter(function (item) {\n            return item.type === 'Count' || item.type === 'DistinctCount';\n        }).map(function (item) { return item.name; });\n        var hasCountField = countFields.length > 0;\n        var realData = this.data;\n        var headerFields = dataSourceSettings.rows.concat(dataSourceSettings.columns.concat(dataSourceSettings.filters)).map(function (item) {\n            return item.name;\n        });\n        var groupRawData = {};\n        var finalData = [];\n        this.groupRawIndex = {};\n        var groupKeys = {};\n        var indexLength = 0;\n        for (var i = 0; i < realData.length; i++) {\n            var currData = realData[i];\n            var members = [];\n            if (hasCountField) {\n                for (var vPos = 0; vPos < countFields.length; vPos++) {\n                    currData[this.fieldKeys[countFields[vPos]]] =\n                        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currData[this.fieldKeys[countFields[vPos]]]) ?\n                            currData[this.fieldKeys[countFields[vPos]]] : 1;\n                }\n            }\n            for (var hPos = 0; hPos < headerFields.length; hPos++) {\n                members.push(currData[this.fieldKeys[headerFields[hPos]]]);\n            }\n            var memberJoin = members.join('-');\n            if (groupRawData[memberJoin]) {\n                for (var vPos = 0; vPos < dataSourceSettings.values.length; vPos++) {\n                    var currFieldName = dataSourceSettings.values[vPos].name;\n                    var currValue = currData[this.fieldKeys[currFieldName]];\n                    var savedData = groupRawData[memberJoin];\n                    var summType = dataSourceSettings.values[vPos].type;\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currValue)) {\n                        if (typeof currValue !== 'number' || summType === 'DistinctCount') {\n                            summType = 'Count';\n                        }\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(savedData[currFieldName])) {\n                            savedData[currFieldName] = summType === 'Product' ? 1 : ((summType === 'Min' || summType === 'Max')\n                                ? undefined : 0);\n                        }\n                        else if (typeof savedData[currFieldName] !== 'number') {\n                            savedData[currFieldName] = 1;\n                        }\n                        if (summType === 'Count') {\n                            savedData[currFieldName] += 1;\n                        }\n                        else if (summType === 'Min') {\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(savedData[currFieldName])) {\n                                savedData[currFieldName] = savedData[currFieldName] > currValue ?\n                                    currValue : savedData[currFieldName];\n                            }\n                        }\n                        else if (summType === 'Max') {\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(savedData[currFieldName])) {\n                                savedData[currFieldName] = savedData[currFieldName] < currValue ?\n                                    currValue : savedData[currFieldName];\n                            }\n                        }\n                        else if (summType === 'Product') {\n                            savedData[currFieldName] *= currValue;\n                        }\n                        else {\n                            savedData[currFieldName] += currValue;\n                        }\n                    }\n                }\n                if (this.isDrillThrough) {\n                    this.groupRawIndex[groupKeys[memberJoin]].push(i);\n                }\n            }\n            else {\n                (groupRawData)[memberJoin] = currData;\n                finalData.push(currData);\n                if (this.isDrillThrough) {\n                    this.groupRawIndex[indexLength] = [i];\n                    groupKeys[memberJoin] = indexLength;\n                    indexLength++;\n                }\n            }\n        }\n        return finalData;\n    };\n    PivotEngine.prototype.getGroupData = function (data) {\n        var _this = this;\n        var fieldkeySet = data[0];\n        var _loop_1 = function (i, groupElements) {\n            var group = groupElements[i];\n            var fieldName = group.name;\n            var caption = group.caption;\n            if (this_1.fields.indexOf(fieldName) > -1) {\n                var groupFields = {};\n                var customGroupFieldName = void 0;\n                if ((group.type === 'Date' && this_1.groupingFields[fieldName]) ||\n                    (group.type === 'Custom' && this_1.groupingFields[fieldName])) {\n                    return { value: fieldkeySet };\n                }\n                else if (group.type === 'Number') {\n                    if (_util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getType(fieldkeySet[fieldName]) === 'number' ||\n                        !this_1.groupingFields[fieldName]) {\n                        if (group.rangeInterval) {\n                            data.sort(function (a, b) { return (Number(a[_this.fieldKeys[fieldName]]) >\n                                Number(b[_this.fieldKeys[fieldName]])) ? 1 :\n                                ((Number(b[_this.fieldKeys[fieldName]]) >\n                                    Number(a[_this.fieldKeys[fieldName]])) ? -1 : 0); });\n                        }\n                    }\n                    else {\n                        return { value: fieldkeySet };\n                    }\n                }\n                // else if (group.type === 'Custom' && this.fields.indexOf(fieldName + '_custom_group') > -1) {\n                //     return fieldkeySet;\n                // }\n                var len = data.length;\n                while (len--) {\n                    var item = data[len];\n                    if (item[this_1.fieldKeys[fieldName]] && group.type === 'Date') {\n                        var date = new Date(item[this_1.fieldKeys[fieldName]].toString());\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(date) && group.groupInterval.length > 0) {\n                            for (var i_1 = 0, len_1 = group.groupInterval.length; i_1 < len_1; i_1++) {\n                                var interval = group.groupInterval[i_1];\n                                var isInRangeAvail = this_1.getRange(group, date.getTime());\n                                var newDate = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.resetTime(new Date());\n                                switch (interval) {\n                                    case 'Years':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_years';\n                                            groupFields[newFieldName] = interval;\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                new Date(newDate.setFullYear(date.getFullYear())).toString());\n                                        }\n                                        break;\n                                    case 'Quarters':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_quarters';\n                                            groupFields[newFieldName] = interval;\n                                            var month = Math.ceil((date.getMonth() + 1) / 3);\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                ((this_1.localeObj ? this_1.localeObj.getConstant('qtr') : 'Qtr') + month.toString()));\n                                        }\n                                        break;\n                                    case 'QuarterYear':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_quarterYear';\n                                            groupFields[newFieldName] = interval;\n                                            var month = Math.ceil((date.getMonth() + 1) / 3);\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                ((this_1.localeObj ? this_1.localeObj.getConstant('qtr') : 'Qtr') + month.toString() + ' '\n                                                    + (this_1.localeObj ? this_1.localeObj.getConstant('of') : 'of') + ' '\n                                                    + date.getFullYear().toString()));\n                                        }\n                                        break;\n                                    case 'Months':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_months';\n                                            groupFields[newFieldName] = interval;\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                new Date(newDate.setMonth(date.getMonth(), 1)).toString());\n                                        }\n                                        break;\n                                    case 'Days':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_days';\n                                            groupFields[newFieldName] = interval;\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                new Date(newDate.setMonth(date.getMonth(), date.getDate())).toString());\n                                        }\n                                        break;\n                                    case 'Hours':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_hours';\n                                            groupFields[newFieldName] = interval;\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                new Date(newDate.setHours(date.getHours())).toString());\n                                        }\n                                        break;\n                                    case 'Minutes':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_minutes';\n                                            groupFields[newFieldName] = interval;\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                new Date(newDate.setMinutes(date.getMinutes())).toString());\n                                        }\n                                        break;\n                                    case 'Seconds':\n                                        {\n                                            var newFieldName = (i_1 === group.groupInterval.length - 1) ? fieldName :\n                                                fieldName + '_date_group_seconds';\n                                            groupFields[newFieldName] = interval;\n                                            this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                                (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                                    this_1.fields.length) : newFieldName;\n                                            if (this_1.fields.indexOf(newFieldName) === -1) {\n                                                this_1.fields.push(newFieldName);\n                                            }\n                                            item[this_1.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :\n                                                new Date(newDate.setSeconds(date.getSeconds())).toString());\n                                        }\n                                        break;\n                                }\n                            }\n                        }\n                    }\n                    else if (!isNaN(Number(item[this_1.fieldKeys[fieldName]])) && group.type === 'Number') {\n                        var isInRangeAvail = this_1.getRange(group, Number(item[this_1.fieldKeys[fieldName]]));\n                        item[this_1.fieldKeys[fieldName]] = isInRangeAvail ? undefined :\n                            item[this_1.fieldKeys[fieldName]];\n                    }\n                    else if (item[this_1.fieldKeys[fieldName]] && group.type === 'Custom' &&\n                        group.customGroups && group.customGroups.length > 0) {\n                        var newFieldName = fieldName + '_custom_group';\n                        var customGroups = group.customGroups;\n                        var groupValue = void 0;\n                        this_1.groupingFieldsInfo[fieldName] = fieldName;\n                        this_1.groupingFieldsInfo[newFieldName] = fieldName;\n                        for (var i_2 = 0, len_2 = customGroups.length; i_2 < len_2; i_2++) {\n                            var cGroup = customGroups[i_2];\n                            if (cGroup.items && cGroup.items.length > 1) {\n                                customGroupFieldName = newFieldName;\n                                this_1.fieldKeys[newFieldName] = this_1.dataSourceSettings.type === 'CSV' ?\n                                    (this_1.fieldKeys[newFieldName] ? this_1.fieldKeys[newFieldName] :\n                                        this_1.fields.length) : newFieldName;\n                                if (this_1.fields.indexOf(newFieldName) === -1) {\n                                    this_1.fields.push(newFieldName);\n                                }\n                                var isDataMatch = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.inArray(item[this_1.fieldKeys[fieldName]].toString(), cGroup.items) === -1 ? false : true;\n                                item[this_1.fieldKeys[newFieldName]] =\n                                    (isDataMatch ? (cGroup.groupName && cGroup.groupName !== '') ? cGroup.groupName :\n                                        this_1.localeObj.getConstant('group') + ' ' + i_2 : (groupValue &&\n                                        groupValue !== item[this_1.fieldKeys[fieldName]].toString()) ?\n                                        groupValue : item[this_1.fieldKeys[fieldName]].toString());\n                                groupValue = item[this_1.fieldKeys[newFieldName]];\n                            }\n                        }\n                    }\n                    var keys = Object.keys(item);\n                    var isCompleteSet = [];\n                    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                        var key = keys_1[_i];\n                        isCompleteSet.push((item[key]) ? true : false);\n                    }\n                    fieldkeySet =\n                        (((isCompleteSet.indexOf(false) === -1) && keys.length === Object.keys(data[0]).length) ? item : fieldkeySet);\n                    //this.fields = Object.keys(fieldkeySet);\n                }\n                if (group.type === 'Date') {\n                    var isDataSource = false;\n                    var axisFields = [this_1.dataSourceSettings.rows, this_1.dataSourceSettings.columns,\n                        this_1.dataSourceSettings.values, this_1.dataSourceSettings.filters];\n                    var groupKeys = Object.keys(groupFields);\n                    var gCnt = Object.keys(groupKeys).length;\n                    var groupField = void 0;\n                    for (var _a = 0, axisFields_1 = axisFields; _a < axisFields_1.length; _a++) {\n                        var axis = axisFields_1[_a];\n                        if (!isDataSource && axis) {\n                            var cnt = axis.length;\n                            var i_3 = 0;\n                            while (i_3 < cnt) {\n                                if (axis[i_3].name === fieldName) {\n                                    isDataSource = true;\n                                    var actualField = axis[i_3];\n                                    axis.splice(i_3, 1);\n                                    var dataFields = this_1.dataSourceSettings.rows;\n                                    dataFields = dataFields.concat(this_1.dataSourceSettings.columns, this_1.dataSourceSettings.values, this_1.dataSourceSettings.filters);\n                                    while (gCnt--) {\n                                        var caption_1 = actualField.caption ? actualField.caption : actualField.name;\n                                        if (this_1.clonedReport) {\n                                            var clonedFields = this_1.clonedReport.rows;\n                                            clonedFields = clonedFields.concat(this_1.clonedReport.columns, this_1.clonedReport.values, this_1.clonedReport.filters);\n                                            var cloneField = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFieldByName(groupKeys[gCnt], clonedFields);\n                                            if (cloneField) {\n                                                caption_1 = cloneField.caption ? cloneField.caption : cloneField.name;\n                                            }\n                                        }\n                                        if (!_util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFieldByName(groupKeys[gCnt], dataFields)) {\n                                            groupField = groupFields[groupKeys[gCnt]];\n                                            caption_1 = (caption_1.indexOf(' (') !== -1 && caption_1.indexOf(')') !== -1) ?\n                                                caption_1.slice(caption_1.indexOf('(') + 1, caption_1.length - 1) : caption_1;\n                                            var newField = {\n                                                name: groupKeys[gCnt],\n                                                caption: (this_1.localeObj ? this_1.localeObj.getConstant(groupField) : groupField) + ' (' + caption_1 + ')',\n                                                type: 'Count',\n                                                showNoDataItems: actualField.showNoDataItems,\n                                                baseField: actualField.baseField,\n                                                baseItem: actualField.baseItem,\n                                                showFilterIcon: actualField.showFilterIcon,\n                                                showSortIcon: actualField.showSortIcon,\n                                                showEditIcon: actualField.showEditIcon,\n                                                showRemoveIcon: actualField.showRemoveIcon,\n                                                showSubTotals: actualField.showValueTypeIcon,\n                                                allowDragAndDrop: actualField.allowDragAndDrop,\n                                                expandAll: actualField.expandAll,\n                                                groupName: actualField.groupName\n                                            };\n                                            axis.splice(i_3, 0, newField);\n                                            this_1.groupingFieldsInfo[newField.name] = fieldName;\n                                        }\n                                        else {\n                                            this_1.groupingFieldsInfo[groupKeys[gCnt]] = fieldName;\n                                        }\n                                    }\n                                    break;\n                                }\n                                else if (axis[i_3].name.indexOf(fieldName) > -1) {\n                                    var axisField = groupFields[axis[i_3].name];\n                                    var currentField = axis.filter(function (axisField) {\n                                        return axisField.name === fieldName;\n                                    })[0];\n                                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentField)) {\n                                        var currentFieldCaption = currentField.caption ?\n                                            (currentField.caption.indexOf(' (') !== -1 && currentField.caption.indexOf(')') !== -1) ?\n                                                currentField.caption.slice(currentField.caption.indexOf('(') + 1, currentField.caption.length - 1) : currentField.caption : fieldName;\n                                        axis[i_3].caption = (this_1.localeObj ? this_1.localeObj.getConstant(axisField) : currentField)\n                                            + ' (' + currentFieldCaption + ')';\n                                    }\n                                }\n                                i_3++;\n                            }\n                            if (isDataSource) {\n                                break;\n                            }\n                        }\n                    }\n                    gCnt = Object.keys(groupKeys).length;\n                    var field = this_1.getMappingField(fieldName, this_1.clonedReport ? this_1.clonedReport.fieldMapping\n                        : this_1.dataSourceSettings.fieldMapping);\n                    var caption_2 = field.caption ? field.caption : fieldName;\n                    while (gCnt--) {\n                        groupField = groupFields[groupKeys[gCnt]];\n                        for (var i_4 = 0, len_3 = this_1.dataSourceSettings.formatSettings.length; i_4 < len_3; i_4++) {\n                            if (this_1.dataSourceSettings.formatSettings[i_4].name === groupKeys[gCnt]) {\n                                this_1.dataSourceSettings.formatSettings.splice(i_4, 1);\n                                break;\n                            }\n                        }\n                        if (groupField !== 'Quarters' && groupField !== 'QuarterYear') {\n                            var formatSettings = {\n                                name: groupKeys[gCnt],\n                                type: ['Years', 'Months', 'Days'].indexOf(groupField) > -1 ? 'date' : 'time',\n                                format: ((groupField === 'Years') ? 'yyyy' : (groupField === 'Months') ? 'MMM' :\n                                    (groupField === 'Days') ? 'd-MMM' : (groupField === 'Hours') ? 'hh a' :\n                                        (groupField === 'Minutes') ? ':mm' : (groupField === 'Seconds') ? ':ss' : undefined)\n                            };\n                            this_1.dataSourceSettings.formatSettings.push(formatSettings);\n                        }\n                        if (!isDataSource) {\n                            var mappingField = this_1.getMappingField(groupKeys[gCnt], this_1.dataSourceSettings.fieldMapping);\n                            if (groupKeys[gCnt] !== fieldName && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(mappingField.name)) {\n                                var newField = {\n                                    name: groupKeys[gCnt],\n                                    caption: (this_1.localeObj ? this_1.localeObj.getConstant(groupField) : groupField) + ' (' + caption_2 + ')'\n                                };\n                                this_1.dataSourceSettings.fieldMapping.push(newField);\n                                this_1.groupingFieldsInfo[newField.name] = fieldName;\n                            }\n                            else if (groupKeys[gCnt] !== fieldName) {\n                                mappingField.caption = (this_1.localeObj ? this_1.localeObj.getConstant(groupField) : groupField) + ' (' + caption_2 + ')';\n                                this_1.groupingFieldsInfo[mappingField.name] = fieldName;\n                            }\n                        }\n                    }\n                    if (!isDataSource) {\n                        var mappingField = this_1.getMappingField(fieldName, this_1.dataSourceSettings.fieldMapping);\n                        groupField = groupFields[fieldName];\n                        if (groupKeys[gCnt] !== fieldName && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(mappingField.name)) {\n                            var newField = {\n                                name: fieldName,\n                                caption: (this_1.localeObj ? this_1.localeObj.getConstant(groupField) : groupField) + ' (' + caption_2 + ')'\n                            };\n                            this_1.dataSourceSettings.fieldMapping.push(newField);\n                            this_1.groupingFieldsInfo[newField.name] = fieldName;\n                        }\n                        else {\n                            mappingField.caption = (this_1.localeObj ? this_1.localeObj.getConstant(groupField) : groupField) + ' (' + caption_2 + ')';\n                            this_1.groupingFieldsInfo[mappingField.name] = fieldName;\n                        }\n                    }\n                }\n                else if (group.type === 'Number' && group.rangeInterval) {\n                    var cEndValue = void 0;\n                    var framedSet = [];\n                    var unframedSet = [];\n                    var dataLength = data.length;\n                    var cnt = 0;\n                    this_1.groupingFields[fieldName] = fieldName;\n                    var endingAt = void 0;\n                    var groupName = [];\n                    while (cnt < dataLength) {\n                        var numericFieldName = Number(data[cnt][fieldName]);\n                        unframedSet.push(numericFieldName);\n                        if (!isNaN(numericFieldName) && framedSet.indexOf(numericFieldName) === -1) {\n                            framedSet.push(numericFieldName);\n                        }\n                        cnt++;\n                    }\n                    dataLength = data.length;\n                    cnt = 0;\n                    while (cnt < dataLength) {\n                        var currentData = data[cnt];\n                        if (currentData && !isNaN(Number(currentData[fieldName]))) {\n                            endingAt = typeof (group.endingAt) === 'string' ? parseInt(group.endingAt, 10) : group.endingAt;\n                            cEndValue = endingAt ? endingAt : Math.max.apply(Math, framedSet);\n                            var decimalCnt = !Number.isInteger(group.rangeInterval) ?\n                                this_1.countDecimalPlaces(group.rangeInterval) : 0;\n                            var range = void 0;\n                            switch (decimalCnt) {\n                                case 10:\n                                    range = 0.0000000001;\n                                    break;\n                                case 9:\n                                    range = 0.000000001;\n                                    break;\n                                case 8:\n                                    range = 0.00000001;\n                                    break;\n                                case 7:\n                                    range = 0.0000001;\n                                    break;\n                                case 6:\n                                    range = 0.000001;\n                                    break;\n                                case 5:\n                                    range = 0.00001;\n                                    break;\n                                case 4:\n                                    range = 0.0001;\n                                    break;\n                                case 3:\n                                    range = 0.001;\n                                    break;\n                                case 2:\n                                    range = 0.01;\n                                    break;\n                                case 1:\n                                    range = 0.1;\n                                    break;\n                                default:\n                                    range = 1;\n                            }\n                            var currentStartValue = Number.isInteger(group.rangeInterval) ?\n                                Math.floor(Number(currentData[fieldName])) :\n                                Number(currentData[fieldName].toFixed(decimalCnt));\n                            var currentEndValue = Number.isInteger(group.rangeInterval) ?\n                                Math.floor(Number(currentStartValue + (group.rangeInterval - 1))) :\n                                Number((currentStartValue + (group.rangeInterval)).toFixed(decimalCnt));\n                            if (currentStartValue >= groupName[0] && currentStartValue <= groupName[groupName.length - 1]) {\n                                var startValue = groupName[0];\n                                var endValue = Number.isInteger(group.rangeInterval) ?\n                                    Math.floor(groupName[groupName.length - 1]) :\n                                    Number(groupName[groupName.length - 1].toFixed(decimalCnt));\n                                this_1.processGrouping(currentData, fieldName, startValue, endValue, cEndValue, group.rangeInterval, decimalCnt);\n                                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this_1.groupedDataType[fieldName])) {\n                                    this_1.groupedDataType[fieldName] = 'string';\n                                }\n                            }\n                            else {\n                                if (groupName.length === 0) {\n                                    for (var i_5 = currentStartValue; i_5 <= currentEndValue; i_5 = Number((i_5 + range).toFixed(decimalCnt))) {\n                                        groupName.push(i_5);\n                                    }\n                                    var startValue = groupName[0];\n                                    var endValue = Number.isInteger(group.rangeInterval) ?\n                                        Math.floor(groupName[groupName.length - 1]) :\n                                        Number(groupName[groupName.length - 1].toFixed(decimalCnt));\n                                    this_1.processGrouping(currentData, fieldName, startValue, endValue, cEndValue, group.rangeInterval, decimalCnt);\n                                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this_1.groupedDataType[fieldName])) {\n                                        this_1.groupedDataType[fieldName] = 'string';\n                                    }\n                                }\n                                else {\n                                    var startValue = Number.isInteger(group.rangeInterval) ?\n                                        Math.floor(groupName[groupName.length - 1]) + 1 :\n                                        Number((groupName[groupName.length - 1]).toFixed(decimalCnt));\n                                    var endValue = Number.isInteger(group.rangeInterval) ?\n                                        Math.floor(startValue + (group.rangeInterval - 1)) :\n                                        Number((startValue + group.rangeInterval).toFixed(decimalCnt));\n                                    var grouping = true;\n                                    groupName.splice(0, groupName.length);\n                                    while (grouping) {\n                                        if (currentStartValue >= startValue && currentStartValue <= endValue) {\n                                            this_1.processGrouping(currentData, fieldName, startValue, endValue, cEndValue, group.rangeInterval, decimalCnt);\n                                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this_1.groupedDataType[fieldName])) {\n                                                this_1.groupedDataType[fieldName] = 'string';\n                                            }\n                                            groupName.push(startValue);\n                                            groupName.push(endValue);\n                                            grouping = false;\n                                        }\n                                        startValue = Number.isInteger(group.rangeInterval) ? endValue + 1 : endValue;\n                                        endValue =\n                                            Number.isInteger(group.rangeInterval) ? Math.floor(startValue + (group.rangeInterval - 1)) :\n                                                Number((startValue + (group.rangeInterval)).toFixed(decimalCnt));\n                                    }\n                                }\n                            }\n                            var keys = Object.keys(currentData);\n                            var isCompleteSet = [];\n                            for (var _b = 0, keys_2 = keys; _b < keys_2.length; _b++) {\n                                var key = keys_2[_b];\n                                isCompleteSet.push((currentData[key]) ? true : false);\n                            }\n                            fieldkeySet = (((isCompleteSet.indexOf(false) === -1) && keys.length === Object.keys(data[0]).length) ?\n                                currentData : fieldkeySet);\n                        }\n                        cnt++;\n                    }\n                    var axisFields = [this_1.dataSourceSettings.rows, this_1.dataSourceSettings.columns,\n                        this_1.dataSourceSettings.values, this_1.dataSourceSettings.filters];\n                    for (var _c = 0, axisFields_2 = axisFields; _c < axisFields_2.length; _c++) {\n                        var fields = axisFields_2[_c];\n                        var field = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFieldByName(fieldName, fields);\n                        if (field) {\n                            field = field.properties ? field.properties : field;\n                            field.type = 'Count';\n                        }\n                    }\n                    for (var i_6 = 0, len_4 = this_1.dataSourceSettings.formatSettings.length; i_6 < len_4; i_6++) {\n                        if (this_1.dataSourceSettings.formatSettings[i_6].name === fieldName) {\n                            this_1.dataSourceSettings.formatSettings.splice(i_6, 1);\n                            break;\n                        }\n                    }\n                }\n                else if (group.type === 'Custom' && customGroupFieldName) {\n                    var customFieldName = customGroupFieldName;\n                    // this.groupingFields[customFieldName] = customFieldName;\n                    var isDataSource = false;\n                    var axisFields = [this_1.dataSourceSettings.rows, this_1.dataSourceSettings.columns,\n                        this_1.dataSourceSettings.values, this_1.dataSourceSettings.filters];\n                    var dataFields = this_1.dataSourceSettings.rows;\n                    dataFields = dataFields.concat(this_1.dataSourceSettings.columns, this_1.dataSourceSettings.values, this_1.dataSourceSettings.filters);\n                    var pattern = [];\n                    if (!caption || caption === '') {\n                        pattern = customFieldName.match(/_custom_group/g);\n                    }\n                    // let actualFieldName: string = fieldName.replace(/_custom_group/g, '');\n                    var parentField = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFieldByName(fieldName.replace(/_custom_group/g, ''), dataFields);\n                    var customGroupField = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFieldByName(customFieldName, dataFields);\n                    for (var _d = 0, axisFields_3 = axisFields; _d < axisFields_3.length; _d++) {\n                        var axis = axisFields_3[_d];\n                        if (!isDataSource && axis) {\n                            var cnt = axis.length;\n                            var i_7 = 0;\n                            while (i_7 < cnt) {\n                                if (axis[i_7].name === group.name && !customGroupField) {\n                                    isDataSource = true;\n                                    var actualField = axis[i_7];\n                                    var newField = {\n                                        name: customFieldName,\n                                        caption: (!caption || caption === '') ? (parentField.caption ? parentField.caption : parentField.name) + (pattern.length + 1) : caption,\n                                        type: 'Count',\n                                        showNoDataItems: actualField.showNoDataItems,\n                                        baseField: actualField.baseField,\n                                        baseItem: actualField.baseItem,\n                                        showSubTotals: actualField.showValueTypeIcon,\n                                        allowDragAndDrop: actualField.allowDragAndDrop,\n                                        showFilterIcon: actualField.showFilterIcon,\n                                        showSortIcon: actualField.showSortIcon,\n                                        showRemoveIcon: actualField.showRemoveIcon,\n                                        showEditIcon: actualField.showEditIcon,\n                                        expandAll: actualField.expandAll,\n                                        groupName: actualField.groupName\n                                    };\n                                    axis.splice(i_7, 0, newField);\n                                    this_1.groupingFieldsInfo[newField.name] = fieldName;\n                                    this_1.groupingFieldsInfo[fieldName] = fieldName;\n                                    break;\n                                }\n                                else if (axis[i_7].name === customFieldName && customGroupField) {\n                                    var newField = {\n                                        name: customGroupField.name,\n                                        caption: (!caption || caption === '') ? customGroupField.caption : caption,\n                                        type: customGroupField.type,\n                                        showNoDataItems: customGroupField.showNoDataItems,\n                                        baseField: customGroupField.baseField,\n                                        baseItem: customGroupField.baseItem,\n                                        showRemoveIcon: customGroupField.showRemoveIcon,\n                                        showSubTotals: customGroupField.showValueTypeIcon,\n                                        allowDragAndDrop: customGroupField.allowDragAndDrop,\n                                        showFilterIcon: customGroupField.showFilterIcon,\n                                        showSortIcon: customGroupField.showSortIcon,\n                                        showEditIcon: customGroupField.showEditIcon,\n                                        expandAll: customGroupField.expandAll,\n                                        groupName: customGroupField.groupName\n                                    };\n                                    axis.splice(i_7, 1, newField);\n                                    this_1.groupingFieldsInfo[newField.name] = fieldName;\n                                    this_1.groupingFieldsInfo[fieldName] = fieldName;\n                                    break;\n                                }\n                                i_7++;\n                            }\n                            if (isDataSource) {\n                                break;\n                            }\n                        }\n                    }\n                    var formatfield = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFieldByName(fieldName, _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.cloneFormatSettings(this_1.dataSourceSettings.formatSettings));\n                    if (formatfield) {\n                        formatfield.name = customFieldName;\n                        this_1.dataSourceSettings.formatSettings.push(formatfield);\n                    }\n                    this_1.groupingFields[fieldName] = fieldName;\n                }\n                this_1.groupingFields = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)(this_1.groupingFields, groupFields);\n            }\n            else {\n                if (i < groupElements.length - 1) {\n                    return \"continue\";\n                }\n                else {\n                    return { value: fieldkeySet };\n                }\n            }\n        };\n        var this_1 = this;\n        for (var i = 0, groupElements = this.dataSourceSettings.groupSettings; i < groupElements.length; i++) {\n            var state_1 = _loop_1(i, groupElements);\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n        }\n        //this.fields = Object.keys(fieldkeySet);\n        return fieldkeySet;\n    };\n    PivotEngine.prototype.countDecimalPlaces = function (num) {\n        var decimalValue = num.toString();\n        return decimalValue.includes('.') ? decimalValue.split('.')[1].length : 0;\n    };\n    PivotEngine.prototype.processGrouping = function (currentData, fieldName, startValue, endValue, cEndValue, rangeInterval, decimalCnt) {\n        if ((Number.isInteger(currentData[fieldName])) || (!Number.isInteger(currentData[fieldName])\n            && (Number(currentData[fieldName]) < endValue || cEndValue <= Number(currentData[fieldName])))) {\n            currentData[fieldName] = this.getNumberGroupHeaders(startValue, endValue, cEndValue);\n        }\n        else if (!Number.isInteger(currentData[fieldName]) && Number(currentData[fieldName]) >= endValue) {\n            currentData[fieldName] =\n                this.getNumberGroupHeaders(Number((startValue + rangeInterval).toFixed(decimalCnt)), Number((endValue + rangeInterval).toFixed(decimalCnt)), cEndValue);\n        }\n    };\n    PivotEngine.prototype.getNumberGroupHeaders = function (startValue, endValue, cEndValue) {\n        var fieldName = (startValue === endValue) ? startValue.toString() : (cEndValue >= startValue && cEndValue <= endValue) ?\n            (cEndValue === startValue) ? startValue.toString() : startValue.toString() + '-' + cEndValue.toString() :\n            startValue.toString() + '-' + endValue.toString();\n        return fieldName;\n    };\n    PivotEngine.prototype.getRange = function (group, cValue) {\n        var isRangeAvail;\n        if (group.type === 'Date') {\n            var cDate = new Date(cValue);\n            var startDate = typeof (group.startingAt) === 'string' ? new Date(group.startingAt) : group.startingAt;\n            var endDate = typeof (group.endingAt) === 'string' ? new Date(group.endingAt) : group.endingAt;\n            if (startDate && cDate.getTime() < startDate.getTime() ||\n                endDate && cDate.getTime() > endDate.getTime()) {\n                isRangeAvail = true;\n            }\n            else {\n                isRangeAvail = false;\n            }\n        }\n        else {\n            var startValue = typeof (group.startingAt) === 'string' ? parseFloat(group.startingAt) : group.startingAt;\n            var endValue = typeof (group.endingAt) === 'string' ? parseFloat(group.endingAt) : group.endingAt;\n            if (!isNaN(startValue) && cValue < startValue || !isNaN(endValue) && cValue > endValue) {\n                isRangeAvail = true;\n            }\n            else {\n                isRangeAvail = false;\n            }\n        }\n        return isRangeAvail;\n    };\n    PivotEngine.prototype.getPercentFormat = function (formatField, currentField) {\n        var isHavingFormat = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(formatField[currentField]) &&\n            !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.formatFields[currentField].format)) ?\n            (this.formatFields[currentField].format).toLowerCase().match(/p[0-9]/) : undefined;\n        return !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isHavingFormat) ? (Number((this.formatFields[currentField].format).replace(/[^0-9]/g, ''))) : 2;\n    };\n    PivotEngine.prototype.getFormattedFields = function (dataSourceSettings) {\n        this.formatFields = this.setFormattedFields(dataSourceSettings.formatSettings);\n        // for (let len: number = 0, lnt: number = fields.length; len < lnt; len++) {\n        // if (fields[len as number] && fields[len as number].name === this.dataSourceSettings.formatSettings[cnt as number].name) {\n        //     this.formatFields[fields[len as number].name] = this.dataSourceSettings.formatSettings[cnt as number];\n        // }\n        // }\n    };\n    /**\n     * It is used to update the format fields.\n     *\n     * @param {IFormatSettings[]} formatSettings -  It contains the format settings.\n     * @returns {Object} - An object mapping keys to format settings.\n     * @hidden\n     */\n    PivotEngine.prototype.setFormattedFields = function (formatSettings) {\n        var cnt = formatSettings.length;\n        var formatFields = {};\n        while (cnt--) {\n            formatFields[formatSettings[cnt].name] = formatSettings[cnt];\n            if (formatSettings[cnt].type) {\n                this.dateFormatFunction[formatSettings[cnt].name] = {\n                    exactFormat: this.globalize.getDateFormat(formatSettings[cnt]),\n                    fullFormat: this.globalize.getDateFormat({\n                        format: 'yyyy/MM/dd/HH/mm/ss', type: formatSettings[cnt].type\n                    })\n                };\n            }\n        }\n        return formatFields;\n    };\n    PivotEngine.prototype.getFieldList = function (fields, isSort, isValueFilteringEnabled) {\n        var _this = this;\n        var type;\n        var lenE = this.dataSourceSettings.excludeFields.length - 1;\n        while (lenE > -1) {\n            var index = this.fields.indexOf(this.dataSourceSettings.excludeFields[lenE]);\n            if (index !== -1) {\n                this.fields.splice(index, 1);\n            }\n            if (this.fieldList) {\n                delete this.fieldList[this.dataSourceSettings.excludeFields[lenE]];\n            }\n            lenE--;\n        }\n        var keys = this.fields;\n        var dataFields = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSourceSettings.rows, null, true);\n        dataFields = dataFields.concat(this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters);\n        this.getFormattedFields(this.dataSourceSettings);\n        this.getCalculatedField(keys);\n        keys = this.fields;\n        var len = keys.length;\n        var dataTypes = ['string', 'number', 'datetime', 'date', 'boolean'];\n        if (this.savedFieldList) {\n            this.fieldList = this.savedFieldList;\n            while (len--) { /** while is used for better performance than for */\n                var key = keys[len];\n                var field = this.getMappingField(key, this.dataSourceSettings.fieldMapping);\n                if (this.fieldList[key]) {\n                    this.fieldList[key].isSelected = false;\n                    this.fieldList[key].index = len;\n                    this.fieldList[key].filter = [];\n                    this.fieldList[key].sort = isSort ? 'Ascending' : 'None';\n                    this.fieldList[key].isExcelFilter = false;\n                    this.fieldList[key].filterType = '';\n                    this.fieldList[key].showFilterIcon = (field && 'showFilterIcon' in field) ?\n                        field.showFilterIcon : true;\n                    this.fieldList[key].showRemoveIcon = (field && 'showRemoveIcon' in field) ?\n                        field.showRemoveIcon : true;\n                    this.fieldList[key].showSortIcon = (field && 'showSortIcon' in field) ?\n                        field.showSortIcon : true;\n                    this.fieldList[key].showEditIcon = (field && 'showEditIcon' in field) ?\n                        field.showEditIcon : true;\n                    this.fieldList[key].showValueTypeIcon = (field && 'showValueTypeIcon' in field) ?\n                        field.showValueTypeIcon : true;\n                    this.fieldList[key].allowDragAndDrop = (field && 'allowDragAndDrop' in field) ?\n                        field.allowDragAndDrop : true;\n                    this.fieldList[key].isCalculatedField = (field && 'isCalculatedField' in field) ?\n                        field.isCalculatedField : false;\n                    this.fieldList[key].showNoDataItems = (field && 'showNoDataItems' in field) ?\n                        field.showNoDataItems : false;\n                    this.fieldList[key].showSubTotals = (field && 'showSubTotals' in field) ?\n                        field.showSubTotals : true;\n                    this.fieldList[key].expandAll = (field && 'expandAll' in field) ?\n                        field.expandAll : false;\n                    this.fieldList[key].pid = (field && 'groupName' in field && field.groupName) ? field.groupName :\n                        this.groupingFieldsInfo[key] ? this.groupingFieldsInfo[key] : undefined;\n                    if (this.isValueFiltersAvail && isValueFilteringEnabled) {\n                        this.fieldList[key].dateMember = [];\n                        this.fieldList[key].members = {};\n                        this.fieldList[key].isMembersFilled = false;\n                    }\n                    this.updateMembersOrder(key);\n                }\n                else {\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.groupedDataType[key])) {\n                        type = this.groupedDataType[key];\n                    }\n                    else {\n                        type = (field && 'dataType' in field && field.dataType && dataTypes.indexOf(field.dataType.toLowerCase()) > -1) ?\n                            field.dataType.toLowerCase() : type;\n                    }\n                    this.fieldList[key] = {\n                        caption: (field && 'caption' in field && field.caption) ? field.caption : key,\n                        id: key,\n                        type: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ?\n                            'string' : (type === undefined || type === 'undefined') ? 'number' : type,\n                        isSelected: false,\n                        sort: isSort ? 'Ascending' : 'None',\n                        filterType: '',\n                        index: len,\n                        filter: [],\n                        isCustomField: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)),\n                        showRemoveIcon: (field && 'showRemoveIcon' in field) ?\n                            field.showRemoveIcon : true,\n                        showFilterIcon: (field && 'showFilterIcon' in field) ?\n                            field.showFilterIcon : true,\n                        showSortIcon: (field && 'showSortIcon' in field) ?\n                            field.showSortIcon : true,\n                        showNoDataItems: (field && 'showNoDataItems' in field) ?\n                            field.showNoDataItems : false,\n                        isCalculatedField: (field && 'isCalculatedField' in field) ?\n                            field.isCalculatedField : false,\n                        showEditIcon: (field && 'showEditIcon' in field) ?\n                            field.showEditIcon : true,\n                        showValueTypeIcon: (field && 'showValueTypeIcon' in field) ?\n                            field.showValueTypeIcon : true,\n                        allowDragAndDrop: (field && 'allowDragAndDrop' in field) ?\n                            field.allowDragAndDrop : true,\n                        showSubTotals: (field && 'showSubTotals' in field) ?\n                            field.showSubTotals : true,\n                        expandAll: (field && 'expandAll' in field) ?\n                            field.expandAll : false,\n                        pid: (field && 'groupName' in field && field.groupName) ? field.groupName :\n                            this.groupingFieldsInfo[key] ? this.groupingFieldsInfo[key] : undefined,\n                        aggregateType: (field && 'type' in field) ? field.type :\n                            (((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ? 'string' :\n                                (type === undefined || type === 'undefined') ? 'number' : type) === 'number' ? 'Sum' : 'Count',\n                        baseField: (field && 'baseField' in field) ?\n                            field.baseField : undefined,\n                        baseItem: (field && 'baseItem' in field) ?\n                            field.baseItem : undefined\n                    };\n                    this.updateMembersOrder(key);\n                }\n            }\n        }\n        else {\n            this.fieldList = {};\n            var _loop_2 = function () {\n                var key = keys[len];\n                var field = this_2.getMappingField(key, this_2.dataSourceSettings.fieldMapping);\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this_2.groupedDataType[key])) {\n                    type = this_2.groupedDataType[key];\n                }\n                else {\n                    type = (field && 'dataType' in field && field.dataType && dataTypes.indexOf(field.dataType.toLowerCase()) > -1) ?\n                        field.dataType.toLowerCase() : _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getType(fields[this_2.fieldKeys[key]]);\n                }\n                if (type === undefined || type === 'undefined') {\n                    if (this_2.dataSourceSettings.groupSettings.length > 0) {\n                        this_2.dataSourceSettings.groupSettings.forEach(function (setting) {\n                            if (_this.fieldKeys[key] === setting.name && setting.type.toLocaleLowerCase() === 'number') {\n                                type = 'string';\n                            }\n                            else {\n                                type = 'number';\n                            }\n                        });\n                    }\n                    else {\n                        type = 'number';\n                    }\n                }\n                this_2.fieldList[key] = {\n                    id: key,\n                    pid: (field && 'groupName' in field && field.groupName) ? field.groupName :\n                        this_2.groupingFieldsInfo[key] ? this_2.groupingFieldsInfo[key] : undefined,\n                    caption: (field && 'caption' in field && field.caption) ? field.caption : key,\n                    type: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ?\n                        'string' : type,\n                    filterType: '',\n                    index: len,\n                    filter: [],\n                    sort: isSort ? 'Ascending' : 'None',\n                    isSelected: false,\n                    isCustomField: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)),\n                    showFilterIcon: (field && 'showFilterIcon' in field) ?\n                        field.showFilterIcon : true,\n                    showRemoveIcon: (field && 'showRemoveIcon' in field) ?\n                        field.showRemoveIcon : true,\n                    showSortIcon: (field && 'showSortIcon' in field) ?\n                        field.showSortIcon : true,\n                    showEditIcon: (field && 'showEditIcon' in field) ?\n                        field.showEditIcon : true,\n                    showValueTypeIcon: (field && 'showValueTypeIcon' in field) ?\n                        field.showValueTypeIcon : true,\n                    allowDragAndDrop: (field && 'allowDragAndDrop' in field) ?\n                        field.allowDragAndDrop : true,\n                    showSubTotals: (field && 'showSubTotals' in field) ?\n                        field.showSubTotals : true,\n                    showNoDataItems: (field && 'showNoDataItems' in field) ?\n                        field.showNoDataItems : false,\n                    isCalculatedField: (field && 'isCalculatedField' in field) ?\n                        field.isCalculatedField : false,\n                    expandAll: (field && 'expandAll' in field) ?\n                        field.expandAll : false,\n                    aggregateType: (field && 'type' in field) ? field.type :\n                        (((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ? 'string' :\n                            (type === undefined || type === 'undefined') ? 'number' : type) === 'number' ? 'Sum' : 'Count',\n                    baseField: (field && 'baseField' in field) ?\n                        field.baseField : undefined,\n                    baseItem: (field && 'baseItem' in field) ?\n                        field.baseItem : undefined\n                };\n                this_2.updateMembersOrder(key);\n            };\n            var this_2 = this;\n            while (len--) {\n                _loop_2();\n            }\n        }\n        this.groupedDataType = {};\n        this.updateTreeViewData(dataFields);\n    };\n    PivotEngine.prototype.updateMembersOrder = function (key) {\n        for (var _i = 0, _a = this.dataSourceSettings.sortSettings; _i < _a.length; _i++) {\n            var sortInfo = _a[_i];\n            if (key === sortInfo.name && sortInfo.membersOrder) {\n                this.fieldList[key].membersOrder = sortInfo.membersOrder;\n                break;\n            }\n        }\n    };\n    PivotEngine.prototype.getMappingField = function (key, fieldMapping) {\n        var field = {};\n        if (fieldMapping && fieldMapping.length > 0) {\n            for (var index = 0, cnt = fieldMapping.length; index < cnt; index++) {\n                if (fieldMapping[index].name === key) {\n                    field = fieldMapping[index];\n                    break;\n                }\n            }\n        }\n        return field;\n    };\n    PivotEngine.prototype.updateFieldList = function (savedFieldList) {\n        var keys = this.fields;\n        var len = keys.length;\n        while (len--) { /** while is used for better performance than for */\n            this.fieldList[keys[len]].isExcelFilter = savedFieldList[keys[len]].isExcelFilter;\n        }\n    };\n    PivotEngine.prototype.updateTreeViewData = function (fields) {\n        var _this = this;\n        var cnt = fields.length;\n        var lnt = this.dataSourceSettings.calculatedFieldSettings.length;\n        while (cnt--) {\n            if (this.fieldList[fields[cnt].name]) {\n                var field = this.fieldList[fields[cnt].name];\n                field.type = fields[cnt].dataType ? fields[cnt].dataType.toLowerCase() : field.type;\n                field.caption = fields[cnt].caption ? fields[cnt].caption : fields[cnt].name;\n                field.isSelected = true;\n                field.showNoDataItems = fields[cnt].showNoDataItems;\n                field.aggregateType = fields[cnt].type;\n                field.baseField = fields[cnt].baseField;\n                field.baseItem = fields[cnt].baseItem;\n                field.allowDragAndDrop = fields[cnt].allowDragAndDrop;\n                field.showFilterIcon = fields[cnt].showFilterIcon;\n                field.showSortIcon = fields[cnt].showSortIcon;\n                field.showRemoveIcon = fields[cnt].showRemoveIcon;\n                field.showValueTypeIcon = fields[cnt].showValueTypeIcon;\n                field.showEditIcon = fields[cnt].showEditIcon;\n                field.showSubTotals = fields[cnt].showSubTotals;\n                field.expandAll = fields[cnt].expandAll;\n            }\n        }\n        while (lnt--) {\n            if (this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name]) {\n                this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name].aggregateType = 'CalculatedField';\n                this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name].isCalculatedField = true;\n                this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name].formula\n                    = this.dataSourceSettings.calculatedFieldSettings[lnt].formula;\n            }\n        }\n        var unBoundFields = this.dataSourceSettings.groupSettings.filter(function (groupSetting) {\n            return !fields.some(function (field) { return groupSetting.name === field.name; });\n        });\n        var groupingTypes = [\n            '_date_group_years',\n            '_date_group_quarters',\n            '_date_group_quarterYear',\n            '_date_group_months',\n            '_date_group_days',\n            '_date_group_hours',\n            '_date_group_minutes',\n            '_date_group_seconds'\n        ];\n        unBoundFields.forEach(function (unBoundField) {\n            var fieldName = unBoundField.name;\n            var fieldType = unBoundField.type.toLowerCase();\n            Object.keys(_this.fieldList).forEach(function (key) {\n                if (fieldType === 'date' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(unBoundField.caption) &&\n                    (groupingTypes.some(function (dateType) { return key === \"\" + fieldName + dateType; }) || key === fieldName)) {\n                    _this.fieldList[key].caption =\n                        _this.fieldList[key].caption.replace(unBoundField.name, unBoundField.caption);\n                }\n                else if (fieldType === 'custom' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(unBoundField.caption) && key === fieldName + \"_custom_group\") {\n                    _this.fieldList[key].caption = unBoundField.caption;\n                }\n                else if (fieldType === 'number' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(unBoundField.caption) && key === fieldName) {\n                    _this.fieldList[key].caption = unBoundField.caption;\n                }\n            });\n        });\n    };\n    PivotEngine.prototype.getCalculatedField = function (keys) {\n        for (var _i = 0, _a = this.dataSourceSettings.calculatedFieldSettings; _i < _a.length; _i++) {\n            var field = _a[_i];\n            this.calculatedFields[field.name] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, field, null, true);\n            this.calculatedFields[field.name].actualFormula = field.formula;\n        }\n        var fieldKeys = Object.keys(this.calculatedFields);\n        var _loop_3 = function (calc, cnt) {\n            var field = this_3.calculatedFields[fieldKeys[calc]];\n            var calcProperties = field.properties;\n            var actualFormula = (calcProperties ? calcProperties.formula : field.formula).trim();\n            var formula = actualFormula.replace(/\"/g, '');\n            field.formula = formula.indexOf('^') > -1 ? this_3.powerFunction(formula) : formula;\n            if (field.formula.indexOf('Math.min(') === -1 && field.formula.indexOf('min(') > -1) {\n                field.formula = field.formula.replace(/min\\(/g, 'Math.min(');\n            }\n            if (field.formula.indexOf('Math.max(') === -1 && field.formula.indexOf('max(') > -1) {\n                field.formula = field.formula.replace(/max\\(/g, 'Math.max(');\n            }\n            if (field.formula.indexOf('Math.abs(') === -1 && field.formula.indexOf('abs(') > -1) {\n                field.formula = field.formula.replace(/abs\\(/g, 'Math.abs(');\n            }\n            field.name = calcProperties ? calcProperties.name : field.name;\n            if (this_3.dataSourceSettings.type === 'CSV') {\n                if (keys.indexOf(field.name) === -1) {\n                    keys.push(field.name);\n                }\n            }\n            else {\n                keys = keys.filter(function (key) { return key !== field.name; });\n                keys.push(field.name);\n            }\n            var formulaType = actualFormula.split('\"');\n            for (var len = 0, lmt = formulaType.length; len < lmt; len++) {\n                var type = formulaType[len].trim();\n                var aggregateValue = type.split(/[ .:;?!~,`\"&|()<>{}[\\]\\r\\n/\\\\]+/);\n                var matchStrings = type.match(/^([^()]+)\\((.*)\\)$/);\n                var selectedString = (aggregateValue[0] === 'DistinctCount' ?\n                    'DistinctCount' : aggregateValue[0] === 'PopulationStDev' ?\n                    'PopulationStDev' : aggregateValue[0] === 'SampleStDev' ? 'SampleStDev' : aggregateValue[0] === 'PopulationVar' ?\n                    'PopulationVar' : aggregateValue[0] === 'SampleVar' ? 'SampleVar' : aggregateValue[0]);\n                if (['Sum', 'Count', 'Min', 'Max', 'Avg', 'Product', 'DistinctCount',\n                    'PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar', 'Median'].indexOf(selectedString) !== -1) {\n                    var index = (keys.indexOf(aggregateValue[1]) === -1 && matchStrings[2]) ?\n                        keys.indexOf(matchStrings[2]) : keys.indexOf(aggregateValue[1]);\n                    if (!this_3.calculatedFormulas[field.name]) {\n                        this_3.calculatedFormulas[field.name] = [{\n                                index: index,\n                                type: selectedString,\n                                formula: type\n                            }];\n                    }\n                    else {\n                        this_3.calculatedFormulas[field.name].push({\n                            index: index,\n                            type: selectedString,\n                            formula: type\n                        });\n                    }\n                }\n            }\n        };\n        var this_3 = this;\n        for (var calc = 0, cnt = fieldKeys.length; calc < cnt; calc++) {\n            _loop_3(calc, cnt);\n        }\n        this.fields = keys;\n    };\n    PivotEngine.prototype.validateFilters = function (data) {\n        this.isValueFiltersAvail = false;\n        var filterElements = data.filterSettings ? data.filterSettings : [];\n        var dataFields = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSourceSettings.rows, null, true);\n        dataFields = dataFields.concat(this.dataSourceSettings.columns);\n        for (var _i = 0, filterElements_1 = filterElements; _i < filterElements_1.length; _i++) {\n            var filter = filterElements_1[_i];\n            for (var _a = 0, dataFields_1 = dataFields; _a < dataFields_1.length; _a++) {\n                var field = dataFields_1[_a];\n                if (filter.name === field.name && filter.type === 'Value') {\n                    this.isValueFiltersAvail = true;\n                    break;\n                }\n            }\n            if (this.isValueFiltersAvail) {\n                break;\n            }\n        }\n    };\n    PivotEngine.prototype.validateValueFields = function () {\n        this.isValueHasAdvancedAggregate = false;\n        for (var _i = 0, _a = this.dataSourceSettings.values; _i < _a.length; _i++) {\n            var value = _a[_i];\n            if ((['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal', 'RunningTotals']).indexOf(value.type) !== -1) {\n                this.isValueHasAdvancedAggregate = true;\n                break;\n            }\n        }\n    };\n    /**\n     * It is used to update the current field members.\n     *\n     * @param {string} fieldName -  Current field Name.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.fetchFieldMembers = function (fieldName) {\n        var fieldPosition = this.fieldList[fieldName].index;\n        this.generateMembers(fieldPosition, new Set());\n    };\n    PivotEngine.prototype.generateMembers = function (kl, formulaFields) {\n        var dlen = this.data.length;\n        var keys = this.fields;\n        var fList = this.fieldList;\n        var key = keys[kl];\n        if (!fList[key].members || this.allowDataCompression) {\n            fList[key].members = {};\n            if (this.allowDataCompression) {\n                fList[key].isMembersFilled = false;\n            }\n        }\n        if (!fList[key].dateMember || this.allowDataCompression) {\n            fList[key].dateMember = [];\n        }\n        var members = fList[key].members;\n        var dateMember = fList[key].dateMember;\n        if ((fList[key].isSelected || formulaFields.has(kl)) && !fList[key].isMembersFilled) {\n            var isDataAvail = Object.keys(members).length > 0;\n            var membersCnt = 0;\n            var isFieldHasExpandAll = fList[key].expandAll;\n            var isDateType = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.isDateField(key, this);\n            //let sort: string[] = [];\n            for (var dl = 0; dl < dlen; dl++) {\n                var memberkey = this.data[dl][this.fieldKeys[key]];\n                var mkey = memberkey;\n                mkey = this.enableHtmlSanitizer ? _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.SanitizeHtmlHelper.sanitize(mkey) : mkey;\n                // if (!isNullOrUndefined(mkey)) {\n                if (!isDataAvail) {\n                    var formattedValue = isDateType ? this.getFormattedValue(mkey, key) : ({\n                        formattedText: mkey === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(mkey)) :\n                            mkey === undefined ? (this.localeObj ? (key in this.groupingFields) ?\n                                this.localeObj.getConstant('groupOutOfRange') : this.localeObj.getConstant('undefined') :\n                                String(mkey)) : mkey.toString(), actualText: mkey === null ? (this.localeObj ?\n                            this.localeObj.getConstant('null') : String(mkey)) : mkey === undefined ? (this.localeObj ?\n                            (key in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :\n                                this.localeObj.getConstant('undefined') : String(mkey)) : mkey\n                    });\n                    if (!Object.prototype.hasOwnProperty.call(members, mkey)) {\n                        membersCnt++;\n                        members[mkey] = {\n                            index: [dl], ordinal: membersCnt,\n                            isDrilled: this.isExpandAll || isFieldHasExpandAll,\n                            caption: formattedValue.formattedText\n                        };\n                        dateMember.push({ formattedText: formattedValue.formattedText, actualText: isDateType ?\n                                formattedValue.dateText : formattedValue.actualText });\n                        //sort.push(mkey);\n                    }\n                    else {\n                        members[mkey].index.push(dl);\n                    }\n                }\n                var memberName = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(memberkey) ? memberkey : fList[key].type === 'number' ?\n                    (!isNaN(Number(memberkey)) ? Number(memberkey) : undefined) : 1;\n                var valueMatrixInfo = {\n                    ordinal: members[mkey].ordinal,\n                    member: memberName\n                };\n                if (!(this.valueMatrix[dl])) {\n                    this.valueMatrix[dl] = [];\n                }\n                this.valueMatrix[dl][kl] = valueMatrixInfo;\n                // }\n            }\n            fList[key].isMembersFilled = true;\n        }\n    };\n    PivotEngine.prototype.fillFieldMembers = function () {\n        var keys = this.fields;\n        var fList = this.fieldList;\n        var kLn = keys.length;\n        if (this.data.length - this.valueMatrix.length < 0) {\n            this.valueMatrix = this.valueMatrix.slice(0, this.data.length);\n        }\n        var formulaFields = new Set();\n        if (this.calculatedFormulas && Object.keys(this.calculatedFormulas).length > 0) {\n            for (var key in this.calculatedFormulas) {\n                if (fList[key] && fList[key].isSelected) {\n                    var calculatedFormulas = this.calculatedFormulas[key];\n                    for (var i = 0; i < calculatedFormulas.length; i++) {\n                        var values = calculatedFormulas[i];\n                        formulaFields.add(values.index);\n                    }\n                }\n            }\n        }\n        for (var kl = 0; kl < kLn; kl++) {\n            this.generateMembers(kl, formulaFields);\n            /*sort = Object.keys(members).sort();\n            let sortedMembers: Members = {};\n            for (let sln: number = 0, slt: number = sort.length; sln < slt; sln++) {\n                sortedMembers[sort[sln]] = members[sort[sln]];\n            }\n            fList[key].members = sortedMembers; */\n        }\n    };\n    PivotEngine.prototype.generateValueMatrix = function () {\n        var keys = this.fields;\n        var len = this.data.length;\n        var keyLen = keys.length;\n        var flList = this.fieldList;\n        while (len--) {\n            var tkln = keyLen;\n            //if (isNullOrUndefined(vMat[len as number])) {\n            //}\n            while (tkln--) {\n                var key = keys[tkln];\n                var field = flList[key];\n                if (field.isMembersFilled) {\n                    var fieldValue = this.data[len][this.fieldKeys[key]];\n                    this.valueMatrix[len][tkln].member =\n                        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(fieldValue) ? fieldValue : (field.type === 'number' ?\n                            (!isNaN(Number(fieldValue)) ? Number(fieldValue) : undefined) : 1);\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.updateSortSettings = function (sortSettings, isSort) {\n        for (var sln = 0, slt = sortSettings ? sortSettings.length : 0; sln < slt && isSort; sln++) {\n            if (this.fieldList[sortSettings[sln].name]) {\n                this.fieldList[sortSettings[sln].name].sort = sortSettings[sln].order;\n            }\n        }\n    };\n    PivotEngine.prototype.updateFilterMembers = function (source) {\n        var filterRw = this.filterMembers;\n        var list = {};\n        //let eList: {[key: string] : number} = {};\n        var isInclude = this.getFilters(source, list);\n        //this.getFilterExcludeList(source.rows, flist);\n        //this.getFilterExcludeList(source.columns, flist);\n        //this.getFilterExcludeList(source.filters, flist);\n        // let filters: Iterator = isInclude ? iList : eList;\n        var dln = this.valueMatrix.length;\n        if (isInclude) {\n            var keys = list.include.index;\n            for (var ln = 0; ln < keys.length; ln++) {\n                if (list.exclude === undefined || list.exclude.indexObject[keys[ln]] === undefined) {\n                    filterRw.push(keys[ln]);\n                }\n            }\n        }\n        else {\n            for (var ln = 0; ln < dln; ln++) {\n                if (list.exclude === undefined || list.exclude.indexObject[ln] === undefined) {\n                    filterRw.push(ln);\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.getFilters = function (source, ilist) {\n        var filterElements = source.filterSettings ? source.filterSettings : [];\n        var isInclude = false;\n        var filter = [];\n        for (var rln = 0, rlt = filterElements.length; rln < rlt; rln++) {\n            var filterElement = filterElements[rln].properties ?\n                filterElements[rln].properties : filterElements[rln];\n            if (this.fieldList[filterElement.name] &&\n                this.fieldList[filterElement.name].isSelected &&\n                this.isValidFilterField(filterElement, source.allowMemberFilter, source.allowLabelFilter)) {\n                this.applyLabelFilter(filterElement);\n                if (filterElement) {\n                    filter = filterElement.items;\n                }\n                if (filterElement.type && filterElement.type === 'Include') {\n                    this.frameFilterList(filter, filterElement.name, ilist, 'include', filterElement.showLabelFilter, isInclude);\n                    isInclude = true;\n                }\n                else {\n                    this.frameFilterList(filter, filterElement.name, ilist, 'exclude', filterElement.showLabelFilter);\n                }\n                if (filterElement.showLabelFilter) {\n                    filterElement.items = [];\n                    filterElement.type = filterElement.showDateFilter ? 'Date' : filterElement.showNumberFilter ? 'Number' : 'Label';\n                }\n            }\n        }\n        /* for (let cln: number = 0, clt: number = cols.length; cln < clt; cln ++) {\n             filter = cols[cln as number].filter ? cols[cln as number].filter.items : [];\n             if (filter.length && cols[cln as number].filter.type && cols[cln as number].filter.type === 'include') {\n                 //type = cols[cln as number].filter.type;\n                 this.frameFilterList(filter, cols[cln as number].name, ilist, 'include', isInclude);\n                 isInclude = true;\n             } else {\n                 this.frameFilterList(filter, cols[cln as number].name, ilist, 'exclude');\n             }\n         }\n         for (let vln: number = 0, vlt: number = filters.length; vln < vlt; vln ++) {\n             filter = filters[vln].filter ? filters[vln].filter.items : [];\n             if (filter.length && filters[vln].filter.type && filters[vln].filter.type === 'include') {\n                 this.frameFilterList(filter, filters[vln].name, ilist, 'include', isInclude);\n                 isInclude = true;\n             } else {\n                 this.frameFilterList(filter, filters[vln].name, ilist, 'exclude');\n             }\n         } */\n        return isInclude;\n    };\n    PivotEngine.prototype.isValidFilterField = function (filterElement, allowMemberFiltering, allowLabelFiltering) {\n        var fieldName = filterElement.name;\n        var isValidFilterElement = false;\n        var filterTypes = ['Include', 'Exclude'];\n        var dataFields = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSourceSettings.rows, null, true);\n        dataFields = dataFields.concat(this.dataSourceSettings.columns);\n        if (this.fieldList[fieldName].isSelected && allowMemberFiltering && filterTypes.indexOf(filterElement.type) >= 0) {\n            isValidFilterElement = true;\n            for (var _i = 0, _a = this.dataSourceSettings.values; _i < _a.length; _i++) {\n                var field = _a[_i];\n                if (fieldName === field.name) {\n                    isValidFilterElement = false;\n                    break;\n                }\n            }\n        }\n        else if (allowLabelFiltering) {\n            for (var _b = 0, dataFields_2 = dataFields; _b < dataFields_2.length; _b++) {\n                var field = dataFields_2[_b];\n                if (fieldName === field.name &&\n                    (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0)) {\n                    isValidFilterElement = true;\n                    break;\n                }\n            }\n        }\n        return isValidFilterElement;\n    };\n    PivotEngine.prototype.applyLabelFilter = function (filterElement) {\n        if (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0) {\n            var members = Object.keys(this.fieldList[filterElement.name].members);\n            filterElement.showLabelFilter = true;\n            if (filterElement.type === 'Label') {\n                filterElement.items = this.getLabelFilterMembers(members, filterElement.condition, filterElement.value1, filterElement.value2);\n            }\n            else if (filterElement.type === 'Date') {\n                filterElement.showDateFilter = true;\n                var date1 = typeof (filterElement.value1) === 'string' ?\n                    new Date(filterElement.value1) : filterElement.value1;\n                var date2 = typeof (filterElement.value2) === 'string' ?\n                    new Date(filterElement.value2) : filterElement.value2;\n                filterElement.items = this.getDateFilterMembers(members, filterElement.name, filterElement.condition, date1, date2);\n            }\n            else {\n                filterElement.showNumberFilter = true;\n                filterElement.items = [];\n                for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n                    var member = members_1[_i];\n                    var operand1 = this.getParsedValue(filterElement.name, filterElement.value1);\n                    var operand2 = this.getParsedValue(filterElement.name, filterElement.value2);\n                    var cValue = this.getParsedValue(filterElement.name, member);\n                    if (this.validateFilterValue(cValue, filterElement.condition, operand1, operand2)) {\n                        filterElement.items.push(member);\n                    }\n                }\n            }\n            var excludeOperators = ['DoesNotBeginWith', 'DoesNotContains', 'DoesNotEndsWith', 'DoesNotEquals', 'NotBetween'];\n            filterElement.type = (filterElement.condition ? (excludeOperators.indexOf(filterElement.condition) > -1 &&\n                !filterElement.showNumberFilter) ? 'Exclude' : 'Include' : 'Exclude');\n        }\n        else {\n            filterElement.showLabelFilter = false;\n        }\n    };\n    PivotEngine.prototype.getLabelFilterMembers = function (members, operator, value1, value2) {\n        var items = [];\n        for (var _i = 0, members_2 = members; _i < members_2.length; _i++) {\n            var member = members_2[_i];\n            var filterValue = member.toLowerCase();\n            if (value1.toString()) {\n                switch (operator) {\n                    case 'Equals':\n                    case 'DoesNotEquals':\n                        if (filterValue === value1.toLowerCase()) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'BeginWith':\n                    case 'DoesNotBeginWith':\n                        if (filterValue.indexOf(value1.toLowerCase()) === 0) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'EndsWith':\n                    case 'DoesNotEndsWith':\n                        if (filterValue.match(value1.toLowerCase() + '$') !== null) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'Contains':\n                    case 'DoesNotContains':\n                        if (filterValue.indexOf(value1.toLowerCase()) > -1) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'GreaterThan':\n                        if (filterValue > value1.toLowerCase()) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'GreaterThanOrEqualTo':\n                        if (filterValue >= value1.toLowerCase()) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'LessThan':\n                        if (filterValue < value1.toLowerCase()) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'LessThanOrEqualTo':\n                        if (filterValue <= value1.toLowerCase()) {\n                            items.push(member);\n                        }\n                        break;\n                    case 'Between':\n                    case 'NotBetween':\n                        if ((filterValue >= value1.toLowerCase()) && (filterValue <= value2.toLowerCase())) {\n                            items.push(member);\n                        }\n                        break;\n                    default:\n                        if (filterValue === value1.toLowerCase()) {\n                            items.push(member);\n                        }\n                        break;\n                }\n            }\n        }\n        return items;\n    };\n    PivotEngine.prototype.getDateFilterMembers = function (members, name, operator, value1, value2) {\n        var items = [];\n        for (var _i = 0, members_3 = members; _i < members_3.length; _i++) {\n            var member = members_3[_i];\n            var filterValue = new Date(member);\n            if (value1) {\n                switch (operator) {\n                    case 'Equals':\n                    case 'DoesNotEquals':\n                        if (this.getFormattedValue(filterValue.toString(), name).formattedText === this.getFormattedValue(value1.toString(), name).formattedText) {\n                            items.push(this.getFormattedValue(member, name).formattedText);\n                        }\n                        break;\n                    case 'After':\n                        if (filterValue.getTime() > value1.getTime()) {\n                            items.push(this.getFormattedValue(member, name).formattedText);\n                        }\n                        break;\n                    case 'AfterOrEqualTo':\n                        if (filterValue.getTime() >= value1.getTime()) {\n                            items.push(this.getFormattedValue(member, name).formattedText);\n                        }\n                        break;\n                    case 'Before':\n                        if (filterValue.getTime() < value1.getTime()) {\n                            items.push(this.getFormattedValue(member, name).formattedText);\n                        }\n                        break;\n                    case 'BeforeOrEqualTo':\n                        if (filterValue.getTime() <= value1.getTime()) {\n                            items.push(this.getFormattedValue(member, name).formattedText);\n                        }\n                        break;\n                    case 'Between':\n                    case 'NotBetween':\n                        if ((filterValue.getTime() >= value1.getTime()) &&\n                            (filterValue.getTime() <= value2.getTime())) {\n                            items.push(this.getFormattedValue(member, name).formattedText);\n                        }\n                        break;\n                    default:\n                        if (this.getFormattedValue(filterValue.toString(), name).formattedText === this.getFormattedValue(value1.toString(), name).formattedText) {\n                            items.push(this.getFormattedValue(member, name).formattedText);\n                        }\n                        break;\n                }\n            }\n        }\n        return items;\n    };\n    PivotEngine.prototype.validateFilterValue = function (val, operator, value1, value2) {\n        var isMemberInclude = false;\n        if (typeof (value1) === 'number') {\n            switch (operator) {\n                case 'Equals':\n                    if (val === value1) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                case 'DoesNotEquals':\n                    if (val !== value1) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                case 'GreaterThan':\n                    if (val > value1) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                case 'GreaterThanOrEqualTo':\n                    if (val >= value1) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                case 'LessThan':\n                    if (val < value1) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                case 'LessThanOrEqualTo':\n                    if (val <= value1) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                case 'Between':\n                    if ((val >= value1) && (val <= value2)) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                case 'NotBetween':\n                    if (!((val >= value1) && (val <= value2))) {\n                        isMemberInclude = true;\n                    }\n                    break;\n                default:\n                    if (val !== value1) {\n                        isMemberInclude = true;\n                    }\n                    break;\n            }\n        }\n        return isMemberInclude;\n    };\n    PivotEngine.prototype.frameFilterList = function (filter, name, list, type, isLabelFilter, isInclude) {\n        if (!list[type]) {\n            list[type] = { indexObject: {}, index: [] };\n            this.updateFilter(filter, name, list, type, isLabelFilter, isInclude);\n        }\n        else {\n            this.updateFilter(filter, name, list, type, isLabelFilter, isInclude);\n        }\n    };\n    PivotEngine.prototype.updateFilter = function (filter, name, list, type, isLabelFilter, isInclude) {\n        var fln = 0;\n        var field = this.fieldList[name];\n        field.filter = filter;\n        field.filterType = type;\n        field.isExcelFilter = isLabelFilter;\n        var members = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFormattedMembers(field.members, name, this);\n        var allowFil = isInclude;\n        var final = {};\n        var filterObj = {};\n        final[type] = { indexObject: {}, index: [] };\n        this.fieldFilterMem[name] = { memberObj: {} };\n        while (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(filter[fln])) {\n            if (members[filter[fln]]) {\n                var indx = members[filter[fln]].index;\n                if (type === 'include') {\n                    for (var iln = 0, ilt = indx.length; iln < ilt; iln++) {\n                        if (!allowFil || list[type].indexObject[indx[iln]] !== undefined) {\n                            final[type].indexObject[indx[iln]] = indx[iln];\n                            final[type].index.push(indx[iln]);\n                        }\n                    }\n                }\n                else {\n                    for (var iln = 0, ilt = indx.length; iln < ilt; iln++) {\n                        if (list[type].indexObject[indx[iln]] === undefined) {\n                            list[type].indexObject[indx[iln]] = indx[iln];\n                            list[type].index.push(indx[iln]);\n                        }\n                    }\n                    this.fieldFilterMem[name].memberObj[filter[fln]] = filter[fln];\n                }\n            }\n            fln++;\n        }\n        if (type === 'include') {\n            list[type] = final[type];\n            for (var iln = 0; iln < filter.length; iln++) {\n                if (members[filter[iln]]) {\n                    filterObj[filter[iln]] = filter[iln];\n                }\n            }\n            var items = Object.keys(members);\n            for (var iln = 0, ilt = items.length; iln < ilt; iln++) {\n                if (filterObj[items[iln]] === undefined) {\n                    this.fieldFilterMem[name].memberObj[items[iln]] = items[iln];\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.applyValueFiltering = function (rowData, level, rows, columns, valueFilter, rowFilterData, type) {\n        this.isValueFiltered = false;\n        var allMember = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, (type === 'row' && this.rowGrandTotal ? this.rowGrandTotal : type === 'column' && this.columnGrandTotal ? this.columnGrandTotal : (!(this.dataSourceSettings.grandTotalsPosition === 'Top') ? rows[rows.length - 1] : rows[0])), null, true);\n        this.getFilteredData(rows, columns, valueFilter, rowFilterData, level, rowData.name, allMember, type);\n        if (this.isValueFiltered) {\n            if ((type === 'row' && this.rowGrandTotal === null) || (type === 'column' && this.columnGrandTotal === null)) {\n                rowFilterData.push(allMember);\n            }\n            rows = rowFilterData;\n        }\n        return rows;\n    };\n    PivotEngine.prototype.getFilteredData = function (rows, columns, filterSettings, rowFilterData, level, fieldName, allMember, type) {\n        var rLen = rows.length;\n        for (var i = 0; i < rLen; i++) {\n            if (filterSettings[fieldName]) {\n                if (rows[i].level === level) {\n                    this.isValueFiltered = true;\n                    this.fieldList[fieldName].isExcelFilter = true;\n                    var value = 0;\n                    var measure = filterSettings[fieldName].measure;\n                    var mPos = this.fieldList[measure].index;\n                    var aggregate = this.fieldList[measure].aggregateType;\n                    this.rawIndexObject = {};\n                    value = (type === 'row' ? this.getAggregateValue(rows[i].index, columns.indexObject, mPos, aggregate, false) :\n                        this.getAggregateValue(columns.index, rows[i].indexObject, mPos, aggregate, false));\n                    var cellDetails = {\n                        fieldName: measure,\n                        row: rows[i],\n                        column: columns,\n                        value: value,\n                        cellSets: this.getValueCellInfo ? this.getCellSet(this.rawIndexObject) : [],\n                        rowCellType: (rows[i].hasChild && rows[i].isDrilled ? 'subTotal' : rows[i].type === 'grand sum' ? 'grandTotal' : 'value'),\n                        columnCellType: (columns.hasChild && columns.isDrilled ? 'subTotal' : columns.type === 'grand sum' ? 'grandTotal' : 'value'),\n                        aggregateType: aggregate,\n                        skipFormatting: false\n                    };\n                    if (this.getValueCellInfo) {\n                        this.getValueCellInfo(cellDetails);\n                    }\n                    value = cellDetails.value;\n                    this.rawIndexObject = {};\n                    var operand1 = this.getParsedValue(measure, filterSettings[fieldName].value1);\n                    var operand2 = this.getParsedValue(measure, filterSettings[fieldName].value2);\n                    if (!this.validateFilterValue(value, filterSettings[fieldName].condition, operand1, operand2) && rows[i].type !== 'grand sum') {\n                        var data = this.removefilteredData(rows[i], this.valueFilteredData);\n                        var row = data ? data : rows[i];\n                        this.validateFilteredParentData(row, this.valueFilteredData, allMember, 0, level, type);\n                    }\n                    else if (rows[i].type !== 'grand sum') {\n                        rowFilterData.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, rows[i], null, true));\n                        rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;\n                    }\n                }\n                else if (rows[i].hasChild && rows[i].members.length > 0 && rows[i].type !== 'grand sum') {\n                    rowFilterData.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, rows[i], null, true));\n                    rowFilterData[rowFilterData.length - 1].members = [];\n                    rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;\n                    this.getFilteredData(rows[i].members, columns, filterSettings, rowFilterData[rowFilterData.length - 1].members, level, fieldName, allMember, type);\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.getParsedValue = function (measure, value) {\n        var cValue = value ? value.toString() : '';\n        if (this.formatFields[measure] && value) {\n            var formatSetting = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.formatFields[measure], null, true);\n            delete formatSetting.name;\n            return this.globalize.parseNumber(cValue, formatSetting);\n        }\n        else {\n            return this.globalize.parseNumber(cValue, { format: 'N' });\n        }\n    };\n    PivotEngine.prototype.removefilteredData = function (row, rowFilterData) {\n        var rows = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], rowFilterData, null, true);\n        var filteredData;\n        for (var i = 0; i < rows.length; i++) {\n            if (row.isLevelFiltered && row.axis === rows[i].axis &&\n                row.valueSort.levelName === rows[i].valueSort.levelName &&\n                row.actualText === rows[i].actualText && row.axis === rows[i].axis &&\n                row.level === rows[i].level && row.ordinal === rows[i].ordinal) {\n                filteredData = rows[i];\n                rowFilterData.splice(i, 1);\n                break;\n            }\n            else if (rowFilterData[i].hasChild && rowFilterData[i].members.length > 0) {\n                this.removefilteredData(row, rowFilterData[i].members);\n            }\n        }\n        return filteredData;\n    };\n    PivotEngine.prototype.validateFilteredParentData = function (row, rows, allMemberData, i, level, type) {\n        if (rows.length > 0) {\n            for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {\n                var rowFilteredData = rows_1[_i];\n                if (rowFilteredData.level === i) {\n                    if (type === 'row') {\n                        var index = row.index;\n                        for (var _a = 0, index_1 = index; _a < index_1.length; _a++) {\n                            var key = index_1[_a];\n                            if (allMemberData.index.indexOf(key) >= 0) {\n                                allMemberData.index.splice(allMemberData.index.indexOf(key), 1);\n                            }\n                            if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&\n                                rowFilteredData.level !== level && rowFilteredData.index.indexOf(key) >= 0) {\n                                rowFilteredData.index.splice(rowFilteredData.index.indexOf(key), 1);\n                            }\n                        }\n                    }\n                    else {\n                        var index = row.indexObject;\n                        for (var _b = 0, _c = Object.keys(index); _b < _c.length; _b++) {\n                            var key = _c[_b];\n                            if (Object.prototype.hasOwnProperty.call(index, key)) {\n                                delete allMemberData.indexObject[key];\n                                if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&\n                                    rowFilteredData.level !== level) {\n                                    delete rowFilteredData.indexObject[key];\n                                }\n                            }\n                        }\n                    }\n                    if (rowFilteredData && rowFilteredData.members.length > 0 &&\n                        rowFilteredData.members[0].level === i + 1 && rowFilteredData.members[0].level !== level) {\n                        this.validateFilteredParentData(row, rowFilteredData.members, allMemberData, i + 1, level, type);\n                    }\n                }\n            }\n        }\n        else {\n            if (type === 'row') {\n                var index = row.index;\n                for (var _d = 0, index_2 = index; _d < index_2.length; _d++) {\n                    var key = index_2[_d];\n                    if (allMemberData.index.indexOf(key) >= 0) {\n                        allMemberData.index.splice(allMemberData.index.indexOf(key), 1);\n                    }\n                }\n            }\n            else {\n                var index = row.indexObject;\n                for (var _e = 0, _f = Object.keys(index); _e < _f.length; _e++) {\n                    var key = _f[_e];\n                    if (Object.prototype.hasOwnProperty.call(index, key)) {\n                        delete allMemberData.indexObject[key];\n                    }\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.updateFramedHeaders = function (framedHeaders, dataHeaders, filteredHeaders, headers, type) {\n        for (var _i = 0, framedHeaders_1 = framedHeaders; _i < framedHeaders_1.length; _i++) {\n            var dHeader = framedHeaders_1[_i];\n            this.isHeaderAvail = false;\n            if (this.validateFilteredHeaders(dHeader, filteredHeaders, type) || dHeader.type === 'grand sum') {\n                if (type === 'row') {\n                    this.rowCount += this.rowValuesLength;\n                }\n                else {\n                    this.columnCount += this.customProperties.isTabularLayout ? (this.rowMaxLevel + this.colValuesLength) :\n                        this.colValuesLength;\n                }\n                headers.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, dHeader, null, true));\n                headers[headers.length - 1].members = [];\n                if (dHeader.hasChild && dHeader.isDrilled && dHeader.members.length > 0) {\n                    this.updateFramedHeaders(dHeader.members, dataHeaders, filteredHeaders, headers[headers.length - 1].members, type);\n                }\n            }\n        }\n        return this.filterFramedHeaders;\n    };\n    PivotEngine.prototype.validateFilteredHeaders = function (dHeader, filteredHeaders, type) {\n        for (var _i = 0, filteredHeaders_1 = filteredHeaders; _i < filteredHeaders_1.length; _i++) {\n            var vHeader = filteredHeaders_1[_i];\n            if (!this.isHeaderAvail) {\n                if (dHeader.actualText === vHeader.actualText &&\n                    dHeader.level === vHeader.level &&\n                    dHeader.valueSort.levelName === vHeader.valueSort.levelName) {\n                    if (type === 'row') {\n                        if (vHeader.index.length > 0) {\n                            this.isHeaderAvail = true;\n                            dHeader.index = vHeader.index;\n                            return true;\n                        }\n                        else {\n                            this.isHeaderAvail = false;\n                            dHeader.index = vHeader.index;\n                            return false;\n                        }\n                    }\n                    else {\n                        if (Object.keys(vHeader.indexObject).length > 0) {\n                            this.isHeaderAvail = true;\n                            dHeader.indexObject = vHeader.indexObject;\n                            return true;\n                        }\n                        else {\n                            this.isHeaderAvail = false;\n                            dHeader.indexObject = vHeader.indexObject;\n                            return false;\n                        }\n                    }\n                }\n                else if (vHeader.hasChild && vHeader.members.length > 0 && vHeader.type !== 'grand sum') {\n                    this.validateFilteredHeaders(dHeader, vHeader.members, type);\n                }\n            }\n        }\n        return this.isHeaderAvail;\n    };\n    PivotEngine.prototype.isEmptyDataAvail = function (rowHeaders, columnHeaders) {\n        this.isEmptyData = false;\n        if (rowHeaders.length > 0 && rowHeaders[rowHeaders.length - 1].type === 'grand sum' &&\n            rowHeaders[rowHeaders.length - 1].index.length === 0) {\n            this.isEmptyData = true;\n        }\n        if (columnHeaders.length > 0 && columnHeaders[columnHeaders.length - 1].type === 'grand sum' &&\n            Object.keys(columnHeaders[columnHeaders.length - 1].indexObject).length === 0) {\n            this.isEmptyData = true;\n        }\n        if (rowHeaders.length === 0 || columnHeaders.length === 0) {\n            this.isEmptyData = true;\n        }\n    };\n    /**\n     * It is used to update the grid data.\n     *\n     * @param {IDataOptions} dataSource -  It contains the dataSourceSettings.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.updateGridData = function (dataSource) {\n        this.updateDataSourceSettings(dataSource, true);\n        this.data = dataSource.dataSource;\n        if (this.allowDataCompression) {\n            this.actualData = this.data;\n            this.data = this.getGroupedRawData(dataSource);\n        }\n        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {\n            var field = _a[_i];\n            this.fieldList[field].members = {};\n            this.fieldList[field].dateMember = [];\n            this.fieldList[field].isMembersFilled = false;\n        }\n        this.fillFieldMembers();\n        this.filterMembers = [];\n        this.cMembers = [];\n        this.rMembers = [];\n        this.updateFilterMembers(dataSource);\n        this.isEditing = true;\n        this.isDrillThrough = true;\n        this.generateGridData(dataSource);\n        this.isEditing = false;\n    };\n    PivotEngine.prototype.generateGridData = function (dataSource, requireDatasourceUpdate, isExport, headerCollection) {\n        if (requireDatasourceUpdate === void 0) { requireDatasourceUpdate = false; }\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(headerCollection) && this.customProperties.isTabularLayout) {\n            this.rowMaxLevel = 0;\n        }\n        this.updateDataSourceSettings(dataSource, requireDatasourceUpdate);\n        var columns = dataSource.columns ? dataSource.columns : [];\n        var data = this.data;\n        var rows = dataSource.rows ? dataSource.rows : [];\n        var filterSettings = dataSource.filterSettings;\n        var values = dataSource.values ? dataSource.values : [];\n        this.removeCount = 0;\n        this.isExpandAll = dataSource.expandAll;\n        this.drilledMembers = dataSource.drilledMembers ? dataSource.drilledMembers : [];\n        this.isEmptyData = false;\n        var filterMembers = [];\n        var showNoDataItems = (rows[0] && rows[0].showNoDataItems) || (columns[0] && columns[0].showNoDataItems);\n        // let dataFields: IFieldOptions[] = extend([], this.dataSourceSettings.rows, null, true) as IFieldOptions[];\n        // dataFields = dataFields.concat(this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters);\n        if (showNoDataItems) {\n            for (var ln = 0; ln < this.valueMatrix.length; ln++) {\n                filterMembers.push(ln);\n            }\n        }\n        for (var ln = 0; ln < this.filterMembers.length; ln++) {\n            this.filterPosObj[this.filterMembers[ln]] = this.filterMembers[ln];\n        }\n        //let childrens: Field = this.fieldList[rows[0].name + ''];\n        this.valueSortSettings.columnIndex = undefined;\n        this.validateValueFields();\n        this.frameDrillObject();\n        if (!this.isValueFilterEnabled || this.isEditing) {\n            if (!headerCollection) {\n                this.isLastHeaderHasMeasures = true;\n                this.columnCount = 0;\n                this.rowCount = 0;\n                this.cMembers = [];\n                this.rMembers = [];\n                if (rows.length !== 0 && values.length !== 0) {\n                    this.rMembers = this.getIndexedHeaders(rows, data, this.customProperties.isTabularLayout ? this.rowMaxLevel : 0, rows[0].showNoDataItems ? filterMembers :\n                        this.filterMembers, 'row', '', this.allowValueFilter);\n                }\n                if (columns.length !== 0 && values.length !== 0) {\n                    this.cMembers = this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ? filterMembers : this.filterMembers, 'column', '', this.allowValueFilter);\n                }\n                this.insertAllMembersCommon();\n                this.saveDataHeaders = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? {\n                    rowHeaders: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.rMembers, null, true),\n                    columnHeaders: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.cMembers, null, true)\n                } : {};\n            }\n        }\n        if (this.customProperties.isTabularLayout) {\n            this.showSubTotalsAtBottom = true;\n        }\n        this.pivotValues = [];\n        this.headerContent = [];\n        this.valueContent = [];\n        this.valueFilteredData = [];\n        this.filterFramedHeaders = [];\n        var rowheads = [];\n        var colheads = [];\n        var rowFilteredData = [];\n        var columnFilteredData = [];\n        var updatedRowMembers = [];\n        var valuesCount = (this.dataSourceSettings.values.length);\n        if (this.isValueFiltersAvail && dataSource.allowValueFilter && !headerCollection) {\n            this.valueFilteredData = [];\n            var rowHeaders = this.saveDataHeaders.rowHeaders ? this.saveDataHeaders.rowHeaders : [];\n            var columnHeaders = this.saveDataHeaders.columnHeaders ? this.saveDataHeaders.columnHeaders : [];\n            if (filterSettings.length > 0) {\n                var valueFilters = {};\n                var valueFields = {};\n                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                    var value = values_1[_i];\n                    valueFields[value.name] = value;\n                }\n                for (var _a = 0, filterSettings_1 = filterSettings; _a < filterSettings_1.length; _a++) {\n                    var filter = filterSettings_1[_a];\n                    rowHeaders = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);\n                    columnHeaders = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);\n                    this.valueFilteredData = [];\n                    var filterElement = filter.properties ?\n                        filter.properties : filter;\n                    if (filterElement.type === 'Value' && this.fieldList[filter.name] && this.fieldList[filter.name].isSelected) {\n                        valueFilters[filter.name] = filter;\n                        filterElement.items = [];\n                        var isAvail = false;\n                        var rLen = rows.length;\n                        var cLen = columns.length;\n                        for (var i = 0; i < rLen; i++) {\n                            if (filterElement.name === rows[i].name && valueFields[filterElement.measure] && !isAvail) {\n                                isAvail = true;\n                                rowFilteredData = this.applyValueFiltering(rows[i], i, rowHeaders, (this.columnGrandTotal ? this.columnGrandTotal : (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals) ? columnHeaders[0] : columnHeaders[columnHeaders.length - 1]), valueFilters, this.valueFilteredData, 'row');\n                                break;\n                            }\n                        }\n                        for (var j = 0; j < cLen; j++) {\n                            if (filterElement.name === columns[j].name && valueFields[filterElement.measure] && !isAvail) {\n                                isAvail = true;\n                                columnFilteredData = this.applyValueFiltering(columns[j], j, columnHeaders, (this.rowGrandTotal ? this.rowGrandTotal : (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals) ? rowHeaders[0] : rowHeaders[rowHeaders.length - 1]), valueFilters, this.valueFilteredData, 'column');\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            rowFilteredData = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);\n            columnFilteredData = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);\n            this.isEmptyDataAvail(rowFilteredData, columnFilteredData);\n            var savedFieldList = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getClonedFieldList(this.fieldList);\n            var fields = this.data[0];\n            this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);\n            this.fillFieldMembers();\n            this.updateSortSettings(dataSource.sortSettings, this.enableSort);\n            this.filterMembers = [];\n            this.updateFilterMembers(dataSource);\n            this.isLastHeaderHasMeasures = true;\n            this.rMembers = rows.length !== 0 ?\n                this.getIndexedHeaders(rows, data, 0, rows[0].showNoDataItems ?\n                    filterMembers : this.filterMembers, 'row', '') : [];\n            this.cMembers = columns.length !== 0 ?\n                this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ?\n                    filterMembers : this.filterMembers, 'column', '') : [];\n            this.insertAllMembersCommon();\n            this.updateFieldList(savedFieldList);\n            this.rowCount = 0;\n            this.columnCount = 0;\n            this.rMembers = this.updateFramedHeaders(this.rMembers, this.rMembers, rowFilteredData, this.filterFramedHeaders, 'row');\n            this.filterFramedHeaders = [];\n            this.cMembers = this.updateFramedHeaders(this.cMembers, this.cMembers, columnFilteredData, this.filterFramedHeaders, 'column');\n            this.isValueFilterEnabled = true;\n        }\n        if (!headerCollection) {\n            this.applyValueSorting();\n        }\n        if (this.isPagingOrVirtualizationEnabled) {\n            if (!headerCollection) {\n                this.headerCollection.rowHeaders = this.rMembers;\n                this.headerCollection.columnHeaders = this.cMembers;\n                this.headerCollection.rowHeadersCount = this.rowCount;\n                this.headerCollection.columnHeadersCount = this.columnCount;\n            }\n            else {\n                this.rMembers = headerCollection.rowHeaders;\n                this.cMembers = headerCollection.columnHeaders;\n                this.rowCount = this.customProperties.isTabularLayout ? this.rowCount + this.emptyRowsLength :\n                    headerCollection.rowHeadersCount;\n                this.columnCount = headerCollection.columnHeadersCount;\n            }\n            this.calculatePagingValues();\n        }\n        if (!this.valueAxis && this.isLastHeaderHasMeasures) {\n            this.getAggregatedHeaders(rows, columns, this.rMembers, this.cMembers, values);\n        }\n        this.getHeaderData(rows, columns, values, updatedRowMembers, this.cMembers, colheads, this.pivotValues, 0, this.valueAxis ? 1 : valuesCount);\n        this.insertSubTotals();\n        this.getTableData((updatedRowMembers.length > 0 ? updatedRowMembers : this.rMembers), rowheads, colheads, 0, this.pivotValues, valuesCount, 0, (this.rowGrandTotal ? this.rowGrandTotal :\n            this.rMembers[this.rMembers.length - 1]), (this.columnGrandTotal ? this.columnGrandTotal :\n            this.cMembers[this.cMembers.length - 1]));\n        this.applyAdvancedAggregate(rowheads, colheads, this.pivotValues);\n        if (this.customProperties.isTabularLayout) {\n            this.pivotValues = this.getTabularPivotValues(requireDatasourceUpdate, dataSource);\n            this.setRowSpan();\n            this.rowCount = this.rowCount - this.emptyRowsLength;\n        }\n        this.isEngineUpdated = true;\n        this.isEmptyDataAvail(this.rMembers, this.cMembers);\n        //  console.log(st1 - st2);\n        this.clearProperties(isExport);\n    };\n    PivotEngine.prototype.updateHeaders = function (rowFlag, columnFlag) {\n        /* removing the row grant-total members */\n        rowFlag = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rowFlag) ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) ?\n            true : (this.dataSourceSettings.rows.length > 0) ? false : true : rowFlag);\n        if (((this.pageSettings && (this.removeRowGrandTotal)) || (!rowFlag && !this.rowGrandTotal)) &&\n            this.rMembers[this.rMembers.length - 1].type === 'grand sum') {\n            this.rMembers = this.rMembers.slice(0, this.rMembers.length - 1);\n        }\n        /* removing the column gran-total members */\n        columnFlag = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(columnFlag) ? (this.dataSourceSettings.showGrandTotals &&\n            this.dataSourceSettings.showColumnGrandTotals) ? true : (this.dataSourceSettings.columns.length > 0) ? false : true :\n            columnFlag);\n        if (((this.pageSettings && (this.removeColumnGrandTotal)) || (!columnFlag && !this.columnGrandTotal)) &&\n            this.cMembers[this.cMembers.length - 1].type === 'grand sum') {\n            this.cMembers = this.cMembers.slice(0, this.cMembers.length - 1);\n        }\n    };\n    PivotEngine.prototype.updatePivotValues = function (updateHeaders) {\n        var rowFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) ?\n            true : (this.dataSourceSettings.rows.length > 0) ? false : true;\n        var columnFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) ?\n            true : (this.dataSourceSettings.columns.length > 0) ? false : true;\n        if (updateHeaders) {\n            this.updateHeaders(rowFlag, columnFlag);\n        }\n        /* removing the row grant-totals */\n        if (((this.pageSettings && (this.removeRowGrandTotal)) ||\n            (!rowFlag && !this.rowGrandTotal)) && this.valueContent.length > 0) {\n            var slicePos = 1;\n            if (this.valueAxis && this.dataSourceSettings.values.length > 0) {\n                slicePos = 1 + this.dataSourceSettings.values.length;\n            }\n            if (this.pivotValues[this.pivotValues.length - slicePos] &&\n                this.pivotValues[this.pivotValues.length - slicePos][0].type === 'grand sum') {\n                this.pivotValues = this.pivotValues.slice(0, this.pivotValues.length - slicePos);\n                this.valueContent = this.valueContent.slice(0, this.valueContent.length - slicePos);\n            }\n        }\n        /* removing the column gran-totals */\n        if (((this.pageSettings && (this.removeColumnGrandTotal)) ||\n            (!columnFlag && !this.columnGrandTotal)) && this.headerContent.length > 0) {\n            var slicePos = this.dataSourceSettings.values.length;\n            if (this.valueAxis && this.dataSourceSettings.values.length > 0) {\n                slicePos = 1;\n            }\n            if (this.pivotValues[0][this.pivotValues[0].length - slicePos] &&\n                this.pivotValues[0][this.pivotValues[0].length - slicePos].type === 'grand sum') {\n                for (var ln = 0; ln < this.pivotValues.length; ln++) {\n                    if (this.pivotValues[ln]) {\n                        this.pivotValues[ln] =\n                            this.pivotValues[ln].slice(0, this.pivotValues[ln].length - slicePos);\n                    }\n                    if (this.headerContent[ln]) {\n                        for (var pos = this.pivotValues[ln].length; pos < (this.pivotValues[ln].length + slicePos); pos++) {\n                            delete this.headerContent[ln][pos];\n                        }\n                    }\n                }\n            }\n        }\n        this.removeRowGrandTotal = this.removeColumnGrandTotal = false;\n    };\n    /**\n     * It performs the updateing Engine by the drilled item.\n     *\n     * @param {IDrilledItem} drilledItem -  It cotains the drilled items.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.onDrill = function (drilledItem) {\n        if (!this.enableVirtualization && !this.enablePaging && this.customProperties.isTabularLayout) {\n            this.rowMaxLevel = 0;\n        }\n        this.frameDrillObject(drilledItem);\n        var headersInfo = this.getHeadersInfo(drilledItem.fieldName, drilledItem.axis);\n        this.performDrillOperation(headersInfo.headers, drilledItem, headersInfo.fields, headersInfo.position, 0);\n        this.headerCollection.rowHeadersCount = this.rowCount;\n        this.headerCollection.columnHeadersCount = this.columnCount;\n        if (headersInfo.axis === 'row') {\n            this.headerCollection.rowHeaders = headersInfo.headers;\n        }\n        else {\n            this.headerCollection.columnHeaders = headersInfo.headers;\n        }\n        this.updateEngine();\n    };\n    /**\n     * It performs to update the engine by sorting data.\n     *\n     * @param {ISort} sortItem - It cotains the drilled item data.\n     * @param {IDataOptions} dataSource - It contains dataSource.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.onSort = function (sortItem, dataSource) {\n        if (dataSource) {\n            this.updateDataSourceSettings(dataSource, true);\n        }\n        var headersInfo = this.getHeadersInfo(sortItem.name, '');\n        this.fieldList[sortItem.name].sort = sortItem.order;\n        this.performSortOperation(headersInfo.headers, sortItem, headersInfo, 0);\n        this.updateEngine();\n    };\n    /**\n     * It performs to update the engine by filtering data.\n     *\n     * @param {IFilter} filterItem - It contains the value of filter Item.\n     * @param {IDataOptions} dataSource - It contains dataSource.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.onFilter = function (filterItem, dataSource) {\n        this.updateDataSourceSettings(dataSource, true);\n        var headersInfo = this.getHeadersInfo(filterItem.name, '');\n        this.isLastHeaderHasMeasures = (this.valueAxis && headersInfo.axis === 'row') ||\n            (!this.valueAxis && headersInfo.axis === 'column') ? true : this.isLastHeaderHasMeasures;\n        if (filterItem.type === 'Include' && filterItem.items.length === this.fieldList[filterItem.name].dateMember.length) {\n            this.fieldList[filterItem.name].filter = [];\n            this.fieldList[filterItem.name].filterType = '';\n        }\n        else {\n            this.fieldList[filterItem.name].filter = filterItem.items;\n            this.fieldList[filterItem.name].filterType = filterItem.type;\n        }\n        var posObj = {};\n        for (var _i = 0, _a = this.filterMembers; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            posObj[pos] = pos;\n        }\n        this.filterMembers = [];\n        this.fieldFilterMem = {};\n        this.updateFilterMembers(dataSource);\n        var addPos = this.filterMembers.filter(function (pos) { return posObj[pos] === undefined; });\n        var itemsObj = {};\n        for (var _b = 0, _c = filterItem.items; _b < _c.length; _b++) {\n            var item = _c[_b];\n            itemsObj[item] = item;\n        }\n        var showNoDataItems = (this.dataSourceSettings.rows[0] && this.dataSourceSettings.rows[0].showNoDataItems) || (this.dataSourceSettings.columns[0] && this.dataSourceSettings.columns[0].showNoDataItems);\n        if (showNoDataItems && this.columnKeys[filterItem.name]) {\n            showNoDataItems = (this.dataSourceSettings.columns[0] && this.dataSourceSettings.columns[0].showNoDataItems) ? true : false;\n        }\n        else if (showNoDataItems && headersInfo.axis === 'row') {\n            showNoDataItems = (this.dataSourceSettings.rows[0] && this.dataSourceSettings.rows[0].showNoDataItems) ? true : false;\n        }\n        if (showNoDataItems) {\n            var filterMembers = [];\n            this.filterPosObj = {};\n            for (var ln = 0; ln < addPos.length; ln++) {\n                this.filterPosObj[addPos[ln]] = addPos[ln];\n            }\n            for (var ln = 0; ln < this.valueMatrix.length; ln++) {\n                filterMembers.push(ln);\n            }\n            addPos = filterMembers;\n        }\n        this.performFilterCommonUpdate(filterItem, headersInfo, addPos);\n        if (headersInfo.axis === 'column') {\n            headersInfo = this.getHeadersInfo('', 'row');\n            this.performFilterCommonUpdate(filterItem, headersInfo, addPos);\n        }\n        else {\n            headersInfo = this.getHeadersInfo('', 'column');\n            this.performFilterCommonUpdate(filterItem, headersInfo, addPos);\n        }\n        this.frameHeaderObjectsCollection = false;\n        this.headerObjectsCollection = {};\n        if (this.customProperties.isTabularLayout) {\n            this.rowCount = this.rowCount - this.emptyRowsLength;\n        }\n        this.updateEngine();\n    };\n    /**\n     * It performs to update the engine by the aggregation.\n     *\n     * @param {IFieldOptions} field -  It cotains the field data.\n     * @param {IDataOptions} dataSource - It contains dataSource.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.onAggregation = function (field, dataSource) {\n        if (dataSource) {\n            this.updateDataSourceSettings(dataSource, true);\n        }\n        this.fieldList[field.name].aggregateType = field.type;\n        this.rMembers = this.headerCollection.rowHeaders;\n        this.cMembers = this.headerCollection.columnHeaders;\n        if (this.allowDataCompression) {\n            this.data = this.getGroupedRawData(this.dataSourceSettings);\n            this.generateValueMatrix();\n        }\n        this.updateEngine();\n    };\n    /**\n     * It performs to update the engine by the calculated field operation.\n     *\n     * @param {ICalculatedFields} field -  It cotains the Calculated Fields.\n     * @param {IDataOptions} dataSourceSettings -  It cotains the dataSourceSettings.\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.onCalcOperation = function (field, dataSourceSettings) {\n        this.dataSourceSettings.calculatedFieldSettings = dataSourceSettings.calculatedFieldSettings ?\n            dataSourceSettings.calculatedFieldSettings : [];\n        this.dataSourceSettings.values = dataSourceSettings.values ? dataSourceSettings.values : [];\n        this.rMembers = this.headerCollection.rowHeaders;\n        this.cMembers = this.headerCollection.columnHeaders;\n        this.getCalculatedField(this.fields);\n        if (this.fieldList[field.name]) {\n            this.fieldList[field.name].formula = field.formula;\n        }\n        else {\n            this.fieldList[field.name] = {\n                id: field.name,\n                caption: field.name,\n                type: 'number',\n                aggregateType: 'CalculatedField',\n                filterType: '',\n                index: this.fields.length - 1,\n                filter: [],\n                sort: this.enableSort ? 'Ascending' : 'None',\n                isSelected: true,\n                isExcelFilter: false,\n                formula: field.formula\n            };\n            if (this.valueAxis === 1) {\n                this.headerCollection.rowHeadersCount = this.rowCount = (this.rowCount / (this.dataSourceSettings.values.length - 1)) * this.dataSourceSettings.values.length;\n            }\n            else {\n                this.headerCollection.columnHeadersCount = this.columnCount = (this.columnCount / (this.dataSourceSettings.values.length - 1)) * this.dataSourceSettings.values.length;\n            }\n        }\n        this.getFormattedFields(dataSourceSettings);\n        this.fillFieldMembers();\n        this.updateEngine();\n    };\n    PivotEngine.prototype.performDrillOperation = function (headers, drilledItem, fields, position, currentPosition) {\n        var count = 0;\n        while (count < headers.length) {\n            if (position === currentPosition) {\n                var levelName = headers[count].valueSort.levelName.split(this.valueSortSettings.headerDelimiter);\n                if (drilledItem.memberName === levelName.join(drilledItem.delimiter ? drilledItem.delimiter : '**')) {\n                    if (drilledItem.action === 'down') {\n                        headers[count].isDrilled = true;\n                        headers[count].members = this.getIndexedHeaders(fields, this.data, position + 1, headers[count].index, drilledItem.axis, drilledItem.memberName.\n                            split(drilledItem.delimiter ? drilledItem.delimiter : '**').join(this.valueSortSettings.headerDelimiter));\n                        var sortedHeaders = void 0;\n                        if (drilledItem.axis === 'row') {\n                            sortedHeaders = this.applyValueSorting(headers[count].members, this.cMembers);\n                            headers[count].members = sortedHeaders.rMembers;\n                            this.rowCount += (this.showSubTotalsAtBottom ? 1 : 0);\n                        }\n                        else {\n                            var showSubTotals = this.dataSourceSettings.showSubTotals &&\n                                this.dataSourceSettings.showColumnSubTotals && fields[position].showSubTotals;\n                            this.columnCount -= !showSubTotals ? this.colValuesLength : 0;\n                            sortedHeaders = this.applyValueSorting(this.rMembers, headers[count].members);\n                            headers[count].members = sortedHeaders.cMembers;\n                        }\n                    }\n                    else {\n                        headers[count].isDrilled = false;\n                        this.updateHeadersCount(headers[count].members, drilledItem.axis, position, fields, 'minus', true);\n                        headers[count].members = [];\n                        if (drilledItem.axis === 'row') {\n                            this.rowCount -= (this.showSubTotalsAtBottom ? 1 : 0);\n                        }\n                    }\n                    break;\n                }\n            }\n            else if (headers[count].members.length > 0) {\n                headers[count].members = this.performDrillOperation(headers[count].members, drilledItem, fields, position, currentPosition + 1);\n            }\n            count++;\n        }\n        return headers;\n    };\n    PivotEngine.prototype.performSortOperation = function (headers, sortItem, headersInfo, currentPosition) {\n        var count = 0;\n        while (count < headers.length) {\n            if (headersInfo.position === currentPosition) {\n                headers = this.getSortedHeaders(headers, sortItem.order.toString());\n                break;\n            }\n            else if (headers[count].members.length > 0) {\n                headers[count].members =\n                    this.performSortOperation(headers[count].members, sortItem, headersInfo, currentPosition + 1);\n            }\n            count++;\n        }\n        return headers;\n    };\n    PivotEngine.prototype.performFilterDeletion = function (headers, filterItem, headersInfo, filterObjects, currentPosition) {\n        var count = 0;\n        var loopIn = true;\n        var _loop_4 = function () {\n            if (headersInfo.position === currentPosition) {\n                var engine_1 = this_4;\n                headers = headers.filter(function (item) {\n                    return engine_1.fieldFilterMem[filterItem.name].memberObj[item.formattedText] === '' ? false :\n                        !engine_1.fieldFilterMem[filterItem.name].memberObj[item.formattedText] || item.type === 'grand sum';\n                });\n                loopIn = false;\n            }\n            else if (headers[count].members.length > 0) {\n                headers[count].members = this_4.performFilterDeletion(headers[count].members, filterItem, headersInfo, filterObjects, currentPosition + 1);\n            }\n            count++;\n        };\n        var this_4 = this;\n        while (count < headers.length && loopIn) {\n            _loop_4();\n        }\n        var engine = this;\n        return headers.filter(function (item) {\n            return (item.members.length > 0 || item.type === 'grand sum') ? true : engine.matchIndexes(item.indexObject, filterObjects);\n        });\n    };\n    PivotEngine.prototype.matchIndexes = function (index, filterObjects) {\n        var keys = Object.keys(index);\n        var len = keys.length;\n        if (len === 0) {\n            return true;\n        }\n        while (len > -1) {\n            if (filterObjects[index[keys[len]]] !== undefined) {\n                return true;\n            }\n            len--;\n        }\n        return false;\n    };\n    PivotEngine.prototype.performFilterAddition = function (headers, fields, headersInfo) {\n        var count = 0;\n        var _loop_5 = function () {\n            var levelName = headers[count].valueSort.levelName;\n            if (this_5.headerObjectsCollection[levelName]) {\n                var memberNameObj_1 = {};\n                for (var _i = 0, _a = headers[count].members; _i < _a.length; _i++) {\n                    var member = _a[_i];\n                    memberNameObj_1[member.valueSort.levelName.toString()] = member.valueSort.levelName.toString();\n                }\n                var excessHeaders = this_5.headerObjectsCollection[levelName].filter(function (member) {\n                    return !memberNameObj_1[member.valueSort.levelName.toString()];\n                });\n                headers[count].members = headers[count].members.concat(excessHeaders);\n                headers[count].members = this_5.getSortedHeaders(headers[count].members, this_5.fieldList[headersInfo.fields[headers[count].members[0].level].name].sort);\n                delete this_5.headerObjectsCollection[levelName];\n            }\n            if (headers[count].members.length > 0) {\n                headers[count].members = this_5.performFilterAddition(headers[count].members, fields, headersInfo);\n            }\n            count++;\n        };\n        var this_5 = this;\n        while (count < headers.length) {\n            _loop_5();\n        }\n        return headers;\n    };\n    PivotEngine.prototype.performFilterCommonUpdate = function (filterItem, headersInfo, addPos) {\n        if (headersInfo.axis === 'row' || headersInfo.axis === 'column') {\n            var rawHeaders = headersInfo.axis === 'row' ? this.rMembers : this.cMembers;\n            var filterObjects = {};\n            for (var _i = 0, _a = this.filterMembers; _i < _a.length; _i++) {\n                var item = _a[_i];\n                filterObjects[item] = item;\n            }\n            if (this.fieldFilterMem[filterItem.name]) {\n                rawHeaders = this.performFilterDeletion(headersInfo.headers, filterItem, headersInfo, filterObjects, 0);\n            }\n            if (addPos.length > 0 && headersInfo.fields.length > 0) {\n                this.frameHeaderObjectsCollection = true;\n                if (headersInfo.fields.filter(function (item) { return item.showNoDataItems; }).length > 0) {\n                    for (var i = 0; i < this.data.length; i++) {\n                        addPos.push(i);\n                    }\n                }\n                this.headerObjectsCollection['parent'] = this.getIndexedHeaders(headersInfo.fields, this.data, 0, addPos, headersInfo.axis, '');\n                rawHeaders = this.performFilterAddition(rawHeaders, headersInfo.fields, headersInfo);\n                var headerNames_1 = {};\n                for (var _b = 0, rawHeaders_1 = rawHeaders; _b < rawHeaders_1.length; _b++) {\n                    var header = rawHeaders_1[_b];\n                    headerNames_1[header.valueSort.levelName.toString()] = header.valueSort.levelName.toString();\n                }\n                var excessHeaders = this.headerObjectsCollection['parent'].filter(function (header) {\n                    return !headerNames_1[header.valueSort.levelName.toString()];\n                });\n                var grandHeader = rawHeaders.filter(function (item) { return item.type === 'grand sum'; });\n                if (grandHeader.length > 0) {\n                    rawHeaders.pop();\n                }\n                rawHeaders = this.getSortedHeaders(rawHeaders.concat(excessHeaders), this.fieldList[headersInfo.fields[0].name].sort).concat(grandHeader);\n                if (headersInfo.axis === 'row') {\n                    this.cMembers = this.getIndexedHeaders(this.dataSourceSettings.columns, this.data, 0, this.filterMembers, 'column', '');\n                    this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');\n                }\n                else {\n                    this.rMembers = this.getIndexedHeaders(this.dataSourceSettings.rows, this.data, 0, this.filterMembers, 'row', '');\n                    this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');\n                }\n            }\n            if (headersInfo.axis === 'row') {\n                this.rowCount = 0;\n            }\n            else {\n                this.columnCount = 0;\n            }\n            this.updateHeadersCount(rawHeaders, headersInfo.axis, 0, headersInfo.fields, 'plus', false);\n            if (headersInfo.axis === 'row') {\n                if (headersInfo.position > 0) {\n                    this.insertPosition(this.dataSourceSettings.rows, this.data, 0, this.filterMembers, 'row', '', rawHeaders);\n                }\n                this.insertTotalPosition(rawHeaders);\n                this.rMembers = this.headerCollection.rowHeaders = rawHeaders;\n                this.headerCollection.rowHeadersCount = this.rowCount;\n            }\n            else {\n                if (headersInfo.position > 0) {\n                    this.insertPosition(this.dataSourceSettings.columns, this.data, 0, this.filterMembers, 'column', '', rawHeaders);\n                }\n                this.insertTotalPosition(rawHeaders);\n                this.cMembers = this.headerCollection.columnHeaders = rawHeaders;\n                this.headerCollection.columnHeadersCount = this.columnCount;\n            }\n        }\n        else {\n            var showNoDataItems = (this.dataSourceSettings.rows[0] && this.dataSourceSettings.rows[0].showNoDataItems) || (this.dataSourceSettings.columns[0] && this.dataSourceSettings.columns[0].showNoDataItems);\n            this.rMembers = this.getIndexedHeaders(this.dataSourceSettings.rows, this.data, 0, showNoDataItems ? addPos : this.filterMembers, 'row', '');\n            this.cMembers = this.getIndexedHeaders(this.dataSourceSettings.columns, this.data, 0, showNoDataItems ? addPos : this.filterMembers, 'column', '');\n            this.insertAllMembersCommon();\n            this.rowCount = 0;\n            this.columnCount = 0;\n            this.updateHeadersCount(this.cMembers, 'column', 0, this.dataSourceSettings.columns, 'plus', false);\n            this.updateHeadersCount(this.rMembers, 'row', 0, this.dataSourceSettings.rows, 'plus', false);\n            if (showNoDataItems) {\n                this.insertPosition(this.dataSourceSettings.rows, this.data, 0, this.filterMembers, 'row', '', this.rMembers);\n                this.insertPosition(this.dataSourceSettings.columns, this.data, 0, this.filterMembers, 'column', '', this.cMembers);\n            }\n            this.headerCollection.rowHeaders = this.rMembers;\n            this.headerCollection.rowHeadersCount = this.rowCount;\n            this.headerCollection.columnHeaders = this.cMembers;\n            this.headerCollection.columnHeadersCount = this.columnCount;\n        }\n        this.applyValueSorting();\n    };\n    PivotEngine.prototype.getHeadersInfo = function (fieldName, axis) {\n        this.rMembers = this.headerCollection.rowHeaders;\n        this.cMembers = this.headerCollection.columnHeaders;\n        axis = axis === '' ? this.getAxisByFieldName(fieldName) : axis;\n        var headers = axis === 'row' ? this.rMembers : this.cMembers;\n        var fields = axis === 'row' ? this.dataSourceSettings.rows : this.dataSourceSettings.columns;\n        var position = 0;\n        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n            var field = fields_1[_i];\n            if (field.name === fieldName) {\n                break;\n            }\n            position++;\n        }\n        return { axis: axis, fields: fields, headers: headers, position: position };\n    };\n    /**\n     * It performs the updating engine.\n     *\n     * @returns {void}\n     * @hidden\n     */\n    PivotEngine.prototype.updateEngine = function () {\n        if (this.customProperties.isTabularLayout) {\n            this.rowCount = this.rowCount + this.emptyRowsLength;\n        }\n        this.removeCount = 0;\n        this.validateValueFields();\n        this.calculatePagingValues();\n        this.pivotValues = [];\n        this.headerContent = [];\n        this.valueContent = [];\n        var rowheads = [];\n        var colheads = [];\n        var updatedRowMembers = [];\n        var valuesCount = (this.dataSourceSettings.values.length);\n        this.frameDrillObject();\n        this.getAggregatedHeaders(this.dataSourceSettings.rows, this.dataSourceSettings.columns, this.rMembers, this.cMembers, this.dataSourceSettings.values);\n        this.getHeaderData(this.dataSourceSettings.rows, this.dataSourceSettings.columns, this.dataSourceSettings.values, updatedRowMembers, this.cMembers, colheads, this.pivotValues, 0, this.valueAxis ? 1 : valuesCount);\n        this.insertSubTotals();\n        this.getTableData((updatedRowMembers.length > 0 ? updatedRowMembers : this.rMembers), rowheads, colheads, 0, this.pivotValues, valuesCount, 0, (this.rowGrandTotal ? this.rowGrandTotal : this.rMembers[this.rMembers.length - 1]), (this.columnGrandTotal ? this.columnGrandTotal : this.cMembers[this.cMembers.length - 1]));\n        this.applyAdvancedAggregate(rowheads, colheads, this.pivotValues);\n        if (this.customProperties.isTabularLayout) {\n            this.pivotValues = this.getTabularPivotValues();\n            this.setRowSpan();\n            this.rowCount = this.rowCount - this.emptyRowsLength;\n        }\n        this.isEngineUpdated = true;\n        this.isEmptyDataAvail(this.rMembers, this.cMembers);\n    };\n    PivotEngine.prototype.getAxisByFieldName = function (fieldName) {\n        var axisCount = 0;\n        var axis = '';\n        while (axisCount < 4 && axis === '') {\n            switch (axisCount) {\n                case 0:\n                    axis = this.getFieldByName(fieldName, this.dataSourceSettings.rows) ? 'row' : '';\n                    break;\n                case 1:\n                    axis = this.getFieldByName(fieldName, this.dataSourceSettings.columns) ? 'column' : '';\n                    break;\n            }\n            axisCount++;\n        }\n        return axis;\n    };\n    PivotEngine.prototype.getFieldByName = function (fieldName, fields) {\n        return new _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__.DataManager({ json: fields }).executeLocal(new _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__.Query().where('name', 'equal', fieldName))[0];\n    };\n    PivotEngine.prototype.updateHeadersCount = function (headers, axis, position, fields, action, isDrill) {\n        var lenCnt = 0;\n        var field = fields[position];\n        var showSubTotals = true;\n        if (axis === 'column') {\n            showSubTotals = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals &&\n                (field ? field.showSubTotals : true);\n        }\n        else {\n            showSubTotals = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showRowSubTotals &&\n                (field ? field.showSubTotals : true);\n        }\n        while (lenCnt < headers.length) {\n            if (axis === 'row') {\n                this.rowCount = this.rowCount - (action === 'plus' ? -(this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1) :\n                    (this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1));\n            }\n            else {\n                this.columnCount = this.columnCount - (action === 'plus' ? -(this.valueAxis === 1 ? 1 : this.dataSourceSettings.values.length) :\n                    (this.valueAxis === 1 ? 1 : this.dataSourceSettings.values.length));\n            }\n            if (headers[lenCnt].members.length > 0) {\n                this.updateHeadersCount(headers[lenCnt].members, axis, position + 1, fields, action, true);\n                if (axis === 'row') {\n                    this.rowCount -= this.showSubTotalsAtBottom && headers[lenCnt].hasChild && headers[lenCnt].isDrilled ? 1 : 0;\n                }\n            }\n            lenCnt++;\n        }\n        if (axis === 'column' && !showSubTotals && isDrill) {\n            this.columnCount += action === 'plus' ? -this.colValuesLength : this.colValuesLength;\n        }\n    };\n    /**\n     * It performs to retrieve the sorted headers.\n     *\n     * @param {IAxisSet[]} headers - It cotains the headers data.\n     * @param {string} sortOrder -  It cotains the ortOrder data\n     * @returns {IAxisSet[]} - return sorted headers as IAxisSet[].\n     * @hidden\n     */\n    PivotEngine.prototype.getSortedHeaders = function (headers, sortOrder) {\n        var fieldName = headers[0].actualText !== 'Grand Total' ? headers[0].valueSort.axis :\n            headers[1].valueSort.axis;\n        var isNotDateType = !(this.formatFields && this.formatFields[fieldName] &&\n            this.formatFields[fieldName].type);\n        var childrens = this.fieldList[fieldName];\n        if (isNotDateType) {\n            if (childrens && childrens.type === 'number' && headers.length > 0 && (typeof (headers[0].actualText) === 'string')) {\n                var stringValue = [];\n                var alphaNumbervalue = [];\n                var nullValue = [];\n                for (var i = 0; i < headers.length; i++) {\n                    if (isNaN(Number(headers[i].actualText.toString().charAt(0)))) {\n                        stringValue.push(headers[i]);\n                    }\n                    else if (headers[i].actualText === '') {\n                        nullValue.push(headers[i]);\n                    }\n                    else {\n                        alphaNumbervalue.push(headers[i]);\n                        break;\n                    }\n                }\n                if (alphaNumbervalue.length > 0) {\n                    alphaNumbervalue = this.sortHeaders(fieldName, childrens, headers, childrens.sort, childrens.isAlphanumeric);\n                }\n                return headers;\n            }\n            else {\n                return this.sortHeaders(fieldName, childrens, headers, sortOrder, childrens.type);\n            }\n        }\n        else {\n            return this.sortHeaders(fieldName, childrens, headers, sortOrder, 'date');\n        }\n    };\n    PivotEngine.prototype.sortHeaders = function (fieldName, childrens, sortMembersOrder, sortOrder, type) {\n        var isHeaderSortByDefault = false;\n        var membersInfo = this.fieldList[fieldName] && this.fieldList[fieldName].membersOrder ?\n            this.fieldList[fieldName].membersOrder.slice() : [];\n        var sortDetails = {\n            fieldName: fieldName,\n            sortOrder: sortOrder,\n            members: membersInfo && membersInfo.length > 0 ? membersInfo : Object.keys(childrens.members),\n            IsOrderChanged: false\n        };\n        type = (type === 'datetime' || type === 'date' || type === 'time') ? (this.formatFields[fieldName] &&\n            (['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1)) ? type : 'string' : type;\n        var isDateType = (type === 'datetime' || type === 'date' || type === 'time');\n        var isNumberGroupSorting = false;\n        if (this.dataSourceSettings.groupSettings.length > 0) {\n            var groupField = this.dataSourceSettings.groupSettings.filter(function (field) {\n                return field.name === childrens.id;\n            });\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(groupField) && groupField.length > 0) {\n                isNumberGroupSorting = groupField[0].type.toLocaleLowerCase() === 'number' &&\n                    childrens.type.toLocaleLowerCase() === 'string';\n            }\n        }\n        if (membersInfo && membersInfo.length > 0) {\n            _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.applyCustomSort(sortDetails, sortMembersOrder, type);\n        }\n        else {\n            _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.applyHeadersSort(sortMembersOrder, sortOrder, type, isNumberGroupSorting);\n            isHeaderSortByDefault = true;\n        }\n        if (isHeaderSortByDefault && this.getHeaderSortInfo) {\n            var copyOrder = [];\n            for (var m = 0, n = 0; m < sortMembersOrder.length; m++) {\n                var member = sortMembersOrder[m];\n                var sortText = isDateType ?\n                    member.dateText : member.actualText;\n                if (member.actualText !== 'Grand Total') {\n                    copyOrder[n++] = sortText;\n                }\n            }\n            sortDetails.members = copyOrder;\n        }\n        if (this.getHeaderSortInfo) {\n            this.getHeaderSortInfo(sortDetails);\n        }\n        if (sortDetails.IsOrderChanged) {\n            _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.applyCustomSort(sortDetails, sortMembersOrder, type, true);\n        }\n        return sortMembersOrder;\n    };\n    /**\n     * It performs to applying  the value sorting.\n     *\n     * @param {IAxisSet[]} rMembers - It contains the row members data.\n     * @param {IAxisSet[]} cMembers - It contains the column members data.\n     * @returns {ISortedHeaders} - It return the sorted value as ISortedHeaders.\n     * @hidden\n     */\n    PivotEngine.prototype.applyValueSorting = function (rMembers, cMembers) {\n        var isNullArgument = false;\n        if (rMembers === undefined || cMembers === undefined) {\n            this.valueSortHeaderText = undefined;\n            if (this.enableValueSorting && this.valueSortSettings.headerText && !this.valueSortHeaderText &&\n                this.valueSortSettings.headerText !== '' && this.dataSourceSettings.values.length > 0) {\n                this.valueSortHeaderText = this.valueSortSettings.headerText;\n                var textArray = this.valueSortHeaderText.split(this.valueSortSettings.headerDelimiter);\n                for (var _i = 0, _a = this.dataSourceSettings.values; _i < _a.length; _i++) {\n                    var field = _a[_i];\n                    var name_1 = field.caption ? field.caption : field.name;\n                    var valueIndex = textArray.indexOf(name_1);\n                    if (valueIndex > -1) {\n                        textArray.splice(valueIndex, 1);\n                        textArray.push(name_1);\n                        this.valueSortHeaderText = textArray.join(this.valueSortSettings.headerDelimiter);\n                        break;\n                    }\n                }\n            }\n            rMembers = this.rMembers;\n            cMembers = this.cMembers;\n            isNullArgument = true;\n        }\n        if (this.valueSortHeaderText) {\n            var textArray = this.valueSortHeaderText.split(this.valueSortSettings.headerDelimiter);\n            var hText = '';\n            var mIndex = void 0;\n            var mType = void 0;\n            var caption = void 0;\n            for (var i = 0; i < this.dataSourceSettings.values.length; i++) {\n                if (this.dataSourceSettings.values[i].caption === textArray[textArray.length - 1]) {\n                    caption = this.dataSourceSettings.values[i].name;\n                    break;\n                }\n                else {\n                    caption = textArray[textArray.length - 1];\n                }\n            }\n            if (((this.dataSourceSettings.values.length === 1 && this.dataSourceSettings.columns.length === 0) ||\n                this.dataSourceSettings.values.length > 1) && caption && this.fieldList[caption]) {\n                for (var i = 0; i < textArray.length - 1; i++) {\n                    hText = hText === '' ? textArray[i] : (hText + this.valueSortSettings.headerDelimiter + textArray[i]);\n                }\n                mIndex = this.fieldList[caption].index;\n                mType = this.fieldList[caption].aggregateType;\n            }\n            else {\n                if (!this.dataSourceSettings.alwaysShowValueHeader || textArray.length === 1) {\n                    hText = this.valueSortHeaderText;\n                }\n                else {\n                    for (var i = 0; i < textArray.length - 1; i++) {\n                        hText = hText === '' ? textArray[i] : (hText + this.valueSortSettings.headerDelimiter + textArray[i]);\n                    }\n                }\n                mIndex = this.fieldList[this.dataSourceSettings.values[0].name].index;\n                mType = this.fieldList[this.dataSourceSettings.values[0].name].aggregateType;\n            }\n            var member = void 0;\n            if (this.valueAxis === 0) {\n                member = this.getMember(cMembers, hText);\n                if (member) {\n                    rMembers = this.sortByValueRow(rMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);\n                }\n            }\n            else {\n                member = this.getMember(rMembers, hText);\n                if (member) {\n                    cMembers = this.sortByValueRow(cMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);\n                }\n            }\n            if (isNullArgument) {\n                this.rMembers = rMembers;\n                this.cMembers = cMembers;\n                if (this.isPagingOrVirtualizationEnabled) {\n                    this.headerCollection.rowHeaders = this.rMembers;\n                    this.headerCollection.columnHeaders = this.cMembers;\n                }\n            }\n        }\n        return { rMembers: rMembers, cMembers: cMembers };\n    };\n    PivotEngine.prototype.getMember = function (cMembers, headerText) {\n        var vlen = cMembers.length;\n        var member;\n        for (var j = 0; j < vlen; j++) {\n            if (cMembers[j].valueSort.levelName === headerText) {\n                member = cMembers[j];\n                break;\n            }\n            else if (cMembers[j].members.length > 0) {\n                member = this.getMember(cMembers[j].members, headerText);\n            }\n            if (member) {\n                return member;\n            }\n        }\n        return member;\n    };\n    PivotEngine.prototype.sortByValueRow = function (rMembers, member, sortOrder, mIndex, mType) {\n        var aggreColl = [];\n        for (var _i = 0, rMembers_1 = rMembers; _i < rMembers_1.length; _i++) {\n            var header = rMembers_1[_i];\n            if (header.type === 'grand sum') {\n                aggreColl.push({ 'header': header });\n            }\n            else {\n                this.rawIndexObject = {};\n                var value = this.getAggregateValue(header.index, member.indexObject, mIndex, mType, false);\n                var cellDetails = {\n                    fieldName: this.fields[mIndex],\n                    row: header,\n                    column: member,\n                    value: value,\n                    cellSets: this.getValueCellInfo ? this.getCellSet(this.rawIndexObject) : [],\n                    rowCellType: (header.hasChild && header.isDrilled ? 'subTotal' : header.type === 'grand sum' ? 'grandTotal' : 'value'),\n                    columnCellType: (member.hasChild && member.isDrilled ? 'subTotal' : member.type === 'grand sum' ? 'grandTotal' : 'value'),\n                    aggregateType: mType,\n                    skipFormatting: false\n                };\n                if (this.getValueCellInfo) {\n                    this.getValueCellInfo(cellDetails);\n                }\n                value = cellDetails.value;\n                this.rawIndexObject = {};\n                aggreColl.push({ 'header': header, 'value': value });\n            }\n        }\n        rMembers = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getSortedValue(aggreColl, sortOrder);\n        for (var _a = 0, rMembers_2 = rMembers; _a < rMembers_2.length; _a++) {\n            var header = rMembers_2[_a];\n            if (header.members.length > 0) {\n                header.members = this.sortByValueRow(header.members, member, sortOrder, mIndex, mType);\n            }\n        }\n        return rMembers;\n    };\n    PivotEngine.prototype.insertAllMembersCommon = function () {\n        this.rowGrandTotal = this.columnGrandTotal = null;\n        var rowFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) ? true :\n            (this.dataSourceSettings.rows.length > 0) ? false : true;\n        var columnFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) ?\n            true : (this.dataSourceSettings.columns.length > 0) ? false : true;\n        if (this.isValueHasAdvancedAggregate) {\n            /* inserting the row grant-total members */\n            this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');\n            if (rowFlag) {\n                this.rowCount += this.rowValuesLength;\n            }\n            /* inserting the column gran-total members */\n            this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');\n            if (columnFlag) {\n                this.columnCount += this.colValuesLength;\n            }\n        }\n        else {\n            if (rowFlag) {\n                /* inserting the row grant-total members */\n                this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');\n                this.rowCount += this.rowValuesLength;\n            }\n            else {\n                this.rowGrandTotal = this.insertAllMember([], this.filterMembers, '', 'row')[0];\n            }\n            if (columnFlag) {\n                /* inserting the column gran-total members */\n                this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');\n                this.columnCount += this.colValuesLength;\n            }\n            else {\n                this.columnGrandTotal = this.insertAllMember([], this.filterMembers, '', 'column')[0];\n            }\n        }\n    };\n    PivotEngine.prototype.insertSubTotals = function () {\n        var rowLength = this.pivotValues.length;\n        for (var rowCnt = 0; rowCnt < rowLength; rowCnt++) {\n            var rowCells = this.pivotValues[rowCnt];\n            if (rowCells) {\n                var savedCell = void 0;\n                var spanCnt = 1;\n                var colLength = rowCells.length;\n                var indexObj = void 0;\n                var startIndex = 1;\n                var lastIndex = this.showSubTotalsAtTop ? this.reformAxisCount : colLength;\n                var colCnt = this.showSubTotalsAtTop ? startIndex : lastIndex - 1;\n                var columnSpan = void 0;\n                var memberCnt = void 0;\n                while (startIndex < lastIndex) {\n                    var cell = rowCells[colCnt];\n                    if (cell) {\n                        // if (cell.rowSpan > 1) {\n                        //     cell.rowSpan = 1;\n                        // }\n                        if (savedCell) {\n                            savedCell.colSpan = spanCnt;\n                            savedCell.colIndex = this.showSubTotalsAtTop ? savedCell.colIndex + (spanCnt - 1) :\n                                savedCell.colIndex - (spanCnt - 1);\n                        }\n                        if (this.showSubTotalsAtTop) {\n                            columnSpan = memberCnt = this.getMemberSpanCount(this.pivotValues[rowCnt], colCnt);\n                        }\n                        indexObj = { index: cell.index, indexObject: cell.indexObject };\n                        cell.index = [];\n                        cell.indexObject = {};\n                        savedCell = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, cell, null, true);\n                        cell.index = indexObj.index;\n                        cell.indexObject = indexObj.indexObject;\n                        var rowPos = rowCnt + 1;\n                        while (this.pivotValues[rowPos] && !this.pivotValues[rowPos][colCnt]) {\n                            var curentCell = this.pivotValues[rowCnt][colCnt];\n                            if (!curentCell.isDrilled && !(!this.valueAxis && !this.isLastHeaderHasMeasures && (curentCell.members\n                                && curentCell.members.length > 0 && rowPos > this.measureIndex))) {\n                                curentCell.rowSpan = (rowPos - rowCnt) + 1;\n                                savedCell.rowSpan = (rowPos - rowCnt) + 1;\n                            }\n                            var cellType = (cell.type === 'sum' || cell.type === 'grand sum') ? cell.type : 'sum';\n                            this.pivotValues[rowPos][colCnt] =\n                                this.headerContent[rowPos][colCnt] = {\n                                    type: cellType, formattedText: ((cell.type === 'sum' || cell.type === 'grand sum') ? cell.formattedText :\n                                        (cell.formattedText + ' Total')), axis: 'column', hierarchyName: cell.hierarchyName,\n                                    level: -1, colIndex: colCnt, rowIndex: rowPos, valueSort: cell.valueSort\n                                };\n                            if (cell.valueSort && cell.valueSort[this.valueSortSettings.headerText]) {\n                                this.valueSortSettings.columnIndex = colCnt;\n                            }\n                            var isSpanned = false;\n                            if (cellType === 'grand sum') {\n                                curentCell.rowSpan = (rowPos - rowCnt) + 1;\n                                savedCell.rowSpan = (rowPos - rowCnt) + 1;\n                            }\n                            else if (curentCell.type !== 'sum' && (curentCell.isDrilled || (this.valueAxisFields[curentCell.actualText] &&\n                                !this.valueAxis && !this.isLastHeaderHasMeasures && curentCell.members && curentCell.members.length > 0))) {\n                                this.pivotValues[rowCnt + 1][colCnt].rowSpan = rowPos - rowCnt;\n                                isSpanned = true;\n                            }\n                            else {\n                                this.pivotValues[rowPos][colCnt].rowSpan = -1;\n                            }\n                            if (rowPos > (rowCnt + 1) && (curentCell.type === 'sum' ||\n                                isSpanned)) {\n                                this.pivotValues[rowPos][colCnt].rowSpan = -1;\n                            }\n                            rowPos++;\n                        }\n                        spanCnt = 1;\n                    }\n                    else {\n                        rowCells[colCnt] =\n                            this.headerContent[rowCnt][colCnt] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, savedCell, null, true);\n                        rowCells[colCnt].index =\n                            this.headerContent[rowCnt][colCnt].index = indexObj.index;\n                        rowCells[colCnt].indexObject =\n                            this.headerContent[rowCnt][colCnt].indexObject = indexObj.indexObject;\n                        spanCnt++;\n                        if (this.showSubTotalsAtTop) {\n                            memberCnt--;\n                            rowCells[colCnt].colSpan = memberCnt;\n                            rowCells[colCnt].colIndex = rowCells[colCnt].colIndex + (spanCnt - 1);\n                        }\n                        else {\n                            rowCells[colCnt].colSpan = spanCnt;\n                            rowCells[colCnt].colIndex = rowCells[colCnt].colIndex - (spanCnt - 1);\n                        }\n                    }\n                    if (colCnt === 1 && savedCell) {\n                        if (this.showSubTotalsAtTop) {\n                            savedCell.colSpan = columnSpan;\n                            savedCell.colIndex = savedCell.colIndex + (spanCnt - 1);\n                        }\n                        else {\n                            savedCell.colSpan = spanCnt;\n                            savedCell.colIndex = savedCell.colIndex - (spanCnt - 1);\n                        }\n                    }\n                    if (this.showSubTotalsAtTop && (rowCells[colCnt + 1] || colCnt + 1 === this.reformAxisCount)) {\n                        var cell_1 = this.pivotValues[rowCnt][(colCnt - spanCnt) + 1];\n                        cell_1.colSpan = columnSpan;\n                        this.pivotValues[rowCnt][(colCnt - spanCnt) + 1] = cell_1;\n                    }\n                    colCnt = this.showSubTotalsAtTop ? colCnt + 1 : colCnt - 1;\n                    startIndex++;\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.getMemberSpanCount = function (rowCellArray, cellIndex) {\n        var colIndex = 1;\n        for (var i = cellIndex + 1; i < this.reformAxisCount; i++) {\n            if (!rowCellArray[i]) {\n                colIndex++;\n            }\n            else {\n                break;\n            }\n        }\n        return colIndex;\n    };\n    PivotEngine.prototype.frameDrillObject = function (vDrilledItem) {\n        if (vDrilledItem === void 0) { vDrilledItem = null; }\n        this.fieldDrillCollection = {};\n        for (var fieldCnt = 0; fieldCnt < this.drilledMembers.length; fieldCnt++) {\n            var drillOption = this.drilledMembers[fieldCnt];\n            var hasValueField = false;\n            var levelCount = 1;\n            var isFieldAvail = false;\n            var field = this.fieldList[drillOption.name];\n            var isDrillMemberExpand = (field && field.expandAll);\n            for (var i = 0; i < this.dataSourceSettings.rows.length; i++) {\n                if (this.dataSourceSettings.rows[i].name === drillOption.name) {\n                    var hasMeasureIndex = this.valueAxis && (this.isMultiMeasures ||\n                        this.dataSourceSettings.alwaysShowValueHeader) && this.measureIndex > -1 && this.measureIndex <= i;\n                    levelCount = (hasMeasureIndex ? (i + 1) : i) + 1;\n                    hasValueField = hasMeasureIndex ? true : false;\n                    isFieldAvail = true;\n                    break;\n                }\n            }\n            if (!isFieldAvail) {\n                for (var i = 0; i < this.dataSourceSettings.columns.length; i++) {\n                    if (this.dataSourceSettings.columns[i].name === drillOption.name) {\n                        var hasMeasureIndex = !this.valueAxis && (this.isMultiMeasures ||\n                            this.dataSourceSettings.alwaysShowValueHeader) && this.measureIndex > -1 && this.measureIndex <= i;\n                        levelCount = (hasMeasureIndex ? (i + 1) : i) + 1;\n                        hasValueField = hasMeasureIndex ? true : false;\n                        isFieldAvail = true;\n                        break;\n                    }\n                }\n            }\n            for (var _i = 0, _a = drillOption.items; _i < _a.length; _i++) {\n                var drilledItem = _a[_i];\n                var members = drilledItem.split(drillOption.delimiter);\n                if (levelCount === members.length) {\n                    var memberString = drillOption.name + this.valueSortSettings.headerDelimiter +\n                        members.join(this.valueSortSettings.headerDelimiter);\n                    this.fieldDrillCollection[memberString] = memberString;\n                    if (hasValueField) {\n                        var isAllValuesAvail = false;\n                        if (this.isExpandAll || isDrillMemberExpand) {\n                            for (var _b = 0, _c = this.dataSourceSettings.values; _b < _c.length; _b++) {\n                                var field_1 = _c[_b];\n                                var name_2 = field_1.caption ? field_1.caption : field_1.name;\n                                members[this.measureIndex] = name_2;\n                                if (drillOption.items.indexOf(members.join(drillOption.delimiter)) > -1) {\n                                    isAllValuesAvail = true;\n                                }\n                                else {\n                                    isAllValuesAvail = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (((this.isExpandAll || isDrillMemberExpand) && isAllValuesAvail) || !this.isExpandAll || !isDrillMemberExpand) {\n                            members = drilledItem.split(drillOption.delimiter);\n                            members.splice(this.measureIndex, 1);\n                            if (vDrilledItem && vDrilledItem.memberName === drilledItem) {\n                                vDrilledItem.memberName = members.join(drillOption.delimiter);\n                            }\n                            memberString = drillOption.name + this.valueSortSettings.headerDelimiter +\n                                members.join(this.valueSortSettings.headerDelimiter);\n                            this.fieldDrillCollection[memberString] = memberString;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.getIndexedHeaders = function (keys, data, keyInd, position, axis, parentMember, valueFil) {\n        var hierarchy = [];\n        var keysPos = 0;\n        if (keys && keys.length > 0) {\n            keysPos++;\n            var rlen = keys.length;\n            var decisionObj = {};\n            var fieldName = keys[keyInd].name;\n            var field = keys[keyInd];\n            // let members: string[] = Object.keys(this.fieldList[field].members);\n            var childrens = this.fieldList[fieldName];\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.reportDataType)) {\n                this.reportDataType = {};\n                for (var i = 0; i < this.dataSourceSettings.rows.length; i++) {\n                    this.reportDataType[this.dataSourceSettings.rows[i].name] =\n                        this.dataSourceSettings.rows[i].dataType;\n                }\n                for (var i = 0; i < this.dataSourceSettings.columns.length; i++) {\n                    this.reportDataType[this.dataSourceSettings.columns[i].name] =\n                        this.dataSourceSettings.columns[i].dataType;\n                }\n                for (var i = 0; i < this.dataSourceSettings.values.length; i++) {\n                    this.reportDataType[this.dataSourceSettings.values[i].name] =\n                        this.dataSourceSettings.values[i].dataType;\n                }\n            }\n            childrens.type = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.reportDataType[childrens.id]) ? this.reportDataType[childrens.id] : childrens.type;\n            var isNoData = false;\n            var isDateType = (this.formatFields[fieldName] &&\n                (['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1));\n            var showNoDataItems = (position.length < 1 && keyInd > 0) || field.showNoDataItems;\n            var savedMembers = {};\n            if (showNoDataItems) {\n                var members = Object.keys(childrens.members);\n                for (var pos = 0, lt = members.length; pos < lt; pos++) {\n                    if (this.dataSourceSettings.showHeaderWhenEmpty ||\n                        (this.localeObj && members[pos] !== this.localeObj.getConstant('undefined'))) {\n                        savedMembers[members[pos]] = members[pos];\n                    }\n                }\n                if (position.length < 1) {\n                    isNoData = true;\n                    position.length = members.length;\n                }\n            }\n            if (axis === this.dataSourceSettings.valueAxis && this.measureIndex === keyInd &&\n                (this.dataSourceSettings.values.length > 1 || this.dataSourceSettings.alwaysShowValueHeader)) {\n                this.isLastHeaderHasMeasures = false;\n            }\n            for (var pos = 0, lt = position.length; pos < lt; pos++) {\n                var member = {};\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(keys[keyInd].showSubTotals) && !keys[keyInd].showSubTotals) {\n                    member.showSubTotals = false;\n                }\n                member.hasChild = keyInd < rlen - 1;\n                member.level = keyInd;\n                member.axis = axis;\n                member.colSpan = 1;\n                this.rowMaxLevel = (axis === 'row' && this.rowMaxLevel < keyInd) ? keyInd : this.rowMaxLevel;\n                var memInd = isNoData ? childrens.members[Object.keys(savedMembers)[0]].ordinal :\n                    this.valueMatrix[position[pos]][childrens.index].ordinal;\n                var headerValue = isNoData ? Object.keys(savedMembers)[0] :\n                    data[position[pos]][this.fieldKeys[fieldName]];\n                headerValue = this.enableHtmlSanitizer ? _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.SanitizeHtmlHelper.sanitize(headerValue) : headerValue;\n                if (((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(headerValue) || (this.localeObj && headerValue === this.localeObj.getConstant('undefined')))\n                    && !this.dataSourceSettings.showHeaderWhenEmpty) {\n                    if (showNoDataItems && !isNoData && keyInd > 0 && pos + 1 === position.length &&\n                        Object.keys(savedMembers).length > 0) {\n                        lt = Object.keys(savedMembers).length;\n                        isNoData = true;\n                        pos = -1;\n                    }\n                    continue;\n                }\n                delete savedMembers[headerValue];\n                if (showNoDataItems && this.fieldFilterMem[fieldName] &&\n                    this.fieldFilterMem[fieldName].memberObj[headerValue] === headerValue) {\n                    continue;\n                }\n                var formattedValue = isDateType ? {\n                    actualText: headerValue,\n                    formattedText: childrens.dateMember[memInd - 1].formattedText,\n                    dateText: childrens.dateMember[memInd - 1].actualText\n                } : {\n                    formattedText: headerValue === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(headerValue)) :\n                        headerValue === undefined ? (this.localeObj ? (fieldName in this.groupingFields) ?\n                            this.localeObj.getConstant('groupOutOfRange') : this.localeObj.getConstant('undefined') :\n                            String(headerValue)) : String(headerValue), actualText: headerValue === null ? (this.localeObj ?\n                        this.localeObj.getConstant('null') : String(headerValue)) : headerValue === undefined ?\n                        (this.localeObj ? (fieldName in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :\n                            this.localeObj.getConstant('undefined') : String(headerValue)) : headerValue\n                };\n                member.actualText = formattedValue.actualText;\n                member.formattedText = formattedValue.formattedText;\n                if (isDateType) {\n                    member.dateText = formattedValue.dateText;\n                }\n                var availData = showNoDataItems ? (this.filterPosObj[position[pos]] !== undefined &&\n                    !isNoData ? true : false) : true;\n                //member.name = members[memInd as number];\n                // member.type = member.hasChild ? 'All' : 'Single';\n                var isFiltered = false;\n                if (showNoDataItems && childrens.filter.length > 0 && childrens.filterType === 'include') {\n                    isFiltered = true;\n                }\n                if ((!(decisionObj && decisionObj[memInd])) && (!isFiltered ||\n                    (isFiltered && childrens.filter.indexOf(headerValue.toString()) > -1))) {\n                    decisionObj[memInd] = { index: [], indexObject: {} };\n                    member.index = decisionObj[memInd].index;\n                    member.indexObject = decisionObj[memInd].indexObject;\n                    if (availData) {\n                        member.index = decisionObj[memInd].index = [position[pos]];\n                        decisionObj[memInd].indexObject[position[pos]] = position[pos];\n                        member.indexObject = decisionObj[memInd].indexObject;\n                    }\n                    member.ordinal = memInd;\n                    member.valueSort = {};\n                    member.valueSort.axis = fieldName;\n                    if (keyInd !== 0) {\n                        member.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter +\n                            (this.customProperties.isTabularLayout ?\n                                this.getFormattedValue(member.formattedText, childrens.caption).formattedText : member.formattedText);\n                        member.valueSort[parentMember + this.valueSortSettings.headerDelimiter + member.formattedText] = 1;\n                        member.valueSort.uniqueName = parentMember + this.valueSortSettings.headerDelimiter +\n                            (member.actualText ? member.actualText : member.formattedText);\n                        member.valueSort[parentMember + this.valueSortSettings.headerDelimiter + (member.actualText ?\n                            member.actualText : member.formattedText)] = 1;\n                    }\n                    else {\n                        member.valueSort[member.formattedText] = 1;\n                        member.valueSort.levelName = (this.customProperties.isTabularLayout ?\n                            this.getFormattedValue(member.formattedText, childrens.caption).formattedText : member.formattedText);\n                        member.valueSort[member.actualText ? member.actualText : member.formattedText] = 1;\n                        member.valueSort.uniqueName = (member.actualText ? member.actualText : member.formattedText);\n                    }\n                    var memberString = member.valueSort.axis + this.valueSortSettings.headerDelimiter + member.valueSort.levelName;\n                    var isExpandMember = this.isExpandAll || (field && field.expandAll);\n                    member.isDrilled = (valueFil && this.isValueFiltersAvail) ? true :\n                        (member.hasChild && this.fieldDrillCollection[memberString]) ?\n                            isExpandMember ? (!this.valueAxis && !this.isLastHeaderHasMeasures && (keysPos >= this.measureIndex) ?\n                                true : false) : true : isExpandMember;\n                    //if (!member.members) {\n                    member.members = [];\n                    //}\n                    //let copyObj: AxisSet = Object.create(member);\n                    hierarchy.push(member);\n                }\n                else if (availData) {\n                    decisionObj[memInd].index.push(position[pos]);\n                    decisionObj[memInd].indexObject[position[pos]] = position[pos];\n                }\n                if (showNoDataItems && !isNoData && keyInd > 0 && pos + 1 === position.length &&\n                    Object.keys(savedMembers).length > 0) {\n                    isNoData = true;\n                    lt = Object.keys(savedMembers).length;\n                    pos = -1;\n                }\n            }\n            for (var iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {\n                if (!this.frameHeaderObjectsCollection) {\n                    if (axis === 'row') {\n                        this.rowCount += (this.rowValuesLength + (hierarchy[iln].isDrilled && hierarchy[iln].hasChild && this.showSubTotalsAtBottom ? 1 : 0));\n                    }\n                    else {\n                        this.columnCount += this.colValuesLength;\n                    }\n                }\n                var level = null;\n                if (hierarchy[iln].valueSort && hierarchy[iln].valueSort.levelName) {\n                    level = hierarchy[iln].valueSort.levelName;\n                }\n                parentMember = (level || hierarchy[iln].formattedText);\n                if (!this.dataSourceSettings.showHeaderWhenEmpty && rlen - 1 > keyInd && hierarchy[iln].index &&\n                    hierarchy[iln].index.length > 0) {\n                    if (showNoDataItems && keys[keyInd + 1] && keys[keyInd + 1].name &&\n                        Object.keys(this.fieldList[keys[keyInd + 1].name].members).length > 0) {\n                        hierarchy[iln].hasChild = true;\n                    }\n                    else {\n                        var hIndLen = hierarchy[iln].index.length;\n                        var count = 0;\n                        for (var len = 0; len < hIndLen; len++) {\n                            var headerValue = data[hierarchy[iln].index[len]][this.fieldKeys[keys[keyInd + 1].name]];\n                            if (((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(headerValue) || (this.localeObj &&\n                                headerValue === this.localeObj.getConstant('undefined')))) {\n                                count++;\n                            }\n                        }\n                        hierarchy[iln].hasChild = count !== hIndLen;\n                    }\n                }\n                if (rlen - 1 > keyInd && hierarchy[iln].isDrilled) {\n                    this.columnCount -= (!(this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals && field.showSubTotals) && axis === 'column') ?\n                        this.colValuesLength : 0;\n                    var filterPosition = hierarchy[iln].index;\n                    hierarchy[iln].members = this.getIndexedHeaders(keys, data, keyInd + 1, (filterPosition === undefined ? [] : filterPosition), axis, parentMember, valueFil);\n                    if (this.frameHeaderObjectsCollection) {\n                        this.headerObjectsCollection[parentMember] = hierarchy[iln].members;\n                    }\n                }\n            }\n            if (this.enableSort) {\n                // return new DataManager(hierarchy as JSON[]).executeLocal(new Query().sortBy('actualText', childrens.sort.toLowerCase()));\n                if (isDateType) {\n                    return this.sortHeaders(fieldName, childrens, hierarchy, childrens.sort, 'date');\n                }\n                else {\n                    if (childrens.type.toLowerCase() === 'number' && hierarchy.length > 0 && (typeof (hierarchy[0].actualText) === 'string') && hierarchy[0].actualText.match(/[a-zA-Z]+/g)) {\n                        var stringValue = [];\n                        var outOfRange = void 0;\n                        var alphaNumbervalue = [];\n                        var nullValue = [];\n                        for (var i = 0; i < hierarchy.length; i++) {\n                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(hierarchy[i].actualText.toString().match(/\\d+/))) {\n                                stringValue.push(hierarchy[i]);\n                                if (!outOfRange && childrens.sort !== 'None') {\n                                    if (hierarchy[i].actualText === 'Out of Range') {\n                                        outOfRange = hierarchy[i];\n                                        hierarchy.splice(i, 1);\n                                    }\n                                }\n                            }\n                            else if (hierarchy[i].actualText === '') {\n                                nullValue.push(hierarchy[i]);\n                            }\n                            else {\n                                this.fieldList[fieldName].isAlphanumeric = true;\n                                alphaNumbervalue.push(hierarchy[i]);\n                                break;\n                            }\n                        }\n                        if (outOfRange) {\n                            if (childrens.sort === 'Ascending') {\n                                if (hierarchy[0].actualText === 'Grand Total') {\n                                    hierarchy.splice(1, 0, outOfRange);\n                                }\n                                else {\n                                    hierarchy.splice(0, 0, outOfRange);\n                                }\n                            }\n                            else {\n                                if (hierarchy[hierarchy.length - 1].actualText === 'Grand Total') {\n                                    hierarchy.splice(hierarchy.length - 1, 0, outOfRange);\n                                }\n                                else {\n                                    hierarchy.splice(hierarchy.length, 0, outOfRange);\n                                }\n                            }\n                        }\n                        if (alphaNumbervalue.length > 0) {\n                            this.sortHeaders(fieldName, childrens, hierarchy, childrens.sort, childrens.isAlphanumeric);\n                        }\n                        return hierarchy;\n                    }\n                    else {\n                        return this.sortHeaders(fieldName, childrens, hierarchy, childrens.sort, childrens.type);\n                    }\n                }\n            }\n            else {\n                return hierarchy;\n            }\n        }\n        else {\n            return hierarchy;\n        }\n    };\n    PivotEngine.prototype.getOrderedIndex = function (headers) {\n        var orderedIndex = {};\n        for (var i = 0; i < headers.length; i++) {\n            if (headers[i].type !== 'grand sum') {\n                orderedIndex[headers[i].ordinal] = i;\n            }\n        }\n        return orderedIndex;\n    };\n    PivotEngine.prototype.insertPosition = function (keys, data, keyInd, position, axis, parentMember, slicedHeaders) {\n        var hierarchy = [];\n        var orderedIndex = this.getOrderedIndex(slicedHeaders);\n        if (keys) {\n            var decisionObj = {};\n            var field = keys[keyInd].name;\n            var childrens = this.fieldList[field];\n            for (var pos = 0, lt = position.length; pos < lt; pos++) {\n                var member = {};\n                var memInd = this.valueMatrix[position[pos]][childrens.index].ordinal;\n                var slicedHeader = slicedHeaders[orderedIndex[memInd]];\n                var value = data[position[pos]][this.fieldKeys[field]];\n                value = value === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(value)) : value;\n                var formattedValue = (this.formatFields[field] &&\n                    (['date', 'dateTime', 'time'].indexOf(this.formatFields[field].type) > -1)) ?\n                    this.getFormattedValue(value, field) : { formattedText: value.toString(), actualText: value.toString() };\n                if (!(slicedHeader && slicedHeader.formattedText === formattedValue.formattedText)) {\n                    continue;\n                }\n                if (!(decisionObj && decisionObj[memInd])) {\n                    decisionObj[memInd] = { index: [], indexObject: {} };\n                    slicedHeader.index = decisionObj[memInd].index = [position[pos]];\n                    decisionObj[memInd].indexObject[position[pos]] = position[pos];\n                    slicedHeader.indexObject = decisionObj[memInd].indexObject;\n                    slicedHeader.valueSort = {};\n                    slicedHeader.valueSort.axis = field;\n                    if (keyInd !== 0) {\n                        slicedHeader.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter +\n                            slicedHeader.formattedText;\n                        slicedHeader.valueSort[parentMember + this.valueSortSettings.headerDelimiter +\n                            slicedHeader.formattedText] = 1;\n                        slicedHeader.valueSort.uniqueName = parentMember + this.valueSortSettings.headerDelimiter +\n                            (slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText);\n                        slicedHeader.valueSort[parentMember + this.valueSortSettings.headerDelimiter +\n                            (slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText)] = 1;\n                    }\n                    else {\n                        slicedHeader.valueSort[slicedHeader.formattedText] = 1;\n                        slicedHeader.valueSort.levelName = slicedHeader.formattedText;\n                        slicedHeader.valueSort[(slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText)] = 1;\n                        slicedHeader.valueSort.uniqueName =\n                            (slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText);\n                    }\n                    member.members = [];\n                    hierarchy.push(member);\n                }\n                else {\n                    decisionObj[memInd].index.push(position[pos]);\n                    decisionObj[memInd].indexObject[position[pos]] = position[pos];\n                }\n            }\n            var diff = slicedHeaders.length - hierarchy.length;\n            while (diff > 0) {\n                hierarchy.push({ members: [] });\n                diff--;\n            }\n            for (var iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {\n                if (slicedHeaders[iln].members.length > 0) {\n                    var level = null;\n                    if (slicedHeaders[iln].valueSort && slicedHeaders[iln].valueSort.levelName) {\n                        level = slicedHeaders[iln].valueSort.levelName;\n                    }\n                    parentMember = (level || slicedHeaders[iln].formattedText);\n                    hierarchy[iln].members = this.insertPosition(keys, data, keyInd + 1, slicedHeaders[iln].index, axis, parentMember, slicedHeaders[iln].members);\n                }\n            }\n            return hierarchy;\n        }\n        else {\n            return hierarchy;\n        }\n    };\n    PivotEngine.prototype.insertTotalPosition = function (headers) {\n        var summCell = headers[headers.length - 1];\n        if (summCell && summCell.type === 'grand sum') {\n            summCell.index = this.filterMembers;\n            summCell.indexObject = {};\n            for (var ln = 0, lt = this.filterMembers.length; ln < lt; ln++) {\n                summCell.indexObject[this.filterMembers[ln]] = this.filterMembers[ln];\n            }\n        }\n        return headers;\n    };\n    PivotEngine.prototype.calculatePagingValues = function () {\n        if (this.isPagingOrVirtualizationEnabled) {\n            if (this.valueAxis === 1) {\n                this.rowValuesLength = this.dataSourceSettings.values.length;\n            }\n            else {\n                this.colValuesLength = this.dataSourceSettings.values.length;\n            }\n            this.columnPageCount = Math.ceil(this.columnCount / this.pageSettings.columnPageSize);\n            this.rowPageCount = Math.ceil(this.rowCount / this.pageSettings.rowPageSize);\n            this.pageSettings.currentColumnPage = this.pageSettings.currentColumnPage >= this.columnPageCount ||\n                (this.enableOptimizedRendering && this.pageSettings.currentColumnPage > 1 &&\n                    ((this.pageSettings.currentColumnPage + 1) * this.colValuesLength) >= this.columnPageCount) ?\n                this.columnPageCount : this.pageSettings.currentColumnPage;\n            this.pageSettings.currentRowPage = this.pageSettings.currentRowPage >= this.rowPageCount ||\n                (this.enableOptimizedRendering && this.pageSettings.currentRowPage > 1 &&\n                    ((this.pageSettings.currentRowPage + 1) * this.rowValuesLength) >= this.rowPageCount) ?\n                this.rowPageCount : this.pageSettings.currentRowPage;\n            var requirePageCount = this.enablePaging ? 1 : this.enableOptimizedRendering ? 1.5 : 3;\n            this.memberCnt = this.enablePaging ? 0 : -this.rowValuesLength;\n            this.rowStartPos = ((this.pageSettings.currentRowPage * this.pageSettings.rowPageSize) -\n                (this.pageSettings.rowPageSize)) * (this.enablePaging ? 1 : this.rowValuesLength) + (this.enablePaging ? 1 : 0);\n            var exactStartPos = this.enablePaging ? this.rowStartPos :\n                (this.rowStartPos + (this.pageSettings.rowPageSize * requirePageCount * this.rowValuesLength)) > this.rowCount ?\n                    (this.rowCount - (this.pageSettings.rowPageSize * requirePageCount * this.rowValuesLength)) : this.rowStartPos;\n            if (exactStartPos < 0) {\n                exactStartPos = this.rowStartPos = 0;\n                this.pageSettings.currentRowPage = 1;\n            }\n            this.rowFirstLvl = (this.rowStartPos - exactStartPos) % this.pageSettings.rowPageSize;\n            this.rowStartPos = exactStartPos;\n            this.endPos = this.rowStartPos + (this.pageSettings.rowPageSize * requirePageCount * (this.enablePaging ? 1 :\n                this.rowValuesLength)) - (this.enablePaging ? 1 : 0);\n            this.endPos = this.endPos > (this.rowCount + 1) ? (this.rowCount + 1) : this.endPos;\n            this.rMembers = this.performSlicing(this.rMembers, [], this.rowStartPos, 'row');\n            this.memberCnt = this.enablePaging ? 0 : -this.colValuesLength;\n            this.pageInLimit = false;\n            this.colHdrBufferCalculated = false;\n            this.colStartPos = ((this.pageSettings.currentColumnPage * this.pageSettings.columnPageSize) -\n                (this.pageSettings.columnPageSize)) * (this.enablePaging ? 1 : this.colValuesLength) + (this.enablePaging ? 1 : 0);\n            exactStartPos = this.enablePaging ? this.colStartPos : (this.colStartPos + (this.pageSettings.columnPageSize *\n                requirePageCount * this.colValuesLength)) > this.columnCount ? (this.columnCount - (this.pageSettings.columnPageSize *\n                requirePageCount * this.colValuesLength)) : this.colStartPos;\n            if (exactStartPos < 0) {\n                exactStartPos = this.colStartPos = 0;\n                this.pageSettings.currentColumnPage = 1;\n            }\n            this.colFirstLvl = (this.colStartPos - exactStartPos) % this.pageSettings.columnPageSize;\n            this.colStartPos = exactStartPos;\n            this.endPos = this.colStartPos + (this.pageSettings.columnPageSize * requirePageCount *\n                (this.enablePaging ? 1 : this.colValuesLength)) - (this.enablePaging ? 1 : 0);\n            this.endPos = this.endPos > (this.columnCount + 1) ? (this.columnCount + 1) : this.endPos;\n            this.cMembers = this.performSlicing(this.cMembers, [], this.colStartPos, 'column');\n            this.memberCnt = -1;\n            this.pageInLimit = false;\n            if (this.isValueHasAdvancedAggregate) {\n                if (this.rMembers[this.rMembers.length - 1].type !== 'grand sum' &&\n                    this.headerCollection.rowHeaders[this.headerCollection.rowHeaders.length - 1].type === 'grand sum') {\n                    this.rMembers.push(this.headerCollection.rowHeaders[this.headerCollection.rowHeaders.length - 1]);\n                    this.removeRowGrandTotal = true;\n                }\n                if (this.cMembers[this.cMembers.length - 1].type !== 'grand sum' &&\n                    this.headerCollection.columnHeaders[this.headerCollection.columnHeaders.length - 1].type === 'grand sum') {\n                    this.cMembers.push(this.headerCollection.columnHeaders[this.headerCollection.columnHeaders.length - 1]);\n                    this.removeColumnGrandTotal = true;\n                }\n            }\n            else {\n                this.rowGrandTotal = this.rowGrandTotal ? this.rowGrandTotal :\n                    this.headerCollection.rowHeaders[this.headerCollection.rowHeaders.length - 1];\n                this.columnGrandTotal = this.columnGrandTotal ? this.columnGrandTotal :\n                    this.headerCollection.columnHeaders[this.headerCollection.columnHeaders.length - 1];\n            }\n        }\n    };\n    PivotEngine.prototype.performSlicing = function (headers, slicedHeaders, startPos, axis) {\n        var pos = 0;\n        while (headers[pos]) {\n            if (this.enablePaging && this.endPos <= this.memberCnt && pos !== 0) {\n                break;\n            }\n            this.memberCnt += headers[pos].level <= this.measureIndex ? (axis === 'column' ? this.colValuesLength : this.rowValuesLength) : 1;\n            if (startPos <= this.memberCnt && this.endPos >= this.memberCnt && !this.pageInLimit) {\n                if (axis === 'column') {\n                    this.colFirstLvl = this.colFirstLvl + headers[pos].level;\n                }\n                else {\n                    this.rowFirstLvl = this.rowFirstLvl + headers[pos].level;\n                }\n                this.pageInLimit = true;\n            }\n            if (this.pageInLimit && !this.enablePaging) {\n                if (this.endPos <= this.memberCnt) {\n                    if (axis === 'column') {\n                        if (headers[pos].members.length === 0) {\n                            if (this.colHdrBufferCalculated) {\n                                break;\n                            }\n                            this.colHdrBufferCalculated = true;\n                            this.endPos += (headers[pos].level * this.colValuesLength);\n                        }\n                        else if (this.colHdrBufferCalculated) {\n                            break;\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            slicedHeaders.push(headers[pos].members.length > 0 ?\n                this.removeChildMembers(headers[pos]) : headers[pos]);\n            if (headers[pos].members.length > 0) {\n                if (axis === 'column') {\n                    this.memberCnt -= !(this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals &&\n                        this.columnKeys[headers[pos].valueSort.axis].showSubTotals) ?\n                        this.colValuesLength : 0;\n                }\n                else if (this.showSubTotalsAtBottom) {\n                    this.memberCnt++;\n                }\n                slicedHeaders[slicedHeaders.length - 1].members =\n                    this.performSlicing(headers[pos].members, [], startPos, axis);\n            }\n            if (!this.pageInLimit) {\n                slicedHeaders.pop();\n            }\n            if (headers[pos].level === 0 && this.pageInLimit && this.endPos <= this.memberCnt) {\n                break;\n            }\n            pos++;\n        }\n        return slicedHeaders;\n    };\n    PivotEngine.prototype.removeChildMembers = function (member) {\n        var keys = Object.keys(member);\n        var keyPos = 0;\n        var framedMember = {};\n        while (keyPos < keys.length) {\n            framedMember[keys[keyPos]] = member[keys[keyPos]];\n            if (keys[keyPos] === 'members') {\n                framedMember['members'] = [];\n            }\n            keyPos++;\n        }\n        return framedMember;\n    };\n    PivotEngine.prototype.insertAllMember = function (set, filter, customText, axis) {\n        var len = set.length;\n        customText = ' Total';\n        var grandTotalSet = {\n            hasChild: false,\n            index: filter,\n            level: 0,\n            axis: axis,\n            isDrilled: false,\n            indexObject: {},\n            members: [],\n            actualText: 'Grand' + customText,\n            formattedText: this.localeObj ? this.localeObj.getConstant('grandTotal') : ('Grand' + customText),\n            ordinal: len,\n            type: 'grand sum',\n            valueSort: {}\n        };\n        grandTotalSet.valueSort[grandTotalSet.formattedText] = 1;\n        grandTotalSet.valueSort.levelName = grandTotalSet.formattedText;\n        grandTotalSet.valueSort[grandTotalSet.actualText] = 1;\n        grandTotalSet.valueSort.uniqueName = grandTotalSet.actualText;\n        for (var ln = 0, lt = filter.length; ln < lt; ln++) {\n            grandTotalSet.indexObject[filter[ln]] = filter[ln];\n        }\n        if (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals) {\n            set.unshift(grandTotalSet);\n        }\n        else {\n            set.push(grandTotalSet);\n        }\n        // if (axis === 'row') {\n        //     this.rowCount += this.rowValuesLength;\n        // } else {\n        //     this.columnCount += this.colValuesLength;\n        // }\n        return set;\n    };\n    PivotEngine.prototype.getTableData = function (rows, reformAxis, columns, pIndex, data, vlt, level, rTotal, cTotal, valueParentIndex) {\n        for (var rlt = rows.length, rln = 0; rln < rlt; rln++) {\n            var tnum = (!this.valueAxis && !this.isLastHeaderHasMeasures && data.length <\n                (this.dataSourceSettings.columns.length + 1)) ? (this.dataSourceSettings.columns.length + 1) : data.length;\n            var row = rows[rln];\n            reformAxis[tnum] = row;\n            var actCnt = tnum - Number(Object.keys(reformAxis)[0]);\n            var isLeastNode = !reformAxis[tnum].members.length;\n            row.colIndex = 0;\n            row.rowIndex = tnum;\n            var isRowFieldsAvail = false;\n            var delimiter = this.dataSourceSettings.valueSortSettings.headerDelimiter;\n            if (this.valueAxis && this.dataSourceSettings.rows.length === 0 && this.dataSourceSettings.values.length > 1) {\n                this.rowIndex = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.rowIndex) && !isLeastNode &&\n                    this.dataSourceSettings.rows.length === 0) ? row.index : this.rowIndex;\n                isRowFieldsAvail = (this.valueAxis && this.dataSourceSettings.rows.length === 0 && row.valueSort.levelName &&\n                    row.valueSort.levelName.toString().indexOf('Grand Total' + delimiter) !== 0);\n                if (this.valueAxis && this.dataSourceSettings.rows.length === 0 &&\n                    row.valueSort.levelName.toString().indexOf('Grand Total' + delimiter) === 0) {\n                    row.index = this.rowIndex;\n                }\n            }\n            if (!isRowFieldsAvail) {\n                var isValue = false;\n                if (this.showSubTotalsAtBottom && reformAxis[pIndex] && reformAxis[pIndex].hasChild) {\n                    var axis = void 0;\n                    for (var _i = 0, _a = reformAxis[pIndex].members; _i < _a.length; _i++) {\n                        axis = _a[_i];\n                        if (axis.type === 'value') {\n                            isValue = true;\n                            break;\n                        }\n                    }\n                }\n                if (isValue && !reformAxis[tnum].isSum && reformAxis[tnum].members &&\n                    reformAxis[tnum].members.length === 0) {\n                    continue;\n                }\n                if (!data[tnum]) {\n                    data[tnum] = [];\n                    this.valueContent[actCnt] = {};\n                }\n                data[tnum][0] = reformAxis[tnum]\n                    = this.valueContent[actCnt][0] = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFormattedHeader(row, this);\n                if (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader)) {\n                    var hPos = tnum;\n                    var actpos = actCnt;\n                    var rowIndex = tnum;\n                    var isValueCellUpdated = false;\n                    if ((((!(level === 0 && this.measureIndex === 0) && !isLeastNode) || isLeastNode) && row.type === 'value' && !row.valueSort.axis) ||\n                        (level > this.measureIndex && row.axis === 'row' && row.valueSort.axis)) {\n                        var vln = 0;\n                        var isValueIndexFound = false;\n                        var rowUniqueName = row.valueSort.uniqueName ?\n                            row.valueSort.uniqueName.toString().split(this.valueSortSettings.headerDelimiter) : [];\n                        for (var cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {\n                            if (!isValueIndexFound) {\n                                for (vln = 0; vln < vlt; vln++) {\n                                    if (rowUniqueName.indexOf(this.dataSourceSettings.values[vln].name) > -1) {\n                                        isValueIndexFound = true;\n                                        isValueCellUpdated = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (level > this.measureIndex && row.axis === 'row' && row.valueSort.axis) {\n                                this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);\n                            }\n                            else {\n                                if (!reformAxis[pIndex]) {\n                                    isValueCellUpdated = false;\n                                    break;\n                                }\n                                var parentIndex = this.showSubTotalsAtBottom && valueParentIndex ? valueParentIndex : pIndex;\n                                this.updateRowData(reformAxis, columns, tnum, data, vln, parentIndex, cln, dln, actCnt, rTotal, cTotal);\n                            }\n                            dln = data[tnum].length;\n                        }\n                    }\n                    if (!isValueCellUpdated) {\n                        for (var cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {\n                            dln = data[tnum].length;\n                            data[hPos][dln] = this.valueContent[actpos][dln] = {\n                                axis: 'value', actualText: '', colSpan: 1,\n                                colIndex: dln, formattedText: '', hasChild: false\n                            };\n                        }\n                    }\n                    this.recursiveRowData(rows, reformAxis, columns, rowIndex, data, vlt, isLeastNode, rln, vlt, level, rTotal, cTotal);\n                }\n                else {\n                    for (var cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {\n                        var columnUniqueName = columns[cln].valueSort.uniqueName ?\n                            columns[cln].valueSort.uniqueName.toString().split(this.valueSortSettings.headerDelimiter) : [];\n                        for (var vln = 0; vln < vlt; vln++) {\n                            if (!this.valueAxis && !this.isLastHeaderHasMeasures) {\n                                if (columnUniqueName.indexOf(this.dataSourceSettings.values[vln].name) > -1) {\n                                    this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);\n                                    dln = data[tnum].length;\n                                }\n                            }\n                            else {\n                                this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);\n                                dln = data[tnum].length;\n                            }\n                        }\n                    }\n                    this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, 0, level, rTotal, cTotal);\n                }\n            }\n            else if (!isLeastNode) {\n                this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, 0, level, rTotal, cTotal);\n            }\n        }\n    };\n    PivotEngine.prototype.insertRowSubTotals = function (reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal) {\n        var isValueAxis = reformAxis[tnum].type ? reformAxis[tnum].type === 'value' &&\n            reformAxis[tnum].valueSort.levelName !== reformAxis[tnum].actualText : false;\n        if (reformAxis[tnum].hasChild && reformAxis[tnum].members.length > 0) {\n            var parentIndexes = [];\n            var subTotal = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(reformAxis[tnum]);\n            if (reformAxis[tnum].members[0].type === 'value') {\n                var startIndex = 0;\n                var valueCells = [];\n                var i = 1;\n                for (var _i = 0, _a = subTotal.members; _i < _a.length; _i++) {\n                    var axis = _a[_i];\n                    if (axis.type === 'value') {\n                        valueCells[valueCells.length] = axis;\n                    }\n                }\n                while (startIndex < valueCells.length) {\n                    var valueCell = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(valueCells[startIndex]);\n                    var index = void 0;\n                    for (i; i < reformAxis.length; i++) {\n                        if (reformAxis[i] && reformAxis[i].valueSort.levelName === valueCell.valueSort.levelName) {\n                            index = reformAxis.indexOf(reformAxis[i]);\n                            break;\n                        }\n                    }\n                    if (index > -1) {\n                        parentIndexes[parentIndexes.length] = index;\n                    }\n                    valueCell.formattedText = subTotal.formattedText + ' ' + valueCell.formattedText;\n                    valueCell.isSum = true;\n                    valueCell.members = [];\n                    this.getTableData([valueCell], reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal);\n                    startIndex++;\n                }\n            }\n            else {\n                subTotal.formattedText = subTotal.formattedText + ' Total';\n                subTotal.members = [];\n                subTotal.isDrilled = false;\n                subTotal.hasChild = false;\n                subTotal.isSum = true;\n                subTotal.type = 'sum';\n                var parentIndex = isValueAxis ? this.getParentIndex(reformAxis, subTotal) : 0;\n                this.getTableData([subTotal], reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal, parentIndex);\n                parentIndexes = [tnum];\n            }\n            for (var index = 0; index < parentIndexes.length; index++) {\n                var parentInfo = data[parentIndexes[index]];\n                parentInfo = parentInfo.map(function (dataValue) {\n                    dataValue.formattedText = dataValue.colIndex === 0 ? dataValue.formattedText : '';\n                    return dataValue;\n                });\n                data[parentIndexes[index]] = parentInfo;\n            }\n        }\n    };\n    PivotEngine.prototype.getParentIndex = function (reformAxis, axis) {\n        var parentIndex = 0;\n        for (var i = reformAxis.length - 1; i > 0; i--) {\n            if (axis.level === reformAxis[i].level && reformAxis[i].index) {\n                parentIndex = i;\n                break;\n            }\n        }\n        return parentIndex;\n    };\n    PivotEngine.prototype.getAggregatedHeaders = function (rows, columns, rMembers, cMembers, values) {\n        this.selectedHeaders = { selectedHeader: [], values: [] };\n        for (var vlt = values.length, vln = 0; vln < vlt; vln++) {\n            switch (values[vln].type) {\n                case 'DifferenceFrom':\n                case 'PercentageOfDifferenceFrom':\n                    {\n                        var baseField = void 0;\n                        var baseItem = void 0;\n                        this.selectedHeaders.values.push(values[vln].name);\n                        if (values[vln].baseField && values[vln].baseItem) {\n                            baseField = values[vln].baseField;\n                            baseItem = values[vln].baseItem;\n                        }\n                        else if (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) &&\n                            columns.length > 0) {\n                            baseField = columns[0].name;\n                            baseItem = Object.keys(this.fieldList[columns[0].name].members)[0];\n                        }\n                        else if (rows.length > 0) {\n                            baseField = rows[0].name;\n                            baseItem = Object.keys(this.fieldList[rows[0].name].members)[0];\n                        }\n                        var isHeaderSelected = false;\n                        for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {\n                            var row = rows_2[_i];\n                            if (row.name === baseField) {\n                                this.getAggregatedHeaderData(rMembers, values[vln].name, baseItem, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln);\n                                isHeaderSelected = true;\n                                break;\n                            }\n                        }\n                        if (!isHeaderSelected) {\n                            for (var _a = 0, columns_1 = columns; _a < columns_1.length; _a++) {\n                                var column = columns_1[_a];\n                                if (column.name === baseField) {\n                                    this.getAggregatedHeaderData(cMembers, values[vln].name, baseItem, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                case 'PercentageOfParentRowTotal':\n                case 'PercentageOfParentColumnTotal':\n                    {\n                        this.selectedHeaders.values.push(values[vln].name);\n                        this.getAggregatedHeaderData((values[vln].type === 'PercentageOfParentRowTotal' ? rMembers : cMembers), values[vln].name, undefined, false, (values[vln].type === 'PercentageOfParentRowTotal' ? 'row' : 'column'), values[vln].type, this.selectedHeaders.selectedHeader, vln);\n                    }\n                    break;\n                case 'RunningTotals':\n                    {\n                        this.selectedHeaders.values.push(values[vln].name);\n                        this.getAggregatedHeaderData((this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) ? cMembers : rMembers), values[vln].name, undefined, false, (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) ? 'column' : 'row'), values[vln].type, this.selectedHeaders.selectedHeader, vln);\n                    }\n                    break;\n                case 'PercentageOfParentTotal':\n                    {\n                        var baseField = void 0;\n                        this.selectedHeaders.values.push(values[vln].name);\n                        if (values[vln].baseField) {\n                            baseField = values[vln].baseField;\n                        }\n                        else if (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) &&\n                            columns.length > 0) {\n                            baseField = columns[0].name;\n                        }\n                        else if (rows.length > 0) {\n                            baseField = rows[0].name;\n                        }\n                        var isHeaderSelected = false;\n                        for (var len = rows.length, i = 0; i < len; i++) {\n                            if (rows[i].name === baseField) {\n                                var level = i >= this.measureIndex ? i + 1 : i;\n                                this.getAggregatedHeaderData(rMembers, values[vln].name, undefined, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln, level);\n                                isHeaderSelected = true;\n                                break;\n                            }\n                        }\n                        if (!isHeaderSelected) {\n                            for (var len = columns.length, i = 0; i < len; i++) {\n                                if (columns[i].name === baseField) {\n                                    var level = i;\n                                    if (!this.valueAxis && !this.isLastHeaderHasMeasures) {\n                                        level = i >= this.measureIndex ? i + 1 : i;\n                                    }\n                                    this.getAggregatedHeaderData(cMembers, values[vln].name, undefined, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln, level);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    break;\n            }\n        }\n    };\n    PivotEngine.prototype.getAggregatedHeaderData = function (headers, name, baseItem, isChildren, type, aggregateType, selectedHeaders, vln, level) {\n        for (var _i = 0, headers_1 = headers; _i < headers_1.length; _i++) {\n            var rln = headers_1[_i];\n            switch (aggregateType) {\n                case 'DifferenceFrom':\n                case 'PercentageOfDifferenceFrom':\n                    {\n                        var levelName = rln.valueSort.levelName.toString().split(this.valueSortSettings.headerDelimiter);\n                        if (levelName.indexOf(baseItem) !== -1) {\n                            var actualHeaders = [];\n                            if (!isChildren && type === 'row') {\n                                for (var _a = 0, headers_2 = headers; _a < headers_2.length; _a++) {\n                                    var header = headers_2[_a];\n                                    if (header.level >= rln.level) {\n                                        actualHeaders.push(header);\n                                    }\n                                }\n                            }\n                            selectedHeaders.push(this.updateSelectedHeaders(baseItem, rln.level, type, isChildren, name, aggregateType, rln.valueSort.levelName, (isChildren ? [rln] : (type === 'column' ? headers : actualHeaders)), vln + 1));\n                            if (rln.members.length > 0) {\n                                var isValuesAvail = false;\n                                var members = [];\n                                if (type === 'row') {\n                                    for (var _b = 0, _c = rln.members; _b < _c.length; _b++) {\n                                        var member = _c[_b];\n                                        if (member.type === 'value' && member.members.length === 0) {\n                                            isValuesAvail = true;\n                                        }\n                                        else {\n                                            members.push(member);\n                                            isValuesAvail = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ((!isValuesAvail && members.length > 0) || type === 'column') {\n                                    this.getAggregatedHeaderData(type === 'column' ? rln.members : members, name, baseItem, true, type, aggregateType, selectedHeaders[selectedHeaders.length - 1].childMembers, vln);\n                                }\n                            }\n                        }\n                        else if (rln.members.length > 0) {\n                            this.getAggregatedHeaderData(rln.members, name, baseItem, false, type, aggregateType, selectedHeaders, vln);\n                        }\n                    }\n                    break;\n                case 'RunningTotals':\n                case 'PercentageOfParentRowTotal':\n                case 'PercentageOfParentColumnTotal':\n                    {\n                        if (rln.type === 'grand sum') {\n                            selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, headers, vln + 1));\n                        }\n                        else {\n                            if (rln.members.length > 0) {\n                                selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, rln.members, vln + 1));\n                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln);\n                            }\n                        }\n                    }\n                    break;\n                case 'PercentageOfParentTotal':\n                    {\n                        if (rln.type !== 'grand sum') {\n                            if ((rln.valueSort.levelName.split(this.valueSortSettings.headerDelimiter).length - 1) === level) {\n                                if (rln.members.length > 0) {\n                                    if (isChildren) {\n                                        var aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;\n                                        for (var _d = 0, _e = rln.members; _d < _e.length; _d++) {\n                                            var member = _e[_d];\n                                            aggregateHeaders.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, member, null, true));\n                                        }\n                                    }\n                                    else {\n                                        var children = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], rln.members, null, true);\n                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, children, vln + 1));\n                                        var aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;\n                                        aggregateHeaders.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, rln, null, true));\n                                    }\n                                    this.getAggregatedHeaderData(rln.members, name, undefined, true, type, aggregateType, selectedHeaders, vln, level + 1);\n                                }\n                                else {\n                                    if (!isChildren) {\n                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, [rln], vln + 1));\n                                    }\n                                }\n                            }\n                            else if (rln.members.length > 0) {\n                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln, level);\n                            }\n                        }\n                    }\n                    break;\n            }\n        }\n    };\n    PivotEngine.prototype.updateSelectedHeaders = function (baseItem, level, type, isChildren, name, aggregateType, levelName, headers, vCount) {\n        var headerData = {\n            name: baseItem,\n            level: level,\n            axis: type,\n            isChild: isChildren,\n            value: name,\n            type: aggregateType,\n            uniqueName: levelName,\n            aggregateHeaders: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], headers, null, true),\n            childMembers: [],\n            valueCount: vCount\n        };\n        return headerData;\n    };\n    PivotEngine.prototype.applyAdvancedAggregate = function (rowheads, colheads, data) {\n        this.aggregatedValueMatrix = [];\n        if (this.selectedHeaders.values.length > 0) {\n            var pivotIndex = {};\n            var colIndex = [];\n            var rowIndex = [];\n            var isIndexFilled = false;\n            for (var rlt = data.length, rln = 0; rln < rlt; rln++) {\n                if (data[rln] !== undefined && data[rln][0] !== undefined) {\n                    if (!isIndexFilled) {\n                        for (var clt = data[rln].length, cln = 0; cln < clt; cln++) {\n                            var actualText = data[rln][cln].actualText;\n                            if (data[rln][cln].axis === 'value' &&\n                                this.selectedHeaders.values.indexOf(actualText) !== -1) {\n                                colIndex.push(cln);\n                                isIndexFilled = true;\n                            }\n                        }\n                    }\n                    var isTotal = this.showSubTotalsAtBottom && data[rln][0].isDrilled &&\n                        data[rln][0].hasChild;\n                    if (!isTotal) {\n                        if (colIndex.length > 0 && data[rln][colIndex[0]].axis === 'value' &&\n                            this.selectedHeaders.values.indexOf(data[rln][colIndex[0]].actualText) !== -1) {\n                            rowIndex.push(rln);\n                            for (var _i = 0, colIndex_1 = colIndex; _i < colIndex_1.length; _i++) {\n                                var index = colIndex_1[_i];\n                                pivotIndex[rln + ',' + index] = [rln, index];\n                            }\n                        }\n                    }\n                }\n            }\n            this.updateAggregates(rowheads, colheads, data, this.selectedHeaders.selectedHeader, colIndex, rowIndex, pivotIndex);\n            var indexCollection = Object.keys(pivotIndex);\n            for (var _a = 0, indexCollection_1 = indexCollection; _a < indexCollection_1.length; _a++) {\n                var index = indexCollection_1[_a];\n                var currentSet = data[pivotIndex[index][0]][pivotIndex[index][1]];\n                // currentSet.formattedText = '0';\n                currentSet.formattedText = (this.selectedHeaders.selectedHeader.length > 0 ? this.emptyCellTextContent : '#N/A');\n                if (!this.aggregatedValueMatrix[pivotIndex[index][0]]) {\n                    this.aggregatedValueMatrix[pivotIndex[index][0]] = [];\n                }\n                this.aggregatedValueMatrix[pivotIndex[index][0]][pivotIndex[index][1]] = 0;\n            }\n            this.updatePivotValues(true);\n        }\n        else {\n            return;\n        }\n    };\n    PivotEngine.prototype.updateAggregates = function (rowheads, colheads, data, selectedHeaders, colIndex, rowIndex, pivotIndex) {\n        for (var _i = 0, selectedHeaders_1 = selectedHeaders; _i < selectedHeaders_1.length; _i++) {\n            var headers = selectedHeaders_1[_i];\n            var selectedHeaderCollection = headers.aggregateHeaders;\n            var name_3 = headers.value;\n            // let valueCount: number = (this.valueAxis && (this.isMutiMeasures || this.dataSourceSettings.alwaysShowValueHeader) ? headers.valueCount : 0);\n            var aggregateType = headers.type;\n            var uniqueName = headers.uniqueName;\n            var axis = headers.axis;\n            var isRowBaseField = axis === 'row' ? true : false;\n            var activeValues = void 0;\n            var indexCollection = [];\n            var activeColumn = [];\n            var columnHeaders = [];\n            var rowindexCollection = [];\n            var selectedRowValues = [];\n            var selectedColumnValues = [];\n            if ((['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal', 'RunningTotals']).indexOf(headers.type) !== -1) {\n                if (isRowBaseField) {\n                    if (headers.type !== 'RunningTotals') {\n                        for (var _a = 0, rowIndex_1 = rowIndex; _a < rowIndex_1.length; _a++) {\n                            var rln = rowIndex_1[_a];\n                            if (rowheads[rln] !== undefined) {\n                                if (rowheads[rln].valueSort[uniqueName]) {\n                                    activeValues = rowheads[rln];\n                                    if (this.valueAxis === 0 || (this.valueAxis && data[rln] && data[rln][1] &&\n                                        data[rln][1].actualText === name_3)) {\n                                        selectedRowValues = data[rln];\n                                    }\n                                    else {\n                                        selectedRowValues = [];\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    for (var len_5 = data.length, i = 0; i < len_5; i++) {\n                        if (data[i] !== undefined && data[i][0] === undefined) {\n                            columnHeaders.push(data[i]);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    var len = columnHeaders.length;\n                    while (len--) {\n                        var axisObj = columnHeaders[len][colIndex[0]];\n                        var cLevelName = axisObj.actualText;\n                        if (this.selectedHeaders.values.indexOf(cLevelName) === -1) {\n                            activeColumn = columnHeaders[len];\n                            len = 0;\n                        }\n                    }\n                    if (headers.type !== 'RunningTotals') {\n                        for (var clt = activeColumn.length, cln = 0; cln < clt; cln++) {\n                            var isSelectedColumn = false;\n                            if (activeColumn[cln] !== undefined && activeColumn[cln].valueSort[uniqueName]) {\n                                activeValues = activeColumn[cln];\n                                for (var len_6 = data.length, i = 0; i < len_6; i++) {\n                                    var axisObj = data[i];\n                                    if (axisObj !== undefined && axisObj[0] !== undefined && axisObj[cln].axis === 'value' && this.selectedHeaders.values.indexOf(axisObj[cln].actualText) !== -1) {\n                                        isSelectedColumn = true;\n                                        selectedColumnValues[i] = axisObj[cln];\n                                        rowindexCollection.push(i);\n                                    }\n                                }\n                                if (isSelectedColumn) {\n                                    break;\n                                }\n                            }\n                        }\n                        if (selectedColumnValues.length === 0 && rowindexCollection.length === 0) {\n                            for (var clt = activeColumn.length, cln = 0; cln < clt; cln++) {\n                                var isSelectedColumn = false;\n                                if (activeColumn[cln] !== undefined &&\n                                    activeColumn[cln].valueSort.levelName.indexOf(uniqueName) === 0) {\n                                    activeValues = activeColumn[cln];\n                                    for (var lnt = data.length, j = 0; j < lnt; j++) {\n                                        var axisObj = data[j];\n                                        if (axisObj !== undefined && axisObj[0] !== undefined && axisObj[cln].axis === 'value' && this.selectedHeaders.values.indexOf(axisObj[cln].actualText) !== -1) {\n                                            isSelectedColumn = true;\n                                            // selectedColumnValues[i as number] = axisObj[cln as number] as IAxisSet;\n                                            rowindexCollection.push(j);\n                                        }\n                                    }\n                                    if (isSelectedColumn) {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            switch (headers.type) {\n                case 'DifferenceFrom':\n                case 'PercentageOfDifferenceFrom':\n                    {\n                        var isChildren = headers.isChild;\n                        if (isRowBaseField) {\n                            if (!isChildren) {\n                                for (var _b = 0, selectedHeaderCollection_1 = selectedHeaderCollection; _b < selectedHeaderCollection_1.length; _b++) {\n                                    var item = selectedHeaderCollection_1[_b];\n                                    for (var _c = 0, rowIndex_2 = rowIndex; _c < rowIndex_2.length; _c++) {\n                                        var rln = rowIndex_2[_c];\n                                        if (rowheads[rln] !== undefined) {\n                                            if (rowheads[rln].valueSort[item.valueSort.levelName] &&\n                                                rowheads[rln].level === activeValues.level && rowheads[rln].type !== 'grand sum') {\n                                                for (var _d = 0, colIndex_2 = colIndex; _d < colIndex_2.length; _d++) {\n                                                    var index = colIndex_2[_d];\n                                                    var currentSet = data[rln][index];\n                                                    if (currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                        indexCollection.push([rln, index]);\n                                                        if (pivotIndex[rln + ',' + index]) {\n                                                            delete pivotIndex[rln + ',' + index];\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            else {\n                                var uniqueLevelName = uniqueName.split(this.valueSortSettings.headerDelimiter);\n                                for (var _e = 0, rowIndex_3 = rowIndex; _e < rowIndex_3.length; _e++) {\n                                    var rlen = rowIndex_3[_e];\n                                    if (rowheads[rlen] !== undefined) {\n                                        var levelName = rowheads[rlen].valueSort.levelName.split(this.valueSortSettings.headerDelimiter);\n                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 && activeValues &&\n                                            rowheads[rlen].level === activeValues.level) {\n                                            for (var _f = 0, colIndex_3 = colIndex; _f < colIndex_3.length; _f++) {\n                                                var index = colIndex_3[_f];\n                                                var currentSet = data[rlen][index];\n                                                if (currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                    indexCollection.push([rlen, index]);\n                                                    if (pivotIndex[rlen + ',' + index]) {\n                                                        delete pivotIndex[rlen + ',' + index];\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            for (var _g = 0, indexCollection_2 = indexCollection; _g < indexCollection_2.length; _g++) {\n                                var index = indexCollection_2[_g];\n                                var currentSet = data[index[0]][index[1]];\n                                var actualValue = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(selectedRowValues[index[1]].actualValue) ? 0 : selectedRowValues[index[1]].actualValue;\n                                // let cVal: number = currentSet.value - (selectedRowValues[index[1]] as IAxisSet).value;\n                                var cVal = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentSet.actualValue) ? 0 : currentSet.actualValue) - actualValue;\n                                cVal = isNaN(cVal) ? 0 : (currentSet.value === 0 && selectedRowValues[index[1]].value === 0) ? 0 : cVal;\n                                if (!this.aggregatedValueMatrix[index[0]]) {\n                                    this.aggregatedValueMatrix[index[0]] = [];\n                                }\n                                if (aggregateType === 'DifferenceFrom') {\n                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;\n                                    currentSet.formattedText = cVal === 0 ? this.emptyCellTextContent :\n                                        this.getFormattedValue(cVal, name_3).formattedText;\n                                }\n                                else {\n                                    // cVal = ((selectedRowValues[index[1]] as IAxisSet).value === 0 ?\n                                    // 0 : (cVal / (selectedRowValues[index[1]] as IAxisSet).value));\n                                    cVal = (actualValue === 0 ? 0 : (cVal / actualValue));\n                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;\n                                    currentSet.formattedText = currentSet.showSubTotals ? (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent) : currentSet.formattedText;\n                                }\n                            }\n                        }\n                        else {\n                            if (!isChildren) {\n                                for (var _h = 0, selectedHeaderCollection_2 = selectedHeaderCollection; _h < selectedHeaderCollection_2.length; _h++) {\n                                    var item = selectedHeaderCollection_2[_h];\n                                    for (var clt = activeColumn.length, cln = 0; cln < clt; cln++) {\n                                        var isSelectedColumn = false;\n                                        if (activeColumn[cln] !== undefined &&\n                                            activeColumn[cln].valueSort[item.valueSort.levelName] && activeValues &&\n                                            activeColumn[cln].level === activeValues.level && activeColumn[cln].type !== 'grand sum') {\n                                            for (var _j = 0, rowindexCollection_1 = rowindexCollection; _j < rowindexCollection_1.length; _j++) {\n                                                var index = rowindexCollection_1[_j];\n                                                var currentSet = data[index][cln];\n                                                if (currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                    isSelectedColumn = true;\n                                                    indexCollection.push([index, cln]);\n                                                    if (pivotIndex[index + ',' + cln]) {\n                                                        delete pivotIndex[index + ',' + cln];\n                                                    }\n                                                }\n                                            }\n                                            if (isSelectedColumn) {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            else {\n                                var uniqueLevelName = uniqueName.split(this.valueSortSettings.headerDelimiter);\n                                for (var clt = activeColumn.length, clen = 0; clen < clt; clen++) {\n                                    var isSelectedColumn = false;\n                                    if (activeColumn[clen] !== undefined) {\n                                        var levelName = activeColumn[clen].valueSort.levelName.split(this.valueSortSettings.headerDelimiter);\n                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 &&\n                                            activeColumn[clen].level === activeValues.level) {\n                                            for (var _k = 0, rowindexCollection_2 = rowindexCollection; _k < rowindexCollection_2.length; _k++) {\n                                                var index = rowindexCollection_2[_k];\n                                                var currentSet = data[index][clen];\n                                                if (currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                    isSelectedColumn = true;\n                                                    indexCollection.push([index, clen]);\n                                                    if (pivotIndex[index + ',' + clen]) {\n                                                        delete pivotIndex[index + ',' + clen];\n                                                    }\n                                                }\n                                            }\n                                            if (isSelectedColumn) {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            var selectedColumn = void 0;\n                            if (selectedColumnValues.length === 0) {\n                                selectedColumn = this.getSelectedColumn(headers.uniqueName, colheads);\n                            }\n                            for (var _l = 0, indexCollection_3 = indexCollection; _l < indexCollection_3.length; _l++) {\n                                var index = indexCollection_3[_l];\n                                var currentSet = data[index[0]][index[1]];\n                                var selectedColumnValue = 0;\n                                if (selectedColumnValues.length === 0) {\n                                    var selectedRow = this.getSelectedRow(currentSet.rowHeaders, rowheads);\n                                    selectedColumnValue = this.getAggregateValue(selectedRow.index, selectedColumn.indexObject, this.fieldList[name_3].index, headers.type, false);\n                                }\n                                else {\n                                    selectedColumnValue = selectedColumnValues[index[0]].value;\n                                }\n                                var cVal = currentSet.value - selectedColumnValue;\n                                cVal = isNaN(cVal) ? 0 : cVal;\n                                if (!this.aggregatedValueMatrix[index[0]]) {\n                                    this.aggregatedValueMatrix[index[0]] = [];\n                                }\n                                if (aggregateType === 'DifferenceFrom') {\n                                    currentSet.formattedText = cVal === 0 ? this.emptyCellTextContent :\n                                        this.getFormattedValue(cVal, name_3).formattedText;\n                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;\n                                }\n                                else {\n                                    cVal = (selectedColumnValues[index[0]].value === 0 ?\n                                        0 : (cVal / selectedColumnValues[index[0]].value));\n                                    currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent);\n                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;\n                                }\n                            }\n                        }\n                        if (headers.childMembers.length > 0) {\n                            this.updateAggregates(rowheads, colheads, data, headers.childMembers, colIndex, rowIndex, pivotIndex);\n                        }\n                    }\n                    break;\n                case 'PercentageOfParentRowTotal':\n                case 'PercentageOfParentColumnTotal':\n                case 'PercentageOfParentTotal':\n                    {\n                        if (isRowBaseField) {\n                            for (var _m = 0, selectedHeaderCollection_3 = selectedHeaderCollection; _m < selectedHeaderCollection_3.length; _m++) {\n                                var item = selectedHeaderCollection_3[_m];\n                                for (var _o = 0, rowIndex_4 = rowIndex; _o < rowIndex_4.length; _o++) {\n                                    var i = rowIndex_4[_o];\n                                    if (rowheads[i] !== undefined) {\n                                        if (rowheads[i].valueSort[item.valueSort.levelName] &&\n                                            rowheads[i].level === item.level) {\n                                            for (var _p = 0, colIndex_4 = colIndex; _p < colIndex_4.length; _p++) {\n                                                var index = colIndex_4[_p];\n                                                var currentSet = data[i][index];\n                                                if (currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                    indexCollection.push([i, index]);\n                                                    if (pivotIndex[i + ',' + index]) {\n                                                        delete pivotIndex[i + ',' + index];\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            for (var _q = 0, indexCollection_4 = indexCollection; _q < indexCollection_4.length; _q++) {\n                                var i = indexCollection_4[_q];\n                                var currentSet = data[i[0]][i[1]];\n                                // let cVal: number = currentSet.value / (selectedRowValues[i[1]] as IAxisSet).value;\n                                var selectedRowValue = 0;\n                                if (selectedRowValues.length === 0 && activeValues) {\n                                    selectedRowValue = this.getAggregateValue(activeValues.index, colheads[i[1] - 1].indexObject, this.fieldList[name_3].index, headers.type, false);\n                                }\n                                else {\n                                    selectedRowValue = selectedRowValues[i[1]] ? selectedRowValues[i[1]].actualValue : 0;\n                                }\n                                var cVal = currentSet.value / selectedRowValue;\n                                cVal = isNaN(cVal) ? 0 : cVal;\n                                currentSet.formattedText = currentSet.showSubTotals ? (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent) : currentSet.formattedText;\n                                if (!this.aggregatedValueMatrix[i[0]]) {\n                                    this.aggregatedValueMatrix[i[0]] = [];\n                                }\n                                this.aggregatedValueMatrix[i[0]][i[1]] = cVal;\n                            }\n                        }\n                        else {\n                            for (var _r = 0, selectedHeaderCollection_4 = selectedHeaderCollection; _r < selectedHeaderCollection_4.length; _r++) {\n                                var item = selectedHeaderCollection_4[_r];\n                                for (var clt = activeColumn.length, j = 0; j < clt; j++) {\n                                    var isSelectedColumn = false;\n                                    if (activeColumn[j] !== undefined &&\n                                        activeColumn[j].valueSort[item.valueSort.levelName]) {\n                                        for (var _s = 0, rowindexCollection_3 = rowindexCollection; _s < rowindexCollection_3.length; _s++) {\n                                            var index = rowindexCollection_3[_s];\n                                            var isTotals = this.showSubTotalsAtBottom && data[index][0].isDrilled && data[index][0].hasChild;\n                                            if (!isTotals) {\n                                                var currentSet = data[index][j];\n                                                if (currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                    isSelectedColumn = true;\n                                                    indexCollection.push([index, j]);\n                                                    if (pivotIndex[index + ',' + j]) {\n                                                        delete pivotIndex[index + ',' + j];\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (isSelectedColumn) {\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                            var selectedCol = void 0;\n                            if (selectedColumnValues.length === 0) {\n                                selectedCol = this.getSelectedColumn(headers.uniqueName, colheads);\n                            }\n                            for (var _t = 0, indexCollection_5 = indexCollection; _t < indexCollection_5.length; _t++) {\n                                var i = indexCollection_5[_t];\n                                var currentSet = data[i[0]][i[1]];\n                                var selectedColValue = 0;\n                                if (selectedColumnValues.length === 0) {\n                                    var selectedRow = this.getSelectedRow(currentSet.rowHeaders, rowheads);\n                                    selectedColValue = this.getAggregateValue(selectedRow.index, selectedCol.indexObject, this.fieldList[name_3].index, headers.type, false);\n                                }\n                                else {\n                                    selectedColValue = selectedColumnValues[i[0]].value;\n                                }\n                                var val = currentSet.value / selectedColValue;\n                                val = isNaN(val) ? 0 : val;\n                                currentSet.formattedText = (val !== 0 ? this.globalize.formatNumber(val, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent);\n                                if (!this.aggregatedValueMatrix[i[0]]) {\n                                    this.aggregatedValueMatrix[i[0]] = [];\n                                }\n                                this.aggregatedValueMatrix[i[0]][i[1]] = val;\n                            }\n                        }\n                    }\n                    break;\n                case 'RunningTotals':\n                    {\n                        if (isRowBaseField) {\n                            for (var _u = 0, colIndex_5 = colIndex; _u < colIndex_5.length; _u++) {\n                                var index = colIndex_5[_u];\n                                var cVal = 0;\n                                for (var _v = 0, selectedHeaderCollection_5 = selectedHeaderCollection; _v < selectedHeaderCollection_5.length; _v++) {\n                                    var item = selectedHeaderCollection_5[_v];\n                                    for (var _w = 0, rowIndex_5 = rowIndex; _w < rowIndex_5.length; _w++) {\n                                        var rlen = rowIndex_5[_w];\n                                        if (rowheads[rlen] !== undefined) {\n                                            var currentSet = data[rlen][index];\n                                            if (rowheads[rlen] !== undefined && rowheads[rlen].valueSort[item.valueSort.levelName] && rowheads[rlen].level === item.level && currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                if (rowheads[rlen].type !== 'grand sum') {\n                                                    cVal += (!currentSet.showSubTotals && !(!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentSet.actualValue) && isNaN(currentSet.actualValue))) ?\n                                                        currentSet.actualValue : (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentSet.value) &&\n                                                        !isNaN(currentSet.value)) ? currentSet.value : null;\n                                                    currentSet.formattedText = currentSet.showSubTotals ? (cVal === 0 &&\n                                                        (currentSet.actualValue && currentSet.actualValue !== 0) ? '' :\n                                                        this.getFormattedValue(cVal, name_3).formattedText) : currentSet.formattedText;\n                                                    if (!this.aggregatedValueMatrix[rlen]) {\n                                                        this.aggregatedValueMatrix[rlen] = [];\n                                                    }\n                                                    this.aggregatedValueMatrix[rlen][index] = cVal;\n                                                }\n                                                if (pivotIndex[rlen + ',' + index]) {\n                                                    delete pivotIndex[rlen + ',' + index];\n                                                }\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            for (var _x = 0, rowIndex_6 = rowIndex; _x < rowIndex_6.length; _x++) {\n                                var rln = rowIndex_6[_x];\n                                if (data[rln] !== undefined) {\n                                    var cVal = 0;\n                                    for (var _y = 0, selectedHeaderCollection_6 = selectedHeaderCollection; _y < selectedHeaderCollection_6.length; _y++) {\n                                        var item = selectedHeaderCollection_6[_y];\n                                        var subTotal = (rowheads[rln].hasChild && rowheads[rln].isDrilled &&\n                                            ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rowheads[rln].showSubTotals) &&\n                                                !rowheads[rln].showSubTotals) || !this.dataSourceSettings.showSubTotals ||\n                                                !this.dataSourceSettings.showRowSubTotals));\n                                        for (var clt = activeColumn.length, cln = 0; cln < clt; cln++) {\n                                            var currentSet = data[rln][cln];\n                                            if (activeColumn[cln] !== undefined &&\n                                                activeColumn[cln].valueSort[item.valueSort.levelName] &&\n                                                currentSet.axis === 'value' && currentSet.actualText === name_3) {\n                                                if (activeColumn[cln].type !== 'grand sum') {\n                                                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentSet.value)) {\n                                                        cVal += currentSet.value;\n                                                    }\n                                                    currentSet.formattedText = subTotal ? '' : this.getFormattedValue(cVal, name_3).formattedText;\n                                                    if (!this.aggregatedValueMatrix[rln]) {\n                                                        this.aggregatedValueMatrix[rln] = [];\n                                                    }\n                                                    this.aggregatedValueMatrix[rln][cln] = cVal;\n                                                }\n                                                if (pivotIndex[rln + ',' + cln]) {\n                                                    delete pivotIndex[rln + ',' + cln];\n                                                }\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    break;\n            }\n        }\n    };\n    PivotEngine.prototype.getSelectedColumn = function (name, colheads) {\n        var set = { axis: 'column', index: [], indexObject: {} };\n        for (var _i = 0, colheads_1 = colheads; _i < colheads_1.length; _i++) {\n            var head = colheads_1[_i];\n            if (head && head.valueSort && head.valueSort.levelName.indexOf(name) === 0) {\n                set.index = set.index.concat(head.index).sort(function (a, b) { return a - b; });\n                set.indexObject = __assign({}, set.indexObject, head.indexObject);\n            }\n        }\n        return set;\n    };\n    PivotEngine.prototype.getSelectedRow = function (name, rowheads) {\n        for (var _i = 0, rowheads_1 = rowheads; _i < rowheads_1.length; _i++) {\n            var head = rowheads_1[_i];\n            if (head) {\n                if (head.valueSort && head.valueSort.levelName === name) {\n                    return head;\n                }\n                else if (name === '' && head.type === 'grand sum') {\n                    return head;\n                }\n            }\n        }\n        return null;\n    };\n    PivotEngine.prototype.recursiveRowData = function (rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, vln, level, rTotal, cTotal) {\n        if (!isLeastNode) {\n            this.getTableData(reformAxis[tnum].members, reformAxis, columns, tnum, data, vlt, level + 1, rTotal, cTotal);\n        }\n        if (this.showSubTotalsAtBottom && (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rows[rln].showSubTotals) ? rows[rln].showSubTotals : true)) {\n            this.insertRowSubTotals(reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal);\n        }\n        if (!this.isPagingOrVirtualizationEnabled) {\n            reformAxis[tnum].members = [];\n        }\n    };\n    PivotEngine.prototype.updateRowData = function (rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal) {\n        var mPos = this.fieldList[this.dataSourceSettings.values[vln].name].index;\n        var aggregate = this.fieldList[this.dataSourceSettings.values[vln].name].aggregateType;\n        var field = this.dataSourceSettings.values[vln].name;\n        var gTotalIndex = [];\n        var totalValues = {};\n        var value = 0;\n        var actualValue = 0;\n        // let isLeast: boolean = isLeastNode && (vln === vlt - 1);\n        switch (aggregate) {\n            case 'Index':\n                {\n                    gTotalIndex = [\n                        [rows[rln], columns[cln]], [rows[rln], cTotal],\n                        [rTotal, columns[cln]], [rTotal, cTotal]\n                    ];\n                    var valueContent = ['cVal', 'rTotalVal', 'cTotalVal', 'gTotalVal'];\n                    var i = 0;\n                    for (var _i = 0, gTotalIndex_1 = gTotalIndex; _i < gTotalIndex_1.length; _i++) {\n                        var rIndex = gTotalIndex_1[_i];\n                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate, i === 0 ? false : true);\n                        i++;\n                    }\n                    var val = ((totalValues.cVal) * (totalValues.gTotalVal)) / ((totalValues.rTotalVal) * (totalValues.cTotalVal));\n                    value = (rows[rln].members.length > 0 && rows[rln].hasChild && rows[rln].isDrilled &&\n                        ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||\n                            !this.dataSourceSettings.showRowSubTotals || !this.dataSourceSettings.showSubTotals)) ? undefined :\n                        ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));\n                    actualValue = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));\n                }\n                break;\n            case 'PercentageOfGrandTotal':\n            case 'PercentageOfColumnTotal':\n            case 'PercentageOfRowTotal':\n                {\n                    gTotalIndex = [[rows[rln], columns[cln]]];\n                    gTotalIndex.push((aggregate === 'PercentageOfGrandTotal' ?\n                        [rTotal, cTotal] : (aggregate === 'PercentageOfColumnTotal' ? [rTotal, columns[cln]] :\n                        [rows[rln], cTotal])));\n                    var valueContent = ['cVal', 'gTotalVal'];\n                    var i = 0;\n                    for (var _a = 0, gTotalIndex_2 = gTotalIndex; _a < gTotalIndex_2.length; _a++) {\n                        var rIndex = gTotalIndex_2[_a];\n                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate, i === 0 ? false : true);\n                        i++;\n                    }\n                    var val = ((totalValues.cVal) / (totalValues.gTotalVal));\n                    value = (rows[rln].members.length > 0 && rows[rln].hasChild && rows[rln].isDrilled &&\n                        ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||\n                            !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals)) ? undefined :\n                        ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));\n                    actualValue = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));\n                }\n                break;\n            default:\n                {\n                    var val = this.getAggregateValue(rows[rln].index, columns[cln].indexObject, mPos, aggregate, false);\n                    value = (rows[rln].members.length > 0 && rows[rln].hasChild && rows[rln].isDrilled &&\n                        ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||\n                            !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals)) ? undefined : val;\n                    actualValue = val;\n                }\n                break;\n        }\n        var cellDetails = {\n            fieldName: this.dataSourceSettings.values[vln].name, row: rows[rln], column: columns[cln],\n            value: value,\n            cellSets: this.getValueCellInfo ? this.getCellSet(this.rawIndexObject) : [],\n            rowCellType: (rows[rln].hasChild && rows[rln].isDrilled ? 'subTotal' : rows[rln].type === 'grand sum' ? 'grandTotal' : 'value'),\n            columnCellType: (columns[cln].hasChild && columns[cln].isDrilled ? 'subTotal' : columns[cln].type === 'grand sum' ? 'grandTotal' : 'value'),\n            aggregateType: aggregate, skipFormatting: false\n        };\n        if (this.getValueCellInfo) {\n            this.getValueCellInfo(cellDetails);\n        }\n        value = cellDetails.value;\n        var isSum = rows[rln].hasChild || columns[cln].hasChild || rows[rln].type === 'grand sum' ||\n            columns[cln].type === 'grand sum' || (this.showSubTotalsAtBottom && rows[rln].isSum);\n        var isGrand = rows[rln].type === 'grand sum' || columns[cln].type === 'grand sum';\n        var subTotal = (rows[rln].members.length > 0 && rows[rln].hasChild &&\n            rows[rln].isDrilled && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rows[rln].showSubTotals) &&\n            !rows[rln].showSubTotals) || !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals));\n        var formattedText = subTotal ?\n            '' : (value === undefined) ? this.emptyCellTextContent :\n            (aggregate === 'Count' || aggregate === 'DistinctCount') ? value.toLocaleString() :\n                this.getFormattedValue(value, field).formattedText;\n        if (!isNaN(value) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value) && (['PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal']).indexOf(aggregate) >= 0) {\n            formattedText = this.globalize.formatNumber(value, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, cellDetails.fieldName) });\n        }\n        else if (!subTotal &&\n            isNaN(value) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value) &&\n            (['PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar']).indexOf(aggregate) !== -1) {\n            formattedText = '#DIV/0!';\n            value = 0;\n        }\n        //dln = data[tnum as number].length;\n        formattedText = (cellDetails.skipFormatting ? (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value) ?\n            this.emptyCellTextContent : value.toString() : formattedText);\n        data[tnum][dln] = this.valueContent[actCnt][dln] = {\n            axis: 'value', actualText: field, indexObject: this.isDrillThrough ? this.rawIndexObject : {},\n            rowHeaders: rows[rln].type === 'grand sum' ? '' : rows[rln].valueSort.levelName,\n            columnHeaders: columns[cln].type === 'grand sum' ? '' : columns[cln].valueSort.levelName,\n            formattedText: formattedText, value: value,\n            hierarchyName: columns[cln].hierarchyName,\n            actualValue: actualValue,\n            rowIndex: tnum, colIndex: dln, isSum: isSum, isGrandSum: isGrand, showSubTotals: !subTotal\n        };\n        this.rawIndexObject = {};\n    };\n    PivotEngine.prototype.getCellSet = function (rawIndexObject) {\n        var currentCellSets = [];\n        var keys = Object.keys(rawIndexObject);\n        for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {\n            var index = keys_3[_i];\n            if (this.data[parseInt(index, 10)]) {\n                currentCellSets.push(this.data[parseInt(index, 10)]);\n            }\n        }\n        return currentCellSets;\n    };\n    PivotEngine.prototype.updateValueMembers = function (hasMeasureIndex, headerInfo, levelInfo, columnHeaders, axis, vcnt, levelIndex) {\n        var levelName = levelInfo && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(levelInfo.levelName) ? levelInfo.levelName.toString() : undefined;\n        var uniqueName = levelInfo && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(levelInfo.uniqueName) ? levelInfo.uniqueName.toString() : undefined;\n        if (hasMeasureIndex) {\n            for (var vln = 0; vln < vcnt; vln++) {\n                var field = this.dataSourceSettings.values[vln];\n                var name_4 = field.caption ? field.caption : field.name;\n                var calObj = {\n                    axis: this.valueAxis ? 'row' : 'column',\n                    rowIndex: !this.valueAxis ? (headerInfo && levelIndex <= headerInfo.rowIndex ?\n                        (headerInfo.rowIndex + 1) : levelIndex) : 0,\n                    actualText: field.name,\n                    formattedText: name_4,\n                    level: 0,\n                    valueSort: {},\n                    // colIndex: (tnum) + 1 + vln,\n                    // rowIndex: this.measureIndex,\n                    members: [],\n                    type: this.valueAxis ? 'value' : (headerInfo ? headerInfo.type : null),\n                    index: !this.valueAxis && headerInfo ? headerInfo.index : null,\n                    indexObject: !this.valueAxis && headerInfo ? headerInfo.indexObject : null\n                };\n                if (axis.length > 0) {\n                    calObj.showSubTotals = field.showSubTotals;\n                }\n                var vData = calObj.valueSort;\n                vData.axis = !this.valueAxis ? field.name : undefined;\n                vData[(levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + name_4] = 1;\n                vData[(uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + field.name] = 1;\n                vData.levelName = (levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + name_4;\n                vData.uniqueName = (uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + field.name;\n                columnHeaders.push(calObj);\n                this.updateValueMembers(false, headerInfo, vData, calObj.members, axis, vcnt, levelIndex + 1);\n            }\n        }\n        else {\n            for (var rln = 0, rlt = axis.length; rln < rlt; rln++) {\n                var header = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(axis[rln]);\n                header.members = [];\n                header.rowIndex = !this.valueAxis ? (levelIndex < 0 ? 0 : levelIndex) : header.rowIndex;\n                var hData = {};\n                hData.axis = header.valueSort.axis;\n                hData[(levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + header.formattedText] = 1;\n                hData[(uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + header.actualText] = 1;\n                hData.levelName = (levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + header.formattedText;\n                hData.uniqueName = (uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + header.actualText;\n                header.hierarchyName = header.valueSort.uniqueName;\n                header.valueSort = hData;\n                var drillInfo = hData.axis + this.valueSortSettings.headerDelimiter + hData.levelName;\n                var isFieldValueHeader = this.fieldList[hData.axis];\n                if (header.isDrilled && (((this.isExpandAll || isFieldValueHeader.expandAll) &&\n                    this.fieldDrillCollection[drillInfo]) || ((!this.isExpandAll && !isFieldValueHeader.expandAll) &&\n                    !this.fieldDrillCollection[drillInfo]))) {\n                    header.isDrilled = false;\n                }\n                columnHeaders.push(header);\n                if (header.isDrilled && axis[rln].members.length > 0) {\n                    if (this.valueAxis && levelIndex < this.measureIndex && this.measureIndex !== (levelIndex + 1) && (!(axis[rln].hasChild &&\n                        ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis[rln].showSubTotals) && !axis[rln].showSubTotals) ||\n                            !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals)))) {\n                        this.updateValueMembers(true, header, hData, columnHeaders[columnHeaders.length - 1].members, [], vcnt, levelIndex);\n                    }\n                    this.updateValueMembers(this.measureIndex === (levelIndex + 1), header, hData, columnHeaders[columnHeaders.length - 1].members, axis[rln].members, vcnt, levelIndex + 1);\n                    if (!this.valueAxis && levelIndex < this.measureIndex && this.measureIndex !== (levelIndex + 1) &&\n                        (!(axis[rln].hasChild && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis[rln].showSubTotals) &&\n                            !axis[rln].showSubTotals) || !this.dataSourceSettings.showSubTotals ||\n                            !this.dataSourceSettings.showColumnSubTotals)))) {\n                        this.updateValueMembers(true, header, hData, columnHeaders[columnHeaders.length - 1].members, [], vcnt, levelIndex);\n                    }\n                }\n                else if (levelIndex < this.measureIndex) {\n                    this.updateValueMembers(true, header, hData, columnHeaders[columnHeaders.length - 1].members, [], vcnt, levelIndex);\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.reArrangeValueMember = function (member) {\n        var valueAxis = [];\n        for (var _i = 0, member_1 = member; _i < member_1.length; _i++) {\n            var axis = member_1[_i];\n            if (this.valueAxisFields[axis.actualText]) {\n                valueAxis[valueAxis.length] = axis;\n            }\n        }\n        return valueAxis.concat(member).slice(0, member.length);\n    };\n    PivotEngine.prototype.frameDefinedHeaderData = function (axis, reformAxis, data, levelIndex, tnum, vcnt) {\n        // let sortText: string = this.valueSortSettings.headerText;\n        for (var rln = 0, rlt = axis.length; rln < rlt; rln++) {\n            var showSubTotals = true;\n            if (axis[rln].members.length > 0 && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis[rln].showSubTotals) && !axis[rln].showSubTotals) ||\n                !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showColumnSubTotals)) {\n                showSubTotals = false;\n            }\n            var index = (this.measureIndex < levelIndex && showSubTotals ? 1 : ((this.measureIndex > levelIndex &&\n                axis[rln].members.length > 0) || !(this.measureIndex === (levelIndex + 1) &&\n                axis[rln].isDrilled) ? ((this.measureIndex === levelIndex && this.measureIndex !== 0 && showSubTotals) ? 1 : ((this.measureIndex > levelIndex && showSubTotals && axis[rln].valueSort &&\n                axis[rln].valueSort.axis && this.measureNames[axis[rln].valueSort.axis.toString()]) ? 1 : 0)) : (this.measureIndex === 0 || !showSubTotals ? 0 : 1)));\n            if (axis[rln].members.length) {\n                var pos = void 0;\n                var members = axis[rln].members;\n                if (this.showSubTotalsAtTop) {\n                    if (levelIndex + 1 < this.measureIndex && showSubTotals) {\n                        pos = tnum;\n                        members = this.reArrangeValueMember(members);\n                    }\n                    else {\n                        pos = tnum + index;\n                    }\n                }\n                else {\n                    pos = tnum;\n                }\n                this.frameDefinedHeaderData(members, reformAxis, data, levelIndex + 1, pos, vcnt);\n            }\n            // let lvl: number = axis[rln as number].level;\n            // axis[rln as number].rowIndex = lvl;\n            var level = this.measureIndex > levelIndex && axis[rln].valueSort &&\n                axis[rln].valueSort.axis && this.measureNames[axis[rln].valueSort.axis.toString()] ?\n                this.measureIndex : levelIndex;\n            tnum = this.showSubTotalsAtTop ? tnum + 1 : reformAxis.length + index;\n            if (!reformAxis[tnum - 1]) {\n                reformAxis[tnum - 1] = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(axis[rln]);\n            }\n            axis[rln].colIndex = tnum;\n            if (!data[level]) {\n                data[level] = [];\n                this.headerContent[level] = {};\n                data[level][tnum] = this.headerContent[level][tnum]\n                    = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(axis[rln]);\n            }\n            else {\n                data[level][tnum] = this.headerContent[level][tnum]\n                    = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(axis[rln]);\n            }\n            if (!this.isPagingOrVirtualizationEnabled && (this.showSubTotalsAtTop ? index !== 0 : true)) {\n                if (reformAxis[tnum - 1]) {\n                    reformAxis[tnum - 1].members = [];\n                }\n            }\n            if (this.showSubTotalsAtTop) {\n                tnum = reformAxis.length;\n                if (rln + 1 === rlt && axis[rln].level === 0) {\n                    this.reformAxisCount = reformAxis.length + 1;\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.getHeaderData = function (rows, columns, values, rowAxis, axis, reformAxis, data, tnum, vcnt) {\n        if (!this.valueAxis && !this.isLastHeaderHasMeasures) {\n            var columnHeaders = [];\n            if (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals && axis[axis.length - 1].type === 'grand sum') {\n                this.updateValueMembers(this.measureIndex === 0 && axis.length > 1, null, null, columnHeaders, axis.slice(0, axis.length - 1), vcnt, 0);\n                this.updateValueMembers(false, null, null, columnHeaders, axis.slice(axis.length - 1, axis.length), vcnt, -1);\n            }\n            else if (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals && this.measureIndex === 0) {\n                this.updateValueMembers(false, null, null, columnHeaders, axis.slice(0, 1), vcnt, -1);\n                this.updateValueMembers(this.measureIndex === 0 && axis.length > 1, null, null, columnHeaders, axis.slice(1, axis.length), vcnt, 0);\n            }\n            else {\n                var hasColumnTotal = columns.length === 0 && axis.length === 1 && axis[0].type === 'grand sum';\n                this.updateValueMembers(!hasColumnTotal && this.measureIndex === 0, null, null, columnHeaders, axis, vcnt, hasColumnTotal ? -1 : 0);\n            }\n            this.getAggregatedHeaders(rows, columns, this.rMembers, columnHeaders, values);\n            if (this.selectedHeaders.values.length > 0) {\n                for (var clt = this.selectedHeaders.selectedHeader.length, i = 0; i < clt; i++) {\n                    var headerData = this.selectedHeaders.selectedHeader[i];\n                    if (headerData.axis === 'column') {\n                        if (headerData.uniqueName === headerData.value) {\n                            this.selectedHeaders.selectedHeader.splice(i, 1);\n                            i--;\n                            clt--;\n                        }\n                        else if (headerData.uniqueName === 'Grand Total') {\n                            for (var clt_1 = headerData.aggregateHeaders.length, j = 0; j < clt_1; j++) {\n                                if (headerData.aggregateHeaders[j] &&\n                                    headerData.aggregateHeaders[j].members.length > 0) {\n                                    for (var _i = 0, _a = headerData.aggregateHeaders[j].members; _i < _a.length; _i++) {\n                                        var member = _a[_i];\n                                        if (member.actualText === headerData.value) {\n                                            headerData.aggregateHeaders[j] = member;\n                                            if (member.type === 'grand sum') {\n                                                headerData.uniqueName = member.valueSort.levelName;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            this.frameDefinedHeaderData(columnHeaders, reformAxis, data, 0, this.showSubTotalsAtTop ? 0 : 1, vcnt);\n            return;\n        }\n        else if (rowAxis.length === 0 && (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader)) &&\n            this.dataSourceSettings.values.length > 0) {\n            if (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals &&\n                this.rMembers[this.rMembers.length - 1].type === 'grand sum') {\n                this.updateValueMembers(this.measureIndex === 0 && this.rMembers.length > 1, null, null, rowAxis, this.rMembers.slice(0, this.rMembers.length - 1), this.dataSourceSettings.values.length, 0);\n                this.updateValueMembers(false, null, null, rowAxis, this.rMembers.slice(this.rMembers.length - 1, this.rMembers.length), this.dataSourceSettings.values.length, -1);\n            }\n            else if (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals && this.measureIndex === 0) {\n                this.updateValueMembers(false, null, null, rowAxis, this.rMembers.slice(0, 1), this.dataSourceSettings.values.length, -1);\n                this.updateValueMembers(this.measureIndex === 0 && this.rMembers.length > 1, null, null, rowAxis, this.rMembers.slice(1, this.rMembers.length), this.dataSourceSettings.values.length, 0);\n            }\n            else {\n                var hasRowTotal = rows.length === 0 && this.rMembers.length === 1 && this.rMembers[0].type === 'grand sum';\n                this.updateValueMembers(!hasRowTotal && this.measureIndex === 0, null, null, rowAxis, this.rMembers, this.dataSourceSettings.values.length, hasRowTotal ? -1 : 0);\n            }\n            this.getAggregatedHeaders(rows, columns, rowAxis, axis, values);\n            if (this.selectedHeaders.values.length > 0) {\n                for (var clt = this.selectedHeaders.selectedHeader.length, i = 0; i < clt; i++) {\n                    var headerData = this.selectedHeaders.selectedHeader[i];\n                    if (headerData.axis === 'row') {\n                        for (var clt_2 = headerData.aggregateHeaders.length, j = 0; j < clt_2; j++) {\n                            if (headerData.aggregateHeaders[j].actualText === headerData.value) {\n                                if (headerData.aggregateHeaders[j].valueSort.levelName.indexOf(headerData.uniqueName) !== -1) {\n                                    headerData.uniqueName = headerData.aggregateHeaders[j].valueSort.levelName;\n                                    headerData.aggregateHeaders.splice(j, 1);\n                                    j--;\n                                    clt_2--;\n                                }\n                                else {\n                                    for (var count = headerData.aggregateHeaders[j].members.length, k = 0; k < count; k++) {\n                                        var member = headerData.aggregateHeaders[j].members[k];\n                                        if (member.type !== 'value' && member.level ===\n                                            headerData.aggregateHeaders[j].level) {\n                                            var members = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], headerData.aggregateHeaders[j].members, null, true);\n                                            headerData.aggregateHeaders = [].concat(headerData.aggregateHeaders, members, headerData.aggregateHeaders.splice(j));\n                                            headerData.aggregateHeaders.splice(members.length + j, 1);\n                                            j = (members.length + j) - 1;\n                                            clt_2 = headerData.aggregateHeaders.length;\n                                        }\n                                    }\n                                }\n                            }\n                            else if (headerData.aggregateHeaders[j].actualText !== headerData.value &&\n                                headerData.aggregateHeaders[j].members.length > 0) {\n                                for (var count = headerData.aggregateHeaders[j].members.length, k = 0; k < count; k++) {\n                                    var member = headerData.aggregateHeaders[j].members[k];\n                                    if (member.actualText === headerData.value) {\n                                        if (headerData.uniqueName ===\n                                            headerData.aggregateHeaders[j].valueSort.levelName) {\n                                            headerData.uniqueName = member.valueSort.levelName;\n                                        }\n                                        headerData.aggregateHeaders[j].members.splice(k, 1);\n                                        headerData.aggregateHeaders[j] = member;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        var rlt = axis.length;\n        var colItmLn = this.dataSourceSettings.columns.length;\n        var sortText = this.valueSortSettings.headerText;\n        //let valueLn: number = this.dataSourceSettings.values.length;\n        for (var rln = 0; rln < rlt; rln++) {\n            var isHidden = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis[rln].showSubTotals) && !axis[rln].showSubTotals;\n            if (axis[rln].members.length) {\n                this.getHeaderData(rows, columns, values, rowAxis, axis[rln].members, reformAxis, data, this.showSubTotalsAtTop && !isHidden ? tnum + 1 : tnum, vcnt);\n            }\n            var isTotalHide = true;\n            tnum = this.showSubTotalsAtTop ? tnum : reformAxis.length;\n            if (isHidden || !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showColumnSubTotals) {\n                if (!(axis[rln].members.length > 0)) {\n                    reformAxis[this.showSubTotalsAtTop ? tnum : reformAxis.length] = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(axis[rln]);\n                }\n                else {\n                    this.removeCount++;\n                    isTotalHide = false;\n                }\n                tnum = this.showSubTotalsAtTop ? tnum : reformAxis.length - 1;\n            }\n            else {\n                reformAxis[tnum] = _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.frameHeaderWithKeys(axis[rln]);\n            }\n            //  let rplus: number = rln + 1;\n            var lvl = axis[rln].level;\n            axis[rln].rowIndex = lvl;\n            var index = (tnum * vcnt) + (this.showSubTotalsAtTop ? 1 : vcnt);\n            axis[rln].colIndex = index;\n            if (!data[lvl]) {\n                data[lvl] = [];\n                this.headerContent[lvl] = {};\n            }\n            data[lvl][index] = this.headerContent[lvl][index] =\n                _util__WEBPACK_IMPORTED_MODULE_2__.PivotUtil.getFormattedHeader(axis[rln], this);\n            var isSingleMeasure = (this.dataSourceSettings.columns.length === 0 &&\n                this.dataSourceSettings.values.length === 1) ? true : false;\n            if ((this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader || isSingleMeasure) &&\n                !this.valueAxis && isTotalHide) {\n                for (var vln = 0; vln < vcnt; vln++) {\n                    var name_5 = this.dataSourceSettings.values[vln].caption ?\n                        this.dataSourceSettings.values[vln].caption : this.dataSourceSettings.values[vln].name;\n                    var calObj = {\n                        axis: 'column', actualText: this.dataSourceSettings.values[vln].name, formattedText: name_5, level: 0, valueSort: {},\n                        colIndex: (tnum * vcnt) + 1 + vln, rowIndex: colItmLn\n                    };\n                    if (!data[colItmLn]) {\n                        data[colItmLn] = [];\n                        this.headerContent[colItmLn] = {};\n                        data[colItmLn][(tnum * vcnt) + 1 + vln] =\n                            this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;\n                    }\n                    else {\n                        data[colItmLn][(tnum * vcnt) + 1 + vln] =\n                            this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;\n                    }\n                    var vData = data[colItmLn][(tnum * vcnt) + 1 + vln].valueSort;\n                    vData[axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name_5] = 1;\n                    vData.levelName = axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name_5;\n                    vData[axis[rln].valueSort.uniqueName + this.valueSortSettings.headerDelimiter +\n                        this.dataSourceSettings.values[vln].name] = 1;\n                    vData.uniqueName = axis[rln].valueSort.uniqueName +\n                        this.valueSortSettings.headerDelimiter + this.dataSourceSettings.values[vln].name;\n                    if (vData && vData[sortText]) {\n                        this.valueSortSettings.columnIndex = (tnum * vcnt) + 1 + vln;\n                    }\n                }\n            }\n            else if (axis[rln].valueSort && axis[rln].valueSort[sortText]) {\n                this.valueSortSettings.columnIndex = (tnum * vcnt) + 1;\n            }\n            if (!this.isPagingOrVirtualizationEnabled) {\n                reformAxis[tnum].members = [];\n            }\n            if (this.showSubTotalsAtTop) {\n                tnum = reformAxis.length;\n                if (axis[rln].level === 0 && rln + 1 === rlt) {\n                    this.reformAxisCount = (reformAxis.length * vcnt) + 1;\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.getAggregateValue = function (rowIndex, columnIndex, value, type, isGrandTotal) {\n        //rowIndex = rowIndex.sort();\n        //columnIndex = columnIndex.sort();\n        //let clt: number = columnIndex.length;\n        var ri = 0;\n        var cellValue = 0;\n        var avgCnt = 0;\n        var isInit = true;\n        var isValueExist = false;\n        switch (type.toLowerCase()) {\n            case 'median':\n                {\n                    var values = [];\n                    var position = 0;\n                    while (rowIndex[ri] !== undefined) {\n                        var index = rowIndex[ri];\n                        if (columnIndex[index] !== undefined) {\n                            isValueExist = true;\n                            this.rawIndexObject[index] = index;\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.valueMatrix[index][value].member)) {\n                                values.push(this.valueMatrix[index][value].member);\n                            }\n                        }\n                        ri++;\n                    }\n                    var len = values.length;\n                    if (len > 0) {\n                        values.sort(function (a, b) { return a - b; });\n                        if (len % 2 === 0) {\n                            position = (len / 2) <= 1 ? 0 : ((len / 2) - 1);\n                            cellValue = (values[position] + values[position + 1]) / 2;\n                        }\n                        else {\n                            position = (len + 1) / 2 <= 1 ? 0 : (((len + 1) / 2) - 1);\n                            cellValue = values[position];\n                        }\n                    }\n                }\n                break;\n            case 'count':\n                {\n                    while (rowIndex[ri] !== undefined) {\n                        var index = rowIndex[ri];\n                        if (columnIndex[index] !== undefined) {\n                            isValueExist = true;\n                            this.rawIndexObject[index] = index;\n                            cellValue += ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.valueMatrix[index][value].member) ?\n                                0 : (this.allowDataCompression ? this.valueMatrix[index][value].member : 1));\n                        }\n                        ri++;\n                    }\n                }\n                break;\n            case 'distinctcount':\n                {\n                    var duplicateValues = [];\n                    while (rowIndex[ri] !== undefined) {\n                        if (columnIndex[rowIndex[ri]] !== undefined) {\n                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];\n                            isValueExist = true;\n                            var val = (this.data[rowIndex[ri]][this.fieldKeys[this.fields[value]]]);\n                            // let currentVal: number = this.valueMatrix[rowIndex[ri as number]][value as number];\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(val)) {\n                                var currentVal = val.toString();\n                                if (duplicateValues.length === 0 || (duplicateValues.length > 0 &&\n                                    duplicateValues.indexOf(currentVal) === -1)) {\n                                    cellValue += (this.allowDataCompression && typeof val === 'number') ? val : 1;\n                                    duplicateValues.push(currentVal);\n                                }\n                            }\n                        }\n                        ri++;\n                    }\n                }\n                break;\n            case 'product':\n                {\n                    while (rowIndex[ri] !== undefined) {\n                        var index = rowIndex[ri];\n                        if (columnIndex[index] !== undefined) {\n                            this.rawIndexObject[index] = index;\n                            isValueExist = true;\n                            var currentVal = this.valueMatrix[index][value].member;\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentVal)) {\n                                cellValue = ((isInit || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cellValue)) ? 1 : cellValue);\n                                cellValue *= currentVal;\n                            }\n                            else if (isInit) {\n                                cellValue = currentVal;\n                            }\n                            isInit = false;\n                        }\n                        ri++;\n                    }\n                }\n                break;\n            case 'populationstdev':\n            case 'samplestdev':\n            case 'populationvar':\n            case 'samplevar':\n                {\n                    var i = 0;\n                    var val = 0;\n                    var indexVal = [];\n                    var avgVal = 0;\n                    var cVal = 0;\n                    var avgDifferenceVal = 0;\n                    while (rowIndex[ri] !== undefined) {\n                        var index = rowIndex[ri];\n                        if (columnIndex[index] !== undefined) {\n                            isValueExist = true;\n                            this.rawIndexObject[index] = index;\n                            var currentVal = this.valueMatrix[index][value].member;\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentVal)) {\n                                val += currentVal;\n                                indexVal.push(currentVal);\n                                i++;\n                            }\n                        }\n                        ri++;\n                    }\n                    if (i > 0) {\n                        avgVal = val / i;\n                        for (var _i = 0, indexVal_1 = indexVal; _i < indexVal_1.length; _i++) {\n                            var index = indexVal_1[_i];\n                            avgDifferenceVal += Math.pow((index - avgVal), 2);\n                        }\n                        if ((['populationstdev', 'samplestdev']).indexOf(type.toLowerCase()) !== -1) {\n                            cVal = Math.sqrt(avgDifferenceVal / (type.toLowerCase() === 'populationstdev' ? i : (i - 1)));\n                        }\n                        else {\n                            cVal = avgDifferenceVal / (type.toLowerCase() === 'populationvar' ? i : (i - 1));\n                        }\n                        cellValue = (cVal === 0 ? NaN : cVal);\n                    }\n                    else {\n                        cellValue = val;\n                    }\n                }\n                break;\n            case 'min':\n                {\n                    var isFirst = true;\n                    cellValue = undefined;\n                    while (rowIndex[ri] !== undefined) {\n                        var index = rowIndex[ri];\n                        if (columnIndex[index] !== undefined &&\n                            this.valueMatrix[index][value].member !== undefined) {\n                            isValueExist = true;\n                            this.rawIndexObject[index] = index;\n                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cellValue) &&\n                                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.valueMatrix[index][value].member)) {\n                                cellValue = this.valueMatrix[index][value].member;\n                            }\n                            else {\n                                if (isFirst) {\n                                    cellValue = this.valueMatrix[index][value].member;\n                                    isFirst = false;\n                                }\n                                else {\n                                    cellValue = this.valueMatrix[index][value].member < cellValue ?\n                                        this.valueMatrix[index][value].member : cellValue;\n                                }\n                            }\n                        }\n                        ri++;\n                    }\n                }\n                break;\n            case 'max':\n                {\n                    var isMaxFirst = true;\n                    while (rowIndex[ri] !== undefined) {\n                        var index = rowIndex[ri];\n                        if (columnIndex[index] !== undefined &&\n                            this.valueMatrix[index][value].member !== undefined) {\n                            isValueExist = true;\n                            this.rawIndexObject[index] = index;\n                            if (isMaxFirst) {\n                                cellValue = this.valueMatrix[index][value].member;\n                                isMaxFirst = false;\n                            }\n                            else {\n                                cellValue = this.valueMatrix[index][value].member > cellValue ?\n                                    this.valueMatrix[index][value].member : cellValue;\n                            }\n                        }\n                        ri++;\n                    }\n                }\n                break;\n            case 'calculatedfield':\n                {\n                    isValueExist = true;\n                    var calcField = this.calculatedFields[this.fields[value]];\n                    var actualFormula = calcField.formula;\n                    var aggregateField = {};\n                    if (this.calculatedFormulas[calcField.name]) {\n                        var calculatedFormulas = this.calculatedFormulas[calcField.name];\n                        for (var len = 0, lmt = calculatedFormulas.length; len < lmt; len++) {\n                            var aggregatedValue = calculatedFormulas[len];\n                            var value_1 = aggregateField[aggregatedValue.formula];\n                            if (value_1 === undefined) {\n                                var type_1 = aggregatedValue.type;\n                                value_1 = this.getAggregateValue(rowIndex, columnIndex, aggregatedValue.index, type_1, false);\n                                aggregateField[aggregatedValue.formula] = value_1;\n                            }\n                            actualFormula = (actualFormula).replace(aggregatedValue.formula, String(value_1));\n                        }\n                    }\n                    cellValue = this.evaluate(actualFormula);\n                    cellValue = (cellValue === Infinity || cellValue === -Infinity ? Infinity : (cellValue === undefined || isNaN(cellValue)) ?\n                        undefined : JSON.parse(String(cellValue)));\n                }\n                break;\n            default:\n                {\n                    cellValue = undefined;\n                    while (rowIndex[ri] !== undefined) {\n                        var index = rowIndex[ri];\n                        if (columnIndex[index] !== undefined) {\n                            isValueExist = true;\n                            if (!isGrandTotal) {\n                                this.rawIndexObject[index] = index;\n                            }\n                            //let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri as number]), 1)[0] : rowIndex[ri as number];\n                            var currentVal = this.valueMatrix[index][value].member;\n                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cellValue) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentVal)) {\n                                cellValue = currentVal;\n                            }\n                            else {\n                                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cellValue)) {\n                                    cellValue = 0;\n                                }\n                                cellValue += ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentVal) ? 0 : currentVal);\n                            }\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currentVal)) {\n                                avgCnt++;\n                            }\n                        }\n                        ri++;\n                    }\n                }\n                break;\n        }\n        /* if (rlt > clt) {\n             this.makeMirrorObject(rowIndex, mirror);\n             while (columnIndex[ci] !== undefined) {\n                 if (mirror[columnIndex[ci]]) {\n                     let cIndx: number = isLeastLevel ? columnIndex.splice(ci, 1)[0] : columnIndex[ci];\n                     //rowIndex.splice\n                     sum += this.valueMatrix[cIndx][value as number];\n                 }\n                 ci++;\n             }\n         } else {\n             this.makeMirrorObject(columnIndex, mirror);\n             while (rowIndex[ri as number] !== undefined) {\n                 if (mirror[rowIndex[ri as number]]) {\n                     let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri as number]), 1)[0] : rowIndex[ri as number];\n                     sum += this.valueMatrix[rowIndex[ri as number]][value as number];\n                 }\n                 ri++;\n             }\n         } */\n        return ((type && type.toLowerCase() === 'avg' && cellValue !== 0 &&\n            !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cellValue)) ? (cellValue / avgCnt) : isValueExist ? cellValue : undefined);\n    };\n    PivotEngine.prototype.evaluate = function (obj) {\n        return Function('\"use strict\";return (' + obj + ')')();\n    };\n    /**\n     * It performs the formatting to get formatted Value\n     *\n     * @param {number | string} value - It contains the value which went formatting.\n     * @param {string} fieldName - It contains the field name.\n     * @returns {IAxisSet} - It returns the formatted value as IAxisSet data.\n     * @hidden\n     */\n    PivotEngine.prototype.getFormattedValue = function (value, fieldName) {\n        var commonValue = value === null ? (this.localeObj ? this.localeObj.getConstant('null') :\n            String(value)) : value === undefined ?\n            (this.localeObj ? (fieldName in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :\n                this.localeObj.getConstant('undefined') : String(value)) : value;\n        var formattedValue = {\n            formattedText: commonValue.toString(),\n            actualText: commonValue,\n            dateText: commonValue\n        };\n        if (this.formatFields[fieldName] && (this.formatFields[fieldName].format ||\n            this.formatFields[fieldName].skeleton) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value)) {\n            try {\n                var formatField = (this.formatFields[fieldName].properties ?\n                    this.formatFields[fieldName].properties :\n                    this.formatFields[fieldName]);\n                var formatSetting = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, formatField, null, true);\n                delete formatSetting.name;\n                if (!formatSetting.minimumSignificantDigits && formatSetting.minimumSignificantDigits < 1) {\n                    delete formatSetting.minimumSignificantDigits;\n                }\n                if (!formatSetting.maximumSignificantDigits && formatSetting.maximumSignificantDigits < 1) {\n                    delete formatSetting.maximumSignificantDigits;\n                }\n                if (formatSetting.type) {\n                    formattedValue.formattedText = this.dateFormatFunction[fieldName].exactFormat(new Date(value))\n                        === null ? formattedValue.formattedText :\n                        this.dateFormatFunction[fieldName].exactFormat(new Date(value));\n                    formattedValue.actualText = value;\n                }\n                else {\n                    delete formatSetting.type;\n                    if ((formatSetting.format) && !(this.formatRegex.test(formatSetting.format))) {\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(formatSetting.minimumFractionDigits)) {\n                            delete formatSetting.minimumFractionDigits;\n                        }\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(formatSetting.maximumFractionDigits)) {\n                            delete formatSetting.maximumFractionDigits;\n                        }\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(formatSetting.minimumIntegerDigits)) {\n                            delete formatSetting.minimumIntegerDigits;\n                        }\n                    }\n                    formattedValue.formattedText =\n                        this.globalize.formatNumber(!isNaN(Number(value)) ? Number(value) : value, formatSetting);\n                    formattedValue.actualText = !isNaN(Number(value)) ? Number(value) : value;\n                    formattedValue.dateText = !isNaN(Number(value)) ? Number(value) : value;\n                }\n                if (this.fieldList[fieldName].sort !== 'None' && formatSetting.type &&\n                    ['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1) {\n                    formattedValue.dateText = this.dateFormatFunction[fieldName].fullFormat(new Date(value));\n                }\n                if (this.fieldList[fieldName].isCustomField) {\n                    formattedValue.formattedText = formattedValue.formattedText === 'NaN' ?\n                        commonValue.toString() : formattedValue.formattedText;\n                    formattedValue.dateText = formattedValue.dateText === 'NaN' ?\n                        commonValue.toString() : formattedValue.dateText;\n                }\n            }\n            catch (exception) {\n                if (!this.fieldList[fieldName].isCustomField) {\n                    throw exception;\n                }\n            }\n            finally {\n                if (this.fieldList[fieldName].isCustomField) {\n                    formattedValue.formattedText =\n                        ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(formattedValue.formattedText) || formattedValue.formattedText === 'NaN') ?\n                            commonValue.toString() : formattedValue.formattedText;\n                    formattedValue.dateText = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(formattedValue.dateText) || formattedValue.dateText === 'NaN') ?\n                        commonValue.toString() : formattedValue.dateText;\n                }\n            }\n        }\n        return formattedValue;\n    };\n    PivotEngine.prototype.powerFunction = function (formula) {\n        if (formula.indexOf('^') > -1) {\n            var items_1 = [];\n            while (formula.indexOf('(') > -1) {\n                formula = formula.replace(/(\\([^()]*\\))/g, function (text, item) {\n                    items_1.push(item);\n                    return ('~' + (items_1.length - 1));\n                });\n            }\n            items_1.push(formula);\n            formula = '~' + (items_1.length - 1);\n            while (formula.indexOf('~') > -1) {\n                formula = formula.replace(new RegExp('~' + '(\\\\d+)', 'g'), function (text, index) {\n                    return items_1[index].replace(/(\\w*)\\^(\\w*)/g, 'Math.pow' + '($1,$2)');\n                });\n            }\n        }\n        return formula;\n    };\n    PivotEngine.prototype.getTabularPivotValues = function (requireDatasourceUpdate, dataSource) {\n        this.tabularPivotValues = [];\n        var colIndex;\n        this.emptyRowsLength = 0;\n        var isGrouping = Object.keys(this.groupingFields).length > 0;\n        if (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n            this.dataSourceSettings.alwaysShowValueHeader)) {\n            this.rowMaxLevel = this.rowMaxLevel + 1;\n        }\n        for (var i = 0; i < this.pivotValues.length; i++) {\n            var rowPivotValues = void 0;\n            var drillMem = false;\n            var isValue = true;\n            var levelName = void 0;\n            var levelNameParts = void 0;\n            var valueAxis = void 0;\n            while ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.pivotValues[i]) && i < this.pivotValues.length) {\n                this.tabularPivotValues.length++;\n                i++;\n            }\n            if (i < this.pivotValues.length) {\n                rowPivotValues = this.pivotValues[i];\n            }\n            var firstRow = rowPivotValues[0] ? rowPivotValues[0] : undefined;\n            if (firstRow) {\n                levelName = firstRow.valueSort.levelName;\n                levelNameParts = levelName.split(this.dataSourceSettings.valueSortSettings.headerDelimiter);\n                if ((!this.dataSourceSettings.showSubTotals || (this.dataSourceSettings.showColumnSubTotals &&\n                    !this.dataSourceSettings.showRowSubTotals)) && firstRow.formattedText !== this.localeObj.getConstant('grandTotal')) {\n                    if (firstRow.isSum) {\n                        isValue = false;\n                    }\n                }\n                if (isGrouping) {\n                    var pivotValue = this.pivotValues[i - 1][this.rowMaxLevel - 1];\n                    var previousValue = this.tabularPivotValues[this.tabularPivotValues.length - 1][this.rowMaxLevel - 1];\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pivotValue) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(previousValue)) {\n                        var pivotValueAxis = pivotValue.valueSort.axis;\n                        var previousValueAxis = void 0;\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(previousValue) && previousValue.valueSort.axis) {\n                            previousValueAxis = previousValue.valueSort.axis;\n                        }\n                        if (pivotValueAxis.includes('custom_group') || previousValueAxis.includes('custom_group')) {\n                            if ((pivotValue.formattedText === levelNameParts[this.rowMaxLevel - 1] && pivotValue.formattedText !==\n                                levelNameParts[levelNameParts.length - 1]) || (previousValue && previousValue.formattedText ===\n                                levelNameParts[this.rowMaxLevel - 1])) {\n                                valueAxis = pivotValue.valueSort.axis ? pivotValue.valueSort.axis : previousValue.valueSort.axis;\n                            }\n                            else {\n                                valueAxis = firstRow.valueSort.axis;\n                            }\n                        }\n                        else {\n                            valueAxis = firstRow.valueSort.axis;\n                        }\n                    }\n                }\n            }\n            if (firstRow && this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                this.dataSourceSettings.alwaysShowValueHeader)) {\n                if (firstRow.type === 'value') {\n                    if (levelNameParts.length - 1 !== this.rowMaxLevel && levelNameParts[0] !== this.localeObj.getConstant('grandTotal')) {\n                        for (var w = 0; w < this.dataSourceSettings.values.length; w++) {\n                            if (firstRow.formattedText === this.dataSourceSettings.values[w].name) {\n                                isValue = false;\n                                firstRow.hasChild = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (levelNameParts.length - 1 !== this.rowMaxLevel) {\n                    firstRow.isDrilled = true;\n                    if (!firstRow.hasChild && !firstRow.type) {\n                        firstRow.hasChild = true;\n                    }\n                    else if (levelNameParts[0] === this.localeObj.getConstant('grandTotal') && firstRow.type === 'grand sum') {\n                        firstRow.hasChild = true;\n                    }\n                    else {\n                        firstRow.level = levelNameParts.length - 1;\n                    }\n                }\n                else {\n                    firstRow.level = levelNameParts.length - 1;\n                }\n                for (var n = 0; n < dataSource.drilledMembers.length; n++) {\n                    var drillItems = dataSource.drilledMembers[n].items;\n                    for (var v = 0; v < drillItems.length; v++) {\n                        var splitdrillItems = drillItems[v].split(dataSource.drilledMembers[n].delimiter);\n                        var rowText = firstRow.formattedText.split(' ');\n                        var rowFormatText = rowText.length > 1 ? rowText.slice(0, rowText.length - 1).join(' ') : rowText[0];\n                        if (splitdrillItems[splitdrillItems.length - 1] === rowFormatText &&\n                            splitdrillItems[0] === levelNameParts[0]) {\n                            drillMem = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(firstRow) && firstRow.axis === 'row') {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rowPivotValues[1]) && !(firstRow.hasChild && firstRow.isDrilled) && isValue) {\n                    var levelNameArray = [];\n                    if ((this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                        this.dataSourceSettings.alwaysShowValueHeader)) && (requireDatasourceUpdate && drillMem\n                        ? levelNameParts.length - 1 < this.rowMaxLevel : levelNameParts.length <= this.rowMaxLevel) &&\n                        firstRow.type === 'value' && (!this.dataSourceSettings.expandAll ? drillMem : !drillMem) ||\n                        levelNameParts[0] === this.localeObj.getConstant('grandTotal')) {\n                        for (var b = levelNameParts.length - 1; b >= 0; b--) {\n                            if (levelNameParts[b] === levelNameParts[levelNameParts.length - 2]) {\n                                levelNameArray[b] = levelNameParts[levelNameParts.length - 2] + ' ' +\n                                    levelNameParts[levelNameParts.length - 1];\n                                if (b === 0) {\n                                    break;\n                                }\n                                else {\n                                    while (b >= 0) {\n                                        levelNameArray[b - 1] = levelNameParts[b - 1];\n                                        b--;\n                                    }\n                                    break;\n                                }\n                            }\n                            else {\n                                levelNameArray[b] = levelNameParts[levelNameParts.length - 2] + ' ' +\n                                    levelNameParts[levelNameParts.length - 1];\n                            }\n                        }\n                        levelNameParts = levelNameArray;\n                    }\n                    colIndex = firstRow.colIndex;\n                    var currentRow = [];\n                    var dLevelName = levelNameParts[0];\n                    var level = 0;\n                    for (var k = 0; k < levelNameParts.length - 1 || k < this.rowMaxLevel; k++) {\n                        var valueIsDrill = void 0;\n                        var valueHasChild = void 0;\n                        var duplIsDrilled = firstRow.isDrilled;\n                        var dupliHasChild = firstRow.hasChild;\n                        if (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                            this.dataSourceSettings.alwaysShowValueHeader)) {\n                            valueIsDrill = false;\n                            valueHasChild = false;\n                            if (levelNameParts[levelNameParts.length - 1] !== levelNameParts[levelNameParts.length - 2]) {\n                                var currentRowIndex = levelNameParts.length - 1 === this.rowMaxLevel &&\n                                    this.dataSourceSettings.rows.length === this.rowMaxLevel ?\n                                    levelNameParts.length - 2 : levelNameParts.length - 1;\n                                if (k < currentRowIndex) {\n                                    valueHasChild = true;\n                                }\n                                if (k < levelNameParts.length - 2) {\n                                    valueIsDrill = true;\n                                }\n                            }\n                        }\n                        else {\n                            if (k < this.rowMaxLevel) {\n                                dupliHasChild = true;\n                            }\n                            if (levelNameParts.length > 1 || k === 0) {\n                                duplIsDrilled = true;\n                            }\n                        }\n                        if (k < levelNameParts.length - 1) {\n                            if (k > 0) {\n                                dLevelName = dLevelName + this.dataSourceSettings.valueSortSettings.headerDelimiter +\n                                    levelNameParts[k];\n                            }\n                            currentRow.push({\n                                actualText: levelNameParts[k],\n                                axis: firstRow.axis,\n                                formattedText: levelNameParts[k],\n                                rowIndex: this.tabularPivotValues.length,\n                                hasChild: (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                                    this.dataSourceSettings.alwaysShowValueHeader) && firstRow.type !== 'grand sum') ?\n                                    valueHasChild : dupliHasChild,\n                                isDrilled: (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                                    this.dataSourceSettings.alwaysShowValueHeader) && firstRow.type !== 'grand sum') ?\n                                    valueIsDrill : duplIsDrilled,\n                                level: level,\n                                valueSort: {\n                                    levelName: dLevelName,\n                                    axis: isGrouping ? valueAxis : this.dataSourceSettings.rows[k].name\n                                },\n                                colIndex: colIndex++,\n                                colSpan: 1,\n                                rowSpan: 1\n                            });\n                        }\n                        if (k >= firstRow.level) {\n                            var span = k === 0 ? this.rowMaxLevel : this.rowMaxLevel - 1;\n                            currentRow.push({\n                                actualText: this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                                    this.dataSourceSettings.alwaysShowValueHeader) ? levelNameParts[k] === undefined ?\n                                    levelNameParts[levelNameParts.length - 1] : levelNameParts[k] : firstRow.formattedText,\n                                axis: firstRow.axis,\n                                formattedText: (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                                    this.dataSourceSettings.alwaysShowValueHeader)) ? levelNameParts[k] === undefined ?\n                                    levelNameParts[levelNameParts.length - 1] : levelNameParts[k] : firstRow.formattedText,\n                                rowIndex: this.tabularPivotValues.length,\n                                hasChild: (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                                    this.dataSourceSettings.alwaysShowValueHeader) && firstRow.type !== 'grand sum') ?\n                                    valueHasChild : firstRow.hasChild,\n                                isDrilled: (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                                    this.dataSourceSettings.alwaysShowValueHeader) && firstRow.type !== 'grand sum') ?\n                                    valueIsDrill : firstRow.isDrilled,\n                                level: level,\n                                valueSort: {\n                                    levelName: firstRow.valueSort.levelName,\n                                    axis: isGrouping ? valueAxis : this.dataSourceSettings.rows[k].name\n                                },\n                                colIndex: colIndex++,\n                                colSpan: span,\n                                rowSpan: 1\n                            });\n                        }\n                        level++;\n                    }\n                    firstRow.colIndex = colIndex;\n                    firstRow.rowIndex = this.tabularPivotValues.length;\n                    firstRow.colSpan = 1;\n                    firstRow.rowSpan = 1;\n                    if (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                        this.dataSourceSettings.alwaysShowValueHeader)) {\n                        firstRow.formattedText = levelNameParts[levelNameParts.length - 1];\n                    }\n                    currentRow.push(firstRow);\n                    this.setColumnSpan(currentRow, firstRow);\n                    var colData = rowPivotValues.slice(1, rowPivotValues.length);\n                    for (var i_8 = 1; i_8 < rowPivotValues.length; i_8++) {\n                        var colDataValues = rowPivotValues[i_8];\n                        colDataValues.colIndex = colIndex + 1;\n                        colDataValues.rowIndex = this.tabularPivotValues.length;\n                        colIndex++;\n                    }\n                    currentRow = currentRow.concat(colData);\n                    this.tabularPivotValues.push(currentRow);\n                }\n                else {\n                    this.emptyRowsLength++;\n                }\n            }\n            else {\n                var emptyRow = [];\n                var headerColIndex = this.rowMaxLevel + 1;\n                for (var j = 0; j < this.rowMaxLevel; j++) {\n                    emptyRow.push(undefined);\n                }\n                emptyRow.push(firstRow);\n                var colData = rowPivotValues.slice(1, rowPivotValues.length);\n                for (var i_9 = 0; i_9 < colData.length; i_9++) {\n                    colData[i_9].colIndex = headerColIndex;\n                    colData[i_9].rowIndex = this.tabularPivotValues.length;\n                    headerColIndex++;\n                }\n                emptyRow = emptyRow.concat(colData);\n                this.tabularPivotValues.push(emptyRow);\n            }\n        }\n        return this.tabularPivotValues;\n    };\n    PivotEngine.prototype.setColumnSpan = function (currentRow, firstRow) {\n        var spanlength = 1;\n        for (var f = currentRow.length - 1; f >= 0; f--) {\n            if (f !== 0) {\n                if (currentRow[f].formattedText === currentRow[f - 1].formattedText) {\n                    currentRow[f].colSpan = 0;\n                    spanlength++;\n                    currentRow[f - 1].colSpan = spanlength;\n                }\n            }\n            var currentRowindex = (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 ||\n                this.dataSourceSettings.alwaysShowValueHeader)) ? currentRow.length - 2 : currentRow.length - 1;\n            if (f < currentRowindex && (firstRow.type !== 'grand sum' || firstRow.isSum) &&\n                currentRow[currentRow.length - 1].formattedText !== currentRow[currentRow.length - 2].formattedText &&\n                firstRow.type !== 'grand sum') {\n                currentRow[f].hasChild = true;\n                var drillMem = this.dataSourceSettings.drilledMembers;\n                for (var drillItem = 0; drillItem < drillMem.length; drillItem++) {\n                    for (var item = 0; item < drillMem[drillItem].items.length; item++) {\n                        if (drillMem[drillItem].items[item] === currentRow[f].formattedText) {\n                            currentRow[f].isDrilled = currentRow[f].isDrilled ? true : false;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    PivotEngine.prototype.setRowSpan = function () {\n        var emptyHeaderLength = this.headerContent.length;\n        for (var m = 0; m < this.rowMaxLevel; m++) {\n            var rowSpan = 1;\n            if (this.tabularPivotValues.length > this.rowMaxLevel + emptyHeaderLength) {\n                for (var j = this.tabularPivotValues.length - 1; j >= emptyHeaderLength - 1; j--) {\n                    if (j !== emptyHeaderLength - 1) {\n                        var tabluarValue = this.tabularPivotValues;\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(tabluarValue[j - 1])) {\n                            break;\n                        }\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(tabluarValue[j - 1][m]) &&\n                            tabluarValue[j][m].formattedText ===\n                                tabluarValue[j - 1][m].formattedText) {\n                            tabluarValue[j][m].rowSpan = 0;\n                            rowSpan++;\n                            tabluarValue[j - 1][m].rowSpan = rowSpan;\n                        }\n                        else {\n                            rowSpan = 1;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    return PivotEngine;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pivotview/src/base/engine.js?");

/***/ })

}]);