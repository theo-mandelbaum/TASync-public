"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-image-editor_src_image-editor_action_crop_js-31464dab"],{

/***/ "./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/crop.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/crop.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Crop: () => (/* binding */ Crop)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\nvar Crop = /** @class */ (function () {\n    function Crop(parent) {\n        this.croppedDegree = 0; // Specifies the degree when crop is performed\n        this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 }; // To redraw old image when navigate to crop tab\n        this.tempFlipPanPoint = { x: 0, y: 0 };\n        this.isPreventScaling = false;\n        this.isInitCrop = false;\n        this.isTransformCrop = false;\n        this.parent = parent;\n        this.addEventListener();\n    }\n    Crop.prototype.destroy = function () {\n        if (this.parent.isDestroyed) {\n            return;\n        }\n        this.removeEventListener();\n    };\n    Crop.prototype.addEventListener = function () {\n        this.parent.on('crop', this.cropping, this);\n        this.parent.on('destroyed', this.destroy, this);\n    };\n    Crop.prototype.removeEventListener = function () {\n        this.parent.off('crop', this.cropping);\n        this.parent.off('destroyed', this.destroy);\n    };\n    Crop.prototype.cropping = function (args) {\n        this.updateCropPvtVar();\n        switch (args.prop) {\n            case 'cropCircle':\n                this.cropCircle(args.value['context'], args.value['isSave'], args.value['isFlip']);\n                break;\n            case 'setCurrSelPoints':\n                this.setCurrSelPoints(args.value['isSetDimension']);\n                break;\n            case 'updateRotatePan':\n                this.updateRotatePan();\n                break;\n            case 'crop':\n                this.crop(args.value['obj']);\n                break;\n            case 'calcRatio':\n                this.calcRatio(args.value['obj'], args.value['dimension']);\n                break;\n            case 'getCurrFlipState':\n                this.getCurrFlipState(args.value['panObj']);\n                break;\n            case 'getPreviousCropCurrentObj':\n                args.value['obj']['prevObj'] = this.prevCropCurrObj;\n                break;\n            case 'setPreviousCropCurrentObj':\n                this.prevCropCurrObj = args.value['obj'];\n                break;\n            case 'setCropDestPoints':\n                this.cropDestPoints = args.value['point'];\n                break;\n            case 'getTempFlipPanPoint':\n                args.value['obj']['point'] = this.tempFlipPanPoint;\n                break;\n            case 'setTempFlipPanPoint':\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(args.value['isAdd'])) {\n                    this.tempFlipPanPoint = args.value['point'];\n                }\n                else {\n                    this.tempFlipPanPoint.x += args.value['point'].x;\n                    this.tempFlipPanPoint.y += args.value['point'].y;\n                }\n                break;\n            case 'getPreventScaling':\n                args.value['obj']['bool'] = this.isPreventScaling;\n                break;\n            case 'adjustStraightenForShapes':\n                this.adjustStraightenForShapes(args.value['type'], args.value['isInitialRotated']);\n                break;\n            case 'resizeWrapper':\n                this.resizeWrapper();\n                break;\n            case 'setTransformCrop':\n                this.isTransformCrop = args.value['bool'];\n                break;\n            case 'setInitCrop':\n                this.isInitCrop = args.value['bool'];\n                break;\n            case 'resetZoom':\n                this.resetZoom();\n                break;\n            case 'revertTransform':\n                this.revertTransform(args.value['type'], args.value['coll']);\n                break;\n            case 'reset':\n                this.reset();\n                break;\n        }\n    };\n    Crop.prototype.getModuleName = function () {\n        return 'crop';\n    };\n    Crop.prototype.updateCropPvtVar = function () {\n        var parent = this.parent;\n        if (parent.lowerCanvas) {\n            this.lowerContext = parent.lowerCanvas.getContext('2d');\n        }\n        if (parent.upperCanvas) {\n            this.upperContext = parent.upperCanvas.getContext('2d');\n        }\n    };\n    Crop.prototype.reset = function () {\n        this.prevCropCurrObj = null;\n        this.croppedDegree = 0;\n        this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 };\n        this.tempFlipPanPoint = { x: 0, y: 0 };\n        this.isPreventScaling = false;\n        this.isInitCrop = false;\n        this.isTransformCrop = false;\n    };\n    Crop.prototype.cropImg = function (isRotateCrop) {\n        var parent = this.parent;\n        var isNullCrop = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isRotateCrop);\n        var resizeIcon = parent.element.querySelector('#' + parent.element.id + '_nonaspectratio');\n        var actPoint = parent.activeObj.activePoint;\n        var img = parent.img;\n        var isRotated = false;\n        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {\n            var currentValue = parent.rotateFlipColl[i];\n            if (currentValue === 90 || currentValue === -90) {\n                isRotated = true;\n            }\n        }\n        parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });\n        if (isNullCrop || resizeIcon) {\n            this.croppedDegree = parent.transform.degree;\n        }\n        if (isNullCrop && (parent.transform.degree !== 0) || isRotated) {\n            this.updateCropObj();\n            var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };\n            parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });\n            this.rotateCrop();\n        }\n        else if (isNullCrop && parent.transform.currFlipState !== '') {\n            this.updateCropObj();\n            var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };\n            parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });\n            this.flipCrop();\n        }\n        else {\n            this.adjustStraightenForShapes('initial', false);\n            parent.notify('draw', { prop: 'setTempZoomFactor', onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });\n            var ratio = this.calcRatio();\n            if (isNullCrop || !isRotateCrop) { // isRotateCrop is NULL or False\n                this.updateCropObj();\n                parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });\n                parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n                var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };\n                parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });\n                parent.currSelectionPoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n                this.cropDestPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };\n            }\n            var obj = { width: 0, height: 0 };\n            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false, value: { width: actPoint.width * ratio.width,\n                    height: actPoint.height * ratio.height, obj: obj, isImgShape: null } });\n            var maxDimension = obj;\n            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n            parent.img = { srcLeft: (actPoint.startX * ratio.width) - (img.destLeft * ratio.width),\n                srcTop: (actPoint.startY * ratio.height) - (img.destTop * ratio.height),\n                srcWidth: (actPoint.width * ratio.width), srcHeight: (actPoint.height * ratio.height),\n                destLeft: (parent.lowerCanvas.clientWidth - maxDimension.width) / 2,\n                destTop: (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2,\n                destWidth: maxDimension.width, destHeight: maxDimension.height };\n            var temp = this.lowerContext.filter;\n            parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });\n            this.lowerContext.filter = 'none';\n            var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n            this.cropObjColl();\n            parent.transform.straighten = 0;\n            parent.activeObj = activeObj;\n            this.cropFreehandDrawColl();\n            parent.shapeColl = [];\n            parent.notify('shape', { prop: 'updateShapeColl', onPropertyChange: false });\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });\n            if (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') {\n                this.cropCircle(this.lowerContext);\n            }\n            else {\n                parent.isCircleCrop = false;\n            }\n            this.lowerContext.filter = temp;\n            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n            parent.currObjType.isCustomCrop = false;\n            parent.pan(false);\n            parent.transform.defaultZoomFactor = 0;\n        }\n    };\n    Crop.prototype.adjustStraightenForShapes = function (type, isInitialRotated) {\n        var parent = this.parent;\n        var center = {\n            x: parent.img.destLeft + parent.img.destWidth / 2,\n            y: parent.img.destTop + parent.img.destHeight / 2\n        };\n        for (var _i = 0, _a = parent.objColl; _i < _a.length; _i++) {\n            var obj = _a[_i];\n            if (['rectangle', 'ellipse', 'text', 'image', 'redact'].indexOf(obj.shape) !== -1) {\n                if (isInitialRotated || obj.rotatedAngle !== 0) {\n                    var _b = obj.activePoint, startX = _b.startX, startY = _b.startY, width = _b.width, height = _b.height;\n                    var angle = type === 'initial' ? obj.rotatedAngle : -obj.rotatedAngle;\n                    var diffX = startX + width / 2 - center.x;\n                    var diffY = startY + height / 2 - center.y;\n                    var cosAngle = Math.cos(angle);\n                    var sinAngle = Math.sin(angle);\n                    var centerX = cosAngle * diffX - sinAngle * diffY + center.x;\n                    var centerY = sinAngle * diffX + cosAngle * diffY + center.y;\n                    var diffXUpdated = centerX - startX - width / 2;\n                    var diffYUpdated = centerY - startY - height / 2;\n                    obj.activePoint.startX += diffXUpdated;\n                    obj.activePoint.startY += diffYUpdated;\n                    obj.activePoint.endX += diffXUpdated;\n                    obj.activePoint.endY += diffYUpdated;\n                }\n            }\n        }\n    };\n    Crop.prototype.updateCropObj = function () {\n        this.parent.afterCropActions = [];\n        var object = { currObj: {} };\n        this.parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n        var obj = object['currObj'];\n        obj.straighten = this.parent.transform.straighten;\n        this.parent.cropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, obj, {}, true);\n    };\n    Crop.prototype.rotateCrop = function () {\n        var parent = this.parent;\n        var flipState = this.getCurrFlipState();\n        var shape = parent.activeObj.shape || '';\n        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n        parent.currSelectionPoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        parent.objColl.push(parent.activeObj);\n        parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n        var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n        var tempCurrSelObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.currSelectionPoint, {}, true);\n        var preventSelObj = { bool: null };\n        parent.notify('transform', { prop: 'getPreventSelect', onPropertyChange: false, value: { obj: preventSelObj } });\n        parent.notify('transform', { prop: 'setPreventSelect', onPropertyChange: false, value: { bool: true } });\n        var coll = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.rotateFlipColl, [], true);\n        this.panToSelRangle(true);\n        activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });\n        parent.objColl.pop();\n        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n        parent.objColl.push(parent.activeObj);\n        // For reverse straightening\n        var straighten = parent.transform.straighten;\n        if (straighten !== 0) {\n            parent.transform.straighten = 0;\n            parent.straightenBaseImageCanvas();\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });\n        }\n        this.resetZoom();\n        var afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n        this.revertTransform('initial', coll);\n        // Perform straighten\n        if (straighten !== 0) {\n            parent.transform.straighten = (flipState === 'horizontal' || flipState === 'vertical') ? -straighten : straighten;\n            parent.straightenBaseImageCanvas();\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n        }\n        activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });\n        parent.objColl.pop();\n        parent.transform.degree = 0;\n        // Checking for selection inside image\n        var object = { isIntersect: null };\n        parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });\n        parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: object } });\n        var count = 0;\n        while (straighten !== 0 && object['isIntersect']) {\n            count++;\n            if (count === 50) {\n                break;\n            }\n            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,\n                value: { zoomFactor: 0.025, zoomPoint: null }, isResize: null });\n            parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });\n            parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: object } });\n        }\n        this.cropImg(true);\n        this.revertTransform('reverse', coll);\n        parent.afterCropActions = afterCropActions;\n        parent.currSelectionPoint = tempCurrSelObj;\n        parent.notify('transform', { prop: 'setPreventSelect', onPropertyChange: false, value: { bool: preventSelObj['bool'] } });\n        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });\n        if (shape === 'crop-circle') {\n            this.cropCircle(this.lowerContext);\n        }\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });\n    };\n    Crop.prototype.revertTransform = function (type, coll) {\n        var parent = this.parent;\n        var obj = { isRotate: false };\n        if (type === 'initial') {\n            for (var i = coll.length - 1; i >= 0; i--) {\n                var value = coll[i];\n                switch (value) {\n                    case 90:\n                        parent.notify('transform', { prop: 'rotate', value: { degree: -90, obj: obj } });\n                        break;\n                    case -90:\n                        parent.notify('transform', { prop: 'rotate', value: { degree: 90, obj: obj } });\n                        break;\n                    default:\n                        parent.notify('transform', { prop: 'flipImage', value: { direction: parent.toPascalCase(value.toString()) } });\n                        break;\n                }\n            }\n        }\n        else {\n            this.updateFlipState();\n            for (var i = 0, len = coll.length; i < len; i++) {\n                var value = coll[i];\n                switch (value) {\n                    case 90:\n                        parent.notify('transform', { prop: 'rotate', value: { degree: 90, obj: obj } });\n                        break;\n                    case -90:\n                        parent.notify('transform', { prop: 'rotate', value: { degree: -90, obj: obj } });\n                        break;\n                    default:\n                        parent.notify('transform', { prop: 'flipImage', value: { direction: parent.toPascalCase(value.toString()) } });\n                        break;\n                }\n            }\n        }\n    };\n    Crop.prototype.updateFlipState = function () {\n        var parent = this.parent;\n        var objColl = parent.objColl;\n        for (var i = 0, len = objColl.length; i < len; i++) {\n            objColl[i].shapeFlip = '';\n        }\n        // eslint-disable-next-line\n        var pointColl = parent.pointColl;\n        for (var i = 0; i < parent.freehandCounter; i++) {\n            pointColl[i].shapeFlip = '';\n        }\n    };\n    Crop.prototype.resetZoom = function () {\n        var parent = this.parent;\n        if (parent.transform.zoomFactor > 0) {\n            var zoomFactor = parent.transform.zoomFactor;\n            var isUndoRedo = parent.isUndoRedo;\n            parent.setProperties({ zoomSettings: { zoomFactor: (zoomFactor * 10) } }, true);\n            parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,\n                value: { previousZoomValue: parent.zoomSettings.zoomFactor } });\n            for (var i = 0; i < (zoomFactor * 10); i++) {\n                parent.isUndoRedo = true;\n                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,\n                    value: { zoomFactor: -0.1, zoomPoint: null }, isResize: null });\n            }\n            parent.isUndoRedo = isUndoRedo;\n            parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });\n        }\n    };\n    Crop.prototype.flipCrop = function () {\n        var parent = this.parent;\n        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: true } });\n        parent.panPoint.totalPannedPoint.x += this.tempFlipPanPoint.x;\n        parent.panPoint.totalPannedPoint.y += this.tempFlipPanPoint.y;\n        var tempCurrFlipState = parent.transform.currFlipState;\n        var obj = { flipColl: null };\n        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });\n        var tempFlipColl = obj['flipColl'];\n        parent.notify('transform', { prop: 'setFlipColl', onPropertyChange: false, value: { flipColl: [] } });\n        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n        parent.objColl.push(parent.activeObj);\n        if (parent.transform.degree === 0) {\n            var panX = -parent.cropObj.totalPannedPoint.x;\n            var panY = -parent.cropObj.totalPannedPoint.y;\n            parent.img.destLeft += panX;\n            parent.img.destTop += panY;\n            parent.notify('transform', { prop: 'drawPannImage', value: { point: { x: panX, y: panY } } });\n            parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });\n            parent.objColl.pop();\n            parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n            parent.objColl.push(parent.activeObj);\n        }\n        this.resetZoom();\n        parent.currSelectionPoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        var temp = this.lowerContext.filter;\n        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });\n        this.updateFlipState();\n        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: this.getCurrFlipState() } });\n        parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,\n            value: { value: this.getCurrFlipState() } });\n        parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n        parent.objColl.pop();\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });\n        this.cropImg(true);\n        parent.notify('transform', { prop: 'setReverseRotate', onPropertyChange: false, value: { bool: true } });\n        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);\n        parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });\n        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,\n            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });\n        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });\n        this.lowerContext.filter = temp;\n        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });\n        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,\n            value: { type: 'reverse', isPreventDestination: null, context: null, isPreventCircleCrop: null } });\n        parent.transform.currFlipState = tempCurrFlipState;\n        parent.notify('transform', { prop: 'setFlipColl', onPropertyChange: false, value: { flipColl: tempFlipColl } });\n        this.lowerContext.filter = 'none';\n        this.updateFlipState();\n        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: this.getCurrFlipState() } });\n        parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,\n            value: { value: this.getCurrFlipState() } });\n        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n        this.lowerContext.filter = temp;\n        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {\n            this.cropCircle(this.lowerContext);\n        }\n        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: false } });\n        parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });\n        this.tempFlipPanPoint = { x: 0, y: 0 };\n    };\n    Crop.prototype.cropObjColl = function () {\n        var parent = this.parent;\n        var point;\n        var shape;\n        var obj;\n        if (parent.objColl.length > 0) {\n            for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                obj = parent.objColl[i];\n                point = obj.activePoint;\n                var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;\n                shape = obj.shape;\n                obj.imageRatio = { startX: ((point.startX - startX) / width),\n                    startY: ((point.startY - startY) / height),\n                    endX: ((point.endX - startX) / width), endY: ((point.endY - startY) / height),\n                    width: width / point.width, height: height / point.height };\n                var degree = void 0;\n                var size = void 0;\n                switch (shape) {\n                    case 'text':\n                        degree = (obj.shapeDegree === 0) ? parent.transform.degree : parent.transform.degree - obj.shapeDegree;\n                        size = (degree === 0 || Math.abs(degree) === 180) ? point.width : point.height;\n                        obj.textSettings.fontRatio = size / obj.textSettings.fontSize;\n                        break;\n                    case 'line':\n                    case 'arrow':\n                        this.cropPointCollection(i);\n                        if (shape === 'arrow') {\n                            parent.notify('shape', { prop: 'updateArrowRatio', onPropertyChange: false, value: { obj: obj } });\n                        }\n                        break;\n                    case 'path':\n                        this.cropPointCollection(i);\n                        break;\n                }\n            }\n        }\n    };\n    Crop.prototype.cropPointCollection = function (i) {\n        var parent = this.parent;\n        var shape = parent.objColl[i].shape;\n        var x;\n        var y;\n        var width;\n        var height;\n        var point = parent.activeObj.activePoint;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        if (shape === 'path') {\n            x = point.startX;\n            y = point.startY;\n            width = point.width;\n            height = point.height;\n        }\n        else {\n            x = destLeft;\n            y = destTop;\n            width = destWidth;\n            height = destHeight;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var pointColl = parent.objColl[i].pointColl;\n        for (var n = 0, len = pointColl.length; n < len; n++) {\n            pointColl[n].ratioX = (pointColl[n].x - x) / width;\n            pointColl[n].ratioY = (pointColl[n].y - y) / height;\n        }\n    };\n    Crop.prototype.cropFreehandDrawColl = function () {\n        var parent = this.parent;\n        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n            parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });\n            var len = parent.points.length;\n            for (var l = 0; l < len; l++) {\n                parent.points[l].ratioX = (parent.points[l].x - startX) / width;\n                parent.points[l].ratioY = (parent.points[l].y - startY) / height;\n            }\n        }\n        parent.notify('freehand-draw', { prop: 'updateCropPtsForSel', onPropertyChange: false });\n    };\n    Crop.prototype.resetAnnotations = function () {\n        var parent = this.parent;\n        parent.objColl = [];\n        parent.pointColl = [];\n        parent.freehandCounter = 0;\n        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });\n    };\n    Crop.prototype.setCurrSelPoints = function (isSetDimension) {\n        var parent = this.parent;\n        parent.allowDownScale = false;\n        var destPoint = this.cropDestPoints;\n        var filter = this.lowerContext.filter;\n        var isCropTab = parent.isCropTab;\n        parent.img = { srcLeft: 0, srcTop: 0, srcWidth: parent.baseImgCanvas.width, srcHeight: parent.baseImgCanvas.height,\n            destLeft: destPoint.startX, destTop: destPoint.startY, destWidth: destPoint.width, destHeight: destPoint.height };\n        var img = parent.img;\n        var currSelPoint = parent.currSelectionPoint;\n        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n        if (isSetDimension) {\n            parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });\n        }\n        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,\n            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });\n        if (this.croppedDegree === 0 && parent.transform.degree === 0 && currSelPoint\n            && currSelPoint.shape !== 'crop-circle' && currSelPoint.shape !== 'crop-square') {\n            img.destLeft = destPoint.startX;\n            img.destTop = destPoint.startY;\n            img.destWidth = destPoint.width;\n            img.destHeight = destPoint.height;\n        }\n        if (parent.transform.degree === 0) {\n            img.destLeft += parent.panPoint.totalPannedInternalPoint.x;\n            img.destTop += parent.panPoint.totalPannedInternalPoint.y;\n        }\n        parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });\n        this.lowerContext.filter = filter;\n        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,\n            value: { type: 'reverse', isPreventDestination: null, context: null, isPreventCircleCrop: true } });\n        var cropObjColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, null, true);\n        var cropPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, null, true);\n        var straightenObj = { straightenPoint: null };\n        parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false,\n            value: { obj: straightenObj } });\n        this.resetAnnotations();\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {\n            parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj.activeObj, null, true);\n        }\n        this.panToSelRangle();\n        parent.isCropTab = isCropTab;\n        parent.objColl = cropObjColl;\n        parent.pointColl = cropPointColl;\n        parent.freehandCounter = parent.pointColl.length;\n        if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {\n            parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false,\n                value: { x: straightenObj['straightenPoint']['x'], y: straightenObj['straightenPoint']['y'],\n                    ratioX: straightenObj['straightenPoint']['ratioX'], ratioY: straightenObj['straightenPoint']['ratioY'] } });\n        }\n        if (parent.cropObj.activeObj.shape) {\n            var destPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };\n            if (currSelPoint && currSelPoint.activePoint) {\n                var _a = currSelPoint.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;\n                img.destLeft = startX;\n                img.destTop = startY;\n                img.destWidth = width;\n                img.destHeight = height;\n            }\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n            img.destLeft = destPoints.startX;\n            img.destTop = destPoints.startY;\n            img.destWidth = destPoints.width;\n            img.destHeight = destPoints.height;\n            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });\n            cropObjColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, null, true);\n            cropPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, null, true);\n            parent.notify('freehand-draw', { prop: 'getStraightenPoint', onPropertyChange: false, value: { obj: straightenObj } });\n            this.resetAnnotations();\n            var object = { selPointColl: null };\n            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: object } });\n            var cropSelPointColl = object['selPointColl'];\n            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false, value: { obj: { selPointColl: [] } } });\n            parent.cropObj.filter = this.lowerContext.filter;\n            var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.currSelectionPoint, null, true);\n            parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: null } });\n            parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, actObj, null, true);\n            var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n            parent.currSelectionPoint = null;\n            parent.isCircleCrop = false;\n            if (parent.transform.degree !== 0) {\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {\n                    parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj.activeObj, null, true);\n                }\n                parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: 0, yDiff: 0 } });\n                parent.panPoint.currentPannedPoint = { x: 0, y: 0 };\n            }\n            parent.objColl = cropObjColl;\n            parent.pointColl = cropPointColl;\n            parent.freehandCounter = parent.pointColl.length;\n            if (straightenObj['straightenPoint']['x'] && straightenObj['straightenPoint']['y']) {\n                parent.notify('freehand-draw', { prop: 'setStraightenPoint', onPropertyChange: false,\n                    value: { x: straightenObj['straightenPoint']['x'], y: straightenObj['straightenPoint']['y'],\n                        ratioX: straightenObj['straightenPoint']['ratioX'], ratioY: straightenObj['straightenPoint']['ratioY'] } });\n            }\n            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,\n                value: { obj: { selPointColl: cropSelPointColl } } });\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });\n            this.adjustStraightenForShapes('reverse', false);\n            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false, value: { isPreventApply: true } });\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n            if (parent.transform.degree === 0) {\n                parent.notify('transform', { prop: 'drawPannImage', onPropertyChange: false,\n                    value: { point: { x: 0, y: 0 } } });\n            }\n            else {\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {\n                    parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj.activeObj, null, true);\n                }\n                parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: 0, yDiff: 0 } });\n                parent.panPoint.currentPannedPoint = { x: 0, y: 0 };\n            }\n            parent.activeObj = activeObj;\n            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });\n            parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,\n                value: { point: null } });\n            if (!this.isInitCrop && parent.transform.degree === 0 && parent.cropObj.currFlipState !== '' &&\n                parent.cropObj.cropZoom !== 0) {\n                this.isInitCrop = true;\n                var obj = { activeObj: null };\n                parent.notify('draw', { prop: 'getStraightenActObj', onPropertyChange: false, value: { obj: obj } });\n                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });\n                parent.notify('draw', { prop: 'setStraightenActObj', onPropertyChange: false, value: { activeObj: obj['activeObj'] } });\n                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'croptransform',\n                        isApplyBtn: false, isCropping: null, isZooming: null, cType: null } });\n            }\n            else {\n                this.isInitCrop = false;\n            }\n        }\n        else {\n            this.adjustStraightenForShapes('reverse', true);\n            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false, value: { isPreventApply: true } });\n            var temp = this.lowerContext.filter;\n            this.lowerContext.filter = 'none';\n            parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });\n            this.lowerContext.filter = temp;\n            parent.currSelectionPoint = null;\n        }\n        if (document.querySelector('.e-ie-straighten-value-span')) {\n            document.querySelector('.e-ie-straighten-value-span').innerHTML = parent.transform.straighten.toString() + '&#176';\n        }\n    };\n    Crop.prototype.panToSelRangle = function (isReverse) {\n        var parent = this.parent;\n        var pannedPoint = parent.cropObj.totalPannedClientPoint;\n        var panX = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.x : pannedPoint.x : 0;\n        var panY = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.y : pannedPoint.y : 0;\n        if (parent.transform.degree !== 0) {\n            parent.panPoint.currentPannedPoint = { x: panX, y: panY };\n            parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: panX, yDiff: panY } });\n            parent.panPoint.currentPannedPoint = { x: 0, y: 0 };\n        }\n    };\n    Crop.prototype.cropCircle = function (context, isSave, isFlip) {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        if (isFlip && parent.transform.currFlipState !== '') {\n            parent.notify('draw', { prop: 'setTransform', onPropertyChange: false,\n                value: { context: context, value: parent.transform.currFlipState, isReverse: null } });\n        }\n        var temp = context.filter;\n        context.filter = 'none';\n        context.globalCompositeOperation = 'destination-in';\n        context.beginPath();\n        var centerX = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isSave) ? destLeft + (destWidth / 2) : context.canvas.width / 2;\n        var centerY = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isSave) ? destTop + (destHeight / 2) : context.canvas.height / 2;\n        var radius = isSave ? context.canvas.width / 2 : destWidth / 2;\n        context.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        context.closePath();\n        context.fill();\n        context.restore();\n        context.globalCompositeOperation = 'source-over';\n        parent.currObjType.isActiveObj = parent.isCircleCrop = true;\n        context.filter = temp;\n        if (isFlip && parent.transform.currFlipState !== '') {\n            parent.notify('draw', { prop: 'setTransform', onPropertyChange: false,\n                value: { context: context, value: parent.transform.currFlipState, isReverse: null } });\n        }\n    };\n    Crop.prototype.getCurrCropState = function () {\n        var parent = this.parent;\n        var flipState = '';\n        var obj = { flipColl: null };\n        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });\n        flipState = this.getCurrFlipState();\n        if (parent.transform.degree === -90 || parent.transform.degree === -270) {\n            if (flipState === 'horizontal') {\n                flipState = 'vertical';\n            }\n            else if (flipState === 'vertical') {\n                flipState = 'horizontal';\n            }\n        }\n        if (flipState === '') {\n            flipState = obj['flipColl'].length > 1 ? this.getCurrFlipState() : parent.transform.currFlipState;\n        }\n        return flipState;\n    };\n    Crop.prototype.updateRotatePan = function () {\n        var parent = this.parent;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.panPoint.currentPannedPoint)) {\n            return;\n        }\n        var panRegion = '';\n        var degree = parent.transform.degree;\n        var _a = parent.panPoint.currentPannedPoint, x = _a.x, y = _a.y;\n        if (parent.rotateFlipColl.length > 0 && typeof (parent.rotateFlipColl[0]) === 'number'\n            && degree < 0) {\n            panRegion = this.getCurrCropState();\n        }\n        else {\n            panRegion = this.getCurrFlipState();\n        }\n        if (degree % 90 === 0 && degree % 180 !== 0) {\n            if (degree === 90 || (degree === -90 && (panRegion === 'horizontal' || panRegion === 'vertical'))\n                || (degree === -270 && (panRegion === '' || panRegion === 'verticalHorizontal'\n                    || panRegion === 'horizontalVertical'))) {\n                if (panRegion === 'horizontal' || panRegion === '') {\n                    parent.img.destLeft += y;\n                }\n                else {\n                    parent.img.destLeft -= y;\n                }\n                if (panRegion === '' || panRegion === 'vertical') {\n                    parent.img.destTop -= x;\n                }\n                else {\n                    parent.img.destTop += x;\n                }\n            }\n            else if (degree === 270 || (degree === -270 && (panRegion === 'horizontal' || panRegion === 'vertical'))\n                || (degree === -90 && (panRegion === '' || panRegion === 'verticalHorizontal'\n                    || panRegion === 'horizontalVertical'))) {\n                if (panRegion === '' || panRegion === 'horizontal') {\n                    parent.img.destLeft -= y;\n                }\n                else {\n                    parent.img.destLeft += y;\n                }\n                if (panRegion === '' || panRegion === 'vertical') {\n                    parent.img.destTop += x;\n                }\n                else {\n                    parent.img.destTop -= x;\n                }\n            }\n        }\n        else {\n            if (degree === 180 || degree === -180) {\n                if (panRegion === '' || panRegion === 'vertical') {\n                    parent.img.destLeft -= x;\n                }\n                else {\n                    parent.img.destLeft += x;\n                }\n                if (panRegion === '' || panRegion === 'horizontal') {\n                    parent.img.destTop -= y;\n                }\n                else {\n                    parent.img.destTop += y;\n                }\n            }\n        }\n    };\n    Crop.prototype.crop = function (obj) {\n        var parent = this.parent;\n        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;\n        if (!parent.disabled && parent.isImageLoaded) {\n            var object = { isCropToolbar: parent.isCropToolbar };\n            if (parent.currObjType.isUndoAction && !object['isCropToolbar']) {\n                parent.notify('undo-redo', { prop: 'refreshUrc', value: { bool: null } });\n            }\n            var transitionArgs = { cancel: false, startPoint: { x: startX, y: startY },\n                endPoint: { x: endX, y: endY }, preventScaling: false };\n            if (!object['isCropToolbar']) {\n                parent.trigger('cropping', transitionArgs);\n                parent.editCompleteArgs = transitionArgs;\n            }\n            this.cropEvent(transitionArgs, obj, object);\n        }\n    };\n    Crop.prototype.cropEvent = function (transitionArgs, obj, object) {\n        var parent = this.parent;\n        var splitWords;\n        if (!transitionArgs.cancel) {\n            splitWords = parent.activeObj.shape ? parent.activeObj.shape.split('-') : [];\n            if (!parent.disabled && parent.activeObj.horTopLine && (parent.currObjType.isCustomCrop || (splitWords.length > 0 &&\n                splitWords[0] === 'crop'))) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                obj.isCrop = true;\n                var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n                var prevObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.prevCropCurrObj, {}, true);\n                if (transitionArgs.preventScaling) {\n                    this.isPreventScaling = true;\n                }\n                else {\n                    this.isPreventScaling = false;\n                }\n                this.cropImg();\n                if (this.isPreventScaling) {\n                    parent.aspectWidth = parent.img.destWidth;\n                    parent.aspectHeight = parent.img.destHeight;\n                }\n                parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });\n                parent.isCropTab = false;\n                parent.transform.zoomFactor = 0;\n                parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);\n                parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,\n                    value: { previousZoomValue: parent.zoomSettings.zoomFactor } });\n                if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n                    this.updateUndoRedoColl(prevObj, prevCropObj, object);\n                }\n                parent.notify('transform', { prop: 'setCropDimension', onPropertyChange: false,\n                    value: { width: parent.cropObj.destPoints.width, height: parent.cropObj.destPoints.height } });\n                var aspectIcon = parent.element.querySelector('#' + parent.element.id + '_aspectratio');\n                var nonAspectIcon = parent.element.querySelector('#' + parent.element.id + '_nonaspectratio');\n                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });\n                if (!object['isCropToolbar'] && ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(aspectIcon) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(nonAspectIcon))) {\n                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',\n                            isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });\n                }\n                this.resizeWrapper();\n                if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n                    this.updateUndoRedoColl(prevObj, prevCropObj, object);\n                }\n            }\n        }\n    };\n    Crop.prototype.updateUndoRedoColl = function (prevObj, prevCropObj, object) {\n        var parent = this.parent;\n        var currSelPtObj = { prevCurrSelectionPoint: parent.prevCurrSelectionPoint };\n        prevObj.currSelectionPoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, currSelPtObj['prevCurrSelectionPoint'], {}, true);\n        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n            value: { operation: 'crop', previousObj: prevObj, previousObjColl: prevObj.objColl,\n                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                previousCropObj: prevCropObj, previousText: null,\n                currentText: null, previousFilter: null, isCircleCrop: parent.isCircleCrop } });\n        if (!object['isCropToolbar']) {\n            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n        }\n    };\n    Crop.prototype.resizeWrapper = function () {\n        var parent = this.parent;\n        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var elem = parent.element;\n            var ctxToolbar = elem.querySelector('#' + elem.id + '_contextualToolbarArea');\n            if (ctxToolbar && ctxToolbar.style.position === '' && !this.isTransformCrop) {\n                ctxToolbar.style.position = 'absolute';\n                parent.isStraightening = false;\n                parent.update();\n                parent.notify('filter', { prop: 'setAdjustmentValue', value: { adjustmentValue: parent.canvasFilter } });\n            }\n        }\n    };\n    Crop.prototype.calcRatio = function (obj, dimension) {\n        var parent = this.parent;\n        var degree = parent.transform.degree;\n        var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        var _b = dimension || parent.baseImgCanvas, width = _b.width, height = _b.height;\n        var widthRatio = (degree === 0 || degree % 180 === 0) ? width / destWidth : height / destWidth;\n        var heightRatio = (degree === 0 || degree % 180 === 0) ? height / destHeight : width / destHeight;\n        if (obj) {\n            obj['width'] = widthRatio;\n            obj['height'] = heightRatio;\n        }\n        return { width: widthRatio, height: heightRatio };\n    };\n    Crop.prototype.getCurrFlipState = function (panObj) {\n        var parent = this.parent;\n        var obj = { panRegion: '' };\n        var object = { collection: parent.rotateFlipColl };\n        parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,\n            value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: object } });\n        parent.rotateFlipColl = object['collection'];\n        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {\n            parent.notify('transform', { prop: 'setCurrPanRegion', onPropertyChange: false,\n                value: { region: obj['panRegion'], type: parent.rotateFlipColl[i], obj: obj } });\n        }\n        if (panObj) {\n            panObj['panRegion'] = obj['panRegion'];\n        }\n        return obj['panRegion'];\n    };\n    return Crop;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/crop.js?");

/***/ })

}]);