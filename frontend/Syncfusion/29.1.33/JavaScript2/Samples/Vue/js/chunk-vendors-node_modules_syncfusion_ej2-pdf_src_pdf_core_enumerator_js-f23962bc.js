"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdf_src_pdf_core_enumerator_js-f23962bc"],{

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/enumerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/enumerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataFormat: () => (/* binding */ DataFormat),\n/* harmony export */   PathPointType: () => (/* binding */ PathPointType),\n/* harmony export */   PdfAnnotationFlag: () => (/* binding */ PdfAnnotationFlag),\n/* harmony export */   PdfAnnotationIntent: () => (/* binding */ PdfAnnotationIntent),\n/* harmony export */   PdfAnnotationState: () => (/* binding */ PdfAnnotationState),\n/* harmony export */   PdfAnnotationStateModel: () => (/* binding */ PdfAnnotationStateModel),\n/* harmony export */   PdfAttachmentIcon: () => (/* binding */ PdfAttachmentIcon),\n/* harmony export */   PdfBlendMode: () => (/* binding */ PdfBlendMode),\n/* harmony export */   PdfBorderEffectStyle: () => (/* binding */ PdfBorderEffectStyle),\n/* harmony export */   PdfBorderStyle: () => (/* binding */ PdfBorderStyle),\n/* harmony export */   PdfCheckBoxStyle: () => (/* binding */ PdfCheckBoxStyle),\n/* harmony export */   PdfCircleMeasurementType: () => (/* binding */ PdfCircleMeasurementType),\n/* harmony export */   PdfCrossReferenceType: () => (/* binding */ PdfCrossReferenceType),\n/* harmony export */   PdfDashStyle: () => (/* binding */ PdfDashStyle),\n/* harmony export */   PdfDestinationMode: () => (/* binding */ PdfDestinationMode),\n/* harmony export */   PdfFillMode: () => (/* binding */ PdfFillMode),\n/* harmony export */   PdfFormFieldVisibility: () => (/* binding */ PdfFormFieldVisibility),\n/* harmony export */   PdfFormFieldsTabOrder: () => (/* binding */ PdfFormFieldsTabOrder),\n/* harmony export */   PdfHighlightMode: () => (/* binding */ PdfHighlightMode),\n/* harmony export */   PdfLayoutBreakType: () => (/* binding */ PdfLayoutBreakType),\n/* harmony export */   PdfLayoutType: () => (/* binding */ PdfLayoutType),\n/* harmony export */   PdfLineCap: () => (/* binding */ PdfLineCap),\n/* harmony export */   PdfLineCaptionType: () => (/* binding */ PdfLineCaptionType),\n/* harmony export */   PdfLineEndingStyle: () => (/* binding */ PdfLineEndingStyle),\n/* harmony export */   PdfLineIntent: () => (/* binding */ PdfLineIntent),\n/* harmony export */   PdfLineJoin: () => (/* binding */ PdfLineJoin),\n/* harmony export */   PdfListMarkerAlignment: () => (/* binding */ PdfListMarkerAlignment),\n/* harmony export */   PdfMeasurementUnit: () => (/* binding */ PdfMeasurementUnit),\n/* harmony export */   PdfNumberStyle: () => (/* binding */ PdfNumberStyle),\n/* harmony export */   PdfPageOrientation: () => (/* binding */ PdfPageOrientation),\n/* harmony export */   PdfPermissionFlag: () => (/* binding */ PdfPermissionFlag),\n/* harmony export */   PdfPopupIcon: () => (/* binding */ PdfPopupIcon),\n/* harmony export */   PdfPrintState: () => (/* binding */ PdfPrintState),\n/* harmony export */   PdfRotationAngle: () => (/* binding */ PdfRotationAngle),\n/* harmony export */   PdfRubberStampAnnotationIcon: () => (/* binding */ PdfRubberStampAnnotationIcon),\n/* harmony export */   PdfSubSuperScript: () => (/* binding */ PdfSubSuperScript),\n/* harmony export */   PdfTextAlignment: () => (/* binding */ PdfTextAlignment),\n/* harmony export */   PdfTextDirection: () => (/* binding */ PdfTextDirection),\n/* harmony export */   PdfTextMarkupAnnotationType: () => (/* binding */ PdfTextMarkupAnnotationType),\n/* harmony export */   PdfTextStyle: () => (/* binding */ PdfTextStyle),\n/* harmony export */   PdfUnorderedListStyle: () => (/* binding */ PdfUnorderedListStyle),\n/* harmony export */   _FieldFlag: () => (/* binding */ _FieldFlag),\n/* harmony export */   _FontDescriptorFlag: () => (/* binding */ _FontDescriptorFlag),\n/* harmony export */   _ImageFormat: () => (/* binding */ _ImageFormat),\n/* harmony export */   _PdfAnnotationType: () => (/* binding */ _PdfAnnotationType),\n/* harmony export */   _PdfCheckFieldState: () => (/* binding */ _PdfCheckFieldState),\n/* harmony export */   _PdfColorSpace: () => (/* binding */ _PdfColorSpace),\n/* harmony export */   _PdfGraphicsUnit: () => (/* binding */ _PdfGraphicsUnit),\n/* harmony export */   _PdfWordWrapType: () => (/* binding */ _PdfWordWrapType),\n/* harmony export */   _SignatureFlag: () => (/* binding */ _SignatureFlag),\n/* harmony export */   _TokenType: () => (/* binding */ _TokenType),\n/* harmony export */   _TrueTypeCmapEncoding: () => (/* binding */ _TrueTypeCmapEncoding),\n/* harmony export */   _TrueTypeCmapFormat: () => (/* binding */ _TrueTypeCmapFormat),\n/* harmony export */   _TrueTypeCompositeGlyphFlag: () => (/* binding */ _TrueTypeCompositeGlyphFlag),\n/* harmony export */   _TrueTypeMacintoshEncodingID: () => (/* binding */ _TrueTypeMacintoshEncodingID),\n/* harmony export */   _TrueTypeMicrosoftEncodingID: () => (/* binding */ _TrueTypeMicrosoftEncodingID),\n/* harmony export */   _TrueTypePlatformID: () => (/* binding */ _TrueTypePlatformID)\n/* harmony export */ });\n/**\n * Public Enum to define annotation flag types.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfAnnotation = page.annotations.at(0);\n * // Sets the annotation flag to enable print\n * annotation.flags = PdfAnnotationFlag.print;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationFlag;\n(function (PdfAnnotationFlag) {\n    /**\n     * Specifies the type of `default`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"default\"] = 0] = \"default\";\n    /**\n     * Specifies the type of `invisible`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"invisible\"] = 1] = \"invisible\";\n    /**\n     * Specifies the type of `hidden`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"hidden\"] = 2] = \"hidden\";\n    /**\n     * Specifies the type of `print`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"print\"] = 4] = \"print\";\n    /**\n     * Specifies the type of `noZoom`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"noZoom\"] = 8] = \"noZoom\";\n    /**\n     * Specifies the type of `noRotate`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"noRotate\"] = 16] = \"noRotate\";\n    /**\n     * Specifies the type of `noView`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"noView\"] = 32] = \"noView\";\n    /**\n     * Specifies the type of `readOnly`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"readOnly\"] = 64] = \"readOnly\";\n    /**\n     * Specifies the type of `locked`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"locked\"] = 128] = \"locked\";\n    /**\n     * Specifies the type of `toggleNoView`.\n     */\n    PdfAnnotationFlag[PdfAnnotationFlag[\"toggleNoView\"] = 256] = \"toggleNoView\";\n})(PdfAnnotationFlag || (PdfAnnotationFlag = {}));\n/**\n * Public Enum to define line ending style.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;\n * // Sets the begin line end style as openArrow\n * annotation.beginLineStyle = PdfLineEndingStyle.openArrow;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfLineEndingStyle;\n(function (PdfLineEndingStyle) {\n    /**\n     * Specifies the type of `none`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the type of `openArrow`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"openArrow\"] = 1] = \"openArrow\";\n    /**\n     * Specifies the type of `closedArrow`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"closedArrow\"] = 2] = \"closedArrow\";\n    /**\n     * Specifies the type of `rOpenArrow`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"rOpenArrow\"] = 3] = \"rOpenArrow\";\n    /**\n     * Specifies the type of `rClosedArrow`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"rClosedArrow\"] = 4] = \"rClosedArrow\";\n    /**\n     * Specifies the type of `butt`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"butt\"] = 5] = \"butt\";\n    /**\n     * Specifies the type of `diamond`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"diamond\"] = 6] = \"diamond\";\n    /**\n     * Specifies the type of `circle`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"circle\"] = 7] = \"circle\";\n    /**\n     * Specifies the type of `square`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"square\"] = 8] = \"square\";\n    /**\n     * Specifies the type of `slash`.\n     */\n    PdfLineEndingStyle[PdfLineEndingStyle[\"slash\"] = 9] = \"slash\";\n})(PdfLineEndingStyle || (PdfLineEndingStyle = {}));\n/**\n * Public Enum to define line indent.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n * // Sets the line intent as lineArrow\n * annotation.lineIntent = PdfLineIntent.lineArrow;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfLineIntent;\n(function (PdfLineIntent) {\n    /**\n     * Specifies the type of `lineArrow`.\n     */\n    PdfLineIntent[PdfLineIntent[\"lineArrow\"] = 0] = \"lineArrow\";\n    /**\n     * Specifies the type of `lineDimension`.\n     */\n    PdfLineIntent[PdfLineIntent[\"lineDimension\"] = 1] = \"lineDimension\";\n})(PdfLineIntent || (PdfLineIntent = {}));\n/**\n * Public Enum to define the types of points and segments in a path.\n *\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access the first page\n * let page: PdfPage = document.getPage(0);\n * // Create a new pen\n * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n * // Create a new brush\n * let brush: PdfBrush = new PdfBrush([0, 255, 255]);\n * // Add path points\n * let pathPoints: Array<number[]> = [[50, 50], [100, 50], [100, 100], [50, 100], [50, 50]];\n * // Add path types\n * let pathTypes: PathPointType[] = [0, 1, 1, 1, 1];\n * // Create a new PDF path\n * let path: PdfPath = new PdfPath(pathPoints, pathTypes);\n * // Draw the path to the PDF page\n * page.graphics.drawPath(path, pen, brush);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PathPointType;\n(function (PathPointType) {\n    /**\n     * The starting point of a path.\n     */\n    PathPointType[PathPointType[\"start\"] = 0] = \"start\";\n    /**\n     * A straight line segment.\n     */\n    PathPointType[PathPointType[\"line\"] = 1] = \"line\";\n    /**\n     * A Bezier curve segment.\n     */\n    PathPointType[PathPointType[\"bezier\"] = 3] = \"bezier\";\n    /**\n     * A mask for extracting the type of a point.\n     */\n    PathPointType[PathPointType[\"pathTypeMask\"] = 7] = \"pathTypeMask\";\n    /**\n     * Indicates that the segment has dashed line style.\n     */\n    PathPointType[PathPointType[\"dashMode\"] = 16] = \"dashMode\";\n    /**\n     * Indicates a marker point in the path.\n     */\n    PathPointType[PathPointType[\"pathMarker\"] = 32] = \"pathMarker\";\n    /**\n     * Closes the current path.\n     */\n    PathPointType[PathPointType[\"closePath\"] = 128] = \"closePath\";\n})(PathPointType || (PathPointType = {}));\n/**\n * Public Enum to define line caption type.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfAnnotation = page.annotations.at(0);\n * // Sets the line caption type as inline\n * annotation.caption.type = PdfLineCaptionType.inline;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfLineCaptionType;\n(function (PdfLineCaptionType) {\n    /**\n     * Specifies the type of `inline`.\n     */\n    PdfLineCaptionType[PdfLineCaptionType[\"inline\"] = 0] = \"inline\";\n    /**\n     * Specifies the type of `top`.\n     */\n    PdfLineCaptionType[PdfLineCaptionType[\"top\"] = 1] = \"top\";\n})(PdfLineCaptionType || (PdfLineCaptionType = {}));\n/**\n * Public Enum to define border style.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfAnnotation = page.annotations.at(0);\n * // Sets the border style as underline\n * annotation.border.style = PdfBorderStyle.underline;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfBorderStyle;\n(function (PdfBorderStyle) {\n    /**\n     * Specifies the type of `solid`.\n     */\n    PdfBorderStyle[PdfBorderStyle[\"solid\"] = 0] = \"solid\";\n    /**\n     * Specifies the type of `dashed`.\n     */\n    PdfBorderStyle[PdfBorderStyle[\"dashed\"] = 1] = \"dashed\";\n    /**\n     * Specifies the type of `beveled`.\n     */\n    PdfBorderStyle[PdfBorderStyle[\"beveled\"] = 2] = \"beveled\";\n    /**\n     * Specifies the type of `inset`.\n     */\n    PdfBorderStyle[PdfBorderStyle[\"inset\"] = 3] = \"inset\";\n    /**\n     * Specifies the type of `underline`.\n     */\n    PdfBorderStyle[PdfBorderStyle[\"underline\"] = 4] = \"underline\";\n    /**\n     * Specifies the type of `dot`.\n     */\n    PdfBorderStyle[PdfBorderStyle[\"dot\"] = 5] = \"dot\";\n})(PdfBorderStyle || (PdfBorderStyle = {}));\n/**\n * Public Enum to define border effect style.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfAnnotation = page.annotations.at(0);\n * // Sets the border effect as underline\n * annotation.borderEffect.style = PdfBorderEffectStyle.cloudy;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfBorderEffectStyle;\n(function (PdfBorderEffectStyle) {\n    /**\n     * Specifies the type of `solid`.\n     */\n    PdfBorderEffectStyle[PdfBorderEffectStyle[\"solid\"] = 0] = \"solid\";\n    /**\n     * Specifies the type of `cloudy`.\n     */\n    PdfBorderEffectStyle[PdfBorderEffectStyle[\"cloudy\"] = 1] = \"cloudy\";\n})(PdfBorderEffectStyle || (PdfBorderEffectStyle = {}));\n/**\n * Public Enum to define rotation of the interactive elements.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access text box field\n * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;\n * // Gets the rotation of the field\n * let rotation: PdfRotationAngle = field.rotationAngle;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfRotationAngle;\n(function (PdfRotationAngle) {\n    /**\n     * Specifies the type of `angle0`.\n     */\n    PdfRotationAngle[PdfRotationAngle[\"angle0\"] = 0] = \"angle0\";\n    /**\n     * Specifies the type of `angle90`.\n     */\n    PdfRotationAngle[PdfRotationAngle[\"angle90\"] = 1] = \"angle90\";\n    /**\n     * Specifies the type of `angle180`.\n     */\n    PdfRotationAngle[PdfRotationAngle[\"angle180\"] = 2] = \"angle180\";\n    /**\n     * Specifies the type of `angle270`.\n     */\n    PdfRotationAngle[PdfRotationAngle[\"angle270\"] = 3] = \"angle270\";\n})(PdfRotationAngle || (PdfRotationAngle = {}));\n/**\n * Public Enum to define cross reference type.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Save the document with cross reference type as stream\n * document.save('output.pdf', PdfCrossReferenceType.stream);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfCrossReferenceType;\n(function (PdfCrossReferenceType) {\n    /**\n     * Specifies the type of `table`.\n     */\n    PdfCrossReferenceType[PdfCrossReferenceType[\"table\"] = 0] = \"table\";\n    /**\n     * Specifies the type of `stream`.\n     */\n    PdfCrossReferenceType[PdfCrossReferenceType[\"stream\"] = 1] = \"stream\";\n})(PdfCrossReferenceType || (PdfCrossReferenceType = {}));\n/**\n * Public Enum to define highlight mode of text box field.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access text box field\n * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;\n * // Sets the highlight mode of text box field as outline\n * field.highlightMode = PdfHighlightMode.outline;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfHighlightMode;\n(function (PdfHighlightMode) {\n    /**\n     * Specifies the type of `noHighlighting`.\n     */\n    PdfHighlightMode[PdfHighlightMode[\"noHighlighting\"] = 0] = \"noHighlighting\";\n    /**\n     * Specifies the type of `invert`.\n     */\n    PdfHighlightMode[PdfHighlightMode[\"invert\"] = 1] = \"invert\";\n    /**\n     * Specifies the type of `outline`.\n     */\n    PdfHighlightMode[PdfHighlightMode[\"outline\"] = 2] = \"outline\";\n    /**\n     * Specifies the type of `push`.\n     */\n    PdfHighlightMode[PdfHighlightMode[\"push\"] = 3] = \"push\";\n})(PdfHighlightMode || (PdfHighlightMode = {}));\n/**\n * Public Enum to define text alignment of text box field.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access text box field\n * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;\n * // Sets the text alignment of form field as center\n * field.textAlignment = PdfTextAlignment.center;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfTextAlignment;\n(function (PdfTextAlignment) {\n    /**\n     * Specifies the type of `left`.\n     */\n    PdfTextAlignment[PdfTextAlignment[\"left\"] = 0] = \"left\";\n    /**\n     * Specifies the type of `center`.\n     */\n    PdfTextAlignment[PdfTextAlignment[\"center\"] = 1] = \"center\";\n    /**\n     * Specifies the type of `right`.\n     */\n    PdfTextAlignment[PdfTextAlignment[\"right\"] = 2] = \"right\";\n    /**\n     * Specifies the type of `justify`.\n     */\n    PdfTextAlignment[PdfTextAlignment[\"justify\"] = 3] = \"justify\";\n})(PdfTextAlignment || (PdfTextAlignment = {}));\n/**\n * Public Enum to define visibility of form field.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access PDF form field\n * let field: PdfField = document.form.fieldAt(0);\n * // Sets the visibility of form field as hidden\n * field.visibility = PdfFormFieldVisibility.hidden;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfFormFieldVisibility;\n(function (PdfFormFieldVisibility) {\n    /**\n     * Specifies the type of `visible`.\n     */\n    PdfFormFieldVisibility[PdfFormFieldVisibility[\"visible\"] = 0] = \"visible\";\n    /**\n     * Specifies the type of `hidden`.\n     */\n    PdfFormFieldVisibility[PdfFormFieldVisibility[\"hidden\"] = 1] = \"hidden\";\n    /**\n     * Specifies the type of `visibleNotPrintable`.\n     */\n    PdfFormFieldVisibility[PdfFormFieldVisibility[\"visibleNotPrintable\"] = 2] = \"visibleNotPrintable\";\n    /**\n     * Specifies the type of `hiddenPrintable`.\n     */\n    PdfFormFieldVisibility[PdfFormFieldVisibility[\"hiddenPrintable\"] = 3] = \"hiddenPrintable\";\n})(PdfFormFieldVisibility || (PdfFormFieldVisibility = {}));\n/**\n * Public Enum to define measurement unit of line measurement annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfLineAnnotation = page.annotations.at(0) PdfLineAnnotation;\n * // Sets the measurement unit of line measurement annoation as centimeter\n * annotation.unit = PdfMeasurementUnit.centimeter;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfMeasurementUnit;\n(function (PdfMeasurementUnit) {\n    /**\n     * Specifies the type of `inch`.\n     */\n    PdfMeasurementUnit[PdfMeasurementUnit[\"inch\"] = 0] = \"inch\";\n    /**\n     * Specifies the type of `pica`.\n     */\n    PdfMeasurementUnit[PdfMeasurementUnit[\"pica\"] = 1] = \"pica\";\n    /**\n     * Specifies the type of `point`.\n     */\n    PdfMeasurementUnit[PdfMeasurementUnit[\"point\"] = 3] = \"point\";\n    /**\n     * Specifies the type of `centimeter`.\n     */\n    PdfMeasurementUnit[PdfMeasurementUnit[\"centimeter\"] = 4] = \"centimeter\";\n    /**\n     * Specifies the type of `millimeter`.\n     */\n    PdfMeasurementUnit[PdfMeasurementUnit[\"millimeter\"] = 6] = \"millimeter\";\n})(PdfMeasurementUnit || (PdfMeasurementUnit = {}));\n/**\n * Public Enum to define measurement type of circle annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfCircleAnnotation = page.annotations.at(0) PdfCircleAnnotation;\n * // Sets the measurement type of circle annotation as diameter\n * annotation.measureType = PdfCircleMeasurementType.diameter;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfCircleMeasurementType;\n(function (PdfCircleMeasurementType) {\n    /**\n     * Specifies the type of `diameter`.\n     */\n    PdfCircleMeasurementType[PdfCircleMeasurementType[\"diameter\"] = 0] = \"diameter\";\n    /**\n     * Specifies the type of `radius`.\n     */\n    PdfCircleMeasurementType[PdfCircleMeasurementType[\"radius\"] = 1] = \"radius\";\n})(PdfCircleMeasurementType || (PdfCircleMeasurementType = {}));\n/**\n * Public Enum to define icon type of rubber stamp annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) PdfRubberStampAnnotation;\n * // Sets the rubber stamp annotation icon type as confidential\n * annotation.icon = PdfRubberStampAnnotationIcon.confidential;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfRubberStampAnnotationIcon;\n(function (PdfRubberStampAnnotationIcon) {\n    /**\n     * Specifies the type of `approved`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"approved\"] = 0] = \"approved\";\n    /**\n     * Specifies the type of `asIs`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"asIs\"] = 1] = \"asIs\";\n    /**\n     * Specifies the type of `confidential`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"confidential\"] = 2] = \"confidential\";\n    /**\n     * Specifies the type of `departmental`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"departmental\"] = 3] = \"departmental\";\n    /**\n     * Specifies the type of `draft`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"draft\"] = 4] = \"draft\";\n    /**\n     * Specifies the type of `experimental`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"experimental\"] = 5] = \"experimental\";\n    /**\n     * Specifies the type of `expired`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"expired\"] = 6] = \"expired\";\n    /**\n     * Specifies the type of `final`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"final\"] = 7] = \"final\";\n    /**\n     * Specifies the type of `forComment`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"forComment\"] = 8] = \"forComment\";\n    /**\n     * Specifies the type of `forPublicRelease`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"forPublicRelease\"] = 9] = \"forPublicRelease\";\n    /**\n     * Specifies the type of `notApproved`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"notApproved\"] = 10] = \"notApproved\";\n    /**\n     * Specifies the type of `notForPublicRelease`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"notForPublicRelease\"] = 11] = \"notForPublicRelease\";\n    /**\n     * Specifies the type of `sold`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"sold\"] = 12] = \"sold\";\n    /**\n     * Specifies the type of `topSecret`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"topSecret\"] = 13] = \"topSecret\";\n    /**\n     * Specifies the type of `completed`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"completed\"] = 14] = \"completed\";\n    /**\n     * Specifies the type of `void`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"void\"] = 15] = \"void\";\n    /**\n     * Specifies the type of `informationOnly`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"informationOnly\"] = 16] = \"informationOnly\";\n    /**\n     * Specifies the type of `preliminaryResults`.\n     */\n    PdfRubberStampAnnotationIcon[PdfRubberStampAnnotationIcon[\"preliminaryResults\"] = 17] = \"preliminaryResults\";\n})(PdfRubberStampAnnotationIcon || (PdfRubberStampAnnotationIcon = {}));\n/**\n * Public Enum to define check box style.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access check box field\n * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;\n * // Access first item of check box field\n * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;\n * // Sets the check box style as check\n * item.style = PdfCheckBoxStyle.check;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfCheckBoxStyle;\n(function (PdfCheckBoxStyle) {\n    /**\n     * Specifies the type of `check`.\n     */\n    PdfCheckBoxStyle[PdfCheckBoxStyle[\"check\"] = 0] = \"check\";\n    /**\n     * Specifies the type of `circle`.\n     */\n    PdfCheckBoxStyle[PdfCheckBoxStyle[\"circle\"] = 1] = \"circle\";\n    /**\n     * Specifies the type of `cross`.\n     */\n    PdfCheckBoxStyle[PdfCheckBoxStyle[\"cross\"] = 2] = \"cross\";\n    /**\n     * Specifies the type of `diamond`.\n     */\n    PdfCheckBoxStyle[PdfCheckBoxStyle[\"diamond\"] = 3] = \"diamond\";\n    /**\n     * Specifies the type of `square`.\n     */\n    PdfCheckBoxStyle[PdfCheckBoxStyle[\"square\"] = 4] = \"square\";\n    /**\n     * Specifies the type of `star`.\n     */\n    PdfCheckBoxStyle[PdfCheckBoxStyle[\"star\"] = 5] = \"star\";\n})(PdfCheckBoxStyle || (PdfCheckBoxStyle = {}));\n/**\n * Public Enum to define type of text markup annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) PdfTextMarkupAnnotation;\n * // Sets the type of the text markup annotation as underline\n * annotation.textMarkupType = PdfTextMarkupAnnotationType.underline;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfTextMarkupAnnotationType;\n(function (PdfTextMarkupAnnotationType) {\n    /**\n     * Specifies the type of `highlight`.\n     */\n    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType[\"highlight\"] = 0] = \"highlight\";\n    /**\n     * Specifies the type of `underline`.\n     */\n    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType[\"underline\"] = 1] = \"underline\";\n    /**\n     * Specifies the type of `squiggly`.\n     */\n    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType[\"squiggly\"] = 2] = \"squiggly\";\n    /**\n     * Specifies the type of `strikeOut`.\n     */\n    PdfTextMarkupAnnotationType[PdfTextMarkupAnnotationType[\"strikeOut\"] = 3] = \"strikeOut\";\n})(PdfTextMarkupAnnotationType || (PdfTextMarkupAnnotationType = {}));\n/**\n * Public Enum to define icon type of popup annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;\n * // Sets the icon type of the popup annotation as comment\n * annotation.icon = PdfPopupIcon.comment;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPopupIcon;\n(function (PdfPopupIcon) {\n    /**\n     * Specifies the type of `note`.\n     */\n    PdfPopupIcon[PdfPopupIcon[\"note\"] = 0] = \"note\";\n    /**\n     * Specifies the type of `comment`.\n     */\n    PdfPopupIcon[PdfPopupIcon[\"comment\"] = 1] = \"comment\";\n    /**\n     * Specifies the type of `help`.\n     */\n    PdfPopupIcon[PdfPopupIcon[\"help\"] = 2] = \"help\";\n    /**\n     * Specifies the type of `insert`.\n     */\n    PdfPopupIcon[PdfPopupIcon[\"insert\"] = 3] = \"insert\";\n    /**\n     * Specifies the type of `key`.\n     */\n    PdfPopupIcon[PdfPopupIcon[\"key\"] = 4] = \"key\";\n    /**\n     * Specifies the type of `new paragraph`.\n     */\n    PdfPopupIcon[PdfPopupIcon[\"newParagraph\"] = 5] = \"newParagraph\";\n    /**\n     * Specifies the type of `paragraph`.\n     */\n    PdfPopupIcon[PdfPopupIcon[\"paragraph\"] = 6] = \"paragraph\";\n})(PdfPopupIcon || (PdfPopupIcon = {}));\n/**\n * Public Enum to define annotation state.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;\n * // Sets the state of the popup annotation as accepted\n * annotation.state = PdfAnnotationState.accepted;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationState;\n(function (PdfAnnotationState) {\n    /**\n     * Specifies the default state of `none`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the state of `accepted`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"accepted\"] = 1] = \"accepted\";\n    /**\n     * Specifies the state of `rejected`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"rejected\"] = 2] = \"rejected\";\n    /**\n     * Specifies the state of `cancel`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"cancel\"] = 3] = \"cancel\";\n    /**\n     * Specifies the state of `completed`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"completed\"] = 4] = \"completed\";\n    /**\n     * Specifies the state of `marked`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"marked\"] = 5] = \"marked\";\n    /**\n     * Specifies the state of `unmarked`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"unmarked\"] = 6] = \"unmarked\";\n    /**\n     * Specifies the state of `unknown`.\n     */\n    PdfAnnotationState[PdfAnnotationState[\"unknown\"] = 7] = \"unknown\";\n})(PdfAnnotationState || (PdfAnnotationState = {}));\n/**\n * Public Enum to define annotation state model.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfPopupAnnotation = page.annotations.at(0) PdfPopupAnnotation;\n * // Sets the state model of the popup annotation as marked\n * annotation.stateModel = PdfAnnotationStateModel.marked;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationStateModel;\n(function (PdfAnnotationStateModel) {\n    /**\n     * Specifies the default model of `none`.\n     */\n    PdfAnnotationStateModel[PdfAnnotationStateModel[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the model of `marked`.\n     */\n    PdfAnnotationStateModel[PdfAnnotationStateModel[\"marked\"] = 1] = \"marked\";\n    /**\n     * Specifies the model of `review`.\n     */\n    PdfAnnotationStateModel[PdfAnnotationStateModel[\"review\"] = 2] = \"review\";\n})(PdfAnnotationStateModel || (PdfAnnotationStateModel = {}));\n/**\n * Public Enum to define icon type of attachment annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) PdfAttachmentAnnotation;\n * // Sets the icon type of attachment annotation to pushPin\n * annotation.icon = PdfAttachmentIcon.pushPin;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAttachmentIcon;\n(function (PdfAttachmentIcon) {\n    /**\n     * Specifies the default icon of `pushPin`.\n     */\n    PdfAttachmentIcon[PdfAttachmentIcon[\"pushPin\"] = 0] = \"pushPin\";\n    /**\n     * Specifies the icon of `tag`.\n     */\n    PdfAttachmentIcon[PdfAttachmentIcon[\"tag\"] = 1] = \"tag\";\n    /**\n     * Specifies the icon of `graph`.\n     */\n    PdfAttachmentIcon[PdfAttachmentIcon[\"graph\"] = 2] = \"graph\";\n    /**\n     * Specifies the icon of `paperClip`.\n     */\n    PdfAttachmentIcon[PdfAttachmentIcon[\"paperClip\"] = 3] = \"paperClip\";\n})(PdfAttachmentIcon || (PdfAttachmentIcon = {}));\n/**\n * Public Enum to define annotation intent of free text annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) PdfFreeTextAnnotation;\n * // Sets the free text annotation intent to freeTextCallout\n * annotation.annotationIntent = PdfAnnotationIntent.freeTextCallout;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationIntent;\n(function (PdfAnnotationIntent) {\n    /**\n     * Specifies the default intent of `none`.\n     */\n    PdfAnnotationIntent[PdfAnnotationIntent[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the intent of `freeTextCallout`.\n     */\n    PdfAnnotationIntent[PdfAnnotationIntent[\"freeTextCallout\"] = 1] = \"freeTextCallout\";\n    /**\n     * Specifies the intent of `freeTextTypeWriter`.\n     */\n    PdfAnnotationIntent[PdfAnnotationIntent[\"freeTextTypeWriter\"] = 2] = \"freeTextTypeWriter\";\n})(PdfAnnotationIntent || (PdfAnnotationIntent = {}));\n/**\n * Public Enum to define destination mode of document link annotation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) PdfDocumentLinkAnnotation;\n * // Sets the destination mode as fitToPage\n * annotation.destination.mode = PdfDestinationMode.fitToPage;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfDestinationMode;\n(function (PdfDestinationMode) {\n    /**\n     * Specifies the default intent of `location`.\n     */\n    PdfDestinationMode[PdfDestinationMode[\"location\"] = 0] = \"location\";\n    /**\n     * Specifies the intent of `FitToPage`.\n     */\n    PdfDestinationMode[PdfDestinationMode[\"fitToPage\"] = 1] = \"fitToPage\";\n    /**\n     * Specifies the intent of `fitR`.\n     */\n    PdfDestinationMode[PdfDestinationMode[\"fitR\"] = 2] = \"fitR\";\n    /**\n     * Specifies the intent of `fitH`.\n     */\n    PdfDestinationMode[PdfDestinationMode[\"fitH\"] = 3] = \"fitH\";\n})(PdfDestinationMode || (PdfDestinationMode = {}));\n/**\n * Public Enum to define export or import data format.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Sets export data format as JSON type to annotation export settings\n * let settings: PdfAnnotationExportSettings = new PdfAnnotationExportSettings();\n * settings.dataFormat = DataFormat.json;\n * // Export annotations to JSON format\n * let json: Uint8Array = document.exportAnnotations(settings);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar DataFormat;\n(function (DataFormat) {\n    /**\n     * Specifies the intent of `FDF`.\n     */\n    DataFormat[DataFormat[\"fdf\"] = 0] = \"fdf\";\n    /**\n     * Specifies the intent of `XFDF`.\n     */\n    DataFormat[DataFormat[\"xfdf\"] = 1] = \"xfdf\";\n    /**\n     * Specifies the intent of `JSON`.\n     */\n    DataFormat[DataFormat[\"json\"] = 2] = \"json\";\n    /**\n     * Specifies the intent of `XML`.\n     */\n    DataFormat[DataFormat[\"xml\"] = 3] = \"xml\";\n})(DataFormat || (DataFormat = {}));\n/**\n * Public enum to define form fields tab order.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Set a PDF form's tab order.\n * document.form.orderFormFields(PdfFormFieldsTabOrder.row);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfFormFieldsTabOrder;\n(function (PdfFormFieldsTabOrder) {\n    /**\n     * Specifies that no tab order is defined.\n     */\n    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the tab order is defined by the document's rows.\n     */\n    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder[\"row\"] = 1] = \"row\";\n    /**\n     * Specifies the tab order is defined by the document's columns.\n     */\n    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder[\"column\"] = 2] = \"column\";\n    /**\n     * Specifies the tab order is defined by the document's structure tree.\n     */\n    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder[\"structure\"] = 3] = \"structure\";\n    /**\n     * Specifies the tab order is defined manually.\n     */\n    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder[\"manual\"] = 4] = \"manual\";\n    /**\n     * Specifies the tab order is defined by the widget annotations in the document.\n     */\n    PdfFormFieldsTabOrder[PdfFormFieldsTabOrder[\"widget\"] = 5] = \"widget\";\n})(PdfFormFieldsTabOrder || (PdfFormFieldsTabOrder = {}));\n/**\n * Enum for PDF loaded annotation type.\n */\nvar _PdfAnnotationType;\n(function (_PdfAnnotationType) {\n    /**\n     * Specifies the intent of `highlight`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"highlight\"] = 0] = \"highlight\";\n    /**\n     * Specifies the intent of `underline`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"underline\"] = 1] = \"underline\";\n    /**\n     * Specifies the intent of `strikeOut`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"strikeOut\"] = 2] = \"strikeOut\";\n    /**\n     * Specifies the intent of `squiggly`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"squiggly\"] = 3] = \"squiggly\";\n    /**\n     * Specifies the intent of `redactionAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"redactionAnnotation\"] = 4] = \"redactionAnnotation\";\n    /**\n     * Specifies the intent of `textAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"textAnnotation\"] = 5] = \"textAnnotation\";\n    /**\n     * Specifies the intent of `linkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"linkAnnotation\"] = 6] = \"linkAnnotation\";\n    /**\n     * Specifies the intent of `documentLinkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"documentLinkAnnotation\"] = 7] = \"documentLinkAnnotation\";\n    /**\n     * Specifies the intent of `uriAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"uriAnnotation\"] = 8] = \"uriAnnotation\";\n    /**\n     * Specifies the intent of `fileLinkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"fileLinkAnnotation\"] = 9] = \"fileLinkAnnotation\";\n    /**\n     * Specifies the intent of `freeTextAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"freeTextAnnotation\"] = 10] = \"freeTextAnnotation\";\n    /**\n     * Specifies the intent of `lineAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"lineAnnotation\"] = 11] = \"lineAnnotation\";\n    /**\n     * Specifies the intent of `circleAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"circleAnnotation\"] = 12] = \"circleAnnotation\";\n    /**\n     * Specifies the intent of `ellipseAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"ellipseAnnotation\"] = 13] = \"ellipseAnnotation\";\n    /**\n     * Specifies the intent of `squareAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"squareAnnotation\"] = 14] = \"squareAnnotation\";\n    /**\n     * Specifies the intent of `rectangleAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"rectangleAnnotation\"] = 15] = \"rectangleAnnotation\";\n    /**\n     * Specifies the intent of `polygonAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"polygonAnnotation\"] = 16] = \"polygonAnnotation\";\n    /**\n     * Specifies the intent of `polyLineAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"polyLineAnnotation\"] = 17] = \"polyLineAnnotation\";\n    /**\n     * Specifies the intent of `textMarkupAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"textMarkupAnnotation\"] = 18] = \"textMarkupAnnotation\";\n    /**\n     * Specifies the intent of `caretAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"caretAnnotation\"] = 19] = \"caretAnnotation\";\n    /**\n     * Specifies the intent of `rubberStampAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"rubberStampAnnotation\"] = 20] = \"rubberStampAnnotation\";\n    /**\n     * Specifies the intent of `popupAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"popupAnnotation\"] = 21] = \"popupAnnotation\";\n    /**\n     * Specifies the intent of `fileAttachmentAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"fileAttachmentAnnotation\"] = 22] = \"fileAttachmentAnnotation\";\n    /**\n     * Specifies the intent of `soundAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"soundAnnotation\"] = 23] = \"soundAnnotation\";\n    /**\n     * Specifies the intent of `movieAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"movieAnnotation\"] = 24] = \"movieAnnotation\";\n    /**\n     * Specifies the intent of `screenAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"screenAnnotation\"] = 25] = \"screenAnnotation\";\n    /**\n     * Specifies the intent of `widgetAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"widgetAnnotation\"] = 26] = \"widgetAnnotation\";\n    /**\n     * Specifies the intent of `printerMarkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"printerMarkAnnotation\"] = 27] = \"printerMarkAnnotation\";\n    /**\n     * Specifies the intent of `trapNetworkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"trapNetworkAnnotation\"] = 28] = \"trapNetworkAnnotation\";\n    /**\n     * Specifies the intent of `watermarkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"watermarkAnnotation\"] = 29] = \"watermarkAnnotation\";\n    /**\n     * Specifies the intent of `textWebLinkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"textWebLinkAnnotation\"] = 30] = \"textWebLinkAnnotation\";\n    /**\n     * Specifies the intent of `inkAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"inkAnnotation\"] = 31] = \"inkAnnotation\";\n    /**\n     * Specifies the intent of `richMediaAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"richMediaAnnotation\"] = 32] = \"richMediaAnnotation\";\n    /**\n     * Specifies the intent of `angleMeasurementAnnotation`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"angleMeasurementAnnotation\"] = 33] = \"angleMeasurementAnnotation\";\n    /**\n     * Specifies the intent of `null`.\n     */\n    _PdfAnnotationType[_PdfAnnotationType[\"null\"] = 34] = \"null\";\n})(_PdfAnnotationType || (_PdfAnnotationType = {}));\n/**\n * Enum for PDF graphics unit.\n */\nvar _PdfGraphicsUnit;\n(function (_PdfGraphicsUnit) {\n    /**\n     * Specifies the type of `centimeter`.\n     */\n    _PdfGraphicsUnit[_PdfGraphicsUnit[\"centimeter\"] = 0] = \"centimeter\";\n    /**\n     * Specifies the type of `pica`.\n     */\n    _PdfGraphicsUnit[_PdfGraphicsUnit[\"pica\"] = 1] = \"pica\";\n    /**\n     * Specifies the type of `pixel`.\n     */\n    _PdfGraphicsUnit[_PdfGraphicsUnit[\"pixel\"] = 2] = \"pixel\";\n    /**\n     * Specifies the type of `point`.\n     */\n    _PdfGraphicsUnit[_PdfGraphicsUnit[\"point\"] = 3] = \"point\";\n    /**\n     * Specifies the type of `inch`.\n     */\n    _PdfGraphicsUnit[_PdfGraphicsUnit[\"inch\"] = 4] = \"inch\";\n    /**\n     * Specifies the type of `document`.\n     */\n    _PdfGraphicsUnit[_PdfGraphicsUnit[\"document\"] = 5] = \"document\";\n    /**\n     * Specifies the type of `millimeter`.\n     */\n    _PdfGraphicsUnit[_PdfGraphicsUnit[\"millimeter\"] = 6] = \"millimeter\";\n})(_PdfGraphicsUnit || (_PdfGraphicsUnit = {}));\nvar _FieldFlag;\n(function (_FieldFlag) {\n    _FieldFlag[_FieldFlag[\"default\"] = 0] = \"default\";\n    _FieldFlag[_FieldFlag[\"readOnly\"] = 1] = \"readOnly\";\n    _FieldFlag[_FieldFlag[\"required\"] = 2] = \"required\";\n    _FieldFlag[_FieldFlag[\"noExport\"] = 4] = \"noExport\";\n    _FieldFlag[_FieldFlag[\"multiLine\"] = 4096] = \"multiLine\";\n    _FieldFlag[_FieldFlag[\"password\"] = 8192] = \"password\";\n    _FieldFlag[_FieldFlag[\"fileSelect\"] = 1048576] = \"fileSelect\";\n    _FieldFlag[_FieldFlag[\"doNotSpellCheck\"] = 4194304] = \"doNotSpellCheck\";\n    _FieldFlag[_FieldFlag[\"doNotScroll\"] = 8388608] = \"doNotScroll\";\n    _FieldFlag[_FieldFlag[\"comb\"] = 16777216] = \"comb\";\n    _FieldFlag[_FieldFlag[\"richText\"] = 33554432] = \"richText\";\n    _FieldFlag[_FieldFlag[\"noToggleToOff\"] = 16384] = \"noToggleToOff\";\n    _FieldFlag[_FieldFlag[\"radio\"] = 32768] = \"radio\";\n    _FieldFlag[_FieldFlag[\"pushButton\"] = 65536] = \"pushButton\";\n    _FieldFlag[_FieldFlag[\"radiosInUnison\"] = 33554432] = \"radiosInUnison\";\n    _FieldFlag[_FieldFlag[\"combo\"] = 131072] = \"combo\";\n    _FieldFlag[_FieldFlag[\"edit\"] = 262144] = \"edit\";\n    _FieldFlag[_FieldFlag[\"sort\"] = 524288] = \"sort\";\n    _FieldFlag[_FieldFlag[\"multiSelect\"] = 2097152] = \"multiSelect\";\n    _FieldFlag[_FieldFlag[\"commitOnSelectChange\"] = 67108864] = \"commitOnSelectChange\";\n})(_FieldFlag || (_FieldFlag = {}));\nvar _SignatureFlag;\n(function (_SignatureFlag) {\n    _SignatureFlag[_SignatureFlag[\"none\"] = 0] = \"none\";\n    _SignatureFlag[_SignatureFlag[\"signatureExists\"] = 1] = \"signatureExists\";\n    _SignatureFlag[_SignatureFlag[\"appendOnly\"] = 2] = \"appendOnly\";\n})(_SignatureFlag || (_SignatureFlag = {}));\nvar _PdfCheckFieldState;\n(function (_PdfCheckFieldState) {\n    _PdfCheckFieldState[_PdfCheckFieldState[\"unchecked\"] = 0] = \"unchecked\";\n    _PdfCheckFieldState[_PdfCheckFieldState[\"checked\"] = 1] = \"checked\";\n    _PdfCheckFieldState[_PdfCheckFieldState[\"pressedUnchecked\"] = 2] = \"pressedUnchecked\";\n    _PdfCheckFieldState[_PdfCheckFieldState[\"pressedChecked\"] = 3] = \"pressedChecked\";\n})(_PdfCheckFieldState || (_PdfCheckFieldState = {}));\n/**\n * Public enum to define the PDF document permission flags.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the permission flag\n * let permission: PdfPermissionFlag = document.permissions;\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPermissionFlag;\n(function (PdfPermissionFlag) {\n    /**\n     * Specifies the default permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"default\"] = 0] = \"default\";\n    /**\n     * Specifies the print permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"print\"] = 4] = \"print\";\n    /**\n     * Specifies the edit content permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"editContent\"] = 8] = \"editContent\";\n    /**\n     * Specifies the copy content permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"copyContent\"] = 16] = \"copyContent\";\n    /**\n     * Specifies the edit annotations permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"editAnnotations\"] = 32] = \"editAnnotations\";\n    /**\n     * Specifies the fill fields permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"fillFields\"] = 256] = \"fillFields\";\n    /**\n     * Specifies the accessibility copy content permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"accessibilityCopyContent\"] = 512] = \"accessibilityCopyContent\";\n    /**\n     * Specifies the assemble document permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"assembleDocument\"] = 1024] = \"assembleDocument\";\n    /**\n     * Specifies the full quality print permission flag.\n     */\n    PdfPermissionFlag[PdfPermissionFlag[\"fullQualityPrint\"] = 2048] = \"fullQualityPrint\";\n})(PdfPermissionFlag || (PdfPermissionFlag = {}));\n/**\n * Public enum to define the PDF page orientation.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Get the page orientation\n * let orientation: PdfPageOrientation = page.orientation;\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPageOrientation;\n(function (PdfPageOrientation) {\n    /**\n     * Specifies the type of `portrait`.\n     */\n    PdfPageOrientation[PdfPageOrientation[\"portrait\"] = 0] = \"portrait\";\n    /**\n     * Specifies the type of `landscape`.\n     */\n    PdfPageOrientation[PdfPageOrientation[\"landscape\"] = 1] = \"landscape\";\n})(PdfPageOrientation || (PdfPageOrientation = {}));\n/**\n * Public enum to define the text direction.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Load the font file\n * let font: PdfTrueTypeFont = new PdfTrueTypeFont(read('./resources/Fonts/', 'Arial.ttf'), 10);\n * // Add a string format\n * let format: PdfStringFormat = new PdfStringFormat();\n * format.alignment = PdfTextAlignment.right;\n * format.textDirection = PdfTextDirection.rightToLeft;\n * // Draw a text with right to left direction\n * page.graphics.drawString('Hello World مرحبا بالعالم', font, [10, 20, 300, 200], undefined, new PdfBrush([0, 0, 255]), format);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfTextDirection;\n(function (PdfTextDirection) {\n    /**\n     * Specifies the type of `none`.\n     */\n    PdfTextDirection[PdfTextDirection[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the type of `leftToRight`.\n     */\n    PdfTextDirection[PdfTextDirection[\"leftToRight\"] = 1] = \"leftToRight\";\n    /**\n     * Specifies the type of `rightToLeft`.\n     */\n    PdfTextDirection[PdfTextDirection[\"rightToLeft\"] = 2] = \"rightToLeft\";\n})(PdfTextDirection || (PdfTextDirection = {}));\n/**\n * Public enum to define the subscript or superscript mode.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Gets the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new PDF standard font\n * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 10);\n * // Create a new PDF string format\n * let format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.right);\n * // Set a new paragraph indent\n * format.paragraphIndent = 20;\n * // Set the subscript or superscript mode\n * format.subSuperScript = PdfSubSuperScript.subScript;\n * // Draw the text\n * page.graphics.drawString('Helvetica', font, [0, 180, page.size[0], 40], undefined, new PdfBrush([0, 0, 255]), format);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfSubSuperScript;\n(function (PdfSubSuperScript) {\n    /**\n     * Specifies the type of `none`.\n     */\n    PdfSubSuperScript[PdfSubSuperScript[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the type of `superScript`.\n     */\n    PdfSubSuperScript[PdfSubSuperScript[\"superScript\"] = 1] = \"superScript\";\n    /**\n     * Specifies the type of `subScript`.\n     */\n    PdfSubSuperScript[PdfSubSuperScript[\"subScript\"] = 2] = \"subScript\";\n})(PdfSubSuperScript || (PdfSubSuperScript = {}));\n/**\n * Public enum to define blend mode of the PDF page.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new font\n * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.symbol, 10);\n * // Set the blend mode\n * graphics.setTransparency(0.5, 0.5, PdfBlendMode.hardLight);\n * // Draw the text\n * graphics.drawString('Hello World', font, null, new PointF(10, 10));\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfBlendMode;\n(function (PdfBlendMode) {\n    /**\n     * Specifies the type of `normal`.\n     */\n    PdfBlendMode[PdfBlendMode[\"normal\"] = 0] = \"normal\";\n    /**\n     * Specifies the type of `multiply`.\n     */\n    PdfBlendMode[PdfBlendMode[\"multiply\"] = 1] = \"multiply\";\n    /**\n     * Specifies the type of `screen`.\n     */\n    PdfBlendMode[PdfBlendMode[\"screen\"] = 2] = \"screen\";\n    /**\n     * Specifies the type of `overlay`.\n     */\n    PdfBlendMode[PdfBlendMode[\"overlay\"] = 3] = \"overlay\";\n    /**\n     * Specifies the type of `darken`.\n     */\n    PdfBlendMode[PdfBlendMode[\"darken\"] = 4] = \"darken\";\n    /**\n     * Specifies the type of `lighten`.\n     */\n    PdfBlendMode[PdfBlendMode[\"lighten\"] = 5] = \"lighten\";\n    /**\n     * Specifies the type of `colorDodge`.\n     */\n    PdfBlendMode[PdfBlendMode[\"colorDodge\"] = 6] = \"colorDodge\";\n    /**\n     * Specifies the type of `colorBurn`.\n     */\n    PdfBlendMode[PdfBlendMode[\"colorBurn\"] = 7] = \"colorBurn\";\n    /**\n     * Specifies the type of `hardLight`.\n     */\n    PdfBlendMode[PdfBlendMode[\"hardLight\"] = 8] = \"hardLight\";\n    /**\n     * Specifies the type of `softLight`.\n     */\n    PdfBlendMode[PdfBlendMode[\"softLight\"] = 9] = \"softLight\";\n    /**\n     * Specifies the type of `difference`.\n     */\n    PdfBlendMode[PdfBlendMode[\"difference\"] = 10] = \"difference\";\n    /**\n     * Specifies the type of `exclusion`.\n     */\n    PdfBlendMode[PdfBlendMode[\"exclusion\"] = 11] = \"exclusion\";\n    /**\n     * Specifies the type of `hue`.\n     */\n    PdfBlendMode[PdfBlendMode[\"hue\"] = 12] = \"hue\";\n    /**\n     * Specifies the type of `saturation`.\n     */\n    PdfBlendMode[PdfBlendMode[\"saturation\"] = 13] = \"saturation\";\n    /**\n     * Specifies the type of `color`.\n     */\n    PdfBlendMode[PdfBlendMode[\"color\"] = 14] = \"color\";\n    /**\n     * Specifies the type of `luminosity`.\n     */\n    PdfBlendMode[PdfBlendMode[\"luminosity\"] = 15] = \"luminosity\";\n})(PdfBlendMode || (PdfBlendMode = {}));\n/**\n * Public enum to define fill mode of the PDF page.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new font\n * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.symbol, 10);\n * // Set the fill mode\n * graphics.setClip([0, 0, 100, 100], PdfFillMode.winding);\n * // Draw the text\n * graphics.drawString('Hello World', font, null, new PointF(10, 10));\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfFillMode;\n(function (PdfFillMode) {\n    /**\n     * Specifies the type of `winding`.\n     */\n    PdfFillMode[PdfFillMode[\"winding\"] = 0] = \"winding\";\n    /**\n     * Specifies the type of `alternate`.\n     */\n    PdfFillMode[PdfFillMode[\"alternate\"] = 1] = \"alternate\";\n})(PdfFillMode || (PdfFillMode = {}));\n/**\n * Public enum to define the dash style.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new pen\n * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n * // Set the dash style\n * pen._dashStyle = PdfDashStyle.dashDot;\n * // Draw a rectangle using pen\n * graphics.drawRectangle(150, 50, 50, 50, pen);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfDashStyle;\n(function (PdfDashStyle) {\n    /**\n     * Specifies the type of `solid`.\n     */\n    PdfDashStyle[PdfDashStyle[\"solid\"] = 0] = \"solid\";\n    /**\n     * Specifies the type of `dash`.\n     */\n    PdfDashStyle[PdfDashStyle[\"dash\"] = 1] = \"dash\";\n    /**\n     * Specifies the type of `dot`.\n     */\n    PdfDashStyle[PdfDashStyle[\"dot\"] = 2] = \"dot\";\n    /**\n     * Specifies the type of `dashDot`.\n     */\n    PdfDashStyle[PdfDashStyle[\"dashDot\"] = 3] = \"dashDot\";\n    /**\n     * Specifies the type of `dashDotDot`.\n     */\n    PdfDashStyle[PdfDashStyle[\"dashDotDot\"] = 4] = \"dashDotDot\";\n    /**\n     * Specifies the type of `custom`.\n     */\n    PdfDashStyle[PdfDashStyle[\"custom\"] = 5] = \"custom\";\n})(PdfDashStyle || (PdfDashStyle = {}));\n/**\n * Public enum to define the line cap.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new pen\n * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n * // Set the dash style\n * pen._dashStyle = PdfDashStyle.dashDot;\n * // Set the line cap\n * pen._lineCap = PdfLineCap.round;\n * // Draw a rectangle using pen\n * graphics.drawRectangle(150, 50, 50, 50, pen);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfLineCap;\n(function (PdfLineCap) {\n    /**\n     * Specifies the type of `flat`.\n     */\n    PdfLineCap[PdfLineCap[\"flat\"] = 0] = \"flat\";\n    /**\n     * Specifies the type of `round`.\n     */\n    PdfLineCap[PdfLineCap[\"round\"] = 1] = \"round\";\n    /**\n     * Specifies the type of `square`.\n     */\n    PdfLineCap[PdfLineCap[\"square\"] = 2] = \"square\";\n})(PdfLineCap || (PdfLineCap = {}));\n/**\n * Public enum to define the line join.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new pen\n * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n * // Set the dash style\n * pen._dashStyle = PdfDashStyle.dashDot;\n * // Set the line join\n * pen._lineJoin = PdfLineJoin.bevel;\n * // Draw a rectangle using pen\n * graphics.drawRectangle(150, 50, 50, 50, pen);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfLineJoin;\n(function (PdfLineJoin) {\n    /**\n     * Specifies the type of `miter`.\n     */\n    PdfLineJoin[PdfLineJoin[\"miter\"] = 0] = \"miter\";\n    /**\n     * Specifies the type of `round`.\n     */\n    PdfLineJoin[PdfLineJoin[\"round\"] = 1] = \"round\";\n    /**\n     * Specifies the type of `bevel`.\n     */\n    PdfLineJoin[PdfLineJoin[\"bevel\"] = 2] = \"bevel\";\n})(PdfLineJoin || (PdfLineJoin = {}));\nvar _PdfWordWrapType;\n(function (_PdfWordWrapType) {\n    /**\n     * Specifies the type of `none`.\n     */\n    _PdfWordWrapType[_PdfWordWrapType[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the type of `word`.\n     */\n    _PdfWordWrapType[_PdfWordWrapType[\"word\"] = 1] = \"word\";\n    /**\n     * Specifies the type of `wordOnly`.\n     */\n    _PdfWordWrapType[_PdfWordWrapType[\"wordOnly\"] = 2] = \"wordOnly\";\n    /**\n     * Specifies the type of `character`.\n     */\n    _PdfWordWrapType[_PdfWordWrapType[\"character\"] = 3] = \"character\";\n})(_PdfWordWrapType || (_PdfWordWrapType = {}));\nvar _FontDescriptorFlag;\n(function (_FontDescriptorFlag) {\n    _FontDescriptorFlag[_FontDescriptorFlag[\"fixedPitch\"] = 1] = \"fixedPitch\";\n    _FontDescriptorFlag[_FontDescriptorFlag[\"serif\"] = 2] = \"serif\";\n    _FontDescriptorFlag[_FontDescriptorFlag[\"symbolic\"] = 4] = \"symbolic\";\n    _FontDescriptorFlag[_FontDescriptorFlag[\"script\"] = 8] = \"script\";\n    _FontDescriptorFlag[_FontDescriptorFlag[\"nonSymbolic\"] = 32] = \"nonSymbolic\";\n    _FontDescriptorFlag[_FontDescriptorFlag[\"italic\"] = 64] = \"italic\";\n    _FontDescriptorFlag[_FontDescriptorFlag[\"forceBold\"] = 262144] = \"forceBold\";\n})(_FontDescriptorFlag || (_FontDescriptorFlag = {}));\nvar _TrueTypeCmapFormat;\n(function (_TrueTypeCmapFormat) {\n    _TrueTypeCmapFormat[_TrueTypeCmapFormat[\"apple\"] = 0] = \"apple\";\n    _TrueTypeCmapFormat[_TrueTypeCmapFormat[\"microsoft\"] = 4] = \"microsoft\";\n    _TrueTypeCmapFormat[_TrueTypeCmapFormat[\"trimmed\"] = 6] = \"trimmed\";\n})(_TrueTypeCmapFormat || (_TrueTypeCmapFormat = {}));\nvar _TrueTypeCmapEncoding;\n(function (_TrueTypeCmapEncoding) {\n    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding[\"unknown\"] = 0] = \"unknown\";\n    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding[\"symbol\"] = 1] = \"symbol\";\n    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding[\"unicode\"] = 2] = \"unicode\";\n    _TrueTypeCmapEncoding[_TrueTypeCmapEncoding[\"macintosh\"] = 3] = \"macintosh\";\n})(_TrueTypeCmapEncoding || (_TrueTypeCmapEncoding = {}));\nvar _TrueTypePlatformID;\n(function (_TrueTypePlatformID) {\n    _TrueTypePlatformID[_TrueTypePlatformID[\"appleUnicode\"] = 0] = \"appleUnicode\";\n    _TrueTypePlatformID[_TrueTypePlatformID[\"macintosh\"] = 1] = \"macintosh\";\n    _TrueTypePlatformID[_TrueTypePlatformID[\"iSO\"] = 2] = \"iSO\";\n    _TrueTypePlatformID[_TrueTypePlatformID[\"microsoft\"] = 3] = \"microsoft\";\n})(_TrueTypePlatformID || (_TrueTypePlatformID = {}));\nvar _TrueTypeMicrosoftEncodingID;\n(function (_TrueTypeMicrosoftEncodingID) {\n    _TrueTypeMicrosoftEncodingID[_TrueTypeMicrosoftEncodingID[\"undefined\"] = 0] = \"undefined\";\n    _TrueTypeMicrosoftEncodingID[_TrueTypeMicrosoftEncodingID[\"unicode\"] = 1] = \"unicode\";\n})(_TrueTypeMicrosoftEncodingID || (_TrueTypeMicrosoftEncodingID = {}));\nvar _TrueTypeMacintoshEncodingID;\n(function (_TrueTypeMacintoshEncodingID) {\n    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID[\"roman\"] = 0] = \"roman\";\n    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID[\"japanese\"] = 1] = \"japanese\";\n    _TrueTypeMacintoshEncodingID[_TrueTypeMacintoshEncodingID[\"chinese\"] = 2] = \"chinese\";\n})(_TrueTypeMacintoshEncodingID || (_TrueTypeMacintoshEncodingID = {}));\nvar _TrueTypeCompositeGlyphFlag;\n(function (_TrueTypeCompositeGlyphFlag) {\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"Arg1And2AreWords\"] = 1] = \"Arg1And2AreWords\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"ArgsAreXyValues\"] = 2] = \"ArgsAreXyValues\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"RoundXyToGrid\"] = 4] = \"RoundXyToGrid\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"WeHaveScale\"] = 8] = \"WeHaveScale\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"Reserved\"] = 16] = \"Reserved\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"MoreComponents\"] = 32] = \"MoreComponents\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"WeHaveAnXyScale\"] = 64] = \"WeHaveAnXyScale\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"WeHaveTwoByTwo\"] = 128] = \"WeHaveTwoByTwo\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"WeHaveInstructions\"] = 256] = \"WeHaveInstructions\";\n    _TrueTypeCompositeGlyphFlag[_TrueTypeCompositeGlyphFlag[\"UseMyMetrics\"] = 512] = \"UseMyMetrics\";\n})(_TrueTypeCompositeGlyphFlag || (_TrueTypeCompositeGlyphFlag = {}));\nvar _ImageFormat;\n(function (_ImageFormat) {\n    /**\n     * Specifies the type of `unknown`.\n     */\n    _ImageFormat[_ImageFormat[\"unknown\"] = 0] = \"unknown\";\n    /**\n     * Specifies the type of `bmp`.\n     */\n    _ImageFormat[_ImageFormat[\"bmp\"] = 1] = \"bmp\";\n    /**\n     * Specifies the type of `emf`.\n     */\n    _ImageFormat[_ImageFormat[\"emf\"] = 2] = \"emf\";\n    /**\n     * Specifies the type of `gif`.\n     */\n    _ImageFormat[_ImageFormat[\"gif\"] = 3] = \"gif\";\n    /**\n     * Specifies the type of `jpeg`.\n     */\n    _ImageFormat[_ImageFormat[\"jpeg\"] = 4] = \"jpeg\";\n    /**\n     * Specifies the type of `png`.\n     */\n    _ImageFormat[_ImageFormat[\"png\"] = 5] = \"png\";\n    /**\n     * Specifies the type of `wmf`.\n     */\n    _ImageFormat[_ImageFormat[\"wmf\"] = 6] = \"wmf\";\n    /**\n     * Specifies the type of `icon`.\n     */\n    _ImageFormat[_ImageFormat[\"icon\"] = 7] = \"icon\";\n})(_ImageFormat || (_ImageFormat = {}));\nvar _TokenType;\n(function (_TokenType) {\n    _TokenType[_TokenType[\"none\"] = 0] = \"none\";\n    _TokenType[_TokenType[\"comment\"] = 1] = \"comment\";\n    _TokenType[_TokenType[\"number\"] = 2] = \"number\";\n    _TokenType[_TokenType[\"real\"] = 3] = \"real\";\n    _TokenType[_TokenType[\"string\"] = 4] = \"string\";\n    _TokenType[_TokenType[\"hexString\"] = 5] = \"hexString\";\n    _TokenType[_TokenType[\"unicodeString\"] = 6] = \"unicodeString\";\n    _TokenType[_TokenType[\"unicodeHexString\"] = 7] = \"unicodeHexString\";\n    _TokenType[_TokenType[\"name\"] = 8] = \"name\";\n    _TokenType[_TokenType[\"operator\"] = 9] = \"operator\";\n    _TokenType[_TokenType[\"beginArray\"] = 10] = \"beginArray\";\n    _TokenType[_TokenType[\"endArray\"] = 11] = \"endArray\";\n    _TokenType[_TokenType[\"eof\"] = 12] = \"eof\";\n})(_TokenType || (_TokenType = {}));\n/**\n * Public enum to define text style.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Get the bookmarks\n * let bookmarks: PdfBookmarkBase = document.bookmarks;\n * // Gets bookmark at the specified index\n * let bookmark : PdfBookMark = bookmarks.at(0) as PdfBookMark;\n * // Gets the textStyle\n * let textStyle: PdfTextStyle = bookmark.textStyle;\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfTextStyle;\n(function (PdfTextStyle) {\n    /**\n     * Specifies the `regular` text style.\n     */\n    PdfTextStyle[PdfTextStyle[\"regular\"] = 0] = \"regular\";\n    /**\n     * Specifies the `italic` text style.\n     */\n    PdfTextStyle[PdfTextStyle[\"italic\"] = 1] = \"italic\";\n    /**\n     * Specifies the `bold` text style.\n     */\n    PdfTextStyle[PdfTextStyle[\"bold\"] = 2] = \"bold\";\n})(PdfTextStyle || (PdfTextStyle = {}));\nvar _PdfColorSpace;\n(function (_PdfColorSpace) {\n    _PdfColorSpace[_PdfColorSpace[\"rgb\"] = 0] = \"rgb\";\n    _PdfColorSpace[_PdfColorSpace[\"cmyk\"] = 1] = \"cmyk\";\n    _PdfColorSpace[_PdfColorSpace[\"grayScale\"] = 2] = \"grayScale\";\n    _PdfColorSpace[_PdfColorSpace[\"indexed\"] = 3] = \"indexed\";\n})(_PdfColorSpace || (_PdfColorSpace = {}));\n/**\n * Public enum type to represent the ordered list style\n * ````typescript\n * // Load an existing document\n * let document: PdfDocument = new PdfDocument(data);\n * // Access the first page\n * let page: PdfPage = document.getPage(0);\n * // Add each item to the item collection by passing the string array\n * let items: PdfListitemCollection = new PdfListitemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);\n * // Create a new ordered list and passing the list item collection\n * let list: PdfOrderedList = new PdfOrderedList(items);\n * // Set the ordered list number style for the list items\n * list.style = PdfNumberStyle.lowerLatin;\n * // Draw the ordered list\n * list.draw(page, 0, 20, 500, 700);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfNumberStyle;\n(function (PdfNumberStyle) {\n    /**\n     * No numbering at all.\n     */\n    PdfNumberStyle[PdfNumberStyle[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies the type '1'.\n     */\n    PdfNumberStyle[PdfNumberStyle[\"numeric\"] = 1] = \"numeric\";\n    /**\n     * Specifies the style 'a'.\n     */\n    PdfNumberStyle[PdfNumberStyle[\"lowerLatin\"] = 2] = \"lowerLatin\";\n    /**\n     * Specifies the style 'i'.\n     */\n    PdfNumberStyle[PdfNumberStyle[\"lowerRoman\"] = 3] = \"lowerRoman\";\n    /**\n     * Specifies the style 'A'.\n     */\n    PdfNumberStyle[PdfNumberStyle[\"upperLatin\"] = 4] = \"upperLatin\";\n    /**\n     * Specifies the style 'I'.\n     */\n    PdfNumberStyle[PdfNumberStyle[\"upperRoman\"] = 5] = \"upperRoman\";\n})(PdfNumberStyle || (PdfNumberStyle = {}));\n/**\n * Public enum to define the style used for unordered list.\n * ```typescript\n * // Load an existing document\n * let document: PdfDocument = new PdfDocument(data);\n * // Access the first page\n * let page: PdfPage = document.getPage(0);\n * // Add each item to the collection by passing the string array\n * let items: PdfListitemCollection = new PdfListitemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);\n * // Create a unordered list and pass the list item collection\n * let list: PdfUnorderedList = new PdfUnorderedList(items);\n * // Set the unordered list style for the list items\n * list.style = PdfUnorderedListStyle.circle;\n * // Draw the unordered list associated with items\n * list.draw(page, 0, 20, 500, 700);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfUnorderedListStyle;\n(function (PdfUnorderedListStyle) {\n    /**\n     * No bulleting at all.\n     */\n    PdfUnorderedListStyle[PdfUnorderedListStyle[\"none\"] = 0] = \"none\";\n    /**\n     * Specifies disk style.\n     */\n    PdfUnorderedListStyle[PdfUnorderedListStyle[\"disk\"] = 1] = \"disk\";\n    /**\n     * Specifies square style.\n     */\n    PdfUnorderedListStyle[PdfUnorderedListStyle[\"square\"] = 2] = \"square\";\n    /**\n     * Specifies asterisk style.\n     */\n    PdfUnorderedListStyle[PdfUnorderedListStyle[\"asterisk\"] = 3] = \"asterisk\";\n    /**\n     * Specifies circle style.\n     */\n    PdfUnorderedListStyle[PdfUnorderedListStyle[\"circle\"] = 4] = \"circle\";\n})(PdfUnorderedListStyle || (PdfUnorderedListStyle = {}));\n/**\n * Public enum to define a layout type for drawing\n * ```typescript\n * // Load an existing document\n * let document: PdfDocument = new PdfDocument(data);\n * // Access the first page\n * let page: PdfPage = document.getPage(0);\n * // Assign the array of string for items\n * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];\n * // Add the items to the list item collection by passing the array\n * let items: PdfListItemCollection = new PdfListItemCollection(products);\n * // Create a new ordered list\n * let list: PdfOrderedList = new PdfOrderedList(items);\n * // Create a layout format for drawing\n * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();\n * // Initialize layout type for drawing\n * pageLayout.layout = PdfLayoutType.paginate;\n * // Draw the list on the page along with the specified layout\n * list.draw(page, 0, 20, 500, 700, pageLayout);\n * // Get the layout type used to draw the list\n * let layoutType: PdfLayoutType = pageLayout.layout;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ````\n */\nvar PdfLayoutType;\n(function (PdfLayoutType) {\n    /**\n     * Specifies pagination across multiple pages based on the specified dimensions and layout options\n     */\n    PdfLayoutType[PdfLayoutType[\"paginate\"] = 0] = \"paginate\";\n    /**\n     * Specifies content to be laid out to fit within a single page, without pagination\n     */\n    PdfLayoutType[PdfLayoutType[\"onePage\"] = 1] = \"onePage\";\n})(PdfLayoutType || (PdfLayoutType = {}));\n/**\n * Public enum to define a layout Break type for drawing\n * ```typescript\n * // Load an existing document\n * let document: PdfDocument = new PdfDocument(data);\n * // Access the first page\n * let page: PdfPage = document.getPage(0);\n * // Assign the array of string for items\n * let products: string[] = ['Excel', 'Power', 'Point', 'Word', 'PDF'];\n * // Add the item to list item collection by passing the string array\n * let items: PdfListItemCollection = new PdfListItemCollection(products);\n * // Create a new ordered list\n * let list: PdfOrderedList = new PdfOrderedList(items);\n * // Create a layout for drawing\n * let pageLayout: PdfLayoutFormat = new PdfLayoutFormat();\n * // Set  the layout break type for drawing\n * pageLayout.break = PdfLayoutBreakType.fitPage;\n * // Draw the list associated with items along with layout\n * list.draw(page, 0, 20, 500, 700, pageLayout);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ````\n */\nvar PdfLayoutBreakType;\n(function (PdfLayoutBreakType) {\n    /**\n     * Specifies that content should break to a new page to fit within specified dimensions.\n     */\n    PdfLayoutBreakType[PdfLayoutBreakType[\"fitPage\"] = 0] = \"fitPage\";\n    /**\n     * Specifies that content should break to a new page or element to fit within specified dimensions.\n     */\n    PdfLayoutBreakType[PdfLayoutBreakType[\"fitElement\"] = 1] = \"fitElement\";\n})(PdfLayoutBreakType || (PdfLayoutBreakType = {}));\n/**\n * Public enum to define a list marker alignment\n * ````typescript\n * // Load an existing document\n * let document: PdfDocument = new PdfDocument(data);\n * // Access the first page\n * let page: PdfPage = document.getPage(0);\n * // Add each item to the item collection by passing the string array\n * let items: PdfListitemCollection = new PdfListitemCollection(['Excel', 'Power', 'Point', 'Word', 'PDF']);\n * // Create a new ordered list and passing the list item collection\n * let list: PdfOrderedList = new PdfOrderedList(items);\n * // Set the marker alignment\n * list.alignment = PdfListMarkerAlignment.left;\n * // Draw the ordered list\n * list.draw(page, 0, 20, 500, 700);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfListMarkerAlignment;\n(function (PdfListMarkerAlignment) {\n    /**\n     * Left alignment for marker.\n     */\n    PdfListMarkerAlignment[PdfListMarkerAlignment[\"left\"] = 0] = \"left\";\n    /**\n     * Right alignment for marker.\n     */\n    PdfListMarkerAlignment[PdfListMarkerAlignment[\"right\"] = 1] = \"right\";\n})(PdfListMarkerAlignment || (PdfListMarkerAlignment = {}));\n/**\n * Public enum to define a print state of layer\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Access the collection of layers in the document\n * let layers: PdfLayerCollection = document.layers;\n * // Retrieve the first layer from the layers collection\n * let layer: PdfLayer = layers.at(0);\n * // Retrieve the print state of the layer\n * let printState: PdfPrintState = layer.printState;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ````\n */\nvar PdfPrintState;\n(function (PdfPrintState) {\n    /**\n     * The PDF layers always get print\n     */\n    PdfPrintState[PdfPrintState[\"alwaysPrint\"] = 0] = \"alwaysPrint\";\n    /**\n     * The PDF layers never get print\n     */\n    PdfPrintState[PdfPrintState[\"neverPrint\"] = 1] = \"neverPrint\";\n    /**\n     * The visible PDF layers get print\n     */\n    PdfPrintState[PdfPrintState[\"printWhenVisible\"] = 2] = \"printWhenVisible\";\n})(PdfPrintState || (PdfPrintState = {}));\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/enumerator.js?");

/***/ })

}]);