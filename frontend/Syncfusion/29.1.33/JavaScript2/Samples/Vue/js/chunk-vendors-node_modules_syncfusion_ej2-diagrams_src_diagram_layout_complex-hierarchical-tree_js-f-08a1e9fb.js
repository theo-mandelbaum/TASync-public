"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_layout_complex-hierarchical-tree_js-f-08a1e9fb"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/complex-hierarchical-tree.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/complex-hierarchical-tree.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComplexHierarchicalTree: () => (/* binding */ ComplexHierarchicalTree)\n/* harmony export */ });\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n\n\n\n\n/**\n * Connects diagram objects with layout algorithm\n */\nvar ComplexHierarchicalTree = /** @class */ (function () {\n    /**\n     * Constructor for the hierarchical tree layout module\n     *\n     * @private\n     */\n    function ComplexHierarchicalTree() {\n        //constructs the layout module\n    }\n    /**\n     * To destroy the hierarchical tree module\n     *\n     * @returns {void}\n     * @private\n     */\n    ComplexHierarchicalTree.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    ComplexHierarchicalTree.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the layout\n         *\n         */\n        return 'ComplexHierarchicalTree';\n    };\n    /**\n     * doLayout method\\\n     *\n     * @returns {  void }    doLayout method .\\\n     * @param {INode[]} nodes - provide the nodes value.\n     * @param {{}} nameTable - provide the nameTable value.\n     * @param {Layout} layout - provide the layout value.\n     * @param {PointModel} viewPort - provide the viewPort value.\n     * @param {Diagram} diagram - provide the diagram model.\n     * @private\n     */\n    ComplexHierarchicalTree.prototype.doLayout = function (nodes, nameTable, layout, viewPort, diagram) {\n        new HierarchicalLayoutUtil().doLayout(nodes, nameTable, layout, viewPort, diagram);\n    };\n    ComplexHierarchicalTree.prototype.getLayoutNodesCollection = function (nodes) {\n        var nodesCollection = [];\n        var node;\n        var parentId = 'parentId';\n        var processId = 'processId';\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[parseInt(i.toString(), 10)];\n            //885697:Position of root node without the child node in complex hierarchical layout is not proper\n            // 941582: ExcludeFromLayout Option Not Supported in Complex Hierarchical Tree\n            if (!node.excludeFromLayout) {\n                if (((node.inEdges.length + node.outEdges.length > 0) || (node.offsetX === 0 && node.offsetY === 0)) &&\n                    !node['' + parentId] && !node['' + processId]) {\n                    nodesCollection.push(node);\n                }\n            }\n        }\n        return nodesCollection;\n    };\n    return ComplexHierarchicalTree;\n}());\n\n/**\n * Utility that arranges the nodes in hierarchical structure\n */\nvar HierarchicalLayoutUtil = /** @class */ (function () {\n    function HierarchicalLayoutUtil() {\n        this.nameTable = {};\n        this.crossReduction = new CrossReduction();\n        /**\n         * The preferred vertical offset between edges exiting a vertex Default is 2.\n         */\n        this.previousEdgeOffset = 6;\n        /**\n         * The preferred horizontal distance between edges exiting a vertex Default is 5.\n         */\n        this.previousEdgeDistance = 5;\n        /**\n         * Holds the collection vertices, that are equivalent to nodes to be arranged\n         */\n        this.jettyPositions = {};\n        /**\n         * Internal cache of bottom-most value of Y for each rank\n         */\n        this.rankBottomY = null;\n        /**\n         * Internal cache of bottom-most value of X for each rank\n         */\n        this.limitX = null;\n        /**\n         * Internal cache of top-most values of Y for each rank\n         */\n        this.rankTopY = null;\n        /**\n         * The minimum parallelEdgeSpacing value is 12.\n         */\n        this.parallelEdgeSpacing = 10;\n        /**\n         * The minimum distance for an edge jetty from a vertex Default is 12.\n         */\n        this.minEdgeJetty = 12;\n    }\n    //Defines a vertex that is equivalent to a node object\n    HierarchicalLayoutUtil.prototype.createVertex = function (node, value, x, y, width, height) {\n        var geometry = { x: x, y: y, width: width, height: height };\n        var vertex = {\n            value: value, geometry: geometry, name: value, vertex: true,\n            inEdges: node.inEdges.slice(), outEdges: node.outEdges.slice()\n        };\n        return vertex;\n    };\n    /**\n     * Initializes the edges collection of the vertices\\\n     *\n     * @returns {  IConnector[] }    Initializes the edges collection of the vertices\\\n     * @param {Vertex} node - provide the node value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getEdges = function (node) {\n        var edges = [];\n        var node1 = this.nameTable[node.name];\n        // 941582: ExcludeFromLayout Option Not Supported in Complex Hierarchical Tree\n        if (node && !node1.excludeFromLayout) {\n            for (var i = 0; node.inEdges.length > 0 && i < node.inEdges.length; i++) {\n                var connector = this.nameTable[node.inEdges[parseInt(i.toString(), 10)]];\n                if (!this.nameTable[connector.sourceID].excludeFromLayout) {\n                    edges.push(connector);\n                }\n            }\n            for (var i = 0; node.outEdges.length > 0 && i < node.outEdges.length; i++) {\n                var connector = this.nameTable[node.outEdges[parseInt(i.toString(), 10)]];\n                if (!this.nameTable[connector.targetID].excludeFromLayout) {\n                    edges.push(connector);\n                }\n            }\n        }\n        return edges;\n    };\n    //Finds the root nodes of the layout\n    HierarchicalLayoutUtil.prototype.findRoots = function (vertices) {\n        var roots = [];\n        var best = null;\n        var maxDiff = -100000;\n        for (var _i = 0, _a = Object.keys(vertices); _i < _a.length; _i++) {\n            var i = _a[_i];\n            var cell = vertices[\"\" + i];\n            var conns = this.getEdges(cell);\n            var outEdges = 0;\n            var inEdges = 0;\n            for (var k = 0; k < conns.length; k++) {\n                var src = this.getVisibleTerminal(conns[parseInt(k.toString(), 10)], true);\n                if (src.name === cell.name) {\n                    outEdges++;\n                }\n                else {\n                    inEdges++;\n                }\n            }\n            if (inEdges === 0 && outEdges > 0) {\n                roots.push(cell);\n            }\n            var diff = outEdges - inEdges;\n            if (diff > maxDiff) {\n                maxDiff = diff;\n                best = cell;\n            }\n        }\n        if (roots.length === 0 && best != null) {\n            roots.push(best);\n        }\n        return roots;\n    };\n    /**\n     * Returns the source/target vertex of the given connector \\\n     *\n     * @returns {  Vertex }    Returns the source/target vertex of the given connector \\\n     * @param {IConnector} edge - provide the node value.\n     * @param {boolean} source - provide the node value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getVisibleTerminal = function (edge, source) {\n        var terminalCache = this.nameTable[edge.targetID];\n        if (source) {\n            terminalCache = this.nameTable[edge.sourceID];\n        }\n        for (var i = 0; i < this.vertices.length; i++) {\n            if (this.vertices[parseInt(i.toString(), 10)].name === terminalCache.id) {\n                return this.vertices[parseInt(i.toString(), 10)];\n            }\n        }\n        return null;\n    };\n    /**\n     * Traverses each sub tree, ensures there is no cycle in traversing \\\n     *\n     * @returns {  {} }    Traverses each sub tree, ensures there is no cycle in traversing .\\\n     * @param {Vertex} vertex - provide the vertex value.\n     * @param {boolean} directed - provide the directed value.\n     * @param {IConnector} edge - provide the edge value.\n     * @param {{}} currentComp - provide the currentComp value.\n     * @param {{}[]} hierarchyVertices - provide the hierarchyVertices value.\n     * @param {{}} filledVertices - provide the filledVertices value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.traverse = function (vertex, directed, edge, currentComp, hierarchyVertices, filledVertices) {\n        if (vertex != null) {\n            var vertexID = vertex.name;\n            if ((filledVertices == null ? true : filledVertices[\"\" + vertexID] != null)) {\n                if (currentComp[\"\" + vertexID] == null) {\n                    currentComp[\"\" + vertexID] = vertex;\n                }\n                if (filledVertices != null) {\n                    delete filledVertices[\"\" + vertexID];\n                }\n                var edges = this.getEdges(vertex);\n                var edgeIsSource = [];\n                for (var i = 0; i < edges.length; i++) {\n                    edgeIsSource[parseInt(i.toString(), 10)] = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], true) === vertex;\n                }\n                for (var i = 0; i < edges.length; i++) {\n                    if (!directed || edgeIsSource[parseInt(i.toString(), 10)]) {\n                        var next = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], !edgeIsSource[parseInt(i.toString(), 10)]);\n                        var netCount = 1;\n                        for (var j = 0; j < edges.length; j++) {\n                            if (j === i) {\n                                continue;\n                            }\n                            else {\n                                var isSource2 = edgeIsSource[parseInt(j.toString(), 10)];\n                                var otherTerm = this.getVisibleTerminal(edges[parseInt(j.toString(), 10)], !isSource2);\n                                if (otherTerm === next) {\n                                    if (isSource2) {\n                                        netCount++;\n                                    }\n                                    else {\n                                        netCount--;\n                                    }\n                                }\n                            }\n                        }\n                        if (netCount >= 0) {\n                            currentComp = this.traverse(next, directed, edges[parseInt(i.toString(), 10)], currentComp, hierarchyVertices, filledVertices);\n                        }\n                    }\n                }\n            }\n            else {\n                if (currentComp[\"\" + vertexID] == null) {\n                    // We've seen this vertex before, but not in the current component This component and the one it's in need to be merged\n                    for (var i = 0; i < hierarchyVertices.length; i++) {\n                        var comp = hierarchyVertices[parseInt(i.toString(), 10)];\n                        if (comp[\"\" + vertexID] != null) {\n                            for (var _i = 0, _a = Object.keys(comp); _i < _a.length; _i++) {\n                                var key = _a[_i];\n                                currentComp[\"\" + key] = comp[\"\" + key];\n                            }\n                            // Remove the current component from the hierarchy set\n                            hierarchyVertices.splice(i, 1);\n                            return currentComp;\n                        }\n                    }\n                }\n            }\n        }\n        return currentComp;\n    };\n    //Returns the bounds of the given vertices\n    HierarchicalLayoutUtil.prototype.getModelBounds = function (nodes) {\n        nodes = nodes.slice();\n        var rect = null;\n        var rect1 = null;\n        for (var i = 0; i < nodes.length; i++) {\n            rect = nodes[parseInt(i.toString(), 10)].geometry;\n            if (rect1) {\n                var right = Math.max(rect1.x + rect1.width, rect.x + rect.width);\n                var bottom = Math.max(rect1.y + rect1.height, rect.y + rect.height);\n                rect1.x = Math.min(rect1.x, rect.x);\n                rect1.y = Math.min(rect1.y, rect.y);\n                rect1.width = right - rect1.x;\n                rect1.height = bottom - rect1.y;\n            }\n            else {\n                rect1 = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };\n            }\n        }\n        return rect1;\n    };\n    /* tslint:disable */\n    /**\n     *  Initializes the layouting process \\\n     *\n     * @returns {  Vertex }     Initializes the layouting process \\\n     * @param {INode[]} nodes - provide the node value.\n     * @param {{}} nameTable - provide the nameTable value.\n     * @param {Layout} layoutProp - provide the layoutProp value.\n     * @param {PointModel} viewPort - provide the viewPort value.\n     * @param {Diagram} diagram - provide the diagram model.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.doLayout = function (nodes, nameTable, layoutProp, viewPort, diagram) {\n        this.nameTable = nameTable;\n        var canEnableRouting = layoutProp.enableRouting;\n        var layout = {\n            horizontalSpacing: layoutProp.horizontalSpacing, verticalSpacing: layoutProp.verticalSpacing,\n            orientation: layoutProp.orientation, marginX: layoutProp.margin.left, marginY: layoutProp.margin.top,\n            enableLayoutRouting: canEnableRouting\n        };\n        var model;\n        var matrixModel = new MatrixModel();\n        matrixModel.edgeMapper = [];\n        matrixModel.diagram = diagram;\n        var nodeWithMultiEdges = [];\n        this.vertices = [];\n        var filledVertexSet = {};\n        for (var i = 0; i < nodes.length; i++) {\n            var node1 = this.nameTable[nodes[parseInt(i.toString(), 10)].id];\n            // 941582: ExcludeFromLayout Option Not Supported in Complex Hierarchical Tree\n            if (!node1.excludeFromLayout) {\n                var node = this.createVertex(nodes[parseInt(i.toString(), 10)], nodes[parseInt(i.toString(), 10)].id, 0, 0, nodes[parseInt(i.toString(), 10)].actualSize.width, nodes[parseInt(i.toString(), 10)].actualSize.height);\n                this.vertices.push(node);\n                if (nodes[parseInt(i.toString(), 10)].inEdges.length > 0\n                    || nodes[parseInt(i.toString(), 10)].outEdges.length > 0) {\n                    nodeWithMultiEdges.push(nodes[parseInt(i.toString(), 10)]);\n                }\n                filledVertexSet[node.name] = node;\n                if (matrixModel) {\n                    var outEdges = nodes[parseInt(i.toString(), 10)].outEdges.slice();\n                    for (var j = 0; j < outEdges.length; j++) {\n                        var outEdge = nameTable[outEdges[parseInt(j.toString(), 10)]];\n                        matrixModel.setEdgeMapper({ key: outEdge, value: [] });\n                    }\n                }\n            }\n        }\n        var hierarchyVertices = [];\n        //let candidateRoots: Vertex[];\n        var candidateRoots = this.findRoots(filledVertexSet);\n        for (var i = 0; i < candidateRoots.length; i++) {\n            var vertexSet = {};\n            hierarchyVertices.push(vertexSet);\n            this.traverse(candidateRoots[parseInt(i.toString(), 10)], true, null, vertexSet, hierarchyVertices, filledVertexSet);\n        }\n        var limit = { marginX: 0, marginY: 0 };\n        var tmp = [];\n        var checkLinear = false;\n        var matrixModelObject;\n        for (var i = 0; i < hierarchyVertices.length; i++) {\n            var vertexSet = hierarchyVertices[parseInt(i.toString(), 10)];\n            // eslint-disable-next-line\n            for (var _i = 0, _a = Object.keys(vertexSet); _i < _a.length; _i++) {\n                var key = _a[_i];\n                tmp.push(vertexSet[\"\" + key]);\n            }\n            if ((layoutProp.arrangement === 'Linear' && i === hierarchyVertices.length - 1) || canEnableRouting) {\n                checkLinear = true;\n            }\n            model = new MultiParentModel(this, tmp, candidateRoots, layout);\n            this.cycleStage(model);\n            this.layeringStage(model);\n            //897503: Child Nodes position in ComplexHierarchicalTree updated wrongly results in connector overlap\n            if ((matrixModel && layoutProp.connectionPointOrigin === 'DifferentPoint') || checkLinear) {\n                matrixModelObject = { model: model, matrix: [], rowOffset: [], roots: [] };\n                matrixModel.arrangeElements(matrixModelObject, layoutProp);\n                layoutProp.ranks = matrixModelObject.model.ranks;\n            }\n            else {\n                if (layoutProp.arrangement === 'Nonlinear') {\n                    this.crossingStage(model);\n                    limit = this.placementStage(model, limit.marginX, limit.marginY);\n                    tmp = [];\n                }\n            }\n        }\n        var modelBounds = this.getModelBounds(this.vertices);\n        this.updateMargin(layoutProp, layout, modelBounds, viewPort);\n        for (var i = 0; i < this.vertices.length; i++) {\n            var clnode = this.vertices[parseInt(i.toString(), 10)];\n            if (clnode) { //Check what is node.source/node.target -  && !clnode.source && !clnode.target) {\n                var dnode = this.nameTable[clnode.name];\n                dnode.offsetX = 0;\n                dnode.offsetY = 0;\n                //initialize layout\n                var dx = (clnode.geometry.x - (dnode.offsetX - (dnode.actualSize.width / 2))) + layout.marginX;\n                var dy = (clnode.geometry.y - (dnode.offsetY - (dnode.actualSize.height / 2))) + layout.marginY;\n                var x = dx;\n                var y = dy;\n                if (layout.orientation === 'BottomToTop') {\n                    if (canEnableRouting) {\n                        clnode.geometry.y = modelBounds.height - dy - dnode.actualSize.height / 2;\n                    }\n                    y = modelBounds.height - dy;\n                }\n                else if (layout.orientation === 'RightToLeft') {\n                    x = modelBounds.width - dx;\n                }\n                dnode.offsetX += x - dnode.offsetX;\n                dnode.offsetY += y - dnode.offsetY;\n                if (layoutProp.horizontalAlignment !== 'Stretch' || layoutProp.verticalAlignment !== 'Stretch') {\n                    matrixModel.nodePropertyChange(dnode);\n                }\n            }\n        }\n        if (!checkLinear) {\n            for (var i = 0; i < this.vertices.length; i++) {\n                this.isNodeOverLap(this.nameTable[this.vertices[parseInt(i.toString(), 10)].name], layoutProp);\n            }\n        }\n        matrixModel.updateLayout(viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable);\n        if (canEnableRouting) {\n            var vertices = {};\n            var matrixrow1 = void 0;\n            for (var p = 0; p < matrixModelObject.matrix.length; p++) {\n                matrixrow1 = matrixModelObject.matrix[parseInt(p.toString(), 10)].value;\n                for (var q = 0; q < matrixrow1.length; q++) {\n                    var matrixCell = matrixrow1[parseInt(q.toString(), 10)];\n                    for (var r = 0; r < matrixCell.cells.length; r++) {\n                        var cell = matrixCell.cells[parseInt(r.toString(), 10)];\n                        var type = this.getType(cell.type);\n                        if (type === 'internalVertex') {\n                            var internalVertex = cell;\n                            vertices[internalVertex.id] = internalVertex;\n                        }\n                    }\n                }\n            }\n            this.updateRankValuess(model);\n            for (var i = 0, a = Object.keys(vertices); i < a.length; i++) {\n                var key = a[parseInt(i.toString(), 10)];\n                this.setVertexLocationValue(vertices[\"\" + key], layoutProp.orientation, modelBounds);\n            }\n            this.localEdgeProcessing(model, vertices);\n            this.assignRankOffset(model);\n            this.updateEdgeSetXYValue(model);\n            var edges = this.getValues(model.edgeMapper);\n            for (var i = 0; i < edges.length; i++) {\n                if ((edges[parseInt(i.toString(), 10)]).x.length > 0) {\n                    for (var j = 0; j < (edges[parseInt(i.toString(), 10)]).x.length; j++) {\n                        if (layoutProp.orientation !== 'RightToLeft' && layoutProp.orientation !== 'LeftToRight') {\n                            (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)]\n                                = (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)] + layout.marginX;\n                        }\n                        else if (layoutProp.orientation === 'LeftToRight') {\n                            (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)]\n                                = (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)] + layoutProp.verticalSpacing / 2;\n                        }\n                        else {\n                            (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)]\n                                = (edges[parseInt(i.toString(), 10)]).x[parseInt(j.toString(), 10)] + layoutProp.verticalSpacing / 2;\n                        }\n                    }\n                }\n                this.setEdgePosition(edges[parseInt(i.toString(), 10)], model, layout);\n            }\n            for (var p = 0; p < this.vertices.length; p++) {\n                var clnode = this.vertices[parseInt(p.toString(), 10)];\n                if (clnode.outEdges.length > 1) {\n                    this.updateMultiOutEdgesPoints(clnode);\n                }\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.setEdgeXY = function (ranks, node, spacing, layer) {\n        if (ranks && node.source.id) {\n            var targetValue = void 0;\n            var sourceValue = void 0;\n            for (var i = 0; i < ranks.length; i++) {\n                for (var k = 0; k < ranks[parseInt(i.toString(), 10)].length; k++) {\n                    if (ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.target.id\n                        || ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.source.id) {\n                        if (ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.target.id\n                            && targetValue === undefined) {\n                            targetValue = i;\n                        }\n                        if (ranks[parseInt(i.toString(), 10)][parseInt(k.toString(), 10)].id === node.source.id\n                            && sourceValue === undefined) {\n                            sourceValue = i;\n                        }\n                    }\n                }\n            }\n            var rankOffsetValue = void 0;\n            for (var m = targetValue; m <= sourceValue; m++) {\n                if (rankOffsetValue === undefined) {\n                    rankOffsetValue = this[m + '_RankOffset'];\n                }\n                if (rankOffsetValue !== undefined && rankOffsetValue < this[m + '_RankOffset']) {\n                    rankOffsetValue = this[m + '_RankOffset'];\n                }\n            }\n            if (this['edges'] === undefined) {\n                this['edges'] = {};\n            }\n            this['edges'][(node).ids[0]] = { x: node.x, y: 0 };\n            var value = this.resetOffsetXValue(rankOffsetValue, spacing / 10);\n            node.x[layer - node.minRank - 1] = value;\n            for (var k = 0; k < (node).edges.length; k++) {\n                (node).edges[parseInt(k.toString(), 10)]['levelSkip'] = true;\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.resetOffsetXValue = function (value, spacing) {\n        for (var i = 0, a = Object.keys(this['edges']); i < a.length; i++) {\n            var key = a[parseInt(i.toString(), 10)];\n            var length_1 = this['edges'][\"\" + key].x;\n            for (var j = 0; j < length_1.length; j++) {\n                var offsetValue = void 0;\n                if (this['edges'][\"\" + key].x[parseInt(j.toString(), 10)] === value) {\n                    offsetValue = value + spacing;\n                    offsetValue = this.resetOffsetXValue(offsetValue, spacing);\n                    return offsetValue;\n                }\n            }\n        }\n        return value;\n    };\n    HierarchicalLayoutUtil.prototype.setEdgePosition = function (cell, model, layout) {\n        // For parallel edges we need to seperate out the points a\n        // little\n        var offsetX = 0;\n        // Only set the edge control points once\n        if (cell.temp[0] !== 101207) {\n            if (cell.maxRank === undefined) {\n                cell.maxRank = -1;\n            }\n            if (cell.minRank === undefined) {\n                cell.minRank = -1;\n            }\n            var maxRank = cell.maxRank;\n            var minRank = cell.minRank;\n            if (maxRank === minRank) {\n                maxRank = cell.source.maxRank;\n                minRank = cell.target.minRank;\n            }\n            var parallelEdgeCount = 0;\n            var jettys = this.jettyPositions[cell.ids[0]];\n            if (cell.isReversed === undefined) {\n                cell.isReversed = false;\n            }\n            else {\n                cell.isReversed = true;\n            }\n            var source = cell.isReversed ? cell.target.cell : cell.source.cell;\n            var layoutReversed = false;\n            if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'LeftToRight') {\n                if (model.layout.orientation === 'TopToBottom') {\n                    layoutReversed = false;\n                }\n                if (model.layout.orientation === 'LeftToRight') {\n                    if (!cell.isReversed) {\n                        layoutReversed = false;\n                    }\n                    else {\n                        layoutReversed = false;\n                    }\n                }\n            }\n            else {\n                if (!cell.isReversed) {\n                    layoutReversed = true;\n                }\n            }\n            for (var i = 0; i < cell.edges.length; i++) {\n                var realEdge = cell.edges[parseInt(i.toString(), 10)];\n                var realSource = this.getVisibleTerminal(realEdge, true);\n                //List oldPoints = graph.getPoints(realEdge);\n                var newPoints = [];\n                // Single length reversed edges end up with the jettys in the wrong\n                // places. Since single length edges only have jettys, not segment\n                // control points, we just say the edge isn't reversed in this section\n                var reversed = cell.isReversed;\n                // if(cell.isReversed===undefined){\n                //     reversed = false\n                // }else{\n                //     reversed =cell.isReversed\n                // }\n                if (realSource !== source) {\n                    // The real edges include all core model edges and these can go\n                    // in both directions. If the source of the hierarchical model edge\n                    // isn't the source of the specific real edge in this iteration\n                    // treat if as reversed\n                    reversed = !reversed;\n                }\n                // First jetty of edge\n                if (jettys != null) {\n                    var arrayOffset = reversed ? 2 : 0;\n                    var y = reversed ?\n                        (layoutReversed ? this.rankBottomY[parseInt(minRank.toString(), 10)]\n                            : this.rankTopY[parseInt(minRank.toString(), 10)])\n                        : (layoutReversed ? this.rankTopY[parseInt(maxRank.toString(), 10)]\n                            : this.rankBottomY[parseInt(maxRank.toString(), 10)]);\n                    var jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        y += jetty;\n                    }\n                    var x = jettys[parallelEdgeCount * 4 + arrayOffset];\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        newPoints.push(this.getPointvalue(x, y + layout.marginY));\n                    }\n                    else {\n                        if (layout.orientation === 'LeftToRight') {\n                            newPoints.push(this.getPointvalue(y + jetty, x + layout.marginY));\n                        }\n                        else {\n                            newPoints.push(this.getPointvalue(y, x + layout.marginY));\n                        }\n                    }\n                }\n                var loopStart = cell.x.length - 1;\n                var loopLimit = -1;\n                var loopDelta = -1;\n                var currentRank = cell.maxRank - 1;\n                if (reversed) {\n                    loopStart = 0;\n                    loopLimit = cell.x.length;\n                    loopDelta = 1;\n                    currentRank = cell.minRank + 1;\n                }\n                // Reversed edges need the points inserted in\n                // reverse order\n                for (var j = loopStart; (cell.maxRank !== cell.minRank) && j !== loopLimit; j += loopDelta) {\n                    // The horizontal position in a vertical layout\n                    var positionX = cell.x[parseInt(j.toString(), 10)] + offsetX;\n                    // This cell.x determines the deviated points of the connectors and jetty positions\n                    //determine the src and targetgeo points .\n                    // Work out the vertical positions in a vertical layout\n                    // in the edge buffer channels above and below this rank\n                    var topChannelY = (this.rankTopY[parseInt(currentRank.toString(), 10)]\n                        + this.rankBottomY[currentRank + 1]) / 2.0;\n                    var bottomChannelY = (this.rankTopY[currentRank - 1]\n                        + this.rankBottomY[parseInt(currentRank.toString(), 10)]) / 2.0;\n                    if (reversed) {\n                        var tmp = topChannelY;\n                        topChannelY = bottomChannelY;\n                        bottomChannelY = tmp;\n                    }\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        newPoints.push(this.getPointvalue(positionX, topChannelY + layout.marginY));\n                        newPoints.push(this.getPointvalue(positionX, bottomChannelY + layout.marginY));\n                    }\n                    else {\n                        newPoints.push(this.getPointvalue(topChannelY, positionX + layout.marginY));\n                        newPoints.push(this.getPointvalue(bottomChannelY, positionX + layout.marginY));\n                    }\n                    this.limitX = Math.max(this.limitX, positionX);\n                    currentRank += loopDelta;\n                }\n                // Second jetty of edge\n                if (jettys != null) {\n                    var arrayOffset = reversed ? 2 : 0;\n                    var rankY = reversed ?\n                        (layoutReversed ? this.rankTopY[parseInt(maxRank.toString(), 10)]\n                            : this.rankBottomY[parseInt(maxRank.toString(), 10)])\n                        : (layoutReversed ? this.rankBottomY[parseInt(minRank.toString(), 10)]\n                            : this.rankTopY[parseInt(minRank.toString(), 10)]);\n                    var jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    var y = rankY - jetty;\n                    var x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        newPoints.push(this.getPointvalue(x, y + layout.marginY));\n                    }\n                    else {\n                        newPoints.push(this.getPointvalue(y, x + layout.marginY));\n                    }\n                }\n                this.setEdgePoints(realEdge, newPoints, model);\n                // Increase offset so next edge is drawn next to\n                // this one\n                if (offsetX === 0.0) {\n                    offsetX = this.parallelEdgeSpacing;\n                }\n                else if (offsetX > 0) {\n                    offsetX = -offsetX;\n                }\n                else {\n                    offsetX = -offsetX + this.parallelEdgeSpacing;\n                }\n                parallelEdgeCount++;\n            }\n            cell.temp[0] = 101207;\n        }\n    };\n    /* tslint:enable */\n    // eslint-disable-next-line\n    HierarchicalLayoutUtil.prototype.getPointvalue = function (x, y) {\n        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };\n    };\n    HierarchicalLayoutUtil.prototype.updateEdgeSetXYValue = function (model) {\n        if (model.layout.enableLayoutRouting) {\n            var isHorizontal = false;\n            if (model.layout.orientation === 'LeftToRight' || model.layout.orientation === 'RightToLeft') {\n                isHorizontal = true;\n            }\n            for (var i = 0; i < model.ranks.length; i++) {\n                var rank = model.ranks[parseInt(i.toString(), 10)];\n                for (var k = 0; k < rank.length; k++) {\n                    var cell = rank[parseInt(k.toString(), 10)];\n                    if ((cell).edges && (cell).edges.length > 0) {\n                        var spacing = model.layout.horizontalSpacing > 0 ? (model.layout.horizontalSpacing / 2) : 15;\n                        var check = true;\n                        if (!(cell.minRank === i - 1 || cell.maxRank === i - 1)) {\n                            check = false;\n                        }\n                        if (check) {\n                            this.setXY(cell, i, undefined, isHorizontal ? true : false, model.ranks, spacing);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.getPreviousLayerConnectedCells = function (layer, cell) {\n        if (cell.previousLayerConnectedCells == null) {\n            cell.previousLayerConnectedCells = [];\n            cell.previousLayerConnectedCells[0] = [];\n            for (var i = 0; i < cell.connectsAsSource.length; i++) {\n                var edge = cell.connectsAsSource[parseInt(i.toString(), 10)];\n                if (edge.minRank === -1 || edge.minRank === layer - 1) {\n                    // No dummy nodes in edge, add node of other side of edge\n                    cell.previousLayerConnectedCells[0].push(edge.target);\n                }\n                else {\n                    // Edge spans at least two layers, add edge\n                    cell.previousLayerConnectedCells[0].push(edge);\n                }\n            }\n        }\n        return cell.previousLayerConnectedCells[0];\n    };\n    HierarchicalLayoutUtil.prototype.compare = function (a, b) {\n        if (a != null && b != null) {\n            if (b.weightedValue > a.weightedValue) {\n                return -1;\n            }\n            else if (b.weightedValue < a.weightedValue) {\n                return 1;\n            }\n        }\n        return 0;\n    };\n    /* tslint:disable */\n    // eslint-disable-next-line\n    HierarchicalLayoutUtil.prototype.localEdgeProcessing = function (model, vertices) {\n        // Iterate through each vertex, look at the edges connected in\n        // both directions.\n        for (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++) {\n            var rank = model.ranks[parseInt(rankIndex.toString(), 10)];\n            for (var cellIndex = 0; cellIndex < rank.length; cellIndex++) {\n                var cell = rank[parseInt(cellIndex.toString(), 10)];\n                if (this.crossReduction.isVertex(cell)) {\n                    var currentCells = this.getPreviousLayerConnectedCells(rankIndex, cell);\n                    var currentRank = rankIndex - 1;\n                    // Two loops, last connected cells, and next\n                    for (var k = 0; k < 2; k++) {\n                        if (currentRank > -1\n                            && currentRank < model.ranks.length\n                            && currentCells != null\n                            && currentCells.length > 0) {\n                            var sortedCells = [];\n                            for (var j = 0; j < currentCells.length; j++) {\n                                var sorter = this.weightedCellSorter(currentCells[parseInt(j.toString(), 10)], this.getX(currentRank, currentCells[parseInt(j.toString(), 10)]));\n                                sortedCells.push(sorter);\n                            }\n                            sortedCells.sort(this.compare);\n                            cell.width = vertices[cell.id].cell.geometry.width;\n                            cell.height = vertices[cell.id].cell.geometry.height;\n                            var leftLimit = void 0;\n                            if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {\n                                cell.x[0] = vertices[cell.id].cell.geometry.x + vertices[cell.id].cell.geometry.width / 2;\n                                leftLimit = cell.x[0] - cell.width / 2 + vertices[cell.id].cell.geometry.height / 2;\n                            }\n                            else {\n                                cell.x[0] = vertices[cell.id].cell.geometry.y;\n                                leftLimit = cell.x[0];\n                            }\n                            var rightLimit = leftLimit + cell.width;\n                            // Connected edge count starts at 1 to allow for buffer\n                            // with edge of vertex\n                            var connectedEdgeCount = 0;\n                            var connectedEdgeGroupCount = 0;\n                            var connectedEdges = [];\n                            // Calculate width requirements for all connected edges\n                            for (var j = 0; j < sortedCells.length; j++) {\n                                var innerCell = sortedCells[parseInt(j.toString(), 10)].cell;\n                                var connections = void 0;\n                                if (this.crossReduction.isVertex(innerCell)) {\n                                    // Get the connecting edge\n                                    if (k === 0) {\n                                        connections = cell.connectsAsSource;\n                                    }\n                                    else {\n                                        connections = cell.connectsAsTarget;\n                                    }\n                                    for (var connIndex = 0; connIndex < connections.length; connIndex++) {\n                                        if (connections[parseInt(connIndex.toString(), 10)].source === innerCell\n                                            || connections[parseInt(connIndex.toString(), 10)].target === innerCell) {\n                                            connectedEdgeCount += connections[parseInt(connIndex.toString(), 10)].edges\n                                                .length;\n                                            connectedEdgeGroupCount++;\n                                            connectedEdges.push(connections[parseInt(connIndex.toString(), 10)]);\n                                        }\n                                    }\n                                }\n                                else {\n                                    connectedEdgeCount += innerCell.edges.length;\n                                    // eslint-disable-next-line\n                                    connectedEdgeGroupCount++;\n                                    connectedEdges.push(innerCell);\n                                }\n                            }\n                            var requiredWidth = (connectedEdgeCount + 1)\n                                * this.previousEdgeDistance;\n                            // Add a buffer on the edges of the vertex if the edge count allows\n                            if (cell.width > requiredWidth\n                                + (2 * this.previousEdgeDistance)) {\n                                leftLimit += this.previousEdgeDistance;\n                                rightLimit -= this.previousEdgeDistance;\n                            }\n                            var availableWidth = rightLimit - leftLimit;\n                            var edgeSpacing = availableWidth / connectedEdgeCount;\n                            var currentX = leftLimit + edgeSpacing / 2.0;\n                            var currentYOffset = this.minEdgeJetty - this.previousEdgeOffset;\n                            var maxYOffset = 0;\n                            for (var j = 0; j < connectedEdges.length; j++) {\n                                var numActualEdges = connectedEdges[parseInt(j.toString(), 10)].edges\n                                    .length;\n                                if (this.jettyPositions === undefined) {\n                                    this.jettyPositions = {};\n                                }\n                                var pos = this.jettyPositions[connectedEdges[parseInt(j.toString(), 10)].ids[0]];\n                                if (pos == null) {\n                                    pos = [];\n                                    this.jettyPositions[connectedEdges[parseInt(j.toString(), 10)].ids[0]] = pos;\n                                }\n                                if (j < connectedEdgeCount / 2) {\n                                    currentYOffset += this.previousEdgeOffset;\n                                }\n                                else if (j > connectedEdgeCount / 2) {\n                                    currentYOffset -= this.previousEdgeOffset;\n                                }\n                                // Ignore the case if equals, this means the second of 2\n                                // jettys with the same y (even number of edges)\n                                for (var m = 0; m < numActualEdges; m++) {\n                                    pos[m * 4 + k * 2] = currentX;\n                                    currentX += edgeSpacing;\n                                    pos[m * 4 + k * 2 + 1] = currentYOffset;\n                                }\n                                maxYOffset = Math.max(maxYOffset, currentYOffset);\n                            }\n                        }\n                        currentCells = this.getNextLayerConnectedCells(rankIndex, cell);\n                        currentRank = rankIndex + 1;\n                    }\n                }\n            }\n        }\n    };\n    /* tslint:enable */\n    HierarchicalLayoutUtil.prototype.updateMultiOutEdgesPoints = function (clnode) {\n        for (var i = 0; i < clnode.outEdges.length / 2; i++) {\n            var connector1 = this.nameTable[clnode.outEdges[parseInt(i.toString(), 10)]];\n            var connector2 = this.nameTable[clnode.outEdges[clnode.outEdges.length - (i + 1)]];\n            var geometry = 'geometry';\n            //900930: To exclude self-loop in layouts\n            if (connector1.sourceID !== connector2.targetID && connector1.targetID !== connector2.sourceID) {\n                connector2[\"\" + geometry].points[0].y = connector1[\"\" + geometry].points[0].y;\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.getNextLayerConnectedCells = function (layer, cell) {\n        if (cell.nextLayerConnectedCells == null) {\n            cell.nextLayerConnectedCells = [];\n            cell.nextLayerConnectedCells[0] = [];\n            for (var i = 0; i < cell.connectsAsTarget.length; i++) {\n                var edge = cell.connectsAsTarget[parseInt(i.toString(), 10)];\n                if (edge.maxRank === -1 || edge.maxRank === layer + 1) {\n                    // Either edge is not in any rank or\n                    // no dummy nodes in edge, add node of other side of edge\n                    cell.nextLayerConnectedCells[0].push(edge.source);\n                }\n                else {\n                    // Edge spans at least two layers, add edge\n                    cell.nextLayerConnectedCells[0].push(edge);\n                }\n            }\n        }\n        return cell.nextLayerConnectedCells[0];\n    };\n    HierarchicalLayoutUtil.prototype.getX = function (layer, cell) {\n        if (this.crossReduction.isVertex(cell)) {\n            return cell.x[0];\n        }\n        else if (!this.crossReduction.isVertex(cell)) {\n            return cell.x[layer - cell.minRank - 1] || cell.temp[layer - cell.minRank - 1];\n        }\n        return 0.0;\n    };\n    HierarchicalLayoutUtil.prototype.getGeometry = function (edge) {\n        var geometry = 'geometry';\n        return edge[\"\" + geometry];\n    };\n    HierarchicalLayoutUtil.prototype.setEdgePoints = function (edge, points, model) {\n        if (edge != null) {\n            var geometryValue = 'geometry';\n            var geometry = this.getGeometry(edge);\n            if (points != null) {\n                for (var i = 0; i < points.length; i++) {\n                    // eslint-disable-next-line\n                    points[i].x = points[i].x;\n                    // eslint-disable-next-line\n                    points[i].y = points[i].y;\n                }\n            }\n            geometry.points = points;\n            edge[\"\" + geometryValue] = geometry;\n        }\n    };\n    HierarchicalLayoutUtil.prototype.assignRankOffset = function (model) {\n        if (model) {\n            for (var i = 0; i < model.ranks.length; i++) {\n                this.rankCoordinatesAssigment(i, model);\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.rankCoordinatesAssigment = function (rankValue, model) {\n        var rank = model.ranks[parseInt(rankValue.toString(), 10)];\n        var spacing = model.layout.horizontalSpacing;\n        var localOffset;\n        for (var i = 0; i < rank.length; i++) {\n            if (this[rankValue + '_' + 'RankOffset'] === undefined) {\n                this[rankValue + '_' + 'RankOffset'] = 0;\n            }\n            localOffset = rank[parseInt(i.toString(), 10)].x[0];\n            if (this[rankValue + '_' + 'RankOffset'] < localOffset) {\n                this[rankValue + '_' + 'RankOffset'] = localOffset + rank[parseInt(i.toString(), 10)].width / 2 + spacing;\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.getType = function (type) {\n        if (type === 'internalVertex') {\n            return 'internalVertex';\n        }\n        else {\n            return 'internalEdge';\n        }\n    };\n    HierarchicalLayoutUtil.prototype.updateRankValuess = function (model) {\n        this.rankTopY = [];\n        this.rankBottomY = [];\n        for (var i = 0; i < model.ranks.length; i++) {\n            this.rankTopY[parseInt(i.toString(), 10)] = Number.MAX_VALUE;\n            this.rankBottomY[parseInt(i.toString(), 10)] = -Number.MAX_VALUE;\n        }\n    };\n    HierarchicalLayoutUtil.prototype.setVertexLocationValue = function (cell, orientation, modelBounds) {\n        var cellGeomtry = cell.cell.geometry;\n        var positionX;\n        var positionY;\n        if (orientation === 'TopToBottom' || orientation === 'BottomToTop') {\n            positionX = cellGeomtry.x;\n            positionY = cellGeomtry.y;\n        }\n        else {\n            positionX = cellGeomtry.y;\n            positionY = cellGeomtry.x;\n        }\n        if (orientation === 'RightToLeft') {\n            // eslint-disable-next-line\n            positionX = cellGeomtry.y;\n            positionY = modelBounds.width - cellGeomtry.x - cellGeomtry.height;\n            this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY);\n            this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY + cellGeomtry.height);\n        }\n        else {\n            this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);\n            this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY + cellGeomtry.height);\n        }\n    };\n    HierarchicalLayoutUtil.prototype.calculateRectValue = function (dnode) {\n        var rect = { x: 0, y: 0, right: 0, bottom: 0, height: 0, width: 0 };\n        rect.x = dnode.offsetX - dnode.actualSize.width / 2;\n        rect.right = dnode.offsetX + dnode.actualSize.width / 2;\n        rect.y = dnode.offsetY - dnode.actualSize.height / 2;\n        rect.bottom = dnode.offsetY + dnode.actualSize.height / 2;\n        return rect;\n    };\n    HierarchicalLayoutUtil.prototype.isNodeOverLap = function (dnode, layoutProp) {\n        var nodeRect = { x: 0, y: 0, right: 0, bottom: 0, height: 0, width: 0 };\n        for (var i = 0; i < this.vertices.length; i++) {\n            var rect = { x: 0, y: 0, width: 0, height: 0 };\n            //let tempnode1: INode;\n            var tempnode1 = this.nameTable[this.vertices[parseInt(i.toString(), 10)].value];\n            if (dnode.id !== tempnode1.id && tempnode1.offsetX !== 0 && tempnode1.offsetY !== 0) {\n                nodeRect = this.calculateRectValue(dnode);\n                rect = this.calculateRectValue(tempnode1);\n                if (this.isIntersect(rect, nodeRect, layoutProp)) {\n                    if (layoutProp.orientation === 'TopToBottom' || layoutProp.orientation === 'BottomToTop') {\n                        dnode.offsetX += layoutProp.horizontalSpacing;\n                    }\n                    else {\n                        dnode.offsetY += layoutProp.verticalSpacing;\n                    }\n                    this.isNodeOverLap(dnode, layoutProp);\n                }\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.isIntersect = function (rect, nodeRect, layoutProp) {\n        if (!(Math.floor(rect.right + layoutProp.horizontalSpacing) <= Math.floor(nodeRect.x) ||\n            Math.floor(rect.x - layoutProp.horizontalSpacing) >= Math.floor(nodeRect.right)\n            || Math.floor(rect.y - layoutProp.verticalSpacing) >= Math.floor(nodeRect.bottom)\n            || Math.floor(rect.bottom + layoutProp.verticalSpacing) <= Math.floor(nodeRect.y))) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /* eslint-disable */\n    HierarchicalLayoutUtil.prototype.updateMargin = function (layoutProp, layout, modelBounds, viewPort) {\n        var viewPortBounds = { x: 0, y: 0, width: viewPort.x, height: viewPort.y };\n        //let layoutBounds: Rect;\n        var bounds = {\n            x: modelBounds.x, y: modelBounds.y,\n            right: modelBounds.x + modelBounds.width,\n            bottom: modelBounds.y + modelBounds.height\n        };\n        var layoutBounds = layoutProp.bounds ? layoutProp.bounds : viewPortBounds;\n        if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n            switch (layoutProp.horizontalAlignment) {\n                case 'Auto':\n                case 'Left':\n                    layout.marginX = (layoutBounds.x - bounds.x) + layoutProp.margin.left;\n                    break;\n                case 'Right':\n                    layout.marginX = layoutBounds.x + layoutBounds.width - layoutProp.margin.right - bounds.right;\n                    break;\n                case 'Center':\n                    layout.marginX = layoutBounds.x + layoutBounds.width / 2 - (bounds.x + bounds.right) / 2;\n                    break;\n            }\n            switch (layoutProp.verticalAlignment) {\n                case 'Top':\n                    //const top: number;\n                    var top_1 = layoutBounds.y + layoutProp.margin.top;\n                    layout.marginY = layout.orientation === 'TopToBottom' ? top_1 : -top_1;\n                    break;\n                case 'Bottom':\n                    //const bottom: number;\n                    var bottom = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom;\n                    layout.marginY = layout.orientation === 'TopToBottom' ? bottom - bounds.bottom : -(bottom - bounds.bottom);\n                    break;\n                case 'Auto':\n                case 'Center':\n                    //const center: number;\n                    var center = layoutBounds.y + layoutBounds.height / 2;\n                    layout.marginY = layout.orientation === 'TopToBottom' ?\n                        center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.y + bounds.bottom) / 2;\n                    break;\n            }\n        }\n        else {\n            switch (layoutProp.horizontalAlignment) {\n                case 'Auto':\n                case 'Left':\n                    //let left: number;\n                    var left = layoutBounds.x + layoutProp.margin.left;\n                    layout.marginX = layout.orientation === 'LeftToRight' ? left : -left;\n                    break;\n                case 'Right':\n                    var right = void 0;\n                    right = layoutBounds.x + layoutBounds.width - layoutProp.margin.right;\n                    layout.marginX = layout.orientation === 'LeftToRight' ? right - bounds.right : bounds.right - right;\n                    break;\n                case 'Center':\n                    var center = void 0;\n                    center = layoutBounds.width / 2 + layoutBounds.x;\n                    layout.marginX = layout.orientation === 'LeftToRight' ?\n                        center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.x + bounds.right) / 2;\n                    break;\n            }\n            switch (layoutProp.verticalAlignment) {\n                case 'Top':\n                    layout.marginY = layoutBounds.y + layoutProp.margin.top - bounds.y;\n                    break;\n                case 'Auto':\n                case 'Center':\n                    layout.marginY = layoutBounds.y + layoutBounds.height / 2 - (bounds.y + bounds.bottom) / 2;\n                    break;\n                case 'Bottom':\n                    layout.marginY = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom - bounds.bottom;\n                    break;\n            }\n        }\n    };\n    /* eslint-enable */\n    //Handles positioning the nodes\n    HierarchicalLayoutUtil.prototype.placementStage = function (model, marginX, marginY) {\n        var placementStage = this.coordinateAssignment(marginX, marginY, parent, model);\n        placementStage.model = model;\n        placementStage.widestRankValue = null;\n        this.placementStageExecute(placementStage);\n        return {\n            marginX: placementStage.marginX + model.layout.horizontalSpacing,\n            marginY: placementStage.marginY + model.layout.verticalSpacing\n        };\n    };\n    //Initializes the layout properties for positioning\n    HierarchicalLayoutUtil.prototype.coordinateAssignment = function (marginX, marginY, parent, model) {\n        var plalementChange = {};\n        if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {\n            plalementChange.horizontalSpacing = model.layout.horizontalSpacing;\n            plalementChange.verticalSpacing = model.layout.verticalSpacing;\n        }\n        else {\n            plalementChange.horizontalSpacing = model.layout.verticalSpacing;\n            plalementChange.verticalSpacing = model.layout.horizontalSpacing;\n        }\n        plalementChange.orientation = 'north';\n        //Removed the conditions here. So check here in case of any issue\n        plalementChange.marginX = plalementChange.marginX = marginX;\n        plalementChange.marginY = plalementChange.marginY = marginY;\n        return plalementChange;\n    };\n    //Calculate the largest size of the node either height or width depends upon the layoutorientation\n    HierarchicalLayoutUtil.prototype.calculateWidestRank = function (plalementChange, graph, model) {\n        var isHorizontal = false;\n        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        var offset = -plalementChange.verticalSpacing;\n        var lastRankMaxCellSize = 0.0;\n        plalementChange.rankSizes = [];\n        plalementChange.rankOffset = [];\n        for (var rankValue = model.maxRank; rankValue >= 0; rankValue--) {\n            var maxCellSize = 0.0;\n            var rank = model.ranks[parseInt(rankValue.toString(), 10)];\n            var localOffset = isHorizontal ? plalementChange.marginY : plalementChange.marginX;\n            for (var i = 0; i < rank.length; i++) {\n                var node = rank[parseInt(i.toString(), 10)];\n                if (this.crossReduction.isVertex(node)) {\n                    var vertex = node;\n                    if (vertex.cell && (vertex.cell.inEdges || vertex.cell.outEdges)) {\n                        var obj = this.nameTable[vertex.cell.name];\n                        vertex.width = obj.actualSize.width;\n                        vertex.height = obj.actualSize.height;\n                        maxCellSize = Math.max(maxCellSize, (isHorizontal ? vertex.width : vertex.height));\n                    }\n                }\n                else {\n                    if (node) {\n                        var edge = node;\n                        var numEdges = 1;\n                        if (edge.edges != null) {\n                            numEdges = edge.edges.length;\n                        }\n                        node.width = (numEdges - 1) * 10;\n                    }\n                }\n                if (isHorizontal) {\n                    if (!node.height) {\n                        node.height = 0;\n                    }\n                }\n                // Set the initial x-value as being the best result so far\n                localOffset += (isHorizontal ? node.height : node.width) / 2.0;\n                this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);\n                this.setTempVariable(node, rankValue, localOffset);\n                localOffset += ((isHorizontal ? node.height : node.width) / 2.0) + plalementChange.horizontalSpacing;\n                if (localOffset > plalementChange.widestRankValue) {\n                    plalementChange.widestRankValue = localOffset;\n                    plalementChange.widestRank = rankValue;\n                }\n                plalementChange.rankSizes[parseInt(rankValue.toString(), 10)] = localOffset;\n            }\n            plalementChange.rankOffset[parseInt(rankValue.toString(), 10)] = offset;\n            var distanceToNextRank = maxCellSize / 2.0 + lastRankMaxCellSize / 2.0 + plalementChange.verticalSpacing;\n            lastRankMaxCellSize = maxCellSize;\n            if (plalementChange.orientation === 'north' || plalementChange.orientation === 'west') {\n                offset += distanceToNextRank;\n            }\n            else {\n                offset -= distanceToNextRank;\n            }\n            for (var i = 0; i < rank.length; i++) {\n                var cell = rank[parseInt(i.toString(), 10)];\n                this.setXY(cell, rankValue, offset, isHorizontal ? false : true);\n            }\n        }\n    };\n    /**\n     * Sets the temp position of the node on the layer \\\n     *\n     * @returns {  void }  Sets the temp position of the node on the layer \\\n     * @param {IVertex} node - provide the nodes value.\n     * @param {number} layer - provide the layer value.\n     * @param {number} value - provide the value value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.setTempVariable = function (node, layer, value) {\n        if (this.crossReduction.isVertex(node)) {\n            node.temp[0] = value;\n        }\n        else {\n            node.temp[layer - node.minRank - 1] = value;\n        }\n    };\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * setXY method \\\n     *\n     * @returns { void }     setXY method .\\\n     * @param {IVertex} node - provide the source value.\n     * @param {number} layer - provide the target value.\n     * @param {number} value - provide the layoutOrientation value.\n     * @param {boolean} isY - provide the layoutOrientation value.\n     * @param {IVertex[][]} ranks - provide the layoutOrientation value.\n     * @param {number} spacing - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.setXY = function (node, layer, value, isY, ranks, spacing) {\n        if (node && node.cell) {\n            if (node.cell.inEdges.length > 0 || node.cell.outEdges.length > 0) {\n                if (isY) {\n                    node.y[0] = value;\n                }\n                else {\n                    node.x[0] = value;\n                }\n            }\n            else {\n                if (isY) {\n                    node.y[layer - node.minRank - 1] = value;\n                }\n                else {\n                    node.x[layer - node.minRank - 1] = value;\n                }\n            }\n        }\n        else {\n            this.setEdgeXY(ranks, node, spacing, layer);\n        }\n    };\n    //Sets geometry position of the layout node on the layout model\n    HierarchicalLayoutUtil.prototype.rankCoordinates = function (stage, rankValue, graph, model) {\n        var isHorizontal = false;\n        if (stage.model.layout.orientation === 'LeftToRight' || stage.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        var rank = model.ranks[parseInt(rankValue.toString(), 10)];\n        var maxOffset = 0.0;\n        var localOffset = (isHorizontal ? stage.marginY : stage.marginX)\n            + (stage.widestRankValue - stage.rankSizes[parseInt(rankValue.toString(), 10)]) / 2;\n        for (var i = 0; i < rank.length; i++) {\n            var node = rank[parseInt(i.toString(), 10)];\n            if (this.crossReduction.isVertex(node)) {\n                var obj = this.nameTable[node.cell.name];\n                node.width = obj.actualSize.width;\n                node.height = obj.actualSize.height;\n                maxOffset = Math.max(maxOffset, node.height);\n            }\n            else {\n                var edge = node;\n                var numEdges = 1;\n                if (edge.edges != null) {\n                    numEdges = edge.edges.length;\n                }\n                if (isHorizontal) {\n                    node.height = (numEdges - 1) * 10;\n                }\n                else {\n                    node.width = (numEdges - 1) * 10;\n                }\n            }\n            var size = (isHorizontal ? node.height : node.width) / 2.0;\n            localOffset += size;\n            this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);\n            this.setTempVariable(node, rankValue, localOffset);\n            localOffset += (size + stage.horizontalSpacing);\n        }\n    };\n    //sets the layout in an initial positioning.it will arange all the ranks as much as possible\n    HierarchicalLayoutUtil.prototype.initialCoords = function (plalementChange, facade, model) {\n        this.calculateWidestRank(plalementChange, facade, model);\n        // Reverse sweep direction each time from widest rank\n        for (var i = plalementChange.widestRank; i >= 0; i--) {\n            if (i < model.maxRank) {\n                this.rankCoordinates(plalementChange, i, facade, model);\n            }\n        }\n        for (var i = plalementChange.widestRank + 1; i <= model.maxRank; i++) {\n            if (i > 0) {\n                this.rankCoordinates(plalementChange, i, facade, model);\n            }\n        }\n    };\n    /**\n     *  Checks whether the given node is an ancestor \\\n     *\n     * @returns {  boolean }  Checks whether the given node is an ancestor \\\n     * @param {IVertex} node - provide the nodes value.\n     * @param {IVertex} otherNode - provide the layer value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.isAncestor = function (node, otherNode) {\n        // Firstly, the hash code of this node needs to be shorter than the other node\n        if (otherNode != null && node.hashCode != null && otherNode.hashCode != null\n            && node.hashCode.length < otherNode.hashCode.length) {\n            if (node.hashCode === otherNode.hashCode) {\n                return true;\n            }\n            if (node.hashCode == null || node.hashCode == null) {\n                return false;\n            }\n            for (var i = 0; i < node.hashCode.length; i++) {\n                if (node.hashCode[parseInt(i.toString(), 10)] !== otherNode.hashCode[parseInt(i.toString(), 10)]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    //initializes the sorter object\n    HierarchicalLayoutUtil.prototype.weightedCellSorter = function (cell, weightedValue) {\n        var weightedCellSorter = {};\n        weightedCellSorter.cell = cell ? cell : null;\n        weightedCellSorter.weightedValue = weightedValue ? weightedValue : 0;\n        weightedCellSorter.visited = false;\n        weightedCellSorter.rankIndex = null;\n        return weightedCellSorter;\n    };\n    //Performs one node positioning in both directions\n    HierarchicalLayoutUtil.prototype.minNode = function (plalementChange, model) {\n        var nodeList = [];\n        var map = { map: {} };\n        var rank = [];\n        for (var i = 0; i <= model.maxRank; i++) {\n            rank[parseInt(i.toString(), 10)] = model.ranks[parseInt(i.toString(), 10)];\n            for (var j = 0; j < rank[parseInt(i.toString(), 10)].length; j++) {\n                var node = rank[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)];\n                var nodeWrapper = this.weightedCellSorter(node, i);\n                nodeWrapper.rankIndex = j;\n                nodeWrapper.visited = true;\n                nodeList.push(nodeWrapper);\n                model.setDictionaryForSorter(map, node, nodeWrapper, true);\n            }\n        }\n        var maxTries = nodeList.length * 10;\n        var count = 0;\n        var tolerance = 1;\n        while (nodeList.length > 0 && count <= maxTries) {\n            var cellWrapper = nodeList.shift();\n            var cell = cellWrapper.cell;\n            var rankValue = cellWrapper.weightedValue;\n            var rankIndex = cellWrapper.rankIndex;\n            var nextLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue);\n            var previousLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue, true);\n            var nextConnectedCount = nextLayerConnectedCells ? nextLayerConnectedCells.length : 0;\n            var prevConnectedCount = previousLayerConnectedCells ? previousLayerConnectedCells.length : 0;\n            var medianNextLevel = this.medianXValue(plalementChange, nextLayerConnectedCells, rankValue + 1);\n            var medianPreviousLevel = this.medianXValue(plalementChange, previousLayerConnectedCells, rankValue - 1);\n            var numConnectedNeighbours = nextConnectedCount + prevConnectedCount;\n            var currentPosition = this.crossReduction.getTempVariable(cell, rankValue);\n            var cellMedian = currentPosition;\n            if (numConnectedNeighbours > 0) {\n                cellMedian = (medianNextLevel * nextConnectedCount + medianPreviousLevel * prevConnectedCount) / numConnectedNeighbours;\n            }\n            if (nextConnectedCount === 1 && prevConnectedCount === 1) {\n                cellMedian = (medianPreviousLevel * prevConnectedCount) / prevConnectedCount;\n            }\n            else if (nextConnectedCount === 1) {\n                cellMedian = (medianNextLevel * nextConnectedCount) / nextConnectedCount;\n            }\n            var positionChanged = false;\n            var tempValue = undefined;\n            if (cellMedian < currentPosition - tolerance) {\n                if (rankIndex === 0) {\n                    tempValue = cellMedian;\n                    positionChanged = true;\n                }\n                else {\n                    var leftCell = rank[parseInt(rankValue.toString(), 10)][rankIndex - 1];\n                    var leftLimit = this.crossReduction.getTempVariable(leftCell, rankValue);\n                    leftLimit = leftLimit + leftCell.width / 2 + plalementChange.intraCellSpacing + cell.width / 2;\n                    if (leftLimit < cellMedian) {\n                        tempValue = cellMedian;\n                        positionChanged = true;\n                    }\n                    else if (leftLimit < this.crossReduction.getTempVariable(cell, rankValue) - tolerance) {\n                        tempValue = leftLimit;\n                        positionChanged = true;\n                    }\n                }\n            }\n            else if (cellMedian > currentPosition + tolerance) {\n                var rankSize = rank[parseInt(rankValue.toString(), 10)].length;\n                if (rankIndex === rankSize - 1) {\n                    tempValue = cellMedian;\n                    positionChanged = true;\n                }\n                else {\n                    var rightCell = rank[parseInt(rankValue.toString(), 10)][rankIndex + 1];\n                    var rightLimit = this.crossReduction.getTempVariable(rightCell, rankValue);\n                    rightLimit = rightLimit - rightCell.width / 2 - plalementChange.intraCellSpacing - cell.width / 2;\n                    if (rightLimit > cellMedian) {\n                        tempValue = cellMedian;\n                        positionChanged = true;\n                    }\n                    else if (rightLimit > this.crossReduction.getTempVariable(cell, rankValue) + tolerance) {\n                        tempValue = rightLimit;\n                        positionChanged = true;\n                    }\n                }\n            }\n            if (positionChanged) {\n                this.setTempVariable(cell, rankValue, tempValue);\n                // Add connected nodes to map and list\n                this.updateNodeList(nodeList, map, nextLayerConnectedCells, model);\n                this.updateNodeList(nodeList, map, previousLayerConnectedCells, model);\n            }\n            if (this.crossReduction.isVertex(cellWrapper.cell)) {\n                cellWrapper.visited = false;\n            }\n            count++;\n        }\n    };\n    //Updates the ndoes collection\n    HierarchicalLayoutUtil.prototype.updateNodeList = function (nodeList, map, collection, model) {\n        for (var i = 0; i < collection.length; i++) {\n            var connectedCell = collection[parseInt(i.toString(), 10)];\n            var connectedCellWrapper = model.getDictionaryForSorter(map, connectedCell);\n            if (connectedCellWrapper != null) {\n                if (connectedCellWrapper.visited === false) {\n                    connectedCellWrapper.visited = true;\n                    nodeList.push(connectedCellWrapper);\n                }\n            }\n        }\n    };\n    //Calculates the node position of the connected cell on the specified rank\n    HierarchicalLayoutUtil.prototype.medianXValue = function (plalementChange, connectedCells, rankValue) {\n        if (!connectedCells || connectedCells.length === 0) {\n            return 0;\n        }\n        var medianValues = [];\n        for (var i = 0; i < connectedCells.length; i++) {\n            medianValues[parseInt(i.toString(), 10)]\n                = this.crossReduction.getTempVariable(connectedCells[parseInt(i.toString(), 10)], rankValue);\n        }\n        medianValues.sort(function (a, b) {\n            return a - b;\n        });\n        if (connectedCells.length % 2 === 1) {\n            return medianValues[Math.floor(connectedCells.length / 2)];\n        }\n        else {\n            var medianPoint = connectedCells.length / 2;\n            var leftMedian = medianValues[medianPoint - 1];\n            var rightMedian = medianValues[parseInt(medianPoint.toString(), 10)];\n            return ((leftMedian + rightMedian) / 2);\n        }\n    };\n    //Updates the geometry of the vertices\n    HierarchicalLayoutUtil.prototype.placementStageExecute = function (plalementChange) {\n        var isHorizontal = false;\n        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        plalementChange.jettyPositions = {};\n        var model = plalementChange.model;\n        // eslint-disable-next-line\n        isHorizontal ? plalementChange.currentYDelta = 0.0 : plalementChange.currentXDelta = 0.0;\n        this.initialCoords(plalementChange, { model: model }, model);\n        this.minNode(plalementChange, model);\n        var bestOffsetDelta = 100000000.0;\n        if (!plalementChange.maxIterations) {\n            plalementChange.maxIterations = 8;\n        }\n        for (var i = 0; i < plalementChange.maxIterations; i++) {\n            // if the total offset is less for the current positioning,\n            //there are less heavily angled edges and so the current positioning is used\n            if ((isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta) < bestOffsetDelta) {\n                for (var j = 0; j < model.ranks.length; j++) {\n                    var rank = model.ranks[parseInt(j.toString(), 10)];\n                    for (var k = 0; k < rank.length; k++) {\n                        var cell = rank[parseInt(k.toString(), 10)];\n                        this.setXY(cell, j, this.crossReduction.getTempVariable(cell, j), isHorizontal ? true : false);\n                    }\n                }\n                bestOffsetDelta = isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta;\n            }\n            // eslint-disable-next-line\n            isHorizontal ? plalementChange.currentYDelta = 0 : plalementChange.currentXDelta = 0;\n        }\n        this.setCellLocations(plalementChange, model);\n    };\n    //sets the cell position in the after the layout operation\n    HierarchicalLayoutUtil.prototype.setCellLocations = function (plalementChange, model) {\n        var vertices = this.getValues(model.vertexMapper);\n        for (var i = 0; i < vertices.length; i++) {\n            this.setVertexLocation(plalementChange, vertices[parseInt(i.toString(), 10)]);\n        }\n    };\n    //used to specify the geometrical position of the layout model cell\n    HierarchicalLayoutUtil.prototype.garphModelsetVertexLocation = function (plalementChange, cell, x, y) {\n        //let model: MultiParentModel = plalementChange.model;\n        var geometry = cell.geometry;\n        var result = null;\n        if (geometry != null) {\n            result = { x: x, y: y, width: geometry.width, height: geometry.height };\n            if (geometry.x !== x || geometry.y !== y) {\n                cell.geometry = result;\n            }\n        }\n        return result;\n    };\n    //set the position of the specified node\n    HierarchicalLayoutUtil.prototype.setVertexLocation = function (plalementChange, cell) {\n        var isHorizontal = false;\n        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        var realCell = cell.cell;\n        var positionX = cell.x[0] - cell.width / 2;\n        var positionY = cell.y[0] - cell.height / 2;\n        this.garphModelsetVertexLocation(plalementChange, realCell, positionX, positionY);\n        if (isHorizontal) {\n            if (!plalementChange.marginY) {\n                plalementChange.marginY = 0;\n            }\n            plalementChange.marginY = Math.max(plalementChange.marginY, positionY + cell.height);\n        }\n        else {\n            if (!plalementChange.marginX) {\n                plalementChange.marginX = 0;\n            }\n            plalementChange.marginX = Math.max(plalementChange.marginX, positionX + cell.width);\n        }\n    };\n    /**\n     *  get the specific value from the key value pair \\\n     *\n     * @returns {  {}[] }  get the specific value from the key value pair \\\n     * @param {VertexMapper} mapper - provide the mapper value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getValues = function (mapper) {\n        var list = [];\n        if (mapper.map) {\n            for (var _i = 0, _a = Object.keys(mapper.map); _i < _a.length; _i++) {\n                var key = _a[_i];\n                list.push(mapper.map[\"\" + key]);\n            }\n        }\n        return list;\n    };\n    /**\n     *Checks and reduces the crosses in between line segments \\\n     *\n     * @returns { void }    Checks and reduces the crosses in between line segments.\\\n     * @param {End} model - provide the model value.\n     *\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.crossingStage = function (model) {\n        this.crossReduction.execute(model);\n    };\n    //Initializes the ranks of the vertices\n    HierarchicalLayoutUtil.prototype.layeringStage = function (model) {\n        this.initialRank(model);\n        this.fixRanks(model);\n    };\n    //determine the initial rank for the each vertex on the relevent direction\n    HierarchicalLayoutUtil.prototype.initialRank = function (model) {\n        var startNodes = model.startNodes;\n        var internalNodes = model.getDictionaryValues(model.vertexMapper);\n        var startNodesCopy = startNodes.slice();\n        while (startNodes.length > 0) {\n            var internalNode = startNodes[0];\n            var layerDeterminingEdges = internalNode.connectsAsTarget;\n            var edgesToBeMarked = internalNode.connectsAsSource;\n            var allEdgesScanned = true;\n            var minimumLayer = 100000000;\n            for (var i = 0; i < layerDeterminingEdges.length; i++) {\n                var internalEdge = layerDeterminingEdges[parseInt(i.toString(), 10)];\n                if (internalEdge.temp[0] === 5270620) {\n                    // This edge has been scanned, get the layer of the node on the other end\n                    var otherNode = internalEdge.source;\n                    minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n                }\n                else {\n                    allEdgesScanned = false;\n                    break;\n                }\n            }\n            // If all edge have been scanned, assign the layer, mark all edges in the other direction and remove from the nodes list\n            if (allEdgesScanned) {\n                internalNode.temp[0] = minimumLayer;\n                if (!model.maxRank) {\n                    model.maxRank = 100000000;\n                }\n                model.maxRank = Math.min(model.maxRank, minimumLayer);\n                if (edgesToBeMarked != null) {\n                    for (var i = 0; i < edgesToBeMarked.length; i++) {\n                        var internalEdge = edgesToBeMarked[parseInt(i.toString(), 10)];\n                        internalEdge.temp[0] = 5270620;\n                        // Add node on other end of edge to LinkedList of nodes to be analysed\n                        var otherNode = internalEdge.target;\n                        // Only add node if it hasn't been assigned a layer\n                        if (otherNode.temp[0] === -1) {\n                            startNodes.push(otherNode);\n                            // Mark this other node as neither being unassigned nor assigned\n                            //so it isn't added to this list again, but it's layer isn't used in any calculation.\n                            otherNode.temp[0] = -2;\n                        }\n                    }\n                }\n                startNodes.shift();\n            }\n            else {\n                // Not all the edges have been scanned, get to the back of the class and put the dunces cap on\n                var removedCell = startNodes.shift();\n                startNodes.push(internalNode);\n                if (removedCell === internalNode && startNodes.length === 1) {\n                    // This is an error condition, we can't get out of this loop.\n                    //It could happen for more than one node but that's a lot harder to detect. Log the error\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < internalNodes.length; i++) {\n            internalNodes[parseInt(i.toString(), 10)].temp[0] -= model.maxRank;\n        }\n        for (var i = 0; i < startNodesCopy.length; i++) {\n            var internalNode = startNodesCopy[parseInt(i.toString(), 10)];\n            var currentMaxLayer = 0;\n            var layerDeterminingEdges = internalNode.connectsAsSource;\n            for (var j = 0; j < layerDeterminingEdges.length; j++) {\n                var internalEdge = layerDeterminingEdges[parseInt(j.toString(), 10)];\n                var otherNode = internalEdge.target;\n                internalNode.temp[0] = Math.max(currentMaxLayer, otherNode.temp[0] + 1);\n                currentMaxLayer = internalNode.temp[0];\n            }\n        }\n        model.maxRank = 100000000 - model.maxRank;\n    };\n    //used to set the optimum value of each vertex on the layout\n    HierarchicalLayoutUtil.prototype.fixRanks = function (model) {\n        model.fixRanks();\n    };\n    //used to determine any cyclic stage have been created on the layout model\n    HierarchicalLayoutUtil.prototype.cycleStage = function (model) {\n        var seenNodes = {};\n        model.startNodes = [];\n        var unseenNodesArray = model.getDictionaryValues(model.vertexMapper);\n        var unseenNodes = [];\n        for (var i = 0; i < unseenNodesArray.length; i++) {\n            unseenNodesArray[parseInt(i.toString(), 10)].temp[0] = -1;\n            unseenNodes[unseenNodesArray[parseInt(i.toString(), 10)].id] = unseenNodesArray[parseInt(i.toString(), 10)];\n        }\n        var rootsArray = null;\n        if (model.roots != null) {\n            var modelRoots = model.roots;\n            rootsArray = [];\n            for (var i = 0; i < modelRoots.length; i++) {\n                rootsArray[parseInt(i.toString(), 10)] = model.getDictionary(model.vertexMapper, modelRoots[parseInt(i.toString(), 10)]);\n                if (rootsArray[parseInt(i.toString(), 10)] != null) {\n                    model.startNodes.push(rootsArray[parseInt(i.toString(), 10)]);\n                }\n            }\n        }\n        model.visit('removeParentConnection', rootsArray, true, null, { seenNodes: seenNodes, unseenNodes: unseenNodes });\n        var seenNodesCopy = model.clone(seenNodes, null, true);\n        model.visit('removeNodeConnection', unseenNodes, true, seenNodesCopy, { seenNodes: seenNodes, unseenNodes: unseenNodes });\n    };\n    /**\n     * removes the edge from the given collection \\\n     *\n     * @returns {  IEdge }    removes the edge from the given collection .\\\n     * @param {IEdge} obj - provide the angle value.\n     * @param { IEdge[]} array - provide the angle value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.remove = function (obj, array) {\n        var index = array.indexOf(obj);\n        if (index !== -1) {\n            array.splice(index, 1);\n        }\n        return obj;\n    };\n    /**\n     * Inverts the source and target of an edge \\\n     *\n     * @returns {  void }    Inverts the source and target of an edge .\\\n     * @param {IEdge} connectingEdge - provide the angle value.\n     * @param { number} layer - provide the angle value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.invert = function (connectingEdge, layer) {\n        var temp = connectingEdge.source;\n        connectingEdge.source = connectingEdge.target;\n        connectingEdge.target = temp;\n        connectingEdge.isReversed = !connectingEdge.isReversed;\n    };\n    /**\n     * used to get the edges between the given source and target  \\\n     *\n     * @returns {  IConnector[] }    used to get the edges between the given source and target  .\\\n     * @param {Vertex} source - provide the angle value.\n     * @param { Vertex} target - provide the angle value.\n     * @param { boolean} directed - provide the angle value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getEdgesBetween = function (source, target, directed) {\n        var edges = this.getEdges(source);\n        var result = [];\n        for (var i = 0; i < edges.length; i++) {\n            var src = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], true);\n            var trg = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], false);\n            if ((src === source && trg === target) || (!directed && src === target && trg === source)) {\n                result.push(edges[parseInt(i.toString(), 10)]);\n            }\n        }\n        return result;\n    };\n    return HierarchicalLayoutUtil;\n}());\n/**\n * Handles position the objects in a hierarchical tree structure\n */\nvar MultiParentModel = /** @class */ (function () {\n    function MultiParentModel(layout, vertices, roots, dlayout) {\n        this.multiObjectIdentityCounter = 0;\n        //used to count the no of times the parent have been used\n        this.dfsCount = 0;\n        this.hierarchicalUtil = new HierarchicalLayoutUtil();\n        this.roots = roots;\n        this.vertexMapper = { map: {} };\n        var internalVertices = [];\n        this.layout = dlayout;\n        this.maxRank = 100000000;\n        this.edgeMapper = { map: {} };\n        this.hierarchicalLayout = layout;\n        this.createInternalCells(layout, vertices, internalVertices, dlayout);\n        for (var i = 0; i < vertices.length; i++) {\n            var edges = internalVertices[parseInt(i.toString(), 10)].connectsAsSource;\n            for (var j = 0; j < edges.length; j++) {\n                var internalEdge = edges[parseInt(j.toString(), 10)];\n                var realEdges = internalEdge.edges;\n                if (realEdges != null && realEdges.length > 0) {\n                    var realEdge = realEdges[0];\n                    var targetCell = layout.getVisibleTerminal(realEdge, false);\n                    var internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);\n                    if (internalVertices[parseInt(i.toString(), 10)] === internalTargetCell) {\n                        targetCell = layout.getVisibleTerminal(realEdge, true);\n                        internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);\n                    }\n                    if (internalTargetCell != null && internalVertices[parseInt(i.toString(), 10)] !== internalTargetCell) {\n                        internalEdge.target = internalTargetCell;\n                        if (internalTargetCell.connectsAsTarget.length === 0) {\n                            internalTargetCell.connectsAsTarget = [];\n                        }\n                        if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {\n                            internalTargetCell.connectsAsTarget.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            internalVertices[parseInt(i.toString(), 10)].temp[0] = 1;\n        }\n    }\n    /* tslint:disable */\n    MultiParentModel.prototype.resetEdge = function (edge) {\n        var geometry = { x: 0, y: 0, width: 0, height: 0, relative: true };\n        var geo = geometry;\n        edge['geometry'] = geo;\n        return edge;\n    };\n    // eslint-disable-next-line max-len\n    MultiParentModel.prototype.createInternalCells = function (layout, vertices, internalVertices, dlayout) {\n        for (var i = 0; i < vertices.length; i++) {\n            internalVertices[parseInt(i.toString(), 10)] = {\n                x: [], y: [], temp: [], cell: vertices[parseInt(i.toString(), 10)],\n                id: vertices[parseInt(i.toString(), 10)].name, connectsAsTarget: [], connectsAsSource: [], type: 'internalVertex'\n            };\n            this.setDictionary(this.vertexMapper, vertices[parseInt(i.toString(), 10)], internalVertices[parseInt(i.toString(), 10)]);\n            var conns = layout.getEdges(vertices[parseInt(i.toString(), 10)]);\n            internalVertices[parseInt(i.toString(), 10)].connectsAsSource = [];\n            for (var j = 0; j < conns.length; j++) {\n                var cell = layout.getVisibleTerminal(conns[parseInt(j.toString(), 10)], false);\n                if (cell !== vertices[parseInt(i.toString(), 10)]) {\n                    var undirectedEdges = layout.getEdgesBetween(vertices[parseInt(i.toString(), 10)], cell, false);\n                    var directedEdges = layout.getEdgesBetween(vertices[parseInt(i.toString(), 10)], cell, true);\n                    if (undirectedEdges != null && undirectedEdges.length > 0 && directedEdges.length * 2 >= undirectedEdges.length) {\n                        var internalEdge = { x: [], y: [], temp: [], edges: undirectedEdges, ids: [] };\n                        if (dlayout.enableLayoutRouting) {\n                            for (var k = 0; k < undirectedEdges.length; k++) {\n                                var edge = undirectedEdges[parseInt(k.toString(), 10)];\n                                this.setDictionary(this.edgeMapper, undefined, internalEdge, edge.id);\n                                // Resets all point on the edge and disables the edge style\n                                // without deleting it from the cell style\n                                this.resetEdge(edge);\n                            }\n                        }\n                        internalEdge.source = internalVertices[parseInt(i.toString(), 10)];\n                        for (var m = 0; m < undirectedEdges.length; m++) {\n                            internalEdge.ids.push(undirectedEdges[parseInt(m.toString(), 10)].id);\n                        }\n                        internalEdge.source = internalVertices[parseInt(i.toString(), 10)];\n                        if (!internalVertices[parseInt(i.toString(), 10)].connectsAsSource) {\n                            internalVertices[parseInt(i.toString(), 10)].connectsAsSource = [];\n                        }\n                        if (internalVertices[parseInt(i.toString(), 10)].connectsAsSource.indexOf(internalEdge) < 0) {\n                            internalVertices[parseInt(i.toString(), 10)].connectsAsSource.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            internalVertices[parseInt(i.toString(), 10)].temp[0] = 0;\n        }\n    };\n    /* tslint:enable */\n    /**\n     * used to set the optimum value of each vertex on the layout \\\n     *\n     * @returns {  void }   used to set the optimum value of each vertex on the layout .\\\n     * @private\n     */\n    MultiParentModel.prototype.fixRanks = function () {\n        var rankList = [];\n        this.ranks = [];\n        for (var i = 0; i < this.maxRank + 1; i++) {\n            rankList[parseInt(i.toString(), 10)] = [];\n            this.ranks[parseInt(i.toString(), 10)] = rankList[parseInt(i.toString(), 10)];\n        }\n        var rootsArray = null;\n        if (this.roots != null) {\n            var oldRootsArray = this.roots;\n            rootsArray = [];\n            for (var i = 0; i < oldRootsArray.length; i++) {\n                var cell = oldRootsArray[parseInt(i.toString(), 10)];\n                var internalNode = this.getDictionary(this.vertexMapper, cell);\n                rootsArray[parseInt(i.toString(), 10)] = internalNode;\n            }\n        }\n        this.visit('updateMinMaxRank', rootsArray, false, null, { seenNodes: null, unseenNodes: null, rankList: rankList });\n    };\n    //Updates the min/max rank of the layer\n    MultiParentModel.prototype.updateMinMaxRank = function (layer, seen, data) {\n        //let seenNodes: {} = data.seenNodes;\n        //let unseenNodes: {} = data.unseenNodes;\n        var parent = data.parent;\n        var node = data.root;\n        var edge = data.edge;\n        var rankList = data.rankList;\n        if (!node.maxRank && node.maxRank !== 0) {\n            node.maxRank = -1;\n        }\n        if (!node.minRank && node.minRank !== 0) {\n            node.minRank = -1;\n        }\n        if (seen === 0 && node.maxRank < 0 && node.minRank < 0) {\n            rankList[node.temp[0]].push(node);\n            node.maxRank = node.temp[0];\n            node.minRank = node.temp[0];\n            node.temp[0] = rankList[node.maxRank].length - 1;\n        }\n        if (parent != null && edge != null) {\n            var parentToCellRankDifference = parent.maxRank - node.maxRank;\n            if (parentToCellRankDifference > 1) {\n                edge.maxRank = parent.maxRank;\n                edge.minRank = node.maxRank;\n                edge.temp = [];\n                edge.x = [];\n                edge.y = [];\n                for (var i = edge.minRank + 1; i < edge.maxRank; i++) {\n                    rankList[parseInt(i.toString(), 10)].push(edge);\n                    this.hierarchicalUtil.setTempVariable(edge, i, rankList[parseInt(i.toString(), 10)].length - 1);\n                }\n            }\n        }\n    };\n    //used to store the value of th given key on the object\n    MultiParentModel.prototype.setDictionary = function (dic, key, value, edgeId) {\n        if (!edgeId) {\n            var id = key.name;\n            var previous = dic.map[\"\" + id];\n            dic.map[\"\" + id] = value;\n            return previous;\n        }\n        else {\n            var previous = dic.map[\"\" + edgeId];\n            dic.map[\"\" + edgeId] = value;\n            return previous;\n        }\n    };\n    /**\n     * used to store the value of th given key on the objectt \\\n     *\n     * @returns {  IVertex }   used to store the value of th given key on the object .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @param {IVertex} key - provide the angle value.\n     * @param {WeightedCellSorter} value - provide the angle value.\n     * @param {boolean} flag - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.setDictionaryForSorter = function (dic, key, value, flag) {\n        var id = key.id;\n        if (!id) {\n            //id = this._getDictionaryForSorter(dic, key);\n        }\n        var previous = dic.map[\"\" + id];\n        dic.map[\"\" + id] = value;\n        return previous;\n    };\n    /**\n     * used to get the value of the given key \\\n     *\n     * @returns {  IVertex }  used to get the value of the given key .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @param {IVertex} key - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.getDictionary = function (dic, key) {\n        if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {\n            this.multiObjectIdentityCounter = 0;\n        }\n        var id = key.name;\n        if (!id) {\n            if (!key.layoutObjectId) { ///####\n                key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;\n                return key.layoutObjectId;\n            }\n            else {\n                return dic.map[key.layoutObjectId];\n            }\n        }\n        return dic.map[\"\" + id];\n    };\n    /**\n     * used to get the value of the given key \\\n     *\n     * @returns {  IVertex }  used to get the value of the given key .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @param {IVertex} key - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.getDictionaryForSorter = function (dic, key) {\n        if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {\n            this.multiObjectIdentityCounter = 0;\n        }\n        var id = key.id;\n        if (!id) {\n            if (!key.layoutObjectId) { ///####\n                key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;\n                return key.layoutObjectId;\n            }\n            else {\n                return dic.map[key.layoutObjectId];\n            }\n        }\n        return dic.map[\"\" + id];\n    };\n    /**\n     * used to get all the values of the dictionary object \\\n     *\n     * @returns {  IVertex[] }  used to get all the values of the dictionary object .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.getDictionaryValues = function (dic) {\n        var result = [];\n        for (var _i = 0, _a = Object.keys(dic.map); _i < _a.length; _i++) {\n            var key = _a[_i];\n            result.push(dic.map[\"\" + key]);\n        }\n        return result;\n    };\n    /**\n     * used to visit all the entries on the given dictionary with given function \\\n     *\n     * @returns { void }  used to visit all the entries on the given dictionary with given function .\\\n     * @param {string} visitor - provide the visitor value.\n     * @param {IVertex[]} dfsRoots - provide the dfsRoots value.\n     * @param {boolean} trackAncestors - provide the trackAncestors value.\n     * @param {{}} seenNodes - provide the seenNodes value.\n     * @param {TraverseData} data - provide the data value.\n     * @private\n     */\n    MultiParentModel.prototype.visit = function (visitor, dfsRoots, trackAncestors, seenNodes, data) {\n        //let seenNodes1: {} = data.seenNodes;\n        //let unseenNodes1: {} = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        // Run depth first search through on all roots\n        if (dfsRoots != null) {\n            for (var i = 0; i < dfsRoots.length; i++) {\n                var internalNode = dfsRoots[parseInt(i.toString(), 10)];\n                if (internalNode != null) {\n                    if (seenNodes == null) {\n                        seenNodes = new Object();\n                    }\n                    data.parent = null;\n                    data.root = internalNode;\n                    data.edge = null;\n                    if (trackAncestors) {\n                        // Set up hash code for root\n                        internalNode.hashCode = [];\n                        internalNode.hashCode[0] = this.dfsCount;\n                        internalNode.hashCode[1] = i;\n                        this.extendedDfs(visitor, seenNodes, i, 0, data);\n                    }\n                    else {\n                        this.depthFirstSearch(visitor, seenNodes, 0, data);\n                    }\n                }\n            }\n            this.dfsCount++;\n        }\n    };\n    //used to perform the depth fisrt search on the layout model\n    MultiParentModel.prototype.depthFirstSearch = function (visitor, seen, layer, data) {\n        //let seenNodes1: {} = data.seenNodes;\n        //let unseenNodes1: {} = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        //let parent: IVertex = data.parent;\n        var root = data.root;\n        //let edge: IEdge = data.edge;\n        if (root != null) {\n            var rootId = root.id;\n            if (seen[\"\" + rootId] == null) {\n                seen[\"\" + rootId] = root;\n                this.updateConnectionRank(visitor, layer, 0, data);\n                // Copy the connects as source list so that visitors can change the original for edge direction inversions\n                var outgoingEdges = root.connectsAsSource.slice();\n                for (var i = 0; i < outgoingEdges.length; i++) {\n                    var internalEdge = outgoingEdges[parseInt(i.toString(), 10)];\n                    var targetNode = internalEdge.target;\n                    // Root check is O(|roots|)\n                    data.parent = root;\n                    data.root = targetNode;\n                    data.edge = internalEdge;\n                    this.depthFirstSearch(visitor, seen, layer + 1, data);\n                }\n            }\n            else {\n                this.updateConnectionRank(visitor, layer, 1, data);\n            }\n        }\n    };\n    //Updates the rank of the connection\n    MultiParentModel.prototype.updateConnectionRank = function (visitor, layer, seen, traversedList) {\n        var parent = traversedList.parent;\n        var root = traversedList.root;\n        var edge = traversedList.edge;\n        if (visitor === 'removeParentConnection' || visitor === 'removeNodeConnection') {\n            var remove = visitor === 'removeNodeConnection';\n            this.removeConnectionEdge(parent, root, edge, layer, traversedList, remove);\n        }\n        if (visitor === 'updateMinMaxRank') {\n            this.updateMinMaxRank(layer, seen, traversedList);\n        }\n    };\n    //Removes the edge from the collection\n    MultiParentModel.prototype.removeConnectionEdge = function (parent, node, edge, layer, data, remove) {\n        var seenNodes = data.seenNodes;\n        var unseenNodes = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        if (this.hierarchicalUtil.isAncestor(node, parent)) {\n            this.hierarchicalUtil.invert(edge, 0);\n            this.hierarchicalUtil.remove(edge, parent.connectsAsSource);\n            if (remove) {\n                node.connectsAsSource.push(edge);\n                parent.connectsAsTarget.push(edge);\n                this.hierarchicalUtil.remove(edge, node.connectsAsTarget);\n            }\n            else {\n                parent.connectsAsTarget.push(edge);\n                this.hierarchicalUtil.remove(edge, node.connectsAsTarget);\n                node.connectsAsSource.push(edge);\n            }\n        }\n        seenNodes[node.id] = node;\n        delete unseenNodes[node.id];\n    };\n    //the dfs extends the default version by keeping track of cells ancestors, but it should be only used when necessary\n    MultiParentModel.prototype.extendedDfs = function (visitor, seen, cHash, layer, data) {\n        //let seenNodes: {} = data.seenNodes;\n        //let unseenNodes: {} = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        var parent = data.parent;\n        var root = data.root;\n        var edge = data.edge;\n        if (root != null) {\n            if (parent != null) {\n                if (root.hashCode == null ||\n                    root.hashCode[0] !== parent.hashCode[0]) {\n                    var hashCodeLength = parent.hashCode.length + 1;\n                    root.hashCode = parent.hashCode.slice();\n                    root.hashCode[hashCodeLength - 1] = cHash;\n                }\n            }\n            var rootId = root.id;\n            if (seen[\"\" + rootId] == null) {\n                seen[\"\" + rootId] = root;\n                this.updateConnectionRank(visitor, layer, 0, data);\n                var outgoingEdges = root.connectsAsSource.slice();\n                for (var i = 0; i < outgoingEdges.length; i++) {\n                    var internalEdge = outgoingEdges[parseInt(i.toString(), 10)];\n                    var targetNode = internalEdge.target;\n                    data.parent = root;\n                    data.root = targetNode;\n                    data.edge = internalEdge;\n                    this.extendedDfs(visitor, seen, i, layer + 1, data);\n                }\n            }\n            else {\n                this.updateConnectionRank(visitor, layer, 1, data);\n            }\n        }\n    };\n    /**\n     * used to clone the specified object ignoring all fieldnames in the given array of transient fields \\\n     *\n     * @returns { void }    used to clone the specified object ignoring all fieldnames in the given array of transient fields .\\\n     * @param {Object} obj - provide the source value.\n     * @param {string[]} transients - provide the target value.\n     * @param {boolean} shallow - provide the shallow value.\n     *\n     * @private\n     */\n    MultiParentModel.prototype.clone = function (obj, transients, shallow) {\n        if (obj != null && typeof (obj.constructor) === 'function') {\n            var clonedObj = obj.constructor();\n            for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n                var i = _a[_i];\n                if (i !== 'layoutObjectId' && (transients == null || transients.indexOf(i) < 0)) {\n                    if (!shallow /*&& typeof (obj[`${i}`]) === 'object'*/) {\n                        //not used\n                        //  _clone[i] = $.extend(true, {}, obj[i]);\n                    }\n                    else {\n                        clonedObj[\"\" + i] = obj[\"\" + i];\n                    }\n                }\n            }\n            return clonedObj;\n        }\n        return null;\n    };\n    return MultiParentModel;\n}());\n/**\n * Defines how to reduce the crosses in between the line segments\n */\nvar CrossReduction = /** @class */ (function () {\n    function CrossReduction() {\n    }\n    /**\n     *  used to calculate the number of edges crossing the layout model \\\n     *\n     * @returns { number }  used to calculate the number of edges crossing the layout model\\\n     * @param {MultiParentModel} model - provide the model value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.calculateCrossings = function (model) {\n        var numRanks = model.ranks.length;\n        var totalCrossings = 0;\n        for (var i = 1; i < numRanks; i++) {\n            totalCrossings += this.calculateRankCrossing(i, model);\n        }\n        return totalCrossings;\n    };\n    /**\n     *  used to get the temp value specified for the node or connector. \\\n     *\n     * @returns { boolean }  used to get the temp value specified for the node or connector.\\\n     * @param {IVertex} node - provide the node value.\n     * @param {IVertex} layer - provide the layer value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.getTempVariable = function (node, layer) {\n        if (node) {\n            if (this.isVertex(node)) {\n                return node.temp[0];\n            }\n            else {\n                return node.temp[layer - node.minRank - 1];\n            }\n        }\n        return 0;\n    };\n    //used to specify the number of conenctors crossing between the specified rank and its below rank\n    CrossReduction.prototype.calculateRankCrossing = function (i, model) {\n        var totalCrossings = 0;\n        var rank = model.ranks[parseInt(i.toString(), 10)];\n        var previousRank = model.ranks[i - 1];\n        var tmpIndices = [];\n        // Iterate over the top rank and fill in the connection information\n        for (var j = 0; j < rank.length; j++) {\n            var node = rank[parseInt(j.toString(), 10)];\n            var rankPosition = this.getTempVariable(node, i);\n            var connectedCells = this.getConnectedCellsOnLayer(node, i, true);\n            ///####\n            var nodeIndices = [];\n            for (var k = 0; k < connectedCells.length; k++) {\n                var connectedNode = connectedCells[parseInt(k.toString(), 10)];\n                var otherCellRankPosition = this.getTempVariable(connectedNode, i - 1);\n                nodeIndices.push(otherCellRankPosition);\n            }\n            nodeIndices.sort(function (x, y) { return x - y; });\n            tmpIndices[parseInt(rankPosition.toString(), 10)] = nodeIndices;\n        }\n        var indices = [];\n        for (var j = 0; j < tmpIndices.length; j++) {\n            indices = indices.concat(tmpIndices[parseInt(j.toString(), 10)]);\n        }\n        var firstIndex = 1;\n        while (firstIndex < previousRank.length) {\n            firstIndex <<= 1;\n        }\n        var treeSize = 2 * firstIndex - 1;\n        firstIndex -= 1;\n        var tree = [];\n        for (var j = 0; j < treeSize; ++j) {\n            tree[parseInt(j.toString(), 10)] = 0;\n        }\n        for (var j = 0; j < indices.length; j++) {\n            var index = indices[parseInt(j.toString(), 10)];\n            var treeIndex = index + firstIndex;\n            ++tree[parseInt(treeIndex.toString(), 10)];\n            while (treeIndex > 0) {\n                if (treeIndex % 2) {\n                    totalCrossings += tree[treeIndex + 1];\n                }\n                treeIndex = (treeIndex - 1) >> 1;\n                ++tree[parseInt(treeIndex.toString(), 10)];\n            }\n        }\n        return totalCrossings;\n    };\n    /**\n     * Calculates and reduces the crosses between line segments\n     *\n     * @returns { void }Calculates and reduces the crosses between line segments.\\\n     * @param {MultiParentModel} model - provide the target value.\n     * @private\n     */\n    CrossReduction.prototype.execute = function (model) {\n        // Stores initial ordering\n        this.nestedBestRanks = [];\n        for (var i = 0; i < model.ranks.length; i++) {\n            this.nestedBestRanks[parseInt(i.toString(), 10)] = model.ranks[parseInt(i.toString(), 10)].slice();\n        }\n        var iterationsWithoutImprovement = 0;\n        var currentBestCrossings = this.calculateCrossings(model);\n        for (var i = 0; i < 24 && iterationsWithoutImprovement < 2; i++) {\n            this.weightedMedian(i, model);\n            var candidateCrossings = this.calculateCrossings(model);\n            if (candidateCrossings < currentBestCrossings) {\n                currentBestCrossings = candidateCrossings;\n                iterationsWithoutImprovement = 0;\n                for (var j = 0; j < this.nestedBestRanks.length; j++) {\n                    var rank = model.ranks[parseInt(j.toString(), 10)];\n                    for (var k = 0; k < rank.length; k++) {\n                        var cell = rank[parseInt(k.toString(), 10)];\n                        var obj = this.nestedBestRanks[parseInt(j.toString(), 10)][cell.temp[0]];\n                        var check = true;\n                        if (cell.edges && obj && !obj.edges) {\n                            check = false;\n                        }\n                        if (obj && check) {\n                            this.nestedBestRanks[parseInt(j.toString(), 10)][cell.temp[0]] = cell;\n                        }\n                    }\n                }\n            }\n            else {\n                // Increase count of iterations\n                iterationsWithoutImprovement++;\n                // Restore the best values to the cells\n                for (var j = 0; j < this.nestedBestRanks.length; j++) {\n                    var rank = model.ranks[parseInt(j.toString(), 10)];\n                    for (var k = 0; k < rank.length; k++) {\n                        var cell = rank[parseInt(k.toString(), 10)];\n                        this.setTempVariable(cell, j, k);\n                    }\n                }\n            }\n            if (currentBestCrossings === 0) {\n                break;\n            }\n        }\n        // Store the best rankings but in the model\n        var ranks = [];\n        var rankList = [];\n        for (var i = 0; i < model.maxRank + 1; i++) {\n            rankList[parseInt(i.toString(), 10)] = [];\n            ranks[parseInt(i.toString(), 10)] = rankList[parseInt(i.toString(), 10)];\n        }\n        for (var i = 0; i < this.nestedBestRanks.length; i++) {\n            for (var j = 0; j < this.nestedBestRanks[parseInt(i.toString(), 10)].length; j++) {\n                rankList[parseInt(i.toString(), 10)].push(this.nestedBestRanks[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)]);\n            }\n        }\n        model.ranks = ranks;\n    };\n    /**\n     *  check whether the object is vertext or edge on the layout model. \\\n     *\n     * @returns { boolean }  check whether the object is vertext or edge on the layout model..\\\n     * @param {IVertex} node - provide the iteration value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.isVertex = function (node) {\n        if (node && node.cell && ((node.cell.inEdges && node.cell.inEdges.length) || (node.cell.outEdges && node.cell.outEdges.length))) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     *  used to move up or move down the node position on the adjacent ranks \\\n     *\n     * @returns { void }  used to move up or move down the node position on the adjacent ranks.\\\n     * @param {number} iteration - provide the iteration value.\n     * @param {MultiParentModel} model - provide the model value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.weightedMedian = function (iteration, model) {\n        // Reverse sweep direction each time through this method\n        var downwardSweep = (iteration % 2 === 0);\n        if (downwardSweep) {\n            for (var j = model.maxRank - 1; j >= 0; j--) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n        else {\n            for (var j = 1; j < model.maxRank; j++) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n    };\n    /**\n     * used to get the node next(up) connected to the specified node or connector \\\n     *\n     * @returns { void } calculates the rank elements on the specified rank.\\\n     * @param {IVertex} cell - provide the cell value.\n     * @param {number} layer - provide the layer value.\n     * @param {boolean} isPrevious - provide the isPrevious value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.getConnectedCellsOnLayer = function (cell, layer, isPrevious) {\n        if (isPrevious === void 0) { isPrevious = false; }\n        var connectedlayer = 'nextLayerConnectedCells';\n        var connectedAs = 'connectsAsTarget';\n        if (isPrevious) {\n            connectedlayer = 'previousLayerConnectedCells';\n            connectedAs = 'connectsAsSource';\n        }\n        if (cell) {\n            if (this.isVertex(cell)) {\n                if (cell[\"\" + connectedlayer] == null) {\n                    cell[\"\" + connectedlayer] = [];\n                    cell[\"\" + connectedlayer][0] = [];\n                    for (var i = 0; i < cell[\"\" + connectedAs].length; i++) {\n                        var edge = cell[\"\" + connectedAs][parseInt(i.toString(), 10)];\n                        if (edge.maxRank === undefined) {\n                            edge.maxRank = -1;\n                        }\n                        if (edge.maxRank === -1 || (isPrevious ? (edge.minRank === layer - 1) : (edge.maxRank === layer + 1))) {\n                            // Either edge is not in any rank or no dummy nodes in edge, add node of other side of edge\n                            cell[\"\" + connectedlayer][0].push(isPrevious ? edge.target : edge.source);\n                        }\n                        else {\n                            // Edge spans at least two layers, add edge\n                            cell[\"\" + connectedlayer][0].push(edge);\n                        }\n                    }\n                }\n                return cell[\"\" + connectedlayer][0];\n            }\n            else {\n                if (cell[\"\" + connectedlayer] == null) {\n                    cell[\"\" + connectedlayer] = [];\n                    for (var i = 0; i < cell.temp.length; i++) {\n                        cell[\"\" + connectedlayer][parseInt(i.toString(), 10)] = [];\n                        if (i === (isPrevious ? 0 : (cell.temp.length - 1))) {\n                            cell[\"\" + connectedlayer][parseInt(i.toString(), 10)].push(isPrevious ? cell.target : cell.source);\n                        }\n                        else {\n                            cell[\"\" + connectedlayer][parseInt(i.toString(), 10)].push(cell);\n                        }\n                    }\n                }\n                return cell[\"\" + connectedlayer][layer - cell.minRank - 1];\n            }\n        }\n        return null;\n    };\n    /**\n     * calculates the rank elements on the specified rank \\\n     *\n     * @returns { void } calculates the rank elements on the specified rank.\\\n     * @param {IVertex[]} connectedCells - provide the cell value.\n     * @param {number} rankValue - provide the layer value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.medianValue = function (connectedCells, rankValue) {\n        var medianValues = [];\n        var arrayCount = 0;\n        for (var i = 0; i < connectedCells.length; i++) {\n            var cell = connectedCells[parseInt(i.toString(), 10)];\n            medianValues[arrayCount++] = this.getTempVariable(cell, rankValue);\n        }\n        // sorts numerical order sort\n        medianValues.sort(function (a, b) { return a - b; });\n        if (arrayCount % 2 === 1) {\n            // For odd numbers of adjacent vertices return the median\n            return medianValues[Math.floor(arrayCount / 2)];\n        }\n        else if (arrayCount === 2) {\n            return ((medianValues[0] + medianValues[1]) / 2.0);\n        }\n        else {\n            var medianPoint = arrayCount / 2;\n            var leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n            var rightMedian = medianValues[arrayCount - 1]\n                - medianValues[parseInt(medianPoint.toString(), 10)];\n            return (medianValues[medianPoint - 1] * rightMedian + medianValues[parseInt(medianPoint.toString(), 10)] * leftMedian)\n                / (leftMedian + rightMedian);\n        }\n    };\n    /**\n     * get the temp value of the specified layer \\\n     *\n     * @returns { void }     getDirection method .\\\n     * @param {IVertex} cell - provide the cell value.\n     * @param {layer} layer - provide the layer value.\n     * @param {LayoutOrientation} value - provide the value value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.setTempVariable = function (cell, layer, value) {\n        if (cell) {\n            cell.temp[0] = value;\n        }\n    };\n    /**\n     * used to minimize the node position on this rank and one of its adjacent ranks\n     */\n    CrossReduction.prototype.medianRank = function (rankValue, downwardSweep) {\n        var numCellsForRank = this.nestedBestRanks[parseInt(rankValue.toString(), 10)].length;\n        var medianValues = [];\n        var reservedPositions = [];\n        for (var i = 0; i < numCellsForRank; i++) {\n            var cell = this.nestedBestRanks[parseInt(rankValue.toString(), 10)][parseInt(i.toString(), 10)];\n            var sorterEntry = { medianValue: 0 };\n            sorterEntry.cell = cell;\n            // Flip whether or not equal medians are flipped on up and down sweeps\n            //TODO re-implement some kind of nudge medianValues[i].nudge = !downwardSweep;\n            var nextLevelConnectedCells = void 0;\n            if (downwardSweep) {\n                nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue);\n            }\n            else {\n                nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue, true);\n            }\n            var nextRankValue = void 0;\n            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n            downwardSweep ? nextRankValue = rankValue + 1 : nextRankValue = rankValue - 1;\n            if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {\n                sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);\n                medianValues.push(sorterEntry);\n            }\n            else {\n                // Nodes with no adjacent vertices are flagged in the reserved array to\n                //indicate they should be left in their current position.\n                reservedPositions[this.getTempVariable(cell, rankValue)] = true;\n            }\n        }\n        medianValues.sort(this.compare);\n        // Set the new position of each node within the rank using its temp variable\n        for (var i = 0; i < numCellsForRank; i++) {\n            if (reservedPositions[parseInt(i.toString(), 10)] == null && medianValues.length > 0) {\n                var cell = medianValues.shift().cell;\n                this.setTempVariable(cell, rankValue, i);\n            }\n        }\n    };\n    //compares two values, it sends the values to the compare function,\n    //and sorts the values according to the returned (negative, zero, positive) value\n    CrossReduction.prototype.compare = function (a, b) {\n        if (a != null && b != null) {\n            if (b.medianValue > a.medianValue) {\n                return -1;\n            }\n            else if (b.medianValue < a.medianValue) {\n                return 1;\n            }\n        }\n        return 0;\n    };\n    return CrossReduction;\n}());\nvar MatrixModel = /** @class */ (function () {\n    function MatrixModel() {\n        this.edgeMapper = [];\n    }\n    /* tslint:disable */\n    /** @private */\n    /**\n     * Arrange the elements\n     *\n     * @returns { void }  arrange the elements.\\\n     * @param {MatrixModelObject} matrixModel - provide the Matrix Model Object.\n     * @param {Layout} layout - provide the layout value.\n     *\n     * @private\n     */\n    MatrixModel.prototype.arrangeElements = function (matrixModel, layout) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal;\n        if (layout.orientation === 'LeftToRight' || layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        else {\n            isHorizontal = false;\n        }\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        //let spacingInverse: number = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        // Need to group element before\n        this.groupLayoutCells(matrixModel);\n        this.createMatrixCells(matrixModel);\n        for (var j = 0; j < matrixModel.matrix.length; j++) {\n            var matrixKey = matrixModel.matrix[parseInt(j.toString(), 10)].key;\n            var matrixrow = matrixModel.matrix[parseInt(matrixKey.toString(), 10)].value;\n            for (var i = 1; i < matrixrow.length; i++) {\n                var cell = matrixrow[parseInt(i.toString(), 10)];\n                var prevCell = matrixrow[i - 1];\n                cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n            }\n        }\n        // Sort roots based on their indices\n        matrixModel.roots.sort(function (a, b) {\n            if (a.cells[0] && b.cells[0]) {\n                var indexA = matrixModel.model.roots.indexOf(a.cells[0].cell);\n                var indexB = matrixModel.model.roots.indexOf(b.cells[0].cell);\n                return indexA - indexB;\n            }\n            return 0;\n        });\n        for (var j = 0; j < matrixModel.roots.length; j++) {\n            var root = matrixModel.roots[parseInt(j.toString(), 10)];\n            this.arrangeMatrix(root, null, matrixModel);\n        }\n        for (var k = 0; k < matrixModel.matrix.length; k++) {\n            var row = matrixModel.matrix[parseInt(k.toString(), 10)].value;\n            for (var i = 0; i < row.length; i++) {\n                var cell = row[parseInt(i.toString(), 10)];\n                var parents = cell.visitedParents.slice();\n                for (var i_1 = 0; i_1 < cell.visitedParents.length; i_1++) {\n                    var cellIgnoredParent = cell.visitedParents[parseInt(i_1.toString(), 10)];\n                    if (cellIgnoredParent && this.containsValue(cellIgnoredParent.ignoredChildren, cell)) {\n                        parents.splice(parents.indexOf(cellIgnoredParent), 1);\n                    }\n                }\n                if (parents.length > 1) {\n                    var firstParent = parents[0];\n                    var lastParent = parents[parents.length - 1];\n                    var firstVertexParent = this.findParentVertexCellGroup(firstParent);\n                    var lastVertexParent = this.findParentVertexCellGroup(lastParent);\n                    if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {\n                        firstParent = firstVertexParent;\n                    }\n                    if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {\n                        lastParent = firstVertexParent;\n                    }\n                    var newoffset = (lastParent.offset + lastParent.size * 0.5 + firstParent.offset - firstParent.size * 0.5) / 2;\n                    var availOffsetMin = cell.initialOffset;\n                    var availOffsetMax = cell.offset;\n                    if (!(availOffsetMax === availOffsetMin)) {\n                        this.seenCells = [];\n                        if (newoffset >= availOffsetMin && newoffset <= availOffsetMax) {\n                            this.translateMatrixCells(newoffset - cell.offset, cell);\n                        }\n                        else if (newoffset < availOffsetMin) {\n                            this.translateMatrixCells(availOffsetMin - cell.offset, cell);\n                        }\n                        this.seenCells = [];\n                    }\n                }\n            }\n        }\n        this.setXYforMatrixCell(matrixModel);\n    };\n    /* tslint:enable */\n    MatrixModel.prototype.groupLayoutCells = function (matrixModel) {\n        var ranks = matrixModel.model.ranks;\n        for (var j = ranks.length - 1; j >= 0; j--) {\n            var vertices = [];\n            for (var v = 0; v < ranks[parseInt(j.toString(), 10)].length; v++) {\n                var rank = ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)];\n                var type = this.getType(rank.type);\n                if (type === 'internalVertex') {\n                    vertices.push(ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)]);\n                }\n            }\n            var edges = [];\n            for (var e = 0; e < ranks[parseInt(j.toString(), 10)].length; e++) {\n                var rank = ranks[parseInt(j.toString(), 10)][parseInt(e.toString(), 10)];\n                var type = this.getType(rank.type);\n                if (type === 'internalEdge') {\n                    edges.push(rank);\n                }\n            }\n            while (vertices.length > 1) {\n                var vertex1 = vertices[0];\n                var parentset1 = this.selectIds(vertex1.connectsAsTarget, true);\n                var childset1 = this.selectIds(vertex1.connectsAsSource, false);\n                while (vertices.length > 1) {\n                    var vertex2 = vertices[1];\n                    var parentset2 = this.selectIds(vertex2.connectsAsTarget, true);\n                    var childset2 = this.selectIds(vertex2.connectsAsSource, false);\n                    var parentequals = this.compareLists(parentset1, parentset2);\n                    var childequals = this.compareLists(childset1, childset2);\n                    if (parentequals && childequals) {\n                        this.updateMutualSharing(vertices[0], vertex2.id);\n                        this.updateMutualSharing(vertices[1], vertex1.id);\n                        vertices.splice(1, 1);\n                        continue;\n                    }\n                    break;\n                }\n                vertices.splice(0, 1);\n            }\n            while (edges.length > 1) {\n                var internalEdge = edges[0];\n                var parentset = internalEdge.source;\n                var childset = internalEdge.target;\n                if (parentset.identicalSibiling != null) {\n                    var groupedges = [];\n                    for (var i = 0; i < edges.length; i++) {\n                        var edge = edges[parseInt(i.toString(), 10)];\n                        if (edge.target === childset) {\n                            groupedges.push(edge);\n                        }\n                    }\n                    for (var i = 0; i < groupedges.length; i++) {\n                        var internalEdgese = groupedges[parseInt(i.toString(), 10)];\n                        if (this.containsValue(parentset.identicalSibiling, internalEdgese.source.id)) {\n                            internalEdgese.source.identicalSibiling = null;\n                        }\n                    }\n                    internalEdge.source.identicalSibiling = null;\n                }\n                edges.splice(0, 1);\n            }\n        }\n    };\n    /* tslint:disable */\n    MatrixModel.prototype.createMatrixCells = function (matrixModel) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight'\n            || layoutSettings.orientation === 'RightToLeft';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var spacingInverse = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var ranks = matrixModel.model.ranks;\n        var matrixCellMapper = [];\n        var rowoffset = -spacingInverse;\n        for (var j = ranks.length - 1; j >= 0; j--) {\n            var maxDimension = 0.0;\n            var index = (ranks.length - 1) - j;\n            var rank = ranks[parseInt(j.toString(), 10)].slice(); //.ToList();\n            // Creating new row and adding it to matrix\n            var matrixRow = [];\n            matrixModel.matrix.push({ key: index, value: matrixRow });\n            // Creating new row mapper\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var tempMatrixRow = [];\n            matrixCellMapper.push({ index: index, value: tempMatrixRow });\n            while (rank.length > 0) //.Any())\n             {\n                var layoutCell = rank[0];\n                // eslint-disable-next-line max-len\n                var matrixCell = { level: index, parents: [], children: [], visitedParents: [], visitedChildren: [], ignoredChildren: [], cells: [], size: 0, offset: 0, initialOffset: 0 };\n                matrixRow.push(matrixCell);\n                var type = this.getType(layoutCell.type);\n                if (type === 'internalVertex') {\n                    matrixCell.cells.push(layoutCell);\n                    if (layoutCell.identicalSibiling != null) {\n                        for (var i = 0; i < rank.length; i++) {\n                            var internalVertex = rank[parseInt(i.toString(), 10)];\n                            var type_1 = this.getType(internalVertex.type);\n                            if (type_1 === 'internalVertex' && this.containsValue(layoutCell.identicalSibiling, internalVertex.id)) {\n                                matrixCell.cells.push(internalVertex);\n                                if (matrixCell.cells.length > layoutCell.identicalSibiling.length) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    for (var i = 0; i < matrixCell.cells.length; i++) {\n                        var internalVertex = matrixCell.cells[parseInt(i.toString(), 10)];\n                        var type_2 = this.getType(internalVertex.type);\n                        if (type_2 === 'internalVertex') {\n                            var geometry = internalVertex.cell.geometry;\n                            matrixCell.size += isHorizontal ? geometry.height : geometry.width;\n                            maxDimension = Math.max(maxDimension, !isHorizontal ? geometry.height : geometry.width);\n                            tempMatrixRow.push({ key: internalVertex.id, value: matrixCell });\n                            if (internalVertex.connectsAsTarget.length > 0) {\n                                for (var k = 0; k < internalVertex.connectsAsTarget.length; k++) {\n                                    var internalEdgese = internalVertex.connectsAsTarget[parseInt(k.toString(), 10)];\n                                    var key = null;\n                                    if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.ids)) {\n                                        key = internalEdgese.ids;\n                                    }\n                                    else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.source.id)) {\n                                        key = internalEdgese.source.id;\n                                    }\n                                    if (key != null) {\n                                        var parentcellValue = matrixCellMapper[index - 1].value;\n                                        var parentMartixCell = void 0;\n                                        for (var v = 0; v < parentcellValue.length; v++) {\n                                            if (parentcellValue[parseInt(v.toString(), 10)].key === key) {\n                                                parentMartixCell = parentcellValue[parseInt(v.toString(), 10)].value;\n                                                break;\n                                            }\n                                        }\n                                        if (!this.containsValue(matrixCell.parents, parentMartixCell)) {\n                                            matrixCell.parents.push(parentMartixCell);\n                                        }\n                                        if (!this.containsValue(parentMartixCell.children, matrixCell)) {\n                                            parentMartixCell.children.push(matrixCell);\n                                        }\n                                    }\n                                }\n                            }\n                            // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout\n                            var vertex = matrixCell.cells[parseInt(i.toString(), 10)];\n                            if (rank.indexOf(vertex) !== -1) {\n                                rank.splice(rank.indexOf(vertex), 1);\n                            }\n                        }\n                    }\n                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n                }\n                else if (type === 'internalEdge') {\n                    matrixCell.cells.push(layoutCell);\n                    for (var i = 0; i < matrixCell.cells.length; i++) {\n                        var internalEdge = matrixCell.cells[parseInt(i.toString(), 10)];\n                        var type1 = this.getType(internalEdge.type);\n                        if (type1 === 'internalEdge' && internalEdge.edges != null) {\n                            // need to spacing based on its source and target Node\n                            var edgeSpacing = 5;\n                            var cellSize = -edgeSpacing;\n                            for (var k = 0; k < internalEdge.edges.length; k++) {\n                                //const internalConnector = internalEdge.edges[k];\n                                // need to summ up the line width\n                                cellSize += 1 + edgeSpacing;\n                            }\n                            matrixCell.size += cellSize;\n                        }\n                        tempMatrixRow.push({ key: internalEdge.ids, value: matrixCell });\n                        var key = null;\n                        if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.ids)) {\n                            key = internalEdge.ids;\n                        }\n                        else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.source.id)) {\n                            key = internalEdge.source.id;\n                        }\n                        if (key != null) {\n                            var parentcell = matrixCellMapper[index - 1].value;\n                            var parentMartixCell = void 0;\n                            for (var v = 0; v < parentcell.length; v++) {\n                                if (parentcell[parseInt(v.toString(), 10)].key === key) {\n                                    parentMartixCell = parentcell[parseInt(v.toString(), 10)].value;\n                                    break;\n                                }\n                            }\n                            if (!this.containsValue(matrixCell.parents, parentMartixCell)) {\n                                matrixCell.parents.push(parentMartixCell);\n                            }\n                            if (!this.containsValue(parentMartixCell.children, matrixCell)) {\n                                parentMartixCell.children.push(matrixCell);\n                            }\n                        }\n                        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout\n                        var vertex = matrixCell.cells[parseInt(i.toString(), 10)];\n                        if (rank.indexOf(vertex) !== -1) {\n                            rank.splice(rank.indexOf(vertex), 1);\n                        }\n                    }\n                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n                }\n                if (matrixCell.cells.length) {\n                    var internalVertices = matrixCell.cells.filter(function (e) { return e.type === 'internalVertex'; });\n                    if (internalVertices.length > 0) {\n                        var _loop_1 = function (cell) {\n                            var vertex = cell.cell;\n                            if (matrixModel.model.roots.some(function (root) { return root === vertex; })) {\n                                matrixModel.roots.push(matrixCell);\n                                return \"break\";\n                            }\n                        };\n                        for (var _i = 0, internalVertices_1 = internalVertices; _i < internalVertices_1.length; _i++) {\n                            var cell = internalVertices_1[_i];\n                            var state_1 = _loop_1(cell);\n                            if (state_1 === \"break\")\n                                break;\n                        }\n                    }\n                }\n            }\n            matrixModel.rowOffset.push(rowoffset + (maxDimension / 2) + spacingInverse);\n            rowoffset += maxDimension + spacingInverse;\n        }\n    };\n    MatrixModel.prototype.arrangeMatrix = function (cell, parent, matrixModel) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight'\n            || layoutSettings.orientation === 'RightToLeft';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var matrix = matrixModel.matrix;\n        var matrixRow = matrix[cell.level].value;\n        var matrixIndex = matrixRow.indexOf(cell);\n        if (cell.visitedParents.length > 0) {\n            if (cell.visitedParents.length === 1) {\n                cell.initialOffset = cell.offset;\n            }\n            if (!this.containsValue(cell.visitedParents, parent)) {\n                var lastParent = cell.visitedParents[cell.visitedParents.length - 1];\n                var parentMatrixRow = matrix[lastParent.level].value;\n                var lastParentIndex = parentMatrixRow.indexOf(lastParent);\n                var parentIndex = parentMatrixRow.indexOf(parent);\n                var nextCell = matrixIndex + 1 < matrixRow.length ? matrixRow[matrixIndex + 1] : undefined;\n                if (lastParent.ignoredChildren.indexOf(cell) !== -1 || parentIndex - lastParentIndex !== 1 ||\n                    (nextCell && nextCell.visitedParents.length > 0)) {\n                    cell.visitedParents.push(parent);\n                    parent.ignoredChildren.push(cell);\n                    return;\n                }\n            }\n        }\n        if (!(cell.children.length > 0)) {\n            var validOffset = cell.offset;\n            if (matrixIndex > 0) {\n                var prevCell = matrixRow[matrixIndex - 1];\n                validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n            }\n            this.shiftMatrixCells(validOffset - cell.offset, cell, false, null, matrixModel);\n        }\n        else {\n            for (var i = 0; i < cell.children.length; i++) {\n                var matrixCellChild = cell.children[parseInt(i.toString(), 10)];\n                if (!this.containsValue(cell.visitedChildren, matrixCellChild)) {\n                    this.arrangeMatrix(matrixCellChild, cell, matrixModel);\n                    cell.visitedChildren.push(matrixCellChild);\n                }\n            }\n            if (cell.visitedChildren.length > 0) {\n                var children = cell.visitedChildren.slice();\n                for (var i = 0; i < cell.ignoredChildren.length; i++) {\n                    var cellIgnoredChild = cell.ignoredChildren[parseInt(i.toString(), 10)];\n                    if (this.containsValue(children, cellIgnoredChild)) {\n                        children.splice(children.indexOf(cellIgnoredChild), 1);\n                    }\n                }\n                if (children.length > 0) {\n                    var firstChild = children[0];\n                    var lastChild = children[children.length - 1];\n                    var x1 = firstChild.offset - (firstChild.size / 2);\n                    var x2 = lastChild.offset + (lastChild.size / 2);\n                    var newoffset = (x1 + x2) / 2;\n                    if (newoffset < cell.offset) {\n                        this.shiftMatrixCells(cell.offset - newoffset, firstChild, true, cell, matrixModel);\n                    }\n                    else if (newoffset > cell.offset) {\n                        this.shiftMatrixCells(newoffset - cell.offset, cell, false, null, matrixModel);\n                    }\n                }\n            }\n        }\n        if (!this.containsValue(cell.visitedParents, parent)) {\n            cell.visitedParents.push(parent);\n        }\n    };\n    MatrixModel.prototype.findParentVertexCellGroup = function (cell) {\n        if (cell.cells[0]) {\n            return cell;\n        }\n        if (cell.parents.length > 0) {\n            return this.findParentVertexCellGroup(cell.parents[0]);\n        }\n        return cell;\n    };\n    MatrixModel.prototype.translateMatrixCells = function (value, cell) {\n        if (!(value === 0)) {\n            if (this.seenCells.indexOf(cell) !== -1) {\n                return;\n            }\n            this.seenCells.push(cell);\n            cell.offset += value;\n            if (cell.visitedChildren.length > 0) {\n                for (var i = 0; i < cell.visitedChildren.length; i++) {\n                    var cellVisitedChild = cell.visitedChildren[parseInt(i.toString(), 10)];\n                    if (cell.ignoredChildren.indexOf(cellVisitedChild) !== -1) {\n                        continue;\n                    }\n                    this.translateMatrixCells(value, cellVisitedChild);\n                }\n            }\n        }\n    };\n    MatrixModel.prototype.setXYforMatrixCell = function (matrixModel) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight'\n            || layoutSettings.orientation === 'RightToLeft';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        for (var i = 0; i < matrixModel.matrix.length; i++) {\n            var matrixrow1 = matrixModel.matrix[parseInt(i.toString(), 10)].value;\n            for (var j = 0; j < matrixrow1.length; j++) {\n                var matrixCell = matrixrow1[parseInt(j.toString(), 10)];\n                var start = matrixCell.offset - (matrixCell.size / 2);\n                for (var k = 0; k < matrixCell.cells.length; k++) {\n                    var cell = matrixCell.cells[parseInt(k.toString(), 10)];\n                    var type = this.getType(cell.type);\n                    if (type === 'internalVertex') {\n                        var internalVertex = cell;\n                        var width = internalVertex.cell.geometry.width;\n                        var height = internalVertex.cell.geometry.height;\n                        if (isHorizontal) {\n                            internalVertex.cell.geometry = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(matrixModel.rowOffset[matrixCell.level] - (width / 2), start, width, height);\n                        }\n                        else {\n                            internalVertex.cell.geometry = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(start, matrixModel.rowOffset[matrixCell.level] - (height / 2), width, height);\n                        }\n                        start += (isHorizontal ? height : width) + spacing;\n                    }\n                    else if (type === 'internalEdge') {\n                        var internalEdges = cell;\n                        var parent_1 = matrixCell.visitedParents[0];\n                        var isContainSibilingVertex = false;\n                        if (parent_1) {\n                            for (var l = 0; l < parent_1.visitedChildren.length; l++) {\n                                var children = parent_1.visitedChildren[parseInt(l.toString(), 10)];\n                                var cells = [];\n                                for (var m = 0; m < children.cells.length; m++) {\n                                    var cell_1 = children.cells[parseInt(m.toString(), 10)];\n                                    var type_3 = this.getType(cell_1.type);\n                                    if (type_3 === 'internalVertex') {\n                                        cells.push(cell_1);\n                                    }\n                                }\n                                if (cells.length > 0) {\n                                    isContainSibilingVertex = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // Need to updated line width\n                        var lineWidth = 1;\n                        var edgeSpacing = 5;\n                        for (var m = 0; m < internalEdges.edges.length; m++) {\n                            var internalConnector = internalEdges.edges[parseInt(m.toString(), 10)];\n                            var pt = this.getPointvalue(start + (lineWidth / 2.0), matrixModel.rowOffset[matrixCell.level]);\n                            if (isHorizontal) {\n                                pt = this.getPointvalue(matrixModel.rowOffset[matrixCell.level], start + (lineWidth / 2.0));\n                            }\n                            if (this.containsValue(this.getEdgeMapper(), internalConnector)) {\n                                var key = void 0;\n                                for (var l = 0; l < this.getEdgeMapper().length; l++) {\n                                    if ((this.getEdgeMapper())[parseInt(l.toString(), 10)].key === internalConnector) {\n                                        key = l;\n                                        break;\n                                    }\n                                }\n                                (this.getEdgeMapper())[parseInt(key.toString(), 10)].value.push(pt);\n                            }\n                            start += lineWidth + edgeSpacing;\n                        }\n                        start += spacing;\n                    }\n                }\n            }\n        }\n    };\n    MatrixModel.prototype.getType = function (type) {\n        if (type === 'internalVertex') {\n            return 'internalVertex';\n        }\n        else {\n            return 'internalEdge';\n        }\n    };\n    MatrixModel.prototype.selectIds = function (node, source) {\n        var returnIds = [];\n        for (var i = 0; i < node.length; i++) {\n            var connector = node[parseInt(i.toString(), 10)];\n            if (source) {\n                {\n                    returnIds.push(connector.source.id);\n                }\n            }\n            else {\n                returnIds.push(connector.target.id);\n            }\n        }\n        return returnIds;\n    };\n    MatrixModel.prototype.compareLists = function (list1, list2) {\n        var newList1 = list1.slice();\n        var newList2 = list2.slice();\n        if (newList1.length === newList2.length) {\n            if (newList1.length === 0) {\n                return true;\n            }\n            else {\n                var isSame = true;\n                for (var i = 0; i < newList2.length; i++) {\n                    var o = newList2[parseInt(i.toString(), 10)];\n                    // EJ2-63944 - Nodes overlapping in Complex hierarchical tree layout in linear arrangement.\n                    if (newList1.indexOf(o) === -1) {\n                        isSame = false;\n                        break;\n                    }\n                }\n                return isSame;\n            }\n        }\n        return false;\n    };\n    MatrixModel.prototype.updateMutualSharing = function (cell, id) {\n        if (cell.identicalSibiling != null) {\n            cell.identicalSibiling.push(id);\n        }\n        else {\n            cell.identicalSibiling = [];\n            cell.identicalSibiling.push(id);\n        }\n    };\n    MatrixModel.prototype.containsValue = function (list, keyValue) {\n        for (var i = 0; i < list.length; i++) {\n            if (list[parseInt(i.toString(), 10)].key === keyValue\n                || list[parseInt(i.toString(), 10)] === keyValue) {\n                return true;\n            }\n        }\n        return false;\n    };\n    MatrixModel.prototype.shiftMatrixCells = function (value, startingCell, shiftChildren, parentCell, matrixModel) {\n        if (!(value === 0)) {\n            var matrix = matrixModel.matrix;\n            var matrixRow = matrix[startingCell.level].value;\n            var index = matrixRow.indexOf(startingCell);\n            for (var i = index; i < matrixRow.length; i++) {\n                matrixRow[parseInt(i.toString(), 10)].offset += value;\n            }\n            if (shiftChildren) {\n                if (startingCell.visitedChildren.length > 0) {\n                    var firstChild = undefined;\n                    for (var i = 0; i < startingCell.visitedChildren.length; i++) {\n                        var child = startingCell.visitedChildren[parseInt(i.toString(), 10)];\n                        if (startingCell.ignoredChildren.indexOf(child) !== -1) {\n                            continue;\n                        }\n                        firstChild = child;\n                        break;\n                    }\n                    if (firstChild) {\n                        this.shiftMatrixCells(value, firstChild, true, startingCell, matrixModel);\n                    }\n                }\n                else {\n                    var i = 1;\n                    var nextSibilingwithChild = null;\n                    while (index + i < matrixRow.length) {\n                        var nextCell = matrixRow[index + i];\n                        if (nextCell.visitedChildren.length > 0 && nextCell.visitedChildren.length > nextCell.ignoredChildren.length) {\n                            nextSibilingwithChild = nextCell;\n                            break;\n                        }\n                        i++;\n                    }\n                    if (nextSibilingwithChild != null) {\n                        var firstChild = undefined;\n                        for (var j = 0; j < nextSibilingwithChild.visitedChildren.length; j++) {\n                            var child = nextSibilingwithChild.visitedChildren[parseInt(j.toString(), 10)];\n                            if (nextSibilingwithChild.ignoredChildren.indexOf(child) !== -1) {\n                                continue;\n                            }\n                            firstChild = child;\n                            break;\n                        }\n                        if (firstChild) {\n                            this.shiftMatrixCells(value, firstChild, true, nextSibilingwithChild, matrixModel);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    MatrixModel.prototype.getPointvalue = function (x, y) {\n        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };\n    };\n    MatrixModel.prototype.getEdgeMapper = function () {\n        return this.edgeMapper;\n    };\n    MatrixModel.prototype.setEdgeMapper = function (value) {\n        this.edgeMapper.push(value);\n    };\n    MatrixModel.prototype.updateLayout = function (viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable) {\n        var trnsX = ((viewPort.x - modelBounds.width) / 2) - modelBounds.x;\n        var trnsY = ((viewPort.y - modelBounds.height) / 2) - modelBounds.y;\n        trnsX = Math.round(trnsX);\n        trnsY = Math.round(trnsY);\n        var modifiedConnectors = [];\n        var transModelBounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(modelBounds.x + trnsX, modelBounds.y + trnsY, modelBounds.width, modelBounds.height);\n        var margin = layoutProp.margin;\n        var isHorizontal = layout.orientation === 'RightToLeft' || layout.orientation === 'LeftToRight';\n        var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;\n        for (var i = 0; i < nodeWithMultiEdges.length; i++) {\n            var node = nodeWithMultiEdges[parseInt(i.toString(), 10)];\n            if (node.outEdges != null && node.outEdges.length > 0) {\n                var count = node.outEdges.length;\n                for (var j = 0; j < count; j++) {\n                    var internalConnector = nameTable[node.outEdges[parseInt(j.toString(), 10)]];\n                    internalConnector['pointCollection'] = [];\n                    if (count > 1) {\n                        var segmentsize = inversespacing / 2.0;\n                        var intermediatePoint = null;\n                        var key = void 0;\n                        var edgeMapper = this.getEdgeMapper();\n                        for (var k = 0; k < edgeMapper.length; k++) {\n                            if (edgeMapper[parseInt(k.toString(), 10)].key === internalConnector) {\n                                key = k;\n                                break;\n                            }\n                        }\n                        if (key && edgeMapper[parseInt(key.toString(), 10)].value.length > 0) {\n                            var edgePoint = edgeMapper[parseInt(key.toString(), 10)].value[0];\n                            var dxValue1 = edgePoint.x + layout.marginX;\n                            var dyValue1 = edgePoint.y + layout.marginY;\n                            var x1 = dxValue1;\n                            var y1 = dyValue1;\n                            if (layout.orientation === 'BottomToTop') {\n                                y1 = modelBounds.height - dyValue1;\n                            }\n                            else if (layout.orientation === 'RightToLeft') {\n                                x1 = modelBounds.width - dxValue1;\n                            }\n                            intermediatePoint = this.getPointvalue(x1, y1);\n                            internalConnector.segments = [];\n                            this.diagram.connectorPropertyChange(internalConnector, {}, {\n                                type: 'Orthogonal',\n                                segments: internalConnector.segments\n                            });\n                        }\n                        var pts = [];\n                        for (var i_2 = 0; i_2 < internalConnector.segments.length; i_2++) {\n                            var pt = internalConnector.segments[parseInt(i_2.toString(), 10)].points;\n                            // eslint-disable-next-line guard-for-in\n                            for (var temp in pt) {\n                                pts.push(pt[parseInt(temp.toString(), 10)]);\n                            }\n                        }\n                        // eslint-disable-next-line max-len\n                        pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layout.orientation);\n                        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout\n                        if (intermediatePoint != null && this.diagram.layout.connectionPointOrigin !== 'DifferentPoint') {\n                            for (var p = 0; p < pts.length; p++) {\n                                var pt = pts[parseInt(p.toString(), 10)];\n                                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));\n                            }\n                        }\n                        this.resetConnectorPoints(internalConnector);\n                    }\n                    modifiedConnectors.push(internalConnector);\n                }\n            }\n            if (node.inEdges != null && node.inEdges.length > 1) {\n                var count = node.inEdges.length;\n                var edgeMapper = this.getEdgeMapper();\n                for (var j = 0; j < count; j++) {\n                    var internalConnector = nameTable[node.inEdges[parseInt(j.toString(), 10)]];\n                    if (!this.containsValue(modifiedConnectors, internalConnector)) {\n                        internalConnector['pointCollection'] = [];\n                    }\n                    if (count > 1) {\n                        var segmentsize = inversespacing / 2.0;\n                        var intermediatePoint = null;\n                        var key = void 0;\n                        var k = void 0;\n                        for (k = 0; k < edgeMapper.length; k++) {\n                            if (edgeMapper[parseInt(k.toString(), 10)].key === internalConnector) {\n                                key = k;\n                                break;\n                            }\n                        }\n                        if (key && edgeMapper[parseInt(key.toString(), 10)].value.length > 0\n                            && !this.containsValue(modifiedConnectors, internalConnector)) {\n                            var edgePt = edgeMapper[parseInt(k.toString(), 10)].value[0];\n                            var dx1 = edgePt.x + layout.marginX;\n                            var dy1 = edgePt.y + layout.marginY;\n                            // eslint-disable-next-line one-var\n                            var x1 = dx1, y1 = dy1;\n                            if (layout.orientation === 'BottomToTop') {\n                                y1 = modelBounds.height - dy1;\n                            }\n                            else if (layout.orientation === 'RightToLeft') {\n                                x1 = modelBounds.width - dx1;\n                            }\n                            intermediatePoint = this.getPointvalue(x1, y1);\n                            internalConnector.segments = [];\n                            this.diagram.connectorPropertyChange(internalConnector, {}, {\n                                type: 'Orthogonal',\n                                segments: internalConnector.segments\n                            });\n                        }\n                        var pts = [];\n                        for (var p = 0; p < internalConnector.segments.length; p++) {\n                            var pt = internalConnector.segments[parseInt(p.toString(), 10)].points;\n                            // eslint-disable-next-line guard-for-in\n                            for (var temp in pt) {\n                                pts.push(pt[parseInt(temp.toString(), 10)]);\n                            }\n                        }\n                        pts.reverse();\n                        // eslint-disable-next-line\n                        pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layoutProp.orientation);\n                        pts.reverse();\n                        internalConnector['pointCollection'] = [];\n                        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout\n                        if (intermediatePoint != null && this.diagram.layout.connectionPointOrigin !== 'DifferentPoint') {\n                            for (var p = 0; p < pts.length; p++) {\n                                var pt = pts[parseInt(p.toString(), 10)];\n                                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));\n                            }\n                        }\n                        this.resetConnectorPoints(internalConnector);\n                    }\n                }\n            }\n        }\n    };\n    MatrixModel.prototype.inflate = function (rect, x, y) {\n        rect.x -= x;\n        rect.y -= y;\n        rect.width += 2 * x;\n        rect.height += 2 * y;\n        return rect;\n    };\n    MatrixModel.prototype.updateConnectorPoints = function (connectorPoints, startSegmentSize, intermediatePoint, bounds, orientation) {\n        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout\n        var layoutBounds = bounds;\n        var isHorizontal = orientation === 'LeftToRight' || orientation === 'RightToLeft';\n        var pts = connectorPoints;\n        var startPoint = pts[0];\n        var endPoint = pts[pts.length - 1];\n        if (intermediatePoint != null) {\n            var startNext = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.transform(startPoint, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findAngle(startPoint, pts[1]), startSegmentSize);\n            var endBefore = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.transform(endPoint, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findAngle(endPoint, pts[pts.length - 2]), startSegmentSize);\n            var intermediateStart = this.getPointvalue(intermediatePoint.x, startNext.y);\n            var intermediateEnd = this.getPointvalue(intermediatePoint.x, endBefore.y);\n            if (isHorizontal) {\n                intermediateStart.x = startNext.x;\n                intermediateStart.y = intermediatePoint.y;\n                intermediateEnd.x = endBefore.x;\n                intermediateEnd.y = intermediatePoint.y;\n            }\n            var length_2 = Math.abs(_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findAngle(intermediateEnd, endBefore));\n            if (length_2 < 0.1) {\n                return [startPoint, startNext, intermediateStart, endBefore, endPoint];\n            }\n            return [startPoint, startNext, intermediateStart, intermediateEnd, endBefore, endPoint];\n        }\n        else if (pts.length === 4) {\n            var startNext = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.transform(startPoint, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findAngle(startPoint, pts[1]), startSegmentSize);\n            var intermediateStart = this.getPointvalue(pts[2].x, startNext.y);\n            if (isHorizontal) {\n                intermediateStart.x = startNext.x;\n                intermediateStart.y = pts[2].y;\n            }\n            return [startPoint, startNext, intermediateStart, endPoint];\n        }\n        return pts;\n    };\n    MatrixModel.prototype.resetConnectorPoints = function (edge) {\n        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout\n        if (edge['pointCollection'] && edge['pointCollection'].length > 0) {\n            var connector = edge;\n            connector.sourcePoint = edge['pointCollection'][0];\n            connector.targetPoint = edge['pointCollection'][edge['pointCollection'].length - 1];\n            var segments = [];\n            for (var i = 0; i < edge['pointCollection'].length - 1; i++) {\n                var point1 = edge['pointCollection'][parseInt(i.toString(), 10)];\n                var point2 = edge['pointCollection'][i + 1];\n                var length_3 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.findDistance)(point1, point2);\n                var direction = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.getConnectorDirection)(point1, point2);\n                if (i === edge['pointCollection'].length - 2) {\n                    if ((this.diagram.layout.orientation === 'RightToLeft' && direction === 'Left')\n                        || (this.diagram.layout.orientation === 'LeftToRight' && direction === 'Right')\n                        || (this.diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')\n                        || (this.diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {\n                        length_3 = length_3 / 2;\n                    }\n                }\n                /* tslint:enable */\n                var tempSegment = new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(edge, 'segments', { type: 'Orthogonal' }, true);\n                tempSegment.length = length_3;\n                tempSegment.direction = direction;\n                segments.push(tempSegment);\n            }\n            connector.segments = segments;\n            connector.type = 'Orthogonal';\n            this.diagram.connectorPropertyChange(connector, {}, {\n                type: 'Orthogonal',\n                segments: connector.segments\n            });\n        }\n        else if (this.diagram.layout.connectionPointOrigin === 'DifferentPoint') {\n            var obstacleCollection = 'obstaclePointCollection';\n            if (edge.segments[0].points\n                && edge.segments[0].points.length > 0 && edge[\"\" + obstacleCollection]) {\n                var connector = edge;\n                connector.sourcePoint = edge[\"\" + obstacleCollection][0];\n                connector.targetPoint = edge[\"\" + obstacleCollection][edge[\"\" + obstacleCollection].length - 1];\n                var segments = [];\n                for (var i = 0; i < edge[\"\" + obstacleCollection].length - 1; i++) {\n                    var point1 = edge[\"\" + obstacleCollection][parseInt(i.toString(), 10)];\n                    var point2 = edge[\"\" + obstacleCollection][i + 1];\n                    var length_4 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.findDistance)(point1, point2);\n                    var direction = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_3__.getConnectorDirection)(point1, point2);\n                    if (i === edge[\"\" + obstacleCollection].length - 2) {\n                        if ((this.diagram.layout.orientation === 'RightToLeft' && direction === 'Left')\n                            || (this.diagram.layout.orientation === 'LeftToRight' && direction === 'Right')\n                            || (this.diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')\n                            || (this.diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {\n                            length_4 = length_4 / 2;\n                        }\n                    }\n                    /* tslint:enable */\n                    var tempSegment = new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(edge, 'segments', { type: 'Orthogonal' }, true);\n                    tempSegment.length = length_4;\n                    tempSegment.direction = direction;\n                    segments.push(tempSegment);\n                }\n                connector.segments = segments;\n                connector.type = 'Orthogonal';\n                this.diagram.connectorPropertyChange(connector, {}, {\n                    type: 'Orthogonal',\n                    segments: connector.segments\n                });\n            }\n        }\n    };\n    MatrixModel.prototype.nodePropertyChange = function (dnode) {\n        // 933466: Excessive Spacing Between Nodes in Complex Hierarchical Tree Layout\n        this.diagram.nodePropertyChange(dnode, {}, { offsetX: dnode.offsetX, offsetY: dnode.offsetY });\n    };\n    return MatrixModel;\n}());\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/complex-hierarchical-tree.js?");

/***/ })

}]);