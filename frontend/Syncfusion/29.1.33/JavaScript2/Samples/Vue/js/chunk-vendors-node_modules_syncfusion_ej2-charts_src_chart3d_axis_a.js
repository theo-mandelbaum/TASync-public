"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart3d_axis_a"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/axis-helper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/axis-helper.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NiceIntervals: () => (/* binding */ NiceIntervals)\n/* harmony export */ });\n/* harmony import */ var _axis_double_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../axis/double-axis */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/double-axis.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/**\n * Common axis classes\n *\n * @private\n */\nvar NiceIntervals = /** @class */ (function (_super) {\n    __extends(NiceIntervals, _super);\n    function NiceIntervals() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Calculates a nice interval for a date-time axis based on the given size and data range.\n     *\n     * @param {Chart3DAxis} axis - The date-time axis for which the nice interval is calculated.\n     * @param {Size} size - The size of the chart area.\n     * @param {number} start - The start value of the data range.\n     * @param {number} end - The end value of the data range.\n     * @returns {number} - The calculated nice interval for the date-time axis.\n     */\n    NiceIntervals.prototype.calculateDateTimeNiceInterval = function (axis, size, start, end) {\n        var oneDay = 24 * 60 * 60 * 1000;\n        var startDate = new Date(start);\n        var endDate = new Date(end);\n        var totalDays = (Math.abs((startDate.getTime() - endDate.getTime()) / (oneDay)));\n        var interval;\n        axis.actualIntervalType = axis.intervalType;\n        var type = axis.intervalType;\n        switch (type) {\n            case 'Years':\n                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);\n                break;\n            case 'Months':\n                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);\n                break;\n            case 'Days':\n                interval = this.calculateNumericNiceInterval(axis, totalDays, size);\n                break;\n            case 'Hours':\n                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);\n                break;\n            case 'Minutes':\n                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);\n                break;\n            case 'Seconds':\n                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);\n                break;\n            case 'Auto':\n                interval = this.calculateNumericNiceInterval(axis, totalDays / 365, size);\n                if (interval >= 1) {\n                    axis.actualIntervalType = 'Years';\n                    return interval;\n                }\n                interval = this.calculateNumericNiceInterval(axis, totalDays / 30, size);\n                if (interval >= 1) {\n                    axis.actualIntervalType = 'Months';\n                    return interval;\n                }\n                interval = this.calculateNumericNiceInterval(axis, totalDays, size);\n                if (interval >= 1) {\n                    axis.actualIntervalType = 'Days';\n                    return interval;\n                }\n                interval = this.calculateNumericNiceInterval(axis, totalDays * 24, size);\n                if (interval >= 1) {\n                    axis.actualIntervalType = 'Hours';\n                    return interval;\n                }\n                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60, size);\n                if (interval >= 1) {\n                    axis.actualIntervalType = 'Minutes';\n                    return interval;\n                }\n                interval = this.calculateNumericNiceInterval(axis, totalDays * 24 * 60 * 60, size);\n                axis.actualIntervalType = 'Seconds';\n                return interval;\n        }\n        return interval;\n    };\n    /**\n     * To get the skeleton for the DateTime axis.\n     *\n     * @param {Chart3DAxis} axis - The date-time axis for which the skeleton is calculated.\n     * @returns {string} - Skeleton format.\n     * @private\n     */\n    NiceIntervals.prototype.getSkeleton = function (axis) {\n        var skeleton;\n        var intervalType = axis.actualIntervalType;\n        if (axis.skeleton) {\n            return axis.skeleton;\n        }\n        if (intervalType === 'Years') {\n            skeleton = ((axis.valueType === 'DateTime' && axis.isIntervalInDecimal) ? 'y' : 'yMMM');\n        }\n        else if (intervalType === 'Months') {\n            skeleton = 'MMMd';\n        }\n        else if (intervalType === 'Days') {\n            skeleton = (axis.valueType === 'DateTime' ? 'MMMd' : 'yMd');\n        }\n        else if (intervalType === 'Hours') {\n            skeleton = (axis.valueType === 'DateTime' ? 'Hm' : 'EHm');\n        }\n        else if (intervalType === 'Minutes') {\n            skeleton = 'Hms';\n        }\n        else {\n            skeleton = 'Hms';\n        }\n        return skeleton;\n    };\n    /**\n     * Find label format for axis\n     *\n     * @param {Chart3DAxis} axis - The  axis for which the label format is calculated.\n     * @returns {string} - The axis label format.\n     * @private\n     */\n    NiceIntervals.prototype.findCustomFormats = function (axis) {\n        var labelFormat = axis.labelFormat ? axis.labelFormat : '';\n        if (!axis.skeleton && axis.actualIntervalType === 'Months' && !labelFormat) {\n            labelFormat = axis.valueType === 'DateTime' ? 'MMM yyyy' : 'yMMM';\n        }\n        return labelFormat;\n    };\n    return NiceIntervals;\n}(_axis_double_axis__WEBPACK_IMPORTED_MODULE_0__.Double3D));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/axis-helper.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/cartesian-panel.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/cartesian-panel.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CartesianAxisLayoutPanel: () => (/* binding */ CartesianAxisLayoutPanel)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n\n\n\n\n/**\n * Specifies the Cartesian Axis Layout.\n */\nvar axisPadding = 10;\n/**\n * The `CartesianAxisLayoutPanel` class is responsible for managing the layout of Cartesian axes in a 3D chart.\n */\nvar CartesianAxisLayoutPanel = /** @class */ (function () {\n    /**\n     *\n     *\n     * @param {Chart3D} chartModule - Specifies the chart module.\n     * @private\n     */\n    function CartesianAxisLayoutPanel(chartModule) {\n        this.chart = chartModule;\n    }\n    /**\n     * Measures and calculates the dimensions of the axis based on the provided rectangle.\n     *\n     * @param {Rect} rect - The rectangle used as a reference for axis measurement and sizing.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n        var chart = this.chart;\n        this.seriesClipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x, rect.y, rect.width, rect.height);\n        this.initialClipRect = rect;\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.initialClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subtractThickness)(this.initialClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.initialClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subtractThickness)(this.initialClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.Thickness(0, 0, this.topSize, this.bottomSize));\n        if (!this.chart.delayRedraw) {\n            this.calculateAxisSize(this.initialClipRect);\n        }\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.seriesClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subtractThickness)(this.seriesClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.seriesClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subtractThickness)(this.seriesClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.Thickness(0, 0, this.topSize, this.bottomSize));\n        if (!this.chart.delayRedraw) {\n            chart.refreshAxis();\n            this.calculateAxisSize(this.seriesClipRect);\n        }\n    };\n    /**\n     * Measures and calculates the dimensions of the row axis within the 3D chart.\n     *\n     * @param {Chart3D} chart - The 3D chart containing the row axis.\n     * @param {Rect} rect - The initial rect values.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n        var row;\n        this.calculateRowSize(rect);\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n            var item = _a[_i];\n            row = item;\n            row.nearSizes = [];\n            row.farSizes = [];\n            this.arrangeAxis(row);\n            this.measureDefinition(row, chart, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Size(chart.availableSize.width, row.computedHeight));\n            if (this.leftSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(row.nearSizes)) {\n                this.leftSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(row.nearSizes);\n            }\n            if (this.rightSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(row.farSizes)) {\n                this.rightSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(row.farSizes);\n            }\n        }\n    };\n    /**\n     * Measures and calculates the dimensions of the column axis within the 3D chart.\n     *\n     * @param {Chart3D} chart - The 3D chart containing the column axis.\n     * @param {Rect} rect - The initial rect values.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n        var column;\n        this.calculateColumnSize(rect);\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var item = _a[_i];\n            column = item;\n            column.farSizes = [];\n            column.nearSizes = [];\n            this.arrangeAxis(column);\n            this.measureDefinition(column, chart, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Size(column.computedWidth, chart.availableSize.height));\n            if (this.bottomSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(column.nearSizes)) {\n                this.bottomSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(column.nearSizes);\n            }\n            if (this.topSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(column.farSizes)) {\n                this.topSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(column.farSizes);\n            }\n        }\n    };\n    /**\n     * Measure the column and row in chart.\n     *\n     * @param {Chart3DRow | Chart3DColumn} definition - Specifies the row or column.\n     * @param {Chart3D} chart - Specifies the chart.\n     * @param {Size} size - Specifies the size.\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\n        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            axis.getModule(chart);\n            axis.baseModule.calculateRangeAndInterval(size, axis);\n            definition.computeSize(axis, chart);\n        }\n        if (definition.farSizes.length > 0) {\n            definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n        }\n        if (definition.nearSizes.length > 0) {\n            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @param {Rect} rect - The initial rect values.\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var axis;\n        var nearCount = 0;\n        var farCount = 0;\n        var size = 0;\n        var x;\n        var y;\n        var axisOffset;\n        this.calculateRowSize(rect);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n                axis = row.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.height === 0) {\n                    axis.rect.height = row.computedHeight;\n                    size = 0;\n                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n                        definition = chart.rows[k];\n                        size += definition.computedHeight;\n                    }\n                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\n                    axis.rect.height = (axis.rect.height + size) -\n                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));\n                    axis.rect.width = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    x = rect.x + rect.width + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArray)(row.farSizes, farCount));\n                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n                    farCount++;\n                }\n                else {\n                    x = rect.x - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArray)(row.nearSizes, nearCount));\n                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n                    nearCount++;\n                }\n            }\n        }\n        this.calculateColumnSize(rect);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n                axis = column.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.width === 0) {\n                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {\n                        definition = chart.columns[k];\n                        axis.rect.width += definition.computedWidth;\n                    }\n                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\n                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));\n                    axis.rect.height = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    y = rect.y - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArray)(column.farSizes, farCount));\n                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n                    farCount++;\n                }\n                else {\n                    y = rect.y + rect.height + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.subArray)(column.nearSizes, nearCount));\n                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n                    nearCount++;\n                }\n            }\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measure = function () {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var actualIndex;\n        var span;\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            if (axis.orientation === 'Vertical') {\n                chart.verticalAxes.push(axis);\n                actualIndex = this.getActualRow(axis);\n                row = chart.rows[actualIndex];\n                this.pushAxis(row, axis);\n                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.rows[j];\n                    definition.axes[row.axes.length - 1] = axis;\n                    chart.rows[j] = definition;\n                }\n                chart.rows[actualIndex] = row;\n            }\n            else {\n                chart.horizontalAxes.push(axis);\n                actualIndex = this.getActualColumn(axis);\n                column = chart.columns[actualIndex];\n                this.pushAxis(column, axis);\n                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.columns[j];\n                    definition.axes[column.axes.length - 1] = axis;\n                    chart.columns[j] = definition;\n                }\n                chart.columns[actualIndex] = column;\n            }\n            axis.isRTLEnabled = chart.enableRtl;\n            axis.setIsInversedAndOpposedPosition();\n        }\n    };\n    /**\n     * Calculates the offset value for an axis based on positions and a plot offset.\n     *\n     * @param {number} position1 - The first position.\n     * @param {number} position2 - The second position.\n     * @param {number} plotOffset - The plot offset value.\n     * @returns {number} - The calculated axis offset value.\n     */\n    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\n        var rangeOffset = position1 ? (position1 + (position2 ? position2 :\n            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);\n        return rangeOffset;\n    };\n    /**\n     * Pushes an axis definition into the specified row or column within the 3D chart.\n     *\n     * @param {Chart3DRow | Chart3DColumn} definition - The row or column definition to which the axis is added.\n     * @param {Chart3DAxis} axis - The axis to be pushed into the definition.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (!definition.axes[i]) {\n                definition.axes[i] = axis;\n                break;\n            }\n        }\n    };\n    /**\n     * Arranges and positions axis elements within the specified row or column definition.\n     *\n     * @param {Chart3DRow | Chart3DColumn} definition - The row or column definition in which axis elements are arranged.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n        var axisCollection = [];\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (definition.axes[i]) {\n                axisCollection.push(definition.axes[i]);\n            }\n        }\n        definition.axes = axisCollection;\n    };\n    /**\n     * Retrieves the actual column index for the specified axis within the 3D chart.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the actual column index is retrieved.\n     * @returns {number} - The actual column index.\n     */\n    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n        var actualLength = this.chart.columns.length;\n        var pos = axis.columnIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    /**\n     * Retrieves the actual row index for the specified axis within the 3D chart.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the actual row index is retrieved.\n     * @returns {number} - The actual row index.\n     */\n    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n        var actualLength = this.chart.rows.length;\n        var pos = axis.rowIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    /**\n     * Measure the row size.\n     *\n     * @param {Rect} rect - The available rect value.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n        /** Calculate row size */\n        var chart = this.chart;\n        var row;\n        var rowTop = rect.y + rect.height;\n        var height = 0;\n        var remainingHeight = Math.max(0, rect.height);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            if (row.height.indexOf('%') !== -1) {\n                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));\n            }\n            else {\n                height = Math.min(remainingHeight, parseInt(row.height, 10));\n            }\n            height = (i !== (len - 1)) ? height : remainingHeight;\n            row.computedHeight = height;\n            rowTop -= height;\n            row.computedTop = rowTop;\n            remainingHeight -= height;\n        }\n    };\n    /**\n     * Measure the column size.\n     *\n     * @param {Rect} rect - The available rect value.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n        /** Calculate column size */\n        var chart = this.chart;\n        var column;\n        var columnLeft = rect.x;\n        var width = 0;\n        var remainingWidth = Math.max(0, rect.width);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            if (column.width.indexOf('%') !== -1) {\n                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));\n            }\n            else {\n                width = Math.min(remainingWidth, parseInt(column.width, 10));\n            }\n            width = (i !== (len - 1)) ? width : remainingWidth;\n            column.computedWidth = width;\n            column.computedLeft = columnLeft;\n            columnLeft += width;\n            remainingWidth -= width;\n        }\n    };\n    return CartesianAxisLayoutPanel;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/cartesian-panel.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/category-axis.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/category-axis.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Category3D: () => (/* binding */ Category3D)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/doubleRange */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/doubleRange.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _axis_axis_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../axis/axis-helper */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/axis-helper.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n/**\n * The `Category` module is used to render category axis.\n */\nvar Category3D = /** @class */ (function (_super) {\n    __extends(Category3D, _super);\n    /**\n     * Constructor for the category module.\n     *\n     * @param {Chart3D} chart - Chart instance.\n     * @private\n     */\n    function Category3D(chart) {\n        return _super.call(this, chart) || this;\n    }\n    /**\n     * Calculates the range and interval for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used for range and interval calculation.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {void}\n     * @private\n     */\n    Category3D.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.applyRangePadding(axis, size);\n        this.calculateVisibleLabels(axis);\n    };\n    /**\n     * Retrieves the actual range for the specified axis based on the provided size.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the actual range is calculated.\n     * @param {Size} size - The size of the chart area used in the range calculation.\n     * @returns {void}\n     */\n    Category3D.prototype.getActualRange = function (axis, size) {\n        this.initializeDoubleRange(axis);\n        axis.actualRange = {};\n        if (!axis.interval) {\n            axis.actualRange.interval = Math.max(1, Math.floor(axis.doubleRange.delta / (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getActualDesiredIntervalsCount)(size, axis)));\n        }\n        else {\n            axis.actualRange.interval = Math.ceil(axis.interval);\n        }\n        axis.actualRange.min = axis.doubleRange.start;\n        axis.actualRange.max = axis.doubleRange.end;\n        axis.actualRange.delta = axis.doubleRange.delta;\n    };\n    /**\n     * Applies range padding to the specified axis based on the provided size.\n     *\n     * @param {Chart3DAxis} axis - The axis to which range padding is applied.\n     * @param {Size} size - The size of the chart area used in the padding calculation.\n     * @returns {void}\n     */\n    Category3D.prototype.applyRangePadding = function (axis, size) {\n        var ticks = 0.5;\n        axis.actualRange.min -= ticks;\n        axis.actualRange.max += ticks;\n        axis.doubleRange = new _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(axis.actualRange.min, axis.actualRange.max);\n        axis.actualRange.delta = axis.doubleRange.delta;\n        this.calculateVisibleRange(size, axis);\n    };\n    /**\n     * Calculate visible labels for the axis based on the range calculated.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the labels are calculated.\n     * @returns {void}\n     * @private\n     */\n    Category3D.prototype.calculateVisibleLabels = function (axis) {\n        /** Generate axis labels */\n        axis.visibleLabels = [];\n        axis.visibleRange.interval = axis.visibleRange.interval < 1 ? 1 : axis.visibleRange.interval;\n        var tempInterval = Math.ceil(axis.visibleRange.min);\n        var labelStyle;\n        var position;\n        axis.startLabel = axis.labels[Math.round(axis.visibleRange.min)];\n        axis.endLabel = axis.labels[Math.floor(axis.visibleRange.max)];\n        for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {\n            labelStyle = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.getValue)('properties', axis.labelStyle), null, true));\n            if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withIn)(tempInterval, axis.visibleRange) && axis.labels.length > 0) {\n                position = Math.round(tempInterval);\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.triggerLabelRender)(this.chart, position, axis.labels[position] ? axis.labels[position].toString() : position.toString(), labelStyle, axis);\n            }\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * Get module name\n     *\n     * @returns {string} - Returns the module name\n     */\n    Category3D.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'Category3D';\n    };\n    /**\n     * To destroy the category axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    Category3D.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return Category3D;\n}(_axis_axis_helper__WEBPACK_IMPORTED_MODULE_3__.NiceIntervals));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/category-axis.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-category-axis.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-category-axis.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTimeCategory3D: () => (/* binding */ DateTimeCategory3D)\n/* harmony export */ });\n/* harmony import */ var _axis_category_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../axis/category-axis */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/category-axis.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * The DatetimeCategory module is used to render date time category axis.\n */\nvar DateTimeCategory3D = /** @class */ (function (_super) {\n    __extends(DateTimeCategory3D, _super);\n    /**\n     * Constructor for the category module.\n     *\n     * @param {Chart3D} chart - Chart3D instance.\n     * @private\n     */\n    function DateTimeCategory3D(chart) {\n        return _super.call(this, chart) || this;\n    }\n    /**\n     * Calculates the range and interval for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used for range and interval calculation.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {void}\n     */\n    DateTimeCategory3D.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.axisSize = size;\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.applyRangePadding(axis, size);\n        this.calculateVisibleLabels(axis);\n    };\n    /**\n     * Calculates and updates the visible labels for the specified axis.\n     *\n     * @param {Chart3DAxis} axis - The axis for which visible labels are calculated.\n     * @returns {void}\n     */\n    DateTimeCategory3D.prototype.calculateVisibleLabels = function (axis) {\n        /** Generate axis labels */\n        axis.visibleLabels = [];\n        var labelStyle;\n        var padding = 0;\n        if (axis.intervalType === 'Auto') {\n            this.calculateDateTimeNiceInterval(axis, this.axisSize, parseInt(axis.labels[0], 10), parseInt(axis.labels[axis.labels.length - 1], 10));\n        }\n        else {\n            axis.actualIntervalType = axis.intervalType;\n        }\n        axis.format = this.chart.intl.getDateFormat({\n            format: axis.labelFormat || '', type: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(axis.skeletonType),\n            skeleton: this.getSkeleton(axis)\n        });\n        var i = 0;\n        for (; i < axis.labels.length; i++) {\n            labelStyle = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.getValue)('properties', axis.labelStyle), null, true));\n            if (!this.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - 1], axis.actualIntervalType, i)\n                || axis.isIndexed) {\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withIn)(i - padding, axis.visibleRange)) {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.triggerLabelRender)(this.chart, i, (axis.isIndexed ? this.getIndexedAxisLabel(axis.labels[i], axis.format) :\n                        axis.format(new Date(axis.labels.map(Number)[i]))), labelStyle, axis);\n                }\n            }\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * To get the indexed axis label text with format for DateTimeCategory axis.\n     *\n     * @param {string} value value\n     * @param {Function} format format\n     * @returns {string} Indexed axis label text\n     */\n    DateTimeCategory3D.prototype.getIndexedAxisLabel = function (value, format) {\n        var texts = value.split(',');\n        for (var i = 0; i < texts.length; i++) {\n            texts[i] = format(new Date(parseInt(texts[i], 10)));\n        }\n        return texts.join(', ');\n    };\n    /**\n     * Checks whether two dates have the same interval value of the specified type at the given index.\n     *\n     * @param {number} currentDate - The current date to be compared.\n     * @param {number} previousDate - The previous date to be compared.\n     * @param {IntervalType} type - The type of interval (year, month, day, etc.).\n     * @param {number} index - The index within the interval.\n     * @returns {boolean} - True if the two dates have the same interval value; otherwise, false.\n     */\n    DateTimeCategory3D.prototype.sameInterval = function (currentDate, previousDate, type, index) {\n        var sameValue;\n        if (index === 0) {\n            sameValue = false;\n        }\n        else {\n            switch (type) {\n                case 'Years':\n                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear();\n                    break;\n                case 'Months':\n                    sameValue = new Date(currentDate).getFullYear() === new Date(previousDate).getFullYear() &&\n                        new Date(currentDate).getMonth() === new Date(previousDate).getMonth();\n                    break;\n                case 'Days':\n                    sameValue = (Math.abs(currentDate - previousDate) < 24 * 60 * 60 * 1000 &&\n                        new Date(currentDate).getDay() === new Date(previousDate).getDay());\n                    break;\n                case 'Hours':\n                    sameValue = (Math.abs(currentDate - previousDate) < 60 * 60 * 1000 &&\n                        new Date(currentDate).getDay() === new Date(previousDate).getDay());\n                    break;\n                case 'Minutes':\n                    sameValue = (Math.abs(currentDate - previousDate) < 60 * 1000 &&\n                        new Date(currentDate).getMinutes() === new Date(previousDate).getMinutes());\n                    break;\n                case 'Seconds':\n                    sameValue = (Math.abs(currentDate - previousDate) < 1000 &&\n                        new Date(currentDate).getDay() === new Date(previousDate).getDay());\n                    break;\n            }\n        }\n        return sameValue;\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name\n     */\n    DateTimeCategory3D.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'DateTimeCategory3D';\n    };\n    /**\n     * To destroy the datetime category axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    DateTimeCategory3D.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return DateTimeCategory3D;\n}(_axis_category_axis__WEBPACK_IMPORTED_MODULE_0__.Category3D));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/date-time-category-axis.js?");

/***/ })

}]);