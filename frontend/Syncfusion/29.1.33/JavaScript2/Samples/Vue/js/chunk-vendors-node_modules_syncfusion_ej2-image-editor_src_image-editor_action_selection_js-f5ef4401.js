"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-image-editor_src_image-editor_action_selection_js-f5ef4401"],{

/***/ "./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/selection.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/selection.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Selection: () => (/* binding */ Selection)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-image-editor/src/image-editor/index.js\");\n/* eslint-disable prefer-const */\n\n\nvar Selection = /** @class */ (function () {\n    function Selection(parent) {\n        this.diffPoint = { x: 0, y: 0 }; // updates resize points\n        this.oldPoint = {};\n        this.isTouch = false;\n        this.isObjSelected = false;\n        this.isFhdPoint = false; // Specifies whether mouse cursor is on freehand drawing point or not\n        this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 }; // updates drag start and end points in mousedown and mousemove\n        this.isShapeInserted = false;\n        this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },\n            flipObjColl: [], triangle: [], triangleRatio: [], order: null }; // for undo redo\n        this.isFirstMove = false; // for pinch zoom\n        this.startTouches = []; // for pinch zoom\n        this.tempTouches = []; // for pinch zoom\n        this.currMousePoint = { x: 0, y: 0 }; // To prevent mouse move event on pinch zoom\n        this.cursorTargetId = '';\n        this.isPreventDragging = false; // Shapes dragging is prevented when crop region is inside shape points\n        this.dragElement = '';\n        this.textRow = 1; // text area row count\n        this.mouseDownPoint = { x: 0, y: 0 };\n        this.previousPoint = { x: 0, y: 0 }; // updates prev x and y points in mouseMove\n        this.zoomType = 'Toolbar';\n        this.isInitialTextEdited = false;\n        this.dragCanvas = false;\n        this.isFhdCustomized = false;\n        this.touchEndPoint = {};\n        this.isFhdEditing = false; // Specifies whether freehand drawing is in editing mode or not\n        this.currentDrawingShape = '';\n        this.initialPrevObj = {};\n        this.touchTime = 0;\n        this.resizedElement = '';\n        this.isImageClarity = true;\n        this.isPinching = false;\n        this.isSliding = false;\n        this.mouseDown = '';\n        this.isSliderActive = false;\n        this.arrowShape = [_index__WEBPACK_IMPORTED_MODULE_1__.ArrowheadType.None, _index__WEBPACK_IMPORTED_MODULE_1__.ArrowheadType.SolidArrow];\n        this.isTouchDblClick = false;\n        this.isMouseDown = false;\n        this.isMouseUp = false;\n        this.mouseWheel = 0;\n        this.isTransformedShape = false;\n        this.parent = parent;\n        this.addEventListener();\n    }\n    Selection.prototype.destroy = function () {\n        if (this.parent.isDestroyed) {\n            return;\n        }\n        this.removeEventListener();\n    };\n    Selection.prototype.addEventListener = function () {\n        this.parent.on('selection', this.selection, this);\n        this.parent.on('destroyed', this.destroy, this);\n    };\n    Selection.prototype.removeEventListener = function () {\n        this.parent.off('selection', this.selection);\n        this.parent.off('destroyed', this.destroy);\n    };\n    Selection.prototype.selection = function (args) {\n        var parent = this.parent;\n        this.updatePrivateVariables();\n        switch (args.prop) {\n            case 'setCursor':\n                this.setCursor(args.value['x'], args.value['y']);\n                break;\n            case 'updateActivePoint':\n                this.updateActivePoint(args.value['x'], args.value['y'], args.value['isCropSelection']);\n                break;\n            case 'updateCursorStyles':\n                this.updateCursorStyles(args.value['x'], args.value['y'], args.value['type']);\n                break;\n            case 'setTextSelection':\n                this.setTextSelection(args.value['width'], args.value['height']);\n                break;\n            case 'setActivePoint':\n                this.setActivePoint(args.value['startX'], args.value['startY']);\n                break;\n            case 'clearSelection':\n                this.clearSelection(args.value['resetCrop']);\n                break;\n            case 'calcShapeRatio':\n                this.calcShapeRatio(args.value['x'], args.value['y'], args.value['imgWidth'], args.value['imgHeight']);\n                break;\n            case 'tab':\n                this.performTabAction();\n                break;\n            case 'setDragDirection':\n                this.setDragDirection(args.value['width'], args.value['height']);\n                break;\n            case 'clearUpperCanvas':\n                if (this.isTouch) {\n                    setTimeout(function () {\n                        parent.upperCanvas.getContext('2d').clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                    }, 550);\n                }\n                break;\n            case 'resetFreehandDrawVariables':\n                this.isFhdEditing = this.isFhdPoint = false;\n                break;\n            case 'isShapeInserted':\n                this.isShapeInserted = args.value['bool'];\n                break;\n            case 'redrawShape':\n                this.redrawShape(args.value['obj']);\n                break;\n            case 'setTextBoxStylesToActObj':\n                this.setTextBoxStylesToActObj();\n                break;\n            case 'mouseDownEventHandler':\n                this.mouseDownEventHandler(args.value['e']);\n                break;\n            case 'mouseMoveEventHandler':\n                this.mouseMoveEventHandler(args.value['e']);\n                break;\n            case 'mouseUpEventHandler':\n                this.mouseUpEventHandler(args.value['e']);\n                break;\n            case 'canvasMouseDownHandler':\n                this.canvasMouseDownHandler(args.value['e']);\n                break;\n            case 'canvasMouseMoveHandler':\n                this.canvasMouseMoveHandler(args.value['e']);\n                break;\n            case 'canvasMouseUpHandler':\n                this.canvasMouseUpHandler(args.value['e']);\n                break;\n            case 'touchStartHandler':\n                this.touchStartHandler(args.value['e']);\n                break;\n            case 'keyDownEventHandler':\n                this.keyDownEventHandler(args.value['e']);\n                break;\n            case 'handleScroll':\n                this.handleScroll(args.value['e']);\n                break;\n            case 'textKeyDown':\n                setTimeout(this.textKeyDown.bind(this), 1, args.value['e']);\n                break;\n            case 'deleteItem':\n                this.deleteItem();\n                break;\n            case 'updatePrevShapeSettings':\n                this.updatePrevShapeSettings(args.value['obj']);\n                break;\n            case 'getZoomType':\n                args.value['obj']['zoomType'] = this.zoomType;\n                break;\n            case 'setZoomType':\n                this.zoomType = args.value['zoomType'];\n                break;\n            case 'setInitialTextEdit':\n                this.isInitialTextEdited = args.value['bool'];\n                break;\n            case 'setDragCanvas':\n                this.dragCanvas = args.value['bool'];\n                break;\n            case 'setFreehandDrawCustomized':\n                this.isFhdCustomized = args.value['isFreehandDrawCustomized'];\n                break;\n            case 'setTouchEndPoint':\n                this.touchEndPoint.x = args.value['x'];\n                this.touchEndPoint.y = args.value['y'];\n                break;\n            case 'getPanDown':\n                args.value['obj']['panDown'] = this.panDown;\n                break;\n            case 'setPanDown':\n                this.panDown = args.value['panDown'];\n                break;\n            case 'getFreehandDrawEditing':\n                args.value['obj']['bool'] = this.isFhdEditing;\n                break;\n            case 'setFreehandDrawEditing':\n                this.isFhdEditing = args.value['bool'];\n                break;\n            case 'getTempActObj':\n                args.value['obj']['tempObj'] = this.tempActiveObj;\n                break;\n            case 'setTempActObj':\n                this.tempActiveObj = args.value['obj'];\n                break;\n            case 'isInside':\n                this.isInside(args.value['x'], args.value['y'], args.value['z1'], args.value['z2'], args.value['z3'], args.value['z4']);\n                break;\n            case 'setDragElement':\n                this.dragElement = args.value['value'];\n                break;\n            case 'setObjSelected':\n                this.isObjSelected = args.value['bool'];\n                break;\n            case 'adjustActObjForLineArrow':\n                this.adjustActObjForLineArrow(args.value['obj']);\n                break;\n            case 'findTarget':\n                this.findTarget(args.value['x'], args.value['y'], args.value['type']);\n                break;\n            case 'getCurrentFlipState':\n                this.getCurrentFlipState();\n                break;\n            case 'setDragWidth':\n                this.setDragWidth(args.value['width']);\n                break;\n            case 'setDragHeight':\n                this.setDragHeight(args.value['setDragHeight']);\n                break;\n            case 'annotate':\n                this.currentDrawingShape = args.value['shape'];\n                if (args.value['shape'] === 'text') {\n                    parent.activeObj.textSettings.fontSize = 11;\n                    parent.activeObj.keyHistory = 'Enter Text';\n                    parent.notify('shape', { prop: 'initializeTextShape', onPropertyChange: false,\n                        value: { text: null, fontFamily: null, fontSize: null, bold: null, italic: null, strokeColor: null } });\n                }\n                else if (args.value['shape'] === 'path') {\n                    parent.activeObj.pointColl = [];\n                }\n                break;\n            case 'getCurrentDrawingShape':\n                args.value['obj']['shape'] = this.currentDrawingShape;\n                break;\n            case 'setCurrentDrawingShape':\n                this.currentDrawingShape = args.value['value'];\n                break;\n            case 'getTransRotationPoint':\n                this.getTransRotationPoint(args.value['obj'], args.value['object']);\n                break;\n            case 'adjustNEPoints':\n                this.adjustNEPoints(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle']);\n                break;\n            case 'adjustRotationPoints':\n                this.adjustRotationPoints(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle'], args.value['type'], args.value['elem']);\n                break;\n            case 'getResizeDirection':\n                this.getResizeDirection(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle']);\n                break;\n            case 'setResizedElement':\n                this.resizedElement = args.value['value'];\n                break;\n            case 'reset':\n                this.reset();\n                break;\n            case 'unWireEvent':\n                this.unwireEvent();\n                break;\n            case 'updPtCollForShpRot':\n                this.updPtCollForShpRot(args.value['obj']);\n                break;\n            case 'findImageRatio':\n                this.findImageRatio(args.value['width'], args.value['height'], args.value['obj']);\n                break;\n            case 'getNumTextValue':\n                this.getNumTextValue(args.value['obj']);\n                break;\n            case 'setImageClarity':\n                this.isImageClarity = args.value['bool'];\n                break;\n            case 'upgradeImageQuality':\n                this.upgradeImageQuality();\n                break;\n            case 'triggerShapeChange':\n                this.triggerShapeChange(args.value['shapeResizingArgs'], args.value['shapeMovingArgs'], args.value['type']);\n                break;\n            case 'applyTransformToImg':\n                this.applyTransformToImg(args.value['ctx']);\n                break;\n            case 'findTargetObj':\n                args.value['obj']['bool'] = this.findTargetObj(args.value['x'], args.value['y'], args.value['isCrop']);\n                break;\n            case 'setSliding':\n                this.isSliding = args.value['bool'];\n                break;\n            case 'setSliderActive':\n                this.isSliderActive = args.value['bool'];\n                break;\n            case 'getArrowType':\n                args.value['obj']['type'] = this.getArrowType(args.value['type']);\n                break;\n            case 'setArrowShape':\n                if (args.value['type'] === 'initial') {\n                    this.arrowShape[0] = args.value['shape'];\n                }\n                else {\n                    this.arrowShape[1] = args.value['shape'];\n                }\n                break;\n            case 'updateNWPoints':\n                this.updateNWPoints(args.value['x'], args.value['y']);\n                break;\n            case 'updateNPoints':\n                this.updateNPoints(args.value['x'], args.value['y']);\n                break;\n            case 'updateNEPoints':\n                this.updateNEPoints(args.value['x'], args.value['y']);\n                break;\n            case 'updateWPoints':\n                this.updateWPoints(args.value['x'], args.value['y']);\n                break;\n            case 'updateEPoints':\n                this.updateEPoints(args.value['x'], args.value['y']);\n                break;\n            case 'updateSWPoints':\n                this.updateSWPoints(args.value['x'], args.value['y']);\n                break;\n            case 'updateSPoints':\n                this.updateSPoints(args.value['x'], args.value['y']);\n                break;\n            case 'updateSEPoints':\n                this.updateSEPoints(args.value['x'], args.value['y']);\n                break;\n            case 'drawMaskCircle':\n                this.drawMaskCircle(args.value['x'], args.value['y']);\n                break;\n            case 'isValueUpdated':\n                this.isValueUpdated();\n                break;\n            case 'getDistance':\n                this.getDistance(args.value['x'], args.value['y']);\n                break;\n            case 'redact':\n                this.currentDrawingShape = args.value['shape'];\n                break;\n            case 'updateTransColl':\n                args.value['obj']['coll'] = this.updateTransColl(args.value['object']);\n                break;\n            case 'getTransformedShape':\n                args.value['obj']['bool'] = this.isTransformedShape;\n                break;\n            case 'setTransformedShape':\n                this.isTransformedShape = args.value['bool'];\n                break;\n            case 'rgbToHex':\n                this.rgbToHex(args.value['r'], args.value['g'], args.value['b'], args.value['a']);\n                break;\n            case 'padLeft':\n                this.padLeft(args.value['value'], args.value['length'], args.value['padChar']);\n                break;\n            case 'setTimer':\n                this.setTimer(args.value['e']);\n                break;\n            case 'targetTouches':\n                args.value['output'] = this.targetTouches(args.value['touches']);\n                break;\n            case 'calculateScale':\n                args.value['output'] = this.calculateScale(args.value['startTouches'], args.value['endTouches']);\n                break;\n            case 'beforeSaveEvent':\n                this.beforeSaveEvent(args.value['args'], args.value['e']);\n                break;\n            case 'isKeyBoardCrop':\n                args.value['output'] = this.isKeyBoardCrop(args.value['e']);\n                break;\n            case 'focusRatioBtn':\n                this.focusRatioBtn();\n                break;\n            case 'performEnterAction':\n                this.performEnterAction(args.value['e']);\n                break;\n            case 'getImagePoints':\n                args.value['output'] = this.getImagePoints(args.value['x'], args.value['y']);\n                break;\n            case 'revertPoints':\n                this.revertPoints(args.value['actPoint'], args.value['tempActiveObj']);\n                break;\n            case 'performNWResize':\n                this.performNWResize(args.value['x'], args.value['y'], args.value['tempActiveObj'], args.value['actPoint']);\n                break;\n            case 'performSEResize':\n                this.performSEResize(args.value['x'], args.value['y'], args.value['tempActiveObj'], args.value['actPoint']);\n                break;\n            case 'isMouseOutsideImg':\n                args.value['output'] = this.isMouseOutsideImg(args.value['x'], args.value['y']);\n                break;\n        }\n    };\n    Selection.prototype.getModuleName = function () {\n        return 'selection';\n    };\n    Selection.prototype.updatePrivateVariables = function () {\n        var parent = this.parent;\n        if (parent.lowerCanvas) {\n            this.lowerContext = parent.lowerCanvas.getContext('2d');\n        }\n        if (parent.upperCanvas) {\n            this.upperContext = parent.upperCanvas.getContext('2d');\n        }\n    };\n    Selection.prototype.reset = function () {\n        this.diffPoint = { x: 0, y: 0 };\n        this.oldPoint = {};\n        this.isTouch = this.isObjSelected = this.isFhdPoint = this.isShapeInserted = false;\n        this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 };\n        this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },\n            flipObjColl: [], triangle: [], triangleRatio: [], order: null };\n        this.isFirstMove = false;\n        this.cursorTargetId = this.dragElement = '';\n        this.isTouchDblClick = false;\n        this.startTouches = [];\n        this.tempTouches = [];\n        this.currMousePoint = { x: 0, y: 0 };\n        this.isPreventDragging = false;\n        this.timer = undefined;\n        this.tempObjColl = undefined;\n        this.mouseWheel = 0;\n        this.textRow = 1;\n        this.mouseDownPoint = { x: 0, y: 0 };\n        this.previousPoint = { x: 0, y: 0 };\n        this.zoomType = 'Toolbar';\n        this.isInitialTextEdited = false;\n        this.dragCanvas = this.isPinching = false;\n        this.isFhdCustomized = false;\n        this.touchEndPoint = {};\n        this.panDown = null;\n        this.isSliding = false;\n        this.isFhdEditing = false;\n        this.pathAdjustedIndex = null;\n        this.touchTime = 0;\n        this.isImageClarity = true;\n        this.currentDrawingShape = '';\n        this.initialPrevObj = {};\n        this.resizedElement = '';\n        this.mouseDown = '';\n        this.isSliderActive = false;\n        this.arrowShape = [_index__WEBPACK_IMPORTED_MODULE_1__.ArrowheadType.None, _index__WEBPACK_IMPORTED_MODULE_1__.ArrowheadType.SolidArrow];\n        this.isMouseDown = this.isMouseUp = this.isTransformedShape = false;\n    };\n    Selection.prototype.performTabAction = function () {\n        var parent = this.parent;\n        if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {\n            var allowUndoRedoPush = this.applyCurrShape(false);\n            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                value: { x: null, y: null, isMouseDown: null } });\n            if (allowUndoRedoPush) {\n                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n            }\n        }\n        parent.isKBDNavigation = true;\n    };\n    Selection.prototype.selMouseUpEvent = function () {\n        this.oldPoint.x = undefined;\n        this.oldPoint.y = undefined;\n    };\n    Selection.prototype.getMouseCursor = function (actObj, x, y, isCropSelection, isApply) {\n        var rotationCirclePoint = this.getTransRotationPoint(actObj);\n        var radius = actObj.bottomCenterCircle.radius;\n        var cursor = 'default';\n        var ratio = isApply ? 0 : ((actObj.topLeftCircle.radius * 2));\n        if (x >= (actObj.topLeftCircle.startX - ratio) &&\n            x <= (actObj.topLeftCircle.startX + ratio) &&\n            y >= (actObj.topLeftCircle.startY - ratio) &&\n            y <= (actObj.topLeftCircle.startY + ratio)) {\n            cursor = 'nw-resize';\n        }\n        else if (x >= (actObj.topLeftCircle.startX - ratio) &&\n            x <= (actObj.topRightCircle.startX - ratio) &&\n            y >= (actObj.topCenterCircle.startY - ratio) &&\n            y <= (actObj.topCenterCircle.startY + ratio)) {\n            cursor = 'n-resize';\n        }\n        else if (x >= (actObj.topRightCircle.startX - ratio) &&\n            x <= (actObj.topRightCircle.startX + ratio) &&\n            y >= (actObj.topRightCircle.startY - ratio) &&\n            y <= (actObj.topRightCircle.startY + ratio)) {\n            cursor = 'ne-resize';\n        }\n        else if (x >= (actObj.centerLeftCircle.startX - ratio) &&\n            x <= (actObj.centerLeftCircle.startX + ratio) &&\n            y >= (actObj.topLeftCircle.startY - ratio) &&\n            y <= (actObj.bottomLeftCircle.startY - ratio)) {\n            cursor = 'w-resize';\n        }\n        else if (x >= (actObj.centerRightCircle.startX - ratio) &&\n            x <= (actObj.centerRightCircle.startX + ratio) &&\n            y >= (actObj.topRightCircle.startY - ratio) &&\n            y <= (actObj.bottomRightCircle.startY - ratio)) {\n            cursor = 'e-resize';\n        }\n        else if (x >= (actObj.bottomLeftCircle.startX - ratio) &&\n            x <= (actObj.bottomLeftCircle.startX + ratio) &&\n            y >= (actObj.bottomLeftCircle.startY - ratio) &&\n            y <= (actObj.bottomLeftCircle.startY + ratio)) {\n            cursor = 'sw-resize';\n        }\n        else if (x >= (actObj.bottomLeftCircle.startX - ratio) &&\n            x <= (actObj.bottomRightCircle.startX - ratio) &&\n            y >= (actObj.bottomCenterCircle.startY - ratio) &&\n            y <= (actObj.bottomCenterCircle.startY + ratio)) {\n            cursor = 's-resize';\n        }\n        else if (x >= (actObj.bottomRightCircle.startX - ratio) &&\n            x <= (actObj.bottomRightCircle.startX + ratio) &&\n            y >= (actObj.bottomRightCircle.startY - ratio) &&\n            y <= (actObj.bottomRightCircle.startY + ratio)) {\n            cursor = 'se-resize';\n        }\n        else if ((x >= actObj.activePoint.startX &&\n            x <= actObj.activePoint.endX) && (y >= actObj.activePoint.startY &&\n            y <= actObj.activePoint.endY)) {\n            if (isCropSelection) {\n                cursor = 'grab';\n            }\n            else {\n                cursor = 'move';\n            }\n        }\n        else if (rotationCirclePoint && !isApply &&\n            x >= (rotationCirclePoint.x - (radius + 2)) &&\n            x <= rotationCirclePoint.x + (radius + 2) &&\n            y >= rotationCirclePoint.y - (radius + 2) &&\n            y <= rotationCirclePoint.y + (radius + 2)) {\n            cursor = 'grabbing';\n        }\n        else {\n            cursor = 'default';\n        }\n        return cursor;\n    };\n    Selection.prototype.setCursor = function (x, y) {\n        var parent = this.parent;\n        parent.upperCanvas.style.cursor = parent.cursor = 'default';\n        var frameObject = { bool: null };\n        parent.notify('toolbar', { prop: 'getFrameToolbar', onPropertyChange: false, value: { obj: frameObject } });\n        if (parent.isResize || this.isSliding || frameObject['bool']) {\n            parent.upperCanvas.style.cursor = 'default';\n            return;\n        }\n        var isCropSelection = false;\n        var splitWords;\n        if (parent.activeObj.shape) {\n            splitWords = parent.activeObj.shape.split('-');\n        }\n        if ((!splitWords && parent.currObjType.isCustomCrop) || (splitWords && splitWords[0] === 'crop')) {\n            isCropSelection = true;\n        }\n        if (parent.currObjType.isDragging) {\n            if (this.dragElement === '') {\n                parent.upperCanvas.style.cursor = parent.cursor = 'move';\n            }\n            else {\n                parent.upperCanvas.style.cursor = parent.cursor = this.dragElement;\n            }\n            return;\n        }\n        if (parent.togglePen) {\n            parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';\n            if (parent.isMaskImage) {\n                this.drawMaskCircle(x, y);\n                parent.upperCanvas.style.cursor = 'none';\n            }\n            return;\n        }\n        if (parent.activeObj.shape) {\n            this.setCursorForActObj(splitWords, isCropSelection, x, y);\n        }\n        if (parent.cursor === 'default' || parent.cursor === 'grab') {\n            var highestOrder = this.getHighestOrder();\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var tempShapeColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.shapeColl, [], true);\n            var objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n            var isShape = false;\n            while (highestOrder > 0) {\n                isShape = false;\n                for (var i = tempShapeColl.length - 1; i >= 0; i--) {\n                    if (tempShapeColl[i].order === highestOrder) {\n                        isShape = true;\n                        if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf('pen') > -1) {\n                            if (parent.pointColl[0] && (parent.cursor !== 'grab' || !isCropSelection)\n                                && !parent.currObjType.isDragging && !parent.currObjType.isResize) {\n                                var points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.points, [], true);\n                                if (!isCropSelection) {\n                                    this.setCursorForFreehandDrawing(x, y, parent.upperCanvas, tempShapeColl[i].id);\n                                }\n                                parent.points = points;\n                            }\n                        }\n                        else {\n                            parent.objColl = [];\n                            parent.objColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, tempShapeColl[i], null, true));\n                            var cursor = parent.upperCanvas.style.cursor;\n                            if (parent.objColl.length > 0 && (parent.cursor !== 'grab' || !isCropSelection)) {\n                                this.setCursorFromObj(x, y, parent.objColl, parent.upperCanvas, isCropSelection);\n                            }\n                            if (cursor === 'grab' && parent.cursor === 'default') {\n                                parent.upperCanvas.style.cursor = parent.cursor = 'grab';\n                            }\n                        }\n                    }\n                    else if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(tempShapeColl[i].order)) {\n                        isShape = true;\n                    }\n                }\n                if (parent.cursor !== 'default' && parent.cursor !== 'grab') {\n                    break;\n                }\n                else if (isShape) {\n                    var isBreak = false;\n                    while (!isBreak && highestOrder > 0) {\n                        for (var a = 0; a < tempShapeColl.length; a++) {\n                            if (tempShapeColl[a].order === highestOrder - 1) {\n                                isBreak = true;\n                                break;\n                            }\n                        }\n                        highestOrder--;\n                        if (!isBreak) {\n                            highestOrder--;\n                        }\n                    }\n                }\n            }\n            parent.objColl = objColl;\n            if (parent.cursor === 'default' || parent.cursor === 'grab') {\n                if (parent.togglePan) {\n                    parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';\n                }\n            }\n        }\n        if (this.currentDrawingShape !== '' && (parent.cursor === 'default' || parent.cursor === 'grab')) {\n            parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';\n        }\n    };\n    Selection.prototype.getHighestOrder = function () {\n        var highestOrder = 0;\n        for (var i = 0; i < this.parent.shapeColl.length; i++) {\n            if (this.parent.shapeColl[i].order > highestOrder) {\n                highestOrder = this.parent.shapeColl[i].order;\n            }\n        }\n        return highestOrder;\n    };\n    Selection.prototype.drawMaskCircle = function (x, y) {\n        var parent = this.parent;\n        if (parent.isMaskImage) {\n            var radius = parent.activeObj.strokeSettings.strokeWidth * 2;\n            var canvasDraw = parent.maskCanvas.getContext('2d');\n            canvasDraw.clearRect(0, 0, parent.maskCanvas.width, parent.maskCanvas.height);\n            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;\n            canvasDraw.strokeStyle = '#fff';\n            canvasDraw.beginPath();\n            canvasDraw.ellipse(x, y, radius / 2, radius / 2, 0, 0, 2 * Math.PI, false);\n            canvasDraw.fill();\n            canvasDraw.stroke();\n            canvasDraw.closePath();\n            parent.maskCanvas.style.cursor = 'none';\n        }\n    };\n    Selection.prototype.setCursorForActObj = function (splitWords, isCropSelection, x, y) {\n        var parent = this.parent;\n        if (parent.activeObj.horTopLine !== undefined) {\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (splitWords === undefined && parent.currObjType.isCustomCrop) {\n                isCropSelection = true;\n            }\n            else if (splitWords !== undefined && splitWords[0] === 'crop') {\n                isCropSelection = true;\n            }\n            if (!isCropSelection && parent.togglePan) {\n                parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';\n            }\n            var cursor = parent.upperCanvas.style.cursor;\n            var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n            this.cursorTargetId = actObj.currIndex;\n            var degree = void 0;\n            if (actObj.shapeDegree === 0) {\n                degree = parent.transform.degree;\n            }\n            else {\n                degree = parent.transform.degree - actObj.shapeDegree;\n            }\n            if (degree < 0) {\n                degree = 360 + degree;\n            }\n            if (actObj.shape === 'line' || actObj.shape === 'arrow') {\n                this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);\n            }\n            else if (actObj.shape === 'path') {\n                this.setCursorForPath(actObj, x, y, parent.upperCanvas);\n            }\n            else if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {\n                this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);\n            }\n            else {\n                parent.upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, false);\n                var cursorColl = ['n-resize', 's-resize', 'e-resize', 'w-resize'];\n                if ((actObj.shape === 'text') && cursorColl.indexOf(parent.cursor) > -1) {\n                    parent.upperCanvas.style.cursor = parent.cursor = 'move';\n                }\n            }\n            if (cursor === 'default' && parent.cursor === 'default' && isCropSelection) {\n                parent.upperCanvas.style.cursor = parent.cursor = 'grab';\n            }\n            if (cursor === 'grab' && parent.cursor === 'default') {\n                parent.upperCanvas.style.cursor = parent.cursor = 'grab';\n            }\n        }\n        else if (parent.togglePan && !parent.togglePen) {\n            parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';\n        }\n        else {\n            if (parent.currObjType.isCustomCrop || parent.togglePen) {\n                parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';\n            }\n            else {\n                parent.upperCanvas.style.cursor = parent.cursor = 'default';\n            }\n        }\n    };\n    Selection.prototype.setCursorForPath = function (actObj, x, y, upperCanvas) {\n        this.setCursorForLineArrow(actObj, x, y, upperCanvas);\n        var parent = this.parent;\n        if (parent.cursor === 'default') {\n            var obj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, actObj, null, true);\n            var isMove = false;\n            for (var i = 1, len = actObj.pointColl.length; i < len; i++) {\n                if (isMove) {\n                    break;\n                }\n                obj.activePoint.startX = actObj.pointColl[i - 1].x;\n                obj.activePoint.startY = actObj.pointColl[i - 1].y;\n                obj.activePoint.endX = actObj.pointColl[i].x;\n                obj.activePoint.endY = actObj.pointColl[i].y;\n                parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,\n                    value: { obj: obj } });\n                var radius = actObj.topLeftCircle.radius;\n                for (var j = 0, jLen = obj.pointColl.length; j < jLen; j++) {\n                    var point = obj.pointColl[j];\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x - (radius * 2)) &&\n                        !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x + (radius * 2)) &&\n                        !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y - (radius * 2)) &&\n                        !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y + (radius * 2)) &&\n                        x >= (point.x - (radius * 2)) &&\n                        x <= (point.x + (radius * 2)) &&\n                        y >= (point.y - (radius * 2)) &&\n                        y <= (point.y + (radius * 2))) {\n                        upperCanvas.style.cursor = parent.cursor = 'move';\n                        isMove = true;\n                        break;\n                    }\n                    else {\n                        upperCanvas.style.cursor = parent.cursor = 'default';\n                    }\n                }\n            }\n        }\n        return parent.cursor;\n    };\n    Selection.prototype.setCursorForLineArrow = function (actObj, x, y, upperCanvas) {\n        var index;\n        var radius = actObj.topLeftCircle.radius;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(actObj.pointColl)) {\n            return index;\n        }\n        for (var i = 0, len = actObj.pointColl.length; i < len; i++) {\n            var point = actObj.pointColl[i];\n            if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&\n                y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {\n                upperCanvas.style.cursor = this.parent.cursor = 'move';\n                index = i;\n                break;\n            }\n            else {\n                upperCanvas.style.cursor = this.parent.cursor = 'default';\n            }\n        }\n        return index;\n    };\n    Selection.prototype.setCursorForRotatedObject = function (actObj, x, y, upperCanvas) {\n        this.resizedElement = '';\n        var parent = this.parent;\n        var radius = actObj.bottomCenterCircle.radius;\n        var horTP = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)];\n        var horTP1 = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)];\n        var verLP = actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)];\n        var verRP = actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)];\n        var horBP = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)];\n        var horBP1 = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)];\n        var rotCP = actObj.rotationCirclePointColl;\n        var horTP0 = actObj.horTopLinePointColl[0];\n        var horBP0 = actObj.horBottomLinePointColl[0];\n        if (x >= (horTP0.x - (radius + 2)) && x <= (horTP0.x + (radius + 2)) && y >= (horTP0.y - (radius + 2)) &&\n            y <= (horTP0.y + (radius + 2))) {\n            upperCanvas.style.cursor = parent.cursor = 'nw-resize';\n        }\n        else if (x >= (horTP.x - 5) && x <= (horTP.x + 5) && y >= (horTP.y - 5) && y <= (horTP.y + 5)) {\n            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'n-resize';\n        }\n        else if (x >= (horTP1.x - (radius + 2)) && x <= (horTP1.x + (radius + 2)) && y >= (horTP1.y - (radius + 2)) &&\n            y <= (horTP1.y + (radius + 2))) {\n            upperCanvas.style.cursor = parent.cursor = 'ne-resize';\n        }\n        else if (x >= (verLP.x - 5) && x <= (verLP.x + 5) && y >= (verLP.y - 5) && y <= (verLP.y + 5)) {\n            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'w-resize';\n        }\n        else if (x >= (verRP.x - 5) && x <= (verRP.x + 5) && y >= (verRP.y - 5) && y <= (verRP.y + 5)) {\n            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'e-resize';\n        }\n        else if (x >= (horBP0.x - (radius + 2)) && x <= (horBP0.x + (radius + 2)) && y >= (horBP0.y - (radius + 2)) &&\n            y <= (horBP0.y + (radius + 2))) {\n            upperCanvas.style.cursor = parent.cursor = 'sw-resize';\n        }\n        else if (x >= (horBP.x - 5) && x <= (horBP.x + 5) && y >= (horBP.y - 5) && y <= (horBP.y + 5)) {\n            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 's-resize';\n        }\n        else if (x >= (horBP1.x - (radius + 2)) && x <= (horBP1.x + (radius + 2)) && y >= (horBP1.y - (radius + 2)) &&\n            y <= (horBP1.y + (radius + 2))) {\n            upperCanvas.style.cursor = parent.cursor = 'se-resize';\n        }\n        else if (rotCP && x >= (rotCP.x - (radius + 2)) && x <= rotCP.x + (radius + 2) && y >= rotCP.y - (radius + 2) &&\n            y <= rotCP.y + (radius + 2)) {\n            upperCanvas.style.cursor = parent.cursor = 'grabbing';\n        }\n        else {\n            upperCanvas.style.cursor = parent.cursor = 'default';\n            var isPointsInsideRectangle = this.getRectanglePoints(actObj.activePoint.startX, actObj.activePoint.startY, actObj.activePoint.width, actObj.activePoint.height, actObj.rotatedAngle * (180 / Math.PI), x, y);\n            if (isPointsInsideRectangle) {\n                upperCanvas.style.cursor = parent.cursor = 'move';\n            }\n        }\n        if (parent.cursor === 'default') {\n            for (var i = 0, len = actObj.horTopLinePointColl.length; i < len; i++) {\n                var horTP_1 = actObj.horTopLinePointColl[i];\n                if (x >= (horTP_1.x - 5) && x <= (horTP_1.x + 5) && y >= (horTP_1.y - 5) && y <= (horTP_1.y + 5)) {\n                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'n-resize';\n                    break;\n                }\n            }\n        }\n        if (parent.cursor === 'default') {\n            for (var i = 0, len = actObj.horBottomLinePointColl.length; i < len; i++) {\n                var horBP_1 = actObj.horBottomLinePointColl[i];\n                if (x >= (horBP_1.x - 5) && x <= (horBP_1.x + 5) && y >= (horBP_1.y - 5) && y <= (horBP_1.y + 5)) {\n                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 's-resize';\n                    break;\n                }\n            }\n        }\n        if (parent.cursor === 'default') {\n            for (var i = 0, len = actObj.verLeftLinePointColl.length; i < len; i++) {\n                var verLP_1 = actObj.verLeftLinePointColl[i];\n                if (x >= (verLP_1.x - 5) && x <= (verLP_1.x + 5) && y >= (verLP_1.y - 5) && y <= (verLP_1.y + 5)) {\n                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'w-resize';\n                    break;\n                }\n            }\n        }\n        if (parent.cursor === 'default') {\n            for (var i = 0, len = actObj.verRightLinePointColl.length; i < len; i++) {\n                var verRP_1 = actObj.verRightLinePointColl[i];\n                if (x >= (verRP_1.x - 5) && x <= (verRP_1.x + 5) && y >= (verRP_1.y - 5) && y <= (verRP_1.y + 5)) {\n                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'e-resize';\n                    break;\n                }\n            }\n        }\n        this.adjustCursorStylesForRotatedState(actObj);\n        return parent.cursor;\n    };\n    Selection.prototype.adjustCursorStylesForRotatedState = function (actObj) {\n        var parent = this.parent;\n        var length = actObj.rotatedAngle * (180 / Math.PI);\n        length = length > 0 ? Math.floor(length) : Math.ceil(length);\n        if ((length >= 92 && length <= 182) || (length >= -178 && length <= -88)) {\n            var cursorMap = { 'nw-resize': 'ne-resize', 'n-resize': 's-resize',\n                'ne-resize': 'nw-resize', 'w-resize': 'e-resize', 'e-resize': 'w-resize',\n                'sw-resize': 'se-resize', 's-resize': 'n-resize', 'se-resize': 'sw-resize'\n            };\n            if (parent.cursor in cursorMap) {\n                parent.cursor = cursorMap[parent.cursor];\n            }\n        }\n        parent.upperCanvas.style.cursor = this.getResizeElement((actObj.rotatedAngle * (180 / Math.PI)), parent.cursor);\n        return parent.cursor;\n    };\n    Selection.prototype.getResizeElement = function (degree, element) {\n        var resizeMappings = [];\n        switch (element) {\n            case 'nw-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 'nw-resize'], [22.5, 67.5, 'n-resize'], [67.5, 112.5, 'ne-resize'],\n                    [112.5, 157.5, 'e-resize'], [157.5, 202.5, 'se-resize'],\n                    [202.5, 247.5, 's-resize'], [247.5, 292.5, 'sw-resize'],\n                    [292.5, 337.5, 'w-resize']\n                ];\n                break;\n            case 'n-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 'n-resize'], [22.5, 67.5, 'ne-resize'], [67.5, 112.5, 'e-resize'],\n                    [112.5, 157.5, 'se-resize'], [157.5, 202.5, 's-resize'], [202.5, 247.5, 'sw-resize'],\n                    [247.5, 292.5, 'w-resize'], [292.5, 337.5, 'nw-resize']\n                ];\n                break;\n            case 'ne-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 'ne-resize'], [22.5, 67.5, 'e-resize'],\n                    [67.5, 112.5, 'se-resize'], [112.5, 157.5, 's-resize'], [157.5, 202.5, 'sw-resize'],\n                    [202.5, 247.5, 'w-resize'], [247.5, 292.5, 'nw-resize'], [292.5, 337.5, 'n-resize']\n                ];\n                break;\n            case 'e-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 'e-resize'], [22.5, 67.5, 'se-resize'], [67.5, 112.5, 's-resize'],\n                    [112.5, 157.5, 'sw-resize'], [157.5, 202.5, 'w-resize'], [202.5, 247.5, 'nw-resize'],\n                    [247.5, 292.5, 'n-resize'], [292.5, 337.5, 'ne-resize']\n                ];\n                break;\n            case 'se-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 'se-resize'], [22.5, 67.5, 's-resize'], [67.5, 112.5, 'sw-resize'],\n                    [112.5, 157.5, 'w-resize'], [157.5, 202.5, 'nw-resize'], [202.5, 247.5, 'n-resize'],\n                    [247.5, 292.5, 'ne-resize'], [292.5, 337.5, 'e-resize']\n                ];\n                break;\n            case 's-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 's-resize'], [22.5, 67.5, 'sw-resize'], [67.5, 112.5, 'w-resize'],\n                    [112.5, 157.5, 'nw-resize'], [157.5, 202.5, 'n-resize'], [202.5, 247.5, 'ne-resize'],\n                    [247.5, 292.5, 'e-resize'], [292.5, 337.5, 'se-resize']\n                ];\n                break;\n            case 'sw-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 'sw-resize'], [22.5, 67.5, 'w-resize'], [67.5, 112.5, 'nw-resize'],\n                    [112.5, 157.5, 'n-resize'], [157.5, 202.5, 'ne-resize'], [202.5, 247.5, 'e-resize'],\n                    [247.5, 292.5, 'se-resize'], [292.5, 337.5, 's-resize']\n                ];\n                break;\n            case 'w-resize':\n                resizeMappings = [\n                    [337.5, 22.5, 'w-resize'], [22.5, 67.5, 'nw-resize'], [67.5, 112.5, 'n-resize'],\n                    [112.5, 157.5, 'ne-resize'], [157.5, 202.5, 'e-resize'], [202.5, 247.5, 'se-resize'],\n                    [247.5, 292.5, 's-resize'], [292.5, 337.5, 'sw-resize']\n                ];\n                break;\n        }\n        var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;\n        for (var _i = 0, resizeMappings_1 = resizeMappings; _i < resizeMappings_1.length; _i++) {\n            var _a = resizeMappings_1[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];\n            if ((positiveDegree > startDegree && positiveDegree <= endDegree) ||\n                (positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree)) {\n                return resizeElement;\n            }\n        }\n        return element;\n    };\n    Selection.prototype.setCursorForFreehandDrawing = function (x, y, upperCanvas, id) {\n        var upperContext = upperCanvas.getContext('2d');\n        var parent = this.parent;\n        var textArea = document.querySelector('#' + parent.element.id + '_textArea');\n        var isEntered = false;\n        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,\n            value: { index: -1 } });\n        var sPoints;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (id && id !== parent.pointColl[n].id) {\n                continue;\n            }\n            var obj = { selPointColl: {} };\n            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: obj } });\n            sPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], obj['selPointColl'][n].points, []);\n            parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n            var ptc = parent.pointColl[n];\n            parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });\n            var len = sPoints.length;\n            for (var l = 0; l < len; l++) {\n                if (l !== 0) {\n                    var isInside = false;\n                    if (sPoints[l - 1] && sPoints[l]) {\n                        isInside = this.isInside(x, y, sPoints[l - 1].x, sPoints[l - 1].y, sPoints[l].x, sPoints[l].y);\n                    }\n                    if (isInside) {\n                        this.isFhdPoint = true;\n                        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,\n                            value: { index: n } });\n                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,\n                            value: { strokeColor: null, strokeWidth: null } });\n                        upperCanvas.style.cursor = parent.cursor = 'pointer';\n                        isEntered = true;\n                        break;\n                    }\n                    else if (!this.isFhdEditing || ptc.isSelected) {\n                        if (this.isFhdPoint || this.isFhdEditing) {\n                            upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);\n                            if (parent.activeObj.shape && textArea.style.display === 'none') {\n                                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });\n                            }\n                        }\n                        if (this.isFhdEditing) {\n                            var indexObj = { freehandSelectedIndex: -1 };\n                            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });\n                            var strokeColor = parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;\n                            var strokeWidth = parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth;\n                            parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,\n                                value: { strokeColor: strokeColor, strokeWidth: strokeWidth } });\n                        }\n                        else {\n                            parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,\n                                value: { index: null } });\n                        }\n                        this.isFhdPoint = false;\n                    }\n                }\n                else {\n                    var pt = parent.points[l];\n                    if (x > pt.x - ptc.strokeWidth && x < pt.x + ptc.strokeWidth && y > pt.y - ptc.strokeWidth &&\n                        y < pt.y + ptc.strokeWidth) {\n                        this.isFhdPoint = true;\n                        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false, value: { index: n } });\n                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false, value: { strokeColor: null, strokeWidth: null } });\n                        upperCanvas.style.cursor = parent.cursor = 'pointer';\n                        isEntered = true;\n                        break;\n                    }\n                    else if (!this.isFhdEditing || ptc.isSelected) {\n                        if (this.isFhdPoint || this.isFhdEditing) {\n                            upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);\n                            if (parent.activeObj.shape && textArea.style.display === 'none') {\n                                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });\n                            }\n                        }\n                        if (this.isFhdEditing) {\n                            var indexObj = { freehandSelectedIndex: -1 };\n                            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });\n                            var strokeColor = parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;\n                            var strokeWidth = parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth;\n                            parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,\n                                value: { strokeColor: strokeColor, strokeWidth: strokeWidth } });\n                        }\n                        this.isFhdPoint = false;\n                    }\n                }\n            }\n            if (isEntered) {\n                break;\n            }\n        }\n    };\n    Selection.prototype.setCursorFromObj = function (x, y, obj, upperCanvas, isCropSelection) {\n        var parent = this.parent;\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (parent.cursor === 'move') {\n                return;\n            }\n            var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, obj[i], {}, true);\n            if (actObj.activePoint.width === 0 && actObj.activePoint.height === 0) {\n                obj.splice(i, 1);\n                return;\n            }\n            this.cursorTargetId = actObj.currIndex;\n            if (actObj.shape === 'line' || actObj.shape === 'arrow') {\n                this.setCursorForLineArrow(actObj, x, y, upperCanvas);\n            }\n            else if (actObj.shape === 'path') {\n                this.setCursorForPath(actObj, x, y, upperCanvas);\n            }\n            else if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {\n                this.setCursorForRotatedObject(actObj, x, y, upperCanvas);\n            }\n            else {\n                upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, true);\n            }\n        }\n    };\n    Selection.prototype.isInside = function (x, y, z1, z2, z3, z4) {\n        var x1 = Math.min(z1, z3);\n        var x2 = Math.max(z1, z3);\n        var y1 = Math.min(z2, z4);\n        var y2 = Math.max(z2, z4);\n        if ((x1 <= x && x <= x2) && (y1 <= y && y <= y2)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Selection.prototype.preventResizing = function (tempActiveObj) {\n        var parent = this.parent;\n        if (parent.activeObj.preventShapeDragOut && this.isShapeDragOut()) {\n            var actPoint = parent.activeObj.activePoint;\n            actPoint.startX = tempActiveObj.activePoint.startX;\n            actPoint.startY = tempActiveObj.activePoint.startY;\n            actPoint.endX = tempActiveObj.activePoint.endX;\n            actPoint.endY = tempActiveObj.activePoint.endY;\n            actPoint.width = tempActiveObj.activePoint.width;\n            actPoint.height = tempActiveObj.activePoint.height;\n            parent.activeObj.rotatedAngle = tempActiveObj.rotatedAngle;\n            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false,\n                value: { actPoint: actPoint, obj: parent.activeObj, isMouseMove: null, x: null, y: null } });\n        }\n    };\n    Selection.prototype.updateActivePoint = function (x, y, isCropSelection) {\n        var parent = this.parent;\n        var obj = { width: 0, height: 0 };\n        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY;\n        var _b = parent.activeObj.activePoint, width = _b.width, height = _b.height;\n        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,\n            value: { width: width, height: height, obj: obj, isImgShape: null } });\n        var previousShapeSettings = this.updatePrevShapeSettings();\n        var shapeResizingArgs = { cancel: false, action: 'resize', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };\n        var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };\n        this.shapeResizingArgs = shapeResizingArgs;\n        this.shapeMovingArgs = shapeMovingArgs;\n        if (parent.activeObj.shape === 'text' && this.dragElement !== '') {\n            parent.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,\n                value: { obj: parent.activeObj, isTextArea: null } });\n        }\n        if (this.currentDrawingShape !== '' && (this.dragElement === '' || this.dragElement === 'move') && parent.isShapeDrawing) {\n            var shapeColl = ['line', 'arrow', 'path'];\n            if (shapeColl.indexOf(parent.activeObj.shape) > -1) {\n                this.dragElement = 'e-resize';\n            }\n            else {\n                if (x > startX && y > startY) {\n                    this.dragElement = 'se-resize';\n                }\n                else if (x < startX && y > startY) {\n                    this.dragElement = 'sw-resize';\n                }\n                else if (x > startX && y < startY) {\n                    this.dragElement = 'ne-resize';\n                }\n                else if (x < startX && y < startY) {\n                    this.dragElement = 'nw-resize';\n                }\n            }\n        }\n        if (parent.activeObj.shape === 'arrow') {\n            if (Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2) > 0) {\n                parent.activeObj.rotatedAngle = -Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2);\n            }\n            else {\n                parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2));\n            }\n        }\n        var degree;\n        var isHorizontalflip = false;\n        var isVerticalflip = false;\n        if (isCropSelection && parent.transform.straighten !== 0 && this.isMouseOutsideImg(x, y)) {\n            return;\n        }\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        var splitWords;\n        var cropResize;\n        if (parent.activeObj.shape !== undefined) {\n            splitWords = parent.activeObj.shape.split('-');\n        }\n        if (splitWords !== undefined && splitWords[0] === 'crop') {\n            cropResize = true;\n        }\n        switch (this.dragElement.toLowerCase()) {\n            case 'nw-resize':\n                this.updateNWPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 'n-resize':\n                this.updateNPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 'ne-resize':\n                this.updateNEPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 'w-resize':\n                this.updateWPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 'e-resize':\n                this.updateEPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 'sw-resize':\n                this.updateSWPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 's-resize':\n                this.updateSPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 'se-resize':\n                this.updateSEPoints(x, y);\n                this.preventResizing(tempActiveObj);\n                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,\n                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });\n                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');\n                break;\n            case 'grabbing':\n                if (Math.atan2(x - (startX + (width / 2)), y - (startY + (height / 2))) > 0) {\n                    parent.activeObj.rotatedAngle = -Math.atan2(x - (startX + (width / 2)), y - (startY + (height / 2)));\n                }\n                else {\n                    parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - (startX + (width / 2)), y - (startY + (height / 2))));\n                }\n                if (parent.activeObj.shapeDegree === 0) {\n                    degree = parent.transform.degree;\n                }\n                else {\n                    degree = parent.transform.degree - parent.activeObj.shapeDegree;\n                }\n                if (degree < 0) {\n                    degree = 360 + degree;\n                }\n                for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {\n                    if (parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {\n                        isHorizontalflip = true;\n                    }\n                    else if (parent.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {\n                        isVerticalflip = true;\n                    }\n                }\n                parent.activeObj.rotatedAngle -= (degree * (Math.PI / 180));\n                if (degree === 0 || degree === 360) {\n                    if (isVerticalflip) {\n                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));\n                    }\n                }\n                else if (degree === 90 || degree === -270) {\n                    if (isHorizontalflip) {\n                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));\n                    }\n                }\n                else if (degree === 180 || degree === -180) {\n                    if (isVerticalflip) {\n                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));\n                    }\n                }\n                else if (degree === 270 || degree === -90) {\n                    if (isHorizontalflip) {\n                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));\n                    }\n                }\n                this.preventResizing(tempActiveObj);\n                break;\n            case 'pathdrag':\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.pathAdjustedIndex)) {\n                    parent.activeObj.pointColl[this.pathAdjustedIndex].x = x;\n                    parent.activeObj.pointColl[this.pathAdjustedIndex].y = y;\n                }\n                break;\n            default:\n                if (!isCropSelection && !parent.currObjType.isCustomCrop) {\n                    var activePoint = parent.activeObj.activePoint;\n                    if (this.dragPoint.startX) {\n                        var width_1 = (this.dragPoint.endX - this.previousPoint.x);\n                        var height_1 = (this.dragPoint.endY - this.previousPoint.y);\n                        activePoint.startX += width_1;\n                        activePoint.endX += width_1;\n                        activePoint.startY += height_1;\n                        activePoint.endY += height_1;\n                        startX = activePoint.startX;\n                        startY = activePoint.startY;\n                        if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' &&\n                            parent.activeObj.rotationCirclePointColl) {\n                            parent.activeObj.rotationCirclePointColl.x += width_1;\n                            parent.activeObj.rotationCirclePointColl.y += height_1;\n                            parent.activeObj.rotationCirclePoint.x += width_1;\n                            parent.activeObj.rotationCirclePoint.y += height_1;\n                        }\n                        if (parent.activeObj.shape === 'path') {\n                            for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {\n                                parent.activeObj.pointColl[i].x += width_1;\n                                parent.activeObj.pointColl[i].y += height_1;\n                            }\n                        }\n                        if ((!this.isPreventDragging && this.isShapeDragOut()) && (parent.activeObj.preventShapeDragOut || parent.activeObj.shape === 'redact' || cropResize)) {\n                            activePoint.startX -= width_1;\n                            activePoint.endX -= width_1;\n                            activePoint.startY -= height_1;\n                            activePoint.endY -= height_1;\n                            if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' &&\n                                parent.activeObj.rotationCirclePointColl) {\n                                parent.activeObj.rotationCirclePointColl.x -= width_1;\n                                parent.activeObj.rotationCirclePointColl.y -= height_1;\n                                parent.activeObj.rotationCirclePoint.x -= width_1;\n                                parent.activeObj.rotationCirclePoint.y -= height_1;\n                            }\n                            else if (parent.activeObj.shape === 'path') {\n                                for (var l = 0, len = parent.activeObj.pointColl.length; l < len; l++) {\n                                    parent.activeObj.pointColl[l].x -= width_1;\n                                    parent.activeObj.pointColl[l].y -= height_1;\n                                }\n                            }\n                            if (parent.activeObj.rotatedAngle === 0) {\n                                var tempEndX = parent.activeObj.activePoint.endX;\n                                var tempEndY = parent.activeObj.activePoint.endY;\n                                if (parent.activeObj.shape === 'path') {\n                                    parent.activeObj.activePoint = parent.getSquarePointForPath(parent.activeObj);\n                                }\n                                this.setDragWidth(width_1);\n                                this.setDragHeight(height_1);\n                                var currObj = parent.activeObj;\n                                var xDiff = currObj.activePoint.endX - tempEndX;\n                                var yDiff = currObj.activePoint.endY - tempEndY;\n                                if (currObj.shape === 'path') {\n                                    for (var l = 0, len = currObj.pointColl.length; l < len; l++) {\n                                        currObj.pointColl[l].x += xDiff;\n                                        currObj.pointColl[l].y += yDiff;\n                                    }\n                                }\n                            }\n                            else {\n                                parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });\n                            }\n                        }\n                    }\n                    else {\n                        activePoint.startX = x < this.mouseDownPoint.x ? x : this.mouseDownPoint.x;\n                        activePoint.startY = y < this.mouseDownPoint.y ? y : this.mouseDownPoint.y;\n                        x = x < this.mouseDownPoint.x ? this.mouseDownPoint.x : x;\n                        y = y < this.mouseDownPoint.y ? this.mouseDownPoint.y : y;\n                        activePoint.endX = x;\n                        activePoint.endY = y;\n                    }\n                    this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'move');\n                }\n                break;\n        }\n    };\n    Selection.prototype.isShapeDragOut = function () {\n        var parent = this.parent;\n        var isShapeDragOut = false;\n        var allowPreventing = false;\n        var shape = parent.activeObj.shape;\n        if (parent.activeObj.preventShapeDragOut) {\n            allowPreventing = true;\n        }\n        else if (parent.activeObj.rotatedAngle === 0 &&\n            (shape !== 'line' && shape !== 'arrow' && shape !== 'path')) {\n            allowPreventing = true;\n        }\n        if (allowPreventing) {\n            var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;\n            if (shape === 'path') {\n                var path = parent.getSquarePointForPath(parent.activeObj);\n                startX = path.startX;\n                startY = path.startY;\n                endX = path.endX;\n                endY = path.endY;\n            }\n            if (parent.activeObj.rotatedAngle === 0 || shape === 'arrow') {\n                isShapeDragOut = this.isObjOutsideImg(startX, startY, endX, endY, shape);\n            }\n            else {\n                var obj = { isIntersect: null, arr: null };\n                parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });\n                parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: obj } });\n                if (obj['arr'][0] || obj['arr'][1] || obj['arr'][2] || obj['arr'][3]) {\n                    isShapeDragOut = true;\n                }\n                else {\n                    isShapeDragOut = this.isObjOutsideImg(startX, startY, endX, endY, shape);\n                }\n            }\n        }\n        return isShapeDragOut;\n    };\n    Selection.prototype.isObjOutsideImg = function (startX, startY, endX, endY, shape) {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        if (startX < destLeft || startY < destTop || endX > destLeft + destWidth ||\n            endY > destTop + destHeight || ((shape === 'line' || shape === 'arrow') &&\n            (startX > destLeft + destWidth || startY > destTop + destHeight ||\n                endX < destLeft || endY < destTop))) {\n            return true;\n        }\n        return false;\n    };\n    Selection.prototype.triggerShapeChange = function (shapeResizingArgs, shapeMovingArgs, type) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        actPoint.width = actPoint.endX - actPoint.startX;\n        actPoint.height = actPoint.endY - actPoint.startY;\n        var currentShapeSettings = this.updatePrevShapeSettings();\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.shapeResizingArgs) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.shapeMovingArgs)) {\n            shapeResizingArgs.currentShapeSettings = this.shapeResizingArgs.currentShapeSettings = currentShapeSettings;\n            shapeMovingArgs.currentShapeSettings = this.shapeMovingArgs.currentShapeSettings = currentShapeSettings;\n        }\n        else {\n            shapeResizingArgs.currentShapeSettings = currentShapeSettings;\n            shapeMovingArgs.currentShapeSettings = currentShapeSettings;\n        }\n        if (type === 'resize') {\n            this.isCropSelection = false;\n            var splitWords = void 0;\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (splitWords !== undefined && splitWords[0] === 'crop') {\n                this.isCropSelection = true;\n            }\n            if (!this.isCropSelection) {\n                if (this.currentDrawingShape !== '' && parent.upperCanvas.style.cursor === 'crosshair') {\n                    shapeResizingArgs.action = 'drawing';\n                }\n                if (!parent.currObjType.isRedact || parent.activeObj.shape !== 'redact') {\n                    parent.trigger('shapeChanging', shapeResizingArgs);\n                }\n                parent.editCompleteArgs = shapeResizingArgs;\n                this.isPreventShaping = shapeResizingArgs.cancel;\n                parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false, value: { shapeSettings: shapeResizingArgs.currentShapeSettings, allowShapeOverflow: shapeResizingArgs.allowShapeOverflow } });\n            }\n            else {\n                if (this.isMouseDown) {\n                    shapeResizingArgs.action = 'resize-start';\n                }\n                else if (this.isMouseUp) {\n                    shapeResizingArgs.action = 'resize-end';\n                }\n                var selectionResizingArgs = { action: shapeResizingArgs.action,\n                    previousSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),\n                        startX: shapeResizingArgs.previousShapeSettings.startX,\n                        startY: shapeResizingArgs.previousShapeSettings.startY,\n                        width: shapeResizingArgs.previousShapeSettings.width,\n                        height: shapeResizingArgs.previousShapeSettings.height },\n                    currentSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),\n                        startX: shapeResizingArgs.currentShapeSettings.startX,\n                        startY: shapeResizingArgs.currentShapeSettings.startY,\n                        width: shapeResizingArgs.currentShapeSettings.width,\n                        height: shapeResizingArgs.currentShapeSettings.height } };\n                this.selectionResizingArgs = selectionResizingArgs;\n                parent.trigger('selectionChanging', selectionResizingArgs);\n                parent.editCompleteArgs = selectionResizingArgs;\n                parent.notify('shape', { prop: 'updSelChangeEventArgs', onPropertyChange: false,\n                    value: { selectionSettings: selectionResizingArgs.currentSelectionSettings } });\n            }\n        }\n        else if (type === 'mouse-down' || type === 'mouse-up') {\n            if (parent.activeObj.shape !== 'redact') {\n                parent.trigger('shapeChanging', shapeResizingArgs);\n            }\n            parent.editCompleteArgs = shapeResizingArgs;\n            this.isPreventShaping = shapeResizingArgs.cancel;\n            parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,\n                value: { shapeSettings: shapeResizingArgs.currentShapeSettings, allowShapeOverflow: shapeResizingArgs.allowShapeOverflow } });\n        }\n        else {\n            if (parent.activeObj.shape !== 'redact') {\n                parent.trigger('shapeChanging', shapeMovingArgs);\n            }\n            parent.editCompleteArgs = shapeMovingArgs;\n            this.isPreventShaping = shapeMovingArgs.cancel;\n            parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,\n                value: { shapeSettings: shapeMovingArgs.currentShapeSettings, allowShapeOverflow: shapeMovingArgs.allowShapeOverflow } });\n        }\n        parent.eventType = type;\n    };\n    Selection.prototype.setDragWidth = function (width) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var _a = parent.img, destLeft = _a.destLeft, destWidth = _a.destWidth;\n        var tempWidth = width;\n        var shape = parent.activeObj.shape;\n        var preventDragOut = false;\n        if (parent.activeObj.preventShapeDragOut && (shape === 'line' || shape === 'arrow')) {\n            preventDragOut = true;\n        }\n        if (tempWidth >= 0) {\n            for (var i = 0; i < tempWidth; i++) {\n                width = tempWidth - i;\n                actPoint.startX += width;\n                actPoint.endX += width;\n                if ((actPoint.startX >= destLeft &&\n                    actPoint.endX <= destLeft + destWidth && !preventDragOut) ||\n                    (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth &&\n                        actPoint.endX >= destLeft && actPoint.startX <= destLeft + destWidth && preventDragOut)) {\n                    break;\n                }\n                else {\n                    actPoint.startX -= width;\n                    actPoint.endX -= width;\n                }\n            }\n        }\n        else {\n            for (var i = 1; i < Math.abs(tempWidth); i++) {\n                width = tempWidth + i;\n                actPoint.startX += width;\n                actPoint.endX += width;\n                if ((actPoint.startX >= destLeft &&\n                    actPoint.endX <= destLeft + destWidth && !preventDragOut) ||\n                    (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth &&\n                        actPoint.endX >= destLeft && actPoint.startX <= destLeft + destWidth && preventDragOut)) {\n                    break;\n                }\n                else {\n                    actPoint.startX -= width;\n                    actPoint.endX -= width;\n                }\n            }\n        }\n    };\n    Selection.prototype.setDragHeight = function (height) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var _a = parent.img, destTop = _a.destTop, destHeight = _a.destHeight;\n        var tempHeight = height;\n        var shape = parent.activeObj.shape;\n        var preventDragOut = false;\n        if (parent.activeObj.preventShapeDragOut && (shape === 'line' || shape === 'arrow')) {\n            preventDragOut = true;\n        }\n        if (tempHeight >= 0) {\n            for (var i = 1; i < tempHeight; i++) {\n                height = tempHeight - i;\n                actPoint.startY += height;\n                actPoint.endY += height;\n                if ((actPoint.startY >= destTop &&\n                    actPoint.endY <= destTop + destHeight && !preventDragOut) ||\n                    (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight &&\n                        actPoint.endY >= destTop && actPoint.startY <= destTop + destHeight && preventDragOut)) {\n                    break;\n                }\n                else {\n                    actPoint.startY -= height;\n                    actPoint.endY -= height;\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < Math.abs(tempHeight); i++) {\n                height = tempHeight + i;\n                actPoint.startY += height;\n                actPoint.endY += height;\n                if ((actPoint.startY >= destTop &&\n                    actPoint.endY <= destTop + destHeight && !preventDragOut) ||\n                    (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight &&\n                        actPoint.endY >= destTop && actPoint.startY <= destTop + destHeight && preventDragOut)) {\n                    break;\n                }\n                else {\n                    actPoint.startY -= height;\n                    actPoint.endY -= height;\n                }\n            }\n        }\n    };\n    Selection.prototype.limitDrag = function (isStart) {\n        var isLimiting = false;\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        var actPoint = parent.activeObj.activePoint;\n        var startX = isStart ? actPoint.startX : actPoint.endX;\n        var startY = isStart ? actPoint.startY : actPoint.endY;\n        var endX = isStart ? actPoint.endX : actPoint.startX;\n        var endY = isStart ? actPoint.endY : actPoint.startY;\n        var wrapperWidth = parent.upperCanvas.width;\n        var wrapperHeight = parent.upperCanvas.height;\n        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n            if (startX < 0 && destLeft < 0) {\n                startX = 0;\n            }\n            if (startY < 0 && destTop < 0) {\n                startY = 0;\n            }\n            if (endX > wrapperWidth && destLeft + destWidth > wrapperWidth) {\n                endX = wrapperWidth;\n            }\n            if (endY > wrapperHeight && destTop + destHeight > wrapperHeight) {\n                endY = wrapperHeight;\n            }\n        }\n        else {\n            if (startX < destLeft) {\n                startX = destLeft;\n            }\n            if (startY < destTop) {\n                startY = destTop;\n            }\n            if (endX > destLeft + destWidth) {\n                endX = destLeft + destWidth;\n            }\n            if (endY > destTop + destHeight) {\n                endY = destTop + destHeight;\n            }\n        }\n        if (parent.transform.straighten !== 0) {\n            var obj = { isIntersect: null, arr: null };\n            parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });\n            parent.notify('draw', { prop: 'isLinesIntersect', onPropertyChange: false, value: { obj: obj } });\n            if (obj['arr'][0] || obj['arr'][1] || obj['arr'][2] || obj['arr'][3]) {\n                isLimiting = true;\n            }\n        }\n        if (isStart) {\n            actPoint.startX = startX;\n            actPoint.startY = startY;\n            actPoint.endX = endX;\n            actPoint.endY = endY;\n        }\n        else {\n            actPoint.startX = endX;\n            actPoint.startY = endY;\n            actPoint.endX = startX;\n            actPoint.endY = startY;\n        }\n        return isLimiting;\n    };\n    Selection.prototype.isMouseOutsideImg = function (x, y) {\n        var obj = { bool: false };\n        this.parent.notify('draw', { prop: 'updateImgCanvasPoints', onPropertyChange: false });\n        this.parent.notify('draw', { prop: 'isPointsInsideImg', value: { obj: obj, x: x, y: y } });\n        return obj['bool'];\n    };\n    Selection.prototype.preventDraggingInvertly = function () {\n        var isLimiting = false;\n        var parent = this.parent;\n        if (parent.activeObj.shape === 'image') {\n            return isLimiting;\n        }\n        var splitWords;\n        var cropResize;\n        if (parent.activeObj.shape !== undefined) {\n            splitWords = parent.activeObj.shape.split('-');\n        }\n        if (splitWords !== undefined && splitWords[0] === 'crop') {\n            cropResize = true;\n        }\n        if ((!this.isPreventDragging && parent.activeObj.rotatedAngle === 0) && (parent.activeObj.preventShapeDragOut || parent.activeObj.shape === 'redact' || cropResize)) {\n            isLimiting = this.limitDrag(true);\n            var shapeColl = ['line', 'arrow', 'path'];\n            if (shapeColl.indexOf(parent.activeObj.shape) > -1) {\n                isLimiting = this.limitDrag(false);\n            }\n        }\n        return isLimiting;\n    };\n    Selection.prototype.preventTextDraggingInvertly = function () {\n        var parent = this.parent;\n        var isLimiting = false;\n        var actPoint = parent.activeObj.activePoint;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        if (!this.isPreventDragging) {\n            if (actPoint.startX < destLeft ||\n                actPoint.startY < destTop ||\n                actPoint.endX > destLeft + destWidth ||\n                actPoint.endY > destTop + destHeight) {\n                isLimiting = true;\n            }\n        }\n        return isLimiting;\n    };\n    Selection.prototype.preventInverseResize = function (tempActiveObj) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        if (actPoint.width < 0) {\n            actPoint.width = 0;\n            actPoint.startX = tempActiveObj.activePoint.startX;\n            actPoint.endX = tempActiveObj.activePoint.endX;\n        }\n        if (actPoint.height < 0) {\n            actPoint.height = 0;\n            actPoint.startY = tempActiveObj.activePoint.startY;\n            actPoint.endY = tempActiveObj.activePoint.endY;\n        }\n    };\n    Selection.prototype.getScaleRatio = function (scale) {\n        var parent = this.parent;\n        var point = { x: scale, y: scale };\n        if (parent.activeObj.shape && parent.activeObj.shape !== 'crop-custom' &&\n            parent.activeObj.shape !== 'crop-circle' && parent.activeObj.shape !== 'crop-square') {\n            var ratio = parent.activeObj.shape === 'image' || parent.activeObj.shape === 'text' ?\n                this.findImageRatio(parent.activeObj.activePoint.width, parent.activeObj.activePoint.height).split('-') :\n                parent.activeObj.shape.split('-');\n            if (ratio.length > 1 || parent.activeObj.shape === 'image' || parent.activeObj.shape === 'text') {\n                ratio = parent.activeObj.shape === 'image' || parent.activeObj.shape === 'text' ? ratio[0].split(':') : ratio[1].split(':');\n                var newScale = scale / (parseInt(ratio[1], 10));\n                point.x = newScale * (parseInt(ratio[0], 10));\n                point.y = newScale * (parseInt(ratio[1], 10));\n            }\n        }\n        return point;\n    };\n    Selection.prototype.findImageRatio = function (width, height, obj) {\n        // eslint-disable-next-line @typescript-eslint/tslint/config\n        var gcd = function (a, b) {\n            if (b === 0) {\n                return a;\n            }\n            return gcd(b, a % b);\n        };\n        var divisor = gcd(width, height);\n        var ratio = width / divisor + \":\" + height / divisor;\n        if (obj) {\n            obj['ratio'] = ratio;\n        }\n        return ratio;\n    };\n    Selection.prototype.revertResizing = function (tempActiveObj) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        if (this.preventDraggingInvertly()) {\n            actPoint.startX = tempActiveObj.activePoint.startX;\n            actPoint.startY = tempActiveObj.activePoint.startY;\n            actPoint.endX = tempActiveObj.activePoint.endX;\n            actPoint.endY = tempActiveObj.activePoint.endY;\n        }\n    };\n    Selection.prototype.performSEResize = function (x, y, tempActiveObj, actPoint) {\n        var parent = this.parent;\n        this.resizeImg(x, y, 'se-resize', tempActiveObj);\n        if (actPoint.endX < actPoint.startX) {\n            var temp = actPoint.endX;\n            actPoint.endX = actPoint.startX;\n            actPoint.startX = temp;\n            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';\n        }\n        if (actPoint.endY < actPoint.startY) {\n            var temp = actPoint.endY;\n            actPoint.endY = actPoint.startY;\n            actPoint.startY = temp;\n            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';\n        }\n        this.revertCustomSelection(actPoint, tempActiveObj, 'se-resize');\n        this.revertResizing(tempActiveObj);\n    };\n    Selection.prototype.performNWResize = function (x, y, tempActiveObj, actPoint) {\n        var parent = this.parent;\n        this.resizeImg(x, y, 'nw-resize', tempActiveObj);\n        if (actPoint.startX > actPoint.endX) {\n            var temp = actPoint.startX;\n            actPoint.startX = actPoint.endX;\n            actPoint.endX = temp;\n            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';\n        }\n        if (actPoint.startY > actPoint.endY) {\n            var temp = actPoint.startY;\n            actPoint.startY = actPoint.endY;\n            actPoint.endY = temp;\n            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';\n        }\n        this.revertCustomSelection(actPoint, tempActiveObj, 'nw-resize');\n        this.revertResizing(tempActiveObj);\n    };\n    Selection.prototype.isCustomSelection = function () {\n        if (this.parent.activeObj.shape) {\n            var shapeColl = ['custom', 'circle', 'square', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '5:7', '7:5', '9:16', '16:9'];\n            return this.parent.activeObj.shape.indexOf('crop-') > -1 && shapeColl.indexOf(this.parent.activeObj.shape.split('-')[1]) === -1;\n        }\n        return false;\n    };\n    Selection.prototype.revertCustomSelection = function (actPoint, tempActiveObj, type) {\n        var parent = this.parent;\n        if (this.isCustomSelection()) {\n            var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n            var endX = destLeft + destWidth < parent.lowerCanvas.width ?\n                destLeft + destWidth : parent.lowerCanvas.width;\n            var endY = destTop + destHeight < parent.lowerCanvas.height ?\n                destTop + destHeight : parent.lowerCanvas.height;\n            var left = destLeft > 0 ? destLeft : 0;\n            var top_1 = destTop > 0 ? destTop : 0;\n            var endY1 = destTop > 0 ? destTop : 0;\n            var endX1 = destLeft > 0 ? destLeft : 0;\n            if ((type === 'se-resize' && (actPoint.endX > endX || actPoint.endY > endY)) ||\n                (type === 'nw-resize' && (actPoint.startX < left || actPoint.startY < top_1)) ||\n                (type === 'ne-resize' && (actPoint.endX > endX || actPoint.startY < endY1)) ||\n                (type === 'sw-resize' && (actPoint.startX < endX1 || actPoint.endY > endY))) {\n                this.revertPoints(actPoint, tempActiveObj);\n            }\n        }\n    };\n    Selection.prototype.revertPoints = function (actPoint, tempActiveObj) {\n        actPoint.startX = tempActiveObj.activePoint.startX;\n        actPoint.startY = tempActiveObj.activePoint.startY;\n        actPoint.endX = tempActiveObj.activePoint.endX;\n        actPoint.endY = tempActiveObj.activePoint.endY;\n        actPoint.width = tempActiveObj.activePoint.width;\n        actPoint.height = tempActiveObj.activePoint.height;\n    };\n    Selection.prototype.updateNWPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape === 'text') {\n            this.resizeImg(x, y, 'nw-resize', tempActiveObj);\n            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,\n                value: { obj: parent.activeObj } });\n        }\n        else {\n            var splitWords = void 0;\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')\n                || this.isCustomSelection()) {\n                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {\n                    this.resizeImg(x, y, 'nw-resize', tempActiveObj);\n                }\n                else {\n                    this.adjustNWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);\n                }\n                if (actPoint.startX > actPoint.endX) {\n                    var temp = actPoint.startX;\n                    actPoint.startX = actPoint.endX;\n                    actPoint.endX = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';\n                }\n                if (actPoint.startY > actPoint.endY) {\n                    var temp = actPoint.startY;\n                    actPoint.startY = actPoint.endY;\n                    actPoint.endY = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';\n                }\n                this.revertCustomSelection(actPoint, tempActiveObj, 'nw-resize');\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop;\n                if (actPoint.startX < x && actPoint.startY < y) {\n                    width = x - actPoint.startX;\n                    height = y - actPoint.startY;\n                    scale = Math.min(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.startX += newScale.x;\n                    actPoint.startY += newScale.y;\n                    var left = destLeft > 0 ? destLeft : 0;\n                    var top_2 = destTop > 0 ? destTop : 0;\n                    if (actPoint.startX < left || actPoint.startY < top_2) {\n                        actPoint.startX -= newScale.x;\n                        actPoint.startY -= newScale.y;\n                    }\n                }\n                else {\n                    width = actPoint.startX - x;\n                    height = y - actPoint.endY;\n                    scale = Math.max(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.startX -= newScale.x;\n                    actPoint.startY -= newScale.y;\n                    var left = destLeft > 0 ? destLeft : 0;\n                    var top_3 = destTop > 0 ? destTop : 0;\n                    if (actPoint.startX < left || actPoint.startY < top_3) {\n                        actPoint.startX += newScale.x;\n                        actPoint.startY += newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n            actPoint.width = actPoint.endX - actPoint.startX;\n            actPoint.height = actPoint.endY - actPoint.startY;\n            this.preventInverseResize(tempActiveObj);\n        }\n    };\n    Selection.prototype.updateNPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape !== 'text') {\n            var splitWords = void 0;\n            if (parent.activeObj.shape) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {\n                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&\n                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {\n                    if (this.dragPoint.startX && this.dragPoint.startY) {\n                        this.previousPoint.x = this.dragPoint.endX;\n                        this.previousPoint.y = this.dragPoint.endY;\n                        this.dragPoint.endX = x;\n                        this.dragPoint.endY = y;\n                    }\n                    width = (this.dragPoint.endX - this.previousPoint.x);\n                    height = (this.dragPoint.endY - this.previousPoint.y);\n                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);\n                }\n                else {\n                    actPoint.startY = y;\n                    actPoint.height = actPoint.endY - actPoint.startY;\n                }\n                if (actPoint.startY > actPoint.endY) {\n                    var temp = actPoint.startY;\n                    actPoint.startY = actPoint.endY;\n                    actPoint.endY = temp;\n                    this.dragElement = this.resizedElement = 's-resize';\n                }\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;\n                if (this.isCustomSelection()) {\n                    this.performNWResize(x, y, tempActiveObj, actPoint);\n                }\n                else if (actPoint.endX > x && actPoint.startY < y) {\n                    width = actPoint.endX - x;\n                    height = y - actPoint.startY;\n                    scale = Math.min(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX -= newScale.x;\n                    actPoint.startY += newScale.y;\n                    if (actPoint.endX > (destLeft + destWidth) ||\n                        actPoint.startY < destTop) {\n                        actPoint.endX += newScale.x;\n                        actPoint.startY -= newScale.y;\n                    }\n                }\n                else {\n                    width = x - actPoint.endX;\n                    height = actPoint.startY - y;\n                    scale = Math.max(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX += newScale.x;\n                    actPoint.startY -= newScale.y;\n                    if (actPoint.endX > (destLeft + destWidth) ||\n                        actPoint.startY < destTop) {\n                        actPoint.endX -= newScale.x;\n                        actPoint.startY += newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n        }\n    };\n    Selection.prototype.updateNEPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape === 'text') {\n            this.resizeImg(x, y, 'ne-resize', tempActiveObj);\n            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,\n                value: { obj: parent.activeObj } });\n        }\n        else {\n            var splitWords = void 0;\n            if (parent.activeObj.shape) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')\n                || this.isCustomSelection()) {\n                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {\n                    this.resizeImg(x, y, 'ne-resize', tempActiveObj);\n                }\n                else {\n                    this.adjustNEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);\n                }\n                if (actPoint.endX < actPoint.startX) {\n                    var temp = actPoint.endX;\n                    actPoint.endX = actPoint.startX;\n                    actPoint.startX = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';\n                }\n                if (actPoint.startY > actPoint.endY) {\n                    var temp = actPoint.startY;\n                    actPoint.startY = actPoint.endY;\n                    actPoint.endY = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';\n                }\n                this.revertCustomSelection(actPoint, tempActiveObj, 'ne-resize');\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;\n                if (actPoint.endX > x && actPoint.startY < y) {\n                    width = actPoint.endX - x;\n                    height = y - actPoint.startY;\n                    scale = Math.min(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX -= newScale.x;\n                    actPoint.startY += newScale.y;\n                    var endX = destLeft + destWidth < parent.lowerCanvas.width ?\n                        destLeft + destWidth : parent.lowerCanvas.width;\n                    var endY = destTop > 0 ? destTop : 0;\n                    if (actPoint.endX > endX || actPoint.startY < endY) {\n                        actPoint.endX += newScale.x;\n                        actPoint.startY -= newScale.y;\n                    }\n                }\n                else {\n                    width = x - actPoint.endX;\n                    height = actPoint.startY - y;\n                    scale = Math.max(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX += newScale.x;\n                    actPoint.startY -= newScale.y;\n                    var endX = destLeft + destWidth < parent.lowerCanvas.width ?\n                        destLeft + destWidth : parent.lowerCanvas.width;\n                    var endY = destTop > 0 ? destTop : 0;\n                    if (actPoint.endX > endX || actPoint.startY < endY) {\n                        actPoint.endX -= newScale.x;\n                        actPoint.startY += newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n            actPoint.width = actPoint.endX - actPoint.startX;\n            actPoint.height = actPoint.endY - actPoint.startY;\n            this.preventInverseResize(tempActiveObj);\n        }\n    };\n    Selection.prototype.updateWPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape !== 'text') {\n            var splitWords = void 0;\n            if (parent.activeObj.shape) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {\n                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&\n                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {\n                    if (this.dragPoint.startX && this.dragPoint.startY) {\n                        this.previousPoint.x = this.dragPoint.endX;\n                        this.previousPoint.y = this.dragPoint.endY;\n                        this.dragPoint.endX = x;\n                        this.dragPoint.endY = y;\n                    }\n                    width = (this.dragPoint.endX - this.previousPoint.x);\n                    height = (this.dragPoint.endY - this.previousPoint.y);\n                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);\n                }\n                else {\n                    actPoint.startX = x;\n                    actPoint.width = actPoint.endX - actPoint.startX;\n                }\n                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path') {\n                    actPoint.startY = y;\n                    actPoint.height = actPoint.endY - actPoint.startY;\n                    if (this.adjustActObjForLineArrow()) {\n                        this.dragElement = 'e-resize';\n                        if (parent.activeObj.triangleDirection === 'right') {\n                            parent.activeObj.triangleDirection = 'left';\n                        }\n                        else if (parent.activeObj.triangleDirection === 'left') {\n                            parent.activeObj.triangleDirection = 'right';\n                        }\n                    }\n                }\n                else if (actPoint.startX > actPoint.endX) {\n                    var temp = actPoint.startX;\n                    actPoint.startX = actPoint.endX;\n                    actPoint.endX = temp;\n                    this.dragElement = this.resizedElement = 'e-resize';\n                }\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;\n                if (this.isCustomSelection()) {\n                    this.performNWResize(x, y, tempActiveObj, actPoint);\n                }\n                else if (actPoint.startX < x && actPoint.endY > y) {\n                    width = x - actPoint.startX;\n                    height = actPoint.endY - y;\n                    scale = Math.min(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.startX += newScale.x;\n                    actPoint.endY -= newScale.y;\n                    if (actPoint.startX < destLeft || actPoint.endY >\n                        (destTop + destHeight)) {\n                        actPoint.startX -= newScale.x;\n                        actPoint.endY += newScale.y;\n                    }\n                }\n                else {\n                    width = actPoint.startX - x;\n                    height = y - actPoint.endY;\n                    scale = Math.max(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.startX -= newScale.x;\n                    actPoint.endY += newScale.y;\n                    if (actPoint.startX < destLeft || actPoint.endY >\n                        (destTop + destHeight)) {\n                        actPoint.startX += newScale.x;\n                        actPoint.endY -= newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n        }\n    };\n    Selection.prototype.updateEPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape !== 'text') {\n            var splitWords = void 0;\n            if (parent.activeObj.shape) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {\n                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&\n                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {\n                    if (this.dragPoint.startX && this.dragPoint.startY) {\n                        this.previousPoint.x = this.dragPoint.endX;\n                        this.previousPoint.y = this.dragPoint.endY;\n                        this.dragPoint.endX = x;\n                        this.dragPoint.endY = y;\n                    }\n                    width = (this.dragPoint.endX - this.previousPoint.x);\n                    height = (this.dragPoint.endY - this.previousPoint.y);\n                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);\n                }\n                else {\n                    actPoint.endX = x;\n                    actPoint.width = actPoint.endX - actPoint.startX;\n                }\n                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path') {\n                    actPoint.endY = y;\n                    actPoint.height = actPoint.endY - actPoint.startY;\n                    if (this.adjustActObjForLineArrow()) {\n                        this.dragElement = 'w-resize';\n                        if (parent.activeObj.triangleDirection === 'right') {\n                            parent.activeObj.triangleDirection = 'left';\n                        }\n                        else if (parent.activeObj.triangleDirection === 'left') {\n                            parent.activeObj.triangleDirection = 'right';\n                        }\n                    }\n                }\n                else if (actPoint.endX < actPoint.startX) {\n                    var temp = actPoint.endX;\n                    actPoint.endX = actPoint.startX;\n                    actPoint.startX = temp;\n                    this.dragElement = this.resizedElement = 'w-resize';\n                }\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n                if (this.isCustomSelection()) {\n                    this.performSEResize(x, y, tempActiveObj, actPoint);\n                }\n                else if (actPoint.endX > x && actPoint.endY > y) {\n                    width = actPoint.endX - x;\n                    height = actPoint.endY - y;\n                    scale = Math.min(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX -= newScale.x;\n                    actPoint.endY -= newScale.y;\n                    if (actPoint.endX > (destLeft + destWidth) ||\n                        actPoint.endY > (destTop + destHeight)) {\n                        actPoint.endX += newScale.x;\n                        actPoint.endY += newScale.y;\n                    }\n                }\n                else {\n                    width = x - actPoint.endX;\n                    height = y - actPoint.endY;\n                    scale = Math.max(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX += newScale.x;\n                    actPoint.endY += newScale.y;\n                    if (actPoint.endX > (destLeft + destWidth) ||\n                        actPoint.endY > (destTop + destHeight)) {\n                        actPoint.endX -= newScale.x;\n                        actPoint.endY -= newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n        }\n    };\n    Selection.prototype.updateSWPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape === 'text') {\n            this.resizeImg(x, y, 'sw-resize', tempActiveObj);\n            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,\n                value: { obj: parent.activeObj } });\n        }\n        else {\n            var splitWords = void 0;\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')\n                || this.isCustomSelection()) {\n                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {\n                    this.resizeImg(x, y, 'sw-resize', tempActiveObj);\n                }\n                else {\n                    this.adjustSWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);\n                }\n                if (actPoint.startX > actPoint.endX) {\n                    var temp = actPoint.startX;\n                    actPoint.startX = actPoint.endX;\n                    actPoint.endX = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';\n                }\n                if (actPoint.endY < actPoint.startY) {\n                    var temp = actPoint.endY;\n                    actPoint.endY = actPoint.startY;\n                    actPoint.startY = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';\n                }\n                this.revertCustomSelection(actPoint, tempActiveObj, 'sw-resize');\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;\n                if (actPoint.startX < x && actPoint.endY > y) {\n                    width = x - actPoint.startX;\n                    height = actPoint.endY - y;\n                    scale = Math.min(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.startX += newScale.x;\n                    actPoint.endY -= newScale.y;\n                    var endX = destLeft > 0 ? destLeft : 0;\n                    var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop +\n                        destHeight : parent.lowerCanvas.height;\n                    if (actPoint.startX < endX || actPoint.endY > endY) {\n                        actPoint.startX -= newScale.x;\n                        actPoint.endY += newScale.y;\n                    }\n                }\n                else {\n                    width = actPoint.startX - x;\n                    height = y - actPoint.endY;\n                    scale = Math.max(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.startX -= newScale.x;\n                    actPoint.endY += newScale.y;\n                    var endX = destLeft > 0 ? destLeft : 0;\n                    var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop +\n                        destHeight : parent.lowerCanvas.height;\n                    if (actPoint.startX < endX || actPoint.endY > endY) {\n                        actPoint.startX += newScale.x;\n                        actPoint.endY -= newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n            actPoint.width = actPoint.endX - actPoint.startX;\n            actPoint.height = actPoint.endY - actPoint.startY;\n            this.preventInverseResize(tempActiveObj);\n        }\n    };\n    Selection.prototype.updateSPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape !== 'text') {\n            var splitWords = void 0;\n            if (parent.activeObj.shape) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {\n                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&\n                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {\n                    if (this.dragPoint.startX && this.dragPoint.startY) {\n                        this.previousPoint.x = this.dragPoint.endX;\n                        this.previousPoint.y = this.dragPoint.endY;\n                        this.dragPoint.endX = x;\n                        this.dragPoint.endY = y;\n                    }\n                    width = (this.dragPoint.endX - this.previousPoint.x);\n                    height = (this.dragPoint.endY - this.previousPoint.y);\n                    this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);\n                }\n                else {\n                    actPoint.endY = y;\n                    actPoint.height = actPoint.endY - actPoint.startY;\n                }\n                if (actPoint.endY < actPoint.startY) {\n                    var temp = actPoint.endY;\n                    actPoint.endY = actPoint.startY;\n                    actPoint.startY = temp;\n                    this.dragElement = this.resizedElement = 'n-resize';\n                }\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n                if (this.isCustomSelection()) {\n                    this.performSEResize(x, y, tempActiveObj, actPoint);\n                }\n                else if (actPoint.endX > x && actPoint.endY > y) {\n                    width = actPoint.endX - x;\n                    height = actPoint.endY - y;\n                    scale = Math.min(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX -= newScale.x;\n                    actPoint.endY -= newScale.y;\n                    if (actPoint.endX > (destLeft + destWidth) ||\n                        actPoint.endY > (destTop + destHeight)) {\n                        actPoint.endX += newScale.x;\n                        actPoint.endY += newScale.y;\n                    }\n                }\n                else {\n                    width = x - actPoint.endX;\n                    height = y - actPoint.endY;\n                    scale = Math.max(width, height);\n                    var newScale = this.getScaleRatio(scale);\n                    actPoint.endX += newScale.x;\n                    actPoint.endY += newScale.x;\n                    if (actPoint.endX > (destLeft + destWidth) ||\n                        actPoint.endY > (destTop + destHeight)) {\n                        actPoint.endX -= newScale.x;\n                        actPoint.endY -= newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n        }\n    };\n    Selection.prototype.updateSEPoints = function (x, y) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (parent.activeObj.shape === 'text') {\n            this.resizeImg(x, y, 'se-resize', tempActiveObj);\n            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,\n                value: { obj: parent.activeObj } });\n        }\n        else {\n            var splitWords = void 0;\n            var newScale = void 0;\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')\n                || this.isCustomSelection()) {\n                if (parent.activeObj.shape === 'image' || this.isCustomSelection()) {\n                    this.resizeImg(x, y, 'se-resize', tempActiveObj);\n                }\n                else {\n                    this.adjustSEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);\n                }\n                if (actPoint.endX < actPoint.startX) {\n                    var temp = actPoint.endX;\n                    actPoint.endX = actPoint.startX;\n                    actPoint.startX = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';\n                }\n                if (actPoint.endY < actPoint.startY) {\n                    var temp = actPoint.endY;\n                    actPoint.endY = actPoint.startY;\n                    actPoint.startY = temp;\n                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';\n                }\n                this.revertCustomSelection(actPoint, tempActiveObj, 'se-resize');\n                this.revertResizing(tempActiveObj);\n            }\n            else {\n                var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n                if (actPoint.endX > x && actPoint.endY > y) {\n                    width = actPoint.endX - x;\n                    height = actPoint.endY - y;\n                    scale = Math.min(width, height);\n                    newScale = this.getScaleRatio(scale);\n                    actPoint.endX -= newScale.x;\n                    actPoint.endY -= newScale.y;\n                    var endX = destLeft + destWidth < parent.lowerCanvas.width ?\n                        destLeft + destWidth : parent.lowerCanvas.width;\n                    var endY = destTop + destHeight < parent.lowerCanvas.height ?\n                        destTop + destHeight : parent.lowerCanvas.height;\n                    if (actPoint.endX > endX || actPoint.endY > endY) {\n                        actPoint.endX += newScale.x;\n                        actPoint.endY += newScale.y;\n                    }\n                }\n                else {\n                    width = x - actPoint.endX;\n                    height = y - actPoint.endY;\n                    scale = Math.max(width, height);\n                    newScale = this.getScaleRatio(scale);\n                    actPoint.endX += newScale.x;\n                    actPoint.endY += newScale.y;\n                    var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft +\n                        destWidth : parent.lowerCanvas.width;\n                    var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop +\n                        destHeight : parent.lowerCanvas.height;\n                    if (actPoint.endX > endX || actPoint.endY > endY) {\n                        actPoint.endX -= newScale.x;\n                        actPoint.endY -= newScale.y;\n                    }\n                }\n                actPoint.width = actPoint.endX - actPoint.startX;\n                actPoint.height = actPoint.endY - actPoint.startY;\n                this.revertResizing(tempActiveObj);\n            }\n            this.preventInverseResize(tempActiveObj);\n        }\n    };\n    Selection.prototype.resizeImg = function (x, y, elem, tempActiveObj) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var width;\n        var height;\n        var scale;\n        var newScale;\n        if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {\n            if (this.currentDrawingShape === 'text') {\n                this.setCursor(x, y);\n                if (parent.activeObj.textSettings.fontSize === 0) {\n                    parent.activeObj.textSettings.fontSize = 11;\n                    parent.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,\n                        value: { obj: parent.activeObj, isTextArea: null } });\n                    parent.activeObj.textSettings.text = parent.activeObj.keyHistory = 'Enter Text';\n                    parent.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,\n                        value: { isTextBox: null } });\n                    var width_2 = this.upperContext.measureText(parent.activeObj.textSettings.text).width +\n                        parent.activeObj.textSettings.fontSize * 0.5;\n                    actPoint.endX = actPoint.startX + width_2;\n                    actPoint.endY = actPoint.startY + parent.activeObj.textSettings.fontSize;\n                    actPoint.width = actPoint.endX - actPoint.startX;\n                    actPoint.height = actPoint.endY - actPoint.startY;\n                    tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n                    parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,\n                            isMouseMove: null, x: null, y: null } });\n                }\n            }\n            switch (parent.upperCanvas.style.cursor) {\n                case 'se-resize':\n                case 's-resize':\n                    if (this.previousPoint.x > x || this.previousPoint.y > y) {\n                        width = (this.previousPoint.x - x);\n                        height = (this.previousPoint.y - y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {\n                        width = (x - this.previousPoint.x);\n                        height = (y - this.previousPoint.y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    break;\n                case 'sw-resize':\n                    if (this.previousPoint.x < x || this.previousPoint.y > y) {\n                        width = (x - this.previousPoint.x);\n                        height = (this.previousPoint.y - y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {\n                        width = (this.previousPoint.x - x);\n                        height = (y - this.previousPoint.y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    break;\n                case 'w-resize':\n                case 'nw-resize':\n                    if (this.previousPoint.x < x || this.previousPoint.y < y) {\n                        width = (x - this.previousPoint.x);\n                        height = (y - this.previousPoint.y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {\n                        width = (this.previousPoint.x - x);\n                        height = (this.previousPoint.y - y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    break;\n                case 'n-resize':\n                case 'ne-resize':\n                    if (this.previousPoint.x > x || this.previousPoint.y < y) {\n                        width = (this.previousPoint.x - x);\n                        height = (y - this.previousPoint.y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {\n                        width = (x - this.previousPoint.x);\n                        height = (this.previousPoint.y - y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    break;\n                case 'e-resize':\n                    if (this.previousPoint.x > x || this.previousPoint.y > y) {\n                        width = (this.previousPoint.x - x);\n                        height = (this.previousPoint.y - y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {\n                        width = (x - this.previousPoint.x);\n                        height = (y - this.previousPoint.y);\n                        scale = (width + height) / 2;\n                        newScale = this.getScaleRatio(scale);\n                        this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, 'img-resize', elem);\n                    }\n                    break;\n            }\n            actPoint.width = actPoint.endX - actPoint.startX;\n            actPoint.height = actPoint.endY - actPoint.startY;\n            if ((actPoint.width < 10 || actPoint.height < 10) ||\n                (parent.activeObj.shape === 'text' && parent.activeObj.rotatedAngle === 0 && this.preventTextDraggingInvertly())) {\n                parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, tempActiveObj, null, true);\n            }\n        }\n        this.previousPoint = { x: x, y: y };\n    };\n    Selection.prototype.adjustNWPoints = function (rectangle, x, y, angle) {\n        var cx = rectangle.startX + rectangle.width / 2;\n        var cy = rectangle.startY + rectangle.height / 2;\n        var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);\n        var newCenter = [(rotatedC[0] + x) / 2, (rotatedC[1] + y) / 2];\n        var newBottomRight = this.rotatePoints(rotatedC[0], rotatedC[1], newCenter[0], newCenter[1], -angle);\n        var newTopLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);\n        rectangle.endX = newBottomRight[0];\n        rectangle.endY = newBottomRight[1];\n        rectangle.startY = newTopLeft[1];\n        rectangle.startX = newTopLeft[0];\n        rectangle.width = rectangle.endX - rectangle.startX;\n        rectangle.height = rectangle.endY - rectangle.startY;\n        return rectangle;\n    };\n    Selection.prototype.adjustNEPoints = function (rectangle, x, y, angle) {\n        var cx = rectangle.startX + rectangle.width / 2;\n        var cy = rectangle.startY + rectangle.height / 2;\n        var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);\n        var newCenter = [(rotatedD[0] + x) / 2, (rotatedD[1] + y) / 2];\n        var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);\n        var newTopRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);\n        rectangle.startX = newBottomLeft[0];\n        rectangle.endY = newBottomLeft[1];\n        rectangle.width = newTopRight[0] - newBottomLeft[0];\n        rectangle.height = newBottomLeft[1] - newTopRight[1];\n        rectangle.endX = rectangle.startX + rectangle.width;\n        rectangle.startY = rectangle.endY - rectangle.height;\n        return rectangle;\n    };\n    Selection.prototype.adjustSWPoints = function (rectangle, x, y, angle) {\n        var cx = rectangle.startX + rectangle.width / 2;\n        var cy = rectangle.startY + rectangle.height / 2;\n        var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);\n        var newCenter = [(rotatedB[0] + x) / 2, (rotatedB[1] + y) / 2];\n        var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);\n        var newBottomLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);\n        rectangle.endX = newTopRight[0];\n        rectangle.startY = newTopRight[1];\n        rectangle.startX = newBottomLeft[0];\n        rectangle.endY = newBottomLeft[1];\n        rectangle.width = rectangle.endX - rectangle.startX;\n        rectangle.height = rectangle.endY - rectangle.startY;\n        return rectangle;\n    };\n    Selection.prototype.adjustSEPoints = function (rectangle, x, y, angle) {\n        var cx = rectangle.startX + rectangle.width / 2;\n        var cy = rectangle.startY + rectangle.height / 2;\n        var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);\n        var newCenter = [(rotatedA[0] + x) / 2, (rotatedA[1] + y) / 2];\n        var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);\n        var newBottomRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);\n        rectangle.startX = newTopLeft[0];\n        rectangle.startY = newTopLeft[1];\n        rectangle.width = newBottomRight[0] - newTopLeft[0];\n        rectangle.height = newBottomRight[1] - newTopLeft[1];\n        rectangle.endX = rectangle.startX + rectangle.width;\n        rectangle.endY = rectangle.startY + rectangle.height;\n        return rectangle;\n    };\n    Selection.prototype.adjustRotationPoints = function (rectangle, x, y, angle, type, elem) {\n        var cx = rectangle.startX + rectangle.width / 2;\n        var cy = rectangle.startY + rectangle.height / 2;\n        this.getResizeDirection(rectangle, x, y, angle, type, elem);\n        var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);\n        var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);\n        var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);\n        var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);\n        var newCenter = [(rotatedA[0] + rotatedC[0]) / 2, (rotatedA[1] + rotatedC[1]) / 2];\n        var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);\n        var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);\n        var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);\n        rectangle.startX = newTopLeft[0];\n        rectangle.startY = newTopLeft[1];\n        rectangle.endX = newTopRight[0];\n        rectangle.endY = newBottomLeft[1];\n        rectangle.width = rectangle.endX - rectangle.startX;\n        rectangle.height = rectangle.endY - rectangle.startY;\n        return rectangle;\n    };\n    Selection.prototype.rotatePoints = function (x, y, cx, cy, angle) {\n        return [\n            (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,\n            (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy\n        ];\n    };\n    Selection.prototype.setResizedValue = function (element, value, x, y) {\n        switch (element) {\n            case 'x':\n                value += x;\n                break;\n            case 'y':\n                value += y;\n                break;\n            case 'abs-x':\n                value += (x > 0 ? -x : Math.abs(x));\n                break;\n            case 'abs-y':\n                value += (y > 0 ? -y : Math.abs(y));\n                break;\n            case 'y-abs-x':\n                value += (y + ((x > 0 ? -x : Math.abs(x)) / 2));\n                break;\n            case 'abs-x-abs-y':\n                value += ((x > 0 ? -x : Math.abs(x)) + ((y > 0 ? -y : Math.abs(y)) / 2));\n                break;\n            case 'abs-y-x':\n                value += ((y > 0 ? -y : Math.abs(y)) + (x / 2));\n                break;\n            case 'x-y':\n                value += (x + (y / 2));\n                break;\n            case 'y-x':\n                value += (y + (x / 2));\n                break;\n            case 'img-resize-x':\n                value += x;\n                break;\n            case 'img-resize-y':\n                value += y;\n                break;\n        }\n        return value;\n    };\n    Selection.prototype.getResizeDirection = function (rectangle, x, y, angle, type, elem) {\n        var rotatedAngle = angle * (180 / Math.PI);\n        var element = this.getResizedElement(rotatedAngle, this.resizedElement);\n        if (this.resizedElement === 'e-resize') {\n            rectangle.width = this.setResizedValue(element, rectangle.width, x, y);\n            rectangle.endX = rectangle.width + rectangle.startX;\n        }\n        else if (this.resizedElement === 'n-resize') {\n            rectangle.startY = this.setResizedValue(element, rectangle.startY, x, y);\n            rectangle.height = rectangle.endY - rectangle.startY;\n        }\n        else if (this.resizedElement === 'w-resize') {\n            rectangle.startX = this.setResizedValue(element, rectangle.startX, x, y);\n            rectangle.width = rectangle.startX + rectangle.endX;\n        }\n        else if (this.resizedElement === 's-resize') {\n            rectangle.height = this.setResizedValue(element, rectangle.height, x, y);\n            rectangle.endY = rectangle.height + rectangle.startY;\n        }\n        else if (type && type === 'img-resize') {\n            rectangle.width = this.setResizedValue('img-resize-x', rectangle.width, x, y);\n            rectangle.height = this.setResizedValue('img-resize-y', rectangle.height, x, y);\n            if (elem === 'se-resize') {\n                rectangle.endX = rectangle.width + rectangle.startX;\n                rectangle.endY = rectangle.height + rectangle.startY;\n            }\n            else if (elem === 'sw-resize') {\n                rectangle.startX = rectangle.endX - rectangle.width;\n                rectangle.endY = rectangle.height + rectangle.startY;\n            }\n            else if (elem === 'ne-resize') {\n                rectangle.endX = rectangle.width + rectangle.startX;\n                rectangle.startY = rectangle.endY - rectangle.height;\n            }\n            else if (elem === 'nw-resize') {\n                rectangle.startX = rectangle.endX - rectangle.width;\n                rectangle.startY = rectangle.endY - rectangle.height;\n            }\n        }\n        else if (type && type === 'text') {\n            if (elem === 'widthHeight') {\n                rectangle.width = this.setResizedValue('x-y', rectangle.width, x, y);\n                rectangle.endX = rectangle.width + rectangle.startX;\n                rectangle.height = this.setResizedValue('y-x', rectangle.height, x, y);\n                rectangle.endY = rectangle.height + rectangle.startY;\n            }\n            else if (elem === 'width') {\n                rectangle.width = this.setResizedValue('x-y', rectangle.width, x, y);\n                rectangle.endX = rectangle.width + rectangle.startX;\n            }\n            else if (elem === 'height') {\n                rectangle.height = this.setResizedValue('y-abs-x', rectangle.height, x, y);\n                rectangle.endY = rectangle.height + rectangle.startY;\n            }\n        }\n    };\n    Selection.prototype.getResizedElement = function (degree, element) {\n        var resizeMappings = [];\n        if (element === 'n-resize') {\n            resizeMappings = [\n                [337.5, 360, 'y'],\n                [0, 22.5, 'y'],\n                [22.5, 67.5, 'y-abs-x'],\n                [67.5, 112.5, 'abs-x'],\n                [112.5, 157.5, 'abs-x-abs-y'],\n                [157.5, 202.5, 'abs-y'],\n                [202.5, 247.5, 'abs-y-x'],\n                [247.5, 292.5, 'x'],\n                [292.5, 337.5, 'x-y']\n            ];\n        }\n        else if (element === 'e-resize') {\n            resizeMappings = [\n                [337.5, 360, 'x'],\n                [0, 22.5, 'x'],\n                [22.5, 67.5, 'x-y'],\n                [67.5, 112.5, 'y'],\n                [112.5, 157.5, 'y-abs-x'],\n                [157.5, 202.5, 'abs-x'],\n                [202.5, 247.5, 'abs-x-abs-y'],\n                [247.5, 292.5, 'abs-y'],\n                [292.5, 337.5, 'abs-y-x']\n            ];\n        }\n        else if (element === 's-resize') {\n            resizeMappings = [\n                [337.5, 360, 'y'],\n                [0, 22.5, 'y'],\n                [22.5, 67.5, 'y-abs-x'],\n                [67.5, 112.5, 'abs-x'],\n                [112.5, 157.5, 'abs-x-abs-y'],\n                [157.5, 202.5, 'abs-y'],\n                [202.5, 247.5, 'abs-y-x'],\n                [247.5, 292.5, 'x'],\n                [292.5, 337.5, 'x-y']\n            ];\n        }\n        else if (element === 'w-resize') {\n            resizeMappings = [\n                [337.5, 360, 'x'],\n                [0, 22.5, 'x'],\n                [22.5, 67.5, 'x-y'],\n                [67.5, 112.5, 'y'],\n                [112.5, 157.5, 'y-abs-x'],\n                [157.5, 202.5, 'abs-x'],\n                [202.5, 247.5, 'abs-x-abs-y'],\n                [247.5, 292.5, 'abs-y'],\n                [292.5, 337.5, 'abs-y-x']\n            ];\n        }\n        var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;\n        for (var _i = 0, resizeMappings_2 = resizeMappings; _i < resizeMappings_2.length; _i++) {\n            var _a = resizeMappings_2[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];\n            if ((positiveDegree > startDegree && positiveDegree <= endDegree) ||\n                (positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree)) {\n                return resizeElement;\n            }\n        }\n        return element;\n    };\n    Selection.prototype.updateCursorStyles = function (x, y, type) {\n        var parent = this.parent;\n        var isResize = false;\n        if (parent.activeObj.keyHistory !== '' && parent.activeObj.shape === undefined && !parent.currObjType.isCustomCrop &&\n            !parent.currObjType.isLine && parent.currObjType.isText) {\n            parent.activeObj.shape = 'text';\n        }\n        var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(actObj.topLeftCircle)) {\n            return;\n        }\n        var degree;\n        if (actObj.shapeDegree === 0) {\n            degree = parent.transform.degree;\n        }\n        else {\n            degree = parent.transform.degree - actObj.shapeDegree;\n        }\n        if (degree < 0) {\n            degree = 360 + degree;\n        }\n        if (this.isObjSelected) {\n            if (actObj.shape === 'line' || actObj.shape === 'arrow') {\n                isResize = this.updateCursorStylesForLineArrow(x, y, actObj);\n            }\n            else if (actObj.shape === 'path') {\n                isResize = this.updateCursorStylesForPath(x, y, actObj);\n            }\n            else if (actObj.rotatedAngle) {\n                this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);\n                if (parent.cursor === 'grabbing') {\n                    parent.upperCanvas.style.cursor = parent.cursor = 'grabbing';\n                    this.dragElement = parent.cursor;\n                }\n                else if (parent.cursor === 'move') {\n                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;\n                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;\n                }\n                else if (parent.cursor !== 'default') {\n                    isResize = true;\n                    this.dragElement = parent.cursor;\n                    parent.currObjType.isResize = true;\n                }\n            }\n            else {\n                var rotationCirclePoint = this.getTransRotationPoint(actObj);\n                var radius = actObj.topLeftCircle.radius;\n                if (rotationCirclePoint &&\n                    x >= rotationCirclePoint.x - (radius * 2) &&\n                    x <= rotationCirclePoint.x + (radius * 2) &&\n                    y >= rotationCirclePoint.y - (radius * 2) &&\n                    y <= rotationCirclePoint.y + (radius * 2) && this.dragElement !== 'grabbing') {\n                    parent.upperCanvas.style.cursor = parent.cursor = 'grabbing';\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.topLeftCircle.startX - (radius * 2)) &&\n                    x <= (actObj.topLeftCircle.startX + (radius * 2)) &&\n                    y >= (actObj.topLeftCircle.startY - (radius * 2)) &&\n                    y <= (actObj.topLeftCircle.startY + (radius * 2)) && this.dragElement !== 'nw-resize') {\n                    actObj.topLeftCircle.startX = actObj.topLeftCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.topLeftCircle.startX - (radius * 2)) &&\n                    x <= (actObj.topRightCircle.startX - (radius * 2)) &&\n                    y >= (actObj.topCenterCircle.startY - (radius * 2)) &&\n                    y <= (actObj.topCenterCircle.startY + (radius * 2)) && this.dragElement !== 'n-resize') {\n                    actObj.topCenterCircle.startX = actObj.topCenterCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 'n-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.topRightCircle.startX - (radius * 2)) &&\n                    x <= (actObj.topRightCircle.startX + (radius * 2)) &&\n                    y >= (actObj.topRightCircle.startY - (radius * 2)) &&\n                    y <= (actObj.topRightCircle.startY + (radius * 2)) && this.dragElement !== 'ne-resize') {\n                    actObj.topRightCircle.startX = actObj.topRightCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.centerLeftCircle.startX - (radius * 2)) &&\n                    x <= (actObj.centerLeftCircle.startX + (radius * 2)) &&\n                    y >= (actObj.topLeftCircle.startY - (radius * 2)) &&\n                    y <= (actObj.bottomLeftCircle.startY - (radius * 2)) && this.dragElement !== 'w-resize') {\n                    actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 'w-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.centerRightCircle.startX - (radius * 2)) &&\n                    x <= (actObj.centerRightCircle.startX + (radius * 2)) &&\n                    y >= (actObj.topRightCircle.startY - (radius * 2)) &&\n                    y <= (actObj.bottomRightCircle.startY - (radius * 2)) && this.dragElement !== 'e-resize') {\n                    actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 'e-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.bottomLeftCircle.startX - (radius * 2)) &&\n                    x <= (actObj.bottomLeftCircle.startX + (radius * 2)) &&\n                    y >= (actObj.bottomLeftCircle.startY - (radius * 2)) &&\n                    y <= (actObj.bottomLeftCircle.startY + (radius * 2)) && this.dragElement !== 'sw-resize') {\n                    actObj.bottomLeftCircle.startX = actObj.bottomLeftCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.bottomLeftCircle.startX - (radius * 2)) &&\n                    x <= (actObj.bottomRightCircle.startX - (radius * 2)) &&\n                    y >= (actObj.bottomCenterCircle.startY - (radius * 2)) &&\n                    y <= (actObj.bottomCenterCircle.startY + (radius * 2)) && this.dragElement !== 's-resize') {\n                    actObj.bottomCenterCircle.startX = actObj.bottomCenterCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 's-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else if (x >= (actObj.bottomRightCircle.startX - (radius * 2)) &&\n                    x <= (actObj.bottomRightCircle.startX + (radius * 2)) &&\n                    y >= (actObj.bottomRightCircle.startY - (radius * 2)) &&\n                    y <= (actObj.bottomRightCircle.startY + (radius * 2)) && this.dragElement !== 'se-resize') {\n                    actObj.bottomRightCircle.startX = actObj.bottomRightCircle.startY = 0;\n                    parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';\n                    isResize = true;\n                    this.dragElement = parent.upperCanvas.style.cursor;\n                }\n                else {\n                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;\n                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;\n                }\n                if ((actObj.shape === 'text') && (parent.cursor === 'n-resize' ||\n                    parent.cursor === 's-resize' || parent.cursor === 'e-resize' ||\n                    parent.cursor === 'w-resize')) {\n                    parent.upperCanvas.style.cursor = parent.cursor = 'move';\n                    this.dragElement = '';\n                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;\n                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;\n                }\n            }\n        }\n        else {\n            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;\n            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;\n        }\n        this.previousPoint.x = this.previousPoint.y = this.diffPoint.x = this.diffPoint.y = 0;\n        if (type === 'touchstart') {\n            if (isResize || (x >= actObj.activePoint.startX && x <= actObj.activePoint.endX\n                && y >= actObj.activePoint.startY && y <= actObj.activePoint.endY) || this.dragElement === 'grabbing') {\n                parent.currObjType.isDragging = true;\n            }\n            else if (actObj.shape === 'line' || actObj.shape === 'arrow') {\n                this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);\n                if (parent.cursor === 'move') {\n                    parent.currObjType.isDragging = true;\n                }\n            }\n            else if (actObj.shape === 'path') {\n                this.setCursorForPath(actObj, x, y, parent.upperCanvas);\n                if (parent.cursor === 'move') {\n                    parent.currObjType.isDragging = true;\n                }\n            }\n        }\n        else {\n            parent.currObjType.isDragging = true;\n        }\n        if (actObj.rotatedAngle !== 0 && (this.dragElement === 'e-resize' ||\n            this.dragElement === 'w-resize' || this.dragElement === 'n-resize' ||\n            this.dragElement === 's-resize')) {\n            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;\n            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;\n        }\n    };\n    Selection.prototype.updateCursorStylesForLineArrow = function (x, y, actObj) {\n        var isResize = false;\n        var parent = this.parent;\n        var point;\n        var radius = actObj.topLeftCircle.radius;\n        for (var i = 0; i < 5; i++) {\n            point = actObj.pointColl[i];\n            if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&\n                y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {\n                actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;\n                this.dragElement = 'w-resize';\n                isResize = true;\n                break;\n            }\n        }\n        if (!isResize) {\n            for (var i = 1; i < 6; i++) {\n                point = actObj.pointColl[actObj.pointColl.length - i];\n                if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&\n                    y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {\n                    actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;\n                    this.dragElement = 'e-resize';\n                    isResize = true;\n                    break;\n                }\n            }\n        }\n        if (!isResize) {\n            for (var i = 0; i < actObj.pointColl.length; i++) {\n                point = actObj.pointColl[i];\n                if (x >= (point.x - (radius * 2)) && x <= (point.x + (radius * 2)) &&\n                    y >= (point.y - (radius * 2)) && y <= (point.y + (radius * 2))) {\n                    parent.upperCanvas.style.cursor = parent.cursor = 'move';\n                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;\n                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;\n                    break;\n                }\n                else {\n                    parent.upperCanvas.style.cursor = parent.cursor = 'default';\n                }\n            }\n        }\n        return isResize;\n    };\n    Selection.prototype.updateCursorStylesForPath = function (x, y, actObj) {\n        var isResize = false;\n        var parent = this.parent;\n        this.pathAdjustedIndex = this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);\n        if (parent.cursor === 'move') {\n            isResize = true;\n            this.dragElement = 'pathDrag';\n        }\n        if (!isResize) {\n            parent.upperCanvas.style.cursor = parent.cursor = 'move';\n            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;\n            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;\n        }\n        return isResize;\n    };\n    Selection.prototype.setTextSelection = function (width, height) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var degree = parent.transform.degree;\n        if (parent.activeObj.shapeDegree === 0) {\n            degree = parent.transform.degree;\n        }\n        else {\n            degree = parent.transform.degree - parent.activeObj.shapeDegree;\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        var coll = parent.activeObj.rotateFlipColl;\n        if (this.isTransformedShape && coll) {\n            degree = 0;\n            for (var i = 0; i < coll.length; i++) {\n                if (typeof (coll[i]) === 'number') {\n                    degree += (coll[i]);\n                }\n            }\n        }\n        if (degree < 0) {\n            degree = 360 + degree;\n        }\n        for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {\n            var flip = parent.activeObj.flipObjColl[i].toLowerCase();\n            switch (degree) {\n                case 0:\n                    switch (flip) {\n                        case 'horizontal':\n                            actPoint = { startX: actPoint.endX - width, startY: actPoint.startY, endX: (actPoint.endX),\n                                endY: actPoint.startY + (height ? height : 0) };\n                            break;\n                        case 'vertical':\n                            actPoint.startY = actPoint.endY - height;\n                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + (width ? width : 0)),\n                                endY: actPoint.endY };\n                            break;\n                        default:\n                            actPoint = { startX: actPoint.startX,\n                                startY: actPoint.startY, endX: (actPoint.startX + (width ? width : 0)), endY: actPoint.startY +\n                                    (height ? height : 0) };\n                            break;\n                    }\n                    break;\n                case 90:\n                    switch (flip) {\n                        case 'horizontal':\n                            actPoint.endX = actPoint.startX + height;\n                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.endX),\n                                endY: actPoint.startY + (width ? width : 0) };\n                            break;\n                        case 'vertical':\n                            actPoint.startX = actPoint.endX - height;\n                            actPoint = { startX: actPoint.startX, startY: actPoint.endY - width, endX: (actPoint.endX), endY: actPoint.endY };\n                            break;\n                        default:\n                            actPoint.startX = actPoint.endX - height;\n                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.endX),\n                                endY: actPoint.startY + (width ? width : 0) };\n                            break;\n                    }\n                    break;\n                case 180:\n                    switch (flip) {\n                        case 'horizontal':\n                            actPoint.startY = actPoint.endY - height;\n                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + width),\n                                endY: actPoint.endY };\n                            break;\n                        case 'vertical':\n                            actPoint.endY = actPoint.startY + height;\n                            actPoint = { endX: actPoint.endX, endY: actPoint.endY, startX: (actPoint.endX - (width ? width : 0)),\n                                startY: actPoint.startY };\n                            break;\n                        default:\n                            actPoint = { endX: actPoint.endX, endY: actPoint.endY, startX: (actPoint.endX - (width ? width : 0)),\n                                startY: actPoint.endY - (height ? height : 0) };\n                            break;\n                    }\n                    break;\n                case 270:\n                    switch (flip) {\n                        case 'horizontal':\n                            actPoint.startX = actPoint.endX - height;\n                            actPoint = { startX: actPoint.startX, startY: actPoint.endY - (width ? width : 0), endX: actPoint.endX,\n                                endY: actPoint.endY };\n                            break;\n                        case 'vertical':\n                            actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + height),\n                                endY: actPoint.startY + (width ? width : 0) };\n                            break;\n                        default:\n                            actPoint.endX = actPoint.startX + height;\n                            actPoint = { startX: actPoint.startX, startY: actPoint.endY - (width ? width : 0), endX: actPoint.endX,\n                                endY: actPoint.endY };\n                            break;\n                    }\n                    break;\n            }\n        }\n        if (parent.activeObj.flipObjColl.length === 0) {\n            switch (degree) {\n                case 0:\n                    actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.startX + (width ? width : 0)),\n                        endY: actPoint.startY + (height ? height : 0) };\n                    break;\n                case 90:\n                    actPoint.startX = actPoint.endX - height;\n                    actPoint = { startX: actPoint.startX, startY: actPoint.startY, endX: (actPoint.endX),\n                        endY: actPoint.startY + (width ? width : 0) };\n                    break;\n                case 180:\n                    actPoint = { endX: actPoint.endX, endY: actPoint.endY, startX: (actPoint.endX - (width ? width : 0)),\n                        startY: actPoint.endY - (height ? height : 0) };\n                    break;\n                case 270:\n                    actPoint.endX = actPoint.startX + height;\n                    actPoint = { startX: actPoint.startX, startY: actPoint.endY - (width ? width : 0), endX: actPoint.endX,\n                        endY: actPoint.endY };\n                    break;\n            }\n        }\n        actPoint.width = actPoint.endX - actPoint.startX;\n        actPoint.height = actPoint.endY - actPoint.startY;\n        parent.activeObj.activePoint = actPoint;\n        if (parent.transform.degree === 360 || parent.transform.degree === -360) {\n            parent.transform.degree = 0;\n        }\n    };\n    Selection.prototype.setActivePoint = function (startX, startY) {\n        var parent = this.parent;\n        var activePoint = parent.activeObj.activePoint;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(activePoint)) {\n            return;\n        }\n        if (parent.currObjType.isText) {\n            var textWidth = startX ? startX : 0;\n            var textHeight = startY ? startY : parent.activeObj.textSettings.fontSize;\n            if (parent.activeObj.textSettings.fontSize === undefined) {\n                parent.activeObj.textSettings.fontSize = (Math.abs(parent.baseImgCanvas.width - parent.baseImgCanvas.height)) * 0.1;\n            }\n            this.setTextSelection(textWidth, textHeight);\n            this.mouseDownPoint.x = activePoint.endX;\n            this.mouseDownPoint.y = activePoint.endY;\n            if (parent.activeObj.horTopLine !== undefined) {\n                parent.activeObj.activePoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, activePoint, {}, true);\n            }\n            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });\n        }\n        else if (startX && startY) {\n            activePoint.startX = this.mouseDownPoint.x = startX;\n            activePoint.startY = this.mouseDownPoint.y = startY;\n            parent.currObjType.isDragging = true;\n        }\n        else {\n            var selectInfo = parent.activeObj;\n            activePoint = { startX: selectInfo.horTopLine.startX, startY: selectInfo.horTopLine.startY,\n                endX: selectInfo.horTopLine.endX, endY: selectInfo.horTopLine.endY };\n            activePoint.width = activePoint.endX - activePoint.startX;\n            activePoint.height = activePoint.endY - activePoint.startY;\n        }\n    };\n    Selection.prototype.mouseDownEventHandler = function (e) {\n        var parent = this.parent;\n        parent.isKBDNavigation = false;\n        this.mouseDown = e.currentTarget === parent.lowerCanvas || e.currentTarget === parent.upperCanvas ?\n            'canvas' : '';\n        if (e.type === 'touchstart') {\n            this.isTouch = true;\n        }\n        else {\n            this.isTouch = false;\n        }\n        if (e.type === 'touchstart' && e.currentTarget === parent.lowerCanvas && !parent.isImageLoaded) {\n            return;\n        }\n        this.isCropSelection = false;\n        this.isPan = true;\n        var splitWords;\n        if (parent.activeObj.shape !== undefined) {\n            splitWords = parent.activeObj.shape.split('-');\n        }\n        if (splitWords !== undefined && splitWords[0] === 'crop') {\n            this.isCropSelection = true;\n        }\n        if (this.isCropSelection) {\n            this.dragCanvas = parent.togglePan = true;\n        }\n        if (parent.cursor === 'grabbing') {\n            var obj = { shapeSettingsObj: {} };\n            this.isGrabbing = true;\n            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });\n            var shapeSettings = obj['shapeSettingsObj'];\n            var shapeResizingArgs = { cancel: false, action: 'rotate-start', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            var shapeMovingArgs = { cancel: false, action: 'rotate-start', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-down');\n        }\n        var imageEditorClickEventArgs = { point: this.setXYPoints(e) };\n        parent.trigger('click', imageEditorClickEventArgs);\n        this.isMouseDown = true;\n        this.isMouseUp = false;\n        this.clickEvent(imageEditorClickEventArgs, e);\n    };\n    Selection.prototype.getImagePoints = function (x, y) {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        if (x < destLeft) {\n            x = destLeft;\n        }\n        else if (x > destLeft + destWidth) {\n            x = destLeft + destWidth;\n        }\n        if (y < destTop) {\n            y = destTop;\n        }\n        else if (y > destTop + destHeight) {\n            y = destTop + destHeight;\n        }\n        return { x: x, y: y };\n    };\n    Selection.prototype.clickEvent = function (imageEditorClickEventArgs, e) {\n        var parent = this.parent;\n        var activePoint = parent.activeObj.activePoint;\n        var x = imageEditorClickEventArgs.point.x;\n        var y = imageEditorClickEventArgs.point.y;\n        var cursor = parent.activeObj.shape && parent.activeObj.shape === 'text' ?\n            parent.cursor : 'default';\n        var tempCursor = parent.upperCanvas.style.cursor;\n        if (parent.isResize) {\n            this.performEnterAction(e);\n            parent.upperCanvas.style.cursor = 'default';\n            return;\n        }\n        else if (JSON.stringify(parent.frameObj) !== JSON.stringify(parent.tempFrameObj)) {\n            parent.okBtn();\n        }\n        else if (this.currentDrawingShape !== '' && (!this.isShapeTouch(e, this.isCropSelection) &&\n            ((this.isTouch) || tempCursor === 'crosshair' || parent.isShapeDrawing))) {\n            if (parent.drawingShape && !parent.isShapeDrawing) {\n                parent.okBtn();\n                parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);\n            }\n            activePoint = parent.activeObj.activePoint;\n            var object_1 = { currObj: {} };\n            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object_1 } });\n            this.initialPrevObj = object_1['currObj'];\n            this.initialPrevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n            this.initialPrevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n            this.initialPrevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n            var selPointCollObj = { selPointColl: null };\n            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n                value: { obj: selPointCollObj } });\n            this.initialPrevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n            this.setActivePoint(x, y);\n            activePoint = parent.activeObj.activePoint;\n            if (this.currentDrawingShape === 'path') {\n                var point = this.getImagePoints(x, y);\n                parent.activeObj.pointColl.push({ x: point.x, y: point.y });\n                if (activePoint.width !== 0 && activePoint.height !== 0) {\n                    activePoint.width = 0;\n                    activePoint.height = 0;\n                    activePoint.startX = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].x;\n                    activePoint.startY = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].y;\n                }\n            }\n            activePoint.endX = activePoint.startX;\n            activePoint.endY = activePoint.startY;\n            if (this.currentDrawingShape === 'text') {\n                parent.activeObj.textSettings.fontSize = 11;\n                this.previousPoint.x = activePoint.startX;\n                this.previousPoint.y = activePoint.startY;\n                parent.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,\n                    value: { isTextBox: null } });\n                var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;\n                activePoint.endX = activePoint.startX + width;\n                activePoint.endY = activePoint.startY + parent.activeObj.textSettings.fontSize;\n                activePoint.width = activePoint.endX - activePoint.startX;\n                activePoint.height = activePoint.endY - activePoint.startY;\n            }\n            else if (this.currentDrawingShape === 'arrow') {\n                parent.activeObj.start = this.arrowShape[0];\n                parent.activeObj.end = this.arrowShape[1];\n            }\n            parent.currObjType.isDragging = true;\n            var previousShapeSettings = this.updatePrevShapeSettings();\n            var shapeResizingArgs = { cancel: false, action: 'draw-start', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            this.shapeResizingArgs = shapeResizingArgs;\n            this.shapeMovingArgs = shapeMovingArgs;\n            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-down');\n            parent.activeObj.activePoint = activePoint;\n            parent.isShapeDrawing = true;\n            this.tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n            return;\n        }\n        parent.notify('draw', { prop: 'resetFrameZoom', onPropertyChange: false, value: { isOk: true } });\n        if (this.isCropSelection && this.dragCanvas) {\n            this.setCursor(x, y);\n            if (parent.cursor !== 'move' && parent.cursor !== 'crosshair' &&\n                parent.cursor !== 'default' && parent.cursor !== 'grab') {\n                this.isPan = false;\n            }\n        }\n        if (parent.activeObj.shape) {\n            this.isObjSelected = true;\n        }\n        else {\n            this.isObjSelected = false;\n        }\n        var object = { currObj: {} };\n        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n        var prevObj = object['currObj'];\n        var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        var isShape = this.isShapeTouch(e, this.isCropSelection);\n        var isFreehandDraw = this.isFreehandDrawTouch(e, this.isCropSelection);\n        var isShapeClick = isShape ? isShape : this.isShapeClick(e, this.isCropSelection);\n        var allowUndoRedoPush = this.applyCurrShape(isShapeClick);\n        var isTextArea = parent.textArea.style.display !== 'none' ? true : false;\n        if (this.isTouch && !isShape && activeObj.shape && !this.isCropSelection) {\n            if (this.applyObj(x, y)) {\n                parent.okBtn(true);\n                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });\n            }\n            var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,\n                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                    previousCropObj: prevCropObj, previousText: null,\n                    currentText: null, previousFilter: null, isCircleCrop: parent.isCircleCrop } });\n            if (allowUndoRedoPush) {\n                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n            }\n        }\n        if (!isShape && !parent.togglePen && !this.isCropSelection && parent.activeObj.redactType !== 'blur' && parent.activeObj.redactType !== 'pixelate') {\n            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n            parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });\n        }\n        if (this.dragCanvas && this.isPan && (parent.cursor === 'grab' || this.isTouch)\n            && !isShape && !isFreehandDraw && !parent.togglePen) {\n            if (this.applyObj(x, y)) {\n                parent.okBtn(true);\n                if (allowUndoRedoPush) {\n                    var cursor_1 = parent.cursor;\n                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n                    parent.cursor = cursor_1;\n                }\n                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });\n            }\n            if (this.isFhdEditing) {\n                parent.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });\n                this.isFhdCustomized = false;\n                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });\n            }\n            var shape = parent.activeObj.shape;\n            var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'text', 'image', 'redact'];\n            if (shape && shapeColl.indexOf(shape) > -1) {\n                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                    value: { x: null, y: null, isMouseDown: null } });\n                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });\n                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n            }\n            var isCropSelection = false;\n            if (parent.activeObj.shape && parent.activeObj.shape.indexOf('crop-') > -1) {\n                isCropSelection = true;\n            }\n            if (parent.element.querySelector('.e-contextual-toolbar-wrapper') && !isCropSelection) {\n                if (!parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {\n                    parent.okBtn();\n                    parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');\n                }\n            }\n            this.canvasMouseDownHandler(e);\n        }\n        else {\n            var isLineArrow = false;\n            if (parent.activeObj.shape && (parent.activeObj.shape === 'line' ||\n                parent.activeObj.shape === 'arrow')) {\n                isLineArrow = true;\n            }\n            var points = this.setXYPoints(e);\n            var x_1 = points.x;\n            var y_1 = points.y;\n            if (this.applyObj(x_1, y_1)) {\n                parent.okBtn(true);\n                if (allowUndoRedoPush) {\n                    var cursor_2 = parent.cursor;\n                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n                    parent.cursor = cursor_2;\n                }\n                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });\n            }\n            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                value: { x: x_1, y: y_1, isMouseDown: true } });\n            var obj = { index: null };\n            parent.notify('freehand-draw', { prop: 'getFreehandDrawHoveredIndex', onPropertyChange: false, value: { obj: obj } });\n            var indexObj = { freehandSelectedIndex: null };\n            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });\n            if (this.isFhdPoint || (this.isFhdCustomized && !parent.togglePen)) {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(indexObj['freehandSelectedIndex']) &&\n                    indexObj['freehandSelectedIndex'] !== obj['index']) {\n                    var tempHoveredIndex = obj['index'];\n                    parent.okBtn();\n                    this.isFhdCustomized = false;\n                    parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,\n                        value: { index: tempHoveredIndex } });\n                    if (obj['index'] > -1) {\n                        var strokeColor = parent.pointColl[obj['index']].strokeColor;\n                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,\n                            value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[obj['index']].strokeWidth } });\n                    }\n                }\n                indexObj['freehandSelectedIndex'] = null;\n                parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });\n                var objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj['index']) && obj['index'] > -1) {\n                    parent.notify('freehand-draw', { prop: 'selectFhd', value: { type: 'ok' } });\n                    parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,\n                        value: { strokeColor: null, strokeWidth: null } });\n                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });\n                }\n                else if (indexObj['freehandSelectedIndex']) {\n                    parent.okBtn();\n                    var strokeColor = parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;\n                    parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,\n                        value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth } });\n                }\n                else if (this.findTargetObj(x_1, y_1, false)) {\n                    parent.objColl = objColl;\n                    this.findTarget(x_1, y_1, e.type);\n                    parent.notify('draw', { prop: 'redrawDownScale' });\n                }\n            }\n            else {\n                if (this.isFhdEditing) {\n                    parent.apply();\n                    var qbArea = document.getElementById(parent.element.id + '_quickAccessToolbarArea');\n                    if (qbArea) {\n                        qbArea.style.display = 'none';\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    var point = parent.pointColl[indexObj['freehandSelectedIndex']];\n                    var shapeSettings = { id: 'pen_' + (indexObj['freehandSelectedIndex'] + 1), type: _index__WEBPACK_IMPORTED_MODULE_1__.ShapeType.FreehandDraw,\n                        startX: point.points[0].x, startY: point.points[0].y, strokeColor: point.strokeColor,\n                        strokeWidth: point.strokeWidth, points: point.points, opacity: point.opacity,\n                        index: point.order };\n                    var shapeChangedArgs = { action: 'apply', currentShapeSettings: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, shapeSettings, {}, true) };\n                    parent.trigger('shapeChange', shapeChangedArgs);\n                    parent.editCompleteArgs = shapeChangedArgs;\n                }\n                var isPenDraw = parent.togglePen;\n                parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });\n                if (isPenDraw) {\n                    parent.freeHandDraw(true);\n                }\n                this.isFhdEditing = false;\n                if (isLineArrow) {\n                    this.setCursor(x_1, y_1);\n                }\n                else if (cursor !== 'default') {\n                    parent.upperCanvas.style.cursor = parent.cursor = cursor;\n                }\n                if (parent.cursor === 'crosshair' || (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice && parent.togglePen)) {\n                    if (parent.togglePen) {\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.strokeSettings)) {\n                            var obj_1 = { strokeSettings: {} };\n                            parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false, value: { obj: obj_1 } });\n                            parent.activeObj.strokeSettings = obj_1['strokeSettings'];\n                        }\n                        var obj_2 = { penStrokeWidth: null };\n                        parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: obj_2 } });\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj_2['penStrokeWidth'])) {\n                            parent.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: 2 } });\n                        }\n                        this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;\n                        this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;\n                        parent.notify('freehand-draw', { prop: 'resetSelPoints', onPropertyChange: false });\n                        parent.notify('freehand-draw', { prop: 'freehandDownHandler', onPropertyChange: false,\n                            value: { e: e, canvas: parent.upperCanvas } });\n                    }\n                    else {\n                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                    }\n                    parent.currObjType.isActiveObj = false;\n                    this.dragElement = '';\n                    this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;\n                }\n                if (((this.isTouch && tempCursor !== 'crosshair' || parent.cursor !== 'crosshair') &&\n                    e.type.toLowerCase() === 'touchstart') ||\n                    (parent.currObjType.isActiveObj && parent.cursor !== 'default' && !parent.togglePen)) {\n                    parent.notify('draw', { prop: 'updateTempObjColl' });\n                    parent.notify('draw', { prop: 'updateTempPointColl' });\n                    this.findTarget(x_1, y_1, e.type);\n                    parent.notify('draw', { prop: 'redrawDownScale' });\n                }\n                else if ((parent.currObjType.shape === '' || parent.currObjType.isCustomCrop) && !parent.togglePen && parent.cursor !== 'default') {\n                    this.setActivePoint(x_1, y_1);\n                }\n                if (isTextArea) {\n                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n                }\n            }\n        }\n        this.isShapeInserted = false;\n        this.tempActiveObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n    };\n    Selection.prototype.mouseMoveEventHandler = function (e) {\n        var parent = this.parent;\n        var cursor = parent.cursor;\n        var canvasCursor = parent.upperCanvas.style.cursor;\n        e.preventDefault();\n        if (this.isPreventShaping || (parent.isShapeDrawing && parent.currObjType.isDragging && this.isTouch &&\n            parent.activeObj.shape && parent.activeObj.shape === 'path')) {\n            return;\n        }\n        if (parent.cursor === 'grabbing' && this.isGrabbing) {\n            var obj = { shapeSettingsObj: {} };\n            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });\n            var shapeSettings = obj['shapeSettingsObj'];\n            var shapeResizingArgs = { cancel: false, action: 'rotating', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            var shapeMovingArgs = { cancel: false, action: 'rotating', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-down');\n        }\n        if (this.timer && this.timer > 0 && this.dragPoint.startX && this.dragPoint.startY) {\n            var width = Math.abs(this.dragPoint.startX - e.touches[0].clientX);\n            var height = Math.abs(this.dragPoint.startY - e.touches[0].clientY);\n            if (width > 10 || height > 10) {\n                this.timer = 0;\n            }\n        }\n        var bbox = parent.lowerCanvas.getBoundingClientRect();\n        if (e.type === 'touchmove' && e.touches.length === 2) {\n            if (this.isFirstMove) {\n                this.startTouches = this.targetTouches(e.touches);\n                this.tempTouches = [];\n                this.tempTouches.push({ x: (e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft) - bbox.left),\n                    y: (e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop)) - bbox.top });\n                this.tempTouches.push({ x: (e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left,\n                    y: (e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop)) - bbox.top });\n            }\n            else {\n                var firstFingerX = (e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left;\n                var firstFingerY = (e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop)) - bbox.top;\n                var secondFingerX = (e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left;\n                var secondFingerY = (e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop)) - bbox.top;\n                var center = { x: firstFingerX < secondFingerX ? secondFingerX - ((secondFingerX - firstFingerX) / 2) :\n                        firstFingerX - ((firstFingerX - secondFingerX) / 2), y: firstFingerY < secondFingerY ?\n                        secondFingerY - ((secondFingerY - firstFingerY) / 2) : firstFingerY - ((firstFingerY - secondFingerY) / 2) };\n                if (this.currMousePoint.x !== center.x && this.currMousePoint.y !== center.y) {\n                    var type = '';\n                    if (e.type === 'touchmove' && (parent.zoomSettings.zoomTrigger & _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.Pinch) === _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.Pinch) {\n                        this.zoomType = 'Pinch';\n                        var scale = this.calculateScale(this.startTouches, this.targetTouches(e.touches));\n                        this.startTouches = this.targetTouches(e.touches);\n                        if (scale > 1) {\n                            type = 'zoomIn';\n                        }\n                        else if (scale < 1) {\n                            type = 'zoomOut';\n                        }\n                    }\n                    if (type !== '') {\n                        parent.isZoomBtnClick = true;\n                        parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,\n                            value: { x: center.x, y: center.y, type: type, isResize: null } });\n                    }\n                    this.tempTouches = [];\n                    this.tempTouches.push({ x: e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft),\n                        y: e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop) });\n                    this.tempTouches.push({ x: e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft),\n                        y: e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop) });\n                    this.currMousePoint.x = center.x;\n                    this.currMousePoint.y = center.y;\n                    this.isPinching = true;\n                }\n            }\n            this.isFirstMove = false;\n            return;\n        }\n        var x;\n        var y;\n        if (e.type === 'mousemove') {\n            x = e.clientX;\n            y = e.clientY;\n        }\n        else {\n            this.touchEndPoint.x = x = e.touches[0].clientX;\n            this.touchEndPoint.y = y = e.touches[0].clientY;\n        }\n        x -= bbox.left;\n        y -= bbox.top;\n        this.canvasMouseMoveHandler(e);\n        var isCropSelection = false;\n        var splitWords;\n        if (parent.activeObj.shape !== undefined) {\n            splitWords = parent.activeObj.shape.split('-');\n        }\n        if (splitWords !== undefined && splitWords[0] === 'crop') {\n            isCropSelection = true;\n        }\n        if (isCropSelection) {\n            parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });\n        }\n        parent.upperCanvas.style.cursor = canvasCursor;\n        parent.cursor = cursor;\n        if (parent.currObjType.isActiveObj && (parent.activeObj.activePoint !== undefined || parent.objColl.length > 0) &&\n            !this.dragCanvas || parent.activeObj.activePoint !== undefined) {\n            if (this.dragElement === '') {\n                this.setCursor(x, y);\n                if ((parent.activeObj.activePoint &&\n                    (parent.activeObj.activePoint.width === 0 || (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.currIndex) &&\n                        this.cursorTargetId !== parent.activeObj.currIndex)))\n                    && parent.cursor !== 'default' &&\n                    parent.cursor !== 'move' && parent.cursor !== 'crosshair'\n                    && parent.cursor !== 'grab' && parent.cursor !== 'pointer') {\n                    parent.upperCanvas.style.cursor = parent.cursor = 'move';\n                }\n                this.findTarget(x, y, e.type);\n            }\n        }\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        if (parent.currObjType.isDragging) {\n            if (parent.activeObj.shape && parent.activeObj.preventShapeDragOut) {\n                if (x < destLeft || x > destLeft + destWidth || y < destTop || y > destTop + destHeight) {\n                    return;\n                }\n            }\n            this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n            this.updateActivePoint(x, y, isCropSelection);\n            parent.notify('shape', { prop: 'updateTrianglePoints', onPropertyChange: false, value: { obj: parent.activeObj } });\n            if (this.isPreventDragging) {\n                if (!this.isShapeDragOut()) {\n                    this.isPreventDragging = false;\n                }\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,\n                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });\n            }\n            else {\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,\n                        points: null, isPreventDrag: null, saveContext: null, isPreventSelection: null } });\n            }\n            if (isCropSelection) {\n                this.dragCanvas = parent.togglePan = true;\n            }\n        }\n        this.isMouseDown = false;\n        this.isMouseUp = false;\n    };\n    Selection.prototype.mouseUpEventHandler = function (e) {\n        var parent = this.parent;\n        var id = parent.element.id;\n        parent.isKBDNavigation = this.isMouseDown = false;\n        this.isMouseUp = true;\n        if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice && ((parent.element.querySelector('#' + id + '_contextualToolbar') &&\n            !parent.element.querySelector('#' + id + '_contextualToolbar').parentElement.classList.contains('e-hide')) ||\n            (parent.element.querySelector('#' + id + '_headWrapper')\n                && !parent.element.querySelector('#' + id + '_headWrapper').parentElement.classList.contains('e-hide')))) {\n            if (!(parent.activeObj.shape && parent.activeObj.shape === 'redact' && parent.isShapeDrawing)) {\n                return;\n            }\n        }\n        if (parent.cursor === 'grabbing' && this.isGrabbing) {\n            var obj = { shapeSettingsObj: {} };\n            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });\n            var shapeSettings = obj['shapeSettingsObj'];\n            var shapeResizingArgs = { cancel: false, action: 'rotate-end', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            var shapeMovingArgs = { cancel: false, action: 'rotate-end', previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };\n            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-up');\n        }\n        this.isGrabbing = false;\n        if (this.isPreventShaping) {\n            this.isPreventShaping = false;\n        }\n        if (this.mouseDown === 'canvas' || this.isSliderActive ||\n            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n            e.target.closest('.e-image-editor') || e.target.closest('.e-ie-ddb-popup')) {\n            if (e.type === 'touchstart') {\n                this.isTouch = false;\n            }\n            else if (e.type === 'touchend') {\n                e.stopImmediatePropagation();\n            }\n            e.preventDefault();\n            if (parent.togglePan) {\n                this.canvasMouseUpHandler(e);\n            }\n            var x = void 0;\n            var y = void 0;\n            if (e.type === 'mouseup') {\n                x = e.clientX;\n                y = e.clientY;\n            }\n            else if (!this.isTouchDblClick) {\n                x = this.touchEndPoint.x;\n                y = this.touchEndPoint.y;\n            }\n            var bbox = parent.lowerCanvas.getBoundingClientRect();\n            x -= bbox.left;\n            y -= bbox.top;\n            var activeObjShape = void 0;\n            var currentDrawingShape = this.currentDrawingShape;\n            var dummyClick = false;\n            if (e.type === 'touchend') {\n                this.startTouches = this.tempTouches = [];\n                this.isFirstMove = false;\n                if (parent.textArea.style.display === 'none') {\n                    this.timer = 0;\n                }\n                if (this.isPinching) {\n                    this.isPinching = false;\n                    parent.notify('draw', { prop: 'redrawDownScale' });\n                    if (parent.isCropTab || parent.activeObj.shape) {\n                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });\n                        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });\n                    }\n                    if (parent.isStraightening) {\n                        parent.notify('draw', { prop: 'resetStraightenDestPoints' });\n                        parent.notify('draw', { prop: 'setDestForStraighten' });\n                    }\n                    return;\n                }\n            }\n            var isCropSelection = false;\n            var splitWords = void 0;\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (splitWords !== undefined && splitWords[0] === 'crop') {\n                isCropSelection = true;\n            }\n            if (this.currentDrawingShape === 'path' && parent.isShapeDrawing) {\n                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n                var elem = e.srcElement;\n                var elemId = elem.parentElement.id;\n                var id_1 = parent.element.id;\n                // eslint-disable-next-line max-len\n                if (e.currentTarget !== parent.upperCanvas && e.currentTarget !== parent.lowerCanvas && parent.activeObj.pointColl.length > 0 &&\n                    (elem.classList.contains('e-upload-icon') || elemId === id_1 + '_zoomIn' ||\n                        elemId === id_1 + '_zoomOut' || elemId === id_1 + '_annotationBtn' ||\n                        elemId === id_1 + '_borderColorBtn' || elemId === id_1 + '_borderWidthBtn')) {\n                    parent.notify('shape', { prop: 'stopPathDrawing', onPropertyChange: false, value: { e: e, isApply: true } });\n                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                    parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,\n                            points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });\n                }\n                if (parent.currObjType.isDragging && this.isTouch &&\n                    parent.activeObj.shape && parent.activeObj.shape === 'path') {\n                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                    parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,\n                            points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });\n                }\n                return;\n            }\n            if (e.currentTarget === parent.upperCanvas && !parent.isResize) {\n                this.pathAdjustedIndex = null;\n                if (this.currentDrawingShape !== '') {\n                    if (this.currentDrawingShape === 'text') {\n                        var prevCropObj_1 = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n                        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                            value: { operation: 'shapeInsert', previousObj: this.initialPrevObj, previousObjColl: this.initialPrevObj.objColl,\n                                previousPointColl: this.initialPrevObj.pointColl, previousSelPointColl: this.initialPrevObj.selPointColl,\n                                previousCropObj: prevCropObj_1, previousText: null,\n                                currentText: null, previousFilter: null, isCircleCrop: null } });\n                    }\n                    else {\n                        parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: this.initialPrevObj.objColl, operation: 'shapeInsert' } });\n                    }\n                    this.isShapeInserted = true;\n                    this.currentDrawingShape = '';\n                    if ((parent.activeObj.shape && parent.activeObj.shape === 'path' && parent.activeObj.pointColl.length === 0) ||\n                        ((!parent.activeObj.shape || parent.activeObj.shape !== 'path') && parent.activeObj.activePoint.width === 0 &&\n                            parent.activeObj.activePoint.height === 0)) {\n                        dummyClick = true;\n                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                    }\n                    var previousShapeSettings = this.updatePrevShapeSettings();\n                    var shapeResizingArgs = { cancel: false, action: 'draw-end', previousShapeSettings: previousShapeSettings };\n                    var shapeMovingArgs = { cancel: false, action: 'move', previousShapeSettings: previousShapeSettings };\n                    this.shapeResizingArgs = shapeResizingArgs;\n                    this.shapeMovingArgs = shapeMovingArgs;\n                    this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'mouse-up');\n                }\n                if (parent.activeObj.shape && parent.activeObj.shape === 'path' && parent.activeObj.pointColl.length > 0) {\n                    parent.activeObj.activePoint = parent.getSquarePointForPath(parent.activeObj);\n                }\n                this.adjustActObjForLineArrow();\n                this.updPtCollForShpRot();\n                parent.currObjType.shape = parent.currObjType.shape.toLowerCase();\n                var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n                var object = { currObj: {} };\n                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n                var prevObj = object['currObj'];\n                prevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n                prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n                prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n                var selPointCollObj = { selPointColl: null };\n                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n                    value: { obj: selPointCollObj } });\n                prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n                if (!parent.togglePen && !isCropSelection) {\n                    if (this.tempObjColl && parent.activeObj.activePoint.width !== 0) {\n                        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n                        parent.objColl.push(parent.activeObj);\n                        if (JSON.stringify(parent.activeObj.activePoint) !== JSON.stringify(this.tempActiveObj.activePoint)) {\n                            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: this.tempObjColl,\n                                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                                    previousCropObj: prevCropObj, previousText: null,\n                                    currentText: null, previousFilter: null, isCircleCrop: null } });\n                        }\n                        var tempObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], {}, true);\n                        parent.objColl.pop();\n                        this.redrawShape(tempObj);\n                        this.tempObjColl = undefined;\n                    }\n                    if (!this.isFhdEditing) {\n                        this.applyCurrActObj(x, y);\n                        parent.currObjType.isResize = false;\n                        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });\n                    }\n                }\n                else if (isCropSelection && this.isMouseUp && parent.cursor.indexOf('resize') > -1) {\n                    var previousShapeSettings = this.updatePrevShapeSettings();\n                    var shapeResizingArgs = { cancel: false, action: 'resize-end', previousShapeSettings: previousShapeSettings };\n                    this.triggerShapeChange(shapeResizingArgs, shapeResizingArgs, 'resize');\n                }\n                if (parent.activeObj) {\n                    var isCropSelection_1 = false;\n                    var splitWords_1;\n                    if (parent.activeObj.shape !== undefined) {\n                        splitWords_1 = parent.activeObj.shape.split('-');\n                    }\n                    if (splitWords_1 === undefined && (parent.currObjType.isCustomCrop || parent.togglePen)) {\n                        isCropSelection_1 = true;\n                    }\n                    else if (splitWords_1 !== undefined && splitWords_1[0] === 'crop') {\n                        isCropSelection_1 = true;\n                    }\n                    var shape = parent.activeObj.shape;\n                    activeObjShape = shape;\n                    var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path'];\n                    if (shapeColl.indexOf(shape) > -1) {\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',\n                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    }\n                    else if (shape === 'text') {\n                        if (parent.textArea.style.display === 'none') {\n                            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',\n                                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                        }\n                    }\n                    else if (shape === 'redact') {\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',\n                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    }\n                    else if (this.isFhdEditing) {\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',\n                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    }\n                    else if (!isCropSelection_1) {\n                        var eventargs = { type: 'main', isApplyBtn: null, isCropping: false, isZooming: null };\n                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });\n                    }\n                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n                    if (!this.isFhdEditing) {\n                        var width = Math.floor(parent.activeObj.activePoint.width);\n                        if (parent.activeObj.shape && parent.activeObj.shape === 'text' &&\n                            parent.activeObj.textSettings.fontSize === 11 && Math.floor(parent.activeObj.activePoint.height) === 11 &&\n                            (width === 55 || (parent.activeObj.textSettings.bold && width === 58))) {\n                            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                            if (parent.drawingShape === 'text' && !parent.activeObj.keyHistory) {\n                                parent.activeObj.keyHistory = 'Enter Text';\n                            }\n                        }\n                        if (!isCropSelection_1) {\n                            this.adjustActObjForLineArrow();\n                            if (parent.isShapeDrawing) {\n                                var temp = this.currentDrawingShape;\n                                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });\n                                this.currentDrawingShape = temp;\n                            }\n                            else {\n                                parent.notify('undo-redo', { prop: 'updateUndoRedoStack', onPropertyChange: false });\n                            }\n                        }\n                    }\n                }\n            }\n            if (parent.activeObj.shape !== undefined) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (splitWords !== undefined && splitWords[0] === 'crop') {\n                isCropSelection = true;\n            }\n            if (parent.activeObj.shape && !isCropSelection && e.currentTarget === parent.upperCanvas &&\n                parent.textArea.style.display === 'none') {\n                if (parent.activeObj.shape === 'text') {\n                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',\n                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                }\n                else if (parent.activeObj.shape === 'redact') {\n                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'redact',\n                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                }\n                else {\n                    var temp = this.currentDrawingShape;\n                    this.currentDrawingShape = '';\n                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',\n                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n                    this.currentDrawingShape = temp;\n                }\n                parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });\n            }\n            var obj = { freehandDrawSelectedId: null };\n            parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });\n            if (parent.togglePen && e.currentTarget === parent.upperCanvas && !obj['freehandDrawSelectedId']) {\n                parent.notify('freehand-draw', { prop: 'freehandUpHandler', onPropertyChange: false,\n                    value: { e: e, canvas: parent.upperCanvas, context: this.upperContext } });\n                if (parent.togglePen && !parent.isMaskImage && ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.toolbar) ||\n                    (parent.toolbar && parent.toolbar.length > 0) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.toolbarTemplate))) {\n                    parent.okBtn();\n                    parent.freeHandDraw(true);\n                }\n            }\n            else {\n                parent.currObjType.shape = '';\n            }\n            this.dragElement = '';\n            this.mouseDown = '';\n            this.isSliderActive = false;\n            parent.currObjType.isInitialLine = parent.currObjType.isDragging = false;\n            this.selMouseUpEvent();\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.drawingShape) && activeObjShape && currentDrawingShape !== '') {\n                parent.drawingShape = activeObjShape;\n            }\n            if (parent.drawingShape) {\n                this.currentDrawingShape = parent.drawingShape.toLowerCase();\n                if (dummyClick) {\n                    parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);\n                    parent.upperCanvas.style.cursor = 'crosshair';\n                }\n            }\n            parent.isShapeDrawing = false;\n            parent.notify('freehand-draw', { prop: 'resetSelPoints', onPropertyChange: false });\n        }\n        this.isMouseUp = false;\n    };\n    Selection.prototype.adjustActObjForLineArrow = function (obj) {\n        var isAdjusted = false;\n        var parent = this.parent;\n        obj = obj ? obj : parent.activeObj;\n        if (obj.shape && (obj.shape === 'line' || parent.activeObj.shape === 'arrow')) {\n            var temp = void 0;\n            if ((this.dragElement === 'e-resize' && obj.activePoint.endX < obj.activePoint.startX) ||\n                (this.dragElement === 'w-resize' && obj.activePoint.startX > obj.activePoint.endX)) {\n                isAdjusted = true;\n                temp = obj.activePoint.startX;\n                obj.activePoint.startX = obj.activePoint.endX;\n                obj.activePoint.endX = temp;\n                temp = obj.activePoint.startY;\n                obj.activePoint.startY = obj.activePoint.endY;\n                obj.activePoint.endY = temp;\n            }\n            obj.activePoint.width = Math.abs(obj.activePoint.endX - obj.activePoint.startX);\n            obj.activePoint.height = Math.abs(obj.activePoint.endY - obj.activePoint.startY);\n            if (parent.activeObj.shape !== 'path') {\n                parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,\n                    value: { obj: obj } });\n                for (var i = 0; i < obj.pointColl.length; i++) {\n                    obj.pointColl[i].ratioX = (obj.pointColl[i].x -\n                        parent.img.destLeft) / parent.img.destWidth;\n                    obj.pointColl[i].ratioY = (obj.pointColl[i].y -\n                        parent.img.destTop) / parent.img.destHeight;\n                }\n            }\n        }\n        return isAdjusted;\n    };\n    Selection.prototype.updPtCollForShpRot = function (obj) {\n        var parent = this.parent;\n        obj = obj ? obj : parent.activeObj;\n        if (obj.shape && obj.rotatedAngle !== 0) {\n            parent.notify('shape', { prop: 'setPointCollForShapeRotation', onPropertyChange: false, value: { obj: obj } });\n            var _a = parent.img, destLeft_1 = _a.destLeft, destTop_1 = _a.destTop, destWidth_1 = _a.destWidth, destHeight_1 = _a.destHeight;\n            var horTopLinePointColl = obj.horTopLinePointColl, horBottomLinePointColl = obj.horBottomLinePointColl, verLeftLinePointColl = obj.verLeftLinePointColl, verRightLinePointColl = obj.verRightLinePointColl;\n            // eslint-disable-next-line @typescript-eslint/tslint/config\n            var setRatio = function (point) {\n                point.ratioX = (point.x - destLeft_1) / destWidth_1;\n                point.ratioY = (point.y - destTop_1) / destHeight_1;\n            };\n            horTopLinePointColl.forEach(setRatio);\n            horBottomLinePointColl.forEach(setRatio);\n            verLeftLinePointColl.forEach(setRatio);\n            verRightLinePointColl.forEach(setRatio);\n        }\n    };\n    Selection.prototype.setXYPoints = function (e) {\n        e.preventDefault();\n        var x;\n        var y;\n        if (e.type === 'mousedown') {\n            x = e.clientX;\n            y = e.clientY;\n        }\n        else {\n            this.touchEndPoint.x = x = e.touches[0].clientX;\n            this.touchEndPoint.y = y = e.touches[0].clientY;\n        }\n        var bbox = this.parent.lowerCanvas.getBoundingClientRect();\n        x -= bbox.left;\n        y -= bbox.top;\n        return { x: x, y: y };\n    };\n    Selection.prototype.getCurrentIndex = function () {\n        var index;\n        var parent = this.parent;\n        for (var i = 0, len = parent.objColl.length; i < len; i++) {\n            if (parent.activeObj.currIndex === parent.objColl[i].currIndex) {\n                index = i;\n                break;\n            }\n        }\n        return index;\n    };\n    Selection.prototype.isShapeClick = function (e, isCropSelection) {\n        var parent = this.parent;\n        var isShape = false;\n        if (parent.togglePen) {\n            return isShape;\n        }\n        if (parent.activeObj.shape && parent.activeObj.shape === 'text' && this.isShapeInserted) {\n            var isTextArea = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')\n                ? true : false;\n            var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                value: { x: null, y: null, isMouseDown: true } });\n            var points = this.setXYPoints(e);\n            var x = points.x;\n            var y = points.y;\n            isShape = this.findTargetObj(x, y, isCropSelection);\n            if (!isCropSelection) {\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                if (isShape) {\n                    parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                        value: { x: null, y: null, isMouseDown: true } });\n                }\n            }\n            if (isTextArea) {\n                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;\n                parent.textArea.style.display = 'block';\n                parent.activeObj = activeObj;\n                var index = this.getCurrentIndex();\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(index)) {\n                    parent.objColl.pop();\n                }\n                else {\n                    parent.objColl.splice(index, 1);\n                }\n            }\n            else if (!isShape && activeObj.shape) {\n                parent.activeObj = activeObj;\n                var index = this.getCurrentIndex();\n                if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(index) &&\n                    JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint))) {\n                    parent.objColl.splice(index, 1);\n                }\n                else if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.currIndex)) {\n                    parent.objColl.pop();\n                }\n            }\n        }\n        return isShape;\n    };\n    Selection.prototype.isShapeTouch = function (e, isCropSelection) {\n        var parent = this.parent;\n        var isShape = false;\n        if (e.type === 'touchstart' && !parent.togglePen) {\n            if (parent.activeObj && parent.activeObj.shape === 'text') {\n                this.timer = setTimeout(this.setTimer.bind(this), 1000, e);\n            }\n            var isTextArea = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')\n                ? true : false;\n            var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                value: { x: null, y: null, isMouseDown: true } });\n            var points = this.setXYPoints(e);\n            var x = points.x;\n            var y = points.y;\n            isShape = this.findTargetObj(x, y, isCropSelection);\n            if (!isCropSelection) {\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            }\n            if (isTextArea) {\n                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;\n                parent.textArea.style.display = 'block';\n                parent.activeObj = activeObj;\n                var index = this.getCurrentIndex();\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(index)) {\n                    parent.objColl.pop();\n                }\n                else {\n                    parent.objColl.splice(index, 1);\n                }\n            }\n            else if (!isShape && activeObj.shape && (activeObj.activePoint.width !== 0 || activeObj.activePoint.height !== 0 ||\n                (activeObj.shape === 'path' && activeObj.pointColl.length > 0))) {\n                parent.activeObj = activeObj;\n                var index = this.getCurrentIndex();\n                if (!isCropSelection) {\n                    if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(index) && JSON.stringify(parent.activeObj.activePoint) ===\n                        JSON.stringify(parent.objColl[index].activePoint))) {\n                        parent.objColl.splice(index, 1);\n                    }\n                    else if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.currIndex)) {\n                        parent.objColl.pop();\n                    }\n                }\n            }\n        }\n        return isShape;\n    };\n    Selection.prototype.isFreehandDrawTouch = function (e, isCropSelection) {\n        var parent = this.parent;\n        var isFreehandDraw = false;\n        if (e.type === 'touchstart' && !isCropSelection && !parent.togglePen) {\n            var isTextArea = (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')\n                ? true : false;\n            var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                value: { x: null, y: null, isMouseDown: true } });\n            var points = this.setXYPoints(e);\n            var x = points.x;\n            var y = points.y;\n            this.setCursor(x, y);\n            if (this.isFhdPoint) {\n                isFreehandDraw = true;\n            }\n            if (isTextArea) {\n                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;\n                parent.textArea.style.display = 'block';\n                parent.activeObj = activeObj;\n                var index = this.getCurrentIndex();\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(index)) {\n                    parent.objColl.pop();\n                }\n                else {\n                    parent.objColl.splice(index, 1);\n                }\n            }\n            else if (activeObj.shape) {\n                parent.activeObj = activeObj;\n                var index = this.getCurrentIndex();\n                if (!isCropSelection) {\n                    if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(index) && JSON.stringify(parent.activeObj.activePoint) ===\n                        JSON.stringify(parent.objColl[index].activePoint))) {\n                        parent.objColl.splice(index, 1);\n                    }\n                    else if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.currIndex)) {\n                        parent.objColl.pop();\n                    }\n                }\n            }\n        }\n        return isFreehandDraw;\n    };\n    Selection.prototype.applyObj = function (x, y) {\n        var parent = this.parent;\n        var isApply = false;\n        if (parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) {\n            return false;\n        }\n        var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'image', 'text'];\n        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;\n        if (parent.activeObj.shape && shapeColl.indexOf(parent.activeObj.shape) > -1) {\n            var radius = parent.activeObj.topLeftCircle.radius;\n            if (x >= (startX - (radius * 2)) && x <= (endX + (radius * 2)) && y >= (startY - (radius * 2)) &&\n                y <= (endY + (radius * 2))) {\n                isApply = false;\n            }\n            else if (parent.upperCanvas.style.cursor !== 'default' && parent.upperCanvas.style.cursor !== 'grab' &&\n                parent.upperCanvas.style.cursor !== 'crosshair' && parent.upperCanvas.style.cursor !== 'pointer' &&\n                parent.upperCanvas.style.cursor !== 'move') {\n                isApply = false;\n            }\n            else {\n                isApply = true;\n            }\n        }\n        return isApply;\n    };\n    Selection.prototype.applyCurrShape = function (isShapeClick) {\n        var parent = this.parent;\n        var isApply = false;\n        if (parent.togglePen) {\n            return isApply;\n        }\n        var obj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        if (this.isShapeInserted && parent.activeObj.shape === 'text' && isShapeClick) {\n            this.isInitialTextEdited = true;\n            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: true } });\n        }\n        if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {\n            var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,\n                value: { x: null, y: null, isMouseDown: null } });\n            obj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[parent.objColl.length - 1], null, true);\n            parent.objColl.pop();\n            parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, activeObj, null, true);\n            parent.textArea.value = obj.keyHistory;\n            parent.textArea.style.display = 'block';\n            var strokeColor = obj.strokeSettings && obj.strokeSettings.strokeColor ? obj.strokeSettings.strokeColor.split('(')[0] === 'rgb' ?\n                this.rgbToHex(parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[0]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[1]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[2]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[3])) :\n                obj.strokeSettings.strokeColor : null;\n            if (strokeColor && strokeColor === '#ffffff') {\n                strokeColor = '#fff';\n            }\n            if (this.tempActiveObj.strokeSettings && this.tempActiveObj.strokeSettings.strokeColor &&\n                this.tempActiveObj.strokeSettings.strokeColor === '#ffffff') {\n                this.tempActiveObj.strokeSettings.strokeColor = '#fff';\n            }\n            if (obj.keyHistory !== this.tempActiveObj.keyHistory ||\n                (strokeColor && (strokeColor !== this.tempActiveObj.strokeSettings.strokeColor)) ||\n                (obj.textSettings && obj.textSettings.fontFamily !== this.tempActiveObj.textSettings.fontFamily) ||\n                (obj.textSettings && Math.round(obj.textSettings.fontSize) !== Math.round(this.tempActiveObj.textSettings.fontSize)) ||\n                (obj.textSettings && Math.round(obj.textSettings.fontRatio) !== Math.round(this.tempActiveObj.textSettings.fontRatio)) ||\n                (obj.textSettings && obj.textSettings.bold !== this.tempActiveObj.textSettings.bold) ||\n                (obj.textSettings && obj.textSettings.italic !== this.tempActiveObj.textSettings.italic) ||\n                (obj.textSettings && obj.textSettings.underline !== this.tempActiveObj.textSettings.underline)) {\n                isApply = true;\n            }\n            if (this.isInitialTextEdited && !isApply) {\n                isApply = true;\n                this.isInitialTextEdited = false;\n            }\n        }\n        else {\n            this.tempActiveObj.activePoint.height = Math.abs(this.tempActiveObj.activePoint.height);\n            isApply = JSON.stringify(obj) !== JSON.stringify(this.tempActiveObj);\n        }\n        return isApply;\n    };\n    Selection.prototype.canvasMouseDownHandler = function (e) {\n        var parent = this.parent;\n        e.preventDefault();\n        var x;\n        var y;\n        if (e.type === 'mousedown') {\n            x = e.offsetX || (e.pageX - parent.lowerCanvas.offsetLeft);\n            y = e.offsetY || (e.pageY - parent.lowerCanvas.offsetTop);\n        }\n        else {\n            x = e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft);\n            y = e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop);\n        }\n        var bbox = parent.lowerCanvas.getBoundingClientRect();\n        x -= bbox.left;\n        y -= bbox.top;\n        this.panDown = { x: x, y: y };\n        var tempPanMoveObj = { tempPanMove: null };\n        parent.notify('transform', { prop: 'getTempPanMove', onPropertyChange: false,\n            value: { obj: tempPanMoveObj } });\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(tempPanMoveObj['tempPanMove'])) {\n            parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,\n                value: { point: { x: x, y: y } } });\n        }\n    };\n    Selection.prototype.canvasMouseMoveHandler = function (e) {\n        var parent = this.parent;\n        var frameObject = { bool: null };\n        parent.notify('toolbar', { prop: 'getFrameToolbar', onPropertyChange: false, value: { obj: frameObject } });\n        if (parent.isResize || frameObject['bool']) {\n            parent.upperCanvas.style.cursor = 'default';\n            return;\n        }\n        if (this.dragCanvas) {\n            parent.lowerCanvas.style.cursor = 'grab';\n        }\n        else {\n            this.dragCanvas = parent.togglePan = false;\n            parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'default';\n        }\n        var x;\n        var y;\n        if (e.type === 'mousemove') {\n            x = e.offsetX;\n            y = e.offsetY;\n        }\n        else {\n            x = e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft);\n            y = e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop);\n        }\n        var bbox = parent.lowerCanvas.getBoundingClientRect();\n        x -= bbox.left;\n        y -= bbox.top;\n        var panMove = { x: x, y: y };\n        parent.notify('transform', { prop: 'setPanMove', onPropertyChange: false,\n            value: { point: { x: x, y: y } } });\n        if (this.panDown && panMove && parent.togglePan && this.dragCanvas) {\n            if (parent.isCropTab || parent.activeObj.shape) {\n                parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });\n                parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });\n            }\n            parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,\n                value: { xDiff: null, yDiff: null } });\n        }\n    };\n    Selection.prototype.canvasMouseUpHandler = function (e) {\n        var parent = this.parent;\n        e.preventDefault();\n        var panMoveObj = { panMove: null };\n        parent.notify('transform', { prop: 'getPanMove', onPropertyChange: false,\n            value: { obj: panMoveObj } });\n        if (parent.togglePan) {\n            if (this.panDown && panMoveObj['panMove'] && parent.togglePan && this.dragCanvas) {\n                this.panDown = null;\n                parent.notify('transform', { prop: 'setPanMove', onPropertyChange: false,\n                    value: { point: null } });\n            }\n        }\n        parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,\n            value: { point: null } });\n        if (this.currentDrawingShape !== 'path') {\n            parent.currObjType.isDragging = false;\n        }\n    };\n    Selection.prototype.touchStartHandler = function (e) {\n        e.preventDefault();\n        var parent = this.parent;\n        if (this.touchTime === 0) {\n            this.touchTime = new Date().getTime();\n        }\n        else {\n            if (((new Date().getTime()) - this.touchTime) < 400) {\n                this.isTouchDblClick = true;\n                var temp = parent.isShapeDrawing;\n                parent.notify('shape', { prop: 'stopPathDrawing', onPropertyChange: false, value: { e: e, isApply: null } });\n                this.isTouchDblClick = false;\n                this.touchTime = 0;\n                if (temp !== parent.isShapeDrawing && parent.activeObj.shape &&\n                    parent.activeObj.shape === 'path') {\n                    return;\n                }\n            }\n            else {\n                this.touchTime = new Date().getTime();\n            }\n        }\n        if (e.touches.length === 2) {\n            this.isFirstMove = true;\n        }\n        else {\n            this.mouseDownEventHandler(e);\n        }\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(parent.lowerCanvas, 'touchend', this.mouseUpEventHandler, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(parent.lowerCanvas, 'touchmove', this.mouseMoveEventHandler, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(parent.upperCanvas, 'touchend', this.mouseUpEventHandler, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(parent.upperCanvas, 'touchmove', this.mouseMoveEventHandler, this);\n    };\n    Selection.prototype.unwireEvent = function () {\n        var parent = this.parent;\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(parent.lowerCanvas, 'touchend', this.mouseUpEventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(parent.lowerCanvas, 'touchmove', this.mouseMoveEventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(parent.upperCanvas, 'touchend', this.mouseUpEventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(parent.upperCanvas, 'touchmove', this.mouseMoveEventHandler);\n    };\n    Selection.prototype.keyDownEventHandler = function (e) {\n        var parent = this.parent;\n        if (e.ctrlKey && (e.key === '+' || e.key === '-')) {\n            e.preventDefault();\n        }\n        var obj = { fileName: '', fileType: null };\n        parent.notify('draw', { prop: 'getFileName', onPropertyChange: false, value: { obj: obj } });\n        var beforeSave = { fileName: obj['fileName'], fileType: obj['fileType'], cancel: false };\n        switch (e.key) {\n            case (e.ctrlKey && 's'):\n                parent.trigger('beforeSave', beforeSave);\n                this.beforeSaveEvent(beforeSave, e);\n                break;\n            case (e.ctrlKey && 'z'):\n                if (parent.allowUndoRedo) {\n                    parent.noPushUndo = false;\n                    if (parent.togglePen || parent.drawingShape) {\n                        parent.okBtn();\n                        parent.drawingShape = null;\n                    }\n                    parent.notify('undo-redo', { prop: 'call-undo' });\n                }\n                break;\n            case (e.ctrlKey && 'y'):\n                if (parent.allowUndoRedo) {\n                    parent.noPushUndo = false;\n                    if (parent.togglePen || parent.drawingShape) {\n                        parent.okBtn();\n                        parent.drawingShape = null;\n                    }\n                    parent.notify('undo-redo', { prop: 'call-redo' });\n                }\n                break;\n            case (e.ctrlKey && '+'):\n                if ((parent.zoomSettings.zoomTrigger & _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.Commands) === _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.Commands) {\n                    this.zoomType = 'Commands';\n                    parent.isZoomBtnClick = true;\n                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,\n                        value: { zoomFactor: .1, zoomPoint: null }, isResize: null });\n                    parent.notify('draw', { prop: 'redrawDownScale' });\n                    if (parent.isCropTab || parent.activeObj.shape) {\n                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });\n                        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });\n                    }\n                    if (parent.isStraightening) {\n                        parent.notify('draw', { prop: 'resetStraightenDestPoints' });\n                        parent.notify('draw', { prop: 'setDestForStraighten' });\n                    }\n                }\n                break;\n            case (e.ctrlKey && '-'):\n                if ((parent.zoomSettings.zoomTrigger & _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.Commands) === _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.Commands) {\n                    this.zoomType = 'Commands';\n                    parent.isZoomBtnClick = true;\n                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,\n                        value: { zoomFactor: -.1, zoomPoint: null }, isResize: null });\n                    parent.notify('draw', { prop: 'redrawDownScale' });\n                    if (parent.isCropTab || parent.activeObj.shape) {\n                        parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });\n                        parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });\n                    }\n                    if (parent.isStraightening) {\n                        parent.notify('draw', { prop: 'resetStraightenDestPoints' });\n                        parent.notify('draw', { prop: 'setDestForStraighten' });\n                    }\n                }\n                break;\n            case 'Delete':\n                this.deleteItem();\n                break;\n            case 'Escape':\n                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null, isFinalCancel: true } });\n                break;\n            case 'Enter':\n                this.performEnterAction(e);\n                break;\n            case 'Tab':\n                this.performTabAction();\n                break;\n            default:\n                if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice && (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block')) {\n                    setTimeout(this.textKeyDown.bind(this), 1, e);\n                }\n                break;\n        }\n    };\n    Selection.prototype.performEnterAction = function (e) {\n        var parent = this.parent;\n        if (parent.isResize) {\n            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n            var target = e.target;\n            var isIcon = target.id.indexOf('aspectratio') ||\n                target.id.indexOf('non-aspectratio') > -1 ? true : false;\n            var isValue = this.isValueUpdated();\n            if (!isValue) {\n                if (isIcon) {\n                    this.focusRatioBtn();\n                }\n                return;\n            }\n            var point = this.getNumTextValue();\n            var aspectRatioElement = parent.element.querySelector('#' + parent.element.id + '_aspectratio');\n            var blrAspRatElem = parent.element.querySelector('.e-ie-toolbar-aspect-ratio-btn');\n            if (point && point.x && point.y) {\n                if (aspectRatioElement || (blrAspRatElem && !blrAspRatElem.classList.contains('e-hidden'))) {\n                    parent.notify('transform', { prop: 'resize', value: { width: point.x, height: null, isAspectRatio: true } });\n                }\n                else {\n                    parent.notify('transform', { prop: 'resize', value: { width: point.x, height: point.y, isAspectRatio: false } });\n                }\n            }\n            var aspectRatioHeight = parent.element.querySelector('#' + parent.element.id + '_resizeHeight');\n            var aspectRatioWidth = parent.element.querySelector('#' + parent.element.id + '_resizeWidth');\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(aspectRatioElement)) {\n                if (aspectRatioHeight) {\n                    var elem = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getComponent)(aspectRatioHeight, 'numerictextbox');\n                    if (aspectRatioHeight && aspectRatioHeight.value === '') {\n                        elem.value = parseFloat(elem.placeholder);\n                        aspectRatioHeight.value = elem.placeholder + 'px';\n                    }\n                }\n                if (aspectRatioWidth) {\n                    var elem = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getComponent)(aspectRatioWidth, 'numerictextbox');\n                    if (aspectRatioWidth && aspectRatioWidth.value === '') {\n                        elem.value = parseFloat(elem.placeholder);\n                        aspectRatioWidth.value = elem.placeholder + 'px';\n                    }\n                }\n            }\n            parent.notify('draw', { prop: 'redrawDownScale' });\n            if (isIcon) {\n                this.focusRatioBtn();\n            }\n            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        }\n        else if (e.target.classList.contains('e-upload')) {\n            var upload = parent.element.querySelector('.e-image-upload');\n            if (upload && upload.querySelector('.e-tbar-btn')) {\n                upload.querySelector('.e-tbar-btn').click();\n            }\n            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        }\n        else if (e.target.classList.contains('filter-wrapper')) {\n            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n            e.target.parentElement.click();\n        }\n        else {\n            var splitWords = void 0;\n            if (parent.activeObj.shape) {\n                splitWords = parent.activeObj.shape.split('-');\n            }\n            if (e && this.isKeyBoardCrop(e) &&\n                parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] === 'crop')) {\n                parent.crop();\n            }\n        }\n    };\n    Selection.prototype.focusRatioBtn = function () {\n        var id = this.parent.element.id;\n        if (this.parent.isKBDNavigation) {\n            // eslint-disable-next-line @typescript-eslint/tslint/config\n            setTimeout(function () {\n                if (document.getElementById(id + '_aspectratio')) {\n                    document.getElementById(id + '_aspectratio').focus();\n                }\n                else if (document.getElementById(id + '_nonaspectratio')) {\n                    document.getElementById(id + '_nonaspectratio').focus();\n                }\n            }, 50);\n        }\n    };\n    Selection.prototype.isKeyBoardCrop = function (e) {\n        var bool = false;\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        var target = e.target;\n        if (target.id === this.parent.element.id + '_ok' || target.id === '') {\n            bool = true;\n        }\n        return bool;\n    };\n    Selection.prototype.beforeSaveEvent = function (observableSaveArgs, e) {\n        var parent = this.parent;\n        if (!observableSaveArgs.cancel) {\n            parent.notify('export', { prop: 'export', onPropertyChange: false,\n                value: { type: observableSaveArgs.fileType, fileName: observableSaveArgs.fileName } });\n        }\n        e.preventDefault();\n        e.stopImmediatePropagation();\n    };\n    Selection.prototype.handleScroll = function (e) {\n        this.mouseWheel++;\n        var parent = this.parent;\n        var x;\n        var y;\n        var isInsideCanvas = false;\n        if (e.type === 'mousewheel') {\n            // eslint-disable-next-line\n            x = e.clientX;\n            y = e.clientY;\n        }\n        var bbox = parent.lowerCanvas.getBoundingClientRect();\n        x -= bbox.left;\n        y -= bbox.top;\n        if (x > parent.img.destLeft && x < parent.img.destLeft + parent.img.destWidth && y > parent.img.destTop &&\n            y < parent.img.destTop + parent.img.destHeight) {\n            isInsideCanvas = true;\n        }\n        if (this.mouseWheel === 2) {\n            this.mouseWheel = 0;\n            if (e.ctrlKey === true && isInsideCanvas) {\n                e.preventDefault();\n            }\n            return;\n        }\n        e.stopPropagation();\n        if (e.ctrlKey === true && isInsideCanvas) {\n            e.preventDefault();\n            if (!parent.isCropTab && (parent.activeObj.shape && parent.activeObj.shape.split('-')[0] !== 'crop')) {\n                parent.okBtn(null, true);\n                parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });\n            }\n            var type = '';\n            if (e.type === 'mousewheel' && (parent.zoomSettings.zoomTrigger & _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.MouseWheel) === _index__WEBPACK_IMPORTED_MODULE_1__.ZoomTrigger.MouseWheel) {\n                this.zoomType = 'MouseWheel';\n                // eslint-disable-next-line\n                if (e.wheelDelta > 0) {\n                    type = 'zoomIn';\n                }\n                else {\n                    type = 'zoomOut';\n                }\n            }\n            if (type !== '') {\n                parent.isZoomBtnClick = true;\n                parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,\n                    value: { x: x, y: y, type: type, isResize: null } });\n                parent.notify('draw', { prop: 'redrawDownScale' });\n                if (parent.isCropTab || parent.activeObj.shape) {\n                    parent.notify('draw', { prop: 'setStraightenActObj', value: { activeObj: null } });\n                    parent.notify('freehand-draw', { prop: 'resetStraightenPoint' });\n                }\n                if (parent.isStraightening) {\n                    parent.notify('draw', { prop: 'resetStraightenDestPoints' });\n                    parent.notify('draw', { prop: 'setDestForStraighten' });\n                }\n            }\n        }\n    };\n    Selection.prototype.textKeyDown = function (e) {\n        var parent = this.parent;\n        if (parent.activeObj.rotatedAngle !== 0) {\n            return;\n        }\n        if (String.fromCharCode(e.which) === '\\r') {\n            this.textRow += 1;\n        }\n        parent.textArea.setAttribute('rows', this.textRow.toString());\n        parent.textArea.style.height = 'auto';\n        parent.textArea.style.height = parent.textArea.scrollHeight + 'px';\n        parent.notify('shape', { prop: 'setTextBoxWidth', onPropertyChange: false, value: { e: e } });\n        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n            parent.textArea.style.width = parseFloat(parent.textArea.style.width) + parent.textArea.style.fontSize + 'px';\n        }\n        var rows = parent.textArea.value.split('\\n');\n        this.textRow = rows.length;\n        parent.textArea.setAttribute('rows', this.textRow.toString());\n        this.isInitialTextEdited = false;\n    };\n    Selection.prototype.clearSelection = function (resetCrop) {\n        var parent = this.parent;\n        if (!parent.disabled && parent.isImageLoaded) {\n            if (resetCrop) {\n                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });\n            }\n            else {\n                parent.togglePen = false;\n                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                this.dragElement = '';\n                this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;\n                parent.currObjType.shape = '';\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                parent.currObjType.isActiveObj = true;\n                parent.currObjType.isCustomCrop = false;\n                parent.upperCanvas.style.cursor = parent.cursor = 'default';\n            }\n        }\n    };\n    Selection.prototype.setDragDirection = function (width, height) {\n        var arcRadius = (7.5);\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        if (parent.img.destWidth > parent.img.destHeight) {\n            actPoint.startX = this.dragPoint.startX = ((width / 2) - (height / 2)) + arcRadius;\n            actPoint.startY = this.dragPoint.startY = ((height / 2) - (height / 2)) + arcRadius;\n            actPoint.endX = ((width / 2) + (height / 2)) - arcRadius;\n            actPoint.endY = ((height / 2) + (height / 2)) - arcRadius;\n        }\n        else {\n            actPoint.startY = this.dragPoint.startX = ((height / 2) - (width) / 2) + arcRadius;\n            actPoint.endY = ((height / 2) + (width) / 2) - arcRadius;\n            actPoint.startX = this.dragPoint.startX = arcRadius;\n            actPoint.endX = width - arcRadius;\n        }\n    };\n    Selection.prototype.calcShapeRatio = function (x, y, imgWidth, imgHeight) {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        var arcRadius = (7.5);\n        var presetRatio = x / y;\n        var originalWidth = imgWidth;\n        var originalHeight = imgHeight;\n        var standardSize = originalWidth >= originalHeight ? originalWidth : originalHeight;\n        var width = standardSize * presetRatio;\n        var height = standardSize;\n        var scaleWidth = this.getScale(width, originalWidth);\n        var snippetArray = [];\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        for (var i = 0; i < 2; i++) {\n            if (i === 0) {\n                snippetArray.push(width * scaleWidth);\n            }\n            else {\n                snippetArray.push(height * scaleWidth);\n            }\n        }\n        width = snippetArray[0];\n        height = snippetArray[1];\n        var scaleHeight = this.getScale(height, originalHeight);\n        var snippetArray1 = [];\n        for (var i = 0; i < 2; i++) {\n            if (i === 0) {\n                snippetArray1.push(width * scaleHeight);\n            }\n            else {\n                snippetArray1.push(height * scaleHeight);\n            }\n        }\n        width = snippetArray1[0];\n        height = snippetArray1[1];\n        actPoint.width = width;\n        actPoint.height = height;\n        actPoint.startX = (this.dragPoint.startX = (originalWidth - width) / 2) + arcRadius;\n        actPoint.startY = (this.dragPoint.startY = (originalHeight - height) / 2) + arcRadius;\n        actPoint.endX = actPoint.startX + actPoint.width;\n        actPoint.endY = actPoint.startY + actPoint.height;\n        if (actPoint.startX < destLeft && destLeft + destWidth > parent.lowerCanvas.clientWidth) {\n            actPoint.startX = destLeft;\n            actPoint.endX = actPoint.startX + width - arcRadius;\n        }\n        if (actPoint.startY < destTop && destTop + destHeight > parent.lowerCanvas.clientHeight) {\n            actPoint.startY = destTop;\n            actPoint.endY = actPoint.startY + height - arcRadius;\n        }\n        actPoint.width = actPoint.endX - actPoint.startX;\n        actPoint.height = actPoint.endY - actPoint.startY;\n    };\n    Selection.prototype.getScale = function (value, originalValue) {\n        return value > originalValue ? originalValue / value : 1;\n    };\n    Selection.prototype.findTarget = function (x, y, type) {\n        var parent = this.parent;\n        if (type.toLowerCase() === 'mousedown' || type.toLowerCase() === 'touchstart') {\n            var splitWords = void 0;\n            var isCrop = false;\n            if (parent.activeObj.shape) {\n                splitWords = parent.activeObj.shape.split('-');\n                if (splitWords[0] === 'crop') {\n                    isCrop = true;\n                }\n            }\n            this.findTargetObj(x, y, isCrop);\n            this.updateCursorStyles(x, y, type);\n        }\n        else {\n            var _a = parent.activeObj, topLeftCircle = _a.topLeftCircle, topCenterCircle = _a.topCenterCircle, topRightCircle = _a.topRightCircle, centerLeftCircle = _a.centerLeftCircle, centerRightCircle = _a.centerRightCircle, bottomLeftCircle = _a.bottomLeftCircle, bottomCenterCircle = _a.bottomCenterCircle, bottomRightCircle = _a.bottomRightCircle;\n            switch (this.dragElement.toLowerCase()) {\n                case 'nw-resize':\n                    topLeftCircle.startX = x;\n                    topLeftCircle.startY = y;\n                    break;\n                case 'n-resize':\n                    topCenterCircle.startX = x;\n                    topCenterCircle.startY = y;\n                    break;\n                case 'ne-resize':\n                    topRightCircle.startX = x;\n                    topRightCircle.startY = y;\n                    break;\n                case 'w-resize':\n                    centerLeftCircle.startX = x;\n                    centerLeftCircle.startY = y;\n                    break;\n                case 'e-resize':\n                    centerRightCircle.startX = x;\n                    centerRightCircle.startY = y;\n                    break;\n                case 'sw-resize':\n                    bottomLeftCircle.startX = x;\n                    bottomLeftCircle.startY = y;\n                    break;\n                case 's-resize':\n                    bottomCenterCircle.startX = x;\n                    bottomCenterCircle.startY = y;\n                    break;\n                case 'se-resize':\n                    bottomRightCircle.startX = x;\n                    bottomRightCircle.startY = y;\n                    break;\n                default:\n                    if (this.dragPoint.startX && this.dragPoint.startY) {\n                        this.previousPoint.x = this.dragPoint.endX;\n                        this.previousPoint.y = this.dragPoint.endY;\n                        this.dragPoint.endX = x;\n                        this.dragPoint.endY = y;\n                    }\n                    break;\n            }\n        }\n    };\n    Selection.prototype.findTargetObj = function (x, y, isCrop) {\n        var parent = this.parent;\n        var isShape = false;\n        if (parent.objColl.length !== 0 && !parent.currObjType.isCustomCrop && !isCrop) {\n            var prevIndex = 0;\n            var i = void 0;\n            for (var index = 0; index < parent.objColl.length; index++) {\n                var cursor = parent.upperCanvas.style.cursor;\n                this.setCursor(x, y);\n                var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[index], {}, true);\n                var radius = actObj.topLeftCircle.radius;\n                if (actObj.shape === 'line' || actObj.shape === 'arrow') {\n                    for (var j = 0; j < actObj.pointColl.length; j++) {\n                        if (x >= actObj.pointColl[j].x - (radius * 2) &&\n                            x <= actObj.pointColl[j].x + (radius * 2) &&\n                            y >= actObj.pointColl[j].y - (radius * 2) &&\n                            y <= actObj.pointColl[j].y + (radius * 2)) {\n                            if (this.tempActiveObj && this.tempActiveObj.activePoint &&\n                                JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {\n                                i = index;\n                                break;\n                            }\n                            else {\n                                if (this.isTouch || parent.cursor === 'move' ||\n                                    parent.cursor === 'grab' || this.isShapeInserted) {\n                                    if (prevIndex === 0 || prevIndex < actObj.order) {\n                                        prevIndex = actObj.order;\n                                        i = index;\n                                    }\n                                }\n                                else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {\n                                    i = index;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                }\n                else if (actObj.shape === 'path') {\n                    var cursor_3 = this.setCursorForPath(actObj, x, y, parent.upperCanvas);\n                    if (cursor_3 !== 'default' && cursor_3 !== 'grab') {\n                        if (this.tempActiveObj && this.tempActiveObj.activePoint &&\n                            JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {\n                            i = index;\n                            break;\n                        }\n                        else {\n                            if (this.isTouch || parent.cursor === 'move' || parent.cursor === 'grab' || this.isShapeInserted) {\n                                if (prevIndex === 0 || prevIndex < actObj.order) {\n                                    prevIndex = actObj.order;\n                                    i = index;\n                                }\n                            }\n                            else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {\n                                i = index;\n                            }\n                        }\n                    }\n                }\n                else if (actObj.rotatedAngle !== 0) {\n                    var cursor_4 = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);\n                    if (cursor_4 !== 'default' && cursor_4 !== 'grab') {\n                        if (this.tempActiveObj && this.tempActiveObj.activePoint &&\n                            JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {\n                            i = index;\n                            break;\n                        }\n                        else {\n                            if (this.isTouch || parent.cursor === 'move' || parent.cursor === 'grab' || this.isShapeInserted) {\n                                if (prevIndex === 0 || (prevIndex < actObj.order && (actObj.shape !== 'redact' || parent.drawingShape === 'redact'))) {\n                                    prevIndex = actObj.order;\n                                    i = index;\n                                }\n                            }\n                            else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {\n                                i = index;\n                            }\n                        }\n                    }\n                }\n                else {\n                    var rotationCirclePoint = this.getTransRotationPoint(actObj);\n                    if ((x >= (actObj.activePoint.startX - (radius * 2)) &&\n                        x <= (actObj.activePoint.endX + (radius * 2)) &&\n                        y >= (actObj.activePoint.startY - (radius * 2)) &&\n                        y <= (actObj.activePoint.endY + (radius * 2))) ||\n                        (rotationCirclePoint &&\n                            x >= (rotationCirclePoint.x - (radius * 2)) &&\n                            x <= (rotationCirclePoint.x + (radius * 2)) &&\n                            y >= (rotationCirclePoint.y - (radius * 2)) &&\n                            y <= (rotationCirclePoint.y + (radius * 2)))) {\n                        if (this.tempActiveObj && this.tempActiveObj.activePoint &&\n                            JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {\n                            i = index;\n                            break;\n                        }\n                        else {\n                            if (this.isTouch || cursor === 'move' || cursor === 'grabbing' || this.isShapeInserted\n                                || parent.cursor === 'move' || parent.cursor === 'grabbing') {\n                                if (prevIndex === 0 || (prevIndex < actObj.order && (actObj.shape !== 'redact' || parent.drawingShape === 'redact'))) {\n                                    prevIndex = actObj.order;\n                                    i = index;\n                                }\n                            }\n                            else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {\n                                i = index;\n                            }\n                        }\n                    }\n                }\n            }\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(i)) {\n                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                isShape = false;\n            }\n            else {\n                this.tempObjColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n                parent.currObjType.isCustomCrop = false;\n                parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[i], {}, true);\n                var temp = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.objColl[i], {}, true);\n                parent.objColl.splice(i, 1);\n                if (parent.transform.degree === 0) {\n                    var temp_1 = this.lowerContext.filter;\n                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n                    parent.notify('draw', { prop: 'drawImage', onPropertyChange: false });\n                    this.lowerContext.filter = 'none';\n                    parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                        value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });\n                    parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, temp_1, {}, true);\n                    this.lowerContext.filter = temp_1;\n                    this.getCurrentFlipState();\n                }\n                else {\n                    var totalPannedInternalPoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.panPoint.totalPannedInternalPoint, {}, true);\n                    var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,\n                        height: parent.img.destHeight };\n                    parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });\n                    parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;\n                    parent.img.destLeft = destPoints.startX;\n                    parent.img.destTop = destPoints.startY;\n                    parent.img.destWidth = destPoints.width;\n                    parent.img.destHeight = destPoints.height;\n                    parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                        value: { ctx: this.lowerContext, shape: 'iterate', pen: 'iterate', isPreventApply: null } });\n                }\n                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n                if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {\n                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,\n                        value: { context: this.lowerContext, isSave: null, isFlip: null } });\n                }\n                parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, temp, {}, true);\n                this.setActivePoint();\n                parent.activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, temp, {}, true);\n                var tempStrokeSettings = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj.strokeSettings, {}, true);\n                parent.notify('draw', { prop: 'setTempStrokeSettings', onPropertyChange: false,\n                    value: { tempStrokeSettings: tempStrokeSettings } });\n                var tempTextSettings = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj.textSettings, {}, true);\n                parent.notify('draw', { prop: 'setTempTextSettings', onPropertyChange: false, value: { tempTextSettings: tempTextSettings } });\n                var shapeSettings = this.updatePrevShapeSettings();\n                var shapeChangingArgs = { cancel: false, action: 'select', previousShapeSettings: shapeSettings,\n                    currentShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };\n                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow') {\n                    shapeChangingArgs.currentShapeSettings.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;\n                    shapeChangingArgs.currentShapeSettings.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;\n                }\n                this.isCropSelection = false;\n                var splitWords = void 0;\n                if (parent.activeObj.shape !== undefined) {\n                    splitWords = parent.activeObj.shape.split('-');\n                }\n                if (splitWords !== undefined && splitWords[0] === 'crop') {\n                    this.isCropSelection = true;\n                }\n                if (!this.isCropSelection && parent.activeObj.shape !== 'redact') {\n                    parent.trigger('shapeChanging', shapeChangingArgs);\n                    this.shapeEvent(shapeChangingArgs);\n                    parent.editCompleteArgs = shapeChangingArgs;\n                }\n                else {\n                    if (this.isMouseDown) {\n                        shapeChangingArgs.action = 'resize-start';\n                    }\n                    else if (this.isMouseUp) {\n                        shapeChangingArgs.action = 'resize-end';\n                    }\n                    var selectionChangingArgs = { action: shapeChangingArgs.action,\n                        previousSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),\n                            startX: shapeChangingArgs.previousShapeSettings.startX,\n                            startY: shapeChangingArgs.previousShapeSettings.startY,\n                            width: shapeChangingArgs.previousShapeSettings.width,\n                            height: shapeChangingArgs.previousShapeSettings.height },\n                        currentSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),\n                            startX: shapeChangingArgs.currentShapeSettings.startX,\n                            startY: shapeChangingArgs.currentShapeSettings.startY,\n                            width: shapeChangingArgs.currentShapeSettings.width,\n                            height: shapeChangingArgs.currentShapeSettings.height } };\n                    parent.trigger('selectionChanging', selectionChangingArgs);\n                    parent.editCompleteArgs = selectionChangingArgs;\n                    shapeChangingArgs.currentShapeSettings.startX = selectionChangingArgs.currentSelectionSettings.startX;\n                    shapeChangingArgs.currentShapeSettings.startY = selectionChangingArgs.currentSelectionSettings.startY;\n                    shapeChangingArgs.currentShapeSettings.width = selectionChangingArgs.currentSelectionSettings.width;\n                    shapeChangingArgs.currentShapeSettings.height = selectionChangingArgs.currentSelectionSettings.height;\n                    this.shapeEvent(shapeChangingArgs);\n                }\n                isShape = true;\n            }\n        }\n        return isShape;\n    };\n    Selection.prototype.shapeEvent = function (shapeChangingArgs) {\n        var parent = this.parent;\n        parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,\n            value: { shapeSettings: shapeChangingArgs.currentShapeSettings, allowShapeOverflow: shapeChangingArgs.allowShapeOverflow } });\n        if (parent.activeObj.activePoint) {\n            var obj = { prevActObj: null };\n            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj['prevActObj'])) {\n                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false,\n                    value: { prevActObj: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true) } });\n            }\n            if (parent.activeObj.shape === 'image' && !this.isImageClarity) {\n                this.upgradeImageQuality();\n                this.isImageClarity = true;\n            }\n            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,\n                    points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });\n            if (!this.isShapeInserted) {\n                this.isPreventDragging = this.isShapeDragOut();\n            }\n        }\n    };\n    Selection.prototype.upgradeImageQuality = function () {\n        var parent = this.parent;\n        if (!parent.activeObj.imageCanvas) {\n            return;\n        }\n        var activeObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, null, true);\n        var ctx = parent.activeObj.imageCanvas.getContext('2d');\n        var dimObj = { width: 0, height: 0 };\n        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false, value: { width: parent.activeObj.imageElement.width,\n                height: parent.activeObj.imageElement.height, obj: dimObj, isImgShape: null } });\n        parent.notify('shape', { prop: 'updateObj', onPropertyChange: false, value: { dimObj: dimObj, x: null, y: null } });\n        ctx.clearRect(0, 0, parent.activeObj.imageCanvas.width, parent.activeObj.imageCanvas.height);\n        this.applyTransformToImg(ctx);\n        parent.activeObj = activeObj;\n    };\n    Selection.prototype.applyTransformToImg = function (ctx) {\n        var parent = this.parent;\n        if (parent.activeObj.isHorImageFlip && parent.activeObj.isVerImageFlip) {\n            parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = false;\n            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,\n                value: { ctx: ctx, isImgAnnotation: true, isHFlip: true, isVFlip: true } });\n        }\n        else if (parent.activeObj.isHorImageFlip) {\n            parent.activeObj.isHorImageFlip = false;\n            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,\n                value: { ctx: ctx, isImgAnnotation: true, isHFlip: true, isVFlip: false } });\n        }\n        else if (parent.activeObj.isVerImageFlip) {\n            parent.activeObj.isVerImageFlip = false;\n            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,\n                value: { ctx: ctx, isImgAnnotation: true, isHFlip: false, isVFlip: true } });\n        }\n        else {\n            parent.notify('draw', { prop: 'downScaleImgCanvas', onPropertyChange: false,\n                value: { ctx: ctx, isImgAnnotation: true, isHFlip: false, isVFlip: false } });\n        }\n    };\n    // eslint-disable-next-line\n    Selection.prototype.targetTouches = function (touches) {\n        var bbox = this.parent.lowerCanvas.getBoundingClientRect();\n        var p1 = { x: touches[0].pageX - bbox.left, y: touches[0].pageY - bbox.top };\n        var p2 = { x: touches[1].pageX - bbox.left, y: touches[1].pageY - bbox.top };\n        var points = [p1, p2];\n        return points;\n    };\n    Selection.prototype.calculateScale = function (startTouches, endTouches) {\n        var startDistance = this.getDistance(startTouches[0], startTouches[1]);\n        var endDistance = this.getDistance(endTouches[0], endTouches[1]);\n        return endDistance / startDistance;\n    };\n    Selection.prototype.getDistance = function (a, b) {\n        var x = 0;\n        var y = 0;\n        if (a && b) {\n            x = a.x - b.x;\n            y = a.y - b.y;\n        }\n        return Math.sqrt(x * x + y * y);\n    };\n    Selection.prototype.redrawShape = function (obj, isMouseUp) {\n        var parent = this.parent;\n        for (var i = 0, len = parent.objColl.length; i < len; i++) {\n            if (JSON.stringify(obj) === JSON.stringify(parent.objColl[i])) {\n                parent.objColl.splice(i, 1);\n                if (obj.shape && parent.textArea.style.display === 'none') {\n                    var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, obj, {}, true);\n                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n                    parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });\n                    if (parent.rotateFlipColl.length > 0 && (parent.panPoint.totalPannedClientPoint.x !== 0 ||\n                        parent.panPoint.totalPannedClientPoint.y !== 0)) {\n                        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });\n                    }\n                    obj = parent.activeObj = actObj;\n                }\n                break;\n            }\n        }\n        if ((obj.shape === 'path' && obj.pointColl.length === 0) ||\n            (obj.shape !== 'path' && (obj.activePoint.width === 0 && obj.activePoint.height === 0))) {\n            return;\n        }\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        if (this.isPreventDragging) {\n            if (parent.activeObj.activePoint.startX > parent.img.destLeft) {\n                this.isPreventDragging = false;\n            }\n            if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,\n                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });\n            }\n            else {\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,\n                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });\n            }\n        }\n        else {\n            if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,\n                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });\n            }\n            else {\n                if (parent.activeObj.shape === 'redact') {\n                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n                    parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });\n                    parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n                }\n                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,\n                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });\n            }\n        }\n    };\n    Selection.prototype.setTimer = function (e) {\n        var parent = this.parent;\n        if (this.timer > 10) {\n            clearTimeout(this.timer);\n            this.timer = 0;\n            parent.notify('shape', { prop: 'findTextTarget', onPropertyChange: false, value: { e: e } });\n            if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            }\n        }\n    };\n    Selection.prototype.applyCurrActObj = function (x, y) {\n        var parent = this.parent;\n        var isInside = false;\n        var actObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(actObj.activePoint)) {\n            return;\n        }\n        var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;\n        var radius = actObj.topLeftCircle ? actObj.topLeftCircle.radius : 0;\n        if ((x >= Math.floor(startX) && x <= Math.ceil(endX) && y >= Math.floor(startY) && y <= Math.ceil(endY))) {\n            isInside = true;\n        }\n        else if (radius !== 0 && (x >= Math.floor(startX) - radius && x <= Math.ceil(endX) + radius &&\n            y >= Math.floor(startY) - radius && y <= Math.ceil(endY) + radius)) {\n            isInside = true;\n            this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },\n                flipObjColl: [], triangle: [], triangleRatio: [] };\n        }\n        else if ((actObj.shape === 'text' || actObj.shape === 'image') && this.dragElement !== '') {\n            isInside = true;\n        }\n        else if (actObj.shape === 'line' || actObj.shape === 'arrow') {\n            var smallPoint = { x: startX < endX ? startX : endX, y: startY < endY ? startY : endY };\n            var largePoint = { x: startX > endX ? startX : endX, y: startY > endY ? startY : endY };\n            if ((x >= (Math.floor(smallPoint.x) - 5) && x <= (Math.ceil(largePoint.x) + 5) &&\n                y >= (Math.floor(smallPoint.y) - 5) && y <= (Math.ceil(largePoint.y) + 5)) ||\n                parent.activeObj.preventShapeDragOut) {\n                isInside = true;\n            }\n        }\n        else if (actObj.shape === 'path') {\n            var cursor = this.setCursorForPath(actObj, x, y, parent.upperCanvas);\n            if (cursor === 'move') {\n                isInside = true;\n            }\n        }\n        else if (this.dragElement === 'grabbing') {\n            isInside = true;\n        }\n        else if (actObj.rotatedAngle !== 0) {\n            var cursor = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);\n            if ((cursor !== 'default' && cursor !== 'grab') || this.dragElement === 'n-resize' || this.dragElement === 'e-resize' ||\n                this.dragElement === 's-resize' || this.dragElement === 'w-resize') {\n                isInside = true;\n            }\n        }\n        else if (parent.textArea.style.display === 'block' || parent.textArea.style.display === 'inline-block') {\n            isInside = true;\n        }\n        if (!isInside) {\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.currIndex)) {\n                var shapeIDObj = { id: 'shape_' + (parent.objColl.length + 1) };\n                parent.notify('shape', { prop: 'getNewShapeId', onPropertyChange: false, value: { obj: shapeIDObj } });\n                parent.activeObj.currIndex = shapeIDObj['id'];\n            }\n            parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });\n            if (parent.activeObj.horTopLine !== undefined && parent.activeObj.horTopLine.startX !== 0 && parent.activeObj.horTopLine.endX\n                !== 0 && !parent.currObjType.isCustomCrop && parent.currObjType.shape !== '') {\n                if (parent.objColl.length > 0 &&\n                    JSON.stringify(parent.objColl[parent.objColl.length - 1].activePoint) !==\n                        JSON.stringify(parent.activeObj.activePoint)) {\n                    parent.objColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true));\n                }\n            }\n            var shapeColl = ['rectangle', 'ellipse', 'line', 'arrow', 'path', 'text', 'image'];\n            if (shapeColl.indexOf(parent.activeObj.shape) > -1) {\n                var tempFilter = this.lowerContext.filter;\n                this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +\n                    'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' +\n                    'invert(0%)';\n                parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n                    value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: null } });\n                this.lowerContext.filter = tempFilter;\n                if (parent.activeObj.shape) {\n                    parent.notify('shape', { prop: 'apply', onPropertyChange: false,\n                        value: { shape: null, obj: null, canvas: null } });\n                }\n                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });\n                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });\n                if (parent.isCircleCrop) {\n                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,\n                        value: { context: this.lowerContext, isSave: null, isFlip: null } });\n                }\n            }\n            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n        }\n    };\n    Selection.prototype.getCurrentFlipState = function () {\n        var parent = this.parent;\n        if (parent.rotateFlipColl.length !== 0) {\n            var totalPannedInternalPoint = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.panPoint.totalPannedInternalPoint, {}, true);\n            parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });\n            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;\n        }\n        else {\n            parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });\n        }\n    };\n    Selection.prototype.setTextBoxStylesToActObj = function () {\n        var parent = this.parent;\n        parent.activeObj.textSettings.fontFamily = parent.textArea.style.fontFamily;\n        parent.activeObj.strokeSettings.strokeColor = parent.textArea.style.color !== '' &&\n            parent.textArea.style.color.split('(')[1] && parent.textArea.style.color.split('(')[1].split(',')[0] &&\n            parent.textArea.style.color.split('(')[1].split(',')[1] && parent.textArea.style.color.split('(')[1].split(',')[2]\n            && parent.textArea.style.color.split('(')[1].split(',')[3] ?\n            this.rgbToHex(parseFloat(parent.textArea.style.color.split('(')[1].split(',')[0]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[1]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[2]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[3])) :\n            parent.textArea.style.color;\n        parent.activeObj.strokeSettings.fillColor = parent.textArea.style.backgroundColor !== '' &&\n            parent.textArea.style.backgroundColor.split('(')[1] && parent.textArea.style.backgroundColor.split('(')[1].split(',')[0] &&\n            parent.textArea.style.backgroundColor.split('(')[1].split(',')[1] && parent.textArea.style.backgroundColor.split('(')[1].split(',')[2]\n            && parent.textArea.style.backgroundColor.split('(')[1].split(',')[3] ?\n            this.rgbToHex(parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[0]), parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[1]), parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[2]), parseFloat(parent.textArea.style.backgroundColor.split('(')[1].split(',')[3])) :\n            parent.textArea.style.backgroundColor;\n        parent.activeObj.strokeSettings.outlineColor = parent.textArea.style.textShadow !== '' &&\n            parent.textArea.style.textShadow.split('(')[1] && parent.textArea.style.textShadow.split('(')[1].split(',')[0] &&\n            parent.textArea.style.textShadow.split('(')[1].split(',')[1] && parent.textArea.style.textShadow.split('(')[1].split(',')[2]\n            && parent.textArea.style.textShadow.split('(')[1].split(',')[3] ?\n            this.rgbToHex(parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[0]), parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[1]), parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[2]), parseFloat(parent.textArea.style.textShadow.split('(')[1].split(',')[3])) :\n            (parent.textArea.style.textShadow.match(/^(\\s*[\\w#]+)\\s/) ?\n                parent.textArea.style.textShadow.match(/^(\\s*[\\w#]+)\\s/)[1].trim() :\n                parent.textArea.style.textShadow);\n        if (parent.textArea.style.fontWeight === 'bold') {\n            parent.activeObj.textSettings.bold = true;\n        }\n        else {\n            parent.activeObj.textSettings.bold = false;\n        }\n        if (parent.textArea.style.fontStyle === 'italic') {\n            parent.activeObj.textSettings.italic = true;\n        }\n        else {\n            parent.activeObj.textSettings.italic = false;\n        }\n        parent.activeObj.textSettings.fontSize = (parseFloat(parent.textArea.style.fontSize));\n    };\n    Selection.prototype.rgbToHex = function (r, g, b, a) {\n        r = Math.max(0, Math.min(255, Math.round(r)));\n        g = Math.max(0, Math.min(255, Math.round(g)));\n        b = Math.max(0, Math.min(255, Math.round(b)));\n        a = Math.max(0, Math.min(1, a));\n        var hexR = this.padLeft(r.toString(16), 2, '0');\n        var hexG = this.padLeft(g.toString(16), 2, '0');\n        var hexB = this.padLeft(b.toString(16), 2, '0');\n        var hexA = this.padLeft(Math.round(a * 255).toString(16), 2, '0');\n        var hex;\n        if (isNaN(Number(hexA))) {\n            hex = \"#\" + hexR + hexG + hexB;\n        }\n        else {\n            hex = \"#\" + hexR + hexG + hexB + hexA;\n        }\n        return hex;\n    };\n    Selection.prototype.padLeft = function (value, length, padChar) {\n        while (value.length < length) {\n            value = padChar + value;\n        }\n        return value;\n    };\n    Selection.prototype.deleteItem = function () {\n        var parent = this.parent;\n        var shapeChangingArgs = { cancel: false };\n        var previousShapeSettings = {};\n        if (this.isFhdEditing) {\n            this.updateFreehandDrawColorChange();\n            var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n            var object = { currObj: {} };\n            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n            var prevObj = object['currObj'];\n            prevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n            prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n            prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n            var selPointCollObj = { selPointColl: null };\n            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n                value: { obj: selPointCollObj } });\n            prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n            var obj = { freehandDrawSelectedId: null };\n            parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });\n            parent.notify('freehand-draw', { prop: 'deleteFhd', value: { id: obj['freehandDrawSelectedId'] } });\n            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                value: { operation: 'deleteFreehandDrawing', previousObj: prevObj, previousObjColl: this.tempObjColl,\n                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                    previousCropObj: prevCropObj, previousText: null,\n                    currentText: null, previousFilter: null, isCircleCrop: null } });\n            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n            parent.notify('freehand-draw', { prop: 'resetFreehandDrawSelectedId' });\n        }\n        else if (parent.textArea.style.display === 'none') {\n            var obj = { prevActObj: null };\n            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });\n            if (obj['prevActObj']) {\n                obj['prevActObj']['activePoint']['width'] = Math.abs(obj['prevActObj']['activePoint']['width']);\n                obj['prevActObj']['activePoint']['height'] = Math.abs(obj['prevActObj']['activePoint']['height']);\n            }\n            if (obj['prevActObj'] && JSON.stringify(obj['prevActObj']) !== JSON.stringify(parent.activeObj)) {\n                var index = parent.activeObj.currIndex;\n                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null, isFinalCancel: true } });\n                for (var i = 0, len = parent.objColl.length; i < len; i++) {\n                    if (parent.objColl[i].currIndex === index) {\n                        parent.objColl.splice(i, 1);\n                        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });\n                        break;\n                    }\n                }\n            }\n            var object = { isNewPath: null };\n            parent.notify('draw', { prop: 'getNewPath', value: { obj: object } });\n            if (object['isNewPath']) {\n                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });\n                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n            }\n            else if (parent.activeObj.shape) {\n                parent.objColl.push(parent.activeObj);\n                var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n                var object_2 = { currObj: {} };\n                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object_2 } });\n                var prevObj = object_2['currObj'];\n                prevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n                prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n                prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n                var selPointCollObj = { selPointColl: null };\n                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,\n                    value: { obj: selPointCollObj } });\n                prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n                parent.objColl.pop();\n                previousShapeSettings = this.updatePrevShapeSettings();\n                shapeChangingArgs = { cancel: false, action: 'delete', previousShapeSettings: previousShapeSettings, currentShapeSettings: null };\n                parent.notify('shape', { prop: 'setKeyHistory', onPropertyChange: false, value: { keyHistory: '' } });\n                parent.clearSelection();\n                parent.trigger('shapeChanging', shapeChangingArgs);\n                parent.editCompleteArgs = shapeChangingArgs;\n                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(prevObj.objColl[prevObj.objColl.length - 1].currIndex)) {\n                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                        value: { operation: 'deleteObj', previousObj: prevObj, previousObjColl: this.tempObjColl,\n                            previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                            previousCropObj: prevCropObj, previousText: null,\n                            currentText: null, previousFilter: null, isCircleCrop: null } });\n                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });\n                }\n            }\n            parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });\n            if (parent.drawingShape) {\n                this.currentDrawingShape = parent.drawingShape.toLowerCase();\n                parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);\n                parent.upperCanvas.style.cursor = 'crosshair';\n            }\n        }\n        if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {\n            document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';\n        }\n    };\n    Selection.prototype.updateFreehandDrawColorChange = function () {\n        var parent = this.parent;\n        var indexObj = { freehandSelectedIndex: null };\n        parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(indexObj['freehandSelectedIndex']) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.pointColl[indexObj['freehandSelectedIndex']])\n            && parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor === '#42a5f5') {\n            var obj = { tempFreeHandDrawEditingStyles: null };\n            parent.notify('freehand-draw', { prop: 'getTempFreeHandDrawEditingStyles', value: { obj: obj } });\n            parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor = obj['tempFreeHandDrawEditingStyles'].strokeColor;\n        }\n    };\n    Selection.prototype.updatePrevShapeSettings = function (obj) {\n        var parent = this.parent;\n        var fontStyle = [];\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.currIndex)) {\n            var shapeIDObj = { id: 'shape_' + (parent.objColl.length + 1) };\n            parent.notify('shape', { prop: 'getNewShapeId', onPropertyChange: false, value: { obj: shapeIDObj } });\n            parent.activeObj.currIndex = shapeIDObj['id'];\n        }\n        if (parent.activeObj.shape === 'text' && parent.activeObj.textSettings) {\n            if (parent.activeObj.textSettings.bold) {\n                fontStyle.push('bold');\n            }\n            if (parent.activeObj.textSettings.italic) {\n                fontStyle.push('italic');\n            }\n            if (parent.activeObj.textSettings.underline) {\n                fontStyle.push('underline');\n            }\n        }\n        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;\n        var _b = parent.activeObj, keyHistory = _b.keyHistory, currIndex = _b.currIndex, shape = _b.shape, textSettings = _b.textSettings, strokeSettings = _b.strokeSettings, rotatedAngle = _b.rotatedAngle, imageElement = _b.imageElement, opacity = _b.opacity;\n        var shapeSettingsObj = {\n            id: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(currIndex) ? currIndex : null,\n            type: parent.toPascalCase(shape),\n            startX: startX, startY: startY, width: width, height: height,\n            strokeColor: strokeSettings ? (shape === 'text' ? strokeSettings.outlineColor : strokeSettings.strokeColor) : null,\n            strokeWidth: strokeSettings ? (shape === 'text' ? strokeSettings.outlineWidth : strokeSettings.strokeWidth) : null,\n            fillColor: strokeSettings ? strokeSettings.fillColor : null,\n            radius: shape === 'ellipse' ? width / 2 : null,\n            length: shape === 'line' || shape === 'arrow' ? width : null,\n            text: shape === 'text' ? (keyHistory ? keyHistory : (textSettings.text ? textSettings.text : null)) : null,\n            fontSize: shape === 'text' ? (textSettings ? textSettings.fontSize : null) : null,\n            fontFamily: shape === 'text' ? (textSettings ? textSettings.fontFamily : null) : null,\n            fontStyle: shape === 'text' ? fontStyle : null,\n            color: shape === 'text' ? (strokeSettings ? strokeSettings.strokeColor : null) : null,\n            degree: shape === 'ellipse' || shape === 'rectangle' || shape === 'image' || shape === 'text' ? rotatedAngle * (180 / Math.PI) : null,\n            imageData: shape === 'image' ? imageElement.src : null,\n            opacity: shape === 'image' ? opacity : null,\n            radiusX: shape === 'ellipse' ? width / 2 : null,\n            radiusY: shape === 'ellipse' ? height / 2 : null,\n            endX: shape === 'line' || shape === 'arrow' ? endX : null,\n            endY: shape === 'line' || shape === 'arrow' ? endY : null,\n            arrowHead: shape === 'arrow' ? this.getArrowType(parent.activeObj.start) : null,\n            arrowTail: shape === 'arrow' ? this.getArrowType(parent.activeObj.end) : null,\n            points: shape === 'path' ? parent.activeObj.pointColl : null,\n            index: parent.activeObj.order,\n            transformCollection: shape === 'text' ? this.updateTransColl(parent.activeObj) : null\n        };\n        if (obj) {\n            obj['shapeSettingsObj'] = shapeSettingsObj;\n        }\n        return shapeSettingsObj;\n    };\n    Selection.prototype.updateTransColl = function (object) {\n        var parent = this.parent;\n        var coll;\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        var tempColl = object.rotateFlipColl;\n        if (tempColl && tempColl.length > 0) {\n            var value = void 0;\n            coll = [];\n            for (var i = 0; i < tempColl.length; i++) {\n                value = tempColl[i];\n                if (typeof (value) === 'number') {\n                    coll.push({ degree: value });\n                }\n                else {\n                    coll.push({ flip: parent.toPascalCase(value) });\n                }\n            }\n        }\n        return coll;\n    };\n    Selection.prototype.getArrowType = function (type) {\n        var typeToArrowType = { 'none': 'None', 'arrow': 'Arrow', 'arrowSolid': 'SolidArrow',\n            'circle': 'Circle', 'circleSolid': 'SolidCircle', 'square': 'Square', 'squareSolid': 'SolidSquare', 'bar': 'Bar' };\n        return typeToArrowType[\"\" + type];\n    };\n    Selection.prototype.getRectanglePoints = function (rectX, rectY, rectWidth, rectHeight, rectAngle, pointX, pointY) {\n        var centerX = rectX + rectWidth / 2;\n        var centerY = rectY + rectHeight / 2;\n        var angleRad = rectAngle * (Math.PI / 180);\n        var cosAngle = Math.cos(angleRad);\n        var sinAngle = Math.sin(angleRad);\n        var localX = pointX - centerX;\n        var localY = pointY - centerY;\n        var rotatedX = localX * cosAngle + localY * sinAngle;\n        var rotatedY = -localX * sinAngle + localY * cosAngle;\n        var halfWidth = rectWidth / 2;\n        var halfHeight = rectHeight / 2;\n        if (rotatedX >= -halfWidth && rotatedX <= halfWidth && rotatedY >= -halfHeight &&\n            rotatedY <= halfHeight) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Selection.prototype.getTransRotationPoint = function (obj, object) {\n        var rotationCirclePoint;\n        var degree;\n        var isHorizontalflip = false;\n        var isVerticalflip = false;\n        degree = (obj.shapeDegree === 0) ? this.parent.transform.degree : this.parent.transform.degree - obj.shapeDegree;\n        if (degree < 0) {\n            degree = 360 + degree;\n        }\n        if (obj.flipObjColl) {\n            for (var i = 0, iLen = obj.flipObjColl.length; i < iLen; i++) {\n                if (obj.flipObjColl[i].toLowerCase() === 'horizontal') {\n                    isHorizontalflip = true;\n                }\n                else if (obj.flipObjColl[i].toLowerCase() === 'vertical') {\n                    isVerticalflip = true;\n                }\n            }\n        }\n        if (degree === 0 || degree === 360) {\n            if (isVerticalflip) {\n                rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };\n            }\n            else {\n                rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };\n            }\n        }\n        else if (degree === 90 || degree === -270) {\n            if (isHorizontalflip) {\n                rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };\n            }\n            else {\n                rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };\n            }\n        }\n        else if (degree === 180 || degree === -180) {\n            if (isVerticalflip) {\n                rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };\n            }\n            else {\n                rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };\n            }\n        }\n        else if (degree === 270 || degree === -90) {\n            if (isHorizontalflip) {\n                rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };\n            }\n            else {\n                rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };\n            }\n        }\n        if (object) {\n            object['rotationCirclePoint'] = rotationCirclePoint;\n        }\n        return rotationCirclePoint;\n    };\n    Selection.prototype.getNumTextValue = function (obj) {\n        var parent = this.parent;\n        var elem = parent.element;\n        var height;\n        var width;\n        var widthElement;\n        var heightElement;\n        widthElement = elem.querySelector('#' + elem.id + '_resizeWidth');\n        heightElement = elem.querySelector('#' + elem.id + '_resizeHeight');\n        if (widthElement && heightElement) {\n            var heightString = heightElement.value.replace(/,/g, '');\n            var widthString = widthElement.value.replace(/,/g, '');\n            if (heightString === '') {\n                heightString = heightElement.placeholder.replace(/,/g, '');\n            }\n            if (widthString === '') {\n                widthString = widthElement.placeholder.replace(/,/g, '');\n            }\n            height = parseFloat(heightString);\n            width = parseFloat(widthString);\n        }\n        if (obj) {\n            obj['width'] = width;\n            obj['height'] = height;\n        }\n        return { x: width, y: height };\n    };\n    Selection.prototype.isValueUpdated = function () {\n        var isValue = true;\n        var widthElement;\n        var heightElement;\n        widthElement = this.parent.element.querySelector('#' + this.parent.element.id + '_resizeWidth');\n        heightElement = this.parent.element.querySelector('#' + this.parent.element.id + '_resizeHeight');\n        if (widthElement && heightElement) {\n            if (heightElement.value.replace(/,/g, '') === '' && widthElement.value.replace(/,/g, '') === '') {\n                isValue = false;\n            }\n        }\n        return isValue;\n    };\n    Selection.prototype.allowOutofBound = function () {\n        var shapes = ['ellipse', 'rectangle', 'text', 'image', 'redact'];\n        // eslint-disable-next-line max-len\n        var allowOutofBound = (shapes.indexOf(this.parent.activeObj.shape) !== -1 && this.parent.activeObj.rotatedAngle === 0) ? false : true;\n        return allowOutofBound;\n    };\n    return Selection;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/selection.js?");

/***/ })

}]);