"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_layout_flowChart_flow-chart-layout_js-b8922577"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/flow-chart-layout.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/flow-chart-layout.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlowchartLayout: () => (/* binding */ FlowchartLayout)\n/* harmony export */ });\n/* harmony import */ var _diagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../diagram */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _flow_chart_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flow-chart-model */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/flow-chart-model.js\");\n/* harmony import */ var _matrix_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matrix-model */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/matrix-model.js\");\n\n\n\n\n/**\n * Defines the Flowchart Layout\n */\nvar FlowchartLayout = /** @class */ (function () {\n    function FlowchartLayout() {\n        this.rootNodes = [];\n        this.vertexMapper = new Map();\n        this.edgesMapper = new Map();\n        this.loopedgesMapper = new Map();\n        this.anchorX = 0;\n        this.anchorY = 0;\n        this.verticalSpacing = 50;\n        this.horizontalSpacing = 50;\n        this.horizontalAlignment = 'Center';\n        this.verticalAlignment = 'Top';\n        this.margin = { top: 50, right: 50, bottom: 50, left: 50 };\n        this.orientation = 'TopToBottom';\n        this.yesBranchDirection = 'SameAsFlow';\n        this.noBranchDirection = 'RightInFlow';\n        this.yesBranchValues = ['Yes', 'True'];\n        this.noBranchValues = ['No', 'False'];\n        this.diagram = new _diagram__WEBPACK_IMPORTED_MODULE_0__.Diagram();\n    }\n    /**\n     * To update the layout of the diagram.\n     * @private\n     * @param {NodeModel[]} nodes - provide the node value.\n     * @param {Diagram} diagram - provide the diagram value.\n     * @returns { void }\n     */\n    FlowchartLayout.prototype.updateLayout = function (nodes, diagram) {\n        this.diagram = diagram;\n        this.yesBranchDirection = this.diagram.layout.flowchartLayoutSettings.yesBranchDirection;\n        this.noBranchDirection = this.diagram.layout.flowchartLayoutSettings.noBranchDirection;\n        this.yesBranchValues = this.diagram.layout.flowchartLayoutSettings.yesBranchValues || ['Yes', 'True'];\n        this.noBranchValues = this.diagram.layout.flowchartLayoutSettings.noBranchValues || ['No', 'False'];\n        this.orientation = this.diagram.layout.orientation === 'TopToBottom' || this.diagram.layout.orientation === 'BottomToTop' ? 'TopToBottom' : 'LeftToRight';\n        this.horizontalAlignment = this.diagram.layout.horizontalAlignment;\n        this.verticalAlignment = this.diagram.layout.verticalAlignment;\n        this.verticalSpacing = this.diagram.layout.verticalSpacing;\n        this.horizontalSpacing = this.diagram.layout.horizontalSpacing;\n        this.margin = this.diagram.layout.margin;\n        var firstLevelNodes = [];\n        var unseenVertices = [];\n        this.rootNodes = [];\n        this.vertexMapper.clear();\n        this.edgesMapper.clear();\n        this.loopedgesMapper.clear();\n        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n            var item = nodes_1[_i];\n            if (!item.excludeFromLayout) {\n                var vertex = this.createVertex(item);\n                this.vertexMapper.set(vertex.id, vertex);\n                unseenVertices.push(vertex);\n                if (!vertex.inEdges || vertex.inEdges.length === 0) {\n                    firstLevelNodes.push(vertex);\n                    this.rootNodes.push(item);\n                }\n            }\n        }\n        var previousModel = null;\n        for (var _a = 0, firstLevelNodes_1 = firstLevelNodes; _a < firstLevelNodes_1.length; _a++) {\n            var firstLevelNode = firstLevelNodes_1[_a];\n            var vertexSet = [];\n            this.getTreeVertices(firstLevelNode, vertexSet, unseenVertices);\n            var layoutModel = new _flow_chart_model__WEBPACK_IMPORTED_MODULE_2__.FlowchartModel(this, firstLevelNode, vertexSet);\n            layoutModel.layeringStage();\n            var matrixModel = new _matrix_model__WEBPACK_IMPORTED_MODULE_3__.MatrixModel(layoutModel);\n            matrixModel.siblingModel = previousModel;\n            matrixModel.arrangeElements();\n            previousModel = matrixModel;\n        }\n        var vertices = Array.from(this.vertexMapper.values());\n        var modelBounds = this.getModelBounds(vertices);\n        this.updateAnchor(modelBounds);\n        var isHorizontal = this.orientation === 'LeftToRight';\n        var inverseSpacing = !isHorizontal ? this.verticalSpacing : this.horizontalSpacing;\n        var nodeWithMultiEdges = [];\n        for (var _b = 0, vertices_1 = vertices; _b < vertices_1.length; _b++) {\n            var vertex = vertices_1[_b];\n            if (vertex) {\n                var node = vertex.item;\n                if (node) {\n                    node.offsetX = vertex.geometry.x + (vertex.geometry.width / 2) + this.anchorX;\n                    node.offsetY = vertex.geometry.y + (vertex.geometry.height / 2) + this.anchorY;\n                    if ((vertex.inEdges && vertex.inEdges.length > 0) || (vertex.outEdges && vertex.outEdges.length > 0)) {\n                        nodeWithMultiEdges.push(node);\n                    }\n                }\n                diagram.dataBind();\n            }\n        }\n        var transModelBounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(modelBounds.x + this.anchorX, modelBounds.y\n            + this.anchorY, modelBounds.width, modelBounds.height);\n        this.nodeWithMultiEdges = nodeWithMultiEdges;\n        this.inverseSpacing = inverseSpacing;\n        this.transModelBounds = transModelBounds;\n        this.diagram.layout.flowChartData = this;\n    };\n    /**\n     * To re-rout the flowchart connectors.\n     * @private\n     * @param {FlowchartLayout} layoutData - provide the layoutData value.\n     * @param {Diagram} diagram - provide the diagram value.\n     * @returns { void }\n     */\n    FlowchartLayout.prototype.reRouteFlowChartConnectors = function (layoutData, diagram) {\n        this.diagram = diagram;\n        var nodeWithMultiEdges = layoutData.nodeWithMultiEdges;\n        var inverseSpacing = layoutData.inverseSpacing;\n        this.orientation = layoutData.orientation;\n        var isVertical = this.orientation === 'TopToBottom';\n        var transModelBounds = layoutData.transModelBounds;\n        this.vertexMapper = layoutData.vertexMapper;\n        this.loopedgesMapper = layoutData.loopedgesMapper;\n        this.edgesMapper = layoutData.edgesMapper;\n        this.anchorX = layoutData.anchorX;\n        this.anchorY = layoutData.anchorY;\n        var modifiedConnectors = [];\n        for (var _i = 0, nodeWithMultiEdges_1 = nodeWithMultiEdges; _i < nodeWithMultiEdges_1.length; _i++) {\n            var node = nodeWithMultiEdges_1[_i];\n            if (node.outEdges && node.outEdges.length > 0) {\n                for (var _a = 0, _b = node.outEdges; _a < _b.length; _a++) {\n                    var edge = _b[_a];\n                    var internalConnector = this.diagram.nameTable[\"\" + edge];\n                    if (this.loopedgesMapper.has(internalConnector) && this.loopedgesMapper.get(internalConnector)) {\n                        if (modifiedConnectors.indexOf(internalConnector) === -1) {\n                            this.updateLoopConnector(internalConnector);\n                            modifiedConnectors.push(internalConnector);\n                        }\n                    }\n                    else {\n                        var updatedPts = [];\n                        if (node.outEdges.length > 1) {\n                            var segmentSize = inverseSpacing / 2.0;\n                            var intermediatePoint = null;\n                            if (this.edgesMapper.has(internalConnector)) {\n                                var edgePt = this.edgesMapper.get(internalConnector)[0];\n                                if (edgePt) {\n                                    intermediatePoint = { x: edgePt.x + this.anchorX, y: edgePt.y + this.anchorY };\n                                }\n                            }\n                            internalConnector.segments = [];\n                            internalConnector.intermediatePoints = [];\n                            var pts = [internalConnector.sourcePoint, internalConnector.targetPoint];\n                            if (isVertical) {\n                                updatedPts = this.updateVerticalConnectorSegments(internalConnector, pts);\n                                var sourceNode = this.diagram.nameTable[internalConnector.sourceID];\n                                var decisionNode = this.vertexMapper.get(sourceNode.id).isDecisionNode;\n                                if (!decisionNode && updatedPts.length <= 2) {\n                                    pts = this.updateConnectorPoints(updatedPts, segmentSize, intermediatePoint, transModelBounds);\n                                }\n                                else {\n                                    pts = updatedPts;\n                                }\n                            }\n                            else {\n                                updatedPts = this.updateHorizontalSegments(internalConnector, pts);\n                                pts = updatedPts;\n                            }\n                            if (pts.length > 2) {\n                                this.updatePoints(pts, internalConnector);\n                            }\n                            modifiedConnectors.push(internalConnector);\n                        }\n                        else if (internalConnector.intermediatePoints.length === 4) {\n                            // Determine updated points based on orientation (vertical or horizontal)\n                            var start = internalConnector.intermediatePoints[0];\n                            var end = internalConnector.intermediatePoints[3];\n                            var offsetPoint = isVertical\n                                ? { x: start.x, y: end.y - 20 }\n                                : { x: end.x - 20, y: start.y };\n                            var updatedPts_1 = [start, offsetPoint, end];\n                            // Update connector points and add to modified list\n                            this.updatePoints(updatedPts_1, internalConnector);\n                            modifiedConnectors.push(internalConnector);\n                        }\n                    }\n                }\n            }\n            if (node.inEdges && node.inEdges.length > 1) {\n                for (var _c = 0, _d = node.inEdges; _c < _d.length; _c++) {\n                    var edge = _d[_c];\n                    var internalConnector = this.diagram.nameTable[\"\" + edge];\n                    if (modifiedConnectors.indexOf(internalConnector) === -1) {\n                        internalConnector.segments[0].points = [];\n                        if (this.loopedgesMapper.has(internalConnector) && this.loopedgesMapper.get(internalConnector)) {\n                            this.updateLoopConnector(internalConnector);\n                            modifiedConnectors.push(internalConnector);\n                        }\n                        else {\n                            if (node.inEdges.length > 1) {\n                                var segmentSize = inverseSpacing / 2.0;\n                                var intermediatePoint = null;\n                                if (this.edgesMapper.has(internalConnector) && modifiedConnectors.indexOf(internalConnector) === -1) {\n                                    var edgePt = this.edgesMapper.get(internalConnector)[0];\n                                    if (edgePt) {\n                                        intermediatePoint = { x: edgePt.x + this.anchorX, y: edgePt.y + this.anchorY };\n                                    }\n                                }\n                                internalConnector.segments = [];\n                                var pts = [internalConnector.targetPoint, internalConnector.sourcePoint];\n                                var updatedPts = [];\n                                if (isVertical) {\n                                    updatedPts = this.updateVerticalConnectorSegments(internalConnector, pts);\n                                }\n                                else {\n                                    updatedPts = this.updateHorizontalSegments(internalConnector, pts);\n                                }\n                                pts = this.updateConnectorPoints(updatedPts, segmentSize, intermediatePoint, transModelBounds);\n                                pts.reverse();\n                                if (pts.length > 2) {\n                                    this.updatePoints(pts, internalConnector);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    FlowchartLayout.prototype.updateAnchor = function (bounds) {\n        var viewPort = {\n            width: this.diagram.scrollSettings.viewPortWidth,\n            height: this.diagram.scrollSettings.viewPortHeight\n        };\n        if (this.orientation === 'TopToBottom') {\n            this.anchorX = viewPort.width / 2 - bounds.width / 2 - bounds.x;\n            this.anchorY = this.margin.top;\n        }\n        else {\n            this.anchorX = this.margin.left;\n            this.anchorY = viewPort.height / 2 - bounds.height / 2 - bounds.y;\n        }\n        if (this.rootNodes.length === 1) {\n            var fixedNode = this.rootNodes[0]; // Assuming rootNodes is defined elsewhere\n            var fixedNodeGeometry = this.vertexMapper.get(fixedNode.id).geometry; // Assuming vertexMapper and its usage are defined elsewhere\n            var offsetX = fixedNodeGeometry.x + fixedNodeGeometry.width / 2;\n            var offsetY = fixedNodeGeometry.y + fixedNodeGeometry.height / 2;\n            var dx = offsetX - (bounds.x + bounds.width / 2);\n            var dy = offsetY - (bounds.y + bounds.height / 2);\n            if (this.orientation === 'TopToBottom') {\n                this.anchorX -= dx;\n            }\n            else {\n                this.anchorY -= dy;\n            }\n        }\n    };\n    FlowchartLayout.prototype.updateConnectorPoints = function (connectorPoints, startSegmentSize, intermediatePoint, layoutBounds) {\n        var isHorizontal = this.orientation === 'LeftToRight';\n        var pts = connectorPoints.slice();\n        // Helper function to find angle between two points\n        function findAngle(point1, point2) {\n            return Math.atan2(point2.y - point1.y, point2.x - point1.x) * (180 / Math.PI);\n        }\n        // Function to find the distance (length) between two points\n        function findLength(point1, point2) {\n            var dx = point2.x - point1.x;\n            var dy = point2.y - point1.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n        // Helper function to transform a point\n        function transform(point, length, angle) {\n            var rad = angle * (Math.PI / 180);\n            var newX = point.x + length * Math.cos(rad);\n            var newY = point.y + length * Math.sin(rad);\n            return { x: newX, y: newY };\n        }\n        if (pts.length > 2) {\n            var newPt = transform(pts[0], startSegmentSize, findAngle(pts[0], pts[1]));\n            var nextPt = transform(newPt, findLength(newPt, pts[1]), findAngle(newPt, pts[2]));\n            pts.splice(1, 0, nextPt);\n            pts.splice(1, 0, newPt);\n            pts.splice(3, 2);\n            if (intermediatePoint != null) {\n                var index = 2;\n                var ptsCount = pts.length;\n                var newPt1 = transform(pts[ptsCount - 1], startSegmentSize, findAngle(pts[ptsCount - 1], pts[ptsCount - 2]));\n                pts.splice(ptsCount - 1, 0, newPt1);\n                while (index < pts.length - 2) {\n                    pts.splice(index, 1);\n                }\n                var edgePt = intermediatePoint;\n                this.inflate(layoutBounds, layoutBounds.width, layoutBounds.height);\n                if (isHorizontal) {\n                    var line1 = [{ x: layoutBounds.left, y: edgePt.y }, { x: layoutBounds.right, y: edgePt.y }];\n                    var line2 = [{ x: pts[1].x, y: layoutBounds.top }, { x: pts[1].x, y: layoutBounds.bottom }];\n                    var line3 = [{ x: newPt1.x, y: layoutBounds.top }, { x: newPt1.x, y: layoutBounds.bottom }];\n                    var intercepts1 = [];\n                    var intercepts2 = [];\n                    // Dummy function calls, replace with actual implementation or mock\n                    intercepts1 = this.diagram.commandHandler.intersect(line1, line2, false);\n                    intercepts2 = this.diagram.commandHandler.intersect(line1, line3, false);\n                    if (intercepts2.length) {\n                        pts.splice(2, 0, intercepts2[0]);\n                    }\n                    if (intercepts1.length) {\n                        pts.splice(2, 0, intercepts1[0]);\n                    }\n                }\n                else {\n                    var line1 = [{ x: edgePt.x, y: layoutBounds.top }, { x: edgePt.x, y: layoutBounds.bottom }];\n                    var line2 = [{ x: layoutBounds.left, y: pts[1].y }, { x: layoutBounds.right, y: pts[1].y }];\n                    var line3 = [{ x: layoutBounds.left, y: newPt1.y }, { x: layoutBounds.right, y: newPt1.y }];\n                    var intercepts1 = [];\n                    var intercepts2 = [];\n                    // Dummy function calls, replace with actual implementation or mock\n                    intercepts1 = this.diagram.commandHandler.intersect(line1, line2, false);\n                    intercepts2 = this.diagram.commandHandler.intersect(line1, line3, false);\n                    if (intercepts2.length) {\n                        pts.splice(2, 0, intercepts2[0]);\n                    }\n                    if (intercepts1.length) {\n                        pts.splice(2, 0, intercepts1[0]);\n                    }\n                }\n            }\n        }\n        else if (pts.length === 2 && intermediatePoint != null) {\n            var startPt = pts[0];\n            var endPt = pts[1];\n            var lineAngle = findAngle(pts[0], pts[1]);\n            var newPt1 = transform(startPt, startSegmentSize, lineAngle);\n            var newPt2 = transform(endPt, startSegmentSize, (lineAngle + 180) % 360);\n            pts.splice(1, 0, newPt2);\n            if (isHorizontal) {\n                var nextPt1 = { x: newPt1.x, y: intermediatePoint.y };\n                var nextPt2 = { x: newPt2.x, y: intermediatePoint.y };\n                pts.splice(1, 0, nextPt2);\n                pts.splice(1, 0, nextPt1);\n            }\n            else {\n                var nextPt1 = { x: intermediatePoint.x, y: newPt1.y };\n                var nextPt2 = { x: intermediatePoint.x, y: newPt2.y };\n                pts.splice(1, 0, nextPt2);\n                pts.splice(1, 0, nextPt1);\n            }\n            pts.splice(1, 0, newPt1);\n        }\n        return pts;\n    };\n    FlowchartLayout.prototype.inflate = function (rect, width, height) {\n        rect.x -= width;\n        rect.y -= height;\n        rect.width += 2 * width;\n        rect.height += 2 * height;\n    };\n    FlowchartLayout.isBranchConnector = function (internalConnector, branchValues) {\n        if (internalConnector.annotations.length > 0 && internalConnector.annotations[0].content) {\n            var text_1 = internalConnector.annotations[0].content;\n            return branchValues.some(function (branchText) { return text_1.localeCompare(branchText, undefined, { sensitivity: 'accent' }) === 0; });\n        }\n        return false;\n    };\n    FlowchartLayout.prototype.isYesBranchConnector = function (internalConnector) {\n        return FlowchartLayout.isBranchConnector(internalConnector, this.yesBranchValues);\n    };\n    FlowchartLayout.prototype.isNoBranchConnector = function (internalConnector) {\n        return FlowchartLayout.isBranchConnector(internalConnector, this.noBranchValues);\n    };\n    FlowchartLayout.prototype.updateHorizontalSegments = function (internalConnector, pts) {\n        var updatedPts = [];\n        var sourcenode = this.diagram.nameTable[internalConnector.sourceID];\n        var targetnode = this.diagram.nameTable[internalConnector.targetID];\n        var decisionNode = this.vertexMapper.get(sourcenode.id).isDecisionNode;\n        var hSpacing = this.horizontalSpacing / 2;\n        var vSpacing = this.verticalSpacing / 2;\n        if (decisionNode) {\n            var isYesBranch = this.isYesBranchConnector(internalConnector);\n            var isNoBranch = this.isNoBranchConnector(internalConnector);\n            if ((!targetnode.wrapper.bounds.containsPoint({ x: targetnode.offsetX, y: sourcenode.offsetY })) &&\n                !((sourcenode.offsetY !== targetnode.offsetY) &&\n                    ((isYesBranch && this.yesBranchDirection === 'SameAsFlow') ||\n                        (isNoBranch && this.noBranchDirection === 'SameAsFlow' && this.yesBranchDirection !== 'SameAsFlow')))) {\n                if (sourcenode.wrapper.bounds.bottom < targetnode.wrapper.bounds.center.y) {\n                    var spoint1 = sourcenode.wrapper.bounds.bottom;\n                    var spoint2 = sourcenode.offsetX;\n                    var tpoint1 = targetnode.wrapper.bounds.left;\n                    var tpoint2 = targetnode.offsetY;\n                    updatedPts.push({ x: spoint2, y: spoint1 });\n                    updatedPts.push({ x: spoint2, y: tpoint2 });\n                    updatedPts.push({ x: tpoint1, y: tpoint2 });\n                }\n                else if (sourcenode.wrapper.bounds.top > targetnode.wrapper.bounds.center.y) {\n                    var spoint1 = sourcenode.wrapper.bounds.top;\n                    var spoint2 = sourcenode.offsetX;\n                    var tpoint1 = targetnode.wrapper.bounds.left;\n                    var tpoint2 = targetnode.offsetY;\n                    updatedPts.push({ x: spoint2, y: spoint1 });\n                    updatedPts.push({ x: spoint2, y: tpoint2 });\n                    updatedPts.push({ x: tpoint1, y: tpoint2 });\n                }\n                else if ((isYesBranch && this.yesBranchDirection === 'RightInFlow') ||\n                    (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&\n                        (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||\n                        (this.yesBranchDirection === 'LeftInFlow' &&\n                            (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {\n                    var spoint1 = sourcenode.offsetX;\n                    var spoint2 = sourcenode.wrapper.bounds.bottom;\n                    var tpoint1 = targetnode.wrapper.bounds.left;\n                    var tpoint2 = targetnode.wrapper.bounds.center.y;\n                    updatedPts.push({ x: spoint1, y: spoint2 });\n                    updatedPts.push({ x: spoint1, y: spoint2 + vSpacing });\n                    updatedPts.push({ x: tpoint1 - hSpacing, y: spoint2 + vSpacing });\n                    updatedPts.push({ x: tpoint1 - hSpacing, y: tpoint2 });\n                    updatedPts.push({ x: tpoint1, y: tpoint2 });\n                }\n            }\n            else if ((isYesBranch && this.yesBranchDirection === 'LeftInFlow') ||\n                (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&\n                    (this.noBranchDirection === 'SameAsFlow' || this.noBranchDirection === 'LeftInFlow')) ||\n                    (this.yesBranchDirection === 'RightInFlow' &&\n                        (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {\n                var spoint1 = sourcenode.offsetX;\n                var spoint2 = sourcenode.wrapper.bounds.top;\n                var tpoint1 = targetnode.wrapper.bounds.left;\n                var tpoint2 = targetnode.wrapper.bounds.center.y;\n                updatedPts.push({ x: spoint1, y: spoint2 });\n                updatedPts.push({ x: spoint1, y: spoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1 - hSpacing, y: spoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1 - hSpacing, y: tpoint2 });\n                updatedPts.push({ x: tpoint1, y: tpoint2 });\n            }\n            else if ((sourcenode.offsetY !== targetnode.offsetY) &&\n                ((isYesBranch && this.yesBranchDirection === 'SameAsFlow') ||\n                    (isNoBranch && this.noBranchDirection === 'SameAsFlow' &&\n                        this.yesBranchDirection !== 'SameAsFlow'))) {\n                var spoint1 = sourcenode.wrapper.bounds.right;\n                var spoint2 = sourcenode.offsetY;\n                var tpoint1 = targetnode.wrapper.bounds.left;\n                var tpoint2 = targetnode.wrapper.bounds.center.y;\n                updatedPts.push({ x: spoint1, y: spoint2 });\n                updatedPts.push({ x: tpoint1 - hSpacing, y: spoint2 });\n                updatedPts.push({ x: tpoint1 - hSpacing, y: tpoint2 });\n                updatedPts.push({ x: tpoint1, y: tpoint2 });\n            }\n        }\n        else {\n            updatedPts = pts;\n        }\n        return updatedPts;\n    };\n    FlowchartLayout.prototype.updateVerticalConnectorSegments = function (internalConnector, pts) {\n        var updatedPts = [];\n        var sourcenode = this.diagram.nameTable[internalConnector.sourceID];\n        var targetnode = this.diagram.nameTable[internalConnector.targetID];\n        var decisionNode = this.vertexMapper.get(sourcenode.id).isDecisionNode;\n        var hSpacing = this.horizontalSpacing / 2;\n        var vSpacing = this.verticalSpacing / 2;\n        if (decisionNode) {\n            var isYesBranch = this.isYesBranchConnector(internalConnector);\n            var isNoBranch = this.isNoBranchConnector(internalConnector);\n            if ((sourcenode.wrapper.bounds.right < targetnode.wrapper.bounds.center.x) &&\n                ((isYesBranch && this.yesBranchDirection === 'RightInFlow') ||\n                    (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&\n                        (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||\n                        (this.yesBranchDirection === 'LeftInFlow' &&\n                            (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow')))))) {\n                var spoint1 = sourcenode.wrapper.bounds.right;\n                var spoint2 = sourcenode.offsetY;\n                var tpoint1 = targetnode.wrapper.bounds.top;\n                var tpoint2 = targetnode.offsetY;\n                updatedPts.push({ x: spoint1, y: spoint2 });\n                var overlappingNodes = this.diagram.nodes.filter(function (e) {\n                    return e.wrapper.bounds.containsPoint({ x: targetnode.offsetX, y: sourcenode.offsetY });\n                });\n                overlappingNodes = overlappingNodes.sort(function (a, b) {\n                    return b.wrapper.bounds.left - a.wrapper.bounds.left;\n                });\n                if (overlappingNodes.length === 0) {\n                    updatedPts.push({ x: targetnode.offsetX, y: spoint2 });\n                }\n                else {\n                    var bounds = overlappingNodes[0].wrapper.bounds;\n                    updatedPts.push({ x: bounds.left - hSpacing, y: overlappingNodes[0].offsetY });\n                    updatedPts.push({ x: bounds.left - hSpacing, y: bounds.bottom + vSpacing });\n                }\n                updatedPts.push({ x: tpoint1, y: tpoint2 });\n            }\n            else if ((sourcenode.wrapper.bounds.left > targetnode.wrapper.bounds.center.x) &&\n                ((isYesBranch && this.yesBranchDirection === 'LeftInFlow') ||\n                    (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&\n                        (this.noBranchDirection === 'SameAsFlow' || this.noBranchDirection === 'LeftInFlow')) ||\n                        (this.yesBranchDirection === 'RightInFlow' &&\n                            (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow')))))) {\n                var spoint1 = sourcenode.wrapper.bounds.left;\n                var spoint2 = sourcenode.offsetY;\n                var tpoint1 = targetnode.wrapper.bounds.top;\n                var tpoint2 = targetnode.offsetY;\n                updatedPts.push({ x: spoint1, y: spoint2 });\n                var middleRect_1 = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds([updatedPts[0], { x: targetnode.offsetX, y: spoint2 }]);\n                var overlappingNodes = this.diagram.nodes.filter(function (e) {\n                    return e.wrapper.bounds.intersects(middleRect_1) &&\n                        e.id !== sourcenode.id &&\n                        e.id !== targetnode.id;\n                });\n                overlappingNodes = overlappingNodes.sort(function (a, b) {\n                    return b.wrapper.bounds.right - a.wrapper.bounds.right;\n                });\n                if (overlappingNodes.length === 0) {\n                    updatedPts.push({ x: targetnode.offsetX, y: spoint2 });\n                }\n                else {\n                    var bounds = overlappingNodes[0].wrapper.bounds;\n                    updatedPts.push({ x: bounds.right + hSpacing, y: overlappingNodes[0].offsetY });\n                    updatedPts.push({ x: bounds.right + hSpacing, y: bounds.bottom + vSpacing });\n                }\n                updatedPts.push({ x: tpoint1, y: tpoint2 });\n            }\n            else if ((isYesBranch && this.yesBranchDirection === 'RightInFlow') ||\n                (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&\n                    (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||\n                    (this.yesBranchDirection === 'LeftInFlow' &&\n                        (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {\n                var spoint1 = sourcenode.wrapper.bounds.right;\n                var spoint2 = sourcenode.offsetY;\n                var tpoint1 = targetnode.wrapper.bounds.topCenter.x;\n                var tpoint2 = targetnode.wrapper.bounds.topCenter.y;\n                updatedPts.push({ x: spoint1, y: spoint2 });\n                updatedPts.push({ x: spoint1 + hSpacing, y: spoint2 });\n                updatedPts.push({ x: spoint1 + hSpacing, y: tpoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1, y: tpoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1, y: tpoint2 });\n                var middleRect_2 = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds([updatedPts[1], updatedPts[2]]);\n                var overlappingNodes = this.diagram.nodes.filter(function (e) {\n                    return e.wrapper.bounds.intersects(middleRect_2);\n                });\n                overlappingNodes = overlappingNodes.sort(function (a, b) {\n                    return b.wrapper.bounds.right - a.wrapper.bounds.right;\n                });\n                if (overlappingNodes.length > 0 && overlappingNodes[0].wrapper.bounds.intersects(middleRect_2)) {\n                    var bounds = overlappingNodes[0].wrapper.bounds;\n                    updatedPts[1].x = bounds.right + hSpacing;\n                    updatedPts[2].x = bounds.right + hSpacing;\n                }\n            }\n            else if ((isYesBranch && this.yesBranchDirection === 'LeftInFlow') ||\n                (isNoBranch && ((this.yesBranchDirection === 'SameAsFlow' &&\n                    (this.noBranchDirection === 'SameAsFlow' || this.noBranchDirection === 'LeftInFlow')) ||\n                    (this.yesBranchDirection === 'RightInFlow' &&\n                        (this.noBranchDirection === 'LeftInFlow' || this.noBranchDirection === 'RightInFlow'))))) {\n                var spoint1 = sourcenode.wrapper.bounds.left;\n                var spoint2 = sourcenode.offsetY;\n                var tpoint1 = targetnode.wrapper.bounds.topCenter.x;\n                var tpoint2 = targetnode.wrapper.bounds.topCenter.y;\n                updatedPts.push({ x: spoint1, y: spoint2 });\n                updatedPts.push({ x: spoint1 - hSpacing, y: spoint2 });\n                updatedPts.push({ x: spoint1 - hSpacing, y: tpoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1, y: tpoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1, y: tpoint2 });\n                var middleRect_3 = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds([updatedPts[1], updatedPts[2]]);\n                var overlappingNodes = this.diagram.nodes.filter(function (e) {\n                    return e.wrapper.bounds.intersects(middleRect_3);\n                });\n                overlappingNodes = overlappingNodes.sort(function (a, b) {\n                    return b.wrapper.bounds.left - a.wrapper.bounds.left;\n                });\n                if (overlappingNodes.length > 0 && overlappingNodes[0].wrapper.bounds.intersects(middleRect_3)) {\n                    var bounds = overlappingNodes[0].wrapper.bounds;\n                    updatedPts[1].x = bounds.left - hSpacing;\n                    updatedPts[2].x = bounds.left - hSpacing;\n                }\n            }\n            else if ((sourcenode.offsetX !== targetnode.offsetX) &&\n                ((isYesBranch && this.yesBranchDirection === 'SameAsFlow') ||\n                    (isNoBranch &&\n                        this.noBranchDirection === 'SameAsFlow' &&\n                        this.yesBranchDirection !== 'SameAsFlow'))) {\n                var spoint1 = sourcenode.offsetX;\n                var spoint2 = sourcenode.wrapper.bounds.bottom;\n                var tpoint1 = targetnode.wrapper.bounds.topCenter.x;\n                var tpoint2 = targetnode.wrapper.bounds.topCenter.y;\n                updatedPts.push({ x: spoint1, y: spoint2 });\n                updatedPts.push({ x: spoint1, y: tpoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1, y: tpoint2 - vSpacing });\n                updatedPts.push({ x: tpoint1, y: tpoint2 });\n            }\n            else {\n                updatedPts = pts;\n            }\n        }\n        else {\n            updatedPts = pts;\n        }\n        return updatedPts;\n    };\n    FlowchartLayout.prototype.getModelBounds = function (nodes) {\n        var rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(0, 0, 0, 0);\n        nodes = Array.from(nodes);\n        nodes.forEach(function (vertex) {\n            var geo = vertex.geometry;\n            rect.uniteRect(geo);\n        });\n        return rect;\n    };\n    FlowchartLayout.prototype.createVertex = function (node) {\n        var _this = this;\n        var nodeWidth = isNaN(node.width) ? node.wrapper.bounds.width : node.width;\n        var nodeHeight = isNaN(node.height) ? node.wrapper.bounds.height : node.height;\n        var geometry = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect(0, 0, nodeWidth, nodeHeight);\n        var inEdges = [];\n        var outEdges = [];\n        var branches = { isYesBranch: false, isNoBranch: false };\n        if (node.inEdges != null) {\n            for (var _i = 0, _a = node.inEdges; _i < _a.length; _i++) {\n                var edge = _a[_i];\n                var con = this.diagram.nameTable[\"\" + edge];\n                if (con) {\n                    inEdges.push(con);\n                }\n            }\n        }\n        if (node.outEdges != null) {\n            for (var _b = 0, _c = node.outEdges; _b < _c.length; _b++) {\n                var edge = _c[_b];\n                var con = this.diagram.nameTable[\"\" + edge];\n                if (con) {\n                    outEdges.push(con);\n                }\n            }\n        }\n        var isYesBranch = branches.isYesBranch;\n        var isNoBranch = branches.isNoBranch;\n        if (inEdges != null) {\n            inEdges.forEach(function (inEdge) {\n                branches = _this.checkForYesOrNoBranch(inEdge, isYesBranch, isNoBranch);\n            });\n        }\n        if (outEdges != null) {\n            outEdges.forEach(function (outEdge) {\n                _this.edgesMapper.set(outEdge, []);\n                _this.loopedgesMapper.set(outEdge, false);\n            });\n        }\n        var vert = {\n            id: node.id,\n            geometry: geometry,\n            inEdges: inEdges,\n            layoutObjectId: {},\n            outEdges: outEdges,\n            item: node,\n            isDecisionNode: false,\n            isYesChild: branches.isYesBranch,\n            isNoChild: branches.isNoBranch\n        };\n        return vert;\n    };\n    FlowchartLayout.prototype.updatePoints = function (pts, internalConnector) {\n        var pointSets = [];\n        var segCollection = [];\n        for (var i = 0; i < pts.length; i++) {\n            if (pts[i + 2]) {\n                pointSets.push(pts[parseInt(i.toString(), 10)]);\n                pointSets.push(pts[i + 1]);\n                var seg = {\n                    type: 'Orthogonal',\n                    points: pointSets,\n                    length: pointSets[0].x === pointSets[1].x ? Math.abs(pointSets[0].y - pointSets[1].y)\n                        : Math.abs(pointSets[0].x - pointSets[1].x),\n                    direction: pointSets[0].x === pointSets[1].x ? pointSets[0].y > pointSets[1].y ? 'Top' : 'Bottom'\n                        : pointSets[0].x > pointSets[1].x ? 'Left' : 'Right'\n                };\n                pointSets = [];\n                segCollection.push(seg);\n            }\n        }\n        internalConnector.segments = segCollection;\n    };\n    FlowchartLayout.prototype.contains = function (point, bounds) {\n        return (point.x >= bounds.left && point.x <= bounds.right && point.y >= bounds.top && point.y <= bounds.bottom);\n    };\n    FlowchartLayout.prototype.updateLoopConnector = function (internalConnector) {\n        var loopPts = [];\n        if (this.edgesMapper.has(internalConnector)) {\n            var loopPoints = this.edgesMapper.get(internalConnector);\n            if (loopPoints) {\n                for (var _i = 0, loopPoints_1 = loopPoints; _i < loopPoints_1.length; _i++) {\n                    var loopPt = loopPoints_1[_i];\n                    var pointX = loopPt.x + this.anchorX;\n                    var pointY = loopPt.y + this.anchorY;\n                    loopPts.push({ x: pointX, y: pointY });\n                }\n            }\n        }\n        loopPts.reverse();\n        var pts = [];\n        var firstPt = loopPts[0];\n        var lastPt = loopPts[loopPts.length - 1];\n        var sourceNode = this.diagram.nameTable[internalConnector.sourceID];\n        var targetNode = this.diagram.nameTable[internalConnector.targetID];\n        var srcBounds = sourceNode.wrapper.bounds;\n        var tarBounds = targetNode.wrapper.bounds;\n        var srcNode = sourceNode;\n        var tarNode = targetNode;\n        var decisionNode = this.vertexMapper.get(internalConnector.sourceID).isDecisionNode;\n        var isYesBranch = this.isYesBranchConnector(internalConnector);\n        var isNoBranch = this.isNoBranchConnector(internalConnector);\n        var isYesBranchLeft = isYesBranch && this.yesBranchDirection === 'LeftInFlow';\n        var isNoBranchRight = isNoBranch && ((this.yesBranchDirection === 'RightInFlow' &&\n            (this.noBranchDirection === 'RightInFlow' || this.noBranchDirection === 'SameAsFlow')) ||\n            (this.noBranchDirection === 'LeftInFlow' &&\n                (this.yesBranchDirection === 'RightInFlow' || this.yesBranchDirection === 'SameAsFlow')));\n        var hSpacing = this.horizontalSpacing / 2;\n        var vSpacing = this.verticalSpacing / 2;\n        var combinedBounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect().uniteRect(srcNode.wrapper.bounds).uniteRect(tarNode.wrapper.bounds);\n        var overlappingNodesInDiagram = this.diagram.nodes.filter(function (node) {\n            return node.id !== tarNode.id && node.id !== srcNode.id && node.wrapper.bounds.intersects(combinedBounds);\n        });\n        if (this.orientation === 'TopToBottom') {\n            var source = Array.from(this.vertexMapper.values())\n                .filter(function (e) {\n                return e.item.wrapper.bounds.containsPoint({ x: e.item.wrapper.bounds.x, y: srcNode.offsetY }) &&\n                    srcNode.id !== e.item.id;\n            });\n            var target = Array.from(this.vertexMapper.values())\n                .filter(function (e) {\n                return e.item.wrapper.bounds.containsPoint({ x: e.item.wrapper.bounds.x, y: tarNode.offsetY }) &&\n                    tarNode.id !== e.item.id;\n            });\n            var max = Math.max.apply(Math, loopPts.map(function (pt) { return pt.x; }));\n            var isSiblingsInRight = false;\n            if (decisionNode) {\n                if (isYesBranchLeft || isNoBranchRight) {\n                    isSiblingsInRight = true;\n                }\n            }\n            else {\n                isSiblingsInRight = (source.length > 0 && source[0].item.wrapper.bounds.x > srcBounds.x);\n            }\n            if (target.length === 0 || (!isSiblingsInRight && target.length > 0 && target.filter(function (e) {\n                return e.item.wrapper.bounds.right < tarBounds.left;\n            }).length > 0)) {\n                // Determine X coordinates based on conditions\n                var initialX = (!isSiblingsInRight && max > srcBounds.right) ? srcBounds.right : srcBounds.left;\n                var midX = initialX + (isSiblingsInRight ? -hSpacing : hSpacing);\n                var targetX = (!isSiblingsInRight && max > tarBounds.right) ? tarBounds.right : tarBounds.left;\n                // Add points to the collection\n                pts.push({ x: initialX, y: srcNode.offsetY });\n                pts.push({ x: midX, y: srcNode.offsetY });\n                pts.push({ x: midX, y: tarNode.offsetY });\n                pts.push({ x: targetX, y: tarNode.offsetY });\n            }\n            else {\n                var targetBottom = target[0].item.wrapper.bounds.bottom;\n                var verticalMiddle = targetBottom + vSpacing;\n                var startX = !isSiblingsInRight ? srcBounds.right : srcBounds.left;\n                var middleX = startX + (isSiblingsInRight ? -hSpacing : hSpacing);\n                var endX = !isSiblingsInRight && max > tarBounds.right ? tarBounds.right + hSpacing : tarBounds.left - hSpacing;\n                var finalX = !isSiblingsInRight && max > tarBounds.right ? tarBounds.right : tarBounds.left;\n                pts.push({ x: startX, y: srcNode.offsetY });\n                pts.push({ x: middleX, y: srcNode.offsetY });\n                pts.push({ x: middleX, y: verticalMiddle });\n                pts.push({ x: endX, y: verticalMiddle });\n                pts.push({ x: endX, y: tarNode.offsetY });\n                pts.push({ x: finalX, y: tarNode.offsetY });\n            }\n            if (overlappingNodesInDiagram.length > 0) {\n                var boundsValue = isSiblingsInRight\n                    ? Math.min.apply(Math, overlappingNodesInDiagram.map(function (node) { return node.wrapper.bounds.left; })) : Math.max.apply(Math, overlappingNodesInDiagram.map(function (node) { return node.wrapper.bounds.right; }));\n                if ((isSiblingsInRight && boundsValue < pts[1].x) || (!isSiblingsInRight && boundsValue > pts[1].x)) {\n                    var newX = boundsValue + (isSiblingsInRight ? -hSpacing : hSpacing);\n                    pts[1].x = newX;\n                    pts[2].x = newX;\n                }\n            }\n        }\n        else {\n            var source = Array.from(this.vertexMapper.values())\n                .filter(function (e) {\n                return e.item.wrapper.bounds.containsPoint({ y: e.item.wrapper.bounds.y, x: srcNode.offsetX }) &&\n                    srcNode.id !== e.item.id;\n            });\n            var target = Array.from(this.vertexMapper.values())\n                .filter(function (e) {\n                return e.item.wrapper.bounds.containsPoint({ y: e.item.wrapper.bounds.y, x: tarNode.offsetX }) &&\n                    tarNode.id !== e.item.id;\n            });\n            var max = Math.max.apply(Math, loopPts.map(function (pt) { return pt.y; }));\n            var isSiblingsInBottom = false;\n            if (decisionNode) {\n                if (isYesBranchLeft || isNoBranchRight) {\n                    isSiblingsInBottom = true;\n                }\n            }\n            else {\n                isSiblingsInBottom = (source.length > 0 && source[0].item.wrapper.bounds.y > srcBounds.y);\n            }\n            if (target.length === 0 || (!isSiblingsInBottom && target.length > 0 && target.some(function (e) {\n                return e.item.wrapper.bounds.bottom < tarBounds.top;\n            }))) {\n                pts.push({ x: srcNode.offsetX, y: (!isSiblingsInBottom && max > srcBounds.bottom) ? srcBounds.bottom : srcBounds.top });\n                var midY = pts[0].y + (isSiblingsInBottom ? -vSpacing : vSpacing);\n                pts.push({ x: srcNode.offsetX, y: midY });\n                pts.push({ x: tarNode.offsetX, y: midY });\n                pts.push({ x: tarNode.offsetX, y: (!isSiblingsInBottom && max > tarBounds.bottom) ? tarBounds.bottom : tarBounds.top });\n            }\n            else {\n                var targetRight = target[0].item.wrapper.bounds.right + hSpacing;\n                var midY = (!isSiblingsInBottom && max > tarBounds.bottom)\n                    ? tarBounds.bottom + vSpacing : tarBounds.top - vSpacing;\n                pts.push({ x: srcNode.offsetX, y: (!isSiblingsInBottom) ? srcBounds.bottom : srcBounds.top });\n                pts.push({ x: srcNode.offsetX, y: pts[0].y + (isSiblingsInBottom ? -vSpacing : vSpacing) });\n                pts.push({ x: targetRight, y: pts[1].y });\n                pts.push({ x: targetRight, y: midY });\n                pts.push({ x: tarNode.offsetX, y: midY });\n                pts.push({ x: tarNode.offsetX, y: ((!isSiblingsInBottom && max > tarBounds.bottom) ? tarBounds.bottom : tarBounds.top) });\n            }\n            if (overlappingNodesInDiagram.length > 0) {\n                var boundsValue = isSiblingsInBottom\n                    ? Math.min.apply(Math, overlappingNodesInDiagram.map(function (e) { return e.wrapper.bounds.top; })) : Math.max.apply(Math, overlappingNodesInDiagram.map(function (e) { return e.wrapper.bounds.bottom; }));\n                if ((isSiblingsInBottom && pts[1].y > boundsValue) || (!isSiblingsInBottom && pts[1].y < boundsValue)) {\n                    var adjustment = isSiblingsInBottom ? -vSpacing : vSpacing;\n                    pts[1].y = boundsValue + adjustment;\n                    pts[2].y = boundsValue + adjustment;\n                }\n            }\n        }\n        this.updatePoints(pts, internalConnector);\n    };\n    FlowchartLayout.prototype.checkForYesOrNoBranch = function (edge, isYesBranch, isNoBranch) {\n        var _this = this;\n        if (edge.annotations && edge.annotations.length) {\n            edge.annotations.forEach(function (annotation) {\n                if (typeof annotation.content === 'string') {\n                    var text_2 = annotation.content.toString();\n                    _this.yesBranchValues.forEach(function (branchText) {\n                        if (text_2.localeCompare(branchText, undefined, { sensitivity: 'accent' }) === 0) {\n                            isYesBranch = true;\n                            return;\n                        }\n                    });\n                    _this.noBranchValues.forEach(function (branchText) {\n                        if (text_2.localeCompare(branchText, undefined, { sensitivity: 'accent' }) === 0) {\n                            isNoBranch = true;\n                            return;\n                        }\n                    });\n                }\n            });\n        }\n        return { isYesBranch: isYesBranch, isNoBranch: isNoBranch };\n    };\n    FlowchartLayout.prototype.getTreeVertices = function (root, seenVertices, unseenVertices) {\n        var _this = this;\n        if (root != null && seenVertices.indexOf(root) === -1) {\n            seenVertices.push(root);\n            unseenVertices = unseenVertices.filter(function (vertex) { return vertex !== root; });\n            var children = root.item.outEdges;\n            if (children.length === 2) {\n                var c1 = this.diagram.nameTable[this.diagram.nameTable[children[0]].targetID];\n                var c2 = this.diagram.nameTable[this.diagram.nameTable[children[1]].targetID];\n                var childVertex1 = this.vertexMapper.get(c1.id);\n                var childVertex2 = this.vertexMapper.get(c2.id);\n                if (childVertex1 && childVertex2) {\n                    var hasYesChild = childVertex1.isYesChild || childVertex2.isYesChild;\n                    var hasNoChild = childVertex1.isNoChild || childVertex2.isNoChild;\n                    if (hasYesChild && !hasNoChild) {\n                        if (childVertex1.isYesChild) {\n                            childVertex2.isNoChild = true;\n                        }\n                        else {\n                            childVertex1.isNoChild = true;\n                        }\n                        hasNoChild = true;\n                    }\n                    else if (!hasYesChild && hasNoChild) {\n                        if (childVertex1.isNoChild) {\n                            childVertex2.isYesChild = true;\n                        }\n                        else {\n                            childVertex1.isYesChild = true;\n                        }\n                        hasYesChild = true;\n                    }\n                    root.isDecisionNode = hasYesChild;\n                }\n            }\n            root.outEdges.forEach(function (outConnector) {\n                var child = _this.diagram.nameTable[outConnector.targetID];\n                var childVertex = _this.vertexMapper.get(child.id);\n                if (childVertex != null) {\n                    if (!root.isDecisionNode) {\n                        childVertex.isYesChild = false;\n                        childVertex.isNoChild = false;\n                    }\n                    _this.getTreeVertices(childVertex, seenVertices, unseenVertices);\n                }\n            });\n        }\n    };\n    /**\n     * Initializes the edges collection of the vertices\\\n     *\n     * @returns {  IConnector[] }    Initializes the edges collection of the vertices\\\n     * @param {FlowChartVertex} node - provide the node value.\n     * @private\n     */\n    FlowchartLayout.prototype.getEdges = function (node) {\n        var edges = [];\n        if (node !== null && node !== undefined) {\n            for (var _i = 0, _a = node.inEdges; _i < _a.length; _i++) {\n                var inEdge = _a[_i];\n                edges.push(inEdge);\n            }\n            for (var _b = 0, _c = node.outEdges; _b < _c.length; _b++) {\n                var outEdge = _c[_b];\n                edges.push(outEdge);\n            }\n        }\n        return edges;\n    };\n    /**\n     * Returns the source/target vertex of the given connector \\\n     *\n     * @returns {  FlowChartVertex }    Returns the source/target vertex of the given connector \\\n     * @param {IConnector} edge - provide the node value.\n     * @param {boolean} source - provide the node value.\n     * @private\n     */\n    FlowchartLayout.prototype.getVisibleTerminal = function (edge, source) {\n        //differ from complex-hierarchical-tree.ts\n        var nodeWrapper = source ? edge.sourceID : edge.targetID;\n        return this.vertexMapper.get(nodeWrapper);\n    };\n    /**\n     * used to get the edges between the given source and target  \\\n     *\n     * @returns {  IConnector[] }    used to get the edges between the given source and target  .\\\n     * @param {FlowChartVertex} source - provide the angle value.\n     * @param { FlowChartVertex} target - provide the angle value.\n     * @param { boolean} directed - provide the angle value.\n     * @private\n     */\n    FlowchartLayout.prototype.getEdgesBetween = function (source, target, directed) {\n        var edges = this.getEdges(source);\n        var result = [];\n        for (var i = 0; i < edges.length; i++) {\n            var src = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], true);\n            var trg = this.getVisibleTerminal(edges[parseInt(i.toString(), 10)], false);\n            if ((src.id === source.id && trg.id === target.id)) {\n                result.push(edges[parseInt(i.toString(), 10)]);\n            }\n        }\n        return result;\n    };\n    /**\n     *To destroy the FlowchartLayout\n     *\n     * @returns {void} To destroy the FlowchartLayout\n     */\n    FlowchartLayout.prototype.destroy = function () {\n        /**\n         * Destroys the FlowchartLayout module\n         */\n    };\n    /**\n     * @returns { string } toBounds method .\\\n     * Get getModuleName name.\n     */\n    FlowchartLayout.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'FlowchartLayout';\n    };\n    return FlowchartLayout;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/flow-chart-layout.js?");

/***/ })

}]);