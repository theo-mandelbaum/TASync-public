"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_scroller_js-89e16530"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/scroller.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/scroller.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiagramScroller: () => (/* binding */ DiagramScroller)\n/* harmony export */ });\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _primitives_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/matrix */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js\");\n/* harmony import */ var _ruler_ruler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ruler/ruler */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/ruler/ruler.js\");\n/* harmony import */ var _utility_constraints_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../utility/constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n\n\n\n\n\n/**\n */\nvar DiagramScroller = /** @class */ (function () {\n    function DiagramScroller(diagram) {\n        /** @private */\n        this.transform = { tx: 0, ty: 0, scale: 1 };\n        /**   @private  */\n        this.oldCollectionObjects = [];\n        /**   @private  */\n        this.removeCollection = [];\n        this.vPortWidth = 0;\n        this.vPortHeight = 0;\n        this.currentZoomFActor = 1;\n        this.hOffset = 0;\n        this.vOffset = 0;\n        this.scrolled = false;\n        this.hScrollSize = 0;\n        this.vScrollSize = 0;\n        this.diagram = diagram;\n        this.objects = [];\n        this.transform = diagram.scroller ? diagram.scroller.transform : { tx: 0, ty: 0, scale: 1 };\n        this.vPortWidth = diagram.scrollSettings.viewPortWidth;\n        this.vPortHeight = diagram.scrollSettings.viewPortHeight;\n        this.currentZoomFActor = diagram.scrollSettings.currentZoom;\n        this.hOffset = diagram.scrollSettings.horizontalOffset;\n        this.vOffset = diagram.scrollSettings.verticalOffset;\n    }\n    Object.defineProperty(DiagramScroller.prototype, \"viewPortHeight\", {\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { number }     verticalOffset method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.vPortHeight;\n        },\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { void }     verticalOffset method .\\\n         * @param {number} offset - provide the hOffset value.\n         *\n         * @private\n         */\n        set: function (offset) {\n            this.vPortHeight = offset;\n            this.diagram.scrollSettings.viewPortHeight = offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiagramScroller.prototype, \"currentZoom\", {\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { number }     verticalOffset method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.currentZoomFActor || 1;\n        },\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { void }     verticalOffset method .\\\n         * @param {number} offset - provide the hOffset value.\n         *\n         * @private\n         */\n        set: function (offset) {\n            this.currentZoomFActor = offset;\n            this.diagram.scrollSettings.currentZoom = offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiagramScroller.prototype, \"viewPortWidth\", {\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { number }     verticalOffset method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.vPortWidth;\n        },\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { void }     verticalOffset method .\\\n         * @param {number} offset - provide the hOffset value.\n         *\n         * @private\n         */\n        set: function (offset) {\n            this.vPortWidth = offset;\n            this.diagram.scrollSettings.viewPortWidth = offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiagramScroller.prototype, \"horizontalOffset\", {\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { number }     verticalOffset method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.hOffset;\n        },\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { void }     verticalOffset method .\\\n         * @param {number} offset - provide the hOffset value.\n         *\n         * @private\n         */\n        set: function (offset) {\n            this.hOffset = offset;\n            if (Math.abs(this.hOffset - this.diagram.scrollSettings.horizontalOffset) > 1) {\n                this.diagram.realActions = this.diagram.realActions | _enum_enum__WEBPACK_IMPORTED_MODULE_1__.RealAction.hScrollbarMoved;\n                this.scrolled = true;\n            }\n            this.diagram.scrollSettings.horizontalOffset = offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiagramScroller.prototype, \"verticalOffset\", {\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { number }     verticalOffset method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.vOffset;\n        },\n        /**\n         * verticalOffset method \\\n         *\n         * @returns { void }     verticalOffset method .\\\n         * @param {number} offset - provide the hOffset value.\n         *\n         * @private\n         */\n        set: function (offset) {\n            this.vOffset = offset;\n            if (Math.abs(this.vOffset - this.diagram.scrollSettings.verticalOffset) > 1) {\n                this.diagram.realActions = this.diagram.realActions | _enum_enum__WEBPACK_IMPORTED_MODULE_1__.RealAction.vScrollbarMoved;\n                this.scrolled = true;\n            }\n            this.diagram.scrollSettings.verticalOffset = offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Method added to get bounds value if diagram is loaded from negative axis.\n    // SF-359118 implemented for this ticket requirement.\n    DiagramScroller.prototype.getBounds = function () {\n        var pageBounds;\n        var postion = this.diagram.spatialSearch.getPageBounds(0, 0);\n        if ((postion.x < 0 || postion.y < 0) && !this.diagram.pageSettings.multiplePage) {\n            pageBounds = this.getPageBounds(undefined, undefined, true, true);\n        }\n        else {\n            pageBounds = this.getPageBounds(undefined, undefined, true);\n        }\n        return pageBounds;\n    };\n    /**\n     * updateScrollOffsets method \\\n     *\n     * @returns { void }     updateScrollOffsets method .\\\n     * @param {number} hOffset - provide the hOffset value.\n     * @param {number} vOffset - provide the vOffset value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.updateScrollOffsets = function (hOffset, vOffset) {\n        var offsetX = 0;\n        var offsetY = 0;\n        var pageBounds = this.getBounds();\n        pageBounds.x *= this.currentZoom;\n        pageBounds.y *= this.currentZoom;\n        pageBounds.width *= this.currentZoom;\n        pageBounds.height *= this.currentZoom;\n        offsetX = Math.max(0, hOffset - pageBounds.left);\n        offsetY = Math.max(0, vOffset - pageBounds.top);\n        if (hOffset !== undefined && vOffset !== undefined) {\n            this.horizontalOffset = offsetX;\n            this.verticalOffset = offsetY;\n            this.diagram.setOffset(offsetX, offsetY);\n        }\n        else {\n            this.diagram.setOffset(-this.horizontalOffset - pageBounds.x, -this.verticalOffset - pageBounds.y);\n        }\n        this.transform = {\n            tx: Math.max(this.horizontalOffset, -pageBounds.left) / this.currentZoom, ty: Math.max(this.verticalOffset, -pageBounds.top) / this.currentZoom,\n            scale: this.currentZoom\n        };\n    };\n    /**\n     * setScrollOffset method \\\n     *\n     * @returns { void }     setScrollOffset method .\\\n     * @param {number} hOffset - provide the hOffset value.\n     * @param {number} vOffset - provide the vOffset value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.setScrollOffset = function (hOffset, vOffset) {\n        this.scrolled = false;\n        var pageBounds = this.getBounds();\n        pageBounds.x *= this.currentZoom;\n        pageBounds.y *= this.currentZoom;\n        pageBounds.width *= this.currentZoom;\n        pageBounds.height *= this.currentZoom;\n        var x = -pageBounds.left;\n        var y = -pageBounds.top;\n        var set = false;\n        var viewWidth = this.viewPortWidth * this.currentZoom;\n        var viewHeight = this.viewPortHeight * this.currentZoom;\n        var newX = x - hOffset;\n        if (newX !== this.horizontalOffset) {\n            if (x < this.horizontalOffset) {\n                if (this.horizontalOffset > newX) {\n                    this.horizontalOffset -= hOffset;\n                }\n                else {\n                    this.horizontalOffset = newX;\n                }\n                set = true;\n            }\n            var right = Math.max(pageBounds.right + this.vScrollSize, viewWidth);\n            if (!set && right < -newX + this.viewPortWidth) {\n                var actualRight = -newX + viewWidth - this.vScrollSize;\n                var currentRight = -this.horizontalOffset + viewWidth - this.vScrollSize;\n                if (actualRight < currentRight) {\n                    //define\n                    this.horizontalOffset = newX;\n                }\n                else {\n                    if (actualRight - pageBounds.right > actualRight - currentRight) {\n                        this.horizontalOffset = newX;\n                    }\n                    else {\n                        this.horizontalOffset = -(pageBounds.right + this.vScrollSize - viewWidth);\n                    }\n                }\n                set = true;\n            }\n            if (!set) {\n                this.horizontalOffset = x - hOffset;\n            }\n        }\n        set = false;\n        //vertical offset\n        var newY = y - vOffset;\n        if (newY !== this.verticalOffset) {\n            if (y < this.verticalOffset) {\n                if (this.verticalOffset > newY) {\n                    this.verticalOffset -= vOffset;\n                }\n                else {\n                    this.verticalOffset = newY;\n                }\n                set = true;\n            }\n            var bottom = Math.max(pageBounds.bottom + this.hScrollSize, viewHeight);\n            if (!set && bottom < -newY + viewHeight) {\n                var actualBottom = -newY + viewHeight - this.hScrollSize;\n                var currentBottom = -this.verticalOffset + viewHeight - this.hScrollSize;\n                if (actualBottom < currentBottom) {\n                    //define\n                    this.verticalOffset = newY;\n                }\n                else {\n                    if (actualBottom - pageBounds.bottom > actualBottom - currentBottom) {\n                        this.verticalOffset = newY;\n                    }\n                    else {\n                        this.verticalOffset = -(pageBounds.bottom + this.hScrollSize - viewHeight);\n                    }\n                }\n                set = true;\n            }\n            if (!set) {\n                this.verticalOffset = y - vOffset;\n            }\n        }\n        this.transform = {\n            tx: Math.max(this.horizontalOffset, -pageBounds.left) / this.currentZoom, ty: Math.max(this.verticalOffset, -pageBounds.top) / this.currentZoom,\n            scale: this.currentZoom\n        };\n        this.setSize();\n    };\n    /**\n     * getObjects \\\n     *\n     * @returns { string[] }     To get page pageBounds.\\\n     * @param {string[]} coll1 - provide the source value.\n     * @param {string[]} coll2 - provide the source value.\n     * @private\n     */\n    DiagramScroller.prototype.getObjects = function (coll1, coll2) {\n        var objects = [];\n        for (var i = 0; i < coll1.length; i++) {\n            var isExist = false;\n            for (var j = 0; j < coll2.length; j++) {\n                if (coll1[parseInt(i.toString(), 10)] === coll2[parseInt(j.toString(), 10)]) {\n                    isExist = true;\n                    break;\n                }\n            }\n            if (!isExist) {\n                objects.push(coll1[parseInt(i.toString(), 10)]);\n            }\n        }\n        return objects;\n    };\n    /**\n     * virtualizeElements \\\n     *\n     * @returns { void }     To get page pageBounds.\\\n     *\n     * @private\n     */\n    DiagramScroller.prototype.virtualizeElements = function () {\n        var viewWidth = this.viewPortWidth / this.currentZoom;\n        var viewHeight = this.viewPortHeight / this.currentZoom;\n        var oObjects = this.diagram.spatialSearch.findObjects(new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(-this.horizontalOffset / this.currentZoom, -this.verticalOffset / this.currentZoom, viewWidth, viewHeight));\n        var oObjectsID = [];\n        var renderOrder = [];\n        for (var j = 0; j < oObjects.length; j++) {\n            var bpmnShape = oObjects[parseInt(j.toString(), 10)].shape;\n            if (bpmnShape.type === 'Bpmn' && bpmnShape && bpmnShape.activity && bpmnShape.activity.subProcess && bpmnShape.activity.subProcess.processes && bpmnShape.activity.subProcess.processes.length > 0) {\n                for (var k = 0; k < bpmnShape.activity.subProcess.processes.length; k++) {\n                    renderOrder.push(bpmnShape.activity.subProcess.processes[parseInt(k.toString(), 10)]);\n                }\n                renderOrder.push(oObjects[parseInt(j.toString(), 10)].id);\n            }\n            else if (oObjects[parseInt(j.toString(), 10)].processId === '' || oObjects[parseInt(j.toString(), 10)].processId === undefined) {\n                renderOrder.push(oObjects[parseInt(j.toString(), 10)].id);\n            }\n        }\n        oObjectsID = renderOrder;\n        var zindexOrder = [];\n        for (var j = 0; j < oObjects.length; j++) {\n            var items = oObjects[parseInt(j.toString(), 10)].shape;\n            if (items.type === 'Bpmn' && items && items.activity && items.activity.subProcess && items.activity.subProcess.processes && items.activity.subProcess.processes.length > 0) {\n                zindexOrder.push(oObjects[parseInt(j.toString(), 10)].id);\n                for (var t = 0; t < items.activity.subProcess.processes.length; t++) {\n                    zindexOrder.push(items.activity.subProcess.processes[parseInt(t.toString(), 10)]);\n                }\n            }\n            else if (oObjects[parseInt(j.toString(), 10)].processId === '' || oObjects[parseInt(j.toString(), 10)].processId === undefined) {\n                zindexOrder.push(oObjects[parseInt(j.toString(), 10)].id);\n            }\n        }\n        for (var j = 0; j < oObjects.length; j++) {\n            for (var k = 0; k < zindexOrder.length; k++) {\n                if (oObjects[parseInt(j.toString(), 10)].id === zindexOrder[parseInt(k.toString(), 10)]) {\n                    oObjects[parseInt(j.toString(), 10)].zIndex = k;\n                    break;\n                }\n            }\n        }\n        var newObjects = this.getObjects(oObjectsID, this.oldCollectionObjects);\n        if (this.oldCollectionObjects.length === 0) {\n            this.oldCollectionObjects = oObjectsID;\n        }\n        var removeObjects = this.getObjects(this.oldCollectionObjects, oObjectsID);\n        this.diagram.updateVirtualObjects(newObjects, false, removeObjects);\n        this.oldCollectionObjects = oObjectsID;\n    };\n    /**\n     * setSize \\\n     *\n     * @returns { void }     To get page pageBounds.\\\n     * @param {PointModel} newOffset - provide the newOffset value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.setSize = function (newOffset) {\n        var pageBounds = this.getPageBounds(undefined, undefined, true);\n        pageBounds.x *= this.currentZoom;\n        pageBounds.y *= this.currentZoom;\n        pageBounds.width *= this.currentZoom;\n        pageBounds.height *= this.currentZoom;\n        var x = Math.min(pageBounds.x, -this.horizontalOffset);\n        var y = Math.min(pageBounds.y, -this.verticalOffset);\n        var difX = -this.horizontalOffset + this.viewPortWidth - pageBounds.right;\n        var difY = -this.verticalOffset + this.viewPortHeight - pageBounds.bottom;\n        var hScrollSize = this.scrollerWidth;\n        var vScrollSize = this.scrollerWidth;\n        if (-this.verticalOffset <= pageBounds.y && -this.verticalOffset + this.viewPortHeight >= pageBounds.bottom) {\n            vScrollSize = 0;\n        }\n        if (-this.horizontalOffset <= pageBounds.x && -this.horizontalOffset + this.viewPortWidth >= pageBounds.right) {\n            hScrollSize = 0;\n        }\n        this.hScrollSize = hScrollSize;\n        this.vScrollSize = vScrollSize;\n        var oldWidth = this.diagramWidth;\n        var oldHeight = this.diagramHeight;\n        this.diagramWidth = Math.max(pageBounds.right, -this.horizontalOffset + this.viewPortWidth - vScrollSize) - x;\n        this.diagramHeight = Math.max(pageBounds.bottom, -this.verticalOffset + this.viewPortHeight - hScrollSize) - y;\n        if ((oldWidth !== this.diagramWidth || oldHeight !== this.diagramHeight) && this.diagram.scrollSettings.scrollLimit !== 'Diagram') {\n            this.diagram.setSize(this.diagramWidth, this.diagramHeight);\n        }\n        if (this.diagram.scrollSettings.scrollLimit === 'Diagram') {\n            if ((oldWidth !== this.diagramWidth || oldHeight !== this.diagramHeight || this.currentZoom !== 1)\n                && ((!this.diagram.diagramActions || !newOffset) || (this.diagram.diagramActions && newOffset &&\n                    ((this.verticalOffset !== 0 || this.verticalOffset === newOffset.y) &&\n                        (this.horizontalOffset !== 0 || this.horizontalOffset === newOffset.x))))) {\n                if ((this.diagram.scrollActions & _enum_enum__WEBPACK_IMPORTED_MODULE_1__.ScrollActions.Interaction) && newOffset) {\n                    this.transform = {\n                        tx: Math.max(newOffset.x, -(pageBounds.left / this.currentZoom)) / this.currentZoom,\n                        ty: Math.max(newOffset.y, -(pageBounds.top / this.currentZoom)) / this.currentZoom,\n                        scale: this.currentZoom\n                    };\n                    this.horizontalOffset = newOffset.x;\n                    this.verticalOffset = newOffset.y;\n                }\n                this.diagram.setSize(this.diagramWidth, this.diagramHeight);\n                if ((!(this.diagram.scrollActions & _enum_enum__WEBPACK_IMPORTED_MODULE_1__.ScrollActions.PropertyChange)) && newOffset) {\n                    this.horizontalOffset = newOffset.x;\n                    this.verticalOffset = newOffset.y;\n                    this.transform = {\n                        tx: Math.max(newOffset.x, -pageBounds.left) / this.currentZoom,\n                        ty: Math.max(newOffset.y, -pageBounds.top) / this.currentZoom,\n                        scale: this.currentZoom\n                    };\n                }\n            }\n            else if (newOffset && oldWidth === this.diagramWidth && oldHeight === this.diagramHeight &&\n                ((this.diagram.diagramCanvas.scrollHeight > this.viewPortHeight &&\n                    newOffset.y < 0 && this.horizontalOffset === newOffset.x && this.verticalOffset === 0) ||\n                    (this.diagram.diagramCanvas.scrollWidth > this.viewPortWidth &&\n                        newOffset.x < 0 && this.verticalOffset === newOffset.y && this.horizontalOffset === 0))) {\n                this.verticalOffset = newOffset.y;\n                this.horizontalOffset = newOffset.x;\n                this.transform = {\n                    tx: Math.max(newOffset.x, -pageBounds.left) / this.currentZoom,\n                    ty: Math.max(newOffset.y, -pageBounds.top) / this.currentZoom,\n                    scale: this.currentZoom\n                };\n            }\n        }\n        this.diagram.transformLayers();\n        this.diagram.element.style.overflow = 'hidden';\n    };\n    /**\n     * setViewPortSize \\\n     *\n     * @returns { void }     To get page pageBounds.\\\n     * @param {number} width - provide the factor value.\n     * @param {number} height - provide the factor value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.setViewPortSize = function (width, height) {\n        this.viewPortWidth = width;\n        this.viewPortHeight = height;\n    };\n    /**\n     * To get page pageBounds \\\n     *\n     * @returns { Rect }     To get page pageBounds.\\\n     * @param {boolean} boundingRect - provide the factor value.\n     * @param {DiagramRegions} region - provide the factor value.\n     * @param {boolean} hasPadding - provide the factor value.\n     * @param {boolean} isnegativeRegion - provide the isnegativeRegion value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.getPageBounds = function (boundingRect, region, hasPadding, isnegativeRegion) {\n        var rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect();\n        var temp = 0;\n        var pageBounds;\n        if (region !== 'Content' && !isnegativeRegion && this.diagram.pageSettings.width !== null && this.diagram.pageSettings.height !== null) {\n            var width = this.diagram.pageSettings.width;\n            var height = this.diagram.pageSettings.height;\n            var negwidth = 0;\n            var negheight = 0;\n            if (this.diagram.pageSettings.multiplePage) {\n                rect = this.diagram.spatialSearch.getPageBounds(0, 0);\n                if (rect.right > width) {\n                    var x = Math.ceil(rect.right / width);\n                    width = width * x;\n                }\n                if (rect.bottom > height) {\n                    var x = Math.ceil(rect.bottom / height);\n                    height = height * x;\n                }\n                if (rect.left < 0 && Math.abs(rect.left) > negwidth) {\n                    var x = Math.ceil(Math.abs(rect.left) / this.diagram.pageSettings.width);\n                    negwidth = this.diagram.pageSettings.width * x;\n                }\n                if (rect.top < 0 && Math.abs(rect.top) > negheight) {\n                    var x = Math.ceil(Math.abs(rect.top) / this.diagram.pageSettings.height);\n                    negheight = this.diagram.pageSettings.height * x;\n                }\n            }\n            pageBounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect((-negwidth), (-negheight), width + negwidth, height + negheight);\n        }\n        else {\n            var origin_1 = boundingRect ? undefined : 0;\n            pageBounds = this.diagram.spatialSearch.getPageBounds(origin_1, origin_1);\n        }\n        if (hasPadding) {\n            var scrollpadding = this.diagram.scrollSettings.padding;\n            pageBounds.x -= scrollpadding.left;\n            pageBounds.y -= scrollpadding.top;\n            pageBounds.width += (scrollpadding.left + scrollpadding.right);\n            pageBounds.height += (scrollpadding.top + scrollpadding.bottom);\n        }\n        return pageBounds;\n    };\n    /**\n     * To get page break when PageBreak is set as true \\\n     *\n     * @returns { Segment[] }     To get page break when PageBreak is set as true.\\\n     * @param {Rect} pageBounds - provide the factor value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.getPageBreak = function (pageBounds) {\n        var i = 0;\n        var j = 0;\n        var v = -1;\n        var collection = [];\n        var x1 = 0;\n        var x2 = 0;\n        var y1 = 0;\n        var y2 = 0;\n        var left = this.diagram.pageSettings.margin.left;\n        var right = this.diagram.pageSettings.margin.right;\n        var top = this.diagram.pageSettings.margin.top;\n        var bottom = this.diagram.pageSettings.margin.bottom;\n        var widthCount = 1;\n        var heightCount = 1;\n        var segment = { x1: x1, y1: y1, x2: x2, y2: y2 };\n        while (pageBounds.width > i) {\n            i = i + (this.diagram.pageSettings.width ? this.diagram.pageSettings.width : pageBounds.width);\n            if (i === this.diagram.pageSettings.width) {\n                segment = {\n                    x1: pageBounds.left + left, y1: pageBounds.top + top,\n                    x2: pageBounds.left + left, y2: pageBounds.bottom - bottom\n                };\n                collection[++v] = segment;\n            }\n            if (i < pageBounds.width) {\n                x1 = pageBounds.topLeft.x + this.diagram.pageSettings.width * widthCount;\n                y1 = pageBounds.topLeft.y + top;\n                x2 = pageBounds.bottomLeft.x + this.diagram.pageSettings.width * widthCount;\n                y2 = pageBounds.bottomLeft.y - bottom;\n                segment = { x1: x1, y1: y1, x2: x2, y2: y2 };\n                collection[++v] = segment;\n                widthCount++;\n            }\n            if (pageBounds.width === i) {\n                segment = {\n                    x1: pageBounds.right - right, y1: pageBounds.top + top,\n                    x2: pageBounds.right - right, y2: pageBounds.bottom - bottom\n                };\n                collection[++v] = segment;\n            }\n        }\n        while (pageBounds.height > j) {\n            j = j + (this.diagram.pageSettings.height ? this.diagram.pageSettings.height : pageBounds.height);\n            if (j === this.diagram.pageSettings.height) {\n                segment = {\n                    x1: pageBounds.left + left, y1: pageBounds.top + top,\n                    x2: pageBounds.right - right, y2: pageBounds.top + top\n                };\n                collection[++v] = segment;\n            }\n            if (j < pageBounds.height) {\n                x1 = pageBounds.topLeft.x + left;\n                y1 = pageBounds.topLeft.y + this.diagram.pageSettings.height * heightCount;\n                x2 = pageBounds.topRight.x - right;\n                y2 = pageBounds.topRight.y + this.diagram.pageSettings.height * heightCount;\n                segment = { x1: x1, y1: y1, x2: x2, y2: y2 };\n                collection[++v] = segment;\n                heightCount++;\n            }\n            if (pageBounds.height === j) {\n                segment = {\n                    x1: pageBounds.left + left, y1: pageBounds.bottom - bottom,\n                    x2: pageBounds.right - right, y2: pageBounds.bottom - bottom\n                };\n                collection[++v] = segment;\n            }\n        }\n        return collection;\n    };\n    /**\n     * zoom method \\\n     *\n     * @returns { void }     zoom method .\\\n     * @param {number} factor - provide the factor value.\n     * @param {number} deltaX - provide the bounds value.\n     * @param {number} deltaY - provide the bounds value.\n     * @param {PointModel} focusPoint - provide the bounds value.\n     * @param {boolean} isInteractiveZoomPan - provide the isInteractiveZoomPan value.\n     * @param {boolean} isBringIntoView - provide the isBringIntoView value.\n     * @param {boolean} isTrackpadScroll - provide the isTrackpadScroll value.\n     * @param {boolean} canZoomOut - provide the canZoomOut value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.zoom = function (factor, deltaX, deltaY, focusPoint, isInteractiveZoomPan, isBringIntoView, isTrackpadScroll, canZoomOut) {\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_4__.canZoom)(this.diagram) && factor !== 1 || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_4__.canPan)(this.diagram) && factor === 1)) {\n            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.identityMatrix)();\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.scaleMatrix)(matrix, this.currentZoom, this.currentZoom);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.translateMatrix)(matrix, this.horizontalOffset, this.verticalOffset);\n            focusPoint = focusPoint || {\n                x: (this.viewPortWidth / 2 - this.horizontalOffset) / this.currentZoom,\n                y: (this.viewPortHeight / 2 - this.verticalOffset) / this.currentZoom\n            };\n            focusPoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(matrix, focusPoint);\n            //Bug 853566: Fit to page is not working when zoom value less than minZoom.\n            // Removed minZoom calculation to call fitToPage even if currentZoom less than minZoom.\n            if ((this.currentZoom * factor) <= this.diagram.scrollSettings.maxZoom &&\n                ((this.currentZoom * factor) >= this.diagram.scrollSettings.minZoom || (canZoomOut || factor >= 1))) {\n                this.currentZoom *= factor;\n                var pageBounds = this.getPageBounds(undefined, undefined, true);\n                pageBounds.x *= this.currentZoom;\n                pageBounds.y *= this.currentZoom;\n                //target Matrix\n                var targetMatrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.identityMatrix)();\n                (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.scaleMatrix)(targetMatrix, factor, factor, focusPoint.x, focusPoint.y);\n                (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.translateMatrix)(targetMatrix, deltaX || 0, deltaY || 0);\n                (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplyMatrix)(matrix, targetMatrix);\n                var newOffset = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(matrix, { x: 0, y: 0 });\n                if (factor === 1) {\n                    // EJ2-69238 - add true as an extra parameter to calcuate the horizontal and vertical offset\n                    newOffset = this.applyScrollLimit(newOffset.x, newOffset.y, isInteractiveZoomPan, isBringIntoView, isTrackpadScroll);\n                }\n                // Bug 829925: Scroll bar flickers on scrolling the diagram using touchpad.\n                // The below condition is used to avoid the flickering of the scroll bar on scrolling the diagram using trackpad.\n                isTrackpadScroll = (-(pageBounds.y) >= newOffset.y && -(pageBounds.x) >= newOffset.x && isTrackpadScroll);\n                if ((this.diagram.scrollActions & _enum_enum__WEBPACK_IMPORTED_MODULE_1__.ScrollActions.PropertyChange ||\n                    !(this.diagram.scrollActions & _enum_enum__WEBPACK_IMPORTED_MODULE_1__.ScrollActions.Interaction)) ||\n                    this.diagram.scrollSettings.scrollLimit !== 'Diagram' || isTrackpadScroll) {\n                    this.transform = {\n                        tx: Math.max(newOffset.x, -pageBounds.left) / this.currentZoom,\n                        ty: Math.max(newOffset.y, -pageBounds.top) / this.currentZoom,\n                        scale: this.currentZoom\n                    };\n                    this.horizontalOffset = newOffset.x;\n                    this.verticalOffset = newOffset.y;\n                }\n                this.setSize(newOffset);\n                if (this.diagram.mode !== 'SVG' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_4__.canVitualize)(this.diagram)) {\n                    this.diagram.scroller.virtualizeElements();\n                }\n                if (this.diagram.mode !== 'SVG' && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_4__.canVitualize)(this.diagram)) {\n                    this.diagram.refreshDiagramLayer();\n                }\n                this.diagram.setOffset(-this.horizontalOffset - pageBounds.x, -this.verticalOffset - pageBounds.y);\n                (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_3__.updateRuler)(this.diagram);\n                //Bug 863516: Overview is not synced with diagram content while zoom-out the diagram.\n                //Updating overview after the page scrolled or zoomed.\n                if (this.diagram.views && this.diagram.views.overview) {\n                    var overview = this.diagram.views.overview;\n                    var bounds = overview.scrollOverviewRect(overview.parent.scroller.horizontalOffset, overview.parent.scroller.verticalOffset, overview.parent.scroller.currentZoom, true);\n                    overview.updateOverviewrect(-bounds.x, -bounds.y, bounds.width, bounds.height);\n                    overview.updateView(overview);\n                }\n            }\n        }\n    };\n    /**\n     * fitToPage method \\\n     *\n     * @returns { void }     fitToPage method .\\\n     * @param {IFitOptions} options - provide the bounds value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.fitToPage = function (options) {\n        options = options || {};\n        var mode = options.mode;\n        var region = options.region;\n        var margin = options.margin || {};\n        var canZoomIn = options.canZoomIn;\n        var customBounds = options.customBounds;\n        // Allows fitToPage when the currentZoom less than minZoom.\n        var canZoomOut = options.canZoomOut;\n        margin.bottom = margin.bottom || 25;\n        margin.top = margin.top || 25;\n        margin.left = margin.left || 25;\n        margin.right = margin.right || 25;\n        var bounds = customBounds;\n        var factor;\n        var deltaX = -this.horizontalOffset;\n        var deltaY = -this.verticalOffset;\n        region = region ? region : 'PageSettings';\n        //fit mode\n        if ((region === 'PageSettings' && this.diagram.pageSettings.width && this.diagram.pageSettings.height)\n            || (this.diagram.nodes.length > 0 || this.diagram.connectors.length > 0)) {\n            mode = mode ? mode : 'Page';\n            if (region !== 'CustomBounds') {\n                bounds = this.getPageBounds(true, region, true);\n            }\n            var scale = { x: 0, y: 0 };\n            //Bug 853566: Fit to page is not working when zoom value less than minZoom.\n            // Resetting margin value if the margin value is greater than the viewport size to avoid scale value in negative.\n            if ((margin.left + margin.right) > this.viewPortWidth) {\n                if (this.viewPortWidth <= 100) {\n                    margin.left = 5;\n                    margin.right = 5;\n                }\n                else {\n                    margin.left = 25;\n                    margin.right = 25;\n                }\n            }\n            if ((margin.top + margin.bottom) > this.viewPortHeight) {\n                if (this.viewPortHeight <= 100) {\n                    margin.top = 5;\n                    margin.bottom = 5;\n                }\n                else {\n                    margin.top = 25;\n                    margin.bottom = 25;\n                }\n            }\n            scale.x = (this.viewPortWidth - (margin.left + margin.right)) / (bounds.width);\n            scale.y = (this.viewPortHeight - (margin.top + margin.bottom)) / (bounds.height);\n            if (!canZoomIn && (((bounds.width - this.horizontalOffset) < this.viewPortWidth) &&\n                (bounds.height - this.verticalOffset) < this.viewPortHeight)) {\n                scale.x = Math.min(this.currentZoom, scale.x);\n                scale.y = Math.min(this.currentZoom, scale.y);\n            }\n            var zoomFactor = void 0;\n            var centerX = void 0;\n            var centerY = void 0;\n            switch (mode) {\n                case 'Width':\n                    zoomFactor = scale.x;\n                    factor = zoomFactor / this.currentZoom;\n                    centerX = (this.viewPortWidth - (bounds.width) * zoomFactor) / 2 - bounds.x * zoomFactor;\n                    deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;\n                    deltaY -= -this.verticalOffset * factor;\n                    deltaY = region !== 'CustomBounds' ? deltaY : deltaY - this.verticalOffset * factor;\n                    break;\n                case 'Height':\n                    zoomFactor = scale.y;\n                    factor = (zoomFactor / this.currentZoom);\n                    centerX = ((this.viewPortWidth - (bounds.width) * zoomFactor) / 2) - bounds.x * zoomFactor;\n                    centerY = ((this.viewPortHeight - (bounds.height) * zoomFactor) / 2) - bounds.y * zoomFactor;\n                    deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;\n                    deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;\n                    break;\n                case 'Page':\n                    zoomFactor = Math.min(scale.x, scale.y);\n                    factor = (zoomFactor / this.currentZoom);\n                    centerX = (this.viewPortWidth - (bounds.width) * zoomFactor) / 2 - bounds.x * zoomFactor;\n                    centerY = (this.viewPortHeight - (bounds.height) * zoomFactor) / 2 - bounds.y * zoomFactor;\n                    deltaX += centerX + (margin.left - margin.right) / 2 * zoomFactor;\n                    deltaY += centerY + (margin.top - margin.bottom) / 2 * zoomFactor;\n                    break;\n            }\n            /**\n             * EJ2-62912 - fit to page is not working properly when call it multiple times.\n             */\n            this.zoom(factor, deltaX, deltaY, { x: 0, y: 0 }, true, undefined, undefined, canZoomOut);\n        }\n        else {\n            factor = 1 / this.currentZoom;\n            this.zoom(factor, deltaX, deltaY, { x: 0, y: 0 }, true, undefined, undefined, canZoomOut);\n        }\n    };\n    /**\n     * bringIntoView method \\\n     *\n     * @returns { void }     bringIntoView method .\\\n     * @param {Rect} rect - provide the bounds value.\n     * @param {boolean} isBringIntoView - provide the isBringIntoView value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.bringIntoView = function (rect, isBringIntoView) {\n        // EJ2-68130-Bringintoview shows the object outside the viewport\n        var x = 0;\n        var y = 0;\n        var scale = this.currentZoom;\n        var bounds = rect;\n        var hoffset = -this.horizontalOffset;\n        var voffset = -this.verticalOffset;\n        bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(bounds.x * scale, bounds.y * scale, bounds.width * scale, bounds.height * scale);\n        var view = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(hoffset, voffset, this.viewPortWidth, this.viewPortHeight);\n        //To prevent nodes from being cut off in the horizontal and vertical scrollbars when calling the \"bring into view\" function, a padding value is added.\n        var nodePadding = 20;\n        if (!(view.containsRect(bounds))) {\n            if (bounds.right > (-hoffset + this.viewPortWidth)) {\n                x = bounds.right - this.viewPortWidth;\n                x += nodePadding;\n            }\n            if (bounds.x < -hoffset) {\n                x = bounds.x;\n            }\n            if (bounds.bottom > (-voffset + this.viewPortHeight)) {\n                y = bounds.bottom - this.viewPortHeight;\n                y += nodePadding;\n            }\n            if (bounds.y < -voffset) {\n                y = bounds.y;\n            }\n            this.zoom(1, -this.horizontalOffset - x, -this.verticalOffset - y, null, undefined, isBringIntoView);\n        }\n    };\n    /**\n     * bringToCenter method \\\n     *\n     * @returns { void }     bringToCenter method .\\\n     * @param {Rect} bounds - provide the bounds value.\n     *\n     * @private\n     */\n    DiagramScroller.prototype.bringToCenter = function (bounds) {\n        var scale = this.currentZoom;\n        var actualbounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(bounds.x * scale, bounds.y * scale, bounds.width * scale, bounds.height * scale);\n        var hoffset = actualbounds.x + actualbounds.width / 2 - this.viewPortWidth / 2;\n        var voffset = actualbounds.y + actualbounds.height / 2 - this.viewPortHeight / 2;\n        /**\n         * In applyScrollLimit method the sign of deltaX and deltaY\n         * will be changed ,so here we change the sign.\n         * similarly for bringIntoView.\n         */\n        hoffset *= -1;\n        voffset *= -1;\n        this.zoom(1, -this.horizontalOffset - hoffset, -this.verticalOffset - voffset, null);\n    };\n    DiagramScroller.prototype.applyScrollLimit = function (hOffset, vOffset, isInteractiveZoomPan, isBringIntoView, isTrackpadScroll) {\n        /**\n         * EJ2-60980- ScrollOffset is not updated properly in runtime.\n         * EJ2-62524 - panning is not working properly in diagram.\n         * isInteractiveZoomPan is undefined while setting scrollOffset at runtime.\n         */\n        if (this.diagram.scrollSettings.scrollLimit === 'Infinity') {\n            if (isInteractiveZoomPan === undefined && !isBringIntoView) {\n                hOffset = -hOffset;\n                vOffset = -vOffset;\n            }\n        }\n        if (this.diagram.scrollSettings.scrollLimit !== 'Infinity') {\n            var bounds = void 0;\n            if (this.diagram.scrollSettings.scrollLimit === 'Limited') {\n                var scrollableBounds = this.diagram.scrollSettings.scrollableArea;\n                bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(scrollableBounds.x, scrollableBounds.y, scrollableBounds.width, scrollableBounds.height);\n            }\n            // Bug 829925: Scroll bar flickers on scrolling the diagram using touchpad.\n            // Added below code to get the page bounds based on the scroll.\n            bounds = bounds || (isTrackpadScroll ? this.getPageBounds(false, undefined, true) : this.getPageBounds(true, undefined, true));\n            // 939223: Unable to Pan to the Extreme End of the Diagram When Scroll Padding is Applied\n            var eventHandler = 'eventHandler';\n            if (this.diagram[\"\" + eventHandler].currentAction === 'Pan' && this.diagram[\"\" + eventHandler].inAction) {\n                bounds = this.getPageBounds(false, undefined, true);\n            }\n            bounds.x *= this.currentZoom;\n            bounds.y *= this.currentZoom;\n            bounds.width *= this.currentZoom;\n            bounds.height *= this.currentZoom;\n            if (isInteractiveZoomPan !== undefined) {\n                hOffset *= -1;\n                vOffset *= -1;\n            }\n            // EJ2-69238 - Added below code to multiple the horizontal and vertical offset to bring the node in viewport\n            if (isBringIntoView) {\n                hOffset *= -1;\n                vOffset *= -1;\n            }\n            var allowedRight = Math.max(bounds.right, this.viewPortWidth);\n            if (!isBringIntoView && !(hOffset <= bounds.x && (hOffset + this.viewPortWidth >= bounds.right ||\n                hOffset >= bounds.right - this.viewPortWidth)\n                || hOffset >= bounds.x && (hOffset + this.viewPortWidth <= allowedRight))) {\n                //not allowed case\n                if (hOffset >= bounds.x) {\n                    hOffset = Math.max(bounds.x, Math.min(hOffset, hOffset - (hOffset + this.viewPortWidth - this.vScrollSize - allowedRight)));\n                }\n                else {\n                    var allowed = bounds.right - this.viewPortWidth;\n                    hOffset = Math.min(allowed, bounds.x);\n                }\n            }\n            var allowedBottom = Math.max(bounds.bottom, this.viewPortHeight);\n            // EJ2-69238 - Added below code to restrict the min value calculation for vertical offset in bringIntoview scenarion.\n            if (!isBringIntoView && !(vOffset <= bounds.y && vOffset + this.viewPortHeight >= bounds.bottom\n                || vOffset >= bounds.y && vOffset + this.viewPortHeight <= allowedBottom)) {\n                //not allowed case\n                if (vOffset >= bounds.y) {\n                    vOffset = Math.max(bounds.y, Math.min(vOffset, vOffset - (vOffset + this.viewPortHeight - this.hScrollSize - allowedBottom)));\n                }\n                else {\n                    var allowed = bounds.bottom - this.viewPortHeight;\n                    vOffset = Math.min(bounds.y, allowed);\n                }\n            }\n            hOffset *= -1;\n            vOffset *= -1;\n        }\n        return { x: hOffset, y: vOffset };\n    };\n    return DiagramScroller;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/scroller.js?");

/***/ })

}]);