"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_user-interaction_crosshair_js-94fbe6f7"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/crosshair.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/crosshair.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Crosshair: () => (/* binding */ Crosshair)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _chart_utils_get_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chart/utils/get-data */ \"./node_modules/@syncfusion/ej2-charts/src/chart/utils/get-data.js\");\n\n\n\n\n/**\n * The `Crosshair` module is used to render the crosshair for the chart.\n */\nvar Crosshair = /** @class */ (function () {\n    /**\n     * Constructor for crosshair module.\n     *\n     * @private\n     */\n    function Crosshair(chart) {\n        this.arrowLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(0, 0);\n        this.rx = 2;\n        this.ry = 2;\n        this.highlightWidth = 0;\n        this.crosshairLeftOverflow = 0;\n        this.crosshairRightOverflow = 0;\n        this.chart = chart;\n        this.elementID = this.chart.element.id;\n        this.svgRenderer = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.SvgRenderer(this.chart.element.id);\n        if (this.chart.crosshair.snapToData || this.chart.crosshair.highlightCategory) {\n            this.data = new _chart_utils_get_data__WEBPACK_IMPORTED_MODULE_3__.ChartData(this.chart);\n        }\n        this.addEventListener();\n    }\n    /**\n     * Adds event listeners to the chart elements.\n     *\n     * @private\n     * @returns {void}\n     */\n    Crosshair.prototype.addEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        var cancelEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer ? 'pointerleave' : 'mouseleave';\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMoveHandler, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseUpHandler, this);\n        this.chart.on(cancelEvent, this.mouseLeaveHandler, this);\n        this.chart.on('tapHold', this.longPress, this);\n    };\n    Crosshair.prototype.mouseUpHandler = function () {\n        if (this.chart.startMove) {\n            this.removeCrosshair(2000);\n        }\n    };\n    Crosshair.prototype.mouseLeaveHandler = function () {\n        this.removeCrosshair(1000);\n    };\n    Crosshair.prototype.mouseMoveHandler = function (event) {\n        var chart = this.chart;\n        if (chart.stockChart && chart.stockChart.onPanning) {\n            if (chart.mouseY < chart.chartAxisLayoutPanel.seriesClipRect.y) {\n                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y;\n            }\n            else if (chart.mouseY > chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height) {\n                chart.mouseY = chart.chartAxisLayoutPanel.seriesClipRect.y + chart.chartAxisLayoutPanel.seriesClipRect.height;\n            }\n        }\n        if (event.type === 'touchmove' && (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIos || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIos7) && chart.startMove && event.preventDefault) {\n            event.preventDefault();\n        }\n        // Tooltip for chart series.\n        if (!chart.disableTrackTooltip) {\n            if (chart.crosshair.enable && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n                if (chart.startMove || !chart.isTouch) {\n                    this.crosshair();\n                }\n            }\n            else {\n                this.removeCrosshair(1000);\n            }\n        }\n    };\n    /**\n     * Handles the long press on chart.\n     *\n     * @returns {boolean} false\n     * @private\n     */\n    Crosshair.prototype.longPress = function () {\n        var chart = this.chart;\n        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n            this.crosshair();\n        }\n        return false;\n    };\n    /**\n     * Finds the data points closest to the mouse position for all visible series in the chart.\n     * Updates the `data` object with the nearest data point to be used for mouse interactions.\n     *\n     * @param {Chart} chart - The chart instance containing the visible series and mouse position.\n     * @returns {boolean} -  True if chart has atleast one visible series.\n     * @private\n     */\n    Crosshair.prototype.findMousePoints = function (chart) {\n        var data = this.data.getData();\n        var pointLocations = [];\n        var axisCoordinate = chart.isTransposed ? 'x' : 'y';\n        var nearestDataPoint = null;\n        var nearestValue = null;\n        var minDifference = Infinity; // For finding the nearest value\n        var mouseCoordinate = axisCoordinate === 'x' ? chart.mouseX : chart.mouseY;\n        var seriesVisibility = false;\n        var commonXvalues = this.data.mergeXvalues(this.chart.visibleSeries);\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n            var series = _a[_i];\n            seriesVisibility = seriesVisibility ? seriesVisibility : series.visible;\n            if (series.visible && series.category !== 'TrendLine') {\n                // Get the closest X value and store the data point\n                var closestData = this.data.getClosestX(chart, series, commonXvalues) || data;\n                if (closestData && closestData.point && closestData.point.symbolLocations[0]) {\n                    var pointLocation = closestData.point.symbolLocations[0][axisCoordinate] +\n                        closestData.series.clipRect[axisCoordinate];\n                    if (chart.crosshair.snapToData || chart.crosshair.highlightCategory) {\n                        pointLocations.push(pointLocation); // Store point locations for nearest calculation\n                        // Calculate the nearest point to the mouse\n                        var difference = Math.abs(pointLocation - mouseCoordinate);\n                        if (difference < minDifference) {\n                            minDifference = difference;\n                            nearestValue = pointLocation;\n                            nearestDataPoint = closestData;\n                        }\n                    }\n                }\n            }\n        }\n        // Use the nearest data point\n        if ((chart.crosshair.snapToData || chart.crosshair.highlightCategory) && nearestDataPoint) {\n            data = nearestDataPoint;\n            chart.crosshairModule.highlightWidth = 0;\n            if (chart.crosshair.highlightCategory && data.series.xAxis.valueType === 'Category') {\n                var clipRectSize = chart.isTransposed || chart.requireInvertedAxis ?\n                    chart.chartAxisLayoutPanel.seriesClipRect.height : chart.chartAxisLayoutPanel.seriesClipRect.width;\n                var highlightCategoryWidth = clipRectSize / data.series.xAxis.visibleRange.delta;\n                var pointRelativePosition = (data.point.xValue - data.series.xAxis.visibleRange.min) /\n                    (data.series.xAxis.visibleRange.max - data.series.xAxis.visibleRange.min);\n                chart.crosshairModule.crosshairLeftOverflow = Math.max(0, (highlightCategoryWidth / 2) -\n                    pointRelativePosition * clipRectSize);\n                chart.crosshairModule.crosshairRightOverflow = Math.max(0, (pointRelativePosition * clipRectSize +\n                    (highlightCategoryWidth / 2)) - clipRectSize);\n                chart.crosshairModule.highlightWidth = Math.max(0, highlightCategoryWidth - chart.crosshairModule.crosshairLeftOverflow -\n                    chart.crosshairModule.crosshairRightOverflow);\n            }\n        }\n        if (data && data.point) {\n            this.data.findMouseValues(data, chart, this);\n        }\n        return seriesVisibility;\n    };\n    /**\n     * Renders the crosshair.\n     *\n     * @returns {void}\n     * @private\n     */\n    Crosshair.prototype.crosshair = function () {\n        var visibleSeriesLength = this.chart.series.filter(function (series) { return series.visible; }).length;\n        var seriesVisible = true;\n        if (this.chart.crosshair.snapToData || this.chart.crosshair.highlightCategory) {\n            seriesVisible = this.findMousePoints(this.chart);\n        }\n        var chart = this.chart;\n        var horizontalCross = '';\n        var verticalCross = '';\n        var options;\n        var axisTooltipGroup = document.getElementById(this.elementID + '_crosshair_axis');\n        var crosshair = chart.crosshair;\n        var tooltipdiv = document.getElementById(this.elementID + '_tooltip');\n        var chartRect = chart.chartAxisLayoutPanel.seriesClipRect;\n        var crossGroup = chart.enableCanvas ? document.getElementById(this.elementID + '_Secondary_Element') :\n            document.getElementById(this.elementID + '_UserInteraction');\n        var crosshairsvg;\n        var cross = document.getElementById(this.elementID + '_Crosshair');\n        if (chart.enableCanvas) {\n            if (!cross) {\n                cross = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n                    id: this.elementID + '_Crosshair', styles: 'position: absolute; pointer-events: none'\n                });\n                crossGroup.appendChild(cross);\n            }\n        }\n        this.stopAnimation();\n        if (visibleSeriesLength === 0 || (chart.crosshair.snapToData && this.valueY === undefined) ||\n            chart.isCrosshair && chart.tooltip.enable && chart.tooltipModule &&\n                !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(chart.tooltipModule.valueX, chart.tooltipModule.valueY, chartRect) ||\n            (chart.crosshair.snapToData && !seriesVisible)) {\n            return null;\n        }\n        this.valueX = chart.crosshair.snapToData || chart.crosshair.highlightCategory ? this.valueX :\n            (chart.tooltip.enable && chart.tooltipModule && chart.tooltipModule.valueX ? chart.tooltipModule.valueX : chart.mouseX);\n        this.valueY = chart.crosshair.snapToData || chart.crosshair.highlightCategory ? this.valueY :\n            (chart.tooltip.enable && chart.tooltipModule && chart.tooltipModule.valueY ? chart.tooltipModule.valueY : chart.mouseY);\n        if (!chart.enableCanvas) {\n            crossGroup.setAttribute('opacity', '1');\n        }\n        if (crosshair.lineType === 'Both' || crosshair.lineType === 'Horizontal') {\n            if ((chart.crosshair.highlightCategory && this.highlightWidth !== 0) && (chart.isTransposed || chart.requireInvertedAxis)) {\n                var crosshairHighlightWidth = this.highlightWidth;\n                chart.crosshairModule.valueY = this.adjustCrosshairPositionForOverflow(this.valueY, true, chart);\n                var y = this.valueY - (crosshairHighlightWidth / 2);\n                horizontalCross = 'M ' + chartRect.x + ' ' + y +\n                    ' L ' + (chartRect.x + chartRect.width) + ' ' + y +\n                    ' L ' + (chartRect.x + chartRect.width) + ' ' + (y + crosshairHighlightWidth) +\n                    ' L ' + chartRect.x + ' ' + (y + crosshairHighlightWidth) + ' Z';\n            }\n            else {\n                horizontalCross += 'M ' + chartRect.x + ' ' + this.valueY +\n                    ' L ' + (chartRect.x + chartRect.width) + ' ' + this.valueY;\n            }\n        }\n        if (crosshair.lineType === 'Both' || crosshair.lineType === 'Vertical') {\n            if ((chart.crosshair.highlightCategory && this.highlightWidth !== 0) && !chart.requireInvertedAxis) {\n                var crosshairHighlightWidth = this.highlightWidth;\n                chart.crosshairModule.valueX = this.adjustCrosshairPositionForOverflow(this.valueX, false, chart);\n                var x = this.valueX - (crosshairHighlightWidth / 2);\n                verticalCross = 'M ' + x + ' ' + chartRect.y +\n                    ' L ' + (x + crosshairHighlightWidth) + ' ' + chartRect.y +\n                    ' L ' + (x + crosshairHighlightWidth) + ' ' + (chartRect.y + chartRect.height) +\n                    ' L ' + x + ' ' + (chartRect.y + chartRect.height) + ' Z';\n            }\n            else {\n                verticalCross += 'M ' + this.valueX + ' ' + chartRect.y +\n                    ' L ' + this.valueX + ' ' + (chartRect.y + chartRect.height);\n            }\n        }\n        if (chart.enableCanvas) {\n            if (!axisTooltipGroup) {\n                axisTooltipGroup = this.svgRenderer.createGroup({ 'id': this.elementID + '_crosshair_axis' });\n            }\n            var elementID = chart.tooltip.enable ? chart.element.id + '_tooltip_svg' : chart.element.id + '_svg';\n            crosshairsvg = this.svgRenderer.createSvg({\n                id: elementID,\n                width: chart.availableSize.width,\n                height: chart.availableSize.height\n            });\n            if (chart.tooltip.enable) {\n                tooltipdiv = !tooltipdiv ? chart.tooltipModule.createElement() : tooltipdiv;\n                tooltipdiv.appendChild(crosshairsvg);\n                crossGroup.appendChild(tooltipdiv);\n            }\n            options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.elementID + '_HorizontalLine', 'none', crosshair.line.width, crosshair.horizontalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, (chart.theme.indexOf('Bootstrap5') > -1 || chart.theme === 'Fluent2HighContrast' || chart.theme.indexOf('Tailwind3') > -1) ? crosshair.dashArray || '2.5' : crosshair.dashArray, horizontalCross);\n            this.drawCrosshairLine(options, cross, chartRect.x, this.valueY, chartRect.width, 0, horizontalCross);\n            /**\n             * due to not working for vertical line side I added new option\n             * options.d = verticalCross; options.id = this.elementID + '_VerticalLine';\n             */\n            options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.elementID + '_VerticalLine', 'none', crosshair.line.width, crosshair.verticalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, (chart.theme.indexOf('Bootstrap5') > -1 || chart.theme === 'Fluent2HighContrast' || chart.theme.indexOf('Tailwind3') > -1) ? crosshair.dashArray || '2.5' : crosshair.dashArray, verticalCross);\n            this.drawCrosshairLine(options, cross, this.valueX, chartRect.y, 0, chartRect.height, verticalCross);\n            this.renderAxisTooltip(chart, chartRect, axisTooltipGroup);\n            crosshairsvg.appendChild(axisTooltipGroup);\n            if (!chart.tooltip.enable) {\n                cross.appendChild(crosshairsvg);\n            }\n        }\n        else {\n            if (crossGroup.childNodes.length === 0) {\n                var horizontalHighlight = (chart.crosshair.highlightCategory && this.highlightWidth !== 0) &&\n                    (chart.isTransposed || chart.requireInvertedAxis);\n                var verticalHighlight = (chart.crosshair.highlightCategory && this.highlightWidth !== 0) &&\n                    !chart.requireInvertedAxis;\n                axisTooltipGroup = chart.renderer.createGroup({ 'id': this.elementID + '_crosshair_axis' });\n                options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.elementID + '_HorizontalLine', horizontalHighlight ? (crosshair.horizontalLineColor || crosshair.line.color) ? this.crosshairLightenColor(crosshair.horizontalLineColor || crosshair.line.color) : chart.themeStyle.crosshairBackground : 'none', horizontalHighlight ? 0 : crosshair.line.width, horizontalHighlight ? 'none' : crosshair.horizontalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, horizontalHighlight ? null : (chart.theme.indexOf('Bootstrap5') > -1 || chart.theme === 'Fluent2HighContrast' || chart.theme.indexOf('Tailwind3') > -1) ? crosshair.dashArray || '2.5' : crosshair.dashArray, horizontalCross);\n                this.renderCrosshairLine(options, crossGroup);\n                options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.PathOption(this.elementID + '_VerticalLine', verticalHighlight ? (crosshair.verticalLineColor || crosshair.line.color) ? this.crosshairLightenColor(crosshair.verticalLineColor || crosshair.line.color) : chart.themeStyle.crosshairBackground : 'none', verticalHighlight ? 0 : crosshair.line.width, verticalHighlight ? 'none' : crosshair.verticalLineColor || crosshair.line.color || chart.themeStyle.crosshairLine, crosshair.opacity, verticalHighlight ? null : (chart.theme.indexOf('Bootstrap5') > -1 || chart.theme === 'Fluent2HighContrast' || chart.theme.indexOf('Tailwind3') > -1) ? crosshair.dashArray || '2.5' : crosshair.dashArray, verticalCross);\n                this.renderCrosshairLine(options, crossGroup);\n                crossGroup.appendChild(axisTooltipGroup);\n                this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);\n            }\n            else {\n                document.getElementById(this.elementID + '_HorizontalLine').setAttribute('d', horizontalCross);\n                document.getElementById(this.elementID + '_VerticalLine').setAttribute('d', verticalCross);\n                this.renderAxisTooltip(chart, chartRect, crossGroup.lastChild);\n            }\n        }\n    };\n    /**\n     * Converts a specified color into a semi-transparent RGB string format.\n     *\n     * @param {string} color - The main color in hex format.\n     * @returns {string} - The lightened color in RGBA format with an alpha value of 0.25.\n     */\n    Crosshair.prototype.crosshairLightenColor = function (color) {\n        var rgbValue = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.convertHexToColor)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.colorNameToHex)(color));\n        return 'rgb(' + rgbValue.r + ',' + rgbValue.g + ',' + rgbValue.b + ',' + 0.25 + ')';\n    };\n    /**\n     * Adjusts the crosshair position to account for any overflow beyond the chart boundaries,\n     * ensuring it stays within visible limits. It handles horizontal and vertical orientations separately.\n     *\n     * @param {number} initialPosition - The initial calculated position of the crosshair before adjustments.\n     * @param {boolean} isHorizontalOrientation - Determines whether the crosshair is oriented horizontally.\n     * @param {Chart} chart - The chart instance containing details on crosshair module and overflow values.\n     * @returns {number} - The adjusted position of the crosshair after accounting for boundary overflow.\n     * @private\n     */\n    Crosshair.prototype.adjustCrosshairPositionForOverflow = function (initialPosition, isHorizontalOrientation, chart) {\n        if (chart.crosshairModule.crosshairLeftOverflow > 0) {\n            initialPosition += isHorizontalOrientation ? -chart.crosshairModule.crosshairLeftOverflow / 2 :\n                chart.crosshairModule.crosshairLeftOverflow / 2;\n        }\n        if (chart.crosshairModule.crosshairRightOverflow > 0) {\n            initialPosition += isHorizontalOrientation ? chart.crosshairModule.crosshairRightOverflow / 2 :\n                -chart.crosshairModule.crosshairRightOverflow / 2;\n        }\n        return initialPosition;\n    };\n    Crosshair.prototype.renderCrosshairLine = function (options, crossGroup) {\n        var htmlObject = this.chart.renderer.drawPath(options);\n        crossGroup.appendChild(htmlObject);\n    };\n    Crosshair.prototype.drawCrosshairLine = function (options, crossGroup, left, top, width, height, direction) {\n        if (!document.getElementById(options.id) && direction) {\n            var line = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n                id: options.id\n            });\n            crossGroup.appendChild(line);\n        }\n        if (document.getElementById(options.id)) {\n            var style = 'top:' + top.toString() + 'px;' +\n                'left:' + left.toString() + 'px;' +\n                'width:' + width + 'px;' +\n                'height:' + height + 'px;' +\n                'fill:' + options.stroke + ';' +\n                'border: 0.5px solid ' + options.stroke + ';' +\n                'opacity: ' + options.opacity + ' ; ' +\n                'position: absolute';\n            var crosshairline = document.getElementById(options.id);\n            var crosshairtooltip = document.getElementById(this.elementID + '_crosshair_axis');\n            crosshairline.style.cssText = style;\n            crossGroup.style.opacity = '1';\n            if (crosshairtooltip) {\n                crosshairtooltip.style.opacity = '1';\n            }\n        }\n    };\n    Crosshair.prototype.renderAxisTooltip = function (chart, chartRect, axisGroup) {\n        var axis;\n        var text;\n        var rect;\n        var pathElement;\n        var textElem;\n        var options;\n        var padding = 5;\n        var direction;\n        var axisRect;\n        for (var k = 0, length_1 = chart.axisCollections.length; k < length_1; k++) {\n            axis = chart.axisCollections[k];\n            axisRect = !axis.placeNextToAxisLine ? axis.rect : axis.updatedRect;\n            if (axis.crosshairTooltip.enable) {\n                if (axisRect && ((this.valueX <= (axisRect.x + axisRect.width) && axisRect.x <= this.valueX) ||\n                    (this.valueY <= (axisRect.y + axisRect.height) && axisRect.y <= this.valueY))) {\n                    pathElement = document.getElementById(this.elementID + '_axis_tooltip_' + k);\n                    textElem = document.getElementById(this.elementID + '_axis_tooltip_text_' + k);\n                    text = this.getAxisText(axis);\n                    if (text && text.indexOf('<br') > -1) {\n                        text = this.getAxisText(axis).split(/<br.*?>/g);\n                    }\n                    if (!text) {\n                        continue;\n                    }\n                    rect = this.tooltipLocation(text, axis, chartRect, axisRect);\n                    if (rect.y + rect.height / 2 > chart.availableSize.height || rect.y < 0) {\n                        continue;\n                    }\n                    if (pathElement === null) {\n                        if (chart.enableCanvas) {\n                            pathElement = this.svgRenderer.drawPath({\n                                'id': this.elementID + '_axis_tooltip_' + k,\n                                'fill': axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill\n                            });\n                        }\n                        else {\n                            pathElement = chart.renderer.drawPath({\n                                'id': this.elementID + '_axis_tooltip_' + k,\n                                'fill': axis.crosshairTooltip.fill || chart.themeStyle.crosshairFill\n                            }, null);\n                        }\n                        axisGroup.appendChild(pathElement);\n                        options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.TextOption(this.elementID + '_axis_tooltip_text_' + k, 0, 0, (chart.stockChart && chart.enableRtl) ? 'end' : 'start', text);\n                        var render = chart.enableCanvas ? this.svgRenderer : chart.renderer;\n                        textElem = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.textElement)(render, options, axis.crosshairTooltip.textStyle, axis.crosshairTooltip.textStyle.color || chart.themeStyle.crosshairLabelFont.color, axisGroup, null, null, null, null, null, null, null, null, chart.enableCanvas, null, this.chart.themeStyle.crosshairLabelFont);\n                    }\n                    direction = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.findCrosshairDirection)(this.rx, this.ry, rect, this.arrowLocation, 9, this.isTop, this.isBottom, this.isLeft, this.valueX, this.valueY);\n                    pathElement.setAttribute('d', direction);\n                    if (typeof text !== 'string' && text.length > 1) {\n                        for (var i = 0; i < text.length; i++) {\n                            textElem.childNodes[i].textContent = text[i];\n                        }\n                    }\n                    else {\n                        textElem.textContent = text;\n                    }\n                    textElem.setAttribute('x', (rect.x + padding + (chart.enableRtl ? this.elementSize.width : 0)).toString());\n                    textElem.setAttribute('y', (rect.y + padding + 3 * this.elementSize.height / 4).toString());\n                    var shadowId = this.chart.element.id + '_shadow';\n                    if (typeof text !== 'string' && text.length > 1) {\n                        var height = 0;\n                        textElem.setAttribute('y', (rect.y + padding + 3 * this.elementSize.height / (4 * text.length)).toString());\n                        for (var i = 0; i < textElem.children.length; i++) {\n                            height += this.elementSize.height / text.length;\n                            textElem.children[i].setAttribute('x', (rect.x + padding + (chart.enableRtl ? this.elementSize.width : 0) + this.elementSize.width / 2).toString());\n                            textElem.children[i].setAttribute('y', ((parseInt(textElem.getAttribute('y'), 10) + height).toString()));\n                            textElem.children[i].style.textAnchor = 'middle';\n                        }\n                    }\n                    if (this.chart.theme === 'Fluent' || this.chart.theme === 'FluentDark' || this.chart.theme === 'Fabric' || this.chart.theme === 'FabricDark' || this.chart.theme === 'Fluent2HighContrast') {\n                        var defElement = this.chart.renderer.createDefs();\n                        var bordercolor = this.chart.theme === 'Fluent' || this.chart.theme === 'Fabric' ? '#D2D0CE' : this.chart.theme === 'Fluent2HighContrast' ? '#FFFFFF' : null;\n                        var borderwidth = this.chart.theme === 'Fluent' || this.chart.theme === 'Fabric' || this.chart.theme === 'Fluent2HighContrast' ? 1 : null;\n                        defElement.setAttribute('id', this.chart.element.id + 'SVG_tooltip_definition');\n                        axisGroup.appendChild(defElement);\n                        pathElement.setAttribute('stroke', bordercolor);\n                        pathElement.setAttribute('stroke-width', ' ' + borderwidth);\n                    }\n                    else if (this.chart.theme.indexOf('Fluent2') > -1) {\n                        pathElement.setAttribute('box-shadow', '0px 1.6px 3.6px 0px #00000021, 0px 0.3px 0.9px 0px #0000001A');\n                        pathElement.setAttribute('filter', _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIE ? '' : 'url(#' + shadowId + ')');\n                        var shadow = '<filter id=\"' + shadowId + '\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"3\"/>';\n                        shadow += '<feOffset dx=\"-1\" dy=\"3.6\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"0.2\"/>';\n                        shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n                        var defElement = this.chart.renderer.createDefs();\n                        defElement.setAttribute('id', this.chart.element.id + 'SVG_tooltip_definition');\n                        pathElement.appendChild(defElement);\n                        defElement.innerHTML = shadow;\n                    }\n                }\n                else {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(this.elementID + '_axis_tooltip_' + k);\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(this.elementID + '_axis_tooltip_text_' + k);\n                }\n            }\n        }\n    };\n    Crosshair.prototype.getAxisText = function (axis) {\n        var value;\n        this.isBottom = false;\n        this.isTop = false;\n        this.isLeft = false;\n        this.isRight = false;\n        var labelValue = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks')\n            ? 0.5 : 0;\n        var isOpposed = axis.isAxisOpposedPosition;\n        if (axis.orientation === 'Horizontal') {\n            value = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getValueXByPoint)(Math.abs(this.valueX - axis.rect.x), axis.rect.width, axis) + labelValue;\n            this.isBottom = !isOpposed;\n            this.isTop = isOpposed;\n        }\n        else {\n            value = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getValueYByPoint)(Math.abs(this.valueY - axis.rect.y), axis.rect.height, axis) + labelValue;\n            this.isRight = isOpposed;\n            this.isLeft = !isOpposed;\n        }\n        if (axis.valueType === 'DateTime') {\n            return axis.format(new Date(value));\n        }\n        else if (axis.valueType === 'Category') {\n            return axis.labels[Math.floor(value)];\n        }\n        else if (axis.valueType === 'DateTimeCategory') {\n            return this.chart.dateTimeCategoryModule.getIndexedAxisLabel(axis.labels[Math.round(value)], axis.format);\n        }\n        else if (axis.valueType === 'Logarithmic') {\n            return value = axis.format(Math.pow(axis.logBase, value));\n        }\n        else {\n            var customLabelFormat = axis.labelFormat && axis.labelFormat.match('{value}') !== null;\n            return customLabelFormat ? axis.labelFormat.replace('{value}', axis.format(value)) : axis.format(value);\n        }\n    };\n    Crosshair.prototype.tooltipLocation = function (text, axis, bounds, axisRect) {\n        var padding = 5;\n        var arrowPadding = 9;\n        var tooltipRect;\n        var boundsX = bounds.x;\n        var boundsY = bounds.y;\n        var islabelInside = axis.labelPosition === 'Inside';\n        var scrollBarHeight = axis.scrollbarSettings.enable || (axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject)\n            ? axis.scrollBarHeight : 0;\n        this.elementSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)(text, axis.crosshairTooltip.textStyle, this.chart.themeStyle.crosshairLabelFont);\n        if (typeof text !== 'string' && text.length > 1) {\n            this.elementSize.width = 0;\n            this.elementSize.height = 0;\n            for (var i = 0; i < text.length; i++) {\n                var size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)(text[i], axis.crosshairTooltip.textStyle, this.chart.themeStyle.crosshairLabelFont);\n                this.elementSize.height += size.height;\n                if (this.elementSize.width < size.width) {\n                    this.elementSize.width = size.width;\n                }\n            }\n        }\n        var isOpposed = axis.isAxisOpposedPosition;\n        if (axis.orientation === 'Horizontal') {\n            var yLocation = islabelInside ? axisRect.y - this.elementSize.height - (padding * 2 + arrowPadding) :\n                axisRect.y + scrollBarHeight;\n            var height = islabelInside ? axisRect.y - this.elementSize.height - arrowPadding : axisRect.y + arrowPadding;\n            this.arrowLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(this.valueX, yLocation);\n            tooltipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect((this.valueX - (this.elementSize.width / 2) - padding), height + (!islabelInside ? scrollBarHeight : 0), this.elementSize.width + padding * 2, this.elementSize.height + padding * 2);\n            if (isOpposed) {\n                tooltipRect.y = islabelInside ? axisRect.y : axisRect.y -\n                    (this.elementSize.height + padding * 2 + arrowPadding) - scrollBarHeight;\n            }\n            if (tooltipRect.x < boundsX) {\n                tooltipRect.x = boundsX;\n            }\n            if (tooltipRect.x + tooltipRect.width > boundsX + bounds.width) {\n                tooltipRect.x -= ((tooltipRect.x + tooltipRect.width) - (boundsX + bounds.width));\n            }\n            if (this.arrowLocation.x + arrowPadding / 2 > tooltipRect.x + tooltipRect.width - this.rx) {\n                this.arrowLocation.x = tooltipRect.x + tooltipRect.width - this.rx - arrowPadding;\n            }\n            if (this.arrowLocation.x - arrowPadding < tooltipRect.x + this.rx) {\n                this.arrowLocation.x = tooltipRect.x + this.rx + arrowPadding;\n            }\n        }\n        else {\n            scrollBarHeight = scrollBarHeight * (isOpposed ? 1 : -1);\n            this.arrowLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(axisRect.x, this.valueY);\n            var width = islabelInside ? axisRect.x - scrollBarHeight :\n                axisRect.x - (this.elementSize.width) - (padding * 2 + arrowPadding);\n            tooltipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(width + scrollBarHeight, this.valueY - (this.elementSize.height / 2) - padding, this.elementSize.width + (padding * 2), this.elementSize.height + padding * 2);\n            if (isOpposed) {\n                tooltipRect.x = islabelInside ? axisRect.x - this.elementSize.width - arrowPadding :\n                    axisRect.x + arrowPadding + scrollBarHeight;\n                if ((tooltipRect.x + tooltipRect.width) > this.chart.availableSize.width) {\n                    this.arrowLocation.x -= ((tooltipRect.x + tooltipRect.width) - this.chart.availableSize.width);\n                    tooltipRect.x -= ((tooltipRect.x + tooltipRect.width) - this.chart.availableSize.width);\n                }\n            }\n            else {\n                if (tooltipRect.x < 0) {\n                    this.arrowLocation.x -= tooltipRect.x;\n                    tooltipRect.x = 0;\n                }\n            }\n            if (tooltipRect.y < boundsY) {\n                tooltipRect.y = boundsY;\n            }\n            if (tooltipRect.y + tooltipRect.height >= boundsY + bounds.height) {\n                tooltipRect.y -= ((tooltipRect.y + tooltipRect.height) - (boundsY + bounds.height));\n            }\n            if (this.arrowLocation.y + arrowPadding / 2 > tooltipRect.y + tooltipRect.height - this.ry) {\n                this.arrowLocation.y = tooltipRect.y + tooltipRect.height - this.ry - arrowPadding / 2;\n            }\n            if (this.arrowLocation.y - arrowPadding / 2 < tooltipRect.y + this.ry) {\n                this.arrowLocation.y = tooltipRect.y + this.ry + arrowPadding / 2;\n            }\n        }\n        return tooltipRect;\n    };\n    Crosshair.prototype.stopAnimation = function () {\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stopTimer)(this.crosshairInterval);\n    };\n    Crosshair.prototype.progressAnimation = function () {\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stopTimer)(this.crosshairInterval);\n    };\n    /**\n     * Removes the crosshair on mouse leave.\n     *\n     * @returns {void}\n     * @private\n     */\n    Crosshair.prototype.removeCrosshair = function (duration) {\n        var chart = this.chart;\n        var crosshair = chart.enableCanvas ? document.getElementById(this.elementID + '_Crosshair') :\n            document.getElementById(this.elementID + '_UserInteraction');\n        var crosshairtooltip = chart.enableCanvas ? document.getElementById(this.elementID + '_crosshair_axis') : null;\n        this.stopAnimation();\n        if (crosshair && crosshair.getAttribute('opacity') !== '0') {\n            this.crosshairInterval = +setTimeout(function () {\n                new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(crosshair, {\n                    duration: 200,\n                    progress: function (args) {\n                        // crosshair.removeAttribute('e-animate');\n                        crosshair.style.animation = '';\n                        if (!chart.enableCanvas) {\n                            crosshair.setAttribute('opacity', (1 - (args.timeStamp / args.duration)).toString());\n                        }\n                        else {\n                            crosshair.style.opacity = (1 - (args.timeStamp / args.duration)).toString();\n                            crosshairtooltip.style.opacity = (1 - (args.timeStamp / args.duration)).toString();\n                        }\n                    },\n                    end: function () {\n                        if (chart.enableCanvas) {\n                            crosshair.style.opacity = '0';\n                            crosshairtooltip.style.opacity = '0';\n                        }\n                        else {\n                            crosshair.setAttribute('opacity', '0');\n                        }\n                        chart.startMove = false;\n                        if (chart.tooltipModule) {\n                            chart.tooltipModule.valueX = null;\n                            chart.tooltipModule.valueY = null;\n                        }\n                    }\n                });\n            }, duration);\n        }\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} module name\n     */\n    Crosshair.prototype.getModuleName = function () {\n        /**\n         * Returns the module name.\n         */\n        return 'Crosshair';\n    };\n    /**\n     * To destroy the crosshair.\n     *\n     * @returns {void}\n     * @private\n     */\n    Crosshair.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    return Crosshair;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/crosshair.js?");

/***/ })

}]);