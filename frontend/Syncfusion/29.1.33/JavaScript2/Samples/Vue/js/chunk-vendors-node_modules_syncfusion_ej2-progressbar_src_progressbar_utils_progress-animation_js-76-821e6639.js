"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-progressbar_src_progressbar_utils_progress-animation_js-76-821e6639"],{

/***/ "./node_modules/@syncfusion/ej2-progressbar/src/progressbar/utils/progress-animation.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-progressbar/src/progressbar/utils/progress-animation.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProgressAnimation: () => (/* binding */ ProgressAnimation)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/helper */ \"./node_modules/@syncfusion/ej2-progressbar/src/progressbar/utils/helper.js\");\n/* harmony import */ var _model_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/constant */ \"./node_modules/@syncfusion/ej2-progressbar/src/progressbar/model/constant.js\");\n\n\n\n/**\n * Animation for progress bar\n */\nvar ProgressAnimation = /** @class */ (function () {\n    function ProgressAnimation() {\n    }\n    /**\n     * Performs linear animation on the specified element.\n     *\n     * @param {Element} element - The HTML element to animate.\n     * @param {ProgressBar} progress - The progress bar control.\n     * @param {number} delay - The delay before starting the animation, in milliseconds.\n     * @param {number} previousWidth - The previous width of the progress.\n     * @param {Element} active - The active element to control the animation.\n     * @returns {void}\n     */\n    ProgressAnimation.prototype.doLinearAnimation = function (element, progress, delay, previousWidth, active) {\n        var _this = this;\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var linearPath = element;\n        var duration = (progress.isActive) ? 3000 : progress.animation.duration;\n        var width = linearPath.getAttribute('width');\n        var x = linearPath.getAttribute('x');\n        var opacityValue = 0;\n        var value = 0;\n        var start = (!progress.enableRtl || (progress.cornerRadius === 'Round4px')) ? previousWidth : parseInt(x, 10);\n        var end = (!progress.enableRtl || (progress.cornerRadius === 'Round4px')) ? parseInt(width, 10) - start :\n            parseInt(width, 10) - previousWidth;\n        var rtlX = parseInt(x, 10) - end;\n        linearPath.style.visibility = 'hidden';\n        animation.animate(linearPath, {\n            duration: (progress.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 2000 : duration,\n            delay: delay,\n            progress: function (args) {\n                progress.cancelResize = true;\n                if (progress.enableRtl && !(progress.cornerRadius === 'Round4px')) {\n                    if (args.timeStamp >= args.delay) {\n                        linearPath.style.visibility = 'visible';\n                        if (progress.isActive) {\n                            value = _this.activeAnimate((args.timeStamp / args.duration), parseInt(x, 10), parseInt(width, 10), true);\n                            opacityValue = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, 0.5, 0.5, args.duration, true);\n                            active.setAttribute('opacity', opacityValue.toString());\n                            linearPath.setAttribute('x', value.toString());\n                        }\n                        else {\n                            value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, start, end, args.duration, true);\n                            linearPath.setAttribute('x', value.toString());\n                        }\n                    }\n                }\n                else {\n                    if (args.timeStamp >= args.delay) {\n                        linearPath.style.visibility = 'visible';\n                        if (progress.isActive) {\n                            value = _this.activeAnimate((args.timeStamp / args.duration), 0, parseInt(width, 10), false);\n                            opacityValue = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, 0.5, 0.5, args.duration, true);\n                            active.setAttribute('opacity', opacityValue.toString());\n                            linearPath.setAttribute('width', value.toString());\n                        }\n                        else {\n                            value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, start, end, args.duration, false);\n                            linearPath.setAttribute('width', value.toString());\n                        }\n                    }\n                }\n            },\n            end: function () {\n                progress.cancelResize = false;\n                linearPath.style.visibility = '';\n                if (progress.enableRtl && !(progress.cornerRadius === 'Round4px')) {\n                    if (progress.isActive) {\n                        linearPath.setAttribute('x', x.toString());\n                        _this.doLinearAnimation(element, progress, delay, previousWidth, active);\n                    }\n                    else {\n                        linearPath.setAttribute('x', rtlX.toString());\n                    }\n                }\n                else {\n                    linearPath.setAttribute('width', width);\n                    if (progress.isActive) {\n                        _this.doLinearAnimation(element, progress, delay, previousWidth, active);\n                    }\n                }\n                progress.trigger('animationComplete', {\n                    value: progress.value, trackColor: progress.trackColor,\n                    progressColor: progress.progressColor\n                });\n            }\n        });\n    };\n    /**\n     * Initiates linear animation for an indeterminate progress bar.\n     *\n     * @param {Element} element - The HTML element representing the progress bar.\n     * @param {number} progressWidth - The width of the progress bar.\n     * @param {number} thickness - The thickness of the progress bar.\n     * @param {ProgressBar} progress - The progress bar control.\n     * @param {Element} clipPath - The SVG clip path element to control the animation.\n     * @returns {void}\n     */\n    ProgressAnimation.prototype.doLinearIndeterminate = function (element, progressWidth, thickness, progress, clipPath) {\n        var _this = this;\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var linearPath = element;\n        var x = linearPath.getAttribute('x');\n        var width = linearPath.getAttribute('width');\n        var value = 0;\n        var start = (width) ? -(parseInt(width, 10)) : -progressWidth;\n        var end = (progress.progressRect.x + progress.progressRect.width) + ((width) ? (parseInt(width, 10)) : progressWidth);\n        var duration = (!progress.enableProgressSegments) ? progress.animation.duration : progress.animation.duration + 1000;\n        animation.animate(clipPath, {\n            duration: (progress.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 2000 : duration,\n            delay: 0,\n            progress: function (args) {\n                if (progress.enableRtl && !(progress.cornerRadius === 'Round4px')) {\n                    value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, parseInt(x, 10) || progress.progressRect.x + progressWidth, end, args.duration, true);\n                    if (!progress.enableProgressSegments) {\n                        linearPath.setAttribute('x', value.toString());\n                    }\n                    else {\n                        linearPath.setAttribute('d', progress.getPathLine(value, progressWidth, thickness));\n                    }\n                }\n                else {\n                    value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, start, end, args.duration, false);\n                    if (!progress.enableProgressSegments) {\n                        linearPath.setAttribute('x', value.toString());\n                    }\n                    else {\n                        linearPath.setAttribute('d', progress.getPathLine(value, progressWidth, thickness));\n                    }\n                }\n            },\n            end: function () {\n                if (progress.enableRtl && !progress.enableProgressSegments && !(progress.cornerRadius === 'Round4px')) {\n                    linearPath.setAttribute('x', x.toString());\n                }\n                else if (!progress.enableProgressSegments) {\n                    linearPath.setAttribute('x', start.toString());\n                }\n                if (!progress.destroyIndeterminate) {\n                    _this.doLinearIndeterminate(element, progressWidth, thickness, progress, clipPath);\n                }\n            }\n        });\n    };\n    /**\n     * Performs striped animation on the specified element.\n     *\n     * @param {Element} element - The HTML element to animate.\n     * @param {ProgressBar} progress - The progress bar object.\n     * @param {number} value - The value indicating the progress of the animation.\n     * @returns {void}\n     */\n    ProgressAnimation.prototype.doStripedAnimation = function (element, progress, value) {\n        var _this = this;\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var point = 1000 / progress.animation.duration;\n        animation.animate(element, {\n            duration: (progress.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 2000 : progress.animation.duration,\n            delay: progress.animation.delay,\n            progress: function () {\n                value += (progress.enableRtl) ? -point : point;\n                element.setAttribute('gradientTransform', 'translate(' + value + ') rotate(-45)');\n            },\n            end: function () {\n                if (!progress.destroyIndeterminate) {\n                    _this.doStripedAnimation(element, progress, value);\n                }\n            }\n        });\n    };\n    /**\n     * Initiates circular animation on the specified element.\n     *\n     * @param {number} x - The x-coordinate of the center of the circle.\n     * @param {number} y - The y-coordinate of the center of the circle.\n     * @param {number} radius - The radius of the circle.\n     * @param {number} progressEnd - The end value of the progress.\n     * @param {number} totalEnd - The total end value of the progress.\n     * @param {Element} element - The HTML element representing the circular progress.\n     * @param {ProgressBar} progress - The progress bar control.\n     * @param {number} thickness - The thickness of the circular progress.\n     * @param {number} delay - The delay before starting the animation, in milliseconds.\n     * @param {number} startValue - The starting value of the progress.\n     * @param {number} previousTotal - The previous total value of the progress.\n     * @param {Element} active - The active element to control the animation.\n     * @returns {void}\n     */\n    ProgressAnimation.prototype.doCircularAnimation = function (x, y, radius, progressEnd, totalEnd, element, progress, thickness, delay, startValue, previousTotal, active) {\n        var _this = this;\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var circularPath = element;\n        var start = progress.startAngle;\n        var pathRadius = radius + (thickness / 2);\n        var end = 0;\n        var opacityValue = 0;\n        var duration = (progress.isActive) ? 3000 : progress.animation.duration;\n        start += (progress.cornerRadius === 'Round' && totalEnd !== _model_constant__WEBPACK_IMPORTED_MODULE_2__.completeAngle && totalEnd !== 0) ?\n            ((progress.enableRtl) ? (_model_constant__WEBPACK_IMPORTED_MODULE_2__.lineCapRadius / 2) * thickness : -(_model_constant__WEBPACK_IMPORTED_MODULE_2__.lineCapRadius / 2) * thickness) : 0;\n        totalEnd += (progress.cornerRadius === 'Round' && totalEnd !== _model_constant__WEBPACK_IMPORTED_MODULE_2__.completeAngle && totalEnd !== 0) ?\n            (_model_constant__WEBPACK_IMPORTED_MODULE_2__.lineCapRadius / 2) * thickness : 0;\n        progressEnd += (progress.cornerRadius === 'Round' && totalEnd !== _model_constant__WEBPACK_IMPORTED_MODULE_2__.completeAngle && totalEnd !== 0) ?\n            ((progress.enableRtl) ? -(_model_constant__WEBPACK_IMPORTED_MODULE_2__.lineCapRadius / 2) * thickness : (_model_constant__WEBPACK_IMPORTED_MODULE_2__.lineCapRadius / 2) * thickness) : 0;\n        if (progress.cornerRadius === 'Round' && totalEnd !== _model_constant__WEBPACK_IMPORTED_MODULE_2__.completeAngle && totalEnd !== 0 && progress.startAngle === progress.endAngle) {\n            var startPosition = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(x, y, pathRadius, start).x;\n            var endPosition = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(x, y, pathRadius, progressEnd).x;\n            while (((progress.enableRtl !== progress.startAngle >= 180) ? endPosition <= startPosition : endPosition >= startPosition)) {\n                progressEnd += (progress.enableRtl ? 0.1 : -0.1);\n                endPosition = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(x, y, pathRadius, progressEnd).x;\n            }\n        }\n        var startPos = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(startValue)) ? startValue : start;\n        var endPos = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(startValue)) ? totalEnd - previousTotal : totalEnd;\n        circularPath.setAttribute('visibility', 'Hidden');\n        animation.animate(circularPath, {\n            duration: (progress.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 2000 : duration,\n            delay: delay,\n            progress: function (args) {\n                progress.cancelResize = true;\n                if (args.timeStamp >= args.delay) {\n                    circularPath.setAttribute('visibility', 'visible');\n                    if (progress.isActive) {\n                        end = _this.activeAnimate((args.timeStamp / args.duration), startPos, endPos, progress.enableRtl);\n                        opacityValue = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, 0.5, 0.5, args.duration, true);\n                        active.setAttribute('opacity', opacityValue.toString());\n                        circularPath.setAttribute('d', (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getPathArc)(x, y, pathRadius, start, end % 360, progress.enableRtl, true));\n                    }\n                    else {\n                        end = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, startPos, endPos, args.duration, progress.enableRtl);\n                        circularPath.setAttribute('d', (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getPathArc)(x, y, pathRadius, start, end % 360, progress.enableRtl, true));\n                    }\n                }\n            },\n            end: function () {\n                progress.cancelResize = false;\n                circularPath.setAttribute('visibility', '');\n                circularPath.setAttribute('d', (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getPathArc)(x, y, pathRadius, start, progressEnd, progress.enableRtl, true));\n                if (progress.isActive) {\n                    _this.doCircularAnimation(x, y, radius, progressEnd, totalEnd, element, progress, thickness, delay, startValue, previousTotal, active);\n                }\n                progress.trigger('animationComplete', {\n                    value: progress.value, trackColor: progress.trackColor,\n                    progressColor: progress.progressColor\n                });\n            }\n        });\n    };\n    /**\n     * Initiates circular animation for an indeterminate progress bar.\n     *\n     * @param {Element} circularProgress - The HTML element representing the circular progress bar.\n     * @param {ProgressBar} progress - The progress bar object.\n     * @param {number} start - The starting value of the progress.\n     * @param {number} end - The ending value of the progress.\n     * @param {number} x - The x-coordinate of the center of the circle.\n     * @param {number} y - The y-coordinate of the center of the circle.\n     * @param {number} radius - The radius of the circle.\n     * @param {number} thickness - The thickness of the circular progress bar.\n     * @param {Element} clipPath - The SVG clip path element to control the animation.\n     * @returns {void}\n     */\n    ProgressAnimation.prototype.doCircularIndeterminate = function (circularProgress, progress, start, end, x, y, radius, thickness, clipPath) {\n        var _this = this;\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var pathRadius = radius + ((!progress.enableProgressSegments) ? (thickness / 2) : 0);\n        var duration = (progress.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 2000 : progress.animation.duration;\n        var value = (!progress.enableProgressSegments) ? 6000 / duration : 4000 / duration;\n        animation.animate(clipPath, {\n            progress: function () {\n                circularProgress.style.visibility = 'visible';\n                start += (progress.enableRtl) ? -value : value;\n                end += (progress.enableRtl) ? -value : value;\n                circularProgress.setAttribute('d', (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getPathArc)(x, y, pathRadius, start % 360, end % 360, progress.enableRtl, !progress.enableProgressSegments));\n            },\n            end: function () {\n                if (!progress.destroyIndeterminate) {\n                    _this.doCircularIndeterminate(circularProgress, progress, start, end, x, y, radius, thickness, clipPath);\n                }\n            }\n        });\n    };\n    /**\n     * Initiates label animation for a progress bar.\n     *\n     * @param {Element} labelPath - The SVG path element representing the label.\n     * @param {number} start - The starting value of the progress.\n     * @param {number} end - The ending value of the progress.\n     * @param {ProgressBar} progress - The progress bar control.\n     * @param {number} delay - The delay before starting the animation, in milliseconds.\n     * @param {number} textSize - The size of the text.\n     * @returns {void}\n     */\n    ProgressAnimation.prototype.doLabelAnimation = function (labelPath, start, end, progress, delay, textSize) {\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var label = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var startPos;\n        var endPos;\n        var text = labelPath.innerHTML;\n        var value = 0;\n        var xPos = 0;\n        var valueChanged = 0;\n        var percentage = 100;\n        var labelText = progress.labelStyle.text;\n        var labelPos = progress.labelStyle.textAlignment;\n        var posX = parseInt(labelPath.getAttribute('x'), 10);\n        labelPath.setAttribute('visibility', 'Hidden');\n        if (progress.type === 'Linear') {\n            startPos = (progress.enableRtl) ? (progress.progressRect.x + progress.progressRect.width) + (textSize / 2) :\n                start - (textSize / 2);\n            startPos = (startPos <= 0) ? 0 : startPos;\n            endPos = (progress.enableRtl) ? startPos - posX : posX - startPos;\n        }\n        animation.animate(labelPath, {\n            duration: (progress.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 2000 : progress.animation.duration,\n            delay: delay,\n            progress: function (args) {\n                progress.cancelResize = true;\n                args.name = 'SlideRight';\n                if (progress.type === 'Linear') {\n                    if (args.timeStamp >= args.delay) {\n                        if (labelText === '') {\n                            labelPath.setAttribute('visibility', 'visible');\n                            value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, start, end, args.duration, false);\n                            valueChanged = parseInt((((Math.round(value)) / progress.progressRect.width) * percentage).toString(), 10);\n                            labelPath.innerHTML = valueChanged.toString() + '%';\n                            if (labelPos === 'Far' || labelPos === 'Center') {\n                                xPos = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, startPos, endPos, args.duration, progress.enableRtl);\n                                labelPath.setAttribute('x', xPos.toString());\n                            }\n                        }\n                    }\n                }\n                else if (progress.type === 'Circular') {\n                    if (labelText === '') {\n                        labelPath.setAttribute('visibility', 'visible');\n                        value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, start, end - start, args.duration, false);\n                        valueChanged = parseInt((((Math.round(value)) / progress.totalAngle) * percentage).toString(), 10);\n                        labelPath.innerHTML = valueChanged.toString() + '%';\n                    }\n                }\n            },\n            end: function () {\n                progress.cancelResize = false;\n                if (labelText === '') {\n                    labelPath.innerHTML = text;\n                    labelPath.setAttribute('x', posX.toString());\n                }\n                else {\n                    label.animate(labelPath, {\n                        progress: function (args) {\n                            labelPath.setAttribute('visibility', 'visible');\n                            value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, 0, 1, args.duration, false);\n                            labelPath.setAttribute('opacity', value.toString());\n                        },\n                        end: function () {\n                            labelPath.setAttribute('opacity', '1');\n                        }\n                    });\n                }\n            }\n        });\n    };\n    /**\n     * Initiates annotation animation for a circular progress bar.\n     *\n     * @param {Element} circularPath - The SVG path element representing the circular progress bar.\n     * @param {ProgressBar} progress - The progress bar object.\n     * @param {number} previousEnd - The previous end value of the progress.\n     * @param {number} previousTotal - The previous total value of the progress.\n     * @returns {void}\n     */\n    ProgressAnimation.prototype.doAnnotationAnimation = function (circularPath, progress, previousEnd, previousTotal) {\n        var animation = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({});\n        var value = 0;\n        var percentage = 100;\n        var isAnnotation = progress.annotations.length > 0;\n        var annotatElementChanged;\n        var firstAnnotatElement;\n        var start = progress.startAngle;\n        var totalAngle = progress.totalAngle;\n        var totalEnd;\n        var annotateValueChanged;\n        var annotateValue;\n        if (isAnnotation && progress.progressAnnotationModule) {\n            firstAnnotatElement = document.getElementById(progress.element.id + 'Annotation0').children[0];\n            if (firstAnnotatElement && firstAnnotatElement.children[0]) {\n                if (firstAnnotatElement.children[0].tagName === 'SPAN') {\n                    annotatElementChanged = firstAnnotatElement.children[0];\n                }\n            }\n        }\n        totalEnd = ((progress.argsData.value - progress.minimum) / (progress.maximum - progress.minimum)) * progress.totalAngle;\n        progress.annotateTotal = totalEnd =\n            (progress.argsData.value < progress.minimum) ? 0 : totalEnd;\n        progress.annotateEnd = start + totalEnd;\n        annotateValue = ((progress.argsData.value - progress.minimum) / (progress.maximum - progress.minimum)) * percentage;\n        annotateValue = (progress.argsData.value < progress.minimum) ? 0 :\n            Math.round(annotateValue);\n        var startValue = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(previousEnd)) ? previousEnd : start;\n        var endValue = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(previousEnd)) ? totalEnd - previousTotal : totalEnd;\n        if (progress.argsData.value <= progress.minimum) {\n            annotatElementChanged.innerHTML = annotateValue + '%';\n        }\n        else {\n            animation.animate(circularPath, {\n                duration: (progress.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 2000 : progress.animation.duration,\n                delay: progress.animation.delay,\n                progress: function (args) {\n                    progress.cancelResize = true;\n                    if (isAnnotation && annotatElementChanged) {\n                        value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_1__.effect)(args.timeStamp, startValue, endValue, args.duration, false);\n                        annotateValueChanged = parseInt((((Math.round(value) - start) / totalAngle) * percentage).toString(), 10);\n                        annotatElementChanged.innerHTML = annotateValueChanged ? annotateValueChanged.toString() + '%' : '0%';\n                    }\n                },\n                end: function () {\n                    progress.cancelResize = false;\n                    annotatElementChanged.innerHTML = annotateValue + '%';\n                }\n            });\n        }\n    };\n    ProgressAnimation.prototype.activeAnimate = function (t, start, end, enableRtl) {\n        var time = 1 - Math.pow(1 - t, 3);\n        var attrValue = start + ((!enableRtl) ? (time * end) : -(time * end));\n        return attrValue;\n    };\n    return ProgressAnimation;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-progressbar/src/progressbar/utils/progress-animation.js?");

/***/ })

}]);