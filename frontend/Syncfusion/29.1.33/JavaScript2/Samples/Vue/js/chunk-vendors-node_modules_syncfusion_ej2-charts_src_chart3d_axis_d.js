"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart3d_axis_d"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/double-axis.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/double-axis.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Double3D: () => (/* binding */ Double3D)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/doubleRange */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/doubleRange.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _utils_chart3dRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/chart3dRender */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js\");\n\n\n\n\n\n/**\n * The numeric module is used to render numeric axis.\n */\nvar Double3D = /** @class */ (function () {\n    /**\n     * Constructor for the dateTime module.\n     *\n     * @param {Chart3D} chart - Chart3D instance.\n     * @private\n     */\n    function Double3D(chart) {\n        this.isColumn = 0;\n        this.isStacking = false;\n        this.chart = chart;\n    }\n    /**\n     * Calculates a numeric nice interval for the specified axis based on the provided delta and size.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the numeric nice interval is calculated.\n     * @param {number} delta - The delta value to consider in the interval calculation.\n     * @param {Size} size - The size of the chart area used in the calculation.\n     * @returns {number} - The calculated numeric nice interval.\n     * @protected\n     */\n    Double3D.prototype.calculateNumericNiceInterval = function (axis, delta, size) {\n        var actualDesiredIntervalsCount = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getActualDesiredIntervalsCount)(size, axis);\n        var niceInterval = delta / actualDesiredIntervalsCount;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(axis.desiredIntervals)) {\n            return niceInterval;\n        }\n        var minInterval = Math.pow(10, Math.floor((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.logBase)(niceInterval, 10)));\n        for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {\n            var interval = _a[_i];\n            var currentInterval = minInterval * interval;\n            if (actualDesiredIntervalsCount < (delta / currentInterval)) {\n                break;\n            }\n            niceInterval = currentInterval;\n        }\n        return niceInterval;\n    };\n    /**\n     * Retrieves the actual range for the specified axis based on the provided size.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the actual range is retrieved.\n     * @param {Size} size - The size of the chart area used in the range calculation.\n     * @returns {void}\n     */\n    Double3D.prototype.getActualRange = function (axis, size) {\n        this.initializeDoubleRange(axis);\n        if ((!axis.startFromZero) && (this.isColumn > 0)) {\n            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;\n            if ((axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0)) {\n                axis.actualRange.min = 0;\n            }\n            else {\n                axis.actualRange.min = axis.doubleRange.start - (this.isStacking ? 0 : axis.actualRange.interval);\n            }\n        }\n        else {\n            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            axis.actualRange.min = axis.doubleRange.start;\n            axis.actualRange.max = axis.doubleRange.end;\n        }\n    };\n    /**\n     * Range for the axis.\n     *\n     * @param {Chart3DAxis} axis - Specifies the instance of the axis.\n     * @returns {void}\n     * @private\n     */\n    Double3D.prototype.initializeDoubleRange = function (axis) {\n        //Axis Min\n        if (axis.minimum !== null) {\n            this.min = axis.minimum;\n        }\n        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n            this.min = 0;\n        }\n        // Axis Max\n        if (axis.maximum !== null) {\n            this.max = axis.maximum;\n        }\n        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n            this.max = 5;\n        }\n        if (this.min === this.max) {\n            this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;\n        }\n        axis.doubleRange = new _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(this.min, this.max);\n        axis.actualRange = {};\n    };\n    /**\n     * Calculates the range and interval for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used for range and interval calculation.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {void}\n     */\n    Double3D.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.applyRangePadding(axis, size);\n        this.calculateVisibleLabels(axis, this.chart);\n    };\n    /**\n     * Calculates range for the axis.\n     *\n     * @param {Chart3DAxis} axis - Specifies the instance of the axis.\n     * @returns {void}\n     * @private\n     */\n    Double3D.prototype.calculateRange = function (axis) {\n        /** Generate axis range */\n        this.min = null;\n        this.max = null;\n        if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.setRange)(axis)) {\n            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (!series.visible) {\n                    continue;\n                }\n                this.paddingInterval = 0;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(series.points)) {\n                    axis.maxPointLength = series.points.length;\n                }\n                axis.maxPointLength = series.points.length;\n                if (((series.type.indexOf('Column') > -1) && axis.orientation === 'Horizontal')\n                    || (series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical')) {\n                    if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime')\n                        && series.xAxis.rangePadding === 'Auto') {\n                        this.paddingInterval = (0,_utils_chart3dRender__WEBPACK_IMPORTED_MODULE_3__.getMinPointsDeltaValue)(series.xAxis, axis.series) * 0.5;\n                    }\n                }\n                //For xRange\n                if (axis.orientation === 'Horizontal') {\n                    if (this.chart.requireInvertedAxis) {\n                        this.yAxisRange(axis, series);\n                    }\n                    else {\n                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n                    }\n                }\n                // For yRange\n                if (axis.orientation === 'Vertical') {\n                    this.isColumn += (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1) ? 1 : 0;\n                    this.isStacking = series.type.indexOf('Stacking') !== -1;\n                    if (this.chart.requireInvertedAxis) {\n                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n                    }\n                    else {\n                        this.yAxisRange(axis, series);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Sets the range for the Y-axis based on the minimum and maximum values of the series.\n     *\n     * @param {Chart3DAxis} axis - The Y-axis of the 3D chart.\n     * @param {Chart3DSeries} series - The 3D series for which to determine the range.\n     * @returns {void}\n     */\n    Double3D.prototype.yAxisRange = function (axis, series) {\n        this.findMinMax(series.yMin, series.yMax);\n    };\n    /**\n     * Finds and updates the minimum and maximum values within a given range.\n     *\n     * @param {Object} min - The minimum value to compare.\n     * @param {Object} max - The maximum value to compare.\n     * @returns {void}\n     */\n    Double3D.prototype.findMinMax = function (min, max) {\n        if (this.min === null || this.min > min) {\n            this.min = min;\n        }\n        if (this.max === null || this.max < max) {\n            this.max = max;\n        }\n        if ((this.max === this.min) && this.max < 0 && this.min < 0) { // max == min\n            this.max = 0;\n        }\n    };\n    /**\n     * Apply padding for the range.\n     *\n     * @param {Chart3DAxis} axis - Specifies the instance of the axis.\n     * @param {Size} size - Specifies the size of the axis.\n     * @returns {void}\n     * @private\n     */\n    Double3D.prototype.applyRangePadding = function (axis, size) {\n        var start = axis.actualRange.min;\n        var end = axis.actualRange.max;\n        if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.setRange)(axis)) {\n            var interval = axis.actualRange.interval;\n            var padding = axis.getRangePadding(this.chart);\n            if (padding === 'Additional' || padding === 'Round') {\n                this.findAdditional(axis, start, end, interval, size);\n            }\n            else if (padding === 'Normal') {\n                this.findNormal(axis, start, end, interval, size);\n            }\n            else {\n                this.updateActualRange(axis, start, end, interval);\n            }\n        }\n        axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n        this.calculateVisibleRange(size, axis);\n    };\n    /**\n     * Updates the actual range of the 3D axis with specified minimum, maximum, and interval values.\n     *\n     * @param {Chart3DAxis} axis - The 3D axis to update.\n     * @param {number} minimum - The minimum value for the axis.\n     * @param {number} maximum - The maximum value for the axis.\n     * @param {number} interval - The interval value for the axis.\n     * @returns {void}\n     */\n    Double3D.prototype.updateActualRange = function (axis, minimum, maximum, interval) {\n        axis.actualRange = {\n            min: axis.minimum != null ? axis.minimum : minimum,\n            max: axis.maximum != null ? axis.maximum : maximum,\n            interval: axis.interval != null ? axis.interval : interval,\n            delta: axis.actualRange.delta\n        };\n    };\n    /**\n     * Finds additional range for the 3D axis based on specified start, end, interval, and size values.\n     *\n     * @param {Chart3DAxis} axis - The 3D axis to find additional range for.\n     * @param {number} start - The start value for the axis range.\n     * @param {number} end - The end value for the axis range.\n     * @param {number} interval - The interval value for the axis.\n     * @param {Size} size - The size of the chart area.\n     * @returns {void}\n     */\n    Double3D.prototype.findAdditional = function (axis, start, end, interval, size) {\n        var minimum;\n        var maximum;\n        minimum = Math.floor(start / interval) * interval;\n        maximum = Math.ceil(end / interval) * interval;\n        if (axis.rangePadding === 'Additional') {\n            minimum -= interval;\n            maximum += interval;\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(axis.desiredIntervals)) {\n            var delta = maximum - minimum;\n            interval = this.calculateNumericNiceInterval(axis, delta, size);\n        }\n        this.updateActualRange(axis, minimum, maximum, interval);\n    };\n    /**\n     * Finds normal range for the 3D axis based on specified start, end, interval, and size values.\n     *\n     * @param {Chart3DAxis} axis - The 3D axis to find normal range for.\n     * @param {number} start - The start value for the axis range.\n     * @param {number} end - The end value for the axis range.\n     * @param {number} interval - The interval value for the axis.\n     * @param {Size} size - The size of the chart area.\n     * @returns {void}\n     */\n    Double3D.prototype.findNormal = function (axis, start, end, interval, size) {\n        var remaining;\n        var minimum;\n        var maximum;\n        var startValue = start;\n        if (start < 0) {\n            startValue = 0;\n            minimum = start + (start * 0.05);\n            remaining = interval + (minimum % interval);\n            if ((0.365 * interval) >= remaining) {\n                minimum -= interval;\n            }\n            if (minimum % interval < 0) {\n                minimum = (minimum - interval) - (minimum % interval);\n            }\n        }\n        else {\n            minimum = start < ((5.0 / 6.0) * end) ? 0 : (start - (end - start) * 0.5);\n            if (minimum % interval > 0) {\n                minimum -= (minimum % interval);\n            }\n        }\n        maximum = (end > 0) ? (end + (end - startValue) * 0.05) : (end - (end - startValue) * 0.05);\n        remaining = interval - (maximum % interval);\n        if ((0.365 * interval) >= remaining) {\n            maximum += interval;\n        }\n        if (maximum % interval > 0) {\n            maximum = (maximum + interval) - (maximum % interval);\n        }\n        axis.doubleRange = new _utils_doubleRange__WEBPACK_IMPORTED_MODULE_1__.DoubleRange(minimum, maximum);\n        if (minimum === 0 || (minimum < 0 && maximum < 0)) {\n            interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            maximum = Math.ceil(maximum / interval) * interval;\n        }\n        this.updateActualRange(axis, minimum, maximum, interval);\n    };\n    /**\n     * Calculate visible range for axis.\n     *\n     * @param {Size} size - Specifies the size of the axis.\n     * @param {Chart3DAxis} axis - Specifies the instance of the axis.\n     * @returns {void}\n     * @private\n     */\n    Double3D.prototype.calculateVisibleRange = function (size, axis) {\n        axis.visibleRange = {\n            max: axis.actualRange.max, min: axis.actualRange.min,\n            delta: axis.actualRange.delta, interval: axis.actualRange.interval\n        };\n        if (axis.maximum && axis.orientation === 'Vertical' && axis.rangePadding === 'Auto') {\n            var duplicateTempInterval = void 0;\n            var tempInterval = axis.visibleRange.min;\n            for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {\n                duplicateTempInterval = tempInterval;\n            }\n            if (duplicateTempInterval < axis.visibleRange.max) {\n                axis.visibleRange.max = duplicateTempInterval + axis.visibleRange.interval;\n            }\n        }\n        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n    };\n    /**\n     * Calculates the visible label for the axis.\n     *\n     * @param {Chart3DAxis} axis - Specifies the instance of the axis.\n     * @param {Chart3D} chart - Specifies the instance of the chart.\n     * @returns {void}\n     * @private\n     */\n    Double3D.prototype.calculateVisibleLabels = function (axis, chart) {\n        /** Generate axis labels */\n        axis.visibleLabels = [];\n        var tempInterval = axis.visibleRange.min;\n        var labelStyle;\n        var format = this.getFormat(axis);\n        var isCustom = format.match('{value}') !== null;\n        var intervalDigits = 0;\n        var formatDigits = 0;\n        if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {\n            formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);\n        }\n        axis.format = chart.intl.getNumberFormat({\n            format: isCustom ? '' : format,\n            useGrouping: chart.useGroupingSeparator\n        });\n        axis.startLabel = axis.format(axis.visibleRange.min);\n        axis.endLabel = axis.format(axis.visibleRange.max);\n        if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {\n            intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;\n        }\n        var duplicateTempInterval;\n        for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {\n            duplicateTempInterval = tempInterval;\n            labelStyle = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.getValue)('properties', axis.labelStyle), null, true));\n            if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withIn)(tempInterval, axis.visibleRange)) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.triggerLabelRender)(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n            }\n        }\n        if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {\n            tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ?\n                +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;\n            if (tempInterval <= axis.visibleRange.max) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.triggerLabelRender)(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n            }\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * Gets the format for the axis label.\n     *\n     * @param {Chart3DAxis} axis - Specifies the instance of the axis.\n     * @returns {string} - Returns the string value.\n     * @private\n     */\n    Double3D.prototype.getFormat = function (axis) {\n        if (axis.labelFormat) {\n            if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {\n                return '{value}%';\n            }\n            return axis.labelFormat;\n        }\n        return axis.isStack100 ? '{value}%' : '';\n    };\n    /**\n     * Formats the axis label.\n     *\n     * @param {Chart3DAxis} axis - Specifies the instance of the axis.\n     * @param {boolean} isCustom - Specifies whether the format is custom.\n     * @param {string} format - Specifies the format of the axis label.\n     * @param {number} tempInterval - Specifies the interval of the axis label.\n     * @returns {string} - Returns the string value.\n     * @private\n     */\n    Double3D.prototype.formatValue = function (axis, isCustom, format, tempInterval) {\n        var labelValue = !(tempInterval % 1) ? tempInterval : Number(tempInterval.toLocaleString().split(',').join(''));\n        return isCustom ? format.replace('{value}', axis.format(labelValue))\n            : format ? axis.format(tempInterval) : axis.format(labelValue);\n    };\n    /**\n     * Gets the module name.\n     *\n     * @returns {string} - the module name.\n     */\n    Double3D.prototype.getModuleName = function () {\n        /**\n         * Returns the module name.\n         */\n        return 'Double3D';\n    };\n    return Double3D;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/double-axis.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/logarithmic-axis.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/logarithmic-axis.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logarithmic3D: () => (/* binding */ Logarithmic3D)\n/* harmony export */ });\n/* harmony import */ var _axis_double_axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../axis/double-axis */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/double-axis.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * The `Logarithmic` module is used to render log axis.\n */\nvar Logarithmic3D = /** @class */ (function (_super) {\n    __extends(Logarithmic3D, _super);\n    /**\n     * Constructor for the logerithmic module.\n     *\n     * @param {Chart3D} chart - Chart3D instance.\n     * @private\n     */\n    function Logarithmic3D(chart) {\n        return _super.call(this, chart) || this;\n    }\n    /**\n     * Calculates the range and interval for the specified axis based on the provided size.\n     *\n     * @param {Size} size - The size of the chart area used for range and interval calculation.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {void}\n     */\n    Logarithmic3D.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.calculateVisibleRange(size, axis);\n        this.calculateVisibleLabels(axis, this.chart);\n    };\n    /**\n     * Calculates actual range for the axis.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @param {Size} size - The size of the axis.\n     * @returns {void}\n     * @private\n     */\n    Logarithmic3D.prototype.getActualRange = function (axis, size) {\n        this.initializeDoubleRange(axis);\n        this.min = this.min < 0 ? 0 : this.min;\n        var logStart = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.logBase)(this.min, axis.logBase);\n        logStart = isFinite(logStart) ? logStart : this.min;\n        var logEnd = this.max === 1 ? 1 : (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.logBase)(this.max, axis.logBase);\n        logEnd = isFinite(logStart) ? logEnd : this.max;\n        this.min = Math.floor(logStart / 1);\n        var isRectSeries = axis.series && axis.series.some(function (item) {\n            return (item.type.indexOf('Column') !== -1 || item.type.indexOf('Bar') !== -1);\n        });\n        if (isRectSeries) {\n            this.min = (this.min <= 0) ? (+this.min - 1) : this.min;\n        }\n        this.max = Math.ceil(logEnd / 1);\n        this.max = this.max === this.min ? this.max + 1 : this.max;\n        axis.actualRange.interval = axis.interval || this.calculateLogNiceInterval(this.max - this.min, size, axis);\n        axis.actualRange.min = this.min;\n        axis.actualRange.max = this.max;\n        axis.actualRange.delta = this.max - this.min;\n    };\n    /**\n     * Calculates visible range for the axis.\n     *\n     * @param {Size} size - The size of the axis.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {void}\n     * @private\n     */\n    Logarithmic3D.prototype.calculateVisibleRange = function (size, axis) {\n        axis.visibleRange = {\n            interval: axis.actualRange.interval, max: axis.actualRange.max,\n            min: axis.actualRange.min, delta: axis.actualRange.delta\n        };\n    };\n    /**\n     * Calculates log inteval for the axis.\n     *\n     * @param {number} delta - The delta value.\n     * @param {Size} size - The size of the axis.\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @returns {number} - Returns the log interval.\n     * @private\n     */\n    Logarithmic3D.prototype.calculateLogNiceInterval = function (delta, size, axis) {\n        var actualDesiredIntervalsCount = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getActualDesiredIntervalsCount)(size, axis);\n        var niceInterval = delta;\n        var minInterval = Math.pow(axis.logBase, Math.floor((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.logBase)(niceInterval, 10)));\n        for (var j = 0, len = axis.intervalDivs.length; j < len; j++) {\n            var currentInterval = minInterval * axis.intervalDivs[j];\n            if (actualDesiredIntervalsCount < (delta / currentInterval)) {\n                break;\n            }\n            niceInterval = currentInterval;\n        }\n        return niceInterval;\n    };\n    /**\n     * Calculates labels for the axis.\n     *\n     * @param {Chart3DAxis} axis - The axis for which the range and interval are calculated.\n     * @param {Chart3D} chart - Specifies the instance of the chart.\n     * @returns {void}\n     * @private\n     */\n    Logarithmic3D.prototype.calculateVisibleLabels = function (axis, chart) {\n        /** Generate axis labels */\n        var tempInterval = axis.visibleRange.min;\n        axis.visibleLabels = [];\n        var labelStyle;\n        var value;\n        var axisFormat = this.getFormat(axis);\n        var isCustomFormat = axisFormat.match('{value}') !== null;\n        var startValue = Math.pow(axis.logBase, axis.visibleRange.min);\n        axis.format = chart.intl.getNumberFormat({\n            format: isCustomFormat ? '' : axisFormat,\n            useGrouping: chart.useGroupingSeparator,\n            maximumFractionDigits: startValue < 1 ? 20 : 3\n        });\n        axis.startLabel = axis.format(startValue < 1 ? +startValue.toPrecision(1) : startValue);\n        axis.endLabel = axis.format(Math.pow(axis.logBase, axis.visibleRange.max));\n        for (; tempInterval <= axis.visibleRange.max; tempInterval += axis.visibleRange.interval) {\n            labelStyle = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.extend)({}, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.getValue)('properties', axis.labelStyle), null, true));\n            if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withIn)(tempInterval, axis.visibleRange)) {\n                value = Math.pow(axis.logBase, tempInterval);\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.triggerLabelRender)(this.chart, tempInterval, this.formatValue(axis, isCustomFormat, axisFormat, value < 1 ? +value.toPrecision(1) : value), labelStyle, axis);\n            }\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    Logarithmic3D.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'Logarithmic3D';\n    };\n    /**\n     * To destroy the category axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    Logarithmic3D.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return Logarithmic3D;\n}(_axis_double_axis__WEBPACK_IMPORTED_MODULE_0__.Double3D));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/axis/logarithmic-axis.js?");

/***/ })

}]);