"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_objects_connector_js-204e1024"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityFlow: () => (/* binding */ ActivityFlow),\n/* harmony export */   BezierSegment: () => (/* binding */ BezierSegment),\n/* harmony export */   BezierSettings: () => (/* binding */ BezierSettings),\n/* harmony export */   BpmnFlow: () => (/* binding */ BpmnFlow),\n/* harmony export */   ClassifierMultiplicity: () => (/* binding */ ClassifierMultiplicity),\n/* harmony export */   Connector: () => (/* binding */ Connector),\n/* harmony export */   ConnectorSegment: () => (/* binding */ ConnectorSegment),\n/* harmony export */   ConnectorShape: () => (/* binding */ ConnectorShape),\n/* harmony export */   Decorator: () => (/* binding */ Decorator),\n/* harmony export */   DiagramConnectorSegment: () => (/* binding */ DiagramConnectorSegment),\n/* harmony export */   DiagramConnectorShape: () => (/* binding */ DiagramConnectorShape),\n/* harmony export */   MultiplicityLabel: () => (/* binding */ MultiplicityLabel),\n/* harmony export */   OrthogonalSegment: () => (/* binding */ OrthogonalSegment),\n/* harmony export */   RelationShip: () => (/* binding */ RelationShip),\n/* harmony export */   StraightSegment: () => (/* binding */ StraightSegment),\n/* harmony export */   Vector: () => (/* binding */ Vector),\n/* harmony export */   bezierPoints: () => (/* binding */ bezierPoints),\n/* harmony export */   getBezierBounds: () => (/* binding */ getBezierBounds),\n/* harmony export */   getBezierPoints: () => (/* binding */ getBezierPoints),\n/* harmony export */   getDirection: () => (/* binding */ getDirection),\n/* harmony export */   isEmptyVector: () => (/* binding */ isEmptyVector)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _core_appearance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/appearance */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/appearance.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _utility_connector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utility/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _annotation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./annotation */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/annotation.js\");\n/* harmony import */ var _core_containers_canvas__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../core/containers/canvas */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/canvas.js\");\n/* harmony import */ var _dictionary_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dictionary/common */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/dictionary/common.js\");\n/* harmony import */ var _node_base__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node-base */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node-base.js\");\n/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tooltip */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/tooltip.js\");\n/* harmony import */ var _primitives_matrix__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../primitives/matrix */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js\");\n/* harmony import */ var _core_elements_html_element__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../core/elements/html-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/html-element.js\");\n/* harmony import */ var _utility_dom_util__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../utility/dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _preview__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./preview */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/preview.js\");\n/* harmony import */ var _fixed_user_handle__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./fixed-user-handle */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/fixed-user-handle.js\");\n/* harmony import */ var _interaction_tool__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../interaction/tool */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/tool.js\");\n/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./port */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/port.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar getConnectorType = function (obj) {\n    //Removed isBlazor code\n    if (obj) {\n        switch (obj.type) {\n            case 'Bpmn':\n                return BpmnFlow;\n            case 'UmlActivity':\n                return ActivityFlow;\n            case 'UmlClassifier':\n                return RelationShip;\n            default:\n                return ConnectorShape;\n        }\n    }\n    return ConnectorShape;\n};\nvar getSegmentType = function (obj) {\n    if (obj) {\n        //Removed isBlazor code\n        switch (obj.type) {\n            case 'Straight':\n                return StraightSegment;\n            case 'Bezier':\n                return BezierSegment;\n            case 'Orthogonal':\n                return OrthogonalSegment;\n            default:\n                return StraightSegment;\n        }\n    }\n    return undefined;\n};\n/**\n * Decorators are used to decorate the end points of the connector with some predefined path geometry\n */\nvar Decorator = /** @class */ (function (_super) {\n    __extends(Decorator, _super);\n    function Decorator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], Decorator.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], Decorator.prototype, \"height\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Arrow')\n    ], Decorator.prototype, \"shape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ fill: 'black', strokeColor: 'black', strokeWidth: 1 }, _core_appearance__WEBPACK_IMPORTED_MODULE_1__.ShapeStyle)\n    ], Decorator.prototype, \"style\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0.5 }, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], Decorator.prototype, \"pivot\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Decorator.prototype, \"pathData\", void 0);\n    return Decorator;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Describes the length and angle between the control point and the start point of bezier segment\n */\nvar Vector = /** @class */ (function (_super) {\n    __extends(Vector, _super);\n    function Vector() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Vector.prototype, \"angle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Vector.prototype, \"distance\", void 0);\n    return Vector;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Describes the length and angle between the control point and the start point of bezier segment\n */\nvar BezierSettings = /** @class */ (function (_super) {\n    __extends(BezierSettings, _super);\n    function BezierSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.ControlPointsVisibility.All)\n    ], BezierSettings.prototype, \"controlPointsVisibility\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('FreeForm')\n    ], BezierSettings.prototype, \"segmentEditOrientation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.BezierSmoothness.Default)\n    ], BezierSettings.prototype, \"smoothness\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], BezierSettings.prototype, \"allowSegmentsReset\", void 0);\n    return BezierSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Sets the type of the connector\n */\nvar ConnectorShape = /** @class */ (function (_super) {\n    __extends(ConnectorShape, _super);\n    function ConnectorShape() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('None')\n    ], ConnectorShape.prototype, \"type\", void 0);\n    return ConnectorShape;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Sets the type of the flow in a BPMN Process\n */\nvar ActivityFlow = /** @class */ (function (_super) {\n    __extends(ActivityFlow, _super);\n    function ActivityFlow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Object')\n    ], ActivityFlow.prototype, \"flow\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(30)\n    ], ActivityFlow.prototype, \"exceptionFlowHeight\", void 0);\n    return ActivityFlow;\n}(ConnectorShape));\n\n/**\n * Sets the type of the flow in a BPMN Process\n */\nvar BpmnFlow = /** @class */ (function (_super) {\n    __extends(BpmnFlow, _super);\n    function BpmnFlow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Sequence')\n    ], BpmnFlow.prototype, \"flow\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Normal')\n    ], BpmnFlow.prototype, \"sequence\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Default')\n    ], BpmnFlow.prototype, \"message\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Default')\n    ], BpmnFlow.prototype, \"association\", void 0);\n    return BpmnFlow;\n}(ConnectorShape));\n\n/**\n * Defines the behavior of connector segments\n */\nvar ConnectorSegment = /** @class */ (function (_super) {\n    __extends(ConnectorSegment, _super);\n    // tslint:disable-next-line:no-any\n    function ConnectorSegment(parent, propName, defaultValue, isArray) {\n        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n        _this.points = [];\n        return _this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Straight')\n    ], ConnectorSegment.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], ConnectorSegment.prototype, \"allowDrag\", void 0);\n    return ConnectorSegment;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Defines the behavior of straight segments\n */\nvar StraightSegment = /** @class */ (function (_super) {\n    __extends(StraightSegment, _super);\n    function StraightSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns the name of class StraightSegment\n     *\n     * @private\n     */\n    StraightSegment.prototype.getClassName = function () {\n        return 'StraightSegment';\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], StraightSegment.prototype, \"point\", void 0);\n    return StraightSegment;\n}(ConnectorSegment));\n\n/**\n * Defines the behavior of bezier segments\n */\nvar BezierSegment = /** @class */ (function (_super) {\n    __extends(BezierSegment, _super);\n    function BezierSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @private\n     * Returns the name of class BezierSegment\n     */\n    BezierSegment.prototype.getClassName = function () {\n        return 'BezierSegment';\n    };\n    /**\n     * @private\n     * Returns the total points of the bezier curve\n     */\n    BezierSegment.prototype.getPoints = function (segments, start) {\n        var points = [];\n        if (points.length > 0 || start != null) {\n            var st = points.length > 0 ? points[points.length - 1] : start;\n            var bezier = this.bezireToPoly(st, segments);\n            // 878719: Resolve ESLint errors\n            // eslint-disable-next-line prefer-spread\n            points.push.apply(points, bezier);\n        }\n        return points;\n    };\n    /**\n     * @private\n     * Returns the total points of the bezier curve\n     */\n    BezierSegment.prototype.bezireToPoly = function (start, segment) {\n        var points = [];\n        if (segment) {\n            var bezSeg = segment;\n            var pt0 = start;\n            var pt1 = bezSeg.bezierPoint1;\n            var pt2 = bezSeg.bezierPoint2;\n            var pt3 = { x: bezSeg.points[1].x, y: bezSeg.points[1].y };\n            this.flattenCubicBezier(points, pt0, pt1, pt2, pt3, 10);\n        }\n        return points;\n    };\n    /**\n     * @private\n     * Returns the total points of the bezier curve\n     */\n    BezierSegment.prototype.flattenCubicBezier = function (points, ptStart, ptCtrl1, ptCtrl2, ptEnd, tolerance) {\n        var max = ((_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findLength(ptStart, ptCtrl1) + _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findLength(ptCtrl1, ptCtrl2)\n            + _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findLength(ptCtrl2, ptEnd)) / tolerance);\n        var i;\n        for (i = 0; i <= max; i++) {\n            var t = i / max;\n            var x = (1 - t) * (1 - t) * (1 - t) * ptStart.x +\n                3 * t * (1 - t) * (1 - t) * ptCtrl1.x +\n                3 * t * t * (1 - t) * ptCtrl2.x +\n                t * t * t * ptEnd.x;\n            var y = (1 - t) * (1 - t) * (1 - t) * ptStart.y +\n                3 * t * (1 - t) * (1 - t) * ptCtrl1.y +\n                3 * t * t * (1 - t) * ptCtrl2.y +\n                t * t * t * ptEnd.y;\n            points.push({ x: x, y: y });\n        }\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Horizontal')\n    ], BezierSegment.prototype, \"orientation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], BezierSegment.prototype, \"point1\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], BezierSegment.prototype, \"point2\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ angle: 0, distance: 0 }, Vector)\n    ], BezierSegment.prototype, \"vector1\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ angle: 0, distance: 0 }, Vector)\n    ], BezierSegment.prototype, \"vector2\", void 0);\n    return BezierSegment;\n}(StraightSegment));\n\n/**\n * Defines the behavior of orthogonal segments\n */\nvar OrthogonalSegment = /** @class */ (function (_super) {\n    __extends(OrthogonalSegment, _super);\n    function OrthogonalSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns the module of class OrthogonalSegment\n     *\n     * @private\n     */\n    OrthogonalSegment.prototype.getClassName = function () {\n        return 'OrthogonalSegment';\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], OrthogonalSegment.prototype, \"length\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], OrthogonalSegment.prototype, \"direction\", void 0);\n    return OrthogonalSegment;\n}(ConnectorSegment));\n\n/**\n * Defines the behavior of orthogonal segments\n */\nvar DiagramConnectorSegment = /** @class */ (function (_super) {\n    __extends(DiagramConnectorSegment, _super);\n    function DiagramConnectorSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @private\n     * Returns the module of class OrthogonalSegment\n     */\n    DiagramConnectorSegment.prototype.getClassName = function () {\n        return 'DiagramConnectorSegment';\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Straight')\n    ], DiagramConnectorSegment.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], DiagramConnectorSegment.prototype, \"allowDrag\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], DiagramConnectorSegment.prototype, \"point\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], DiagramConnectorSegment.prototype, \"point1\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], DiagramConnectorSegment.prototype, \"point2\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ angle: 0, distance: 0 }, Vector)\n    ], DiagramConnectorSegment.prototype, \"vector1\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ angle: 0, distance: 0 }, Vector)\n    ], DiagramConnectorSegment.prototype, \"vector2\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], DiagramConnectorSegment.prototype, \"length\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], DiagramConnectorSegment.prototype, \"direction\", void 0);\n    return DiagramConnectorSegment;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Get the direction of the control points while the bezier is connected to the node\n */\nfunction getDirection(bounds, points, excludeBounds) {\n    var center = bounds.center;\n    var direction;\n    var part = excludeBounds ? 45 : (180 / (2 + 2 / (bounds.height / bounds.width)));\n    var fourty5 = part;\n    var one35 = (180 - part);\n    var two25 = one35 + (2 * part);\n    var three15 = 360 - part;\n    var angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_7__.findAngle)(points, center);\n    if (angle > fourty5 && angle < one35) {\n        return direction = 'top';\n    }\n    else if (angle > one35 && angle < two25) {\n        return direction = 'right';\n    }\n    else if (angle > two25 && angle < three15) {\n        return direction = 'bottom';\n    }\n    else {\n        return direction = 'left';\n    }\n}\nfunction isEmptyVector(element) {\n    if (!element.distance && !element.angle) {\n        return true;\n    }\n    return false;\n}\n/**\n * Get the bezier points if control points are not given.\n */\nfunction getBezierPoints(sourcePoint, targetPoint, direction) {\n    var distance = 60;\n    var value = { x: 0, y: 0 };\n    if (!direction) {\n        if (Math.abs(targetPoint.x - sourcePoint.x) > Math.abs(targetPoint.y - sourcePoint.y)) {\n            direction = sourcePoint.x < targetPoint.x ? 'right' : 'left';\n        }\n        else {\n            direction = sourcePoint.y < targetPoint.y ? 'bottom' : 'top';\n        }\n    }\n    switch (direction) {\n        case 'bottom':\n        case 'top':\n            distance = Math.min(Math.abs(sourcePoint.y - targetPoint.y) * 0.45, distance);\n            value = { x: sourcePoint.x, y: sourcePoint.y + (direction === 'bottom' ? distance : -distance) };\n            break;\n        case 'right':\n        case 'left':\n            distance = Math.min(Math.abs(sourcePoint.x - targetPoint.x) * 0.45, distance);\n            value = { x: sourcePoint.x + (direction === 'right' ? distance : -distance), y: sourcePoint.y };\n            break;\n    }\n    return value;\n}\n/**\n * Get the bezier curve bounds.\n */\nfunction getBezierBounds(startPoint, controlPoint1, controlPoint2, endPoint, connector) {\n    var minx = 0;\n    var miny = 0;\n    var maxx = 0;\n    var maxy = 0;\n    var tolerancevalue = 3;\n    var max = Number((connector.distance(controlPoint1, startPoint) +\n        connector.distance(controlPoint2, controlPoint1) +\n        connector.distance(endPoint, controlPoint2)) / tolerancevalue);\n    if (max !== 0) {\n        for (var i = 0; i <= max; i++) {\n            var t = i / max;\n            var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x +\n                3 * t * (1 - t) * (1 - t) * controlPoint1.x +\n                3 * t * t * (1 - t) * controlPoint2.x +\n                t * t * t * endPoint.x;\n            var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y +\n                3 * t * (1 - t) * (1 - t) * controlPoint1.y +\n                3 * t * t * (1 - t) * controlPoint2.y +\n                t * t * t * endPoint.y;\n            if (i === 0) {\n                minx = maxx = x;\n                miny = maxy = y;\n            }\n            else {\n                minx = Math.min(x, minx);\n                miny = Math.min(y, miny);\n                maxx = Math.max(x, maxx);\n                maxy = Math.max(y, maxy);\n            }\n        }\n    }\n    return {\n        x: minx, y: miny, width: maxx - minx, height: maxy - miny,\n        left: minx, top: miny, right: (minx + (maxx - minx)), bottom: (miny + (maxy - miny)),\n        center: { x: (minx + (maxx - minx)) / 2, y: (miny + (maxy - miny)) / 2 }\n    };\n}\n/**\n * Get the intermediate bezier curve for point over connector\n */\nfunction bezierPoints(connector, startPoint, point1, point2, endPoint, i, max) {\n    var pt = { x: 0, y: 0 };\n    var t = i / max;\n    var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x +\n        3 * t * (1 - t) * (1 - t) * point1.x +\n        3 * t * t * (1 - t) * point2.x +\n        t * t * t * endPoint.x;\n    pt.x = x;\n    var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y +\n        3 * t * (1 - t) * (1 - t) * point1.y +\n        3 * t * t * (1 - t) * point2.y +\n        t * t * t * endPoint.y;\n    pt.y = y;\n    return pt;\n}\n/**\n * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults\n */\nvar MultiplicityLabel = /** @class */ (function (_super) {\n    __extends(MultiplicityLabel, _super);\n    function MultiplicityLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], MultiplicityLabel.prototype, \"optional\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(undefined)\n    ], MultiplicityLabel.prototype, \"lowerBounds\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(undefined)\n    ], MultiplicityLabel.prototype, \"upperBounds\", void 0);\n    return MultiplicityLabel;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults\n */\nvar ClassifierMultiplicity = /** @class */ (function (_super) {\n    __extends(ClassifierMultiplicity, _super);\n    function ClassifierMultiplicity() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('OneToOne')\n    ], ClassifierMultiplicity.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, MultiplicityLabel)\n    ], ClassifierMultiplicity.prototype, \"target\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, MultiplicityLabel)\n    ], ClassifierMultiplicity.prototype, \"source\", void 0);\n    return ClassifierMultiplicity;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Defines the behavior of the UMLActivity shape\n */\nvar RelationShip = /** @class */ (function (_super) {\n    __extends(RelationShip, _super);\n    function RelationShip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('UmlClassifier')\n    ], RelationShip.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Aggregation')\n    ], RelationShip.prototype, \"relationship\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Directional')\n    ], RelationShip.prototype, \"associationType\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, ClassifierMultiplicity)\n    ], RelationShip.prototype, \"multiplicity\", void 0);\n    return RelationShip;\n}(ConnectorShape));\n\n/**\n * Connector shape for blazor\n */\nvar DiagramConnectorShape = /** @class */ (function (_super) {\n    __extends(DiagramConnectorShape, _super);\n    function DiagramConnectorShape() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('None')\n    ], DiagramConnectorShape.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Directional')\n    ], DiagramConnectorShape.prototype, \"associationType\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Aggregation')\n    ], DiagramConnectorShape.prototype, \"relationship\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, ClassifierMultiplicity)\n    ], DiagramConnectorShape.prototype, \"multiplicity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Sequence')\n    ], DiagramConnectorShape.prototype, \"bpmnFlow\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Default')\n    ], DiagramConnectorShape.prototype, \"message\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Normal')\n    ], DiagramConnectorShape.prototype, \"sequence\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Default')\n    ], DiagramConnectorShape.prototype, \"association\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Object')\n    ], DiagramConnectorShape.prototype, \"umlActivityFlow\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(30)\n    ], DiagramConnectorShape.prototype, \"exceptionFlowHeight\", void 0);\n    return DiagramConnectorShape;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Connectors are used to create links between nodes\n */\nvar Connector = /** @class */ (function (_super) {\n    __extends(Connector, _super);\n    // tslint:disable-next-line:no-any\n    function Connector(parent, propName, defaultValue, isArray) {\n        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n        /** @private */\n        _this.parentId = '';\n        /** @private */\n        _this.bridges = [];\n        /** @private */\n        _this.status = 'None';\n        /** @private */\n        _this.outEdges = [];\n        /** @private */\n        _this.inEdges = [];\n        if (_this.shape && _this.shape.type === 'UmlActivity') {\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.setUMLActivityDefaults)(defaultValue, _this);\n        }\n        if (defaultValue && defaultValue.shape && defaultValue.shape.type !== 'None') {\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.setConnectorDefaults)(defaultValue, _this);\n        }\n        return _this;\n    }\n    /* tslint:disable */\n    Connector.prototype.setPortID = function (diagram, isTarget) {\n        if (this.targetID && this.sourceID) {\n            var targetNode = diagram.nameTable[this.targetID];\n            var sourceNode = diagram.nameTable[this.sourceID];\n            var ports = isTarget ? (targetNode && targetNode.ports) : (sourceNode && sourceNode.ports);\n            var port = void 0;\n            for (var i = 0; ports && i < ports.length; i++) {\n                port = ports[parseInt(i.toString(), 10)];\n                if (this.targetPortID === port.id && isTarget) {\n                    if ((port.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_4__.PortConstraints.None) || !(port.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_4__.PortConstraints.InConnect)) {\n                        this.targetPortID = '';\n                    }\n                }\n                else if (this.sourcePortID === port.id && !isTarget) {\n                    if ((port.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_4__.PortConstraints.None) || !(port.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_4__.PortConstraints.OutConnect)) {\n                        this.sourcePortID = '';\n                    }\n                }\n            }\n        }\n    };\n    /* tslint:enable */\n    /** @private */\n    // tslint:disable-next-line:no-any\n    Connector.prototype.init = function (diagram) {\n        if (!this.id) {\n            this.id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_9__.randomId)();\n        }\n        if (this.sourcePortID) {\n            this.setPortID(diagram);\n        }\n        if (this.targetPortID) {\n            this.setPortID(diagram, true);\n        }\n        var bpmnElement;\n        var container = new _core_containers_canvas__WEBPACK_IMPORTED_MODULE_12__.Canvas();\n        var segment = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        segment.id = this.id + '_path';\n        var srcDecorator = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        var targetDecorator = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        segment = this.getSegmentElement(this, segment);\n        //let bounds: Rect;\n        var points = [];\n        points = this.type === 'Bezier' ? this.intermediatePoints : this.getConnectorPoints(this.type);\n        points = this.clipDecorators(this, points);\n        var bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_5__.Rect.toBounds(points);\n        container.width = bounds.width;\n        container.height = bounds.height;\n        container.offsetX = bounds.x + container.pivot.x * bounds.width;\n        container.offsetY = bounds.y + container.pivot.y * bounds.height;\n        switch (this.shape.type) {\n            case 'Bpmn':\n                // eslint-disable-next-line no-case-declarations\n                var flow = this.shape.flow;\n                switch (flow) {\n                    case 'Sequence':\n                        bpmnElement = this.getBpmnSequenceFlow();\n                        break;\n                    case 'Association':\n                        bpmnElement = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n                        bpmnElement.visible = false;\n                        this.getBpmnAssociationFlow();\n                        break;\n                    case 'Message':\n                        bpmnElement = this.getBpmnMessageFlow();\n                        segment = this.getSegmentElement(this, segment);\n                        this.updateShapePosition(this, bpmnElement);\n                        break;\n                }\n                break;\n            case 'UmlActivity':\n                // eslint-disable-next-line no-case-declarations\n                var activityFlow = this.shape.flow;\n                switch (activityFlow) {\n                    case 'Object':\n                        this.getUMLObjectFlow();\n                        break;\n                    case 'Exception':\n                        this.getUMLExceptionFlow(segment);\n                        break;\n                }\n                break;\n            case 'UmlClassifier':\n                this.getConnectorRelation();\n                break;\n        }\n        var anglePoints = this.intermediatePoints;\n        if (this.type === 'Bezier') {\n            var firstSegment = this.segments[0];\n            var lastSegment = this.segments[this.segments.length - 1];\n            anglePoints = [!_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.isEmptyPoint(lastSegment.point2) ? lastSegment.point2 : lastSegment.bezierPoint2,\n                !_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.isEmptyPoint(firstSegment.point1) ? firstSegment.point1 : firstSegment.bezierPoint1];\n        }\n        var accessContent = 'getDescription';\n        var getDescription = diagram[\"\" + accessContent];\n        //const strokeWidth: number = this.sourceWrapper ? this.sourceWrapper.style.strokeWidth / 2 / 2 : 0;\n        srcDecorator = this.getDecoratorElement(points[0], anglePoints[1], this.sourceDecorator, true, getDescription);\n        targetDecorator = this.getDecoratorElement(points[points.length - 1], anglePoints[anglePoints.length - 2], this.targetDecorator, false, getDescription);\n        srcDecorator.id = this.id + '_srcDec';\n        targetDecorator.id = this.id + '_tarDec';\n        segment.style = this.style;\n        /* tslint:disable:no-string-literal */\n        segment.style['fill'] = 'transparent';\n        if (getDescription !== undefined) {\n            // tslint:disable-next-line:no-any\n            var wrapperContent = getDescription(this, diagram);\n            segment.description = wrapperContent ? wrapperContent : this.id;\n        }\n        container.style.strokeColor = 'transparent';\n        container.style.fill = 'transparent';\n        container.style.strokeWidth = 0;\n        container.children = [segment, srcDecorator, targetDecorator];\n        container.id = this.id;\n        if (bpmnElement !== undefined) {\n            container.children.push(bpmnElement);\n        }\n        container.offsetX = segment.offsetX;\n        container.offsetY = segment.offsetY;\n        container.width = segment.width;\n        container.height = segment.height;\n        for (var i = 0; this.annotations !== undefined, i < this.annotations.length; i++) {\n            container.children.push(this.getAnnotationElement(this.annotations[parseInt(i.toString(), 10)], this.intermediatePoints, bounds, getDescription, diagram.element.id, diagram.annotationTemplate));\n        }\n        for (var i = 0; this.fixedUserHandles !== undefined, i < this.fixedUserHandles.length; i++) {\n            container.children.push(this.getFixedUserHandle(this.fixedUserHandles[parseInt(i.toString(), 10)], this.intermediatePoints, bounds, diagram.fixedUserHandleTemplate, diagram.element.id));\n        }\n        // Feature 826644: Support to add ports to the connector.\n        this.initPorts(getDescription, container, bounds);\n        this.wrapper = container;\n        return container;\n    };\n    /** @private */\n    Connector.prototype.initPorts = function (accessibilityContent, container, bounds) {\n        for (var i = 0; this.ports !== undefined, i < this.ports.length; i++) {\n            container.children.push(this.initPort(this.ports[parseInt(i.toString(), 10)], this.intermediatePoints, bounds, accessibilityContent));\n        }\n    };\n    // Feature 826644: Support to add ports to the connector. Added below method to init the connector port.\n    /** @private */\n    Connector.prototype.initPort = function (ports, points, bounds, accessibilityContent) {\n        var portWrapper = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        portWrapper.height = ports.height;\n        portWrapper.width = ports.width;\n        portWrapper.margin = ports.margin;\n        ports.shape = ports.shape || 'Square';\n        var pathdata = (ports.shape === 'Custom') ? ports.pathData : (0,_dictionary_common__WEBPACK_IMPORTED_MODULE_13__.getPortShape)(ports.shape);\n        portWrapper.data = pathdata;\n        portWrapper.horizontalAlignment = ports.horizontalAlignment;\n        portWrapper.verticalAlignment = ports.verticalAlignment;\n        // eslint-disable-next-line prefer-const\n        portWrapper = this.initPortWrapper(ports, points, bounds, portWrapper, this);\n        // tslint:disable-next-line:no-any\n        var wrapperContent;\n        var contentAccessibility = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_9__.getFunction)(accessibilityContent);\n        if (contentAccessibility) {\n            wrapperContent = contentAccessibility(portWrapper, this);\n        }\n        portWrapper.description = wrapperContent ? wrapperContent : portWrapper.id;\n        portWrapper.elementActions = portWrapper.elementActions | _enum_enum__WEBPACK_IMPORTED_MODULE_4__.ElementAction.ElementIsPort;\n        portWrapper.isPathPort = true;\n        return portWrapper;\n    };\n    // Feature 826644: Support to add ports to the connector. Added below method to init the connector portwrapper.\n    /** @private */\n    Connector.prototype.initPortWrapper = function (ports, points, bounds, portContent, Connector) {\n        ports.id = ports.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_9__.randomId)();\n        // Creates port element\n        var pivotPoint = { x: 0, y: 0 };\n        var getPointloop = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getPortsPosition)(points, ports, bounds);\n        var newPoint = getPointloop.point;\n        portContent.id = this.id + '_' + (ports.id);\n        var style = ports.style;\n        portContent.style = {\n            fill: style.fill, strokeColor: style.strokeColor, gradient: null,\n            opacity: style.opacity, strokeDashArray: style.strokeDashArray, strokeWidth: style.strokeWidth\n        };\n        if (bounds.width === 0) {\n            bounds.width = this.style.strokeWidth;\n        }\n        if (bounds.height === 0) {\n            bounds.height = this.style.strokeWidth;\n        }\n        var offsetPoint = { x: ((newPoint.x - bounds.x) / bounds.width), y: ((newPoint.y - bounds.y) / bounds.height) };\n        pivotPoint.x = bounds.width * offsetPoint.x;\n        pivotPoint.y = bounds.height * offsetPoint.y;\n        var align = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.alignLabelOnSegments)(ports, getPointloop.angle, points);\n        var hAlign = align.hAlign;\n        var vAlign = align.vAlign;\n        var horizor;\n        var verzor;\n        if (hAlign === 'left') {\n            horizor = 'Left';\n            pivotPoint.x += ports.displacement.x;\n        }\n        else if (hAlign === 'right') {\n            horizor = 'Right';\n            pivotPoint.x -= ports.displacement.x;\n        }\n        else if (hAlign === 'center') {\n            horizor = 'Center';\n        }\n        if (vAlign === 'top') {\n            verzor = 'Top';\n            pivotPoint.y += ports.displacement.y;\n        }\n        else if (vAlign === 'bottom') {\n            verzor = 'Bottom';\n            pivotPoint.y -= ports.displacement.y;\n        }\n        else if (vAlign === 'center') {\n            verzor = 'Center';\n        }\n        portContent.horizontalAlignment = horizor;\n        portContent.verticalAlignment = verzor;\n        if (Connector && Connector.flipMode !== 'Label' && Connector.flipMode !== 'None') {\n            portContent = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updatePortEdges)(portContent, this.flip, ports);\n        }\n        else {\n            portContent = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updatePortEdges)(portContent, 'None', ports);\n        }\n        portContent.float = true;\n        portContent.connectionDirection = ports.connectionDirection;\n        portContent.setOffsetWithRespectToBounds(pivotPoint.x, pivotPoint.y, 'Absolute');\n        portContent.relativeMode = 'Point';\n        portContent.visible = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.checkPortRestriction)(ports, _enum_enum__WEBPACK_IMPORTED_MODULE_4__.PortVisibility.Visible) &&\n            !(0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.checkPortRestriction)(ports, _enum_enum__WEBPACK_IMPORTED_MODULE_4__.PortVisibility.Hover) && !(0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.checkPortRestriction)(ports, _enum_enum__WEBPACK_IMPORTED_MODULE_4__.PortVisibility.Connect) ? true : false;\n        portContent.elementActions = portContent.elementActions | _enum_enum__WEBPACK_IMPORTED_MODULE_4__.ElementAction.ElementIsPort;\n        return portContent;\n    };\n    Connector.prototype.getConnectorRelation = function () {\n        var shape = this.shape;\n        if (shape.relationship === 'Association') {\n            this.segments[0].type = 'Straight';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'Arrow';\n        }\n        else if (shape.relationship === 'Inheritance') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'Arrow';\n        }\n        else if (shape.relationship === 'Composition') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'Diamond';\n            this.targetDecorator.shape = 'None';\n        }\n        else if (shape.relationship === 'Aggregation') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'Diamond';\n            this.targetDecorator.shape = 'None';\n        }\n        else if (shape.relationship === 'Dependency') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'OpenArrow';\n        }\n        else if (shape.relationship === 'Realization') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if (shape.associationType === 'BiDirectional') {\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'None';\n        }\n        var text1 = '';\n        //let lower: MultiplicityLabelModel;\n        //let upper: MultiplicityLabelModel;\n        var sourceText = '';\n        var targetText = '';\n        var text = '';\n        if (shape.multiplicity.source) {\n            shape.multiplicity.source.lowerBounds = shape.multiplicity.source.lowerBounds;\n            shape.multiplicity.source.upperBounds = shape.multiplicity.source.upperBounds;\n        }\n        if (shape.multiplicity.target) {\n            shape.multiplicity.target.lowerBounds = shape.multiplicity.target.lowerBounds;\n            shape.multiplicity.target.upperBounds = shape.multiplicity.target.upperBounds;\n        }\n        var lower = shape.multiplicity.source;\n        var upper = shape.multiplicity.target;\n        text = lower.upperBounds ? lower.lowerBounds + '...' + lower.upperBounds : lower.lowerBounds;\n        text1 = upper.upperBounds ? upper.lowerBounds + '...' + upper.upperBounds : upper.lowerBounds;\n        if (shape.multiplicity.type === 'ManyToOne') {\n            shape.multiplicity.target.optional = false;\n            sourceText = text ? text : '*';\n            targetText = '1';\n        }\n        if (shape.multiplicity.type === 'OneToMany') {\n            shape.multiplicity.source.optional = false;\n            targetText = text1 ? text1 : '*';\n            sourceText = '1';\n        }\n        //831806 -Added ManyToMany relationship for UML class connector annotation label\n        if (shape.multiplicity.type === 'ManyToMany') {\n            sourceText = text ? text : '*';\n            targetText = text1 ? text1 : '*';\n        }\n        if (shape.multiplicity.type === 'OneToOne') {\n            shape.multiplicity.target.optional = false;\n            shape.multiplicity.source.optional = false;\n            sourceText = '1';\n            targetText = '1';\n        }\n        this.annotations = [\n            {\n                id: this.id + 'sourcelabel', content: sourceText, offset: 0, alignment: 'Before',\n                margin: { right: 5, bottom: 5 }\n            },\n            {\n                id: this.id + 'targetlabel', content: targetText, offset: 1, alignment: 'Before',\n                margin: { right: 5, bottom: 5 }\n            }\n        ];\n    };\n    Connector.prototype.getBpmnSequenceFlow = function () {\n        var segment = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        var pathseq = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        var pathseqData;\n        if ((this.shape.sequence) === 'Normal' && this.type !== 'Bezier') {\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if ((this.shape.sequence) === 'Default') {\n            segment = this.getSegmentElement(this, segment);\n            var anglePoints = this.intermediatePoints;\n            pathseq = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updatePathElement)(anglePoints, this);\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if ((this.shape.sequence) === 'Conditional') {\n            this.targetDecorator.shape = 'Arrow';\n            this.sourceDecorator.shape = 'Diamond';\n            pathseq.id = this.id + this.shape.type;\n        }\n        return pathseq;\n    };\n    /** @private */\n    Connector.prototype.getUMLObjectFlow = function () {\n        if (this.annotations) {\n            for (var i = 0; i < this.annotations.length; i++) {\n                this.annotations[parseInt(i.toString(), 10)].content = '[' + this.annotations[parseInt(i.toString(), 10)].content + ']';\n            }\n        }\n    };\n    /** @private */\n    Connector.prototype.getUMLExceptionFlow = function (segment) {\n        this.type = 'Straight';\n        var height = (this.shape.exceptionFlowHeight) / 2;\n        var midPt = { x: (this.targetPoint.x + this.sourcePoint.x) / 2, y: (this.targetPoint.y + this.sourcePoint.y) / 2 };\n        var xDist = midPt.x - this.sourcePoint.x;\n        var yDist = midPt.y - this.sourcePoint.y;\n        var dist = Math.sqrt(xDist * xDist + yDist * yDist);\n        var fractionOfTotal = (height) / dist;\n        var midPt2 = { x: midPt.x - xDist * fractionOfTotal, y: midPt.y - yDist * fractionOfTotal };\n        var midPt1 = { x: midPt.x + xDist * fractionOfTotal, y: midPt.y + yDist * fractionOfTotal };\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.identityMatrix)();\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.rotateMatrix)(matrix, 315, midPt.x, midPt.y);\n        this.segments = [];\n        var segments = new StraightSegment(this, 'segments', { type: 'Straight', point: (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.transformPointByMatrix)(matrix, midPt1) }, true);\n        (this.segments).push(segments);\n        segments = new StraightSegment(this, 'segments', { type: 'Straight', point: (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.transformPointByMatrix)(matrix, midPt2) }, true);\n        (this.segments).push(segments);\n        segment = this.getSegmentElement(this, segment);\n    };\n    Connector.prototype.getBpmnAssociationFlow = function () {\n        if ((this.shape.association) === 'Default') {\n            this.targetDecorator.shape = 'None';\n            this.style.strokeDashArray = '2 2';\n        }\n        if ((this.shape.association) === 'Directional') {\n            this.targetDecorator.shape = 'OpenArrow';\n            this.style.strokeDashArray = '2 2';\n        }\n        if ((this.shape.association) === 'BiDirectional') {\n            this.targetDecorator.shape = 'OpenArrow';\n            this.sourceDecorator.shape = 'OpenArrow';\n            this.style.strokeDashArray = '2 2';\n        }\n    };\n    // 882378 - Added below code to provide template support for fixedUserHandles in connectors\n    /** @private */\n    Connector.prototype.getFixedUserHandle = function (fixedUserHandle, points, bounds, fixedUserHandleTemplate, diagramId) {\n        var fixedUserHandleContainer;\n        if (fixedUserHandle.pathData === '' && fixedUserHandleTemplate) {\n            fixedUserHandleContainer = new _core_elements_html_element__WEBPACK_IMPORTED_MODULE_17__.DiagramHtmlElement(this.id, diagramId, undefined, fixedUserHandleTemplate);\n            fixedUserHandleContainer.isTemplate = true;\n            fixedUserHandleContainer.template = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_18__.getContent)(fixedUserHandleContainer, true, fixedUserHandle);\n            fixedUserHandle.id = fixedUserHandle.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_9__.randomId)();\n            fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;\n        }\n        else {\n            fixedUserHandleContainer = new _core_containers_canvas__WEBPACK_IMPORTED_MODULE_12__.Canvas();\n            var children = [];\n            fixedUserHandleContainer.children = children;\n            fixedUserHandle.id = fixedUserHandle.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_9__.randomId)();\n            fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;\n            var symbolIcon = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.initFixedUserHandlesSymbol)(fixedUserHandle, fixedUserHandleContainer);\n            fixedUserHandleContainer.children.push(symbolIcon);\n        }\n        fixedUserHandleContainer.float = true;\n        fixedUserHandleContainer.visible = fixedUserHandle.visibility;\n        fixedUserHandleContainer.width = fixedUserHandle.width;\n        fixedUserHandleContainer.height = fixedUserHandle.height;\n        fixedUserHandleContainer.style.strokeWidth = fixedUserHandle.handleStrokeWidth;\n        fixedUserHandleContainer.style.fill = fixedUserHandle.fill;\n        fixedUserHandleContainer.style.strokeColor = fixedUserHandle.handleStrokeColor;\n        fixedUserHandleContainer.cornerRadius = fixedUserHandle.cornerRadius;\n        this.updateAnnotation(fixedUserHandle, points, bounds, fixedUserHandleContainer);\n        fixedUserHandleContainer.description = fixedUserHandleContainer.id;\n        return fixedUserHandleContainer;\n    };\n    Connector.prototype.getBpmnMessageFlow = function () {\n        var segmentMessage = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        this.targetDecorator.shape = 'Arrow';\n        this.targetDecorator.width = 10;\n        this.targetDecorator.height = 10;\n        this.sourceDecorator.shape = 'Circle';\n        this.sourceDecorator.style.fill = 'white';\n        this.targetDecorator.style.fill = 'white';\n        if (((this.shape.message) === 'InitiatingMessage') ||\n            ((this.shape.message) === 'NonInitiatingMessage')) {\n            segmentMessage.id = this.id + '_' + (this.shape.message);\n            segmentMessage.width = 25;\n            segmentMessage.height = 15;\n            segmentMessage.data = 'M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0';\n            segmentMessage.horizontalAlignment = 'Center';\n            segmentMessage.verticalAlignment = 'Center';\n            segmentMessage.transform = _enum_enum__WEBPACK_IMPORTED_MODULE_4__.Transform.Self;\n            segmentMessage.style.fill = (this.shape.message) === 'NonInitiatingMessage' ? 'lightgrey' : 'white';\n        }\n        return segmentMessage;\n    };\n    /** @private */\n    Connector.prototype.distance = function (pt1, pt2) {\n        return (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findDistance)(pt1, pt2);\n    };\n    /**   @private  */\n    Connector.prototype.findPath = function (sourcePt, targetPt) {\n        return (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findPath)(sourcePt, targetPt);\n    };\n    /** @private */\n    Connector.prototype.getAnnotationElement = function (annotation, points, bounds, getDescription, diagramId, annotationTemplate) {\n        annotation.content = annotation.content || '';\n        annotation.id = annotation.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_9__.randomId)();\n        var textele;\n        //Removed isBlazor code\n        if (diagramId && (annotation.template || annotation.annotationType === 'Template'\n            || (annotationTemplate && annotation.content === ''))) {\n            // Task 834121: Content-Security-Policy support for diagram\n            var diagramElement = document.getElementById(diagramId);\n            var instance = 'ej2_instances';\n            var diagram = diagramElement[\"\" + instance][0];\n            textele = new _core_elements_html_element__WEBPACK_IMPORTED_MODULE_17__.DiagramHtmlElement(this.id, diagramId, annotation.id, annotationTemplate);\n            if (annotation.template && typeof annotation.template === 'function' && diagram.isReact) {\n                textele.templateFn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.compile)(annotation.template);\n                textele.isTemplate = true;\n            }\n            //908155-Annotation template update wrongly while do interaction for connector\n            if (annotation.height === undefined && annotation.annotationType === 'String' && (annotation.template || annotation.content === '')) {\n                annotation.height = bounds.height;\n            }\n            textele = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_18__.getTemplateContent)(textele, annotation, annotationTemplate, diagram);\n        }\n        else {\n            textele = new _core_elements_text_element__WEBPACK_IMPORTED_MODULE_3__.TextElement();\n            //876030 - Adding hyperlink for connectors\n            var link = annotation.hyperlink.link ? annotation.hyperlink : undefined;\n            textele.style = annotation.style;\n            textele.style.color = link ? link.color || textele.hyperlink.color : annotation.style.color;\n            textele.hyperlink.link = annotation.hyperlink.link || undefined;\n            textele.hyperlink.hyperlinkOpenState = annotation.hyperlink.hyperlinkOpenState || undefined;\n            textele.hyperlink.textDecoration = annotation.hyperlink.textDecoration || undefined;\n            textele.content = link ? link.content ||\n                textele.hyperlink.link : annotation.content;\n        }\n        textele.constraints = annotation.constraints;\n        textele.visible = annotation.visibility;\n        textele.annotationVisibility = textele.visible ? 'Visible' : 'Collapsed';\n        textele.rotateAngle = annotation.rotateAngle;\n        textele.horizontalAlignment = annotation.horizontalAlignment;\n        textele.verticalAlignment = annotation.verticalAlignment;\n        textele.width = annotation.width;\n        textele.height = annotation.height;\n        if (bounds.width !== undefined && !annotation.template) {\n            textele.width = (annotation.width || bounds.width) - annotation.margin.left - annotation.margin.right;\n        }\n        textele.margin = annotation.margin;\n        textele.id = this.id + '_' + annotation.id;\n        if (bounds.width === 0) {\n            bounds.width = this.style.strokeWidth;\n        }\n        if (bounds.height === 0) {\n            bounds.height = this.style.strokeWidth;\n        }\n        // tslint:disable-next-line:no-any\n        var wrapperContent;\n        var description = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_9__.getFunction)(getDescription);\n        if (description) {\n            wrapperContent = description(annotation, this);\n        }\n        textele.description = wrapperContent ? wrapperContent : textele.id;\n        this.updateAnnotation(annotation, points, bounds, textele);\n        return textele;\n    };\n    /** @private */\n    Connector.prototype.updateAnnotation = function (annotation, points, bounds, textElement, canRefresh) {\n        //let getPointloop: SegmentInfo;\n        //let align: Alignment; let hAlign: string;\n        var pivotPoint = { x: 0, y: 0 };\n        //Bug 881512: Wrapping of the connector annotation at run time not working properly.\n        //To refresh the annotation at run time while moving connector end points or while moving nodes connected with connector.\n        if ((textElement instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_3__.TextElement) && (!canRefresh)) {\n            textElement.refreshTextElement();\n        }\n        textElement.width = (annotation.width || bounds.width);\n        var getPointloop = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getAnnotationPosition)(points, annotation, bounds);\n        var newPoint = getPointloop.point;\n        if (annotation instanceof _annotation__WEBPACK_IMPORTED_MODULE_11__.PathAnnotation && annotation.segmentAngle) {\n            textElement.rotateAngle = annotation.rotateAngle + getPointloop.angle;\n            textElement.rotateAngle = (textElement.rotateAngle + 360) % 360;\n        }\n        if (bounds.width === 0) {\n            bounds.width = this.style.strokeWidth;\n        }\n        if (bounds.height === 0) {\n            bounds.height = this.style.strokeWidth;\n        }\n        var offsetPoint = { x: ((newPoint.x - bounds.x) / bounds.width), y: ((newPoint.y - bounds.y) / bounds.height) };\n        pivotPoint.x = bounds.width * offsetPoint.x;\n        pivotPoint.y = bounds.height * offsetPoint.y;\n        var align = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.alignLabelOnSegments)(annotation, getPointloop.angle, points);\n        var hAlign = align.hAlign;\n        var vAlign = align.vAlign;\n        var horizor;\n        var verzor;\n        if (hAlign === 'left') {\n            horizor = 'Left';\n            pivotPoint.x += annotation.displacement.x;\n        }\n        else if (hAlign === 'right') {\n            horizor = 'Right';\n            pivotPoint.x -= annotation.displacement.x;\n        }\n        else if (hAlign === 'center') {\n            horizor = 'Center';\n        }\n        if (vAlign === 'top') {\n            verzor = 'Top';\n            pivotPoint.y += annotation.displacement.y;\n        }\n        else if (vAlign === 'bottom') {\n            verzor = 'Bottom';\n            pivotPoint.y -= annotation.displacement.y;\n        }\n        else if (vAlign === 'center') {\n            verzor = 'Center';\n        }\n        textElement.horizontalAlignment = horizor;\n        textElement.verticalAlignment = verzor;\n        textElement.setOffsetWithRespectToBounds(pivotPoint.x, pivotPoint.y, 'Absolute');\n        textElement.relativeMode = 'Point';\n    };\n    /** @private */\n    Connector.prototype.getConnectorPoints = function (type, points, layoutOrientation, lineDistribution) {\n        //const width: number = Math.abs(this.sourcePoint.x - this.targetPoint.x);\n        //const height: number = Math.abs(this.sourcePoint.y - this.targetPoint.y);\n        points = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_7__.findConnectorPoints)(this, layoutOrientation, lineDistribution);\n        var newPoints = points.slice(0);\n        if (newPoints && newPoints.length > 0) {\n            this.sourcePoint = newPoints[0];\n            this.targetPoint = newPoints[newPoints.length - 1];\n        }\n        return newPoints;\n    };\n    /** @private */\n    Connector.prototype.clipDecorator = function (connector, points, isSource, diagramAction) {\n        var point = { x: 0, y: 0 };\n        var start = { x: 0, y: 0 };\n        var end = { x: 0, y: 0 };\n        var length = points.length;\n        start = !isSource ? points[length - 1] : points[0];\n        end = !isSource ? points[length - 2] : points[1];\n        var len = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.distancePoints(start, end);\n        len = (len === 0) ? 1 : len;\n        var strokeWidth = 1;\n        var node = isSource ? connector.sourceWrapper : connector.targetWrapper;\n        if (node) {\n            strokeWidth = node.style.strokeWidth;\n            if (diagramAction && ((diagramAction) & _enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramAction.DecoratorPropertyChange)) {\n                strokeWidth = 1;\n            }\n        }\n        var width = strokeWidth - 1;\n        point.x = (Math.round(start.x + width * (end.x - start.x) / len));\n        point.y = (Math.round(start.y + width * (end.y - start.y) / len));\n        if ((isSource && connector.sourceDecorator.shape !== 'None') ||\n            (!isSource && connector.targetDecorator.shape !== 'None')) {\n            point = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.adjustPoint(point, end, true, (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_4__.DiagramAction.DecoratorPropertyChange) ? 0 : (strokeWidth / 2));\n        }\n        return point;\n    };\n    /** @private */\n    Connector.prototype.clipDecorators = function (connector, pts, diagramAction) {\n        if (connector.sourceDecorator.shape !== 'None') {\n            pts[0] = this.clipDecorator(connector, pts, true, diagramAction);\n        }\n        if (connector.targetDecorator.shape !== 'None') {\n            pts[pts.length - 1] = this.clipDecorator(connector, pts, false, diagramAction);\n        }\n        return pts;\n    };\n    /** @private */\n    Connector.prototype.updateSegmentElement = function (connector, points, element, diagramActions) {\n        var bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_5__.Rect();\n        //let point: PointModel[];\n        var segmentPath = this.getSegmentPath(connector, points, diagramActions);\n        if (connector.type === 'Bezier') {\n            if (this.segments.length > 0) {\n                for (var i = 0; i < this.segments.length; i++) {\n                    var segment = this.segments[parseInt(i.toString(), 10)];\n                    var connectorSegment = connector.segments[parseInt(i.toString(), 10)];\n                    // eslint-disable-next-line max-len\n                    var point1 = !_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.isEmptyPoint(segment.point1) ? connectorSegment.point1 : connectorSegment.bezierPoint1;\n                    // eslint-disable-next-line max-len\n                    var point2 = !_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.isEmptyPoint(segment.point2) ? connectorSegment.point2 : connectorSegment.bezierPoint2;\n                    bounds.uniteRect(getBezierBounds(segment.points[0], point1, point2, segment.points[1], connector));\n                }\n            }\n        }\n        else {\n            bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_5__.Rect.toBounds(points);\n        }\n        element.width = bounds.width;\n        element.height = bounds.height;\n        element.offsetX = bounds.x + element.width / 2;\n        element.offsetY = bounds.y + element.height / 2;\n        element.data = segmentPath;\n        if (connector.wrapper) {\n            connector.wrapper.offsetX = element.offsetX;\n            connector.wrapper.offsetY = element.offsetY;\n            connector.wrapper.width = bounds.width;\n            connector.wrapper.height = bounds.height;\n        }\n        return element;\n    };\n    /** @private */\n    Connector.prototype.getSegmentElement = function (connector, segmentElement, layoutOrientation, diagramActions, isFlip) {\n        if (isFlip === void 0) { isFlip = true; }\n        //let bounds: Rect; let segmentPath: string;\n        var points = [];\n        if (isFlip) {\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.flipConnector)(connector);\n        }\n        points = this.getConnectorPoints(connector.type, undefined, layoutOrientation);\n        this.intermediatePoints = points;\n        segmentElement.staticSize = true;\n        segmentElement = this.updateSegmentElement(connector, points, segmentElement, diagramActions);\n        return segmentElement;\n    };\n    /** @private */\n    Connector.prototype.getDecoratorElement = function (offsetPoint, adjacentPoint, decorator, isSource, getDescription) {\n        var decEle = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement();\n        var getPath;\n        var angle;\n        decEle.transform = _enum_enum__WEBPACK_IMPORTED_MODULE_4__.Transform.Self;\n        this.updateDecoratorElement(decEle, offsetPoint, adjacentPoint, decorator);\n        if (getDescription !== undefined) {\n            // tslint:disable-next-line:no-any\n            var wrapperContent = getDescription(decorator, this);\n            decEle.description = wrapperContent ? wrapperContent :\n                ('Specifies the ' + isSource ? 'source' : 0);\n        }\n        return decEle;\n    };\n    Connector.prototype.bridgePath = function (connector, path, pointIndex) {\n        var pathData = path;\n        if (connector.bridges.length > 0) {\n            if (connector.type === 'Straight' && connector.segments.length < 2) {\n                for (var n = 0; n < connector.bridges.length; n++) {\n                    var bridge = connector.bridges[parseInt(n.toString(), 10)];\n                    if (!bridge.rendered) {\n                        pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;\n                        pathData += bridge.path;\n                        bridge.rendered = true;\n                    }\n                }\n            }\n            else if (connector.type === 'Orthogonal' || (connector.type === 'Straight' && connector.segments.length > 1)) {\n                for (var n = 0; n < connector.bridges.length; n++) {\n                    var bridge = connector.bridges[parseInt(n.toString(), 10)];\n                    if (bridge.segmentPointIndex === pointIndex) {\n                        if (!bridge.rendered) {\n                            if (bridge.segmentPointIndex === pointIndex) {\n                                pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;\n                                pathData += bridge.path;\n                                bridge.rendered = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return pathData;\n    };\n    /** @private */\n    Connector.prototype.updateDecoratorElement = function (element, pt, adjacentPoint, decorator) {\n        //let getPath: string;// let angle: number;\n        element.offsetX = pt.x;\n        element.offsetY = pt.y;\n        var angle = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.findAngle(pt, adjacentPoint);\n        var getPath = (0,_dictionary_common__WEBPACK_IMPORTED_MODULE_13__.getDecoratorShape)(decorator.shape, decorator);\n        var size = new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(decorator.width, decorator.height);\n        element.pivot.x = decorator.pivot.x;\n        element.pivot.y = decorator.pivot.y;\n        element.style = decorator.style;\n        element.rotateAngle = angle;\n        element.data = getPath;\n        element.canMeasurePath = true;\n        element.width = size.width;\n        element.height = size.height;\n    };\n    /** @private */\n    Connector.prototype.getSegmentPath = function (connector, points, diagramAction) {\n        var path = '';\n        var getPt;\n        var end;\n        var st;\n        var pts = [];\n        var j = 0;\n        while (j < points.length) {\n            pts.push({ x: points[parseInt(j.toString(), 10)].x, y: points[parseInt(j.toString(), 10)].y });\n            j++;\n        }\n        for (var m = 0; m < connector.bridges.length; m++) {\n            var bridge = connector.bridges[parseInt(m.toString(), 10)];\n            bridge.rendered = false;\n        }\n        pts = this.clipDecorators(connector, pts, diagramAction);\n        if (this.cornerRadius > 0 && this.type !== 'Bezier') {\n            for (var j_1 = 0; j_1 < pts.length - 1; j_1++) {\n                getPt = pts[parseInt(j_1.toString(), 10)];\n                if (j_1 === 0) {\n                    path = 'M' + getPt.x + ' ' + getPt.y;\n                }\n                var segLength = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.distancePoints(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1]);\n                if (segLength > 0) {\n                    if (j_1 < pts.length - 2) {\n                        if (segLength < this.cornerRadius * 2) {\n                            end = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], false, segLength / 2);\n                        }\n                        else {\n                            end = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], false, this.cornerRadius);\n                        }\n                    }\n                    else {\n                        end = pts[j_1 + 1];\n                    }\n                    if (j_1 > 0) {\n                        if (segLength < this.cornerRadius * 2) {\n                            st = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], true, segLength / 2);\n                            if (j_1 < pts.length - 2) {\n                                end = null;\n                            }\n                        }\n                        else {\n                            st = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.adjustPoint(pts[parseInt(j_1.toString(), 10)], pts[j_1 + 1], true, this.cornerRadius);\n                        }\n                    }\n                    if (st) {\n                        path += 'Q' + getPt.x + ' ' + getPt.y + ' ' + st.x + ' ' + st.y;\n                    }\n                    if (end) {\n                        if (connector.bridges.length > 0) {\n                            path = this.bridgePath(connector, path, j_1);\n                            if (connector.type === 'Orthogonal') {\n                                path = this.bridgePath(connector, path, j_1 + 1);\n                            }\n                        }\n                        path += ' L' + end.x + ' ' + end.y;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.type === 'Bezier') {\n                var isrezise = void 0;\n                var isDrawing = void 0;\n                if (this.parentObj.element) {\n                    var action = this.parentObj.element.ej2_instances[0]['eventHandler'].action;\n                    isrezise = (this.parentObj.element.ej2_instances[0]['eventHandler']).tool instanceof _interaction_tool__WEBPACK_IMPORTED_MODULE_21__.ResizeTool;\n                    isDrawing = action.includes('PortDraw') || action.includes('Drag');\n                }\n                var direction = void 0;\n                var segments = this.segments;\n                for (var j_2 = 0; j_2 < segments.length; j_2++) {\n                    if (pts.length > 2) {\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint1 = { x: 0, y: 0 };\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint2 = { x: 0, y: 0 };\n                    }\n                    if (_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.isEmptyPoint(segments[parseInt(j_2.toString(), 10)].point1) &&\n                        !segments[parseInt(j_2.toString(), 10)].vector1.angle && !segments[parseInt(j_2.toString(), 10)].vector1.distance) {\n                        if ((connector.sourceID || this.sourcePortID) && this.sourceWrapper && !isDrawing && !isrezise) {\n                            direction = getDirection(this.sourceWrapper.bounds, pts[parseInt(j_2.toString(), 10)], true);\n                        }\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint1 = getBezierPoints(pts[parseInt(j_2.toString(), 10)], pts[j_2 + 1], direction);\n                    }\n                    else if (segments[parseInt(j_2.toString(), 10)].vector1.angle\n                        || segments[parseInt(j_2.toString(), 10)].vector1.distance) {\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint1\n                            = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.transform(pts[parseInt(j_2.toString(), 10)], segments[parseInt(j_2.toString(), 10)].vector1.angle, segments[parseInt(j_2.toString(), 10)].vector1.distance);\n                    }\n                    else {\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint1 = {\n                            x: segments[parseInt(j_2.toString(), 10)].point1.x || segments[parseInt(j_2.toString(), 10)].bezierPoint1.x,\n                            y: segments[parseInt(j_2.toString(), 10)].point1.y || segments[parseInt(j_2.toString(), 10)].bezierPoint1.y\n                        };\n                    }\n                    if (_primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.isEmptyPoint(segments[parseInt(j_2.toString(), 10)].point2) &&\n                        !segments[parseInt(j_2.toString(), 10)].vector2.angle && !segments[parseInt(j_2.toString(), 10)].vector2.distance) {\n                        if ((connector.targetID || this.targetPortID) && this.targetWrapper && !isDrawing && !isrezise) {\n                            direction = getDirection(this.targetWrapper.bounds, pts[j_2 + 1], true);\n                        }\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint2 = getBezierPoints(pts[j_2 + 1], pts[parseInt(j_2.toString(), 10)], direction);\n                    }\n                    else if (segments[parseInt(j_2.toString(), 10)].vector2.angle\n                        || segments[parseInt(j_2.toString(), 10)].vector2.distance) {\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint2\n                            = _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point.transform(pts[j_2 + 1], segments[parseInt(j_2.toString(), 10)].vector2.angle, segments[parseInt(j_2.toString(), 10)].vector2.distance);\n                    }\n                    else {\n                        segments[parseInt(j_2.toString(), 10)].bezierPoint2 = {\n                            x: segments[parseInt(j_2.toString(), 10)].point2.x || segments[parseInt(j_2.toString(), 10)].bezierPoint2.x,\n                            y: segments[parseInt(j_2.toString(), 10)].point2.y || segments[parseInt(j_2.toString(), 10)].bezierPoint2.y\n                        };\n                    }\n                }\n                pts.splice(1, 0, { x: segments[0].bezierPoint1.x, y: segments[0].bezierPoint1.y });\n                pts.splice(pts.length - 1, 0, {\n                    x: segments[segments.length - 1].bezierPoint2.x, y: segments[segments.length - 1].bezierPoint2.y\n                });\n                pts = this.clipDecorators(connector, pts, diagramAction);\n                for (var j_3 = 0; j_3 < segments.length; j_3++) {\n                    if (j_3 === 0) {\n                        path = 'M' + pts[0].x + ' ' + pts[0].y;\n                    }\n                    var lastPoint = (j_3 === segments.length - 1) ? pts[pts.length - 1].x + ' ' + pts[pts.length - 1].y :\n                        segments[parseInt(j_3.toString(), 10)].points[segments[parseInt(j_3.toString(), 10)].points.length - 1].x + ' ' + segments[parseInt(j_3.toString(), 10)].points[segments[parseInt(j_3.toString(), 10)].points.length - 1].y;\n                    path += 'C' +\n                        segments[parseInt(j_3.toString(), 10)].bezierPoint1.x + ' ' + segments[parseInt(j_3.toString(), 10)].bezierPoint1.y + ' ' + segments[parseInt(j_3.toString(), 10)].bezierPoint2.x + ' '\n                        + segments[parseInt(j_3.toString(), 10)].bezierPoint2.y + ' ' + lastPoint;\n                }\n            }\n            else {\n                for (var k = 0; k < pts.length; k++) {\n                    getPt = pts[parseInt(k.toString(), 10)];\n                    if (k === 0) {\n                        path = 'M' + getPt.x + ' ' + getPt.y;\n                    }\n                    if (k > 0) {\n                        path = this.bridgePath(connector, path, k);\n                        path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n                    }\n                }\n            }\n        }\n        return path;\n    };\n    /** @private */\n    Connector.prototype.updateShapeElement = function (connector) {\n        var element;\n        switch (connector.shape.type) {\n            case 'Bpmn':\n                if (connector.wrapper.children[3] instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_10__.PathElement) {\n                    element = connector.wrapper.children[3];\n                }\n                if (connector.shape.flow === 'Message') {\n                    this.updateShapePosition(connector, element);\n                }\n                break;\n            case 'UmlActivity':\n                if (connector.shape.flow === 'Exception') {\n                    this.getUMLExceptionFlow(connector.wrapper.children[0]);\n                }\n                break;\n        }\n    };\n    /** @private */\n    Connector.prototype.updateShapePosition = function (connector, element) {\n        var segmentOffset = 0.5;\n        var angle;\n        var pt;\n        var length = 0;\n        var anglePoints = this.intermediatePoints;\n        //Bug 860251: Bpmn message flow and sequence flow connector child path is not rendered properly.\n        //To get the path offset of message flow.\n        var offset = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getPathOffset)(anglePoints, element, segmentOffset);\n        element.offsetX = offset.x;\n        element.offsetY = offset.y;\n    };\n    /** @hidden */\n    Connector.prototype.scale = function (sw, sh, width, height, refObject) {\n        var tx = 0;\n        var ty = 0;\n        if (this.wrapper && this.wrapper.outerBounds) {\n            var outerBounds = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_7__.getOuterBounds)(this);\n            // EJ2-56887 - Connector do not get rendered properly in symbol palette.\n            // Added the absolute command to change the connector height to positive if it is in negative value.\n            var connWidth = Math.abs((this.wrapper.bounds.width || this.style.strokeWidth || 1) - 2);\n            var connHeight = Math.abs((this.wrapper.bounds.height || this.style.strokeWidth || 1) - 2);\n            tx = (outerBounds.width - connWidth);\n            ty = (outerBounds.height - connHeight);\n            sw = Math.abs((width - (Math.max(tx, ty))) / connWidth);\n            sh = Math.abs((height - (Math.max(tx, ty))) / connHeight);\n            tx = ty = Math.min(tx, ty);\n        }\n        sw = sh = Math.min(sw, sh);\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.identityMatrix)();\n        refObject = refObject || this.wrapper;\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.rotateMatrix)(matrix, -refObject.rotateAngle, refObject.offsetX, refObject.offsetY);\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.scaleMatrix)(matrix, sw, sh, refObject.offsetX, refObject.offsetY);\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.rotateMatrix)(matrix, refObject.rotateAngle, refObject.offsetX, refObject.offsetY);\n        var points = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_16__.transformPointsByMatrix)(matrix, this.intermediatePoints);\n        this.sourcePoint = points[0];\n        this.targetPoint = points[points.length - 1];\n        points = this.intermediatePoints = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_7__.findConnectorPoints)(this);\n        (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateConnector)(this, points);\n        return { x: tx, y: ty };\n    };\n    /**\n     * @private\n     * Returns the name of class Connector\n     */\n    Connector.prototype.getClassName = function () {\n        return 'Connector';\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ComplexFactory)(getConnectorType)\n    ], Connector.prototype, \"shape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(_enum_enum__WEBPACK_IMPORTED_MODULE_4__.ConnectorConstraints.Default)\n    ], Connector.prototype, \"constraints\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], Connector.prototype, \"bridgeSpace\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], _annotation__WEBPACK_IMPORTED_MODULE_11__.PathAnnotation)\n    ], Connector.prototype, \"annotations\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], Connector.prototype, \"sourcePoint\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _primitives_point__WEBPACK_IMPORTED_MODULE_2__.Point)\n    ], Connector.prototype, \"targetPoint\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], _fixed_user_handle__WEBPACK_IMPORTED_MODULE_20__.ConnectorFixedUserHandle)\n    ], Connector.prototype, \"fixedUserHandles\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.CollectionFactory)(getSegmentType)\n    ], Connector.prototype, \"segments\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Connector.prototype, \"sourceID\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Connector.prototype, \"targetID\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], Connector.prototype, \"hitPadding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Connector.prototype, \"connectionPadding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Straight')\n    ], Connector.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Circle')\n    ], Connector.prototype, \"segmentThumbShape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], Connector.prototype, \"segmentThumbSize\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Connector.prototype, \"cornerRadius\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ shape: 'None' }, Decorator)\n    ], Connector.prototype, \"sourceDecorator\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ shape: 'Arrow' }, Decorator)\n    ], Connector.prototype, \"targetDecorator\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _tooltip__WEBPACK_IMPORTED_MODULE_15__.DiagramTooltip)\n    ], Connector.prototype, \"tooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Connector.prototype, \"sourcePortID\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Connector.prototype, \"targetPortID\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Connector.prototype, \"sourcePadding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _preview__WEBPACK_IMPORTED_MODULE_19__.SymbolSize)\n    ], Connector.prototype, \"previewSize\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _preview__WEBPACK_IMPORTED_MODULE_19__.SymbolSize)\n    ], Connector.prototype, \"dragSize\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Connector.prototype, \"targetPadding\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(13)\n    ], Connector.prototype, \"connectorSpacing\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ strokeWidth: 1, strokeColor: 'black' }, _core_appearance__WEBPACK_IMPORTED_MODULE_1__.StrokeStyle)\n    ], Connector.prototype, \"style\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Connector.prototype, \"maxSegmentThumb\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], Connector.prototype, \"allowNodeOverlap\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, BezierSettings)\n    ], Connector.prototype, \"bezierSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], _port__WEBPACK_IMPORTED_MODULE_22__.PathPort)\n    ], Connector.prototype, \"ports\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Connector.prototype, \"wrapper\", void 0);\n    return Connector;\n}(_node_base__WEBPACK_IMPORTED_MODULE_14__.NodeBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js?");

/***/ })

}]);