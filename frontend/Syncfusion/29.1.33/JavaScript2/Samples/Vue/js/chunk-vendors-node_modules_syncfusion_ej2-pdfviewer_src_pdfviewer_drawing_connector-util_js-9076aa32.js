"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_drawing_connector-util_js-9076aa32"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/connector-util.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/connector-util.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clipDecorator: () => (/* binding */ clipDecorator),\n/* harmony export */   clipDecorators: () => (/* binding */ clipDecorators),\n/* harmony export */   findNearestPoint: () => (/* binding */ findNearestPoint),\n/* harmony export */   getConnectorPoints: () => (/* binding */ getConnectorPoints),\n/* harmony export */   getDecoratorElement: () => (/* binding */ getDecoratorElement),\n/* harmony export */   getDecoratorShape: () => (/* binding */ getDecoratorShape),\n/* harmony export */   getPolygonPath: () => (/* binding */ getPolygonPath),\n/* harmony export */   getSegmentElement: () => (/* binding */ getSegmentElement),\n/* harmony export */   getSegmentPath: () => (/* binding */ getSegmentPath),\n/* harmony export */   initDistanceLabel: () => (/* binding */ initDistanceLabel),\n/* harmony export */   initLeader: () => (/* binding */ initLeader),\n/* harmony export */   initLeaders: () => (/* binding */ initLeaders),\n/* harmony export */   initPerimeterLabel: () => (/* binding */ initPerimeterLabel),\n/* harmony export */   isPointOverConnector: () => (/* binding */ isPointOverConnector),\n/* harmony export */   removePerimeterLabel: () => (/* binding */ removePerimeterLabel),\n/* harmony export */   textElement: () => (/* binding */ textElement),\n/* harmony export */   updateCalibrateLabel: () => (/* binding */ updateCalibrateLabel),\n/* harmony export */   updateDecoratorElement: () => (/* binding */ updateDecoratorElement),\n/* harmony export */   updateDistanceLabel: () => (/* binding */ updateDistanceLabel),\n/* harmony export */   updatePerimeterLabel: () => (/* binding */ updatePerimeterLabel),\n/* harmony export */   updateRadiusLabel: () => (/* binding */ updateRadiusLabel),\n/* harmony export */   updateSegmentElement: () => (/* binding */ updateSegmentElement)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-drawings */ \"./node_modules/@syncfusion/ej2-drawings/index.js\");\n/* harmony import */ var _drawing_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawing-util */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/drawing-util.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {PointModel[]} - Returns the annotation points model array.\n */\nfunction getConnectorPoints(obj, points) {\n    points = obj.vertexPoints;\n    var newPoints = points.slice(0);\n    if (newPoints && newPoints.length > 0) {\n        obj.sourcePoint = newPoints[0];\n        obj.targetPoint = newPoints[newPoints.length - 1];\n    }\n    return newPoints;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {string} - Returns the annotation path value.\n */\nfunction getSegmentPath(connector, points) {\n    var path = '';\n    var getPt;\n    var pts = [];\n    var j = 0;\n    while (j < points.length) {\n        pts.push({ x: points[parseInt(j.toString(), 10)].x, y: points[parseInt(j.toString(), 10)].y });\n        j++;\n    }\n    pts = clipDecorators(connector, pts);\n    for (var k = 0; k < pts.length; k++) {\n        getPt = pts[parseInt(k.toString(), 10)];\n        if (k === 0) {\n            path = 'M' + getPt.x + ' ' + getPt.y;\n        }\n        if (k > 0) {\n            path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n        }\n    }\n    return path;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @param {PathElement} element - Specified the annotation element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nfunction updateSegmentElement(connector, points, element) {\n    var bounds = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Rect();\n    var segmentPath = getSegmentPath(connector, points);\n    bounds = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Rect.toBounds(points);\n    element.width = bounds.width;\n    element.height = bounds.height;\n    element.offsetX = bounds.x + element.width / 2;\n    element.offsetY = bounds.y + element.height / 2;\n    element.data = segmentPath;\n    if (connector.wrapper) {\n        connector.wrapper.offsetX = element.offsetX;\n        connector.wrapper.offsetY = element.offsetY;\n        var boundsValue = bounds.width;\n        if (bounds.width < bounds.height) {\n            boundsValue = bounds.height;\n        }\n        else {\n            boundsValue = bounds.width;\n        }\n        connector.wrapper.width = connector.enableShapeLabel ? boundsValue / 2 : boundsValue;\n        connector.wrapper.height = bounds.height;\n    }\n    return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PathElement} segmentElement - Specified the annotation segment element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nfunction getSegmentElement(connector, segmentElement) {\n    var points = [];\n    points = getConnectorPoints(connector);\n    segmentElement.staticSize = true;\n    segmentElement = updateSegmentElement(connector, points, segmentElement);\n    (0,_drawing_util__WEBPACK_IMPORTED_MODULE_1__.setElementStype)(connector, segmentElement);\n    return segmentElement;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {DrawingElement} element - Specified the annotation drawing element.\n * @param {PointModel} pt - Specified the annotation point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {void}\n */\nfunction updateDecoratorElement(obj, element, pt, adjacentPoint, isSource) {\n    element.offsetX = pt.x;\n    element.offsetY = pt.y;\n    var angle = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(pt, adjacentPoint);\n    var getPath = getDecoratorShape(isSource ? obj.sourceDecoraterShapes : obj.taregetDecoraterShapes);\n    var thickness = 0;\n    var size;\n    if (obj.shapeAnnotationType === 'LineWidthArrowHead' || obj.shapeAnnotationType === 'Line') {\n        thickness = obj.thickness;\n        size = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Size(thickness * 12, thickness * 12);\n    }\n    else {\n        thickness = obj.thickness <= 5 ? 5 : obj.thickness;\n        size = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Size(thickness * 2, thickness * 2);\n    }\n    element.transform = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.RotateTransform.Self;\n    (0,_drawing_util__WEBPACK_IMPORTED_MODULE_1__.setElementStype)(obj, element);\n    element.style.fill = (obj.fillColor !== 'tranparent') ? obj.fillColor : 'white';\n    element.rotateAngle = angle;\n    element.data = getPath;\n    element.canMeasurePath = true;\n    element.width = size.width;\n    element.height = size.height;\n    if (obj.sourceDecoraterShapes === 'Butt') {\n        element.width = size.width - 10;\n        element.height = size.height + 10;\n    }\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} offsetPoint - Specified the annotation offset point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PathElement} - Returns the annotation path element.\n */\nfunction getDecoratorElement(obj, offsetPoint, adjacentPoint, isSource) {\n    var decEle = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.PathElement();\n    updateDecoratorElement(obj, decEle, offsetPoint, adjacentPoint, isSource);\n    return decEle;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation object.\n * @param {PointModel[]} pts - Specified the annotation point model array.\n * @returns {PointModel[]} - Returns the annotation point model array.\n */\nfunction clipDecorators(connector, pts) {\n    pts[0] = clipDecorator(connector, pts, true);\n    pts[pts.length - 1] = clipDecorator(connector, pts, false);\n    return pts;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel[]} points - Specified the annotation offset point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PointModel} - Returns the annotation point model.\n */\nfunction clipDecorator(connector, points, isSource) {\n    var point = { x: 0, y: 0 };\n    var start = { x: 0, y: 0 };\n    var end = { x: 0, y: 0 };\n    var length = points.length;\n    start = !isSource ? points[length - 1] : points[0];\n    end = !isSource ? points[length - 2] : points[1];\n    var len = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.distancePoints(start, end);\n    len = (len === 0) ? 1 : len;\n    var width = connector.thickness;\n    point.x = (Math.round(start.x + width * (end.x - start.x) / len));\n    point.y = (Math.round(start.y + width * (end.y - start.y) / len));\n    var strokeWidth = 1;\n    point = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.adjustPoint(point, end, true, (strokeWidth / 2));\n    return point;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\nfunction initDistanceLabel(obj, points, measure, pdfviewer) {\n    var labels = [];\n    var angle = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(points[0], points[1]);\n    var textele = textElement(obj, angle);\n    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n        textele.content = obj.notes;\n    }\n    else {\n        textele.content = measure.setConversion((0,_drawing_util__WEBPACK_IMPORTED_MODULE_1__.findPointsLength)([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n    }\n    textele.rotateValue = { y: -10, angle: angle };\n    if (obj.enableShapeLabel === true) {\n        textele.style.strokeColor = obj.labelBorderColor;\n        textele.style.fill = obj.labelFillColor;\n        textele.style.fontSize = obj.fontSize;\n        textele.style.color = obj.fontColor;\n        textele.style.fontFamily = obj.fontFamily;\n    }\n    labels.push(textele);\n    return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the distance value.\n */\nfunction updateDistanceLabel(obj, points, measure) {\n    var distance;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_1 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_1 && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(textElement_1.content)) {\n            distance = measure.setConversion((0,_drawing_util__WEBPACK_IMPORTED_MODULE_1__.findPointsLength)([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n            textElement_1.content = distance;\n            textElement_1.childNodes[0].text = textElement_1.content;\n            textElement_1.refreshTextElement();\n        }\n    }\n    return distance;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the radius label value.\n */\nfunction updateRadiusLabel(obj, measure) {\n    var radius;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_2 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_2 && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(textElement_2.content)) {\n            radius = measure.setConversion((obj.bounds.width / 2) * measure.pixelToPointFactor, obj);\n            textElement_2.content = radius;\n            if (textElement_2.childNodes.length === 2) {\n                textElement_2.childNodes[0].text = radius;\n                textElement_2.childNodes.splice(textElement_2.childNodes.length - 1, 1);\n            }\n            else {\n                textElement_2.childNodes[0].text = radius;\n            }\n            textElement_2.refreshTextElement();\n        }\n    }\n    return radius;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\nfunction initPerimeterLabel(obj, points, measure, pdfviewer) {\n    var labels = [];\n    var angle = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(points[0], points[1]);\n    var textele = textElement(obj, angle);\n    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n        textele.content = obj.notes;\n    }\n    else {\n        textele.content = measure.calculatePerimeter(obj);\n    }\n    if (obj.enableShapeLabel === true) {\n        textele.style.strokeColor = obj.labelBorderColor;\n        textele.style.fill = obj.labelFillColor;\n        textele.style.fontSize = obj.fontSize;\n        textele.style.color = obj.fontColor;\n        textele.style.fontFamily = obj.fontFamily;\n    }\n    textele.rotateValue = { y: -10, angle: angle };\n    labels.push(textele);\n    return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the perimeter label value.\n */\nfunction updatePerimeterLabel(obj, points, measure) {\n    var perimeter;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_3 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_3 && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(textElement_3.content)) {\n            perimeter = measure.calculatePerimeter(obj);\n            textElement_3.content = perimeter;\n            textElement_3.childNodes[0].text = textElement_3.content;\n            textElement_3.refreshTextElement();\n        }\n    }\n    return perimeter;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nfunction removePerimeterLabel(obj) {\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_4 = obj.wrapper.children[parseInt(i.toString(), 10)];\n        if (textElement_4 && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(textElement_4.content)) {\n            obj.wrapper.children.splice(i, 1);\n        }\n    }\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nfunction updateCalibrateLabel(obj) {\n    if (obj.wrapper && obj.wrapper.children) {\n        for (var i = 0; i < obj.wrapper.children.length; i++) {\n            var textElement_5 = obj.wrapper.children[parseInt(i.toString(), 10)];\n            if (textElement_5 && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(textElement_5.content)) {\n                textElement_5.content = obj.notes;\n                textElement_5.childNodes[0].text = textElement_5.content;\n                textElement_5.refreshTextElement();\n            }\n        }\n    }\n}\n/**\n * Used to find the path for polygon shapes\n *\n * @param {PointModel[]} collection - Specified the polygon annotaion points collection.\n * @hidden\n * @returns {string} - Returns the polygon annotation path.\n */\nfunction getPolygonPath(collection) {\n    var path = '';\n    var seg;\n    path = 'M' + collection[0].x + ' ' + collection[0].y;\n    var i;\n    for (i = 1; i < collection.length; i++) {\n        seg = collection[parseInt(i.toString(), 10)];\n        path += 'L' + seg.x + ' ' + seg.y;\n    }\n    path += 'Z';\n    return path;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {number} angle - Specified the annotaion rotation angle.\n * @hidden\n * @returns {TextElement} - Returns the annotation text element.\n */\nfunction textElement(obj, angle) {\n    var textele = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.TextElement();\n    (0,_drawing_util__WEBPACK_IMPORTED_MODULE_1__.setElementStype)(obj, textele);\n    textele.style.fill = 'transparent';\n    textele.id = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.randomId)();\n    textele.horizontalAlignment = 'Center';\n    textele.rotateValue = { y: 10, angle: angle };\n    textele.verticalAlignment = 'Top';\n    textele.relativeMode = 'Object';\n    textele.setOffsetWithRespectToBounds(.5, .5, 'Absolute');\n    // eslint-disable-next-line\n    textele.offsetX;\n    textele.style.textWrapping = 'NoWrap';\n    return textele;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotaion leader points.\n * @hidden\n * @returns {PathElement[]} - Returns the annotation path elements.\n */\nfunction initLeaders(obj, points) {\n    var leaders = [];\n    var leader = initLeader(obj, points[0], points[1]);\n    leaders.push(leader);\n    leader = initLeader(obj, points[1], points[0], true);\n    leaders.push(leader);\n    return leaders;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} point1 - Specified the annotaion leader point1.\n * @param {PointModel} point2 - Specified the annotaion leader point2.\n * @param {boolean} isSecondLeader - Specified the is second leader or not.\n * @hidden\n * @returns {PathElement} - Returns the annotation path element.\n */\nfunction initLeader(obj, point1, point2, isSecondLeader) {\n    var element = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.PathElement();\n    element.offsetX = point1.x;\n    element.offsetY = point1.y;\n    var angle = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(point1, point2);\n    var center = { x: (point1.x + point2.x) / 2, y: (point1.y + point2.y) / 2 };\n    var matrix = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.identityMatrix)();\n    (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.rotateMatrix)(matrix, 0 - angle, center.x, center.y);\n    var rotatedPoint = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, point1);\n    var newPoint1 = { x: rotatedPoint.x, y: rotatedPoint.y - obj.leaderHeight };\n    matrix = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.identityMatrix)();\n    (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.rotateMatrix)(matrix, angle, element.offsetX, element.offsetY);\n    rotatedPoint = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, newPoint1);\n    var finalPoint = { x: point1.x, y: point1.y };\n    element.offsetX = finalPoint.x;\n    element.offsetY = finalPoint.y;\n    element.transform = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.RotateTransform.Self;\n    var getPath = 'M' + point1.x + ',' + point1.y + ',L' + rotatedPoint.x + ',' + rotatedPoint.y + 'Z';\n    var size = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Size(0, obj.leaderHeight);\n    element.pivot.x = .5;\n    if (isSecondLeader) {\n        element.id = 'leader2_' + (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.randomId)();\n        element.pivot.y = 0;\n    }\n    else {\n        element.id = 'leader1_' + (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.randomId)();\n        element.pivot.y = 1;\n    }\n    (0,_drawing_util__WEBPACK_IMPORTED_MODULE_1__.setElementStype)(obj, element);\n    element.rotateAngle = angle;\n    element.data = getPath;\n    element.canMeasurePath = true;\n    element.width = size.width;\n    element.height = size.height;\n    return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel} reference - Specified the pointer reference value.\n * @returns {boolean} - Returns true or false.\n */\nfunction isPointOverConnector(connector, reference) {\n    var vertexPoints = connector.vertexPoints;\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(vertexPoints)) {\n        for (var i = 0; i < vertexPoints.length - 1; i++) {\n            var start = vertexPoints[parseInt(i.toString(), 10)];\n            var end = vertexPoints[i + 1];\n            var rect = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Rect.toBounds([start, end]);\n            rect.Inflate(10);\n            if (rect.containsPoint(reference)) {\n                var intersectinPt = findNearestPoint(reference, start, end);\n                var segment1 = { x1: start.x, x2: end.x, y1: start.y, y2: end.y };\n                var segment2 = { x1: reference.x, x2: intersectinPt.x, y1: reference.y, y2: intersectinPt.y };\n                var intersectDetails = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.intersect3)(segment1, segment2);\n                if (intersectDetails.enabled) {\n                    var distance = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(reference, intersectDetails.intersectPt);\n                    if (Math.abs(distance) < 10) {\n                        return true;\n                    }\n                }\n                else {\n                    var rect_1 = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Rect.toBounds([reference, reference]);\n                    rect_1.Inflate(3);\n                    if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {\n                        return true;\n                    }\n                }\n                if (_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.equals(reference, intersectinPt)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n/**\n * @param {PointModel} reference - Specified the pointer reference value.\n * @param {PointModel} start - Specified the pointer start value.\n * @param {PointModel} end - Specified the pointer end value.\n * @private\n * @returns {PointModel} - Returns annotation point model.\n */\nfunction findNearestPoint(reference, start, end) {\n    var shortestPoint;\n    var shortest = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(start, reference);\n    var shortest1 = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(end, reference);\n    if (shortest > shortest1) {\n        shortestPoint = end;\n    }\n    else {\n        shortestPoint = start;\n    }\n    var angleBWStAndEnd = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(start, end);\n    var angleBWStAndRef = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(shortestPoint, reference);\n    var r = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findLength(shortestPoint, reference);\n    var vaAngle = angleBWStAndRef + ((angleBWStAndEnd - angleBWStAndRef) * 2);\n    return {\n        x: (shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180)),\n        y: (shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180))\n    };\n}\n/**\n * @param {DecoratorShapes} shape - Specified the annotation decorator shapes.\n * @hidden\n * @returns {string} - Returns the annotation decorator shape value.\n */\nfunction getDecoratorShape(shape) {\n    return decoratorShapes[\"\" + shape];\n}\nvar decoratorShapes = {\n    'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',\n    'Square': 'M0,0 L10,0 L10,10 L0,10 z',\n    'Fletch': 'M14.8,10c0,0-3.5,6,0.2,12c0,0-2.5-6-10.9-6C4.1,16,11.3,16,14.8,10z',\n    'OpenFetch': 'M6,17c-0.6,0-1-0.4-1-1s0.4-1,1-1c10.9,0,11-5,11-5' +\n        'c0-0.6,0.4-1,1-1s1,0.4,1,1C19,10.3,18.9,17,6,17C6,17,6,17,6,17z ' +\n        'M18,23c-0.5,0-1-0.4-1-1c0-0.2-0.3-5-11-5c-0.6,0-1-0.5-1-1s0.4-1,1-1c0,0,0,0,0,0' +\n        'c12.9,0,13,6.7,13,7    C19,22.6,18.6,23,18,23z',\n    'IndentedArrow': 'M17,10c0,0-4.5,5.5,0,12L5,16L17,10z',\n    'OutdentedArrow': 'M14.6,10c0,0,5.4,6,0,12L5,16L14.6,10z',\n    'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',\n    'Arrow': 'M15,10 L15,22 L5,16Z',\n    'Diamond': 'M12,23l-7-7l7-7l6.9,7L12,23z',\n    'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z',\n    'Butt': 'M0,0 L0,90'\n};\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/connector-util.js?");

/***/ })

}]);