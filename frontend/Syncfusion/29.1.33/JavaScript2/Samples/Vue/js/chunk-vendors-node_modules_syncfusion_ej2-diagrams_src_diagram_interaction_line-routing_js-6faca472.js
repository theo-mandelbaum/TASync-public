"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_line-routing_js-6faca472"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-routing.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-routing.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineRouting: () => (/* binding */ LineRouting)\n/* harmony export */ });\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _utility_connector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js\");\n/* harmony import */ var _utility_constraints_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utility/constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n\n\n\n/**\n * Line Routing\n */\nvar LineRouting = /** @class */ (function () {\n    /**\n     * Constructor for the line routing module\n     *\n     * @private\n     */\n    function LineRouting() {\n        this.size = 20;\n        this.intermediatePoints = [];\n        this.gridCollection = [];\n        this.startArray = [];\n        this.targetGridCollection = [];\n        this.sourceGridCollection = [];\n        this.considerWalkable = [];\n        this.skipObstacleCheck = false;\n        //constructs the line routing module\n    }\n    /**\n     * lineRouting method \\\n     *\n     * @returns { void }     lineRouting method .\\\n     * @param {Diagram} diagram - provide the source value.\n     *\n     * @private\n     */\n    LineRouting.prototype.lineRouting = function (diagram) {\n        var length = diagram.connectors.length;\n        this.renderVirtualRegion(diagram);\n        if (length > 0) {\n            for (var k = 0; k < length; k++) {\n                var connector = diagram.connectors[parseInt(k.toString(), 10)];\n                if (connector.type === 'Orthogonal' && connector.visible) {\n                    this.refreshConnectorSegments(diagram, connector, true);\n                }\n            }\n        }\n    };\n    /** @private */\n    /**\n     * renderVirtualRegion method \\\n     *\n     * @returns { void }     renderVirtualRegion method .\\\n     * @param {Diagram} diagram - provide the source value.\n     * @param {boolean} isUpdate - provide the target value.\n     *\n     * @private\n     */\n    LineRouting.prototype.renderVirtualRegion = function (diagram, isUpdate) {\n        /* tslint:disable */\n        var extraBounds = this.size;\n        if (diagram.spatialSearch['pageTop'] < 0 || diagram.spatialSearch['pageLeft'] < 0) {\n            extraBounds = this.size + (this.size / 2);\n        }\n        var right = diagram.spatialSearch['pageRight'] + extraBounds;\n        var bottom = diagram.spatialSearch['pageBottom'] + extraBounds;\n        var left = diagram.spatialSearch['pageLeft'] - extraBounds;\n        var top = diagram.spatialSearch['pageTop'] - extraBounds;\n        left = left < 0 ? left - 20 : 0;\n        top = top < 0 ? top - 20 : 0;\n        /* tslint:enable */\n        if ((isUpdate && (this.width !== (right - left) || this.height !== (bottom - top) ||\n            this.diagramStartX !== left || this.diagramStartY !== top)) || isUpdate === undefined) {\n            this.width = right - left;\n            this.height = bottom - top;\n            this.diagramStartX = left;\n            this.diagramStartY = top;\n            this.gridCollection = [];\n            this.noOfRows = this.width / this.size;\n            this.noOfCols = this.height / this.size;\n            var size = this.size;\n            var x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n            var y = this.diagramStartY < 0 ? this.diagramStartY : 0;\n            for (var i = 0; i < this.noOfCols; i++) {\n                for (var j = 0; j < this.noOfRows; j++) {\n                    if (i === 0) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        this.gridCollection.push([0]);\n                    }\n                    var grid = {\n                        x: x, y: y, width: size, height: size, gridX: j,\n                        gridY: i, walkable: true, tested: undefined, nodeId: []\n                    };\n                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)] = grid;\n                    x += size;\n                }\n                x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n                y += size;\n            }\n        }\n        var nodes = this.findNodes(diagram.nodes);\n        this.updateNodesInVirtualRegion(nodes);\n    };\n    LineRouting.prototype.findNodes = function (nodes) {\n        var objects = [];\n        var node;\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[parseInt(i.toString(), 10)];\n            if (node.shape.type !== 'SwimLane' && !node.isLane && !node.isPhase && !node.isHeader && node.visible) {\n                objects.push(node);\n            }\n        }\n        return objects;\n    };\n    LineRouting.prototype.updateNodesInVirtualRegion = function (diagramNodes) {\n        var size = this.size;\n        var x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n        var y = this.diagramStartY < 0 ? this.diagramStartY : 0;\n        for (var i = 0; i < this.noOfCols; i++) {\n            for (var j = 0; j < this.noOfRows; j++) {\n                var grid = this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)];\n                var rectangle = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(x, y, this.size, this.size);\n                var isContains = void 0;\n                var k = void 0;\n                grid.walkable = true;\n                grid.tested = undefined;\n                grid.nodeId = [];\n                for (k = 0; k < diagramNodes.length; k++) {\n                    if (diagramNodes[parseInt(k.toString(), 10)].wrapper.bounds) {\n                        isContains = this.intersectRect(rectangle, diagramNodes[parseInt(k.toString(), 10)].wrapper.bounds);\n                    }\n                    if (isContains) {\n                        grid.nodeId.push(diagramNodes[parseInt(k.toString(), 10)].id);\n                        grid.walkable = false;\n                        if (diagramNodes[parseInt(k.toString(), 10)].parentId !== '') {\n                            grid.parentNodeId = diagramNodes[parseInt(k.toString(), 10)].parentId;\n                        }\n                    }\n                }\n                x += size;\n            }\n            x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n            y += size;\n        }\n    };\n    LineRouting.prototype.intersectRect = function (r1, r2) {\n        return !(r2.left >= r1.right || r2.right <= r1.left ||\n            r2.top >= r1.bottom || r2.bottom <= r1.top);\n    };\n    LineRouting.prototype.findEndPoint = function (connector, isSource, isPortBounds) {\n        var endPoint;\n        var portDirection;\n        // EJ2-65876 - Exception occurs on line routing injection module\n        if ((isSource && connector.sourcePortID !== '' && connector.sourcePortWrapper) || (!isSource && connector.targetPortID !== '' && connector.targetPortWrapper)) {\n            endPoint = (isSource) ? { x: connector.sourcePortWrapper.offsetX, y: connector.sourcePortWrapper.offsetY } :\n                { x: connector.targetPortWrapper.offsetX, y: connector.targetPortWrapper.offsetY };\n            portDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getPortDirection)(endPoint, undefined, (isSource) ? connector.sourceWrapper.bounds : connector.targetWrapper.bounds, false);\n            var bounds = (isSource) ? connector.sourcePortWrapper.bounds : connector.targetPortWrapper.bounds;\n            if (isPortBounds) {\n                if (portDirection === 'Top') {\n                    endPoint = { x: bounds.topCenter.x, y: bounds.topCenter.y };\n                }\n                else if (portDirection === 'Left') {\n                    endPoint = { x: bounds.middleLeft.x, y: bounds.middleLeft.y };\n                }\n                else if (portDirection === 'Right') {\n                    endPoint = { x: bounds.middleRight.x, y: bounds.middleRight.y };\n                }\n                else {\n                    endPoint = { x: bounds.bottomCenter.x, y: bounds.bottomCenter.y };\n                }\n            }\n            else {\n                endPoint = { x: bounds.center.x, y: bounds.center.y };\n            }\n        }\n        else {\n            if ((isSource && this.startNode) || (!isSource && this.targetNode)) {\n                endPoint = (isSource) ? { x: this.startNode.wrapper.offsetX, y: this.startNode.wrapper.offsetY } :\n                    { x: this.targetNode.wrapper.offsetX, y: this.targetNode.wrapper.offsetY };\n            }\n            else {\n                endPoint = (isSource) ? { x: connector.sourcePoint.x, y: connector.sourcePoint.y } :\n                    { x: connector.targetPoint.x, y: connector.targetPoint.y };\n            }\n        }\n        return endPoint;\n    };\n    /**\n     * Gets the grids that intersect with the line segment defined by the start and end points.\n     * @param {PointModel} startPoint - The starting point of the line segment.\n     * @param {PointModel} endPoint - The ending point of the line segment.\n     * @returns {VirtualBoundaries[]} An array of VirtualBoundaries that intersect with the line segment.\n     * @private\n     */\n    LineRouting.prototype.getGridsIntersect = function (startPoint, endPoint) {\n        var grids = [];\n        var minX = Math.min(startPoint.x, endPoint.x);\n        var minY = Math.min(startPoint.y, endPoint.y);\n        var maxX = Math.max(startPoint.x, endPoint.x);\n        var maxY = Math.max(startPoint.y, endPoint.y);\n        var gridSize = this.size;\n        var minGridX = Math.floor((minX - this.diagramStartX) / gridSize);\n        var minGridY = Math.floor((minY - this.diagramStartY) / gridSize);\n        var maxGridX = Math.floor((maxX - this.diagramStartX) / gridSize);\n        var maxGridY = Math.floor((maxY - this.diagramStartY) / gridSize);\n        var isHorizontal = maxX - minX > maxY - minY;\n        if (isHorizontal) {\n            for (var x = minGridX; x <= maxGridX; x++) {\n                var gridRow = this.gridCollection[parseInt(x.toString(), 10)];\n                if (gridRow) {\n                    var grid = gridRow[parseInt(minGridY.toString(), 10)];\n                    if (grid && grids.indexOf(grid) === -1) {\n                        grids.push(grid);\n                    }\n                }\n            }\n        }\n        else {\n            for (var y = minGridY; y <= maxGridY; y++) {\n                var gridRow = this.gridCollection[parseInt(minGridX.toString(), 10)];\n                if (gridRow) {\n                    var grid = gridRow[parseInt(y.toString(), 10)];\n                    if (grid && grids.indexOf(grid) === -1) {\n                        grids.push(grid);\n                    }\n                }\n            }\n        }\n        return grids;\n    };\n    /**\n     * Checks if the path between the start and end points is walkable.\n     * @param {PointModel} startPoint - The starting point of the path.\n     * @param {PointModel} endPoint - The ending point of the path.\n     * @param {Diagram} diagram - The diagram instance.\n     * @param {Connector} [connector] - The connector to check for obstacles.\n     * @returns {boolean} True if the path is walkable, otherwise false.\n     * @private\n     */\n    LineRouting.prototype.isPathWalkable = function (startPoint, endPoint, diagram, connector) {\n        var minX = Math.min(startPoint.x, endPoint.x);\n        var minY = Math.min(startPoint.y, endPoint.y);\n        var maxX = Math.max(startPoint.x, endPoint.x);\n        var maxY = Math.max(startPoint.y, endPoint.y);\n        var grids = this.getGridsIntersect(startPoint, endPoint);\n        for (var i = 0; i < grids.length; i++) {\n            var grid = grids[parseInt(i.toString(), 10)];\n            // Exclude grids that contain the source or target node\n            if (connector && (grid.nodeId.indexOf(connector.sourceID) !== -1 || grid.nodeId.indexOf(connector.targetID) !== -1)) {\n                continue;\n            }\n            if (!grid.walkable) {\n                var isHorizontal = maxX - minX > maxY - minY;\n                for (var _i = 0, _a = grid.nodeId; _i < _a.length; _i++) {\n                    var nodeId = _a[_i];\n                    var node = diagram.nameTable[\"\" + nodeId];\n                    if (node) {\n                        var bounds = node.wrapper.bounds;\n                        var padding = 5;\n                        if (isHorizontal) {\n                            if (bounds.top - padding < minY && bounds.bottom + padding > maxY) {\n                                return false;\n                            }\n                        }\n                        else {\n                            if (bounds.left - padding < minX && bounds.right + padding > maxX) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    };\n    LineRouting.prototype.checkObstaclesIntersect = function (segmentPoints, connector, diagram) {\n        for (var i = 1; i < segmentPoints.length; i++) {\n            var start = segmentPoints[i - 1];\n            var end = segmentPoints[parseInt(i.toString(), 10)];\n            if (!this.isPathWalkable(start, end, diagram, connector)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * refreshConnectorSegments method \\\n     *\n     * @returns { void }     refreshConnectorSegments method .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     * @param {Connector} connector - provide the connector value.\n     * @param {boolean} isUpdate - provide the diagram value.\n     * @param {boolean} isEnableRouting - provide enableRouting value.\n     *\n     * @private\n     */\n    LineRouting.prototype.refreshConnectorSegments = function (diagram, connector, isUpdate, isEnableRouting) {\n        if (!connector.sourceID || !connector.targetID || connector.sourceID === connector.targetID) {\n            return;\n        }\n        if (!this.skipObstacleCheck && connector.segments && connector.segments.length < 2 && connector.intermediatePoints\n            && this.checkObstaclesIntersect(connector.intermediatePoints, connector, diagram)) {\n            if (diagram.avoidLineOverlappingModule && isUpdate) {\n                diagram.avoidLineOverlappingModule.addConnector(connector);\n                diagram.avoidLineOverlappingModule.refreshModifiedConnectors(diagram);\n            }\n            return;\n        }\n        var sourceId = connector.sourceID;\n        var targetId = connector.targetID;\n        var sourcePortID = connector.sourcePortID;\n        var targetPortID = connector.targetPortID;\n        var startPoint;\n        var targetPoint;\n        var sourcePortDirection;\n        var targetPortDirection;\n        var grid;\n        var sourceTop;\n        var sourceBottom;\n        var isBreak;\n        var sourceLeft;\n        var sourceRight;\n        var targetRight;\n        var targetTop;\n        var targetBottom;\n        var targetLeft;\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_2__.canEnableRouting)(connector, diagram) || isEnableRouting) {\n            this.startNode = diagram.nameTable[\"\" + sourceId];\n            this.targetNode = diagram.nameTable[\"\" + targetId];\n            this.intermediatePoints = [];\n            this.startArray = [];\n            this.targetGridCollection = [];\n            this.sourceGridCollection = [];\n            this.startGrid = undefined;\n            this.targetGrid = undefined;\n            for (var i = 0; i < this.noOfCols; i++) {\n                for (var j = 0; j < this.noOfRows; j++) {\n                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].tested\n                        = this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].parent = undefined;\n                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].previousDistance\n                        = this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].afterDistance = undefined;\n                    this.gridCollection[parseInt(j.toString(), 10)][parseInt(i.toString(), 10)].totalDistance = undefined;\n                }\n            }\n            // Set the source point and target point\n            startPoint = this.findEndPoint(connector, true);\n            targetPoint = this.findEndPoint(connector, false);\n            // Find the start grid and target grid\n            for (var i = 0; i < this.noOfRows; i++) {\n                for (var j = 0; j < this.noOfCols; j++) {\n                    grid = this.gridCollection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)];\n                    var rectangle = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(grid.x, grid.y, grid.width, grid.height);\n                    if (rectangle.containsPoint(startPoint) && !this.startGrid &&\n                        (grid.nodeId.indexOf(sourceId) !== -1 || sourceId === '')) {\n                        this.startGrid = (sourcePortID && this.startGrid &&\n                            (sourcePortDirection === 'Left' || sourcePortDirection === 'Top')) ? this.startGrid : grid;\n                    }\n                    if (rectangle.containsPoint(targetPoint) && !this.targetGrid &&\n                        (grid.nodeId.indexOf(targetId) !== -1 || targetId === '')) {\n                        this.targetGrid = (targetPortID && this.targetGrid &&\n                            (targetPortDirection === 'Left' || targetPortDirection === 'Top')) ? this.targetGrid : grid;\n                    }\n                    if (!sourcePortID && this.startNode) {\n                        var bounds = this.startNode.wrapper.bounds;\n                        if (rectangle.containsPoint(bounds.topCenter) && !sourceTop) {\n                            sourceTop = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleLeft) && !sourceLeft) {\n                            sourceLeft = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleRight) && !sourceRight) {\n                            sourceRight = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.bottomCenter) && !sourceBottom) {\n                            sourceBottom = grid;\n                        }\n                    }\n                    if (!targetPortID && this.targetNode) {\n                        var bounds = this.targetNode.wrapper.bounds;\n                        if (rectangle.containsPoint(bounds.topCenter) && !targetTop) {\n                            targetTop = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleLeft) && !targetLeft) {\n                            targetLeft = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleRight) && !targetRight) {\n                            targetRight = grid;\n                        }\n                        if (rectangle.containsPoint({ x: bounds.bottomCenter.x, y: bounds.bottomCenter.y }) && !targetBottom) {\n                            targetBottom = grid;\n                        }\n                    }\n                }\n            }\n            this.findEdgeBoundary(sourcePortID, sourceLeft, sourceRight, sourceTop, sourceBottom, true);\n            this.findEdgeBoundary(targetPortID, targetLeft, targetRight, targetTop, targetBottom, false);\n            this.startGrid.totalDistance = 0;\n            this.startGrid.previousDistance = 0;\n            this.intermediatePoints.push({ x: this.startGrid.gridX, y: this.startGrid.gridY });\n            this.startArray.push(this.startGrid);\n            if (connector && targetLeft && targetRight && targetTop && targetBottom) {\n                this.checkObstacles(connector, diagram, targetLeft, targetRight, targetTop, targetBottom);\n            }\n            // eslint-disable-next-line no-labels\n            renderPathElement: while (this.startArray.length > 0) {\n                var startGridNode = this.startArray.pop();\n                //890444:Exception thrown while drag and drop shapes on top of each other repeatedly with Line Routing\n                if (startGridNode) {\n                    for (var i = 0; i < this.targetGridCollection.length; i++) {\n                        var target = this.targetGridCollection[parseInt(i.toString(), 10)];\n                        if (startGridNode) {\n                            if (startGridNode.gridX === target.gridX && startGridNode.gridY === target.gridY) {\n                                this.getIntermediatePoints(startGridNode);\n                                this.optimizeIntermediatePoints();\n                                if (startGridNode.nodeId && startGridNode.nodeId.length > 1) {\n                                    connector.segments = [];\n                                }\n                                isBreak = this.updateConnectorSegments(diagram, this.intermediatePoints, this.gridCollection, connector, isUpdate);\n                                if (!isBreak) {\n                                    this.targetGridCollection.splice(this.targetGridCollection.indexOf(target), 1);\n                                    startGridNode = this.startArray.pop();\n                                }\n                                else {\n                                    this.considerWalkable = [];\n                                    // eslint-disable-next-line no-labels\n                                    break renderPathElement;\n                                }\n                            }\n                        }\n                    }\n                    if (startGridNode) {\n                        this.findPath(startGridNode);\n                    }\n                }\n            }\n        }\n    };\n    LineRouting.prototype.checkChildNodes = function (grid, isSource) {\n        var check = false;\n        var reject = false;\n        if (grid.nodeId.length >= 1 && !isSource) {\n            for (var i = 0; i < grid.nodeId.length; i++) {\n                var id = grid.nodeId[parseInt(i.toString(), 10)];\n                for (var j = 0; j < grid.nodeId.length; j++) {\n                    if (this.targetNode.parentId === grid.nodeId[parseInt(j.toString(), 10)]) {\n                        reject = true;\n                    }\n                }\n                if (!reject && this.targetNode.id === id) {\n                    check = true;\n                }\n                else {\n                    check = false;\n                }\n            }\n        }\n        else {\n            if (grid.nodeId.length === 1) {\n                check = true;\n            }\n        }\n        return check;\n    };\n    LineRouting.prototype.findEdgeBoundary = function (portID, left, right, top, bottom, isSource) {\n        var grid;\n        var collection = (isSource) ? this.sourceGridCollection : this.targetGridCollection;\n        if (!portID && ((isSource) ? this.startNode : this.targetNode)) {\n            for (var i = left.gridX; i <= right.gridX; i++) {\n                grid = this.gridCollection[parseInt(i.toString(), 10)][left.gridY];\n                if ((this.checkChildNodes(grid, isSource) && (i === left.gridX || i === right.gridX)) ||\n                    (i !== left.gridX && i !== right.gridX)) {\n                    collection.push(grid);\n                }\n            }\n            for (var i = top.gridY; i <= bottom.gridY; i++) {\n                grid = this.gridCollection[top.gridX][parseInt(i.toString(), 10)];\n                if (((this.checkChildNodes(grid, isSource) && (i === top.gridY || i === bottom.gridY)) ||\n                    (i !== top.gridY && i !== bottom.gridY)) && collection.indexOf(grid) === -1) {\n                    collection.push(grid);\n                }\n            }\n        }\n        else {\n            collection.push((isSource) ? this.startGrid : this.targetGrid);\n        }\n    };\n    LineRouting.prototype.checkObstacles = function (connector, diagram, targetLeft, targetRight, targetTop, targetBottom) {\n        var neigbours = this.findNearestNeigbours(this.startGrid, this.gridCollection, true);\n        if (neigbours.length === 0) {\n            if (connector.sourcePortID !== '') {\n                var endPoint = { x: connector.sourcePortWrapper.offsetX, y: connector.sourcePortWrapper.offsetY };\n                var portDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getPortDirection)(endPoint, undefined, connector.sourceWrapper.bounds, false);\n                if (portDirection === 'Top') {\n                    this.resetGridColl(this.startGrid, 'top', true);\n                }\n                else if (portDirection === 'Right') {\n                    this.resetGridColl(this.startGrid, 'right', true);\n                }\n                else if (portDirection === 'Bottom') {\n                    this.resetGridColl(this.startGrid, 'bottom', true);\n                }\n                else {\n                    this.resetGridColl(this.startGrid, 'left', true);\n                }\n            }\n            else {\n                this.resetGridColl(this.startGrid, 'top', true);\n                this.resetGridColl(this.startGrid, 'right', true);\n                this.resetGridColl(this.startGrid, 'bottom', true);\n                this.resetGridColl(this.startGrid, 'left', true);\n            }\n        }\n        neigbours = this.findNearestNeigbours(this.targetGrid, this.gridCollection, false);\n        if (neigbours.length === 0) {\n            if (connector.targetPortID !== '') {\n                var endPoint = { x: connector.targetPortWrapper.offsetX, y: connector.targetPortWrapper.offsetY };\n                var portDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getPortDirection)(endPoint, undefined, connector.targetWrapper.bounds, false);\n                if (portDirection === 'Top') {\n                    this.resetGridColl(this.targetGrid, 'top', true);\n                }\n                else if (portDirection === 'Right') {\n                    this.resetGridColl(this.targetGrid, 'right', true);\n                }\n                else if (portDirection === 'Bottom') {\n                    this.resetGridColl(this.targetGrid, 'bottom', true);\n                }\n                else {\n                    this.resetGridColl(this.targetGrid, 'left', true);\n                }\n            }\n            else {\n                this.resetGridColl(this.targetGrid, 'top', false);\n                this.resetGridColl(this.targetGrid, 'right', false);\n                this.resetGridColl(this.targetGrid, 'bottom', false);\n                this.resetGridColl(this.targetGrid, 'left', false);\n            }\n        }\n        if (this.targetGridCollection.length > 1 && this.targetGridCollection[0].nodeId.length > 1) {\n            for (var i = 0; i <= 1; i++) {\n                var gridX = this.targetGridCollection[parseInt(i.toString(), 10)].gridX;\n                var gridY = this.targetGridCollection[parseInt(i.toString(), 10)].gridY;\n                var gridNodes = this.targetGridCollection[parseInt(i.toString(), 10)].nodeId;\n                var targetNode = void 0;\n                for (var k = 0; k < gridNodes.length; k++) {\n                    if (this.targetNode.id !== gridNodes[parseInt(k.toString(), 10)]) {\n                        targetNode = gridNodes[parseInt(k.toString(), 10)];\n                        break;\n                    }\n                }\n                var targetNodewrapper = void 0;\n                var overLapNode = void 0;\n                var contains = void 0;\n                if (diagram.nameTable[this.targetNode.id]) {\n                    targetNodewrapper = diagram.nameTable[this.targetNode.id].wrapper;\n                }\n                if (diagram.nameTable[\"\" + targetNode]) {\n                    overLapNode = diagram.nameTable[\"\" + targetNode].wrapper;\n                }\n                if (targetNodewrapper && overLapNode) {\n                    contains = this.contains(overLapNode.bounds, targetNodewrapper.bounds);\n                }\n                var reject = void 0;\n                for (var j = 0; j < gridNodes.length; j++) {\n                    if (this.targetNode.parentId === gridNodes[parseInt(j.toString(), 10)]) {\n                        reject = true;\n                    }\n                }\n                if (!this.gridCollection[parseInt(gridX.toString(), 10)][parseInt(gridY.toString(), 10)].walkable && contains && !reject) {\n                    var grid = void 0;\n                    var diff = void 0;\n                    grid = this.getEndvalue(targetLeft, 'left');\n                    diff = targetLeft.gridX - grid.gridX;\n                    this.changeValue(targetLeft, diff, 'left');\n                    grid = this.getEndvalue(targetRight, 'right');\n                    diff = grid.gridX - targetRight.gridX;\n                    this.changeValue(targetRight, diff, 'right');\n                    grid = this.getEndvalue(targetTop, 'top');\n                    diff = targetTop.gridY - grid.gridY;\n                    this.changeValue(targetTop, diff, 'top');\n                    grid = this.getEndvalue(targetBottom, 'bottom');\n                    diff = targetBottom.gridY - grid.gridY;\n                    this.changeValue(targetBottom, diff, 'top');\n                }\n            }\n        }\n    };\n    LineRouting.prototype.contains = function (rect1, rect2) {\n        return rect1.left <= rect2.left && rect1.right >= rect2.right && rect1.top <= rect2.top && rect1.bottom >= rect2.bottom;\n    };\n    LineRouting.prototype.getEndvalue = function (target, direction) {\n        if (!this.gridCollection[target.gridX][target.gridY].walkable) {\n            if (direction === 'left') {\n                return this.getEndvalue(this.gridCollection[target.gridX - 1][target.gridY], direction);\n            }\n            if (direction === 'right') {\n                return this.getEndvalue(this.gridCollection[target.gridX + 1][target.gridY], direction);\n            }\n            if (direction === 'top') {\n                return this.getEndvalue(this.gridCollection[target.gridX][target.gridY - 1], direction);\n            }\n            if (direction === 'bottom') {\n                return this.getEndvalue(this.gridCollection[target.gridX][target.gridY + 1], direction);\n            }\n        }\n        else {\n            return target;\n        }\n        return target;\n    };\n    LineRouting.prototype.changeValue = function (targetLeft, diff, direction) {\n        if (!targetLeft.walkable) {\n            this.considerWalkable.push(targetLeft);\n        }\n        var grid;\n        for (var i = 0; i <= diff; i++) {\n            if (direction === 'left') {\n                grid = this.gridCollection[targetLeft.gridX - i][targetLeft.gridY];\n            }\n            else if (direction === 'right') {\n                grid = this.gridCollection[targetLeft.gridX + i][targetLeft.gridY];\n            }\n            else if (direction === 'top') {\n                grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY - i];\n            }\n            else if (direction === 'bottom') {\n                grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY + i];\n            }\n            if (!grid.walkable) {\n                this.considerWalkable.push(grid);\n            }\n        }\n    };\n    // Get all the intermediated points from target grid\n    LineRouting.prototype.getIntermediatePoints = function (target) {\n        var distance;\n        this.intermediatePoints = [];\n        while (target) {\n            this.intermediatePoints.push({ x: target.gridX, y: target.gridY });\n            target = target.parent;\n        }\n        this.intermediatePoints.reverse();\n        //890444: Exception thrown while drag and drop shapes on top of each other repeatedly with Line Routing\n        if (this.intermediatePoints.length >= 1 && this.intermediatePoints[0] !== undefined\n            && this.intermediatePoints[1] !== undefined) {\n            if (this.intermediatePoints[0].x === this.intermediatePoints[1].x) {\n                if (this.intermediatePoints[0].y < this.intermediatePoints[1].y) {\n                    distance = this.neigbour(this.startGrid, 'bottom', undefined, true);\n                    this.intermediatePoints[0].y += distance - 1;\n                }\n                else {\n                    distance = this.neigbour(this.startGrid, 'top', undefined, true);\n                    this.intermediatePoints[0].y -= distance - 1;\n                }\n            }\n            else {\n                if (this.intermediatePoints[0].x < this.intermediatePoints[1].x) {\n                    distance = this.neigbour(this.startGrid, 'right', undefined, true);\n                    this.intermediatePoints[0].x += distance - 1;\n                }\n                else {\n                    distance = this.neigbour(this.startGrid, 'left', undefined, true);\n                    this.intermediatePoints[0].x -= distance - 1;\n                }\n            }\n        }\n    };\n    LineRouting.prototype.optimizeIntermediatePoints = function () {\n        this.intermediatePoints = this.removePointsInSameLine(this.intermediatePoints);\n        this.intermediatePoints = this.getValidPoints(this.intermediatePoints);\n    };\n    LineRouting.prototype.removePointsInSameLine = function (points) {\n        if (points.length < 3) {\n            return points;\n        }\n        var result = [points[0]];\n        for (var i = 1; i < points.length - 1; i++) {\n            var prevPoint = result[result.length - 1];\n            var currentPoint = points[parseInt(i.toString(), 10)];\n            var nextPoint = points[i + 1];\n            if (!this.arePointsInSameLine(prevPoint, currentPoint, nextPoint)) {\n                result.push(currentPoint);\n            }\n        }\n        result.push(points[points.length - 1]);\n        return result;\n    };\n    LineRouting.prototype.arePointsInSameLine = function (point1, point2, point3) {\n        return (point2.x - point1.x) * (point3.y - point1.y) === (point3.x - point1.x) * (point2.y - point1.y);\n    };\n    LineRouting.prototype.getValidPoints = function (points) {\n        if (points.length < 4) {\n            return points;\n        }\n        var i = 1;\n        while (i < points.length - 3) {\n            var lineStart1 = points[parseInt(i.toString(), 10)];\n            var lineEnd1 = points[i + 1];\n            var lineStart2 = points[i + 2];\n            var lineEnd2 = points[i + 3];\n            if (lineStart1.x === lineEnd1.x) {\n                if ((lineEnd1.y < lineStart1.y && lineEnd2.y < lineStart2.y)\n                    || (lineEnd1.y > lineStart1.y && lineEnd2.y > lineStart2.y)) {\n                    var dx = lineStart1.x < lineStart2.x ? 1 : -1;\n                    var dy = lineEnd1.y < lineStart1.y ? -1 : 1;\n                    var neigbourGridX = lineStart1.x + dx;\n                    var neigbourGridY = lineStart1.y;\n                    var isValid = false;\n                    while (neigbourGridX !== lineEnd2.x || neigbourGridY !== lineEnd2.y) {\n                        if (!this.isWalkable(neigbourGridX, neigbourGridY)) {\n                            isValid = false;\n                            break;\n                        }\n                        else {\n                            isValid = true;\n                        }\n                        if (neigbourGridX !== lineStart2.x) {\n                            neigbourGridX += dx;\n                        }\n                        else {\n                            neigbourGridY += dy;\n                        }\n                    }\n                    if (isValid) {\n                        lineStart1.x = lineStart2.x;\n                        points.splice(i + 1, 2);\n                        continue;\n                    }\n                }\n            }\n            else if (lineStart1.y === lineEnd1.y) {\n                if ((lineEnd1.x < lineStart1.x && lineEnd2.x < lineStart2.x)\n                    || (lineEnd1.x > lineStart1.x && lineEnd2.x > lineStart2.x)) {\n                    var dy1 = lineStart1.y < lineStart2.y ? 1 : -1;\n                    var dx1 = lineEnd1.x < lineStart1.x ? -1 : 1;\n                    var neigbourGridY1 = lineStart1.y + dy1;\n                    var neigbourGridX1 = lineStart1.x;\n                    var isValid1 = false;\n                    while (neigbourGridX1 !== lineEnd2.x || neigbourGridY1 !== lineEnd2.y) {\n                        if (!this.isWalkable(neigbourGridX1, neigbourGridY1)) {\n                            isValid1 = false;\n                            break;\n                        }\n                        else {\n                            isValid1 = true;\n                        }\n                        if (neigbourGridY1 !== lineStart2.y) {\n                            neigbourGridY1 += dy1;\n                        }\n                        else {\n                            neigbourGridX1 += dx1;\n                        }\n                    }\n                    if (isValid1) {\n                        lineStart1.y = lineStart2.y;\n                        points.splice(i + 1, 2);\n                        continue;\n                    }\n                }\n            }\n            i++;\n        }\n        return points;\n    };\n    // Connector rendering\n    /* tslint:disable */\n    LineRouting.prototype.updateConnectorSegments = function (diagram, intermediatePoints, gridCollection, connector, isUpdate) {\n        var segments = [];\n        var seg;\n        var targetPoint;\n        var pointX;\n        var pointY;\n        var node;\n        var points = [];\n        var direction;\n        var length;\n        var currentdirection;\n        var prevDirection;\n        var targetWrapper = connector.targetWrapper;\n        var sourceWrapper = connector.sourceWrapper;\n        var sourcePoint = this.findEndPoint(connector, true);\n        if (connector.targetPortID !== '' || !connector.targetWrapper) {\n            targetPoint = this.findEndPoint(connector, false, true);\n        }\n        for (var i = 0; i < intermediatePoints.length; i++) {\n            node = gridCollection[intermediatePoints[parseInt(i.toString(), 10)].x][intermediatePoints[parseInt(i.toString(), 10)].y];\n            if (node) {\n                pointX = node.x + node.width / 2;\n                pointY = node.y + node.height / 2;\n                points.push({ x: pointX, y: pointY });\n                if (i >= 1 && points.length > 1) {\n                    if (points[points.length - 2].x !== points[points.length - 1].x) {\n                        currentdirection = (points[points.length - 2].x > points[points.length - 1].x) ? 'Left' : 'Right';\n                    }\n                    else {\n                        currentdirection = (points[points.length - 2].y > points[points.length - 1].y) ? 'Top' : 'Bottom';\n                    }\n                }\n                if (i >= 2 && prevDirection === currentdirection && points.length > 1) {\n                    points.splice(points.length - 2, 1);\n                }\n                prevDirection = currentdirection;\n            }\n        }\n        if (points && points.length > 1) {\n            for (var j = 0; j < points.length - 1; j++) {\n                var currentPoint = points[parseInt(j.toString(), 10)];\n                var nextPoint = points[j + 1];\n                if (currentPoint.x !== nextPoint.x) {\n                    if (j === 0 && connector.sourcePortID === '' && sourceWrapper) {\n                        sourcePoint = (currentPoint.x > nextPoint.x)\n                            ? sourceWrapper.bounds.middleLeft : sourceWrapper.bounds.middleRight;\n                    }\n                    if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {\n                        targetPoint = (currentPoint.x > nextPoint.x)\n                            ? targetWrapper.bounds.middleRight : targetWrapper.bounds.middleLeft;\n                    }\n                    if (j === 0 && sourcePoint) {\n                        currentPoint.x = sourcePoint.x;\n                        currentPoint.y = nextPoint.y = sourcePoint.y;\n                        //Bug:849859 -set node bounds as source point if intersected point exists inside the node\n                        if (connector.sourcePortID === '') {\n                            var newDirection = currentPoint.x > nextPoint.x ? 'Left' : 'Right';\n                            var refPoint = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.findPoint)(sourceWrapper.bounds, (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(newDirection));\n                            sourcePoint = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(connector, sourceWrapper, sourcePoint, refPoint, false);\n                        }\n                        currentPoint.x = sourcePoint.x;\n                    }\n                    if (j === points.length - 2 && targetPoint) {\n                        if (j > 0 && connector.targetDecorator &&\n                            ((targetPoint.x - nextPoint.x) < 0) &&\n                            (Math.abs(targetPoint.x - currentPoint.x) < connector.targetDecorator.width + 1)) {\n                            currentPoint.x = points[j - 1].x -= this.size / 2;\n                        }\n                        if (j > 0 && connector.targetDecorator &&\n                            ((targetPoint.x - nextPoint.x) > 0) &&\n                            (Math.abs(targetPoint.x - currentPoint.x) < connector.targetDecorator.width + 1)) {\n                            currentPoint.x = points[j - 1].x += this.size / 2;\n                        }\n                        nextPoint.x = targetPoint.x;\n                        currentPoint.y = nextPoint.y = targetPoint.y;\n                    }\n                }\n                else {\n                    //EJ2-855805 - Connector target decorator is not proper in complexhierarchical layout when we call doLayout with line-routing\n                    if (j === 0 && connector.sourcePortID === '' && sourceWrapper) {\n                        sourcePoint = (currentPoint.y > nextPoint.y)\n                            ? sourceWrapper.bounds.topCenter : sourceWrapper.bounds.bottomCenter;\n                    }\n                    if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {\n                        targetPoint = (currentPoint.y > nextPoint.y)\n                            ? targetWrapper.bounds.bottomCenter : targetWrapper.bounds.topCenter;\n                    }\n                    if (j === 0 && sourcePoint) {\n                        currentPoint.y = sourcePoint.y;\n                        currentPoint.x = nextPoint.x = sourcePoint.x;\n                        //Bug:849859 -set node bounds as source point if intersected point exists inside the node\n                        if (connector.sourcePortID === '') {\n                            var newDirection1 = currentPoint.y > nextPoint.y ? 'Top' : 'Bottom';\n                            var refPoint = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.findPoint)(sourceWrapper.bounds, (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(newDirection1));\n                            sourcePoint = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getIntersection)(connector, sourceWrapper, sourcePoint, refPoint, false);\n                        }\n                        currentPoint.y = sourcePoint.y;\n                    }\n                    if (j === points.length - 2 && targetPoint) {\n                        if (j > 0 && connector.targetDecorator &&\n                            ((targetPoint.y - nextPoint.y) < 0) &&\n                            (Math.abs(targetPoint.y - currentPoint.y) < connector.targetDecorator.height + 1)) {\n                            currentPoint.y = points[j - 1].y -= this.size / 2;\n                        }\n                        if (j > 0 && connector.targetDecorator &&\n                            ((targetPoint.y - nextPoint.y) > 0) &&\n                            (Math.abs(targetPoint.y - currentPoint.y) < connector.targetDecorator.height + 1)) {\n                            currentPoint.y = points[j - 1].y += this.size / 2;\n                        }\n                        nextPoint.y = targetPoint.y;\n                        currentPoint.x = nextPoint.x = targetPoint.x;\n                    }\n                }\n            }\n            if (diagram.avoidLineOverlappingModule && isUpdate) {\n                diagram.avoidLineOverlappingModule.addConnector(connector, points);\n                var modifiedConnectors = diagram.avoidLineOverlappingModule.getModifiedConnector();\n                if (modifiedConnectors.has(connector)) {\n                    segments = diagram.avoidLineOverlappingModule.getModifiedConnectorSegments(connector);\n                    modifiedConnectors.delete(connector);\n                }\n                if (modifiedConnectors.size > 0) {\n                    diagram.avoidLineOverlappingModule.refreshModifiedConnectors(diagram);\n                }\n            }\n            if (segments.length === 0) {\n                for (var j = 0; j < points.length - 1; j++) {\n                    var currentPoint = points[parseInt(j.toString(), 10)];\n                    var nextPoint = points[j + 1];\n                    if (currentPoint.x !== nextPoint.x) {\n                        if (currentPoint.x > nextPoint.x) {\n                            direction = 'Left';\n                            length = currentPoint.x - nextPoint.x;\n                        }\n                        else {\n                            direction = 'Right';\n                            length = nextPoint.x - currentPoint.x;\n                        }\n                    }\n                    else {\n                        if (currentPoint.y > nextPoint.y) {\n                            direction = 'Top';\n                            length = currentPoint.y - nextPoint.y;\n                        }\n                        else {\n                            direction = 'Bottom';\n                            length = nextPoint.y - currentPoint.y;\n                        }\n                    }\n                    seg = { type: 'Orthogonal', length: length, direction: direction };\n                    segments.push(seg);\n                }\n            }\n        }\n        if (segments && segments.length > 0) {\n            var lastSeg = segments[segments.length - 1];\n            if (segments.length === 1) {\n                lastSeg.length -= 20;\n            }\n            if (lastSeg.length < 10 && segments.length === 2) {\n                segments.pop();\n                if (segments.length > 0) {\n                    segments[0].length -= 20;\n                    lastSeg = segments[0];\n                }\n            }\n            if (connector.targetDecorator &&\n                ((lastSeg.direction === 'Top' || lastSeg.direction === 'Bottom') && lastSeg.length > connector.targetDecorator.height + 1) ||\n                ((lastSeg.direction === 'Right' || lastSeg.direction === 'Left') && lastSeg.length > connector.targetDecorator.width + 1)) {\n                if (isUpdate || !diagram.avoidLineOverlappingModule) {\n                    connector.segments = segments;\n                }\n                if (isUpdate) {\n                    diagram.connectorPropertyChange(connector, {}, { type: 'Orthogonal', segments: segments });\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    /* tslint:enable */\n    // Shortest path\n    LineRouting.prototype.findPath = function (startGrid) {\n        var intermediatePoint;\n        var collection = [];\n        var neigbours = this.findNearestNeigbours(startGrid, this.gridCollection, true);\n        for (var i = 0; i < neigbours.length; i++) {\n            intermediatePoint = this.findIntermediatePoints(neigbours[parseInt(i.toString(), 10)].gridX, neigbours[parseInt(i.toString(), 10)].gridY, startGrid.gridX, startGrid.gridY, this.targetGrid.gridX, this.targetGrid.gridY);\n            if (intermediatePoint !== null) {\n                var grid = this.gridCollection[intermediatePoint.x][intermediatePoint.y];\n                var h = this.octile(Math.abs(intermediatePoint.x - startGrid.gridX), Math.abs(intermediatePoint.y - startGrid.gridY));\n                if (startGrid.parent && startGrid.parent.parent) {\n                    if (grid.gridX !== startGrid.parent.gridX && grid.gridY !== startGrid.parent.gridY) {\n                        h += 0.1;\n                    }\n                }\n                var l = startGrid.previousDistance + h;\n                if ((!grid.previousDistance || grid.previousDistance > l) &&\n                    (!(intermediatePoint.x === startGrid.gridX && intermediatePoint.y === startGrid.gridY))) {\n                    collection.push(intermediatePoint);\n                    grid.previousDistance = l;\n                    grid.afterDistance = grid.afterDistance || this.manhattan(Math.abs(intermediatePoint.x - this.targetGrid.gridX), Math.abs(intermediatePoint.y - this.targetGrid.gridY));\n                    grid.totalDistance = grid.previousDistance + grid.afterDistance;\n                    grid.parent = startGrid;\n                }\n            }\n        }\n        if (collection.length > 0) {\n            for (var i = 0; i < collection.length; i++) {\n                var grid = this.gridCollection[collection[parseInt(i.toString(), 10)].x][collection[parseInt(i.toString(), 10)].y];\n                if (this.startArray.indexOf(grid) === -1) {\n                    this.startArray.push(grid);\n                }\n            }\n        }\n        this.sorting(this.startArray);\n    };\n    // sorting the array based on total distance between source and target node\n    LineRouting.prototype.sorting = function (array) {\n        var done = false;\n        while (!done) {\n            done = true;\n            for (var i = 1; i < array.length; i += 1) {\n                if (array[i - 1].totalDistance < array[parseInt(i.toString(), 10)].totalDistance) {\n                    done = false;\n                    var tmp = array[i - 1];\n                    array[i - 1] = array[parseInt(i.toString(), 10)];\n                    array[parseInt(i.toString(), 10)] = tmp;\n                }\n            }\n        }\n        return array;\n    };\n    LineRouting.prototype.octile = function (t, e) {\n        var r = Math.SQRT2 - 1;\n        return e > t ? r * t + e : r * e + t;\n    };\n    LineRouting.prototype.manhattan = function (t, e) {\n        return t + e;\n    };\n    // Find the nearest neigbour from the current boundaries, the neigbour is use to find next intermdiate point.\n    LineRouting.prototype.findNearestNeigbours = function (startGrid, gridCollection, isSource) {\n        var neigbours = [];\n        var parent = startGrid.parent;\n        if (parent) {\n            var dx = (startGrid.gridX - parent.gridX) / Math.max(Math.abs(startGrid.gridX - parent.gridX), 1);\n            var dy = (startGrid.gridY - parent.gridY) / Math.max(Math.abs(startGrid.gridY - parent.gridY), 1);\n            if (dx !== 0) {\n                if (this.isWalkable(startGrid.gridX, startGrid.gridY - 1, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY - 1]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY - 1]);\n                }\n                if (this.isWalkable(startGrid.gridX, startGrid.gridY + 1, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + 1])) {\n                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + 1]);\n                }\n                if (this.isWalkable(startGrid.gridX + dx, startGrid.gridY, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + dx][startGrid.gridY]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX + dx][startGrid.gridY]);\n                }\n            }\n            else if (dy !== 0) {\n                if (this.isWalkable(startGrid.gridX - 1, startGrid.gridY, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX - 1][startGrid.gridY]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX - 1][startGrid.gridY]);\n                }\n                if (this.isWalkable(startGrid.gridX + 1, startGrid.gridY, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + 1][startGrid.gridY]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX + 1][startGrid.gridY]);\n                }\n                if (this.isWalkable(startGrid.gridX, startGrid.gridY + dy, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + dy]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + dy]);\n                }\n            }\n        }\n        else {\n            this.neigbour(startGrid, 'top', neigbours, isSource);\n            this.neigbour(startGrid, 'right', neigbours, isSource);\n            this.neigbour(startGrid, 'bottom', neigbours, isSource);\n            this.neigbour(startGrid, 'left', neigbours, isSource);\n        }\n        return neigbours;\n    };\n    LineRouting.prototype.neigbour = function (startGrid, direction, neigbours, isSource) {\n        var i = 1;\n        var nearGrid;\n        while (i > 0) {\n            var x = (direction === 'top' || direction === 'bottom') ?\n                (startGrid.gridX) : ((direction === 'left') ? startGrid.gridX - i : startGrid.gridX + i);\n            var y = (direction === 'right' || direction === 'left') ?\n                (startGrid.gridY) : ((direction === 'top') ? startGrid.gridY - i : startGrid.gridY + i);\n            nearGrid = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];\n            if (nearGrid && ((isSource && this.sourceGridCollection.indexOf(nearGrid) === -1)\n                || (!isSource && this.targetGridCollection.indexOf(nearGrid) === -1))) {\n                if (neigbours && this.isWalkable(x, y)) {\n                    neigbours.push(nearGrid);\n                }\n                return i;\n            }\n            if (x > 0 && y > 0) {\n                i++;\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    };\n    LineRouting.prototype.resetGridColl = function (grid, direction, isSource) {\n        var i = 1;\n        var nearGrid;\n        while (i > 0) {\n            var x = (direction === 'top' || direction === 'bottom') ?\n                (grid.gridX) : ((direction === 'left') ? grid.gridX - i : grid.gridX + i);\n            var y = (direction === 'right' || direction === 'left') ?\n                (grid.gridY) : ((direction === 'top') ? grid.gridY - i : grid.gridY + i);\n            nearGrid = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];\n            if (nearGrid && ((isSource && this.sourceGridCollection.indexOf(nearGrid) === -1) ||\n                (!isSource && this.targetGridCollection.indexOf(nearGrid) === -1))) {\n                if (this.isWalkable(x, y)) {\n                    break;\n                }\n                else {\n                    var grid_1 = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];\n                    this.considerWalkable.push(grid_1);\n                }\n            }\n            if (x > 0 && y > 0) {\n                if (direction === 'top' || direction === 'left') {\n                    i--;\n                }\n                else {\n                    i++;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    };\n    LineRouting.prototype.isWalkable = function (x, y, isparent) {\n        if (x >= 0 && x < this.noOfRows && y >= 0 && y < this.noOfCols) {\n            var grid = this.gridCollection[parseInt(x.toString(), 10)][parseInt(y.toString(), 10)];\n            if (grid && (grid.walkable || ((grid.nodeId.length === 1 || (grid.nodeId.length === 2 && grid.parentNodeId\n                || (this.considerWalkable.indexOf(grid) !== -1))) &&\n                (this.sourceGridCollection.indexOf(grid) !== -1 || this.targetGridCollection.indexOf(grid) !== -1 ||\n                    this.considerWalkable.indexOf(grid) !== -1)))) {\n                if ((isparent && !grid.parent) || !isparent) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    LineRouting.prototype.findIntermediatePoints = function (neigbourGridX, neigbourGridY, startGridX, startGridY, endGridX, endGridY) {\n        var dx = neigbourGridX - startGridX;\n        var dy = neigbourGridY - startGridY;\n        var gridX = neigbourGridX;\n        var gridY = neigbourGridY;\n        for (var i = 0; i < this.targetGridCollection.length; i++) {\n            if (neigbourGridX === this.targetGridCollection[parseInt(i.toString(), 10)].gridX\n                && neigbourGridY === this.targetGridCollection[parseInt(i.toString(), 10)].gridY) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n        }\n        if (!this.isWalkable(neigbourGridX, neigbourGridY)) {\n            return null;\n        }\n        var neigbourGrid = this.gridCollection[parseInt(neigbourGridX.toString(), 10)][parseInt(neigbourGridY.toString(), 10)];\n        if (neigbourGrid.tested) {\n            return { x: neigbourGridX, y: neigbourGridY };\n        }\n        neigbourGrid.tested = true;\n        if (dx !== 0) {\n            dx = (dx > 0) ? 1 : -1;\n            if ((this.isWalkable(gridX, gridY - 1) && !this.isWalkable(gridX - dx, gridY - 1)) ||\n                (this.isWalkable(gridX, gridY + 1) && !this.isWalkable(gridX - dx, gridY + 1))) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n        }\n        if (dy !== 0) {\n            dy = (dy > 0) ? 1 : -1;\n            if ((this.isWalkable(gridX - 1, gridY) && !this.isWalkable(gridX - 1, gridY - dy)) ||\n                (this.isWalkable(gridX + 1, gridY) && !this.isWalkable(gridX + 1, gridY - dy))) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n            if (this.findIntermediatePoints(gridX + 1, gridY, gridX, gridY, endGridX, endGridY) ||\n                this.findIntermediatePoints(gridX - 1, gridY, gridX, gridY, endGridX, endGridY)) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n        }\n        return this.findIntermediatePoints(gridX + dx, gridY + dy, gridX, gridY, endGridX, endGridY);\n    };\n    /**\n     *To destroy the line routing\n     *\n     * @returns {void} To destroy the line routing\n     */\n    LineRouting.prototype.destroy = function () {\n        /**\n         * Destroys the line routing module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    LineRouting.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'LineRouting';\n    };\n    return LineRouting;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-routing.js?");

/***/ })

}]);