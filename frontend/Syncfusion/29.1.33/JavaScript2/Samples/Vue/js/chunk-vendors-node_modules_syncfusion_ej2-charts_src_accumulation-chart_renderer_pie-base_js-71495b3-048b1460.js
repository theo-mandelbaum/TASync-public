"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_accumulation-chart_renderer_pie-base_js-71495b3-048b1460"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-base.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-base.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PieBase: () => (/* binding */ PieBase)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _accumulation_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./accumulation-base */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/accumulation-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * Accumulation charts base file\n */\n\n\n\n\n\n/**\n * The `PieBase` class is used to perform base calculations for the `Pie` series.\n *\n * @private\n */\nvar PieBase = /** @class */ (function (_super) {\n    __extends(PieBase, _super);\n    function PieBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * To initialize the property values.\n     *\n     * @private\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @param {AccumulationSeries} series - The series for which the properties are initialized.\n     * @returns {void}\n     */\n    PieBase.prototype.initProperties = function (chart, series) {\n        this.accumulation = chart;\n        this.size = Math.min(chart.initialClipRect.width, chart.initialClipRect.height);\n        this.initAngles(series);\n        var r = parseInt(series.radius, 10);\n        if ((series.radius.indexOf('%') !== -1 || typeof r === 'number') && !isNaN(r)) {\n            this.isRadiusMapped = false;\n            this.pieBaseRadius = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.radius, this.size / 2);\n            this.innerRadius = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.innerRadius, this.pieBaseRadius);\n            this.pieBaseLabelRadius = series.dataLabel.position === 'Inside' ? (((this.pieBaseRadius - this.innerRadius) / 2) + this.innerRadius) :\n                (this.pieBaseRadius + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.dataLabel.connectorStyle.length || '4%', this.size / 2));\n        }\n        else {\n            var radiusCollection = [];\n            this.isRadiusMapped = true;\n            for (var i = 0; i < Object.keys(series.points).length; i++) {\n                if (series.points[i].sliceRadius.indexOf('%') !== -1) {\n                    radiusCollection[i] = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.points[i].sliceRadius, this.size / 2);\n                }\n                else {\n                    radiusCollection[i] = parseInt(series.points[i].sliceRadius, 10);\n                }\n            }\n            var minRadius = Math.min.apply(null, radiusCollection);\n            var maxRadius = Math.max.apply(null, radiusCollection);\n            this.pieBaseRadius = this.seriesRadius = maxRadius;\n            this.innerRadius = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.innerRadius, this.seriesRadius);\n            this.innerRadius = this.innerRadius > minRadius ? (this.innerRadius / 2) : this.innerRadius;\n        }\n        // this.radius = stringToNumber(series.radius, size / 2);\n        // this.innerRadius = stringToNumber(series.innerRadius, this.radius);\n        // this.labelRadius = series.dataLabel.position === 'Inside' ? (((this.radius - this.innerRadius) / 2) + this.innerRadius) :\n        //     (this.radius + stringToNumber(series.dataLabel.connectorStyle.length || '4%', size / 2));\n        this.radius = this.pieBaseRadius;\n        this.labelRadius = this.pieBaseLabelRadius;\n        chart.explodeDistance = series.explode ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.explodeOffset, this.pieBaseRadius) : 0;\n        this.findCenter(chart, series);\n        this.center = this.pieBaseCenter;\n        if (!chart.redraw) {\n            this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position);\n        }\n        this.totalAngle -= 0.001;\n    };\n    /*\n     * To get label radius of the pie.\n     * @private\n     */\n    PieBase.prototype.getLabelRadius = function (series, point) {\n        return series.dataLabel.position === 'Inside' ?\n            (((((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(point.sliceRadius, this.pieBaseRadius) - this.innerRadius)) / 2) + this.innerRadius) :\n            ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(point.sliceRadius, this.size / 2) + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.dataLabel.connectorStyle.length || '4%', this.size / 2));\n    };\n    /**\n     * To find the center of the accumulation.\n     *\n     * @private\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @param {AccumulationSeries} series - The series for which the center is calculated.\n     * @returns {void}\n     */\n    PieBase.prototype.findCenter = function (accumulation, series) {\n        this.accumulation = accumulation;\n        this.pieBaseCenter = {\n            x: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(accumulation.center.x, accumulation.initialClipRect.width) + (accumulation.initialClipRect.x),\n            y: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(accumulation.center.y, accumulation.initialClipRect.height) + (accumulation.initialClipRect.y)\n        };\n        var accumulationRect = this.getSeriesBound(series);\n        var accumulationRectCenter = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(accumulationRect.x + accumulationRect.width / 2, accumulationRect.y + accumulationRect.height / 2);\n        this.pieBaseCenter.x += (this.pieBaseCenter.x - accumulationRectCenter.x);\n        this.pieBaseCenter.y += (this.pieBaseCenter.y - accumulationRectCenter.y);\n        this.accumulation.origin = this.pieBaseCenter;\n    };\n    /**\n     * To find angles from series.\n     *\n     * @param {AccumulationSeries} series - The series for which to calculate angles.\n     * @returns {void}\n     */\n    PieBase.prototype.initAngles = function (series) {\n        var endAngle = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series.endAngle) ? series.startAngle : series.endAngle;\n        this.totalAngle = (endAngle - series.startAngle) % 360;\n        this.startAngle = series.startAngle - 90;\n        this.totalAngle = this.totalAngle <= 0 ? (360 + this.totalAngle) : this.totalAngle;\n        this.startAngle = (this.startAngle < 0 ? (this.startAngle + 360) : this.startAngle) % 360;\n    };\n    /**\n     * To calculate data-label bound.\n     *\n     * @private\n     * @param {AccumulationSeries} series - The series for which to calculate data-label bounds.\n     * @param {boolean} visible - Indicates whether the data-labels are visible.\n     * @param {AccumulationLabelPosition} position - The position of the data-labels.\n     * @returns {void}\n     */\n    PieBase.prototype.defaultLabelBound = function (series, visible, position) {\n        var accumulationBound = this.getSeriesBound(series);\n        series.accumulationBound = accumulationBound;\n        series.labelBound = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);\n        if (visible && position === 'Outside') {\n            series.labelBound = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(Infinity, Infinity, -Infinity, -Infinity);\n        }\n    };\n    /**\n     * To calculate series bound.\n     *\n     * @private\n     * @param {AccumulationSeries} series - The series for which to calculate the bound.\n     * @returns {Rect} - Returns a rect.\n     */\n    PieBase.prototype.getSeriesBound = function (series) {\n        var rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(Infinity, Infinity, -Infinity, -Infinity);\n        this.initAngles(series);\n        var start = this.startAngle;\n        var total = this.totalAngle;\n        var end = (this.startAngle + total) % 360;\n        end = (end === 0) ? 360 : end;\n        series.findMaxBounds(rect, this.getRectFromAngle(start));\n        series.findMaxBounds(rect, this.getRectFromAngle(end));\n        series.findMaxBounds(rect, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(this.pieBaseCenter.x, this.pieBaseCenter.y, 0, 0));\n        var nextQuandrant = (Math.floor(start / 90) * 90 + 90) % 360;\n        var lastQuadrant = (Math.floor(end / 90) * 90) % 360;\n        lastQuadrant = (lastQuadrant === 0) ? 360 : lastQuadrant;\n        if (total >= 90 || lastQuadrant === nextQuandrant) {\n            series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n            series.findMaxBounds(rect, this.getRectFromAngle(lastQuadrant));\n        }\n        if (start === 0 || (start + total >= 360)) {\n            series.findMaxBounds(rect, this.getRectFromAngle(0));\n        }\n        var length = nextQuandrant === lastQuadrant ? 0 : Math.floor(total / 90);\n        for (var i = 1; i < length; i++) {\n            nextQuandrant = nextQuandrant + 90;\n            if ((nextQuandrant < lastQuadrant || end < start) || total === 360) {\n                series.findMaxBounds(rect, this.getRectFromAngle(nextQuandrant));\n            }\n        }\n        rect.width -= rect.x;\n        rect.height -= rect.y;\n        return rect;\n    };\n    /**\n     * To get rect location size from angle.\n     *\n     * @param {number} angle - The angle in degrees.\n     * @returns {Rect} - The rect representing the location size from angle.\n     */\n    PieBase.prototype.getRectFromAngle = function (angle) {\n        var location = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(angle, this.pieBaseRadius, this.pieBaseCenter);\n        return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(location.x, location.y, 0, 0);\n    };\n    /**\n     * To get path arc direction.\n     *\n     * @param {ChartLocation} center - The center coordinates of the arc.\n     * @param {number} start - The starting angle of the arc in degrees.\n     * @param {number} end - The ending angle of the arc in degrees.\n     * @param {number} radius - The radius of the arc.\n     * @param {number} innerRadius - The inner radius of the arc.\n     * @param {number} borderRadius - The border radius of the arc.\n     * @param {boolean} isBorder - It specifies whether it is for rendering a border.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {string} - The path string representing the arc direction.\n     */\n    PieBase.prototype.getPathArc = function (center, start, end, radius, innerRadius, borderRadius, isBorder, seriesPoints) {\n        var degree = end - start;\n        degree = degree < 0 ? (degree + 360) : degree;\n        var flag = (degree < 180) ? 0 : 1;\n        if (!innerRadius && innerRadius === 0) {\n            return this.getPiePath(center, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(start, radius, center), (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(end, radius, center), radius, flag, borderRadius, seriesPoints);\n        }\n        else {\n            return this.getDoughnutPath(center, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(start, radius, center), (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(end, radius, center), radius, (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(start, innerRadius, center), (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.degreeToLocation)(end, innerRadius, center), innerRadius, flag, borderRadius, isBorder, seriesPoints);\n        }\n    };\n    /**\n     * To get pie direction.\n     *\n     * @param {ChartLocation} center - The center of the pie.\n     * @param {ChartLocation} start - The starting location of the pie.\n     * @param {ChartLocation} end - The ending location of the pie.\n     * @param {number} radius - The radius of the pie.\n     * @param {number} clockWise - The direction of the pie.\n     * @param {number} cornerRadius - The border radius of the arc.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {string} - The path direction for the pie.\n     */\n    PieBase.prototype.getPiePath = function (center, start, end, radius, clockWise, cornerRadius, seriesPoints) {\n        var sliceCount = this.sliceCheck(seriesPoints);\n        cornerRadius = sliceCount === 1 ? 0 : cornerRadius;\n        var startAngle = Math.atan2(start.y - center.y, start.x - center.x);\n        var endAngle = Math.atan2(end.y - center.y, end.x - center.x);\n        cornerRadius = this.adjustCornerRadius(startAngle, endAngle, radius, cornerRadius);\n        var x1 = start.x - cornerRadius * Math.cos(startAngle);\n        var y1 = start.y - cornerRadius * Math.sin(startAngle);\n        var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n        var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n        var cx2 = end.x - cornerRadius * Math.cos(endAngle);\n        var cy2 = end.y - cornerRadius * Math.sin(endAngle);\n        var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n        var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n        return \"M \" + center.x + \" \" + center.y + \" L \" + x1 + \" \" + y1 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx2 + \" \" + cy2 + \" Z\";\n    };\n    /**\n     * To get doughnut direction.\n     *\n     * @param {ChartLocation} center - The center of the doughnut.\n     * @param {ChartLocation} start - The starting location of the outer doughnut.\n     * @param {ChartLocation} end - The ending location of the outer doughnut.\n     * @param {number} radius - The radius of the outer doughnut.\n     * @param {ChartLocation} innerStart - The starting location of the inner doughnut.\n     * @param {ChartLocation} innerEnd - The ending location of the inner doughnut.\n     * @param {number} innerRadius - The radius of the inner doughnut.\n     * @param {number} clockWise - The direction of the doughnut.\n     * @param {number} cornerRadius - The border radius of the arc.\n     * @param {boolean} isBorder - It specifies whether it is for rendering a border.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {string} - The path direction for the doughnut.\n     */\n    PieBase.prototype.getDoughnutPath = function (center, start, end, radius, innerStart, innerEnd, innerRadius, clockWise, cornerRadius, isBorder, seriesPoints) {\n        var sliceCount = this.sliceCheck(seriesPoints);\n        cornerRadius = sliceCount === 1 ? 0 : cornerRadius;\n        var startAngle = Math.atan2(start.y - innerStart.y, start.x - innerStart.x);\n        var endAngle = Math.atan2(end.y - innerEnd.y, end.x - innerEnd.x);\n        cornerRadius = this.adjustCornerRadius(startAngle, endAngle, innerRadius, cornerRadius);\n        cornerRadius = (isBorder && (this.innerRadius === 0)) ? cornerRadius * -1 : cornerRadius;\n        var x1 = start.x - cornerRadius * Math.cos(startAngle);\n        var y1 = start.y - cornerRadius * Math.sin(startAngle);\n        var x2 = end.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n        var y2 = end.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n        var x3 = innerEnd.x + cornerRadius * Math.cos(endAngle);\n        var y3 = innerEnd.y + cornerRadius * Math.sin(endAngle);\n        var x4 = innerStart.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n        var y4 = innerStart.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n        var cx1 = start.x + cornerRadius * Math.cos(Math.PI / 2 + startAngle);\n        var cy1 = start.y + cornerRadius * Math.sin(Math.PI / 2 + startAngle);\n        var cx2 = end.x - cornerRadius * Math.cos(endAngle);\n        var cy2 = end.y - cornerRadius * Math.sin(endAngle);\n        var cx3 = innerEnd.x - cornerRadius * Math.cos(Math.PI / 2 + endAngle);\n        var cy3 = innerEnd.y - cornerRadius * Math.sin(Math.PI / 2 + endAngle);\n        var cx4 = innerStart.x + cornerRadius * Math.cos(startAngle);\n        var cy4 = innerStart.y + cornerRadius * Math.sin(startAngle);\n        if (isBorder) {\n            return \"M \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" L \" + cx3 + \" \" + cy3 + \" A \" + innerRadius + \" \" + innerRadius + \" 0 \" + clockWise + \" 0 \" + x4 + \" \" + y4 + \" Z\";\n        }\n        else {\n            return \"M \" + x1 + \" \" + y1 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx1 + \" \" + cy1 + \" A \" + radius + \" \" + radius + \" 0 \" + clockWise + \" 1 \" + x2 + \" \" + y2 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx2 + \" \" + cy2 + \" L \" + x3 + \" \" + y3 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx3 + \" \" + cy3 + \" A \" + innerRadius + \" \" + innerRadius + \" 0 \" + clockWise + \" 0 \" + x4 + \" \" + y4 + \" A \" + cornerRadius + \" \" + cornerRadius + \" 0 0 1 \" + cx4 + \" \" + cy4 + \" Z\";\n        }\n    };\n    /**\n     * Adjusts the corner radius of a pie chart slice based on the angle of the slice.\n     * Ensures that the corner radius does not exceed a value that would cause the arcs\n     * of the slice to overlap or create an invalid shape.\n     *\n     * @param {number} startAngle - The start angle of the pie.\n     * @param {number} endAngle - The end angle of the pie.\n     * @param {number} radius - The radius of the pie.\n     * @param {number} cornerRadius - The border radius of the arc.\n     * @returns {number} - The adjusted corner radius of the pie.\n     */\n    PieBase.prototype.adjustCornerRadius = function (startAngle, endAngle, radius, cornerRadius) {\n        var anglePerSlice = Math.abs(endAngle - startAngle);\n        if (anglePerSlice > Math.PI) {\n            anglePerSlice = 2 * Math.PI - anglePerSlice; // Handle large angles that cross the -PI to PI boundary\n        }\n        // Adjust corner radius based on the angle per slice\n        var angleFactor = anglePerSlice / (2 * Math.PI);\n        var adjustedCornerRadius = radius * angleFactor;\n        return Math.min(cornerRadius, adjustedCornerRadius);\n    };\n    /**\n     * To Check slice count.\n     *\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {number} - The number of visible pie slice.\n     */\n    PieBase.prototype.sliceCheck = function (seriesPoints) {\n        var isOneSlice = 0;\n        for (var index = 0; index < seriesPoints.length; index++) {\n            var point = seriesPoints[index];\n            if (point.visible) {\n                isOneSlice++;\n            }\n        }\n        return isOneSlice;\n    };\n    /**\n     * Method to start animation for pie series.\n     *\n     * @param {Element} slice - The slice element to animate.\n     * @param {AccumulationSeries} series - The accumulation chart control.\n     * @param {Element} groupElement - The group element containing the pie series.\n     * @param {number} borderRadius - The border radius of the arc.\n     * @param {AccPoints[]} seriesPoints - The points of the series.\n     * @returns {void}\n     */\n    PieBase.prototype.doAnimation = function (slice, series, groupElement, borderRadius, seriesPoints) {\n        var _this = this;\n        var startAngle = series.startAngle - 90;\n        var duration = this.accumulation.duration ? this.accumulation.duration : series.animation.duration;\n        var value;\n        this.pieBaseCenter.x += 1;\n        var radius = Math.max(this.accumulation.availableSize.height, this.accumulation.availableSize.width) * 0.75;\n        radius += radius * (0.414); // formula r + r / 2 * (1.414 -1)\n        var effect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getAnimationFunction)('Linear'); // need to check animation type\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(slice, {\n            duration: (duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 1000 : duration,\n            delay: series.animation.delay,\n            progress: function (args) {\n                value = effect(args.timeStamp, startAngle, _this.totalAngle, args.duration);\n                slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, startAngle, value, radius, 0, borderRadius, false, seriesPoints));\n            },\n            end: function () {\n                _this.pieBaseCenter.x -= 1;\n                slice.setAttribute('d', _this.getPathArc(_this.pieBaseCenter, 0, 359.99999, radius, 0, borderRadius, false, seriesPoints));\n                _this.accumulation.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_3__.animationComplete, _this.accumulation.isBlazor ? {} :\n                    { series: series, accumulation: _this.accumulation, chart: _this.accumulation });\n                var datalabelGroup = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(_this.accumulation.element.id + '_datalabel_Series_' + series.index);\n                if (datalabelGroup) {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.markerAnimate)(datalabelGroup, series.animation.delay, series.animation.duration, series, null, null, false);\n                }\n                groupElement.style.cssText = '';\n                var annotationElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(_this.accumulation.element.id + '_Annotation_Collections');\n                if (annotationElement) {\n                    annotationElement.style.visibility = 'visible';\n                }\n            }\n        });\n    };\n    return PieBase;\n}(_accumulation_base__WEBPACK_IMPORTED_MODULE_4__.AccumulationBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pie-base.js?");

/***/ })

}]);