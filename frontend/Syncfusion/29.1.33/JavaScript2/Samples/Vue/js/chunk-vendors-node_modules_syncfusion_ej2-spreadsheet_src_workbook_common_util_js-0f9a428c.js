"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-spreadsheet_src_workbook_common_util_js-0f9a428c"],{

/***/ "./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/common/util.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/common/util.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPredicates: () => (/* binding */ applyPredicates),\n/* harmony export */   checkIsFormula: () => (/* binding */ checkIsFormula),\n/* harmony export */   checkRange: () => (/* binding */ checkRange),\n/* harmony export */   columnIndex: () => (/* binding */ columnIndex),\n/* harmony export */   deleteFormatRange: () => (/* binding */ deleteFormatRange),\n/* harmony export */   getAutoDetectFormatParser: () => (/* binding */ getAutoDetectFormatParser),\n/* harmony export */   getDataRange: () => (/* binding */ getDataRange),\n/* harmony export */   getLeadingSpaces: () => (/* binding */ getLeadingSpaces),\n/* harmony export */   getSplittedAddressForColumn: () => (/* binding */ getSplittedAddressForColumn),\n/* harmony export */   getTrailingSpaces: () => (/* binding */ getTrailingSpaces),\n/* harmony export */   getUpdatedFormula: () => (/* binding */ getUpdatedFormula),\n/* harmony export */   getUpdatedRange: () => (/* binding */ getUpdatedRange),\n/* harmony export */   getViewportIndexes: () => (/* binding */ getViewportIndexes),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   insertFormatRange: () => (/* binding */ insertFormatRange),\n/* harmony export */   isCellReference: () => (/* binding */ isCellReference),\n/* harmony export */   isChar: () => (/* binding */ isChar),\n/* harmony export */   isColumnSelected: () => (/* binding */ isColumnSelected),\n/* harmony export */   isHeightCheckNeeded: () => (/* binding */ isHeightCheckNeeded),\n/* harmony export */   isImported: () => (/* binding */ isImported),\n/* harmony export */   isInMultipleRange: () => (/* binding */ isInMultipleRange),\n/* harmony export */   isInRange: () => (/* binding */ isInRange),\n/* harmony export */   isLocked: () => (/* binding */ isLocked),\n/* harmony export */   isReadOnly: () => (/* binding */ isReadOnly),\n/* harmony export */   isReadOnlyCells: () => (/* binding */ isReadOnlyCells),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isValidCellReference: () => (/* binding */ isValidCellReference),\n/* harmony export */   parseLocaleNumber: () => (/* binding */ parseLocaleNumber),\n/* harmony export */   setVisibleMergeIndex: () => (/* binding */ setVisibleMergeIndex),\n/* harmony export */   skipHiddenIdx: () => (/* binding */ skipHiddenIdx),\n/* harmony export */   updateCFModel: () => (/* binding */ updateCFModel),\n/* harmony export */   updateCell: () => (/* binding */ updateCell),\n/* harmony export */   updateMergeBorder: () => (/* binding */ updateMergeBorder)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../index */ \"./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ \"./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/common/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _internalization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internalization */ \"./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/common/internalization.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n\n\n\n\n\n\n\n\n/**\n * Check whether the text is formula or not.\n *\n * @param {string} text - Specify the text.\n * @param {boolean} isEditing - Specify the isEditing.\n * @returns {boolean} - Check whether the text is formula or not.\n */\nfunction checkIsFormula(text, isEditing) {\n    return text && text[0] === '=' && (text.length > 1 || isEditing);\n}\n/**\n * Check whether the value is cell reference or not.\n *\n * @param {string} value - Specify the value to check.\n * @returns {boolean} - Returns boolean value\n */\nfunction isCellReference(value) {\n    var range = value;\n    range = range.split('$').join('');\n    if (range.indexOf(':') > -1) {\n        var rangeSplit = range.split(':');\n        if (isValidCellReference(rangeSplit[0]) && isValidCellReference(rangeSplit[1])) {\n            return true;\n        }\n    }\n    else if (range.indexOf(':') < 0) {\n        if (isValidCellReference(range)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check whether the value is character or not.\n *\n * @param {string} value - Specify the value to check.\n * @returns {boolean} - Returns boolean value\n */\nfunction isChar(value) {\n    if ((value.charCodeAt(0) >= 65 && value.charCodeAt(0) <= 90) || (value.charCodeAt(0) >= 97 && value.charCodeAt(0) <= 122)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Check whether the range selection is on complete row.\n *\n * @param {SheetModel} sheet - Specify the sheet.\n * @param {number[]} range - Specify the range index.\n * @returns {boolean} - Returns boolean value\n * @hidden\n */\nfunction isRowSelected(sheet, range) {\n    return range[1] === 0 && range[3] === sheet.colCount - 1;\n}\n/**\n * Check whether the range selection is on complete column.\n *\n * @param {SheetModel} sheet - Specify the sheet.\n * @param {number[]} range - Specify the range index.\n * @returns {boolean} - Returns boolean value\n * @hidden\n */\nfunction isColumnSelected(sheet, range) {\n    return range[0] === 0 && range[2] === sheet.rowCount - 1;\n}\n/**\n * @param {number[]} range - Specify the range\n * @param {number} rowIdx - Specify the row index\n * @param {number} colIdx - Specify the col index\n * @returns {boolean} - Returns boolean value\n */\nfunction inRange(range, rowIdx, colIdx) {\n    return range && (rowIdx >= range[0] && rowIdx <= range[2] && colIdx >= range[1] && colIdx <= range[3]);\n}\n/**\n * @param {number[]} address - Specify the address\n * @param {number} rowIdx - Specify the row index\n * @param {number} colIdx - Specify the col index\n * @returns {boolean} - Returns boolean value\n */\nfunction isInMultipleRange(address, rowIdx, colIdx) {\n    var range;\n    var isInRange;\n    var splitedAddress = address.split(' ');\n    for (var i = 0, len = splitedAddress.length; i < len; i++) {\n        range = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(splitedAddress[i]);\n        isInRange = inRange(range, rowIdx, colIdx);\n        if (isInRange) {\n            break;\n        }\n    }\n    return isInRange;\n}\n/** @hidden\n * @param {number[]} range - Specify the range\n * @param {number[]} testRange - Specify the test range\n * @param {boolean} isModify - Specify the boolean value\n * @returns {boolean} - Returns boolean value\n */\nfunction isInRange(range, testRange, isModify) {\n    var inRange = range[0] <= testRange[0] && range[2] >= testRange[2] && range[1] <= testRange[1] && range[3] >= testRange[3];\n    if (inRange) {\n        return true;\n    }\n    if (isModify) {\n        if (testRange[0] < range[0] && testRange[2] < range[0] || testRange[0] > range[2] && testRange[2] > range[2]) {\n            return false;\n        }\n        else {\n            if (testRange[0] < range[0] && testRange[2] > range[0]) {\n                testRange[0] = range[0];\n                inRange = true;\n            }\n            if (testRange[2] > range[2]) {\n                testRange[2] = range[2];\n                inRange = true;\n            }\n        }\n        if (testRange[1] < range[1] && testRange[3] < range[1] || testRange[1] > range[3] && testRange[3] > range[3]) {\n            return false;\n        }\n        else {\n            if (testRange[1] < range[1] && testRange[3] > range[1]) {\n                testRange[1] = range[1];\n                inRange = true;\n            }\n            if (testRange[3] > range[3]) {\n                testRange[3] = range[3];\n                inRange = true;\n            }\n        }\n    }\n    return inRange;\n}\n/**\n * @hidden\n * @param {string} address - Specifies the address for whole column.\n * @param {number[]} testRange - Specifies range used to split the address.\n * @param {number} colIdx - Specifies the column index.\n * @returns {string} - returns the modified address.\n */\nfunction getSplittedAddressForColumn(address, testRange, colIdx) {\n    var colName = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getColumnHeaderText)(colIdx + 1);\n    if (address) {\n        address.split(' ').forEach(function (addrs) {\n            var range = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(addrs);\n            if (isInRange(range, testRange)) {\n                address = address.split(addrs).join(colName + (range[0] + 1) +\n                    ':' + colName + testRange[0] + ' ' + colName + (testRange[2] + 2) +\n                    ':' + colName + (range[2] + 1));\n            }\n            else if (isInRange(range, testRange, true)) {\n                var modifiedAddress = void 0;\n                if (testRange[0] > range[0]) {\n                    modifiedAddress = colName + (range[0] + 1) + ':' + colName + testRange[0];\n                }\n                else {\n                    modifiedAddress = colName + (testRange[2] + 2) + ':' + colName + (range[2] + 1);\n                }\n                address = address.split(addrs).join(modifiedAddress);\n            }\n        });\n    }\n    else {\n        address = colName + '1:' + colName + testRange[0] + ' ' + colName + (testRange[2] + 2) + ':' + colName + '1048576';\n    }\n    return address;\n}\n/**\n * Check whether the cell is locked or not\n *\n * @param {CellModel} cell - Specify the cell.\n * @param {ColumnModel} column - Specify the column.\n * @returns {boolean} - Returns boolean value\n * @hidden\n */\nfunction isLocked(cell, column) {\n    if (!cell) {\n        cell = {};\n    }\n    if (cell.isLocked) {\n        return true;\n    }\n    else if (cell.isLocked === false) {\n        return false;\n    }\n    else if (column && column.isLocked) {\n        return true;\n    }\n    else if (!cell.isLocked && (column && column.isLocked !== false)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Check whether the value is cell reference or not.\n *\n * @param {string} value - Specify the value to check.\n * @returns {boolean} - Returns boolean value\n * @hidden\n */\nfunction isValidCellReference(value) {\n    var text = value;\n    var startNum = 0;\n    var endNum = 0;\n    var cellText = '';\n    var textLength = text.length;\n    for (var i = 0; i < textLength; i++) {\n        if (isChar(text[i])) {\n            endNum++;\n        }\n    }\n    cellText = text.substring(startNum, endNum);\n    var cellTextLength = cellText.length;\n    if (cellTextLength !== textLength) {\n        if (cellTextLength < 4) {\n            if (textLength !== 1 && (isNaN(parseInt(text, 10)))) {\n                var cellColIndex = columnIndex(cellText);\n                // XFD is the last column, 16384 - Maximum number of columns in excel.\n                if (cellColIndex > 16384) {\n                    return false;\n                }\n                var cellNumber = parseFloat(text.substring(endNum, textLength));\n                if (cellNumber > 0 && cellNumber < 1048577) { // 1048576 - Maximum number of rows in excel.\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n/**\n * To get the column index of the given cell.\n *\n * @param {string} cell - Cell address for getting column index.\n * @returns {number} - To get the column index of the given cell.\n * @hidden\n */\nfunction columnIndex(cell) {\n    var j = 0;\n    var k = 0;\n    cell = cell.toUpperCase();\n    if (j < cell.length && cell[j] === '!') {\n        j++;\n        while (j < cell.length && cell[j] !== '!') {\n            j++;\n        }\n        j++;\n    }\n    while (j < cell.length && isChar(cell[j])) {\n        var charCode = cell[j].charCodeAt(0);\n        k = k * 26 + charCode - 64;\n        j++;\n    }\n    if (k === 0) {\n        return -1;\n    }\n    return k;\n}\n/**\n * @hidden\n * @param {SheetModel} sheet - Specify the sheet\n * @param {number} index - specify the index\n * @param {boolean} increase - specify the boolean value.\n * @param {string} layout - specify the string\n * @param {number} count - specify the count.\n * @returns {number} - To skip the hidden index\n *\n */\nfunction skipHiddenIdx(sheet, index, increase, layout, count) {\n    if (layout === void 0) { layout = 'rows'; }\n    var rowColObj;\n    if (increase) {\n        for (var i = index; i < Infinity; i++) {\n            rowColObj = sheet[\"\" + layout];\n            if (rowColObj[index] && rowColObj[index].hidden) {\n                index++;\n            }\n            else {\n                if (count) {\n                    count--;\n                    index++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    }\n    else {\n        for (var i = index; i > -1; i--) {\n            rowColObj = sheet[\"\" + layout];\n            if (rowColObj[index] && rowColObj[index].hidden) {\n                index--;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return index;\n}\n/**\n * @param {CellStyleModel} style - Cell style.\n * @param {boolean} onActionUpdate - Specifies the action.\n * @returns {boolean} - retruns `true` is height needs to be checked.\n * @hidden\n */\nfunction isHeightCheckNeeded(style, onActionUpdate) {\n    var keys = Object.keys(style);\n    return (onActionUpdate ? keys.indexOf('fontSize') > -1 : keys.indexOf('fontSize') > -1\n        && Number(style.fontSize.split('pt')[0]) > 12) || keys.indexOf('fontFamily') > -1 || keys.indexOf('borderTop') > -1\n        || keys.indexOf('borderBottom') > -1;\n}\n/**\n * @param {number[]} currIndexes - current indexes in which formula get updated\n * @param {number[]} prevIndexes - copied indexes\n * @param {SheetModel} sheet - sheet model\n * @param {Workbook} context - Represents workbook instance\n * @param {CellModel} prevCell - Copied or previous cell model\n * @param {boolean} isSort - Represents sort action\n * @returns {string} - retruns updated formula\n * @hidden\n */\nfunction getUpdatedFormula(currIndexes, prevIndexes, sheet, context, prevCell, isSort) {\n    var cIdxValue;\n    var cell;\n    if (prevIndexes) {\n        cell = prevCell || (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(prevIndexes[0], prevIndexes[1], sheet, false, true);\n        cIdxValue = cell.formula || '';\n    }\n    if (cIdxValue) {\n        if (isSort) {\n            context.notify(_index__WEBPACK_IMPORTED_MODULE_1__.clearFormulaDependentCells, { cellRef: (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCellAddress)(prevIndexes[0], prevIndexes[1]) });\n        }\n        if (cIdxValue.indexOf('=') === 0) {\n            cIdxValue = cIdxValue.slice(1);\n        }\n        cIdxValue = cIdxValue.split('(').join(context.listSeparator).split(')').join(context.listSeparator);\n        var formulaOperators = ['+', '-', '*', '/', '>=', '<=', '<>', '>', '<', '=', '%', '&'];\n        var splitArray = void 0;\n        var value = cIdxValue;\n        for (var i = 0; i < formulaOperators.length; i++) {\n            splitArray = value.split(formulaOperators[i]);\n            value = splitArray.join(context.listSeparator);\n        }\n        splitArray = value.split(context.listSeparator);\n        var newAddress = [];\n        var newRef = void 0;\n        var refObj = void 0;\n        var isSheetRef = void 0;\n        var cellRefSheet = void 0;\n        var cellRef = void 0;\n        for (var j = 0; j < splitArray.length; j++) {\n            isSheetRef = splitArray[j].includes('!');\n            if (isSheetRef) {\n                var lastIndex = splitArray[j].lastIndexOf('!');\n                cellRefSheet = splitArray[j].substring(0, lastIndex);\n                cellRef = splitArray[j].substring(lastIndex + 1).toUpperCase();\n            }\n            else {\n                cellRef = splitArray[j].toUpperCase();\n            }\n            if (isCellReference(cellRef.trim()) && !cellRef.includes('$')) {\n                var leadingSpaces = getLeadingSpaces(cellRef);\n                var trailingSpaces = getTrailingSpaces(cellRef);\n                var range = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(cellRef);\n                var newRange = [currIndexes[0] - (prevIndexes[0] - range[0]), currIndexes[1] - (prevIndexes[1] - range[1]),\n                    currIndexes[0] - (prevIndexes[0] - range[2]), currIndexes[1] - (prevIndexes[1] - range[3])];\n                if (newRange[1] < 0 || newRange[2] < 0 || newRange[3] < 0 || (!isSort && newRange[0] < 0)) {\n                    newRef = '#REF!';\n                }\n                else {\n                    if (isSort && newRange[0] < 0) {\n                        newRange[0] = newRange[2];\n                    }\n                    newRef = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCellAddress)(newRange[0], newRange[1]);\n                    if (cellRef.includes(':')) {\n                        newRef += (':' + (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCellAddress)(newRange[2], newRange[3]));\n                    }\n                    newRef = isCellReference(newRef) ? newRef : '#REF!';\n                }\n                refObj = {};\n                if (isSheetRef) {\n                    newRef = cellRefSheet + \"!\" + newRef;\n                }\n                refObj[splitArray[j]] = \"\" + leadingSpaces + newRef + trailingSpaces;\n                if (splitArray[j].includes(':')) {\n                    newAddress.splice(0, 0, refObj);\n                }\n                else {\n                    newAddress.push(refObj);\n                }\n            }\n        }\n        var objKey = void 0;\n        var objValue = void 0;\n        cIdxValue = cell.formula;\n        var newCIdxValue = cIdxValue;\n        for (var j = 0; j < newAddress.length; j++) {\n            objKey = Object.keys(newAddress[j])[0];\n            objValue = newAddress[j][\"\" + objKey];\n            var objKeyLen = objKey.length;\n            var positionIdx = newCIdxValue.indexOf(objKey);\n            var emptyString = '';\n            for (var idx = 0; idx < objValue.length; idx++) {\n                emptyString += ' ';\n            }\n            cIdxValue = cIdxValue.slice(0, positionIdx) + objValue + cIdxValue.slice(positionIdx + objKeyLen);\n            newCIdxValue = newCIdxValue.slice(0, positionIdx) + emptyString + newCIdxValue.slice(positionIdx + objKeyLen);\n        }\n        return cIdxValue;\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Retrieves the leading spaces from a given string.\n *\n * @param {string} string - The input string from which to retrieve leading spaces.\n * @returns {string} - A string containing all leading spaces from the input string.\n * @hidden\n */\nfunction getLeadingSpaces(string) {\n    var leadingSpaces = '';\n    for (var i = 0; i < string.length; i++) {\n        if (string[i] === ' ') {\n            leadingSpaces += ' ';\n        }\n        else {\n            break;\n        }\n    }\n    return leadingSpaces;\n}\n/**\n * Retrieves the trailing spaces from a given string.\n *\n * @param {string} string - The input string from which to retrieve trailing spaces.\n * @returns {string} - A string containing all trailing spaces from the input string.\n * @hidden\n */\nfunction getTrailingSpaces(string) {\n    var trailingSpaces = '';\n    for (var i = string.length - 1; i >= 0; i--) {\n        if (string[i] === ' ') {\n            trailingSpaces = ' ' + trailingSpaces;\n        }\n        else {\n            break;\n        }\n    }\n    return trailingSpaces;\n}\n/**\n * @param {Workbook} context - Specifies the context.\n * @param {SheetModel} sheet - Specifies the sheet.\n * @param {CellUpdateArgs} prop - Specifies the props.\n * @param {BeforeActionData} actionData - It holds the undoRedoCollection cell details.\n * @param {boolean} isUndo - It holds the undo information.\n * @returns {boolean} - returns args cancel value.\n * @hidden */\nfunction updateCell(context, sheet, prop, actionData, isUndo) {\n    var args = { cell: prop.cell, rowIndex: prop.rowIdx, colIndex: prop.colIdx, cancel: false, sheet: sheet.name };\n    if (!prop.preventEvt) { // Prevent event triggering for public method cell update.\n        context.trigger(_index__WEBPACK_IMPORTED_MODULE_1__.beforeCellUpdate, args);\n    }\n    if (!prop.eventOnly && !args.cancel) { // `eventOnly` - To trigger event and return without cell model update.\n        if (prop.valChange) {\n            var prevCell = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(args.rowIndex, args.colIndex, sheet);\n            var prevCellVal = !prop.preventEvt && context.getDisplayText(prevCell);\n            var isFormulaCell = !!(prevCell && prevCell.formula);\n            (0,_index__WEBPACK_IMPORTED_MODULE_0__.setCell)(args.rowIndex, args.colIndex, sheet, args.cell, !prop.pvtExtend);\n            var cell = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(args.rowIndex, args.colIndex, sheet, false, true);\n            if (prop.mergedCells) {\n                delete cell.value;\n                delete cell.formula;\n            }\n            if (cell.formattedText) {\n                delete cell.formattedText;\n            }\n            var evtArgs = {\n                action: 'updateCellValue',\n                address: [args.rowIndex, args.colIndex], sheetIndex: (0,_index__WEBPACK_IMPORTED_MODULE_0__.getSheetIndex)(context, sheet.name), value: isFormulaCell && !cell.formula ? (cell.value || (cell.value === 0 ? '0' : '')) :\n                    (cell.formula || cell.value || (cell.value === 0 ? '0' : '')),\n                skipFormatCheck: prop.skipFormatCheck, isRandomFormula: prop.isRandomFormula,\n                isDelete: prop.isDelete, deletedRange: prop.deletedRange, fillType: prop.fillType,\n                cellInformation: actionData, isRedo: !isUndo, actionName: prop.fillType,\n                isPaste: prop.requestType === 'paste'\n            };\n            context.notify(_index__WEBPACK_IMPORTED_MODULE_1__.workbookEditOperation, evtArgs);\n            prop.isFormulaDependent = evtArgs.isFormulaDependent;\n            if (prop.requestType && args.cell === null) {\n                (0,_index__WEBPACK_IMPORTED_MODULE_0__.setCell)(args.rowIndex, args.colIndex, sheet, args.cell, !prop.pvtExtend);\n            }\n            if (prop.cellDelete) {\n                delete cell.value;\n                delete cell.formula;\n                delete cell.hyperlink;\n            }\n            if (prop.uiRefresh) {\n                context.serviceLocator.getService('cell').refresh(args.rowIndex, args.colIndex, prop.lastCell, prop.td, prop.checkCF, prop.checkWrap, prop.skipFormatCheck, prop.isRandomFormula, prop.fillType);\n            }\n            if (!prop.preventEvt) {\n                var cellDisplayText = context.getDisplayText(cell);\n                if (cellDisplayText !== prevCellVal) {\n                    var cellValue = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(args.rowIndex, args.colIndex, sheet, false, true).value;\n                    cellValue = cellValue || (cellValue === 0 ? '0' : '');\n                    var evtArgs_1 = { value: cellValue, oldValue: prevCellVal, formula: cell.formula || '',\n                        address: sheet.name + \"!\" + (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCellAddress)(args.rowIndex, args.colIndex), displayText: cellDisplayText };\n                    if (prop.requestType) {\n                        evtArgs_1.requestType = prop.requestType;\n                    }\n                    context.trigger('cellSave', evtArgs_1);\n                }\n            }\n        }\n        else {\n            (0,_index__WEBPACK_IMPORTED_MODULE_0__.setCell)(args.rowIndex, args.colIndex, sheet, args.cell, !prop.pvtExtend);\n        }\n    }\n    return args.cancel;\n}\n/**\n * @param {number} rowIdx - row index\n * @param {number} colIdx - column index\n * @param {SheetModel} sheet - sheet model\n * @returns {number[]} - retruns data range\n * @hidden\n */\nfunction getDataRange(rowIdx, colIdx, sheet) {\n    var sRowIdx = rowIdx;\n    var eRowIdx = rowIdx;\n    var sColIdx = colIdx;\n    var eColIdx = colIdx;\n    var usedRowIdx = sheet.usedRange.rowIndex;\n    var usedColIdx = sheet.usedRange.colIndex;\n    var isEmptyRow = function (idx) {\n        for (var i = 0; i <= usedColIdx; i++) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isUndefined)((0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(idx, i, sheet, null, true).value)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var isEmptyColumn = function (idx) {\n        for (var i = sRowIdx; i <= eRowIdx; i++) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isUndefined)((0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(i, idx, sheet, null, true).value)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    for (var i = sRowIdx; i <= usedRowIdx; i++) { // To find end row index\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isUndefined)((0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(i, colIdx, sheet, null, true).value) && isEmptyRow(i)) {\n            break;\n        }\n        else {\n            eRowIdx = i;\n        }\n    }\n    for (var i = sRowIdx; i >= 0; i--) { // To find start row index\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isUndefined)((0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(i, colIdx, sheet, null, true).value) && isEmptyRow(i)) {\n            break;\n        }\n        else {\n            sRowIdx = i;\n        }\n    }\n    for (var i = sColIdx; i <= usedColIdx; i++) { // To find end column index\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isUndefined)((0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(rowIdx, i, sheet, null, true).value) && isEmptyColumn(i)) {\n            break;\n        }\n        else {\n            eColIdx = i;\n        }\n    }\n    for (var i = sColIdx; i >= 0; i--) { // To find start column index\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isUndefined)((0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(rowIdx, i, sheet, null, true).value) && isEmptyColumn(i)) {\n            break;\n        }\n        else {\n            sColIdx = i;\n        }\n    }\n    return [sRowIdx, sColIdx, eRowIdx, eColIdx];\n}\n/**\n * @param {InsertDeleteModelArgs} args - row index\n * @param {number[]} formatRange - format range index\n * @param {boolean} isAction - specifies isAction.\n * @returns {number[]} - retruns updated range\n * @hidden\n */\nfunction insertFormatRange(args, formatRange, isAction) {\n    var sltRangeIndex = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(args.model.selectedRange);\n    var insertStartIndex = 0;\n    var insertEndIndex = 0;\n    if (args.modelType === 'Column') {\n        if (isAction || (args.insertType === 'before' && args.isUndoRedo)) {\n            sltRangeIndex = [0, args.start, 0, args.end];\n        }\n        if (args.insertType === 'before') {\n            if ((formatRange[1] <= sltRangeIndex[1] && formatRange[3] >= sltRangeIndex[1])) {\n                insertStartIndex = 0;\n                insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;\n            }\n            else if (sltRangeIndex[1] < formatRange[1]) {\n                insertStartIndex = insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;\n            }\n        }\n        else {\n            if (args.isUndoRedo) {\n                var diffValue = (args.end - args.start) + 1;\n                sltRangeIndex = [0, args.start - diffValue, 0, args.end - diffValue];\n            }\n            if ((formatRange[1] <= sltRangeIndex[3] && formatRange[3] >= sltRangeIndex[3])) {\n                insertStartIndex = 0;\n                insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;\n            }\n            else if (sltRangeIndex[3] < formatRange[3]) {\n                insertStartIndex = insertEndIndex = (sltRangeIndex[3] - sltRangeIndex[1]) + 1;\n            }\n        }\n        return [formatRange[0], formatRange[1] + insertStartIndex, formatRange[2], formatRange[3] + insertEndIndex];\n    }\n    else {\n        if (isAction || (args.insertType === 'above' && args.isUndoRedo)) {\n            sltRangeIndex = [args.start, 0, args.end, 0];\n        }\n        if (args.insertType === 'above') {\n            if ((formatRange[0] <= sltRangeIndex[0] && formatRange[2] >= sltRangeIndex[0])) {\n                insertStartIndex = 0;\n                insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;\n            }\n            else if (sltRangeIndex[0] < formatRange[0]) {\n                insertStartIndex = insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;\n            }\n        }\n        else {\n            if (args.isUndoRedo) {\n                var diffValue = (args.end - args.start) + 1;\n                sltRangeIndex = [args.start - diffValue, 0, args.end - diffValue, 0];\n            }\n            if ((formatRange[0] <= sltRangeIndex[2] && formatRange[2] >= sltRangeIndex[2])) {\n                insertStartIndex = 0;\n                insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;\n            }\n            else if (sltRangeIndex[2] < formatRange[2]) {\n                insertStartIndex = insertEndIndex = (sltRangeIndex[2] - sltRangeIndex[0]) + 1;\n            }\n        }\n        return [formatRange[0] + insertStartIndex, formatRange[1], formatRange[2] + insertEndIndex, formatRange[3]];\n    }\n}\n/**\n * @param {InsertDeleteModelArgs} args - row index\n * @param {number[]} formatRange - cell range index\n * @returns {number[]} - retruns data range\n * @hidden\n */\nfunction deleteFormatRange(args, formatRange) {\n    var cellRange;\n    var deleteStartIndex = 0;\n    var deleteEndIndex = 0;\n    if (args.modelType === 'Column') {\n        cellRange = [0, args.start, args.model.usedRange.rowIndex, args.end];\n        if (cellRange[3] < formatRange[1]) {\n            deleteStartIndex = deleteEndIndex = cellRange[3] - cellRange[1] + 1;\n        }\n        else if (cellRange[1] >= formatRange[1] && cellRange[3] <= formatRange[3]) {\n            deleteEndIndex = cellRange[3] - cellRange[1] + 1;\n        }\n        else if (cellRange[1] >= formatRange[1] && cellRange[1] <= formatRange[3]) {\n            deleteEndIndex = formatRange[3] - cellRange[1] + 1;\n        }\n        else if (cellRange[1] < formatRange[1] && cellRange[3] >= formatRange[1]) {\n            deleteStartIndex = formatRange[1] - cellRange[1];\n            deleteEndIndex = cellRange[3] - cellRange[1] + 1;\n        }\n        else if (cellRange[1] < formatRange[1] && cellRange[3] < formatRange[3]) {\n            deleteStartIndex = (cellRange[3] - formatRange[1]) + (cellRange[3] - cellRange[1]) + 1;\n            deleteEndIndex = cellRange[3] - cellRange[1] + 1;\n        }\n        return [formatRange[0], formatRange[1] - deleteStartIndex, formatRange[2], formatRange[3] - deleteEndIndex];\n    }\n    else {\n        cellRange = [args.start, 0, args.end, args.model.usedRange.colIndex];\n        if (cellRange[2] < formatRange[0]) {\n            deleteStartIndex = deleteEndIndex = cellRange[2] - cellRange[0] + 1;\n        }\n        else if (cellRange[0] >= formatRange[0] && cellRange[2] <= formatRange[2]) {\n            deleteEndIndex = cellRange[2] - cellRange[0] + 1;\n        }\n        else if (cellRange[0] >= formatRange[0] && cellRange[0] <= formatRange[2]) {\n            deleteEndIndex = formatRange[2] - cellRange[0] + 1;\n        }\n        else if (cellRange[0] < formatRange[0] && cellRange[2] >= formatRange[0]) {\n            deleteStartIndex = formatRange[0] - cellRange[0];\n            deleteEndIndex = cellRange[2] - cellRange[0] + 1;\n        }\n        else if (cellRange[0] < formatRange[0] && cellRange[2] < formatRange[2]) {\n            deleteStartIndex = (cellRange[2] - formatRange[0]) + (cellRange[2] - cellRange[0]) + 1;\n            deleteEndIndex = cellRange[2] - cellRange[0] + 1;\n        }\n        return [formatRange[0] - deleteStartIndex, formatRange[1], formatRange[2] - deleteEndIndex, formatRange[3]];\n    }\n}\n/**\n * @param {ConditionalFormat[]} curCF - Specifies current Conditional formatting.\n * @param {ConditionalFormatModel[]} cfRule - Specifies conditional formatting rules.\n * @param {number} rowIdx - Specifies the row index.\n * @param {number} colIdx -Specifies the col index.\n * @param {number[]} startRanges - Specifies conditional formatting origin index.\n * @param {number[]} fillRanges - Specifies the conditional formatting fill ranges.\n * @param {SheetModel} sheet -Specifies the conditional formatted sheet.\n * @returns {void} - Updates Conditional formatting model.\n * @hidden\n */\nfunction updateCFModel(curCF, cfRule, rowIdx, colIdx, startRanges, fillRanges, sheet) {\n    var cfRange;\n    var indexes;\n    for (var i = curCF.length - 1; i >= 0; i--) {\n        cfRange = curCF[i].range.trim().split(',');\n        for (var j = 0; j < cfRange.length; j++) {\n            indexes = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(cfRange[j].includes(':') ? cfRange[j] :\n                cfRange[j] + \":\" + cfRange[j]);\n            if (rowIdx >= indexes[0] && colIdx >= indexes[1] && rowIdx <= indexes[2] && colIdx <= indexes[3]) {\n                cfRule.push(curCF[i]);\n                curCF.splice(i, 1);\n                break;\n            }\n            else if (startRanges && startRanges[0] >= indexes[0] && startRanges[1] >= indexes[1] &&\n                startRanges[0] <= indexes[2] && startRanges[1] <= indexes[3]) {\n                var newCondiFormat = {\n                    action: 'autofillWithCF',\n                    cFColor: curCF[i].cFColor,\n                    range: (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeAddress)(fillRanges),\n                    type: curCF[i].type,\n                    value: curCF[i].value\n                };\n                curCF.splice(i, 1);\n                for (var i_1 = 0, cfMembers = sheet.conditionalFormats; i_1 < cfMembers.length; i_1++) {\n                    if (cfMembers[i_1].action === 'autofillWithCF' && cfMembers[i_1].range === newCondiFormat.range) {\n                        break;\n                    }\n                    else if (i_1 === cfMembers.length - 1) {\n                        cfRule.push(newCondiFormat);\n                        sheet.conditionalFormats.push(newCondiFormat);\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n/**\n * @param {number} indexes - Specifies the indexes.\n * @param {string} range - Specifies the range.\n * @returns {boolean} - Return is range or not.\n * @hidden\n */\nfunction checkRange(indexes, range) {\n    var ranges = range.trim().split(',');\n    var left;\n    var right;\n    var top;\n    var bottom;\n    var cfIdx;\n    var checkRange = function (idx) {\n        for (var i = 0; i < ranges.length; i++) {\n            cfIdx = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(ranges[i].includes(':') ? ranges[i] : ranges[i] + \":\" + ranges[i]);\n            if (idx[0] <= cfIdx[0] && idx[1] <= cfIdx[1] && idx[2] >= cfIdx[2] && idx[3] >= cfIdx[3]) {\n                return true;\n            }\n            else {\n                top = idx[0] >= cfIdx[0] && idx[0] <= cfIdx[2];\n                bottom = idx[2] >= cfIdx[0] && idx[2] <= cfIdx[2];\n                left = idx[1] >= cfIdx[1] && idx[1] <= cfIdx[3];\n                right = idx[3] >= cfIdx[1] && idx[3] <= cfIdx[3];\n                if (top && bottom) {\n                    if (left || right || (idx[1] < cfIdx[1] && idx[3] > cfIdx[3])) {\n                        if (idx[0] - cfIdx[0] > 0) {\n                            return true;\n                        }\n                        if (cfIdx[2] - idx[2] > 0) {\n                            return true;\n                        }\n                    }\n                    if (left && idx[1] !== cfIdx[1]) {\n                        return true;\n                    }\n                    if (right && idx[3] !== cfIdx[3]) {\n                        return true;\n                    }\n                }\n                else if (left && right) {\n                    if (top || bottom || (idx[0] < cfIdx[0] && idx[2] > cfIdx[2])) {\n                        if (idx[1] - cfIdx[1] > 0) {\n                            return true;\n                        }\n                        if (cfIdx[3] - idx[3] > 0) {\n                            return true;\n                        }\n                    }\n                    if (top) {\n                        if (idx[0] !== cfIdx[0]) {\n                            return true;\n                        }\n                    }\n                    else if (bottom && idx[2] !== cfIdx[2]) {\n                        return true;\n                    }\n                }\n                else if (top || bottom) {\n                    if (left) {\n                        if (idx[1] !== cfIdx[1]) {\n                            return true;\n                        }\n                        if (idx[0] - cfIdx[0] > 0) {\n                            return true;\n                        }\n                        else if (cfIdx[2] - idx[2] > 0) {\n                            return true;\n                        }\n                    }\n                    else if (right) {\n                        if (idx[3] !== cfIdx[3]) {\n                            return true;\n                        }\n                        if (idx[0] - cfIdx[0] > 0) {\n                            return true;\n                        }\n                        else if (cfIdx[2] - idx[2] > 0) {\n                            return true;\n                        }\n                    }\n                    else if (idx[1] < cfIdx[1] && idx[3] > cfIdx[3]) {\n                        return true;\n                    }\n                }\n                else if ((left || right) && idx[0] < cfIdx[0] && idx[2] > cfIdx[2]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    for (var j = 0; j < indexes.length; j++) {\n        if (checkRange(indexes[j])) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Parse the formatted text to get the actual cell value.\n *\n * @param {string[]} valArr - Specifies the value array.\n * @param {string} context - Specifies the workbook instance.\n * @param {LocaleNumericSettings} numObj - Specifies the locale numeric options like decimal and group separators.\n * @returns {string[]} - Returns the parsed number collection.\n * @hidden\n */\nfunction parseLocaleNumber(valArr, context, numObj) {\n    var formatArgs;\n    if (!numObj) {\n        numObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.getNumericObject)(context.locale);\n    }\n    for (var idx = 0; idx < valArr.length; idx++) {\n        if ((0,_index__WEBPACK_IMPORTED_MODULE_0__.isNumber)(valArr[idx])) {\n            if (numObj.group === '.') {\n                valArr[idx] = valArr[idx].toString();\n                if (valArr[idx].indexOf('.') &&\n                    (0,_internalization__WEBPACK_IMPORTED_MODULE_3__.parseThousandSeparator)(valArr[idx], context.locale, numObj.group, numObj.decimal)) {\n                    valArr[idx] = valArr[idx].split(numObj.group).join('');\n                }\n            }\n        }\n        else {\n            formatArgs = { formattedText: valArr[idx], value: valArr[idx], format: 'General',\n                cell: { value: valArr[idx], format: 'General' }, isEdit: true };\n            context.notify(_index__WEBPACK_IMPORTED_MODULE_0__.getFormattedCellObject, formatArgs);\n            if ((0,_index__WEBPACK_IMPORTED_MODULE_0__.isNumber)(formatArgs.value)) {\n                valArr[idx] = formatArgs.value.toString();\n            }\n        }\n    }\n    return valArr;\n}\n/**\n * Returns the overall viewport indexes by including the freeze and movable part.\n *\n * @param {Workbook} parent - Specify the Workbook object.\n * @param {number} viewport - Specifies the top, bottom, left, and right index of the current viewport.\n * @param {number} viewport.topIndex - Specifies the top index of the current viewport.\n * @param {number} viewport.leftIndex - Specifies the left index of the current viewport.\n * @param {number} viewport.bottomIndex - Specifies the bottom index of the current viewport.\n * @param {number} viewport.rightIndex - Specifies the right index of the current viewport.\n * @returns {number} - Returns the viewport indexes.\n * @hidden\n */\nfunction getViewportIndexes(parent, viewport) {\n    var sheet = parent.getActiveSheet();\n    var indexes = [[viewport.topIndex + parent.frozenRowCount(sheet), viewport.leftIndex + parent.frozenColCount(sheet),\n            viewport.bottomIndex, viewport.rightIndex]];\n    if (sheet.frozenRows || sheet.frozenColumns) {\n        var froezenRow = parent.frozenRowCount(sheet);\n        var froezenCol = parent.frozenColCount(sheet);\n        var topLeftCell = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCellIndexes)(sheet.topLeftCell);\n        if (froezenRow && froezenCol) {\n            indexes.push([topLeftCell[0], topLeftCell[1], froezenRow - 1, froezenCol - 1]);\n            var paneTopLeftCell = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCellIndexes)(sheet.paneTopLeftCell);\n            indexes.push([paneTopLeftCell[0], topLeftCell[1], viewport.bottomIndex, froezenCol - 1]);\n        }\n        if (froezenRow) {\n            indexes.push([topLeftCell[0], viewport.leftIndex + froezenCol, froezenRow - 1, viewport.rightIndex]);\n        }\n        if (froezenCol) {\n            indexes.push([viewport.topIndex + froezenRow, topLeftCell[1], viewport.bottomIndex,\n                froezenCol - 1]);\n        }\n    }\n    return indexes;\n}\n/**\n * If the primary cell in the merged range row/column is hidden, then this method will update\n * the next visible row/column index within the merged range.\n *\n * @param {VisibleMergeIndexArgs} args - Specifies the args.\n * @returns {void} - Update the next visible row/column index within the merged range.\n */\nfunction setVisibleMergeIndex(args) {\n    if ((0,_index__WEBPACK_IMPORTED_MODULE_0__.isHiddenRow)(args.sheet, args.rowIdx)) {\n        var idx = skipHiddenIdx(args.sheet, args.rowIdx, true);\n        if (idx < args.rowIdx + args.cell.rowSpan) {\n            args.rowIdx = idx;\n            args.isMergedHiddenCell = true;\n        }\n    }\n    if ((0,_index__WEBPACK_IMPORTED_MODULE_0__.isHiddenCol)(args.sheet, args.colIdx)) {\n        var idx = skipHiddenIdx(args.sheet, args.colIdx, true, 'columns');\n        if (idx < args.colIdx + args.cell.colSpan) {\n            args.colIdx = idx;\n            args.isMergedHiddenCell = true;\n        }\n    }\n}\n/**\n * Check whether the sheets are imported.\n *\n * @param {Workbook} context - Specifies the spreadsheet instance.\n * @returns {boolean} - It returns true if the sheets are imported otherwise false.\n * @hidden\n */\nfunction isImported(context) {\n    return context.workbookOpenModule && context.workbookOpenModule.preventFormatCheck;\n}\n/**\n * Return a function that will auto-detect the number format of the formatted cell value.\n *\n * @param {Workbook} context - Specifies the Workbook instance.\n * @returns {void} - Defines the common variables and returns the auto-detect number format function.\n * @hidden\n */\nfunction getAutoDetectFormatParser(context) {\n    var intl = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.Internationalization();\n    var eventArgs = { intl: intl, updateValue: true, value: '',\n        curSymbol: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.getNumberDependable)(context.locale, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.defaultCurrencyCode) };\n    var options = { args: eventArgs, intl: intl };\n    var localeNumObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.getNumericObject)(context.locale);\n    return function (cell) {\n        if (!cell.format && cell.value && !(0,_index__WEBPACK_IMPORTED_MODULE_0__.isNumber)(cell.value)) {\n            eventArgs.cell = cell;\n            eventArgs.value = cell.value;\n            context.notify(_index__WEBPACK_IMPORTED_MODULE_0__.checkDateFormat, eventArgs);\n            if (!cell.format) {\n                var cellVal = cell.value.toString();\n                if (cellVal.includes(options.args.curSymbol) || cellVal.includes(localeNumObj.group) || cellVal.includes('%')) {\n                    options.fResult = cellVal;\n                    context.notify(_index__WEBPACK_IMPORTED_MODULE_0__.checkNumberFormat, options);\n                }\n                else if (localeNumObj.decimal !== '.' && !(0,_index__WEBPACK_IMPORTED_MODULE_0__.isNumber)(cellVal)) {\n                    if (cellVal.includes(localeNumObj.decimal)) {\n                        cellVal = cellVal.replace(localeNumObj.decimal, '.');\n                        if ((0,_index__WEBPACK_IMPORTED_MODULE_0__.isNumber)(cellVal)) {\n                            cell.value = cellVal;\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n/**\n *\n * @param {DataManager} dataManager - Specifies the Datamanager.\n * @param {Predicate[]} predicates - Specifies the predicates.\n * @param {Predicate[]} equalOrPredicates - Specifies the equal or predicates.\n * @returns {Object[]} - Returns apply predicates object.\n * @hidden\n */\nfunction applyPredicates(dataManager, predicates, equalOrPredicates) {\n    var query = new _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.Query();\n    if (predicates.length) {\n        query.where(_syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.Predicate.and(predicates));\n    }\n    var result = dataManager.executeLocal(query);\n    if (equalOrPredicates) {\n        for (var idx = 0, predicateCollLen = equalOrPredicates.length; idx < predicateCollLen; idx++) {\n            if (!result.length) {\n                break;\n            }\n            query = new _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.Query();\n            if (equalOrPredicates[idx].length) {\n                query.where(_syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.Predicate.or(equalOrPredicates[idx]));\n            }\n            result = new _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.DataManager(result).executeLocal(query);\n        }\n    }\n    return result;\n}\n/**\n * Checks whether the cell is read-only or not.\n *\n * @param {CellModel} cell - The cell to check.\n * @param {ColumnModel} column - The column associated with the cell.\n * @param {RowModel} row - The row associated with the cell.\n * @returns {boolean} - Returns true if the cell is read-only, otherwise false.\n * @hidden\n */\nfunction isReadOnly(cell, column, row) {\n    return (cell && cell.isReadOnly) || (row && row.isReadOnly) || (column && column.isReadOnly);\n}\n/**\n * Checks whether a specific range of cells is read-only or not.\n *\n * @param {Workbook} parent - The spreadsheet instance.\n * @param {number[]} rangeIndexes - The range indexes to check.\n * @returns {boolean} - Returns true if any of the cells is read-only, otherwise false.\n * @hidden\n */\nfunction isReadOnlyCells(parent, rangeIndexes) {\n    var sheet = parent.getActiveSheet();\n    var hasReadOnlyCell;\n    var address = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(rangeIndexes) ? rangeIndexes : (0,_index__WEBPACK_IMPORTED_MODULE_1__.getSwapRange)((0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(sheet.selectedRange));\n    for (var row = address[0]; row <= address[2]; row++) {\n        for (var col = address[1]; col <= address[3]; col++) {\n            var cell = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(row, col, sheet);\n            if (isReadOnly(cell, (0,_index__WEBPACK_IMPORTED_MODULE_0__.getColumn)(sheet, col), (0,_index__WEBPACK_IMPORTED_MODULE_0__.getRow)(sheet, row))) {\n                hasReadOnlyCell = true;\n                break;\n            }\n        }\n    }\n    return hasReadOnlyCell;\n}\n/**\n * Checks whether the selected range in the sheet is an entire row or column and returns the updated range accordingly.\n *\n * @param {SheetModel} sheet -Specifies the sheet.\n * @param {string} range - Specify the range that need to be updated.\n * @returns {string} - Retruns updated range\n * @hidden\n */\nfunction getUpdatedRange(sheet, range) {\n    var updateRange = range || sheet.selectedRange;\n    var indexes = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRangeIndexes)(updateRange);\n    var maxColCount = sheet.colCount;\n    var maxRowCount = sheet.rowCount;\n    if (indexes[2] === maxRowCount - 1 && indexes[0] === 0) {\n        updateRange = updateRange.replace(/[0-9]/g, '');\n    }\n    else if (indexes[3] === maxColCount - 1 && indexes[2] === 0) {\n        updateRange = updateRange.replace(/\\D/g, '');\n    }\n    return updateRange;\n}\n/**\n * Updated the top border of the adjacent merged cells\n *\n * @param {Workbook} context - The spreadsheet instance.\n * @param {number[]} rowIndexes - An array of row indexes that top border need to be updated.\n * @param {number[]} colIndexes - An array of col indexes that top border need to be updated.\n * @returns {void}\n * @hidden\n */\nfunction updateMergeBorder(context, rowIndexes, colIndexes) {\n    if (!rowIndexes.length) {\n        return;\n    }\n    var sheet = context.getActiveSheet();\n    var style;\n    var parent = context;\n    var frozenCol = context.frozenColCount(sheet);\n    var startCol = (colIndexes && colIndexes[0]) ||\n        (frozenCol ? (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCellIndexes)(sheet.topLeftCell)[1] : parent.viewport.leftIndex);\n    var endCol = (colIndexes && colIndexes[1]) || parent.viewport.rightIndex;\n    rowIndexes.forEach(function (rowIdx) {\n        for (var col = startCol; col <= endCol; col++) {\n            if (col === frozenCol) {\n                col += parent.viewport.leftIndex;\n            }\n            var prevModel = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(rowIdx - 1, col, sheet, false, true);\n            if (((!prevModel.rowSpan || prevModel.rowSpan === 1)\n                || (!prevModel.colSpan || prevModel.colSpan === 1)) &&\n                (!prevModel.style || !prevModel.style.borderBottom || prevModel.style.borderBottom === 'none')) {\n                style = (0,_index__WEBPACK_IMPORTED_MODULE_0__.getCell)(rowIdx, col, sheet, false, true).style;\n                if (style && style.borderTop) {\n                    var prevCell = context.getCell(rowIdx - 1, col);\n                    if (prevCell && prevCell.style.borderBottom) {\n                        var curCell = context.getCell(rowIdx, col);\n                        if (curCell) {\n                            prevCell.style.borderBottom = '';\n                            curCell.style.borderTop = style.borderTop;\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/common/util.js?");

/***/ })

}]);