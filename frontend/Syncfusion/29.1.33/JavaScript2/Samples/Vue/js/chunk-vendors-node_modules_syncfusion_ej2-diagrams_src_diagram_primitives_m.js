"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_primitives_m"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MatrixTypes: () => (/* binding */ MatrixTypes),\n/* harmony export */   identityMatrix: () => (/* binding */ identityMatrix),\n/* harmony export */   multiplyMatrix: () => (/* binding */ multiplyMatrix),\n/* harmony export */   rotateMatrix: () => (/* binding */ rotateMatrix),\n/* harmony export */   scaleMatrix: () => (/* binding */ scaleMatrix),\n/* harmony export */   transformPointByMatrix: () => (/* binding */ transformPointByMatrix),\n/* harmony export */   transformPointsByMatrix: () => (/* binding */ transformPointsByMatrix),\n/* harmony export */   translateMatrix: () => (/* binding */ translateMatrix)\n/* harmony export */ });\n/**\n * Matrix module is used to transform points based on offsets, angle\n */\n/** @private */\nvar MatrixTypes;\n(function (MatrixTypes) {\n    MatrixTypes[MatrixTypes[\"Identity\"] = 0] = \"Identity\";\n    MatrixTypes[MatrixTypes[\"Translation\"] = 1] = \"Translation\";\n    MatrixTypes[MatrixTypes[\"Scaling\"] = 2] = \"Scaling\";\n    MatrixTypes[MatrixTypes[\"Unknown\"] = 4] = \"Unknown\";\n})(MatrixTypes || (MatrixTypes = {}));\n/** @private */\nvar Matrix = /** @class */ (function () {\n    function Matrix(m11, m12, m21, m22, offsetX, offsetY, type) {\n        this.m11 = m11;\n        this.m12 = m12;\n        this.m21 = m21;\n        this.m22 = m22;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        // if (type === undefined) {\n        //     this.type = MatrixTypes.Unknown;\n        // } else {\n        //     this.type = type;\n        // }\n        this.type = type;\n    }\n    return Matrix;\n}());\n\n/**\n * Will identify the  matrix .\\\n *\n * @returns {Matrix}  Will identify the  matrix .\n * @private\n */\nfunction identityMatrix() {\n    return new Matrix(1, 0, 0, 1, 0, 0, MatrixTypes.Identity);\n}\n/**\n * Will transform the points by matrix .\\\n *\n * @returns {PointModel[]}  Will transform the points by matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} point -  provide the points value.\n * @private\n */\nfunction transformPointByMatrix(matrix, point) {\n    var pt = multiplyPoint(matrix, point.x, point.y);\n    return { x: Math.round(pt.x * 100) / 100, y: Math.round(pt.y * 100) / 100 };\n}\n/**\n * Will transform the points by matrix .\\\n *\n * @returns {PointModel[]}  Will transform the points by matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} points -  provide the points value.\n * @private\n */\nfunction transformPointsByMatrix(matrix, points) {\n    var transformedPoints = [];\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n        var point = points_1[_i];\n        transformedPoints.push(transformPointByMatrix(matrix, point));\n    }\n    return transformedPoints;\n}\n/**\n * Will rotate the matrix .\\\n *\n * @returns {void}  Will rotate the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} angle - provide the angle value.\n * @param {number} centerX - provide the centerX value .\n * @param {number} centerY - provide the centerY value .\n * @private\n */\nfunction rotateMatrix(matrix, angle, centerX, centerY) {\n    angle %= 360.0;\n    multiplyMatrix(matrix, createRotationRadians(angle * 0.017453292519943295, centerX ? centerX : 0, centerY ? centerY : 0));\n}\n/**\n * Will scale the matrix .\\\n *\n * @returns {void} Will scale the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} scaleX - provide the scaleXvalue.\n * @param {number} scaleY - provide the scaleY value .\n * @param {number} centerX - provide the centerX value .\n * @param {number} centerY - provide the centerY value .\n * @private\n */\nfunction scaleMatrix(matrix, scaleX, scaleY, centerX, centerY) {\n    if (centerX === void 0) { centerX = 0; }\n    if (centerY === void 0) { centerY = 0; }\n    multiplyMatrix(matrix, createScaling(scaleX, scaleY, centerX, centerY));\n}\n/**\n * Will translate the matrix .\\\n *\n * @returns {void} Will translate the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} offsetX - provide the offset x value.\n * @param {number} offsetY - provide the offset y value .\n * @private\n */\nfunction translateMatrix(matrix, offsetX, offsetY) {\n    //Removed identity and unknown matrix type checking\n    matrix.offsetX += offsetX;\n    matrix.offsetY += offsetY;\n    matrix.type |= MatrixTypes.Translation;\n}\n/**\n * Will create scaling value .\\\n *\n * @returns {Matrix} Will create scaling value . .\n *\n * @param {Matrix} scaleX - provide the scale x value  .\n * @param {number} scaleY - provide the scale y value.\n * @param {number} centerX - provide the centerX x value .\n * @param {number} centerY - provide the centerX y value .\n * @private\n */\nfunction createScaling(scaleX, scaleY, centerX, centerY) {\n    var result = identityMatrix();\n    result.type = !(centerX || centerY) ? MatrixTypes.Scaling : MatrixTypes.Scaling | MatrixTypes.Translation;\n    setMatrix(result, scaleX, 0.0, 0.0, scaleY, centerX - scaleX * centerX, centerY - scaleY * centerY);\n    return result;\n}\n/**\n * Will create the rotation radians.\\\n *\n * @returns {Matrix} Will create the rotation radians .\n *\n * @param {Matrix} angle - provide the angle  .\n * @param {number} centerX - provide the x value .\n * @param {number} centerY - provide the y value .\n * @private\n */\nfunction createRotationRadians(angle, centerX, centerY) {\n    var result = identityMatrix();\n    var num = Math.sin(angle);\n    var num2 = Math.cos(angle);\n    var offsetX = centerX * (1.0 - num2) + centerY * num;\n    var offsetY = centerY * (1.0 - num2) - centerX * num;\n    result.type = MatrixTypes.Unknown;\n    setMatrix(result, num2, num, -num, num2, offsetX, offsetY);\n    return result;\n}\n/**\n * Multiply the point .\\\n *\n * @returns {void} Multiply the point .\n *\n * @param {Matrix} matrix - Provide the matrix .\n * @param {number} x - provide the x value .\n * @param {number} y - provide the y value .\n * @private\n */\nfunction multiplyPoint(matrix, x, y) {\n    switch (matrix.type) {\n        //Removed identity and translation and scaling matrix type checking\n        case MatrixTypes.Translation | MatrixTypes.Scaling:\n            x *= matrix.m11;\n            x += matrix.offsetX;\n            y *= matrix.m22;\n            y += matrix.offsetY;\n            break;\n        default:\n            // eslint-disable-next-line no-case-declarations\n            var num = y * matrix.m21 + matrix.offsetX;\n            // eslint-disable-next-line no-case-declarations\n            var num2 = x * matrix.m12 + matrix.offsetY;\n            x *= matrix.m11;\n            x += num;\n            y *= matrix.m22;\n            y += num2;\n            break;\n    }\n    return { x: x, y: y };\n}\n/**\n * Will multiply the matrix .\\\n *\n * @returns {void} Will multiply the matrix .\n *\n * @param {Matrix} matrix1 - Provide the matrix 1 value .\n * @param {Matrix} matrix2 - Provide the matrix 2 value .\n * @private\n */\nfunction multiplyMatrix(matrix1, matrix2) {\n    var type = matrix1.type;\n    var type2 = matrix2.type;\n    //Removed identity matrix type checking\n    if (type === MatrixTypes.Identity) {\n        assignMatrix(matrix1, matrix2);\n        matrix1.type = matrix2.type;\n        return;\n    }\n    //Removed translation matrix type checking\n    if (type !== MatrixTypes.Translation) {\n        var num = type << 4 | type2;\n        //Removed num 34,35,36\n        switch (num) {\n            case 50:\n                matrix1.m11 *= matrix2.m11;\n                matrix1.m22 *= matrix2.m22;\n                matrix1.offsetX *= matrix2.m11;\n                matrix1.offsetY *= matrix2.m22;\n                return;\n            case 51:\n                matrix1.m11 *= matrix2.m11;\n                matrix1.m22 *= matrix2.m22;\n                matrix1.offsetX = matrix2.m11 * matrix1.offsetX + matrix2.offsetX;\n                matrix1.offsetY = matrix2.m22 * matrix1.offsetY + matrix2.offsetY;\n                return;\n            case 52: break;\n            default:\n                switch (num) {\n                    case 66:\n                    case 67:\n                    case 68: break;\n                    default: return;\n                }\n                break;\n        }\n        var result = identityMatrix();\n        var m11New = matrix1.m11 * matrix2.m11 + matrix1.m12 * matrix2.m21;\n        var m12New = matrix1.m11 * matrix2.m12 + matrix1.m12 * matrix2.m22;\n        var m21New = matrix1.m21 * matrix2.m11 + matrix1.m22 * matrix2.m21;\n        var m22New = matrix1.m21 * matrix2.m12 + matrix1.m22 * matrix2.m22;\n        var offsetX_1 = matrix1.offsetX * matrix2.m11 + matrix1.offsetY * matrix2.m21 + matrix2.offsetX;\n        var offsetY_1 = matrix1.offsetX * matrix2.m12 + matrix1.offsetY * matrix2.m22 + matrix2.offsetY;\n        setMatrix(result, m11New, m12New, m21New, m22New, offsetX_1, offsetY_1);\n        if (result.m21 || result.m12) {\n            result.type = MatrixTypes.Unknown;\n        }\n        else {\n            if (result.m11 && result.m11 !== 1.0 || result.m22 && result.m22 !== 1.0) {\n                result.type = MatrixTypes.Scaling;\n            }\n            if (result.offsetX || result.offsetY) {\n                result.type |= MatrixTypes.Translation;\n            }\n            if ((result.type & (MatrixTypes.Translation | MatrixTypes.Scaling)) === MatrixTypes.Identity) {\n                result.type = MatrixTypes.Identity;\n            }\n            result.type = MatrixTypes.Scaling | MatrixTypes.Translation;\n        }\n        assignMatrix(matrix1, result);\n        matrix1.type = result.type;\n        return;\n    }\n    var offsetX = matrix1.offsetX;\n    var offsetY = matrix1.offsetY;\n    matrix1.offsetX = offsetX * matrix2.m11 + offsetY * matrix2.m21 + matrix2.offsetX;\n    matrix1.offsetY = offsetX * matrix2.m12 + offsetY * matrix2.m22 + matrix2.offsetY;\n    if (type2 === MatrixTypes.Unknown) {\n        matrix1.type = MatrixTypes.Unknown;\n        return;\n    }\n    matrix1.type = (MatrixTypes.Translation | MatrixTypes.Scaling);\n}\n/**\n * set the matrix .\\\n *\n * @returns {void} set the matrix .\n *\n * @param {Matrix} mat - Provide the matrix 1 value .\n * @param {number} m11 - Provide the matrix m11 value .\n * @param {number} m12 - Provide the matrix m11 value .\n * @param {number} m21 - Provide the matrix m11 value .\n * @param {number} m22 - Provide the matrix m11 value .\n * @param {number} x - Provide the matrix m11 value .\n * @param {number} y - Provide the matrix m11 value .\n * @private\n */\nfunction setMatrix(mat, m11, m12, m21, m22, x, y) {\n    mat.m11 = m11;\n    mat.m12 = m12;\n    mat.m21 = m21;\n    mat.m22 = m22;\n    mat.offsetX = x;\n    mat.offsetY = y;\n}\n/**\n * Assign the matrix .\\\n *\n * @returns {void} Assign the matrix .\n *\n * @param {Matrix} matrix1 - Provide the element type as string .\n * @param {Matrix} matrix2 - Provide the element type as string .\n * @private\n */\nfunction assignMatrix(matrix1, matrix2) {\n    matrix1.m11 = matrix2.m11;\n    matrix1.m12 = matrix2.m12;\n    matrix1.m21 = matrix2.m21;\n    matrix1.m22 = matrix2.m22;\n    matrix1.offsetX = matrix2.offsetX;\n    matrix1.offsetY = matrix2.offsetY;\n    matrix1.type = matrix2.type;\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Defines and processes coordinates\n */\nvar Point = /** @class */ (function (_super) {\n    __extends(Point, _super);\n    function Point() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * equals method \\\n     *\n     * @returns { boolean } equals method .\\\n     * @param {PointModel} point1 - provide the point1 value.\n     * @param {PointModel} point2 - provide the point1 value.\n     *\n     * @private\n     */\n    Point.equals = function (point1, point2) {\n        if (point1 === point2) {\n            return true;\n        }\n        if (!point1 || !point2) {\n            return false;\n        }\n        return !point1 || !point2 || point1.x === point2.x && point1.y === point2.y;\n    };\n    /**\n     * isEmptyPoint method \\\n     *\n     * @returns { boolean } isEmptyPoint method .\\\n     * @param {PointModel} point - provide the points value.\n     *\n     * @private\n     */\n    Point.isEmptyPoint = function (point) {\n        if (point.x && point.y) {\n            return false;\n        }\n        return true;\n    };\n    // public add(point1: PointModel, point2: PointModel): PointModel {\n    //     return { x: point1.x + point2.x, y: point1.y + point2.y };\n    // }\n    // public subtract(point1: PointModel, point2: PointModel): PointModel {\n    //     return { x: point1.x - point2.x, y: point1.y - point2.y };\n    // }\n    // public multiply(point1: PointModel, point2: PointModel): PointModel {\n    //     return {\n    //         x: point1.x * point2.x, y: point1.y * point2.y\n    //     };\n    // }\n    // public crossProduct(point1: PointModel, point2: PointModel): PointModel {\n    //     return {\n    //         x: point1.x * point2.y, y: point2.x * point1.y\n    //     };\n    // }\n    // public offset(offsetX: number, offsetY: number): void {\n    //     this.x += offsetX;\n    //     this.y += offsetY;\n    // }\n    // public rotate(angle: number): PointModel {\n    //     let c: number = Math.cos(angle);\n    //     let s: number = Math.sin(angle);\n    //     return {\n    //         x: c * this.x - s * this.y, y: s * this.x + c * this.y\n    //     };\n    // }\n    // public distance(point2: PointModel): number {\n    //     return Math.sqrt(Math.pow(this.x - point2.x, 2) + Math.pow(this.y - point2.y, 2));\n    // }\n    /**\n     * transform method \\\n     *\n     * @returns { PointModel } transform method .\\\n     * @param {PointModel} point - provide the points value.\n     * @param {number} angle - provide the points value.\n     * @param {number} length - provide the points value.\n     *\n     * @private\n     */\n    Point.transform = function (point, angle, length) {\n        var pt = { x: 0, y: 0 };\n        pt.x = Math.round((point.x + length * Math.cos(angle * Math.PI / 180)) * 100) / 100;\n        pt.y = Math.round((point.y + length * Math.sin(angle * Math.PI / 180)) * 100) / 100;\n        return pt;\n    };\n    /**\n     * findLength method \\\n     *\n     * @returns { number } findLength method .\\\n     * @param {PointModel} s - provide the points value.\n     * @param {PointModel} e - provide the points value.\n     *\n     * @private\n     */\n    Point.findLength = function (s, e) {\n        var length = Math.sqrt(Math.pow((s.x - e.x), 2) + Math.pow((s.y - e.y), 2));\n        return length;\n    };\n    /**\n     * findAngle method \\\n     *\n     * @returns { number } findAngle method .\\\n     * @param {PointModel} point1 - provide the points value.\n     * @param {PointModel} point2 - provide the points value.\n     *\n     * @private\n     */\n    Point.findAngle = function (point1, point2) {\n        var angle = Math.atan2(point2.y - point1.y, point2.x - point1.x);\n        angle = (180 * angle / Math.PI);\n        angle %= 360;\n        if (angle < 0) {\n            angle += 360;\n        }\n        return angle;\n    };\n    /**\n     * distancePoints method \\\n     *\n     * @returns { number } distancePoints method .\\\n     * @param {PointModel} pt1 - provide the points value.\n     * @param {PointModel} pt2 - provide the points value.\n     *\n     * @private\n     */\n    Point.distancePoints = function (pt1, pt2) {\n        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n    };\n    /**\n     * getLengthFromListOfPoints method \\\n     *\n     * @returns { number } getLengthFromListOfPoints method .\\\n     * @param {PointModel[]} points - provide the points value.\n     *\n     * @private\n     */\n    Point.getLengthFromListOfPoints = function (points) {\n        var length = 0;\n        for (var j = 0; j < points.length - 1; j++) {\n            length += this.distancePoints(points[parseInt(j.toString(), 10)], points[j + 1]);\n        }\n        return length;\n    };\n    /**\n     * adjustPoint method \\\n     *\n     * @returns { PointModel } adjustPoint method .\\\n     * @param {PointModel} source - provide the points value.\n     * @param {PointModel} target - provide the points value.\n     * @param {boolean} isStart - provide the isStart value.\n     * @param {number} length - provide the length value.\n     *\n     * @private\n     */\n    Point.adjustPoint = function (source, target, isStart, length) {\n        var pt = isStart ? { x: source.x, y: source.y } : { x: target.x, y: target.y };\n        var angle;\n        if (source.x === target.x) {\n            if (source.y < target.y && isStart || source.y > target.y && !isStart) {\n                pt.y += length;\n            }\n            else {\n                pt.y -= length;\n            }\n        }\n        else if (source.y === target.y) {\n            if (source.x < target.x && isStart || source.x > target.x && !isStart) {\n                pt.x += length;\n            }\n            else {\n                pt.x -= length;\n            }\n        }\n        else {\n            if (isStart) {\n                angle = this.findAngle(source, target);\n                pt = this.transform(source, angle, length);\n            }\n            else {\n                angle = this.findAngle(target, source);\n                pt = this.transform(target, angle, length);\n            }\n        }\n        return pt;\n    };\n    /**\n     * direction method \\\n     *\n     * @returns { string } direction method .\\\n     * @param {PointModel} pt1 - provide the points value.\n     * @param {PointModel} pt2 - provide the points value.\n     *\n     * @private\n     */\n    Point.direction = function (pt1, pt2) {\n        if (Math.abs(pt2.x - pt1.x) > Math.abs(pt2.y - pt1.y)) {\n            return pt1.x < pt2.x ? 'Right' : 'Left';\n        }\n        else {\n            return pt1.y < pt2.y ? 'Bottom' : 'Top';\n        }\n    };\n    //Move these methods to util\n    //public CompareTo(point: PointModel): number {\n    //    let result: number = this.X.CompareTo(point.X);\n    //    return result != 0 ? result : this.Y.CompareTo(point.Y);\n    //}\n    //public CompareOnYAxis(point: PointModel): number {\n    //    let result: number = this.X.CompareTo(point.X);\n    //    return result != 0 ? result : this.Y.CompareTo(point.Y);\n    //}\n    //public CompareOnXAxis(point: PointModel): number {\n    //    let result: number = this.Y.CompareTo(point.Y);\n    //    return result != 0 ? result : this.X.CompareTo(point.X);\n    //}\n    // public round(): void {\n    //     this.x = Math.round(this.x);\n    //     this.y = Math.round(this.y);\n    // }\n    /**\n     * getClassName method \\\n     *\n     * @returns { string } getClassName method .\\\n     *\n     * @private\n     */\n    Point.prototype.getClassName = function () {\n        return 'Point';\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Point.prototype, \"x\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Point.prototype, \"y\", void 0);\n    return Point;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rect: () => (/* binding */ Rect)\n/* harmony export */ });\n/**\n * Rect defines and processes rectangular regions\n */\nvar Rect = /** @class */ (function () {\n    function Rect(x, y, width, height) {\n        /**\n         * Sets the x-coordinate of the starting point of a rectangular region\n         *\n         * @default 0\n         */\n        this.x = Number.MAX_VALUE;\n        /**\n         * Sets the y-coordinate of the starting point of a rectangular region\n         *\n         * @default 0\n         */\n        this.y = Number.MAX_VALUE;\n        /**\n         * Sets the width of a rectangular region\n         *\n         * @default 0\n         */\n        this.width = 0;\n        /**\n         * Sets the height of a rectangular region\n         *\n         * @default 0\n         */\n        this.height = 0;\n        if (x === undefined || y === undefined) {\n            x = y = Number.MAX_VALUE;\n            width = height = 0;\n        }\n        else {\n            if (width === undefined) {\n                width = 0;\n            }\n            if (height === undefined) {\n                height = 0;\n            }\n        }\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    Object.defineProperty(Rect.prototype, \"left\", {\n        // eslint-disable-next-line jsdoc/require-returns\n        /**   @private  */\n        get: function () {\n            return this.x;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"right\", {\n        /**\n         * right method \\\n         *\n         * @returns { Rect } right method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.x + this.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"top\", {\n        /**\n         * toBounds method \\\n         *\n         * @returns { Rect } toBounds method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.y;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"bottom\", {\n        /**\n         * bottom method \\\n         *\n         * @returns { Rect } bottom method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.y + this.height;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"topLeft\", {\n        /**\n         * topLeft method \\\n         *\n         * @returns { Rect } topLeft method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.left, y: this.top };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"topRight\", {\n        /**\n         * topRight method \\\n         *\n         * @returns { Rect } topRight method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.right, y: this.top };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"bottomLeft\", {\n        /**\n         * bottomLeft method \\\n         *\n         * @returns { Rect } bottomLeft method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.left, y: this.bottom };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"bottomRight\", {\n        /**\n         * bottomRight method \\\n         *\n         * @returns { Rect } bottomRight method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.right, y: this.bottom };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"middleLeft\", {\n        /**\n         * middleLeft method \\\n         *\n         * @returns { Rect } middleLeft method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.left, y: this.y + this.height / 2 };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"middleRight\", {\n        /**\n         * middleRight method \\\n         *\n         * @returns { Rect } middleRight method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.right, y: this.y + this.height / 2 };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"topCenter\", {\n        /**\n         * topCenter method \\\n         *\n         * @returns { Rect } topCenter method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.x + this.width / 2, y: this.top };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"bottomCenter\", {\n        /**\n         * bottomCenter method \\\n         *\n         * @returns { Rect } bottomCenter method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.x + this.width / 2, y: this.bottom };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Rect.prototype, \"center\", {\n        /**\n         * center method \\\n         *\n         * @returns { PointModel } center method .\\\n         *\n         * @private\n         */\n        get: function () {\n            return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * equals method \\\n     *\n     * @returns { boolean } equals method .\\\n     * @param {Rect} rect1 - provide the rect1 value.\n     * @param {Rect} rect2 - provide the rect2 value.\n     *\n     * @private\n     */\n    Rect.prototype.equals = function (rect1, rect2) {\n        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;\n    };\n    /**\n     * uniteRect method \\\n     *\n     * @returns { Rect } uniteRect method .\\\n     * @param {Rect} rect - provide the points value.\n     *\n     * @private\n     */\n    Rect.prototype.uniteRect = function (rect) {\n        var right = Math.max(isNaN(this.right) || this.x === Number.MAX_VALUE ? rect.right : this.right, rect.right);\n        var bottom = Math.max(isNaN(this.bottom) || this.y === Number.MAX_VALUE ? rect.bottom : this.bottom, rect.bottom);\n        this.x = Math.min(this.left, rect.left);\n        this.y = Math.min(this.top, rect.top);\n        this.width = right - this.x;\n        this.height = bottom - this.y;\n        return this;\n    };\n    /**\n     * unitePoint method \\\n     *\n     * @returns { void } unitePoint method .\\\n     * @param {PointModel} point - provide the points value.\n     *\n     * @private\n     */\n    Rect.prototype.unitePoint = function (point) {\n        if (this.x === Number.MAX_VALUE) {\n            this.x = point.x;\n            this.y = point.y;\n            return;\n        }\n        var x = Math.min(this.left, point.x);\n        var y = Math.min(this.top, point.y);\n        var right = Math.max(this.right, point.x);\n        var bottom = Math.max(this.bottom, point.y);\n        this.x = x;\n        this.y = y;\n        this.width = right - this.x;\n        this.height = bottom - this.y;\n    };\n    // public intersection(rect: Rect): Rect {\n    //     if (this.intersects(rect)) {\n    //         let left: number = Math.max(this.left, rect.left);\n    //         let top: number = Math.max(this.top, rect.top);\n    //         let right: number = Math.min(this.right, rect.right);\n    //         let bottom: number = Math.min(this.bottom, rect.bottom);\n    //         return new Rect(left, top, right - left, bottom - top);\n    //     }\n    //     return Rect.empty;\n    // }\n    /**\n     * Inflate method \\\n     *\n     * @returns { Rect } Inflate method .\\\n     * @param {number} padding - provide the points value.\n     *\n     * @private\n     */\n    Rect.prototype.Inflate = function (padding) {\n        this.x -= padding;\n        this.y -= padding;\n        this.width += padding * 2;\n        this.height += padding * 2;\n        return this;\n    };\n    //public Inflate(size: Size): Rect {\n    //    this.x -= size.Width;\n    //    this.y -= size.Height;\n    //    this.width += size.Width * 2;\n    //    this.height += size.Height * 2;\n    //    return this;\n    //}\n    // public inflate(width: number, height: number): void {\n    //     this.x -= width;\n    //     this.y -= height;\n    //     this.width += width * 2;\n    //     this.height += height * 2;\n    // }\n    /**\n     * intersects method \\\n     *\n     * @returns { boolean } intersects method .\\\n     * @param {Rect} rect - provide the points value.\n     *\n     * @private\n     */\n    Rect.prototype.intersects = function (rect) {\n        if (this.right < rect.left || this.left > rect.right || this.top > rect.bottom || this.bottom < rect.top) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * containsRect method \\\n     *\n     * @returns { boolean } containsRect method .\\\n     * @param {Rect} rect - provide the points value.\n     *\n     * @private\n     */\n    Rect.prototype.containsRect = function (rect) {\n        return this.left <= rect.left && this.right >= rect.right && this.top <= rect.top && this.bottom >= rect.bottom;\n    };\n    /**\n     * containsPoint method \\\n     *\n     * @returns { boolean } containsPoint method .\\\n     * @param {PointModel} point - provide the points value.\n     * @param {number} padding - provide the padding value.\n     *\n     * @private\n     */\n    Rect.prototype.containsPoint = function (point, padding) {\n        if (padding === void 0) { padding = 0; }\n        return this.left - padding <= point.x && this.right + padding >= point.x\n            && this.top - padding <= point.y && this.bottom + padding >= point.y;\n    };\n    // public toPoints(): PointModel[] {\n    //     let points: PointModel[] = [];\n    //     points.push(this.topLeft);\n    //     points.push(this.topRight);\n    //     points.push(this.bottomLeft);\n    //     points.push(this.bottomRight);\n    //     return points;\n    // }\n    /**\n     * toBounds method \\\n     *\n     * @returns { Rect } toBounds method .\\\n     * @param {PointModel[]} points - provide the points value.\n     *\n     * @private\n     */\n    Rect.toBounds = function (points) {\n        var rect = new Rect();\n        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n            var pt = points_1[_i];\n            rect.unitePoint(pt);\n        }\n        return rect;\n    };\n    /**   @private  */\n    Rect.empty = new Rect(Number.MAX_VALUE, Number.MIN_VALUE, 0, 0);\n    return Rect;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Size: () => (/* binding */ Size)\n/* harmony export */ });\n/**\n * Size defines and processes the size(width/height) of the objects\n */\nvar Size = /** @class */ (function () {\n    function Size(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * isEmpty method \\\n     *\n     * @returns { boolean } isEmpty method .\\\n     *\n     * @private\n     */\n    Size.prototype.isEmpty = function () {\n        return this.height === 0 && this.width === 0;\n    };\n    // public static get empty(): Size {\n    //     return new Size();\n    // }\n    // public get isEmpty(): boolean {\n    //     return this.equals(Size.empty);\n    // }\n    // public equals(size2: Size): boolean {\n    //     return this.width === size2.width && this.height === size2.height;\n    // }\n    // public union(size: Size): void {\n    //     size.width = Math.max(size.width, this.width);\n    //     size.height = Math.max(size.height, this.height);\n    // }\n    /**\n     * clone method \\\n     *\n     * @returns { Size } clone method .\\\n     *\n     * @private\n     */\n    Size.prototype.clone = function () {\n        return new Size(this.width, this.height);\n    };\n    return Size;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js?");

/***/ })

}]);