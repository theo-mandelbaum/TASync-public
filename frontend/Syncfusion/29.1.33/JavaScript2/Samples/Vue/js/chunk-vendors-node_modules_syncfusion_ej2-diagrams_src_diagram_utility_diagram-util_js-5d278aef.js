"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_utility_diagram-util_js-5d278aef"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignElement: () => (/* binding */ alignElement),\n/* harmony export */   alignLabelOnSegments: () => (/* binding */ alignLabelOnSegments),\n/* harmony export */   arrangeChild: () => (/* binding */ arrangeChild),\n/* harmony export */   canMeasureDecoratorPath: () => (/* binding */ canMeasureDecoratorPath),\n/* harmony export */   canResizeCorner: () => (/* binding */ canResizeCorner),\n/* harmony export */   canShowControlPoints: () => (/* binding */ canShowControlPoints),\n/* harmony export */   canShowCorner: () => (/* binding */ canShowCorner),\n/* harmony export */   changeOldFlipDirectionType: () => (/* binding */ changeOldFlipDirectionType),\n/* harmony export */   checkBrowserInfo: () => (/* binding */ checkBrowserInfo),\n/* harmony export */   checkPort: () => (/* binding */ checkPort),\n/* harmony export */   checkPortRestriction: () => (/* binding */ checkPortRestriction),\n/* harmony export */   cloneBlazorObject: () => (/* binding */ cloneBlazorObject),\n/* harmony export */   cloneSelectedObjects: () => (/* binding */ cloneSelectedObjects),\n/* harmony export */   completeRegion: () => (/* binding */ completeRegion),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   findAnnotation: () => (/* binding */ findAnnotation),\n/* harmony export */   findDistance: () => (/* binding */ findDistance),\n/* harmony export */   findNearestPoint: () => (/* binding */ findNearestPoint),\n/* harmony export */   findNodeByName: () => (/* binding */ findNodeByName),\n/* harmony export */   findObjectIndex: () => (/* binding */ findObjectIndex),\n/* harmony export */   findObjectType: () => (/* binding */ findObjectType),\n/* harmony export */   findParentInSwimlane: () => (/* binding */ findParentInSwimlane),\n/* harmony export */   findPath: () => (/* binding */ findPath),\n/* harmony export */   findPort: () => (/* binding */ findPort),\n/* harmony export */   findPortIndex: () => (/* binding */ findPortIndex),\n/* harmony export */   flipConnector: () => (/* binding */ flipConnector),\n/* harmony export */   getAlignedPosition: () => (/* binding */ getAlignedPosition),\n/* harmony export */   getAlignedPositionForPorts: () => (/* binding */ getAlignedPositionForPorts),\n/* harmony export */   getAnnotationPosition: () => (/* binding */ getAnnotationPosition),\n/* harmony export */   getBezierDirection: () => (/* binding */ getBezierDirection),\n/* harmony export */   getChild: () => (/* binding */ getChild),\n/* harmony export */   getCollectionChangeEventArguements: () => (/* binding */ getCollectionChangeEventArguements),\n/* harmony export */   getConnectorArrowType: () => (/* binding */ getConnectorArrowType),\n/* harmony export */   getConnectorDirection: () => (/* binding */ getConnectorDirection),\n/* harmony export */   getDropEventArguements: () => (/* binding */ getDropEventArguements),\n/* harmony export */   getElement: () => (/* binding */ getElement),\n/* harmony export */   getInOutConnectPorts: () => (/* binding */ getInOutConnectPorts),\n/* harmony export */   getInterval: () => (/* binding */ getInterval),\n/* harmony export */   getLineSegment: () => (/* binding */ getLineSegment),\n/* harmony export */   getObjectFromCollection: () => (/* binding */ getObjectFromCollection),\n/* harmony export */   getObjectType: () => (/* binding */ getObjectType),\n/* harmony export */   getOffsetOfConnector: () => (/* binding */ getOffsetOfConnector),\n/* harmony export */   getOffsetOfPorts: () => (/* binding */ getOffsetOfPorts),\n/* harmony export */   getPathOffset: () => (/* binding */ getPathOffset),\n/* harmony export */   getPoint: () => (/* binding */ getPoint),\n/* harmony export */   getPoints: () => (/* binding */ getPoints),\n/* harmony export */   getPortsPosition: () => (/* binding */ getPortsPosition),\n/* harmony export */   getPreviewSize: () => (/* binding */ getPreviewSize),\n/* harmony export */   getSpaceValue: () => (/* binding */ getSpaceValue),\n/* harmony export */   getSymbolSize: () => (/* binding */ getSymbolSize),\n/* harmony export */   getTooltipOffset: () => (/* binding */ getTooltipOffset),\n/* harmony export */   getUMLActivityShapes: () => (/* binding */ getUMLActivityShapes),\n/* harmony export */   getUMLFinalNode: () => (/* binding */ getUMLFinalNode),\n/* harmony export */   getUserHandlePosition: () => (/* binding */ getUserHandlePosition),\n/* harmony export */   groupHasType: () => (/* binding */ groupHasType),\n/* harmony export */   initFixedUserHandlesSymbol: () => (/* binding */ initFixedUserHandlesSymbol),\n/* harmony export */   insertObject: () => (/* binding */ insertObject),\n/* harmony export */   intersect2: () => (/* binding */ intersect2),\n/* harmony export */   intersect3: () => (/* binding */ intersect3),\n/* harmony export */   isDiagramChild: () => (/* binding */ isDiagramChild),\n/* harmony export */   isPointOverConnector: () => (/* binding */ isPointOverConnector),\n/* harmony export */   removeChildNodes: () => (/* binding */ removeChildNodes),\n/* harmony export */   removeGradient: () => (/* binding */ removeGradient),\n/* harmony export */   removeItem: () => (/* binding */ removeItem),\n/* harmony export */   scaleElement: () => (/* binding */ scaleElement),\n/* harmony export */   selectionHasConnector: () => (/* binding */ selectionHasConnector),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   setConnectorDefaults: () => (/* binding */ setConnectorDefaults),\n/* harmony export */   setPortsEdges: () => (/* binding */ setPortsEdges),\n/* harmony export */   setSwimLaneDefaults: () => (/* binding */ setSwimLaneDefaults),\n/* harmony export */   setUMLActivityDefaults: () => (/* binding */ setUMLActivityDefaults),\n/* harmony export */   sort: () => (/* binding */ sort),\n/* harmony export */   updateConnector: () => (/* binding */ updateConnector),\n/* harmony export */   updateContent: () => (/* binding */ updateContent),\n/* harmony export */   updateDefaultValues: () => (/* binding */ updateDefaultValues),\n/* harmony export */   updateHyperlink: () => (/* binding */ updateHyperlink),\n/* harmony export */   updateLayoutValue: () => (/* binding */ updateLayoutValue),\n/* harmony export */   updatePathElement: () => (/* binding */ updatePathElement),\n/* harmony export */   updatePortEdges: () => (/* binding */ updatePortEdges),\n/* harmony export */   updateShape: () => (/* binding */ updateShape),\n/* harmony export */   updateShapeContent: () => (/* binding */ updateShapeContent),\n/* harmony export */   updateStyle: () => (/* binding */ updateStyle),\n/* harmony export */   updateUmlActivityNode: () => (/* binding */ updateUmlActivityNode),\n/* harmony export */   upgrade: () => (/* binding */ upgrade)\n/* harmony export */ });\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _primitives_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../primitives/matrix */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js\");\n/* harmony import */ var _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../core/elements/diagram-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/diagram-element.js\");\n/* harmony import */ var _core_containers_container__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../core/containers/container */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/container.js\");\n/* harmony import */ var _core_appearance__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../core/appearance */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/appearance.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _core_elements_native_element__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./../core/elements/native-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/native-element.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _core_elements_image_element__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/elements/image-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/image-element.js\");\n/* harmony import */ var _objects_annotation__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./../objects/annotation */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/annotation.js\");\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./../objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _objects_dictionary_basic_shapes__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./../objects/dictionary/basic-shapes */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/dictionary/basic-shapes.js\");\n/* harmony import */ var _objects_dictionary_flow_shapes__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./../objects/dictionary/flow-shapes */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/dictionary/flow-shapes.js\");\n/* harmony import */ var _diagram__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./../diagram */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js\");\n/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js\");\n/* harmony import */ var _dom_util__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _base_util__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _utility_path_util__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./../utility/path-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/path-util.js\");\n/* harmony import */ var _core_elements_html_element__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../core/elements/html-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/html-element.js\");\n/* harmony import */ var _ruler_ruler__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../ruler/ruler */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/ruler/ruler.js\");\n/* harmony import */ var _constraints_util__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n/* harmony import */ var _interaction_selector__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../interaction/selector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/selector.js\");\n/* harmony import */ var _objects_dictionary_umlactivity_shapes__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../objects/dictionary/umlactivity-shapes */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/dictionary/umlactivity-shapes.js\");\n/* harmony import */ var _core_containers_canvas__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../core/containers/canvas */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/canvas.js\");\n/* harmony import */ var _objects_port__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../objects/port */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/port.js\");\n/* harmony import */ var _diagram_keyboard_commands__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../diagram/keyboard-commands */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/keyboard-commands.js\");\n/* harmony import */ var _swim_lane_util__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./swim-lane-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../objects/fixed-user-handle */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/fixed-user-handle.js\");\n/* harmony import */ var _overview_overview__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../../overview/overview */ \"./node_modules/@syncfusion/ej2-diagrams/src/overview/overview.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * completeRegion method\\\n *\n * @returns {  void }    completeRegion method .\\\n * @param {Rect} region - provide the region value.\n * @param {(NodeModel | ConnectorModel)[]} selectedObjects - provide the selectedObjects value.\n * @private\n */\nfunction completeRegion(region, selectedObjects) {\n    var collection = [];\n    for (var i = 0; i < selectedObjects.length; i++) {\n        var obj = selectedObjects[parseInt(i.toString(), 10)];\n        if (region.containsRect(obj.wrapper.bounds)) {\n            collection.push(obj);\n        }\n    }\n    return collection;\n}\n/**\n * findNodeByName method \\\n *\n * @returns {  boolean } findNodeByName method .\\\n * @param {(NodeModel | ConnectorModel)[]} nodes - provide the nodes  value.\n * @param {string} name - provide the orientation  value.\n * @private\n */\nfunction findNodeByName(nodes, name) {\n    for (var i = 0; i < nodes.length; i++) {\n        if (nodes[parseInt(i.toString(), 10)].id === name) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * findNodeByName method \\\n *\n * @returns {  string } findNodeByName method .\\\n * @param {(NodeModel | ConnectorModel)[]} drawingObject - provide the drawingObject  value.\n * @private\n */\nfunction findObjectType(drawingObject) {\n    var type;\n    if (drawingObject) {\n        if (drawingObject.type) {\n            type = 'Connector';\n        }\n        else if (drawingObject.shape && !drawingObject.type) {\n            type = 'Node';\n        }\n    }\n    return type;\n}\n/**\n * setSwimLaneDefaults method \\\n *\n * @returns {  void } setSwimLaneDefaults method .\\\n * @param {NodeModel | ConnectorModel} child - provide the child  value.\n * @param {NodeModel | ConnectorModel} node - provide the node  value.\n * @private\n */\nfunction setSwimLaneDefaults(child, node) {\n    if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node) {\n        if (!child.shape.header) {\n            node.shape.hasHeader = false;\n        }\n    }\n}\n/**\n * getSpaceValue method \\\n *\n * @returns {  number } getSpaceValue method .\\\n * @param {number[]} intervals - provide the intervals  value.\n * @param {boolean} isLine - provide the isLine  value.\n * @param {number} i - provide the i  value.\n * @param {number} space - provide the space  value.\n * @private\n */\nfunction getSpaceValue(intervals, isLine, i, space) {\n    space = !isLine ? ((intervals[i - 1] !== undefined) ? intervals[i - 1] + space : 0) : space;\n    return space;\n}\n/**\n * getInterval method \\\n *\n * @returns {  number[] } getInterval method .\\\n * @param {number[]} intervals - provide the intervals  value.\n * @param {boolean} isLine - provide the isLine  value.\n * @private\n */\nfunction getInterval(intervals, isLine) {\n    var newInterval = [];\n    if (!isLine) {\n        for (var k = 0; k < intervals.length; k++) {\n            newInterval.push(intervals[parseInt(k.toString(), 10)]);\n        }\n        newInterval.push(intervals[newInterval.length - 2]);\n        newInterval.push(intervals[newInterval.length - 2]);\n    }\n    else {\n        newInterval = intervals;\n    }\n    return newInterval;\n}\n/**\n * setPortsEdges method \\\n *\n * @returns {  Node } setPortsEdges method .\\\n * @param {Node} node - provide the node  value.\n * @private\n */\nfunction setPortsEdges(node) {\n    for (var k = 0; k < node.ports.length; k++) {\n        node.ports[parseInt(k.toString(), 10)].inEdges = [];\n        node.ports[parseInt(k.toString(), 10)].outEdges = [];\n    }\n    return node;\n}\n/**\n * setUMLActivityDefaults method \\\n *\n * @returns {  void } setUMLActivityDefaults method .\\\n * @param {NodeModel | ConnectorModel} child - provide the child  value.\n * @param {NodeModel | ConnectorModel} node - provide the node  value.\n * @private\n */\nfunction setUMLActivityDefaults(child, node) {\n    if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node) {\n        var shape = child.shape.shape;\n        switch (shape) {\n            case 'JoinNode':\n                if (!child.width) {\n                    node.width = 20;\n                }\n                if (!child.height) {\n                    node.height = 90;\n                }\n                if (!child.style || !child.style.fill) {\n                    node.style.fill = 'black';\n                }\n                break;\n            case 'ForkNode':\n                if (!child.width) {\n                    node.width = 90;\n                }\n                if (!child.height) {\n                    node.height = 20;\n                }\n                if (!child.style || !child.style.fill) {\n                    node.style.fill = 'black';\n                }\n                break;\n            case 'InitialNode':\n                if (!child.style || !child.style.fill) {\n                    node.style.fill = 'black';\n                }\n                break;\n            case 'FinalNode':\n                if (!child.style || !child.style.fill) {\n                    node.style.fill = 'black';\n                }\n                break;\n        }\n    }\n    else {\n        var flow = child.shape.flow;\n        switch (flow) {\n            case 'Object':\n                if (!child.style || !child.style.strokeDashArray) {\n                    node.style.strokeDashArray = '8 4';\n                }\n                if (!child.style || !child.style.strokeWidth) {\n                    node.style.strokeWidth = 2;\n                }\n                if (!child.targetDecorator || !child.targetDecorator.shape) {\n                    node.targetDecorator.shape = 'OpenArrow';\n                }\n                break;\n            case 'Control':\n                if (!child.style || !child.style.strokeWidth) {\n                    node.style.strokeWidth = 2;\n                }\n                if (!child.targetDecorator || !child.targetDecorator.shape) {\n                    node.targetDecorator.shape = 'OpenArrow';\n                }\n                if (!child.sourceDecorator || !child.sourceDecorator.shape) {\n                    node.sourceDecorator.shape = 'None';\n                }\n                break;\n        }\n    }\n}\n/* eslint-disable */\n/**\n * setConnectorDefaults method \\\n *\n * @returns {  void } setConnectorDefaults method .\\\n * @param {ConnectorModel} child - provide the child  value.\n * @param {ConnectorModel} node - provide the node  value.\n * @private\n */\nfunction setConnectorDefaults(child, node) {\n    switch ((child.shape).type) {\n        case 'Bpmn':\n            var bpmnFlow = child.shape.flow;\n            switch (bpmnFlow) {\n                case 'Sequence':\n                    if ((((child.shape.sequence) === 'Normal' && child.type !== 'Bezier')) ||\n                        ((child.shape.sequence) === 'Default') || ((child.shape.sequence) === 'Conditional')) {\n                        if (node.targetDecorator && node.targetDecorator.style) {\n                            node.targetDecorator.style.fill = (child.targetDecorator && child.targetDecorator.style\n                                && child.targetDecorator.style.fill) || 'black';\n                        }\n                        if ((child.shape.sequence) === 'Conditional' && node.sourceDecorator) {\n                            if (node.sourceDecorator.style) {\n                                node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&\n                                    child.sourceDecorator.style.fill) || 'white';\n                            }\n                            node.sourceDecorator.width = (child.sourceDecorator && child.sourceDecorator.width) || 20;\n                            node.sourceDecorator.height = (child.sourceDecorator && child.sourceDecorator.width) || 10;\n                        }\n                    }\n                    break;\n                case 'Association':\n                    if (((child.shape.association) === 'Default') ||\n                        ((child.shape.association) === 'Directional') ||\n                        ((child.shape.association) === 'BiDirectional')) {\n                        if (node.targetDecorator && node.targetDecorator.style) {\n                            node.targetDecorator.style.fill = (child.targetDecorator && child.targetDecorator.style &&\n                                child.targetDecorator.style.fill) || 'black';\n                        }\n                        if ((child.shape.association) === 'BiDirectional') {\n                            if (node.sourceDecorator && node.sourceDecorator.style) {\n                                node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&\n                                    child.sourceDecorator.style.fill) || 'white';\n                                node.sourceDecorator.width = (child.sourceDecorator && child.sourceDecorator.width) || 5;\n                                node.sourceDecorator.height = (child.sourceDecorator && child.sourceDecorator.height) || 10;\n                            }\n                        }\n                    }\n                    break;\n                case 'Message':\n                    if (node.style && !node.style.strokeDashArray) {\n                        node.style.strokeDashArray = (child.style && child.style.strokeDashArray) || '4 4';\n                    }\n                    break;\n            }\n            break;\n        case 'UmlActivity':\n            var flow = child.shape.flow;\n            switch (flow) {\n                case 'Exception':\n                    if (((child.shape.association) === 'Directional') ||\n                        ((child.shape.association) === 'BiDirectional')) {\n                        node.style.strokeDashArray = (child.style && child.style.strokeDashArray) || '2 2';\n                    }\n                    break;\n            }\n            break;\n        case 'UmlClassifier':\n            var hasRelation = false;\n            if (child.shape.relationship === 'Association') {\n                hasRelation = true;\n            }\n            else if (child.shape.relationship === 'Inheritance') {\n                if (node.targetDecorator && node.targetDecorator.style) {\n                    node.targetDecorator.style.fill = (child.targetDecorator && child.targetDecorator.style &&\n                        child.targetDecorator.style.fill) || 'white';\n                }\n                if (node.style) {\n                    hasRelation = true;\n                    node.style.strokeDashArray = (child.style && child.style.strokeDashArray) || '4 4';\n                }\n            }\n            else if (child.shape.relationship === 'Composition') {\n                if (node.sourceDecorator && node.sourceDecorator.style) {\n                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&\n                        child.sourceDecorator.style.fill) || 'black';\n                }\n                hasRelation = true;\n            }\n            else if (child.shape.relationship === 'Aggregation' ||\n                child.shape.relationship === undefined) {\n                if (node.sourceDecorator && node.sourceDecorator.style) {\n                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&\n                        child.sourceDecorator.style.fill) || 'white';\n                }\n                hasRelation = true;\n            }\n            else if (child.shape.relationship === 'Dependency') {\n                if (node.sourceDecorator && node.sourceDecorator.style) {\n                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&\n                        child.sourceDecorator.style.fill) || 'white';\n                }\n                hasRelation = true;\n                node.style.strokeDashArray = '4 4';\n            }\n            else if (child.shape.relationship === 'Realization') {\n                if (node.sourceDecorator && node.sourceDecorator.style) {\n                    node.sourceDecorator.style.fill = (child.sourceDecorator && child.sourceDecorator.style &&\n                        child.sourceDecorator.style.fill) || 'white';\n                }\n                hasRelation = true;\n            }\n            if (hasRelation) {\n                node.style.strokeWidth = (child.style && child.style.strokeWidth) || 2;\n            }\n            break;\n    }\n}\n/* eslint-enable */\n/**\n * findNearestPoint method \\\n *\n * @returns {  PointModel } findNearestPoint method .\\\n * @param {PointModel} reference - provide the reference  value.\n * @param {PointModel} start - provide the start  value.\n * @param {PointModel} end - provide the end  value.\n * @private\n */\nfunction findNearestPoint(reference, start, end) {\n    var shortestPoint;\n    var shortest = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findLength(start, reference);\n    var shortest1 = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findLength(end, reference);\n    if (shortest > shortest1) {\n        shortestPoint = end;\n    }\n    else {\n        shortestPoint = start;\n    }\n    var angleBWStAndEnd = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findAngle(start, end);\n    var angleBWStAndRef = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findAngle(shortestPoint, reference);\n    var r = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findLength(shortestPoint, reference);\n    var vaAngle = angleBWStAndRef + ((angleBWStAndEnd - angleBWStAndRef) * 2);\n    return {\n        x: (shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180)),\n        y: (shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180))\n    };\n}\n/**\n * pointsForBezier method \\\n *\n * @returns {   PointModel[] } pointsForBezier method .\\\n * @param {ConnectorModel} connector - provide the connector  value.\n * @private\n */\nfunction pointsForBezier(connector) {\n    var points = [];\n    if (connector.type === 'Bezier') {\n        var k = 0;\n        for (var i = 0; i < connector.segments.length; i++) {\n            var tolerance = 1.5;\n            var segment = connector.segments[parseInt(i.toString(), 10)];\n            //const pt: PointModel = { x: 0, y: 0 };\n            var point1 = !_primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.isEmptyPoint(segment.point1) ? segment.point1 : segment.bezierPoint1;\n            var point2 = !_primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.isEmptyPoint(segment.point2) ? segment.point2 : segment.bezierPoint2;\n            var max = Number((connector.distance(point1, segment.points[0]) +\n                connector.distance(point2, point1) +\n                connector.distance(segment.points[1], point2)) / tolerance);\n            for (var j = 0; j < max - 1; j = j + 10) {\n                points[parseInt(k.toString(), 10)] =\n                    (0,_objects_connector__WEBPACK_IMPORTED_MODULE_14__.bezierPoints)(connector, segment.points[0], !_primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.isEmptyPoint(segment.point1) ? segment.point1 : segment.bezierPoint1, !_primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.isEmptyPoint(segment.point2) ? segment.point2 : segment.bezierPoint2, segment.points[1], j, max);\n                k++;\n            }\n        }\n    }\n    return points;\n}\n/**\n * isDiagramChild method \\\n *\n * @returns {  boolean } isDiagramChild method .\\\n * @param {HTMLElement} htmlLayer - provide the htmlLayer  value.\n * @private\n */\nfunction isDiagramChild(htmlLayer) {\n    var element = htmlLayer.parentElement;\n    do {\n        if ((0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.hasClass)(element, 'e-diagram')) {\n            return true;\n        }\n        element = element.parentElement;\n    } while (element);\n    return false;\n}\n/**\n * groupHasType method \\\n *\n * @returns {  boolean } groupHasType method .\\\n * @param {NodeModel} node - provide the node  value.\n * @param {Shapes} type - provide the type  value.\n * @param {{}} nameTable - provide the nameTable  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction groupHasType(node, type, nameTable) {\n    var contains = false;\n    if (node && node.children && node.children.length > 0) {\n        var child = void 0;\n        var i = 0;\n        for (; i < node.children.length; i++) {\n            child = nameTable[node.children[parseInt(i.toString(), 10)]];\n            if (child.shape.type === type) {\n                return true;\n            }\n            return groupHasType(child, type, nameTable);\n        }\n    }\n    return contains;\n}\n/**\n * groupHasType method \\\n *\n * @returns {  void } groupHasType method .\\\n * @param {NodeModel | ConnectorModel} actualNode - provide the actualNode  value.\n * @param { NodeModel | ConnectorModel} plainValue - provide the plainValue  value.\n * @param {object} defaultValue - provide the defaultValue  value.\n * @param {NodeModel | ConnectorModel} property - provide the property  value.\n * @param {string} oldKey - provide the oldKey  value.\n * @private\n */\nfunction updateDefaultValues(actualNode, plainValue, \n// eslint-disable-next-line @typescript-eslint/ban-types\ndefaultValue, property, oldKey) {\n    if (defaultValue && ((actualNode instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector) || actualNode\n        && ((actualNode.shape && actualNode.shape.type !== 'SwimLane') || actualNode.shape === undefined))) {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        var keyObj = void 0;\n        for (var _i = 0, _a = Object.keys(defaultValue); _i < _a.length; _i++) {\n            var key = _a[_i];\n            keyObj = defaultValue[\"\" + key];\n            if (key === 'shape' && keyObj.type) {\n                actualNode.shape = { type: keyObj.type };\n            }\n            if (keyObj) {\n                if (Array.isArray(keyObj) && keyObj.length && keyObj.length > 0 && (oldKey !== 'annotations' && oldKey !== 'ports')) {\n                    if (actualNode[\"\" + key].length > 0) {\n                        for (var i = 0; i <= actualNode[\"\" + key].length; i++) {\n                            updateDefaultValues(actualNode[\"\" + key], plainValue ? plainValue[\"\" + key] : undefined, defaultValue[\"\" + key], (key === 'annotations' || key === 'ports') ? actualNode : undefined, key);\n                        }\n                    }\n                    else {\n                        updateDefaultValues(actualNode[\"\" + key], plainValue ? plainValue[\"\" + key] : undefined, defaultValue[\"\" + key], (key === 'annotations' || key === 'ports') ? actualNode : undefined, key);\n                    }\n                }\n                else if (keyObj instanceof Object && plainValue && (oldKey !== 'annotations' && oldKey !== 'ports')) {\n                    updateDefaultValues(actualNode[\"\" + key], plainValue[\"\" + key], defaultValue[\"\" + key]);\n                }\n                else if ((oldKey !== 'annotations' && oldKey !== 'ports')\n                    && (plainValue && !plainValue[\"\" + key]) || (!plainValue && actualNode\n                    && (actualNode[\"\" + key] || actualNode[\"\" + key] !== undefined))) {\n                    actualNode[\"\" + key] = defaultValue[\"\" + key];\n                }\n                else {\n                    var createObject = void 0;\n                    if (oldKey === 'annotations' || oldKey === 'ports') {\n                        if (oldKey === 'annotations') {\n                            if (actualNode[\"\" + key]) {\n                                updateDefaultValues(actualNode[\"\" + key], plainValue[\"\" + key], defaultValue[\"\" + key]);\n                            }\n                            if (!actualNode[\"\" + key]) {\n                                if (getObjectType(property) === _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector) {\n                                    createObject = new _objects_annotation__WEBPACK_IMPORTED_MODULE_12__.PathAnnotation(property, 'annotations', defaultValue[\"\" + key]);\n                                    property.annotations.push(createObject);\n                                }\n                                else {\n                                    createObject = new _objects_annotation__WEBPACK_IMPORTED_MODULE_12__.ShapeAnnotation(property, 'annotations', defaultValue[\"\" + key]);\n                                    property.annotations.push(createObject);\n                                }\n                            }\n                        }\n                        else {\n                            if (actualNode[\"\" + key]) {\n                                updateDefaultValues(actualNode[\"\" + key], plainValue[\"\" + key], defaultValue[\"\" + key]);\n                            }\n                            else {\n                                createObject = new _objects_port__WEBPACK_IMPORTED_MODULE_28__.PointPort(property, 'ports', defaultValue[\"\" + key]);\n                                property.ports.push(createObject);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n/* tslint:disable:no-string-literal */\n/**\n * updateLayoutValue method \\\n *\n * @returns {  void } updateLayoutValue method .\\\n * @param {TreeInfo} actualNode - provide the actualNode  value.\n * @param { object} defaultValue - provide the defaultValue  value.\n * @param {INode[]} nodes - provide the nodes  value.\n * @param {INode} node - provide the node  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction updateLayoutValue(actualNode, defaultValue, nodes, node) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    var keyObj;\n    var assistantKey = 'Role';\n    if (defaultValue) {\n        for (var _i = 0, _a = Object.keys(defaultValue); _i < _a.length; _i++) {\n            var key = _a[_i];\n            keyObj = defaultValue[\"\" + key];\n            if (key === 'getAssistantDetails') {\n                //Removed isBlazor code\n                if (node.data[\"\" + assistantKey] === defaultValue[\"\" + key]['root']) {\n                    var assitants = defaultValue[\"\" + key]['assistants'];\n                    for (var i = 0; i < assitants.length; i++) {\n                        for (var j = 0; j < nodes.length; j++) {\n                            if (nodes[parseInt(j.toString(), 10)].data[\"\" + assistantKey] === assitants[parseInt(i.toString(), 10)]) {\n                                actualNode.assistants.push(nodes[parseInt(j.toString(), 10)].id);\n                                actualNode.children.splice(0, 1);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (keyObj) {\n                actualNode[\"\" + key] = defaultValue[\"\" + key];\n            }\n        }\n    }\n    if (!actualNode.hasSubTree && defaultValue.canEnableSubTree) {\n        actualNode.orientation = node.layoutInfo.orientation;\n        actualNode.type = node.layoutInfo.type;\n        if (node.layoutInfo.offset !== actualNode.offset && (node.layoutInfo.offset) !== undefined) {\n            actualNode.offset = node.layoutInfo.offset;\n        }\n    }\n    node.layoutInfo.hasSubTree = actualNode.hasSubTree;\n}\n/* tslint:enable:no-string-literal */\n/**\n * isPointOverConnector method \\\n *\n * @returns {  boolean } isPointOverConnector method .\\\n * @param {ConnectorModel} connector - provide the connector  value.\n * @param { PointModel} reference - provide the reference  value.\n * @private\n */\nfunction isPointOverConnector(connector, reference) {\n    //let intermediatePoints: PointModel[];\n    var intermediatePoints = connector.type === 'Bezier' ? pointsForBezier(connector) :\n        connector.intermediatePoints;\n    for (var i = 0; i < intermediatePoints.length - 1; i++) {\n        var start = intermediatePoints[parseInt(i.toString(), 10)];\n        var end = intermediatePoints[i + 1];\n        var rect = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds([start, end]);\n        rect.Inflate(connector.hitPadding);\n        if (rect.containsPoint(reference)) {\n            var intersectinPt = findNearestPoint(reference, start, end);\n            var segment1 = { x1: start.x, x2: end.x, y1: start.y, y2: end.y };\n            var segment2 = { x1: reference.x, x2: intersectinPt.x, y1: reference.y, y2: intersectinPt.y };\n            var intersectDetails = intersect3(segment1, segment2);\n            if (intersectDetails.enabled) {\n                var distance = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findLength(reference, intersectDetails.intersectPt);\n                if (Math.abs(distance) < connector.hitPadding) {\n                    return true;\n                }\n            }\n            else {\n                var rect_1 = _primitives_rect__WEBPACK_IMPORTED_MODULE_1__.Rect.toBounds([reference, reference]);\n                rect_1.Inflate(3);\n                if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {\n                    return true;\n                }\n            }\n            if (_primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.equals(reference, intersectinPt)) {\n                return true;\n            }\n        }\n    }\n    if (connector.annotations.length > 0 || connector.ports.length > 0) {\n        var container = connector.wrapper.children;\n        for (var i = 3; i < container.length; i++) {\n            var textElement = container[parseInt(i.toString(), 10)];\n            if (textElement.bounds.containsPoint(reference)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * intersect3 method \\\n *\n * @returns {  Intersection } intersect3 method .\\\n * @param {ConnectorModel} lineUtil1 - provide the lineUtil1  value.\n * @param { PointModel} lineUtil2 - provide the lineUtil2  value.\n * @private\n */\nfunction intersect3(lineUtil1, lineUtil2) {\n    var point = { x: 0, y: 0 };\n    var l1 = lineUtil1;\n    var l2 = lineUtil2;\n    var d = (l2.y2 - l2.y1) * (l1.x2 - l1.x1) - (l2.x2 - l2.x1) * (l1.y2 - l1.y1);\n    var na = (l2.x2 - l2.x1) * (l1.y1 - l2.y1) - (l2.y2 - l2.y1) * (l1.x1 - l2.x1);\n    var nb = (l1.x2 - l1.x1) * (l1.y1 - l2.y1) - (l1.y2 - l1.y1) * (l1.x1 - l2.x1);\n    /*( EJ2-42102 - Connector segments not update properly ) by sivakumar sekar - condition added to avoid bridging for\n     overlapping segments in the connectors and to validate whether the connector is intersecting over the other */\n    if (d === 0 || ((lineUtil1.x1 === lineUtil2.x1 || lineUtil1.y1 === lineUtil2.y1) &&\n        (lineUtil1.x2 === lineUtil2.x2 || lineUtil1.y2 === lineUtil2.y2) && ((na === 0 || nb === 0) && d > 0))) {\n        return { enabled: false, intersectPt: point };\n    }\n    var ua = na / d;\n    var ub = nb / d;\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n        point.x = l1.x1 + (ua * (l1.x2 - l1.x1));\n        point.y = l1.y1 + (ua * (l1.y2 - l1.y1));\n        return { enabled: true, intersectPt: point };\n    }\n    return { enabled: false, intersectPt: point };\n}\n/**\n * intersect2 method \\\n *\n * @returns {  PointModel } intersect2 method .\\\n * @param {PointModel} start1 - provide the start1  value.\n * @param { PointModel} end1 - provide the end1  value.\n * @param { PointModel} start2 - provide the start2  value.\n * @param { PointModel} end2 - provide the end2  value.\n * @private\n */\nfunction intersect2(start1, end1, start2, end2) {\n    var point = { x: 0, y: 0 };\n    var lineUtil1 = getLineSegment(start1.x, start1.y, end1.x, end1.y);\n    var lineUtil2 = getLineSegment(start2.x, start2.y, end2.x, end2.y);\n    var line3 = intersect3(lineUtil1, lineUtil2);\n    if (line3.enabled) {\n        return line3.intersectPt;\n    }\n    else {\n        return point;\n    }\n}\n/**\n * getLineSegment method \\\n *\n * @returns {  Segment } getLineSegment method .\\\n * @param {number} x1 - provide the x1  value.\n * @param { number} y1 - provide the y1  value.\n * @param { number} x2 - provide the x2  value.\n * @param { number} y2 - provide the y2  value.\n * @private\n */\nfunction getLineSegment(x1, y1, x2, y2) {\n    return { 'x1': Number(x1) || 0, 'y1': Number(y1) || 0, 'x2': Number(x2) || 0, 'y2': Number(y2) || 0 };\n}\n/**\n * getPoints method \\\n *\n * @returns {  PointModel[] } getPoints method .\\\n * @param {number} element - provide the element  value.\n * @param { number} corners - provide the corners  value.\n * @param { number} padding - provide the padding  value.\n * @private\n */\nfunction getPoints(element, corners, padding) {\n    var line = [];\n    padding = padding || 0;\n    var left = { x: corners.topLeft.x - padding, y: corners.topLeft.y };\n    var right = { x: corners.topRight.x + padding, y: corners.topRight.y };\n    var top = { x: corners.bottomRight.x, y: corners.bottomRight.y - padding };\n    var bottom = { x: corners.bottomLeft.x, y: corners.bottomLeft.y + padding };\n    line.push(left);\n    line.push(right);\n    line.push(top);\n    line.push(bottom);\n    return line;\n}\n/**\n * getTooltipOffset method \\\n *\n * @returns {  PointModel[] } getTooltipOffset method .\\\n * @param {number} diagram - provide the diagram  value.\n * @param { number} mousePosition - provide the mousePosition  value.\n * @param { NodeModel | ConnectorModel | PointPortModel} node - provide the node  value.\n * @param { string} type - provide the type  value.\n * @private\n */\nfunction getTooltipOffset(diagram, mousePosition, node, type) {\n    //let offset: PointModel;\n    var inheritTooltip = (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node) ? (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.NodeConstraints.InheritTooltip)\n        : (node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector) ? (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.ConnectorConstraints.InheritTooltip)\n            : (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.PortConstraints.InheritTooltip);\n    var objectTooltip = (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node) ? (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.NodeConstraints.Tooltip)\n        : (node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector) ? (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.ConnectorConstraints.Tooltip)\n            : (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.PortConstraints.ToolTip);\n    var isMouseBased = ((!inheritTooltip && objectTooltip ? node.tooltip.relativeMode\n        : diagram.tooltip.relativeMode) === 'Mouse') ? true : false;\n    if (type === 'Mouse') {\n        isMouseBased = true;\n    }\n    else if (type === 'Object') {\n        isMouseBased = false;\n    }\n    var offset = tooltipOffset(node, mousePosition, diagram, isMouseBased);\n    var rulerSize = (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_23__.getRulerSize)(diagram);\n    return { x: offset.x + rulerSize.width, y: offset.y + rulerSize.height };\n}\n/**\n * tooltipOffset method \\\n *\n * @returns { PointModel } tooltipOffset method .\\\n * @param {NodeModel | ConnectorModel | PointPortModel} node - provide the node  value.\n * @param { PointModel} mousePosition - provide the mousePosition  value.\n * @param { Diagram } diagram - provide the diagram  value.\n * @param { boolean} isMouseBased - provide the isMouseBased  value.\n * @private\n */\nfunction tooltipOffset(node, mousePosition, diagram, isMouseBased) {\n    var point = {};\n    //let scale: number = diagram.scroller.transform.scale;\n    var element = document.getElementById(diagram.element.id);\n    var bounds;\n    //EJ2-62120-Tooltip support for ports\n    if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node || node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector) {\n        bounds = node.wrapper.bounds;\n    }\n    else {\n        var objects = diagram.findObjectsUnderMouse(mousePosition);\n        var obj = diagram.findObjectUnderMouse(objects, 'Select', false);\n        var portElement = diagram.findElementUnderMouse(obj, mousePosition, diagram);\n        bounds = portElement.bounds;\n    }\n    var rect = element.getBoundingClientRect();\n    /* eslint-enable */\n    //let horizontalOffset: number = diagram.scroller.horizontalOffset;\n    //let verticalOffset: number = diagram.scroller.verticalOffset;\n    switch (diagram.tooltipObject.position) {\n        case 'BottomCenter':\n            point = offsetPoint(mousePosition, bounds.bottomCenter, diagram, isMouseBased, (rect.width / 2), rect.height);\n            break;\n        case 'BottomLeft':\n        case 'LeftBottom':\n            point = offsetPoint(mousePosition, bounds.bottomLeft, diagram, isMouseBased, 0, rect.height);\n            break;\n        case 'BottomRight':\n        case 'RightBottom':\n            point = offsetPoint(mousePosition, bounds.bottomRight, diagram, isMouseBased, rect.width, rect.height);\n            break;\n        case 'LeftCenter':\n            point = offsetPoint(mousePosition, bounds.middleLeft, diagram, isMouseBased, 0, (rect.height / 2));\n            break;\n        case 'LeftTop':\n        case 'TopLeft':\n            point = offsetPoint(mousePosition, bounds.topLeft, diagram, isMouseBased, 0, 0);\n            break;\n        case 'RightCenter':\n            point = offsetPoint(mousePosition, bounds.middleRight, diagram, isMouseBased, rect.width, (rect.height / 2));\n            break;\n        case 'RightTop':\n        case 'TopRight':\n            point = offsetPoint(mousePosition, bounds.topRight, diagram, isMouseBased, rect.width, 0);\n            break;\n        case 'TopCenter':\n            point = offsetPoint(mousePosition, bounds.topCenter, diagram, isMouseBased, (rect.width / 2), 0);\n            break;\n    }\n    return point;\n}\n/**\n * offsetPoint method \\\n *\n * @returns { PointModel } offsetPoint method .\\\n * @param { PointModel} mousePosition - provide the mousePosition  value.\n * @param { PointModel } bound - provide the diagram  value.\n * @param { Diagram} diagram - provide the isMouseBased  value.\n * @param { boolean} isMouseBased - provide the isMouseBased  value.\n * @param { number} x - provide the isMouseBased  value.\n * @param { number} y - provide the isMouseBased  value.\n * @private\n */\nfunction offsetPoint(mousePosition, bound, diagram, isMouseBased, x, y) {\n    var point = {};\n    var scale = diagram.scroller.transform.scale;\n    var horizontalOffset = diagram.scroller.horizontalOffset;\n    var verticalOffset = diagram.scroller.verticalOffset;\n    horizontalOffset = diagram.modifyClientOffset(horizontalOffset, true);\n    verticalOffset = diagram.modifyClientOffset(verticalOffset, true);\n    point.x = (isMouseBased ? mousePosition.x : bound.x) * scale + horizontalOffset - x;\n    point.y = (isMouseBased ? mousePosition.y : bound.y) * scale + verticalOffset - y;\n    return point;\n}\n/**\n * Gets the fixed user handles symbol \\\n *\n * @returns { DiagramElement } Gets the fixed user handles symbol .\\\n * @param {ConnectorFixedUserHandleModel | NodeFixedUserHandleModel} options - provide the options  value.\n * @param { Canvas} fixedUserHandleContainer - provide the fixedUserHandleContainer  value.\n * @private\n */\nfunction initFixedUserHandlesSymbol(options, fixedUserHandleContainer) {\n    //let fixedUserHandleContent: PathElement | DiagramNativeElement;\n    var fixedUserHandleContent = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n    fixedUserHandleContent.data = options.pathData;\n    fixedUserHandleContent.height =\n        options.height > 10 ? options.height - (options.padding.bottom + options.padding.top) : options.height;\n    fixedUserHandleContent.width =\n        options.width > 10 ? options.width - (options.padding.left + options.padding.right) : options.width;\n    //Bug 912616: Not able to hide the fixedUserHandle in diagram\n    fixedUserHandleContent.visible = options.visibility;\n    fixedUserHandleContent.id = fixedUserHandleContainer.id + '_shape';\n    fixedUserHandleContent.inversedAlignment = false;\n    fixedUserHandleContent.horizontalAlignment = 'Center';\n    fixedUserHandleContent.verticalAlignment = 'Center';\n    fixedUserHandleContent.style = {\n        fill: options.iconStrokeColor, strokeColor: options.iconStrokeColor,\n        strokeWidth: options.iconStrokeWidth\n    };\n    fixedUserHandleContent.setOffsetWithRespectToBounds(0.5, 0.5, 'Fraction');\n    fixedUserHandleContent.relativeMode = 'Object';\n    fixedUserHandleContent.description = fixedUserHandleContainer.description || '';\n    return fixedUserHandleContent;\n}\n/**\n * sort method \\\n *\n * @returns { (NodeModel | ConnectorModel)[] } sort method .\\\n * @param {(NodeModel | ConnectorModel)[]} objects - provide the options  value.\n * @param { DistributeOptions} option - provide the fixedUserHandleContainer  value.\n * @private\n */\nfunction sort(objects, option) {\n    var i = 0;\n    var j = 0;\n    var temp;\n    for (i = 0; i < objects.length; i++) {\n        var b = (0,_base_util__WEBPACK_IMPORTED_MODULE_20__.getBounds)(objects[parseInt(i.toString(), 10)].wrapper);\n        for (j = i + 1; j < objects.length; j++) {\n            var bounds = (0,_base_util__WEBPACK_IMPORTED_MODULE_20__.getBounds)(objects[parseInt(j.toString(), 10)].wrapper);\n            if (option === 'Top' || option === 'Bottom' || option === 'BottomToTop' || option === 'Middle') {\n                if (b.center.y > bounds.center.y) {\n                    temp = objects[parseInt(i.toString(), 10)];\n                    objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];\n                    objects[parseInt(j.toString(), 10)] = temp;\n                }\n            }\n            else {\n                if (b.center.x > bounds.center.x) {\n                    temp = objects[parseInt(i.toString(), 10)];\n                    objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];\n                    objects[parseInt(j.toString(), 10)] = temp;\n                }\n            }\n        }\n    }\n    return objects;\n}\n/**\n * getAnnotationPosition method \\\n *\n * @returns {SegmentInfo } getAnnotationPosition method .\\\n * @param {PointModel[]} pts - provide the pts  value.\n * @param { PathAnnotation | ConnectorFixedUserHandle} annotation - provide the annotation  value.\n * @param { Rect } bound - provide the bound  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getAnnotationPosition(pts, annotation, bound) {\n    //let angle: number;\n    //let getloop: SegmentInfo;\n    //let point: PointModel;\n    var getloop = getOffsetOfConnector(pts, annotation);\n    var angle = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findAngle(pts[getloop.index], pts[getloop.index + 1]);\n    var alignednumber = getAlignedPosition(annotation);\n    var point = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform(getloop.point, angle + 45, alignednumber);\n    getloop.point = point;\n    getloop.angle = angle;\n    return getloop;\n}\n/**\n * getPortsPosition method \\\n *\n * @returns {SegmentInfo } getPortsPosition method .\\\n * @param {PointModel[]} pts - provide the pts  value.\n * @param { Port} ports - provide the ports  value.\n * @param { Rect } bound - provide the bound  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getPortsPosition(pts, ports, bound) {\n    var getloop = getOffsetOfPorts(pts, ports);\n    var angle = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findAngle(pts[getloop.index], pts[getloop.index + 1]);\n    var alignednumber = getAlignedPositionForPorts(ports);\n    var point = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform(getloop.point, angle + 45, alignednumber);\n    getloop.point = point;\n    getloop.angle = angle;\n    return getloop;\n}\n/**\n * getOffsetOfPorts method \\\n *\n * @returns {SegmentInfo } getOffsetOfPorts method .\\\n * @param {PointModel[]} points - provide the pts  value.\n * @param { PathAnnotation | ConnectorFixedUserHandle} ports - provide the ports  value.\n * @private\n */\nfunction getOffsetOfPorts(points, ports) {\n    // eslint-disable-next-line\n    var distance = 0;\n    var offset = ports.offset;\n    var point;\n    var angle;\n    var pointDistance = [];\n    var prevLength;\n    var kCount;\n    for (var j = 0; j < points.length - 1; j++) {\n        distance += _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.distancePoints(points[parseInt(j.toString(), 10)], points[j + 1]);\n        pointDistance.push(distance);\n    }\n    var offsetLength = offset * distance;\n    for (var k = 0; k < pointDistance.length; k++) {\n        if (pointDistance[parseInt(k.toString(), 10)] >= offsetLength) {\n            angle = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findAngle(points[parseInt(k.toString(), 10)], points[k + 1]);\n            point = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform(points[parseInt(k.toString(), 10)], angle, offsetLength - (prevLength || 0));\n            kCount = k;\n            return { point: point, index: kCount };\n        }\n        prevLength = pointDistance[parseInt(k.toString(), 10)];\n    }\n    return { point: point, index: kCount };\n}\n/**\n * getAlignedPosition method . To get the port alignment position \\\n *\n * @returns {number } getAlignedPosition method .\\\n * @param {PointModel[]} ports - provide the annotation value.\n * @private\n */\nfunction getAlignedPositionForPorts(ports) {\n    var constant = 0;\n    var state = 0;\n    switch (ports.alignment) {\n        case 'Center':\n            state = 0;\n            break;\n        case 'Before':\n            state = -((0) / 2 + constant);\n            break;\n        case 'After':\n            state = ((0) / 2 + constant);\n            break;\n    }\n    return state;\n}\n/**\n * getOffsetOfConnector method \\\n *\n * @returns {SegmentInfo } getOffsetOfConnector method .\\\n * @param {PointModel[]} points - provide the pts  value.\n * @param { PathAnnotation | ConnectorFixedUserHandle} annotation - provide the annotation  value.\n * @private\n */\nfunction getOffsetOfConnector(points, annotation) {\n    // eslint-disable-next-line\n    var length = 0;\n    var offset = annotation.offset;\n    var point;\n    var angle;\n    var lengths = [];\n    var prevLength;\n    var kCount;\n    for (var j = 0; j < points.length - 1; j++) {\n        length += _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.distancePoints(points[parseInt(j.toString(), 10)], points[j + 1]);\n        lengths.push(length);\n    }\n    var offsetLength = offset * length;\n    for (var k = 0; k < lengths.length; k++) {\n        if (lengths[parseInt(k.toString(), 10)] >= offsetLength) {\n            angle = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.findAngle(points[parseInt(k.toString(), 10)], points[k + 1]);\n            point = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform(points[parseInt(k.toString(), 10)], angle, offsetLength - (prevLength || 0));\n            kCount = k;\n            return { point: point, index: kCount };\n        }\n        prevLength = lengths[parseInt(k.toString(), 10)];\n    }\n    return { point: point, index: kCount };\n}\n/**\n * getAlignedPosition method \\\n *\n * @returns {number } getAlignedPosition method .\\\n * @param {PointModel[]} annotation - provide the annotation value.\n * @private\n */\nfunction getAlignedPosition(annotation) {\n    var cnst;\n    if ((annotation instanceof _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_32__.ConnectorFixedUserHandle)) {\n        cnst = 0;\n    }\n    else {\n        cnst = annotation.content === undefined ? 10 : 0;\n    }\n    var state = 0;\n    switch (annotation.alignment) {\n        case 'Center':\n            state = 0;\n            break;\n        case 'Before':\n            state = -((0) / 2 + cnst);\n            break;\n        case 'After':\n            state = ((0) / 2 + cnst);\n            break;\n    }\n    return state;\n}\n/**\n * alignLabelOnSegments method \\\n *\n * @returns {Alignment } alignLabelOnSegments method .\\\n * @param {PathAnnotation | ConnectorFixedUserHandle} obj - provide the obj  value.\n * @param { number } ang - provide the ang  value.\n * @param { PointModel[] } pts - provide the pts  value.\n * @private\n */\nfunction alignLabelOnSegments(obj, ang, pts) {\n    //let angle: number = ang % 360;\n    ang %= 360;\n    var fourty5 = 45;\n    var one35 = 135;\n    var two25 = 225;\n    var three15 = 315;\n    var vAlign;\n    var hAlign;\n    switch (obj.alignment) {\n        case 'Before':\n            if (ang >= fourty5 && ang <= one35) {\n                hAlign = 'right';\n                vAlign = obj.offset === 0.5 ? 'center' : 'top';\n            }\n            else if (ang >= two25 && ang <= three15) {\n                hAlign = 'left';\n                vAlign = obj.offset === 0.5 ? 'center' : 'bottom';\n            }\n            else if (ang > fourty5 && ang < two25) {\n                vAlign = 'top';\n                hAlign = obj.offset === 0.5 ? 'center' : 'right';\n            }\n            else {\n                vAlign = 'bottom';\n                hAlign = (obj.offset === 0.5) ? 'center' : 'left';\n            }\n            break;\n        case 'After':\n            if (ang >= fourty5 && ang <= one35) {\n                hAlign = 'left';\n                vAlign = obj.offset === 0.5 ? 'center' : 'top';\n            }\n            else if (ang >= two25 && ang <= three15) {\n                hAlign = 'right';\n                vAlign = obj.offset === 0.5 ? 'center' : 'bottom';\n            }\n            else if (ang > fourty5 && ang < two25) {\n                vAlign = 'bottom';\n                hAlign = obj.offset === 0.5 ? 'center' : 'right';\n            }\n            else {\n                vAlign = 'top';\n                hAlign = obj.offset === 0.5 ? 'center' : 'left';\n            }\n            break;\n        case 'Center':\n            hAlign = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isNullOrUndefined)(obj.horizontalAlignment) ? obj.horizontalAlignment.toLowerCase() : 'center';\n            vAlign = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isNullOrUndefined)(obj.verticalAlignment) ? obj.verticalAlignment.toLowerCase() : 'center';\n            break;\n    }\n    if (obj.offset === 0 || obj.offset === 1) {\n        //let direction: string;\n        var direction = getBezierDirection(pts[0], pts[1]);\n        switch (direction) {\n            case 'left':\n                hAlign = obj.offset === 0 ? 'right' : 'left';\n                break;\n            case 'right':\n                hAlign = obj.offset === 0 ? 'left' : 'right';\n                break;\n            case 'bottom':\n                vAlign = obj.offset === 0 ? 'top' : 'bottom';\n                break;\n            case 'top':\n                vAlign = obj.offset === 0 ? 'bottom' : 'top';\n                break;\n        }\n    }\n    return { hAlign: hAlign, vAlign: vAlign };\n}\n/**\n * getBezierDirection method \\\n *\n * @returns {string } getBezierDirection method .\\\n * @param {PointModel} src - provide the src  value.\n * @param { PointModel } tar - provide the tar  value.\n * @private\n */\nfunction getBezierDirection(src, tar) {\n    if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y)) {\n        return src.x < tar.x ? 'right' : 'left';\n    }\n    else {\n        return src.y < tar.y ? 'bottom' : 'top';\n    }\n}\n/**\n * removeChildNodes method \\\n *\n * @returns {void } removeChildNodes method .\\\n * @param {NodeModel} node - provide the node  value.\n * @param { Diagram } diagram - provide the diagram  value.\n * @private\n */\nfunction removeChildNodes(node, diagram) {\n    if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node && node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n            if (diagram.nameTable[node.children[parseInt(i.toString(), 10)]].children) {\n                removeChildNodes(node, diagram);\n            }\n            diagram.removeFromAQuad(diagram.nameTable[node.children[parseInt(i.toString(), 10)]]);\n            diagram.removeObjectsFromLayer(diagram.nameTable[node.children[parseInt(i.toString(), 10)]]);\n            delete diagram.nameTable[node.children[parseInt(i.toString(), 10)]];\n        }\n    }\n}\n/**\n * getChild method \\\n *\n * @returns {string[] } getChild method .\\\n * @param {Canvas} child - provide the child  value.\n * @param { string[] } children - provide the children  value.\n * @private\n */\nfunction getChild(child, children) {\n    if (child && child.children && child.children.length > 0) {\n        for (var j = 0; j < child.children.length; j++) {\n            var subChild = child.children[parseInt(j.toString(), 10)];\n            if (subChild instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_27__.Canvas) {\n                getChild(subChild, children);\n            }\n        }\n    }\n    if (children.indexOf(child.id) === -1) {\n        children.push(child.id);\n    }\n    return children;\n}\n/**\n * getSwimLaneChildren method \\\n *\n * @returns {string[] } getSwimLaneChildren method .\\\n * @param {NodeModel[]} nodes - provide the nodes  value.\n * @private\n */\nfunction getSwimLaneChildren(nodes) {\n    var children = [];\n    var node;\n    var grid;\n    var childTable;\n    var child;\n    var gridChild = 'childTable';\n    for (var i = 0; i < nodes.length; i++) {\n        node = nodes[parseInt(i.toString(), 10)];\n        if (node.shape.type === 'SwimLane') {\n            grid = node.wrapper.children[0];\n            childTable = grid[\"\" + gridChild];\n            for (var _i = 0, _a = Object.keys(childTable); _i < _a.length; _i++) {\n                var key = _a[_i];\n                child = childTable[\"\" + key];\n                children = getChild(child, children);\n            }\n        }\n    }\n    return children;\n}\n/**\n * removeUnnecessaryNodes method \\\n *\n * @returns {void } removeUnnecessaryNodes method .\\\n * @param {string[]} children - provide the children  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nfunction removeUnnecessaryNodes(children, diagram) {\n    var nodes = diagram.nodes;\n    if (nodes) {\n        for (var i = 0; i < nodes.length; i++) {\n            if (children.indexOf(nodes[parseInt(i.toString(), 10)].id) !== -1) {\n                nodes.splice(i, 1);\n                i--;\n            }\n        }\n    }\n}\n/**\n * serialize method \\\n *\n * @returns {string } serialize method .\\\n * @param {Diagram} model - provide the model  value.\n * @private\n */\nfunction serialize(model) {\n    var removeNodes = getSwimLaneChildren(model.nodes);\n    var clonedObject = (0,_base_util__WEBPACK_IMPORTED_MODULE_20__.cloneObject)(model, model.getCustomProperty);\n    clonedObject.selectedItems.nodes = [];\n    clonedObject.selectedItems.connectors = [];\n    clonedObject.selectedItems.wrapper = null;\n    if (model.serializationSettings.preventDefaults) {\n        clonedObject = preventDefaults(clonedObject, model);\n    }\n    // EJ2-913802 Sub process child won't get serialized when it is a child of a lane.\n    model.nodes.forEach(function (node) {\n        if (node.shape.type === 'SwimLane') {\n            var processes_1 = model.commandHandler.findProcesses(node);\n            processes_1.forEach(function (processId) {\n                clonedObject.nodes.forEach(function (clonedNode) {\n                    if (clonedNode.id === processId) {\n                        var nodeWrapper = clonedNode.wrapper;\n                        clonedNode.offsetX = nodeWrapper.offsetX;\n                        clonedNode.offsetY = nodeWrapper.offsetY;\n                    }\n                });\n            });\n            if (processes_1.length > 0) {\n                removeNodes = removeNodes.filter(function (removeNodeId) { return !processes_1.includes(removeNodeId); });\n            }\n        }\n    });\n    removeUnnecessaryNodes(removeNodes, clonedObject);\n    return JSON.stringify(clonedObject);\n}\n/**\n * preventDefaults method \\\n *\n * @returns {string } preventDefaults method .\\\n * @param {Object} clonedObject - provide the clonedObject  value.\n * @param {object} model - provide the model  value.\n * @param {object} defaultObject - provide the defaultObject  value.\n * @param {boolean} isNodeShape - provide the isNodeShape  value.\n * @private\n */\n// eslint-disable-next-line\nfunction preventDefaults(clonedObject, model, defaultObject, isNodeShape) {\n    defaultObject = getConstructor(model, defaultObject);\n    var properties = [];\n    properties = properties.concat(Object.keys(clonedObject));\n    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {\n        var property = properties_1[_i];\n        if (model instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node) {\n            isNodeShape = (property === 'shape') ? true : false;\n        }\n        if (clonedObject[\"\" + property] instanceof Array) {\n            preventArrayDefaults(clonedObject, defaultObject, model, property);\n        }\n        else if ((clonedObject[\"\" + property] instanceof Object) && defaultObject && defaultObject[\"\" + property]) {\n            if (property !== 'wrapper') {\n                clonedObject[\"\" + property] = preventDefaults(clonedObject[\"\" + property], model[\"\" + property], defaultObject[\"\" + property], isNodeShape);\n            }\n        }\n        else if ((defaultObject && clonedObject[\"\" + property] === defaultObject[\"\" + property]) || clonedObject[\"\" + property] === undefined) {\n            if (!(isNodeShape && property === 'type') && !(model instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.SwimLane && property === 'orientation')) {\n                delete clonedObject[\"\" + property];\n            }\n        }\n        if (JSON.stringify(clonedObject[\"\" + property]) === '[]' ||\n            JSON.stringify(clonedObject[\"\" + property]) === '{}' ||\n            clonedObject[\"\" + property] === undefined) {\n            delete clonedObject[\"\" + property];\n        }\n    }\n    defaultObject = undefined;\n    properties = undefined;\n    return clonedObject;\n}\n/**\n * preventArrayDefaults method \\\n *\n * @returns {void } preventArrayDefaults method .\\\n * @param {object} clonedObject - provide the clonedObject  value.\n * @param {object} defaultObject - provide the defaultObject  value.\n * @param {object} model - provide the model  value.\n * @param {string} property - provide the property  value.\n * @private\n */\n// eslint-disable-next-line\nfunction preventArrayDefaults(clonedObject, defaultObject, model, property) {\n    if (clonedObject[\"\" + property].length === 0) {\n        delete clonedObject[\"\" + property];\n        // eslint-disable-next-line\n    }\n    else if (clonedObject[property].every(function (element) { return typeof element === 'number'; })) {\n        var i = void 0;\n        var isSameArray = true;\n        for (i = 0; i < clonedObject[\"\" + property].length; i++) {\n            if (isSameArray && clonedObject[\"\" + property][parseInt(i.toString(), 10)] === defaultObject[\"\" + property][parseInt(i.toString(), 10)]) {\n                isSameArray = true;\n            }\n            else {\n                isSameArray = false;\n            }\n        }\n        if (isSameArray) {\n            delete clonedObject[\"\" + property];\n        }\n    }\n    else {\n        var i = void 0;\n        // Bug 826717: Unable to select swimlane child nodes after serializing the diagram when we enable preventDefault property.\n        // Removed the codition to delete the layers from clonedObject.\n        if (clonedObject[\"\" + property] && property !== 'layers') {\n            for (i = clonedObject[\"\" + property].length - 1; i >= 0; i--) {\n                if (property === 'nodes' || property === 'connectors') {\n                    clonedObject[\"\" + property][parseInt(i.toString(), 10)].wrapper = null;\n                }\n                if (property !== 'dataManager') {\n                    clonedObject[\"\" + property][parseInt(i.toString(), 10)] = preventDefaults(clonedObject[\"\" + property][parseInt(i.toString(), 10)], model[\"\" + property][parseInt(i.toString(), 10)], (defaultObject[\"\" + property] !== undefined ? defaultObject[\"\" + property][parseInt(i.toString(), 10)] : []));\n                    if (JSON.stringify(clonedObject[\"\" + property][parseInt(i.toString(), 10)]) === '[]' ||\n                        JSON.stringify(clonedObject[\"\" + property][parseInt(i.toString(), 10)]) === '{}' ||\n                        clonedObject[\"\" + property][parseInt(i.toString(), 10)] === undefined) {\n                        clonedObject[\"\" + property].splice(i, 1);\n                    }\n                }\n            }\n        }\n    }\n    clonedObject = undefined;\n}\n/* eslint-disable */\n/**\n * getConstructor method \\\n *\n * @returns {object } getConstructor method .\\\n * @param {object} model - provide the model  value.\n * @param {object} defaultObject - provide the defaultObject  value.\n * @private\n */\n/* tslint:disable */\nfunction getConstructor(model, defaultObject) {\n    var obj = [];\n    var constructor;\n    var getClassName = 'getClassName';\n    if (model[getClassName]) {\n        //EJ2-59327 - Memory leak occurs in saveDiagram method \n        var parent_1 = new _diagram__WEBPACK_IMPORTED_MODULE_17__.Diagram();\n        switch (model[getClassName]()) {\n            case 'Diagram':\n                constructor = parent_1;\n                break;\n            case 'Node':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node(parent_1, '', obj);\n                break;\n            case 'Path':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Path(parent_1, '', obj);\n                break;\n            case 'Native':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Native(parent_1, '', obj);\n                break;\n            case 'Html':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Html(parent_1, '', obj);\n                break;\n            case 'Image':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Image(parent_1, '', obj);\n                break;\n            case 'Text':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Text(parent_1, '', obj);\n                break;\n            case 'BasicShape':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BasicShape(parent_1, '', obj);\n                break;\n            case 'FlowShape':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.FlowShape(parent_1, '', obj);\n                break;\n            case 'BpmnShape':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BpmnShape(parent_1, '', obj);\n                break;\n            case 'UmlActivityShape':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlActivityShape(parent_1, '', obj);\n                break;\n            case 'UmlClassifierShape':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlClassifierShape(parent_1, '', obj);\n                break;\n            case 'SwimLane':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.SwimLane(parent_1, '', obj);\n                if (model.header) {\n                    constructor.header = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Header(parent_1, '', obj);\n                    constructor.header.style.fill = '';\n                }\n                break;\n            case 'ShapeAnnotation':\n                constructor = new _objects_annotation__WEBPACK_IMPORTED_MODULE_12__.ShapeAnnotation(parent_1, '', obj);\n                break;\n            case 'PointPort':\n                constructor = new _objects_port__WEBPACK_IMPORTED_MODULE_28__.PointPort(parent_1, '', obj);\n                break;\n            case 'BpmnGateway':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BpmnGateway(parent_1, '', obj);\n                break;\n            case 'BpmnDataObject':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BpmnDataObject(parent_1, '', obj);\n                break;\n            case 'BpmnEvent':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BpmnEvent(parent_1, '', obj);\n                break;\n            case 'BpmnSubEvent':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BpmnSubEvent(parent_1, '', obj);\n                break;\n            case 'BpmnActivity':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BpmnActivity(parent_1, '', obj);\n                break;\n            case 'BpmnAnnotation':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.BpmnAnnotation(parent_1, '', obj);\n                break;\n            case 'MethodArguments':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.MethodArguments(parent_1, '', obj);\n                break;\n            case 'UmlClassAttribute':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlClassAttribute(parent_1, '', obj);\n                break;\n            case 'UmlClassMethod':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlClassMethod(parent_1, '', obj);\n                break;\n            case 'UmlClass':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlClass(parent_1, '', obj);\n                break;\n            case 'UmlInterface':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlInterface(parent_1, '', obj);\n                break;\n            case 'UmlEnumerationMember':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlEnumerationMember(parent_1, '', obj);\n                break;\n            case 'UmlEnumeration':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.UmlEnumeration(parent_1, '', obj);\n                break;\n            case 'Lane':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Lane(parent_1, '', obj);\n                break;\n            case 'Phase':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.Phase(parent_1, '', obj);\n                break;\n            case 'ChildContainer':\n                constructor = new _objects_node__WEBPACK_IMPORTED_MODULE_13__.ChildContainer();\n                break;\n            case 'Connector':\n                constructor = new _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector(parent_1, '', obj);\n                break;\n            case 'StraightSegment':\n                constructor = new _objects_connector__WEBPACK_IMPORTED_MODULE_14__.StraightSegment(parent_1, '', obj);\n                break;\n            case 'BezierSegment':\n                constructor = new _objects_connector__WEBPACK_IMPORTED_MODULE_14__.BezierSegment(parent_1, '', obj);\n                break;\n            case 'OrthogonalSegment':\n                constructor = new _objects_connector__WEBPACK_IMPORTED_MODULE_14__.OrthogonalSegment(parent_1, '', obj);\n                break;\n            case 'PathAnnotation':\n                constructor = new _objects_annotation__WEBPACK_IMPORTED_MODULE_12__.PathAnnotation(parent_1, '', obj);\n                break;\n            case 'Stop':\n                constructor = new _core_appearance__WEBPACK_IMPORTED_MODULE_5__.Stop(parent_1, '', obj);\n                break;\n            case 'Point':\n                if (!defaultObject) {\n                    constructor = new _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point(parent_1, '', obj);\n                }\n                else {\n                    constructor = defaultObject;\n                }\n                break;\n            case 'UserHandle':\n                constructor = new _interaction_selector__WEBPACK_IMPORTED_MODULE_25__.UserHandle(parent_1, '', obj);\n                break;\n            case 'Command':\n                constructor = new _diagram_keyboard_commands__WEBPACK_IMPORTED_MODULE_29__.Command(parent_1, '', obj);\n                break;\n        }\n    }\n    else {\n        constructor = defaultObject;\n    }\n    parent = undefined;\n    defaultObject = undefined;\n    return constructor;\n}\n/* eslint-enable */\n/* eslint-disable */\n/** @private */\nfunction deserialize(model, diagram) {\n    diagram.enableServerDataBinding(false);\n    var blazorAction = diagram.blazorActions;\n    diagram.blazorActions = diagram.addConstraints(blazorAction, _enum_enum__WEBPACK_IMPORTED_MODULE_7__.BlazorAction.ClearObject);\n    diagram.clear();\n    diagram.blazorActions = diagram.removeConstraints(blazorAction, _enum_enum__WEBPACK_IMPORTED_MODULE_7__.BlazorAction.ClearObject);\n    diagram.protectPropertyChange(true);\n    var map = diagram.dataSourceSettings.doBinding;\n    var nodeTemp = diagram.setNodeTemplate;\n    var getDescription = diagram.getDescription;\n    var getCustomProperty = diagram.getCustomProperty;\n    var commands = {};\n    for (var _i = 0, _a = diagram.commandManager.commands; _i < _a.length; _i++) {\n        var command = _a[_i];\n        commands[command.name] = { execute: command.execute, canExecute: command.canExecute };\n    }\n    var arrangeTickHorizontal = diagram.rulerSettings.horizontalRuler.arrangeTick;\n    var arrangeTickVertical = diagram.rulerSettings.verticalRuler.arrangeTick;\n    var getLayoutInfo = diagram.layout.getLayoutInfo;\n    var getBranch = diagram.layout.getBranch;\n    var nodeDefaults = diagram.getNodeDefaults;\n    var connectorDefaults = diagram.getConnectorDefaults;\n    var dataObj;\n    if (!(model instanceof Object)) {\n        dataObj = JSON.parse(model);\n    }\n    else {\n        dataObj = model;\n    }\n    dataObj = upgrade(dataObj);\n    diagram.contextMenuSettings = dataObj.contextMenuSettings || {};\n    diagram.constraints = dataObj.constraints || _enum_enum__WEBPACK_IMPORTED_MODULE_7__.DiagramConstraints.Default;\n    diagram.tool = dataObj.tool || _enum_enum__WEBPACK_IMPORTED_MODULE_7__.DiagramTools.Default;\n    diagram.bridgeDirection = dataObj.bridgeDirection || 'Top';\n    diagram.pageSettings = dataObj.pageSettings || {};\n    diagram.drawingObject = dataObj.drawingObject || undefined;\n    diagram.tooltip = dataObj.tooltip || {};\n    diagram.addInfo = dataObj.addInfo || undefined;\n    diagram.getDescription = getDescription;\n    diagram.scrollSettings = dataObj.scrollSettings || {};\n    diagram.commandManager = dataObj.commandManager || {};\n    /**\n    * EJ2-62846-Exception occurs after save and load when layers are undefined.\n    */\n    if (dataObj.layers && dataObj.layers.length > 0) {\n        sortLayerObjects(dataObj);\n    }\n    diagram.layers = dataObj.layers || [];\n    diagram.rulerSettings.horizontalRuler.arrangeTick = arrangeTickHorizontal;\n    diagram.rulerSettings.verticalRuler.arrangeTick = arrangeTickVertical;\n    for (var _b = 0, _c = diagram.commandManager.commands; _b < _c.length; _b++) {\n        var cmd = _c[_b];\n        if (commands[cmd.name]) {\n            cmd.execute = commands[cmd.name].execute;\n            cmd.canExecute = commands[cmd.name].canExecute;\n        }\n    }\n    diagram.backgroundColor = dataObj.backgroundColor || 'transparent';\n    diagram.basicElements = dataObj.basicElements || [];\n    // EJ2-66465 - Added below code to empty the segment collection if connector type is bezier\n    if (dataObj.connectors) {\n        for (var i = 0; i < dataObj.connectors.length; i++) {\n            // EJ2-69816 - Added below code to empty the segment collection if connector type is bezier and allowSegmentsReset is true\n            if (dataObj.connectors[i].type === 'Bezier' && dataObj.connectors[i].segments.length > 0 && dataObj.connectors[i].bezierSettings && dataObj.connectors[i].bezierSettings.allowSegmentsReset) {\n                dataObj.connectors[i].segments = [];\n            }\n        }\n    }\n    diagram.connectors = dataObj.connectors || [];\n    diagram.dataSourceSettings = dataObj.dataSourceSettings || {};\n    diagram.dataSourceSettings.doBinding = map;\n    diagram.height = dataObj.height || '100%';\n    diagram.setNodeTemplate = nodeTemp;\n    diagram.getConnectorDefaults = connectorDefaults;\n    diagram.getNodeDefaults = nodeDefaults;\n    diagram.getCustomProperty = getCustomProperty;\n    diagram.mode = dataObj.mode || 'SVG';\n    if (dataObj.nodes) {\n        for (var i = 0; i < dataObj.nodes.length; i++) {\n            if (dataObj.nodes[i].shape && dataObj.nodes[i].shape.type === 'SwimLane') {\n                if (dataObj.nodes[i].wrapper == null) {\n                    {\n                        dataObj.nodes[i].wrapper = {\n                            actualSize: { width: dataObj.nodes[i].width, height: dataObj.nodes[i].height },\n                            offsetX: dataObj.nodes[i].offsetX, offsetY: dataObj.nodes[i].offsetY\n                        };\n                    }\n                }\n                (0,_swim_lane_util__WEBPACK_IMPORTED_MODULE_30__.pasteSwimLane)(dataObj.nodes[i], undefined, undefined, undefined, undefined, true);\n            }\n        }\n    }\n    diagram.nodes = dataObj.nodes || [];\n    changeOldFlipDirectionType(diagram.nodes);\n    changeOldFlipDirectionType(diagram.connectors);\n    diagram.rulerSettings = dataObj.rulerSettings || {};\n    diagram.snapSettings = dataObj.snapSettings || {};\n    diagram.width = dataObj.width || '100%';\n    diagram.layout = dataObj.layout || {};\n    if (dataObj.layout && dataObj.layout.type !== \"None\") {\n        diagram.canLayout = false;\n    }\n    diagram.layout.getLayoutInfo = (0,_base_util__WEBPACK_IMPORTED_MODULE_20__.getFunction)(getLayoutInfo);\n    diagram.layout.getBranch = (0,_base_util__WEBPACK_IMPORTED_MODULE_20__.getFunction)(getBranch);\n    diagram.diagramActions = 0;\n    diagram.isLoading = true;\n    diagram.protectPropertyChange(false);\n    var key = 'refresh';\n    var component;\n    for (var i = 0; i < diagram.views.length; i++) {\n        component = diagram.views[diagram.views[i]];\n        diagram.blazorActions = diagram.addConstraints(blazorAction, _enum_enum__WEBPACK_IMPORTED_MODULE_7__.BlazorAction.ClearObject);\n        component.refresh();\n        // Bug 849892: The Overview does not update properly When loading the diagram with the loadDiagram API.\n        // For this -> EJ2-69580  issue the overview refresh got prevented which leads to this Bug 849892, so added below condition to reset \n        // the overview.\n        if (component instanceof _overview_overview__WEBPACK_IMPORTED_MODULE_33__.Overview) {\n            component.onPropertyChanged({ sourceID: component.sourceID }, {});\n        }\n        diagram.blazorActions = diagram.removeConstraints(blazorAction, _enum_enum__WEBPACK_IMPORTED_MODULE_7__.BlazorAction.ClearObject);\n        if (component instanceof _diagram__WEBPACK_IMPORTED_MODULE_17__.Diagram) {\n            diagram.element.classList.add('e-diagram');\n        }\n    }\n    //881117 - Event to notify after diagram elements are loaded.  \n    var args = { name: 'loaded', diagram: diagram };\n    diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_7__.DiagramEvent.loaded, args);\n    if (dataObj.selectedItems) {\n        dataObj.selectedItems.nodes = [];\n        dataObj.selectedItems.connectors = [];\n        //EJ2-61674 Exception occurs when we move the node after save and load\n        dataObj.selectedItems.selectedObjects = [];\n    }\n    diagram.selectedItems = dataObj.selectedItems;\n    diagram.enableServerDataBinding(true);\n    diagram.canLayout = true;\n    diagram.swimlaneChildTable = {};\n    diagram.swimlaneZIndexTable = {};\n    // EJ2-913802 Sub process child won't get serialized when it is a child of a lane.\n    diagram.nodes.forEach(function (node) {\n        if (node.shape.type === 'SwimLane') {\n            var processes = diagram.commandHandler.findProcesses(node);\n            processes.forEach(function (processId) {\n                var child = diagram.nameTable[processId];\n                if (child && diagram.nameTable[child.processId]) {\n                    var targetWrapper = diagram.nameTable[child.processId].wrapper;\n                    targetWrapper.children.push(child.wrapper);\n                }\n            });\n        }\n    });\n    return dataObj;\n}\n/**\n * To change the string type flip into enum type.\\\n *\n * @param {(NodeModel | ConnectorModel)[]} obj - provide the node or connector collection.\n * @private\n */\nfunction changeOldFlipDirectionType(obj) {\n    // Filter elements that have `flip` set as a string\n    var filteredElements = obj.filter(function (element) { return typeof element.flip === 'string'; });\n    // Loop through the filtered elements and update their `flip` property\n    for (var _i = 0, filteredElements_1 = filteredElements; _i < filteredElements_1.length; _i++) {\n        var element = filteredElements_1[_i];\n        switch (element.flip) {\n            case 'Horizontal':\n                element.flip = _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Horizontal;\n                break;\n            case 'Vertical':\n                element.flip = _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Vertical;\n                break;\n            case 'Both':\n                element.flip = _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Both;\n                break;\n            case 'None':\n                element.flip = _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.None;\n                break;\n        }\n    }\n}\n/**\n * EJ2-61537 - Connectors not connected to the node after save and load\n * when we add nodes and connectors at runtime.\n * */\n/**\n* Sort the nodes and connectors in the layers.\n*\n* @param {Diagram} dataObj - provide the model value.\n* @private\n* */\nfunction sortLayerObjects(dataObj) {\n    var i, j, k;\n    var layers = [];\n    for (i = 0; i < dataObj.layers.length; i++) {\n        for (j = 0; j < dataObj.layers[i].objects.length; j++) {\n            if (dataObj.nodes) {\n                for (k = 0; k < dataObj.nodes.length; k++) {\n                    if (dataObj.layers[i].objects[j] === dataObj.nodes[k].id) {\n                        layers.push(dataObj.layers[i].objects[j]);\n                    }\n                }\n            }\n        }\n        for (j = 0; j < dataObj.layers[i].objects.length; j++) {\n            if (dataObj.connectors) {\n                for (k = 0; k < dataObj.connectors.length; k++) {\n                    if (dataObj.layers[i].objects[j] === dataObj.connectors[k].id) {\n                        layers.push(dataObj.layers[i].objects[j]);\n                    }\n                }\n            }\n        }\n        dataObj.layers[i].objects = layers;\n        layers = [];\n    }\n}\n/* eslint-enable */\n/**\n * upgrade method \\\n *\n * @returns {Diagram } upgrade method .\\\n * @param {Diagram} dataObj - provide the model  value.\n * @private\n */\nfunction upgrade(dataObj) {\n    if (dataObj && (dataObj.version === undefined || (dataObj.version < 17.1)) && dataObj.nodes) {\n        var nodes = dataObj.nodes;\n        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n            var node = nodes_1[_i];\n            if (node && node.ports && node.ports.length > 0) {\n                for (var _a = 0, _b = node.ports; _a < _b.length; _a++) {\n                    var port = _b[_a];\n                    if (port && port.constraints && port.constraints === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.PortConstraints.None) {\n                        port.constraints = _enum_enum__WEBPACK_IMPORTED_MODULE_7__.PortConstraints.Default;\n                    }\n                }\n            }\n        }\n    }\n    return dataObj;\n}\n/**\n * updateStyle method \\\n *\n * @returns {void } updateStyle method .\\\n * @param {TextStyleModel} changedObject - provide the changedObject  value.\n * @param {DiagramElement} target - provide the target  value.\n * @private\n */\nfunction updateStyle(changedObject, target) {\n    //since text style model is the super set of shape style model, we used text style model\n    var style = target.style;\n    var textElement = target;\n    target.canApplyStyle = true;\n    for (var _i = 0, _a = Object.keys(changedObject); _i < _a.length; _i++) {\n        var key = _a[_i];\n        switch (key) {\n            case 'fill':\n                style.fill = changedObject.fill;\n                if (style instanceof _core_appearance__WEBPACK_IMPORTED_MODULE_5__.StrokeStyle) {\n                    /* tslint:disable:no-string-literal */\n                    style['fill'] = 'transparent';\n                }\n                break;\n            case 'textOverflow':\n                style.textOverflow = changedObject.textOverflow;\n                break;\n            case 'opacity':\n                style.opacity = changedObject.opacity;\n                break;\n            case 'strokeColor':\n                style.strokeColor = changedObject.strokeColor;\n                break;\n            case 'strokeDashArray':\n                style.strokeDashArray = changedObject.strokeDashArray;\n                break;\n            case 'strokeWidth':\n                style.strokeWidth = changedObject.strokeWidth;\n                break;\n            case 'bold':\n                style.bold = changedObject.bold;\n                break;\n            case 'color':\n                style.color = changedObject.color;\n                break;\n            case 'textWrapping':\n                style.textWrapping = changedObject.textWrapping;\n                break;\n            case 'fontFamily':\n                style.fontFamily = changedObject.fontFamily;\n                break;\n            case 'fontSize':\n                style.fontSize = changedObject.fontSize;\n                break;\n            case 'italic':\n                style.italic = changedObject.italic;\n                break;\n            case 'textAlign':\n                style.textAlign = changedObject.textAlign;\n                break;\n            case 'whiteSpace':\n                style.whiteSpace = changedObject.whiteSpace;\n                break;\n            case 'textDecoration':\n                style.textDecoration = changedObject.textDecoration;\n                break;\n            case 'gradient':\n                if (style.gradient) {\n                    updateGradient(changedObject.gradient, style.gradient);\n                    break;\n                }\n        }\n    }\n    if (target instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_10__.TextElement) {\n        textElement.refreshTextElement();\n    }\n}\n/**\n * updateGradient method \\\n *\n * @returns {void } updateGradient method .\\\n * @param {GradientModel | LinearGradientModel | RadialGradientModel} changedGradient - provide the changedGradient  value.\n * @param {GradientModel | LinearGradientModel | RadialGradientModel} targetGradient - provide the targetGradient  value.\n * @private\n */\nfunction updateGradient(changedGradient, targetGradient) {\n    for (var _i = 0, _a = Object.keys(changedGradient); _i < _a.length; _i++) {\n        var key = _a[_i];\n        switch (key) {\n            case 'type':\n                targetGradient.type = changedGradient.type;\n                break;\n            case 'x1':\n                targetGradient.x1 = changedGradient.x1;\n                break;\n            case 'x2':\n                targetGradient.x2 = changedGradient.x2;\n                break;\n            case 'y1':\n                targetGradient.y1 = changedGradient.y1;\n                break;\n            case 'y2':\n                targetGradient.y2 = changedGradient.y2;\n                break;\n            case 'cx':\n                targetGradient.cx = changedGradient.cx;\n                break;\n            case 'cy':\n                targetGradient.cy = changedGradient.cy;\n                break;\n            case 'fx':\n                targetGradient.fx = changedGradient.fx;\n                break;\n            case 'fy':\n                targetGradient.fy = changedGradient.fy;\n                break;\n            case 'r':\n                targetGradient.r = changedGradient.r;\n                break;\n            case 'stops':\n                targetGradient.stops = changedGradient.stops;\n                break;\n        }\n    }\n}\n/* eslint-disable */\n/**\n * updateHyperlink method \\\n *\n * @returns {void } updateHyperlink method .\\\n * @param {HyperlinkModel} changedObject - provide the changedObject  value.\n * @param {DiagramElement} target - provide the target  value.\n * @param {AnnotationModel} actualAnnotation - provide the actualAnnotation  value.\n * @private\n */\nfunction updateHyperlink(changedObject, target, actualAnnotation) {\n    var textElement = target;\n    var hyperlink = textElement.hyperlink;\n    for (var _i = 0, _a = Object.keys(changedObject); _i < _a.length; _i++) {\n        var key = _a[_i];\n        switch (key) {\n            case 'color':\n                textElement.style.color = hyperlink.color = changedObject.color;\n                break;\n            case 'content':\n                textElement.content = hyperlink.content = changedObject.content || hyperlink.link;\n                break;\n            case 'link':\n                var labelStyle = actualAnnotation.style;\n                textElement.style.color = changedObject.link ? hyperlink.color : labelStyle.color;\n                textElement.style.textDecoration = changedObject.link ? hyperlink.textDecoration : actualAnnotation.style.textDecoration;\n                textElement.content = changedObject.link ? hyperlink.content || changedObject.link : actualAnnotation.content;\n                hyperlink.link = changedObject.link;\n                break;\n            case 'textDecoration':\n                textElement.style.textDecoration = hyperlink.textDecoration = changedObject.textDecoration;\n                break;\n            case 'hyperlinkOpenState':\n                hyperlink.hyperlinkOpenState = changedObject.hyperlinkOpenState;\n                break;\n        }\n    }\n}\n/* eslint-enable */\n/**\n * updateShapeContent method \\\n *\n * @returns {void } updateShapeContent method .\\\n * @param {DiagramElement} content - provide the content  value.\n * @param {Node} actualObject - provide the actualObject  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nfunction updateShapeContent(content, actualObject, diagram) {\n    content.width = actualObject.width;\n    content.height = actualObject.height;\n    content.minHeight = actualObject.minHeight;\n    content.maxHeight = actualObject.maxHeight;\n    content.minWidth = actualObject.minWidth;\n    content.maxWidth = actualObject.maxWidth;\n    content.horizontalAlignment = actualObject.wrapper.children[0].horizontalAlignment;\n    content.verticalAlignment = actualObject.wrapper.children[0].verticalAlignment;\n    content.relativeMode = actualObject.wrapper.children[0].relativeMode;\n    content.visible = actualObject.wrapper.children[0].visible;\n    if (actualObject.shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Text) {\n        content.margin = actualObject.shape.margin;\n    }\n    content.id = actualObject.wrapper.children[0].id;\n    content.style = actualObject.style;\n    //let view: View;\n    for (var _i = 0, _a = diagram.views; _i < _a.length; _i++) {\n        var elementId = _a[_i];\n        (0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.removeElement)(actualObject.id + '_groupElement', elementId);\n        (0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.removeElement)(actualObject.id + '_content_groupElement', elementId);\n        (0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.removeElement)(actualObject.id + '_html_element', elementId);\n    }\n    actualObject.wrapper.children.splice(0, 1);\n    actualObject.wrapper.children.splice(0, 0, content);\n}\n/* eslint-disable */\n/**\n * updateShape method \\\n *\n * @returns {void } updateShape method .\\\n * @param {Node} node - provide the node  value.\n * @param {Node} actualObject - provide the actualObject  value.\n * @param {Node} oldObject - provide the oldObject  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nfunction updateShape(node, actualObject, oldObject, diagram) {\n    var content = new _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_3__.DiagramElement();\n    var i;\n    //let textStyle: TextStyleModel; let nodeStyle: TextStyleModel;\n    switch (node.shape.type) {\n        case 'Path':\n            var pathContent = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n            pathContent.data = actualObject.shape.data;\n            content = pathContent;\n            updateShapeContent(content, actualObject, diagram);\n            break;\n        case 'Image':\n            var imageContent = new _core_elements_image_element__WEBPACK_IMPORTED_MODULE_11__.ImageElement();\n            imageContent.source = actualObject.shape.source;\n            imageContent.imageAlign = actualObject.shape.align;\n            imageContent.imageScale = actualObject.shape.scale;\n            content = imageContent;\n            updateShapeContent(content, actualObject, diagram);\n            break;\n        case 'Text':\n            //issue\n            var textContent = new _core_elements_text_element__WEBPACK_IMPORTED_MODULE_10__.TextElement();\n            //  (textContent as TextElement).content = (node.shape as TextModel).content;\n            content = textContent;\n            updateShapeContent(content, actualObject, diagram);\n            break;\n        case 'Basic':\n            var element = (actualObject.shape.shape === 'Rectangle') ? new _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_3__.DiagramElement() : new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n            if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)() && actualObject.shape.shape === 'Polygon')) {\n                element.data = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_21__.getPolygonPath)(actualObject.shape.points);\n            }\n            else {\n                element.data = (0,_objects_dictionary_basic_shapes__WEBPACK_IMPORTED_MODULE_15__.getBasicShape)(actualObject.shape.shape);\n            }\n            if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)() && actualObject.shape.shape === 'Rectangle')) {\n                element.cornerRadius = actualObject.shape.cornerRadius;\n            }\n            //EJ2-70880 - Node disappeared after changing shape and type dynamically.\n            content = element;\n            updateShapeContent(content, actualObject, diagram);\n            break;\n        case 'Flow':\n            /* eslint-disable */\n            var flowShapeElement = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n            var shape = actualObject.shape.shape;\n            flowShapeElement.data = (0,_objects_dictionary_flow_shapes__WEBPACK_IMPORTED_MODULE_16__.getFlowShape)(shape);\n            content = flowShapeElement;\n            updateShapeContent(content, actualObject, diagram);\n            break;\n        case 'Native':\n            var nativeContent = new _core_elements_native_element__WEBPACK_IMPORTED_MODULE_9__.DiagramNativeElement(node.id, diagram.element.id);\n            nativeContent.content = actualObject.shape.content;\n            nativeContent.scale = actualObject.shape.scale;\n            content = nativeContent;\n            updateShapeContent(content, actualObject, diagram);\n            break;\n        case 'HTML':\n            var htmlContent = new _core_elements_html_element__WEBPACK_IMPORTED_MODULE_22__.DiagramHtmlElement(actualObject.id, diagram.element.id);\n            htmlContent.content = actualObject.shape.content;\n            content = htmlContent;\n            updateShapeContent(content, actualObject, diagram);\n    }\n    if (node.shape.type === undefined || node.shape.type === oldObject.shape.type) {\n        updateContent(node, actualObject, diagram, oldObject);\n    }\n    else {\n        content.width = actualObject.wrapper.children[0].width;\n        content.height = actualObject.wrapper.children[0].height;\n        if (actualObject.shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Text) {\n            content.margin = actualObject.shape.margin;\n        }\n        content.style = actualObject.style;\n        actualObject.wrapper.children[0] = content;\n    }\n}\n/* eslint-enable */\n/**\n * updateContent method \\\n *\n * @returns {void } updateContent method .\\\n * @param {Node} newValues - provide the newValues  value.\n * @param {Node} actualObject - provide the actualObject  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {Node} oldObject - provide the oldObject  value.\n * @private\n */\nfunction updateContent(newValues, actualObject, diagram, oldObject) {\n    if (Object.keys(newValues.shape).length > 0) {\n        if (actualObject.shape.type === 'Path' && newValues.shape.data !== undefined) {\n            actualObject.wrapper.children[0].data = newValues.shape.data;\n        }\n        else if (actualObject.shape.type === 'Text' && newValues.shape.content !== undefined) {\n            actualObject.wrapper.children[0].content = newValues.shape.content;\n        }\n        else if (actualObject.shape.type === 'Image' && newValues.shape.source !== undefined) {\n            actualObject.wrapper.children[0].source = newValues.shape.source;\n        }\n        else if (actualObject.shape.type === 'Native') {\n            var nativeElement = void 0;\n            for (var i = 0; i < diagram.views.length; i++) {\n                nativeElement = (0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.getDiagramElement)(actualObject.wrapper.children[0].id + '_native_element', diagram.views[parseInt(i.toString(), 10)]);\n                if (newValues.shape.content !== undefined && nativeElement) {\n                    nativeElement.removeChild(nativeElement.children[0]);\n                    actualObject.wrapper.children[0].content = newValues.shape.content;\n                    nativeElement.appendChild((0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.getContent)(actualObject.wrapper.children[0], false));\n                }\n            }\n            actualObject.wrapper.children[0].scale = newValues.shape.scale ?\n                newValues.shape.scale : actualObject.wrapper.children[0].scale;\n        }\n        else if (actualObject.shape.type === 'HTML') {\n            var htmlElement = void 0;\n            for (var i = 0; i < diagram.views.length; i++) {\n                htmlElement = (0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.getDiagramElement)(actualObject.wrapper.children[0].id + '_html_element', diagram.views[parseInt(i.toString(), 10)]);\n                if (htmlElement) {\n                    htmlElement.removeChild(htmlElement.children[0]);\n                    actualObject.wrapper.children[0].content = newValues.shape.content;\n                    htmlElement.appendChild((0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.getContent)(actualObject.wrapper.children[0], true));\n                }\n            }\n        }\n        else if (actualObject.shape.type === 'Flow' && (newValues.shape.shape !== undefined)) {\n            actualObject.shape.shape = newValues.shape.shape;\n            var shapes = actualObject.shape.shape;\n            var flowshapedata = (0,_objects_dictionary_flow_shapes__WEBPACK_IMPORTED_MODULE_16__.getFlowShape)(shapes.toString());\n            actualObject.wrapper.children[0].data = flowshapedata;\n        }\n        else if (actualObject.shape.type === 'UmlActivity' &&\n            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)() && newValues.shape.shape !== undefined)) {\n            updateUmlActivityNode(actualObject, newValues);\n        }\n        else if (newValues.shape.cornerRadius !== undefined) {\n            actualObject.wrapper.children[0].cornerRadius = newValues.shape.cornerRadius;\n        }\n        else if (actualObject.shape.type === 'Basic' && (oldObject && oldObject.shape.shape === 'Rectangle')) {\n            var basicshape = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n            var basicshapedata = (0,_objects_dictionary_basic_shapes__WEBPACK_IMPORTED_MODULE_15__.getBasicShape)(actualObject.shape.shape);\n            basicshape.data = basicshapedata;\n            var content = basicshape;\n            updateShapeContent(content, actualObject, diagram);\n        }\n        else if (newValues.shape.shape !== undefined) {\n            actualObject.shape.shape = newValues.shape.shape;\n            var shapes = actualObject.shape.shape;\n            var basicShapeData = (0,_objects_dictionary_basic_shapes__WEBPACK_IMPORTED_MODULE_15__.getBasicShape)(shapes.toString());\n            actualObject.wrapper.children[0].data = basicShapeData;\n        }\n    }\n    actualObject.wrapper.children[0].canMeasurePath = true;\n}\n/**\n * updateUmlActivityNode method \\\n *\n * @returns {void } updateUmlActivityNode method .\\\n * @param {Node} actualObject - provide the newValues  value.\n * @param {Node} newValues - provide the actualObject  value.\n * @private\n */\nfunction updateUmlActivityNode(actualObject, newValues) {\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)()) {\n        actualObject.shape.shape = newValues.shape.shape;\n    }\n    else {\n        actualObject.shape.umlActivityShape = newValues.shape.umlActivityShape;\n    }\n    var shapes = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)() ? actualObject.shape.shape :\n        actualObject.shape.umlActivityShape;\n    var umlActivityShapeData = (0,_objects_dictionary_umlactivity_shapes__WEBPACK_IMPORTED_MODULE_26__.getUMLActivityShape)(shapes.toString());\n    if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)() && actualObject.shape.shape === 'InitialNode')) {\n        actualObject.wrapper.children[0].style.fill = 'black';\n    }\n    else if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)() && (actualObject.shape.shape === 'ForkNode' ||\n        actualObject.shape.shape === 'JoinNode'))) {\n        actualObject.wrapper.children[0].style.fill = 'black';\n    }\n    else if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.isBlazor)() && actualObject.shape.shape === 'FinalNode')) {\n        if (actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node) {\n            actualObject.wrapper = getUMLFinalNode(actualObject);\n        }\n    }\n    if (umlActivityShapeData) {\n        actualObject.wrapper.children[0].data = umlActivityShapeData;\n    }\n}\n/**\n * getUMLFinalNode method \\\n *\n * @returns {Canvas } getUMLFinalNode method .\\\n * @param {Node} node - provide the newValues  value.\n * @private\n */\nfunction getUMLFinalNode(node) {\n    var finalNodeShape = new _core_containers_canvas__WEBPACK_IMPORTED_MODULE_27__.Canvas();\n    finalNodeShape.style.fill = 'transparent';\n    //childNode0\n    var pathData = 'M 25 50 C 11.21 50 0 38.79 0 25 C 0 11.21 11.21 0 25 0 C 38.78 0 50 11.21 50 25' +\n        ' C 50 38.79 38.78 50 25 50';\n    var innerFinalNode = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n    innerFinalNode.data = pathData;\n    innerFinalNode.id = node.id + '_0_finalNode';\n    innerFinalNode.horizontalAlignment = 'Center';\n    innerFinalNode.verticalAlignment = 'Center';\n    innerFinalNode.relativeMode = 'Object';\n    innerFinalNode.style.strokeColor = node.style.strokeColor;\n    innerFinalNode.style.strokeWidth = node.style.strokeWidth;\n    //childNode1\n    var outerFinalNode = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n    outerFinalNode.data = pathData;\n    outerFinalNode.id = node.id + '_1_finalNode';\n    outerFinalNode.horizontalAlignment = 'Center';\n    outerFinalNode.verticalAlignment = 'Center';\n    outerFinalNode.relativeMode = 'Object';\n    outerFinalNode.style.fill = node.style.fill;\n    outerFinalNode.style.strokeColor = node.style.strokeColor;\n    outerFinalNode.style.strokeWidth = node.style.strokeWidth;\n    //append child and set style\n    finalNodeShape.children = [innerFinalNode, outerFinalNode];\n    finalNodeShape.children[0].width = node.width;\n    finalNodeShape.children[0].height = node.height;\n    finalNodeShape.children[1].height = node.height / 1.5;\n    finalNodeShape.children[1].width = node.width / 1.5;\n    finalNodeShape.style.strokeWidth = 0;\n    finalNodeShape.style.strokeColor = 'transparent';\n    return finalNodeShape;\n}\n/**\n * getUMLActivityShapes method \\\n *\n * @returns {DiagramElement } getUMLActivityShapes method .\\\n * @param {PathElement} umlActivityShape - provide the umlActivityShape  value.\n * @param {DiagramElement} content - provide the content  value.\n * @param {Node} node - provide the node  value.\n * @private\n */\nfunction getUMLActivityShapes(umlActivityShape, content, node) {\n    var shape = node.shape.shape;\n    var umlActivityShapeData = (0,_objects_dictionary_umlactivity_shapes__WEBPACK_IMPORTED_MODULE_26__.getUMLActivityShape)(shape);\n    umlActivityShape.data = umlActivityShapeData;\n    content = umlActivityShape;\n    switch (shape) {\n        case 'StructuredNode':\n            if (node.annotations) {\n                for (var i = 0; i < node.annotations.length; i++) {\n                    node.annotations[parseInt(i.toString(), 10)].content = '<<' + node.annotations[parseInt(i.toString(), 10)].content + '>>';\n                }\n            }\n            content = umlActivityShape;\n            break;\n        case 'FinalNode':\n            content = getUMLFinalNode(node);\n            break;\n    }\n    return content;\n}\n/**\n * removeGradient method \\\n *\n * @returns {void } removeGradient method .\\\n * @param {string} svgId - provide the umlActivityShape  value.\n * @private\n */\nfunction removeGradient(svgId) {\n    (0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.removeElement)(svgId + '_linear');\n    (0,_dom_util__WEBPACK_IMPORTED_MODULE_19__.removeElement)(svgId + '_radial');\n}\n/**\n * removeItem method \\\n *\n * @returns {void } removeItem method .\\\n * @param {string[]} array - provide the umlActivityShape  value.\n * @param {string} item - provide the umlActivityShape  value.\n * @private\n */\nfunction removeItem(array, item) {\n    var index = array.indexOf(item);\n    if (index >= 0) {\n        array.splice(index, 1);\n    }\n}\n/**\n * updateConnector method \\\n *\n * @returns {void } updateConnector method .\\\n * @param {Connector} connector - provide the connector  value.\n * @param {PointModel[]} points - provide the points  value.\n * @param {DiagramAction} diagramActions - provide the diagramActions  value.\n * @private\n */\nfunction updateConnector(connector, points, diagramActions) {\n    var anglePoint; //let srcDecorator: DecoratorModel;\n    //let targetPoint: PointModel;\n    connector.intermediatePoints = points;\n    connector.updateSegmentElement(connector, points, connector.wrapper.children[0], diagramActions);\n    var srcDecorator = connector.sourceDecorator;\n    if (connector.type === 'Bezier') {\n        var firstSegment = connector.segments[0];\n        var lastSegment = connector.segments[connector.segments.length - 1];\n        anglePoint = [!_primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.isEmptyPoint(lastSegment.point2) ? lastSegment.point2 : lastSegment.bezierPoint2,\n            !_primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.isEmptyPoint(firstSegment.point1) ? firstSegment.point1 : firstSegment.bezierPoint1];\n    }\n    else {\n        anglePoint = connector.intermediatePoints;\n    }\n    points = connector.clipDecorators(connector, points, diagramActions);\n    var element = connector.wrapper.children[0];\n    element.canMeasurePath = true;\n    element = connector.wrapper.children[1];\n    connector.updateDecoratorElement(element, points[0], anglePoint[1], srcDecorator);\n    //const targetPoint: PointModel = connector.targetPoint;\n    var tarDecorator = connector.targetDecorator;\n    element = connector.wrapper.children[2];\n    connector.updateDecoratorElement(element, points[points.length - 1], anglePoint[anglePoint.length - 2], tarDecorator);\n    connector.updateShapeElement(connector);\n}\n/**\n * getUserHandlePosition method \\\n *\n * @returns {PointModel } getUserHandlePosition method .\\\n * @param {SelectorModel} selectorItem - provide the connector  value.\n * @param {UserHandleModel} handle - provide the handle  value.\n * @param {Transforms} transform - provide the transform  value.\n * @private\n */\nfunction getUserHandlePosition(selectorItem, handle, transform) {\n    var wrapper = selectorItem.wrapper;\n    //let positionPoints: PointModel;\n    var bounds = wrapper.bounds;\n    var offset = handle.offset;\n    var size = handle.size / transform.scale;\n    var margin = handle.margin;\n    var point;\n    var left = wrapper.offsetX - wrapper.actualSize.width * wrapper.pivot.x;\n    var top = wrapper.offsetY - wrapper.actualSize.height * wrapper.pivot.y;\n    point = { x: 0, y: 0 };\n    if (selectorItem.nodes.length > 0) {\n        switch (handle.side) {\n            case 'Top':\n                point.x += left + offset * wrapper.actualSize.width;\n                point.y += top - (size);\n                break;\n            case 'Bottom':\n                point.x += left + offset * wrapper.actualSize.width;\n                point.y += top + wrapper.actualSize.height + (size);\n                break;\n            case 'Left':\n                point.x += left - (size);\n                point.y += top + offset * wrapper.actualSize.height;\n                break;\n            case 'Right':\n                point.x += left + wrapper.actualSize.width + (size);\n                point.y += top + offset * wrapper.actualSize.height;\n                break;\n        }\n        point.x += ((margin.left - margin.right) / transform.scale) +\n            (size / 2) * (handle.horizontalAlignment === 'Center' ? 0 : (handle.horizontalAlignment === 'Right' ? -1 : 1));\n        point.y += ((margin.top - margin.bottom) / transform.scale) +\n            (size / 2) * (handle.verticalAlignment === 'Center' ? 0 : (handle.verticalAlignment === 'Top' ? -1 : 1));\n    }\n    else if (selectorItem.connectors.length > 0) {\n        var connector = selectorItem.connectors[0];\n        var annotation = { offset: offset };\n        var connectorOffset = getOffsetOfConnector(connector.intermediatePoints, annotation);\n        var index = connectorOffset.index;\n        point = connectorOffset.point;\n        var getPointloop = getAnnotationPosition(connector.intermediatePoints, annotation, bounds);\n        //const points: PointModel[] = connector.intermediatePoints;\n        //const offsetLength: number;\n        var angle = getPointloop.angle;\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.identityMatrix)();\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateMatrix)(matrix, -angle, connector.intermediatePoints[parseInt(index.toString(), 10)].x, connector.intermediatePoints[parseInt(index.toString(), 10)].y);\n        point = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(matrix, point);\n        point.x += (margin.left - margin.right) +\n            (size / 2) * (handle.horizontalAlignment === 'Center' ? 0 : (handle.horizontalAlignment === 'Right' ? -1 : 1));\n        point.y += (margin.top - margin.bottom) +\n            (size / 2) * (handle.verticalAlignment === 'Center' ? 0 : (handle.verticalAlignment === 'Top' ? -1 : 1));\n        matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.identityMatrix)();\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateMatrix)(matrix, angle, connector.intermediatePoints[parseInt(index.toString(), 10)].x, connector.intermediatePoints[parseInt(index.toString(), 10)].y);\n        point = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(matrix, point);\n    }\n    if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.identityMatrix)();\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateMatrix)(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);\n        point = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(matrix, point);\n    }\n    return point;\n}\n/**\n * canResizeCorner method \\\n *\n * @returns {SelectorConstraints } canResizeCorner method .\\\n * @param {string} selectorConstraints - provide the selectorConstraints  value.\n * @param {string} action - provide the selectorConstraints  value.\n * @param {ThumbsConstraints} thumbsConstraints - provide the thumbsConstraints  value.\n * @param {Selector} selectedItems - provide the selectedItems  value.\n * @private\n */\nfunction canResizeCorner(selectorConstraints, action, thumbsConstraints, selectedItems) {\n    if (selectedItems.annotation) {\n        if ((0,_constraints_util__WEBPACK_IMPORTED_MODULE_24__.canResize)(selectedItems.annotation)) {\n            return true;\n        }\n    }\n    else if ((_enum_enum__WEBPACK_IMPORTED_MODULE_7__.SelectorConstraints[\"\" + action] & selectorConstraints) && (_enum_enum__WEBPACK_IMPORTED_MODULE_7__.ThumbsConstraints[\"\" + action] & thumbsConstraints)) {\n        return true;\n    }\n    return false;\n}\n/**\n * canShowCorner method \\\n *\n * @returns {boolean } canShowCorner method .\\\n * @param {SelectorConstraints} selectorConstraints - provide the selectorConstraints  value.\n * @param {string} action - provide the thumbsConstraints  value.\n * @private\n */\nfunction canShowCorner(selectorConstraints, action) {\n    if (_enum_enum__WEBPACK_IMPORTED_MODULE_7__.SelectorConstraints[\"\" + action] & selectorConstraints) {\n        return true;\n    }\n    return false;\n}\n/**\n * canShowControlPoints method \\\n *\n * @returns {boolean } canShowControlPoints method .\\\n * @param {ControlPointsVisibility} bezierControlPoints - provide the bezierControlPoints value.\n * @param {string} action - provide the value.\n * @private\n */\nfunction canShowControlPoints(bezierControlPoints, action) {\n    if (_enum_enum__WEBPACK_IMPORTED_MODULE_7__.ControlPointsVisibility[\"\" + action] & bezierControlPoints) {\n        return true;\n    }\n    return false;\n}\n/**\n * checkPortRestriction method \\\n *\n * @returns {number } checkPortRestriction method .\\\n * @param {PointPortModel} port - provide the port  value.\n * @param {PortVisibility} portVisibility - provide the portVisibility  value.\n * @private\n */\nfunction checkPortRestriction(port, portVisibility) {\n    return port.visibility & portVisibility;\n}\n/**\n * findAnnotation method \\\n *\n * @returns {ShapeAnnotationModel | PathAnnotationModel | TextModel } findAnnotation method .\\\n * @param { NodeModel | ConnectorModel} node - provide the port  value.\n * @param {string} id - provide the portVisibility  value.\n * @private\n */\nfunction findAnnotation(node, id) {\n    var annotation;\n    if (node.shape.type === 'Text') {\n        annotation = (node.shape);\n    }\n    else {\n        var annotationId = id.split('_');\n        id = annotationId[annotationId.length - 1];\n        for (var i = 0; i < node.annotations.length; i++) {\n            if (id === node.annotations[parseInt(i.toString(), 10)].id) {\n                annotation = node.annotations[parseInt(i.toString(), 10)];\n            }\n        }\n    }\n    return annotation;\n}\n/**\n * findPort method \\\n *\n * @returns {PointPortModel} findPort method .\\\n * @param { NodeModel | ConnectorModel} node - provide the port  value.\n * @param {string} id - provide the portVisibility  value.\n * @private\n */\nfunction findPort(node, id) {\n    var port;\n    if (id) {\n        var portId = id.split('_');\n        id = portId[portId.length - 1];\n    }\n    if (node) {\n        node = node;\n        for (var i = 0; i < node.ports.length; i++) {\n            if (id === node.ports[parseInt(i.toString(), 10)].id) {\n                return node.ports[parseInt(i.toString(), 10)];\n            }\n        }\n    }\n    return port;\n}\n/**\n * getInOutConnectPorts method \\\n *\n * @returns {PointPortModel} getInOutConnectPorts method .\\\n * @param { NodeModel} node - provide the port  value.\n * @param {boolean} isInConnect - provide the portVisibility  value.\n * @private\n */\nfunction getInOutConnectPorts(node, isInConnect) {\n    var port = {};\n    var i = 0;\n    if (node.ports) {\n        var ports = node.ports;\n        for (i = 0; i < ports.length; i++) {\n            if (isInConnect) {\n                if ((ports[parseInt(i.toString(), 10)].constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.PortConstraints.InConnect)) {\n                    port = ports[parseInt(i.toString(), 10)];\n                }\n            }\n            else {\n                if ((ports[parseInt(i.toString(), 10)].constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.PortConstraints.OutConnect)) {\n                    port = ports[parseInt(i.toString(), 10)];\n                }\n            }\n        }\n    }\n    return port;\n}\n/**\n * findObjectIndex method \\\n *\n * @returns {PointPortModel} findObjectIndex method .\\\n * @param { NodeModel | ConnectorModel} node - provide the node  value.\n * @param {string} id - provide the string  value.\n * @param {boolean} annotation - provide the boolean  value.\n * @private\n */\nfunction findObjectIndex(node, id, annotation) {\n    //let index: number;\n    var collection = (annotation) ? node.annotations : node.ports;\n    for (var i = 0; i < collection.length; i++) {\n        if (collection[parseInt(i.toString(), 10)].id === id) {\n            return (i).toString();\n        }\n    }\n    return '-1';\n}\n/**\n * findPortIndex method \\\n *\n * @returns {PointPortModel} findPortIndex method .\\\n * @param { NodeModel | ConnectorModel} node - provide the node  value.\n * @param {string} id - provide the string  value.\n * @param {boolean} port - provide the boolean  value.\n * @private\n */\nfunction findPortIndex(node, id, port) {\n    //let index: number;\n    var collection = node.ports;\n    for (var i = 0; i < collection.length; i++) {\n        if (collection[parseInt(i.toString(), 10)].id === id) {\n            return (i).toString();\n        }\n    }\n    return '-1';\n}\n/**\n * getObjectFromCollection method \\\n *\n * @returns {boolean} getObjectFromCollection method .\\\n * @param { (NodeModel | ConnectorModel)[] } obj - provide the node  value.\n * @param {string} id - provide the string  value.\n * @private\n */\nfunction getObjectFromCollection(obj, id) {\n    var i;\n    for (i = 0; i < obj.length; i++) {\n        if (id === obj[parseInt(i.toString(), 10)].id) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * scaleElement method \\\n *\n * @returns {void} scaleElement method .\\\n * @param { DiagramElement } element - provide the element  value.\n * @param {number} sw - provide the string  value.\n * @param {number} sh - provide the string  value.\n * @param {DiagramElement} refObject - provide the refObject  value.\n * @private\n */\nfunction scaleElement(element, sw, sh, refObject) {\n    if (element.width !== undefined && element.height !== undefined) {\n        element.width *= sw;\n        element.height *= sh;\n    }\n    if (element instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_4__.Container) {\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.identityMatrix)();\n        var width = refObject.width || refObject.actualSize.width;\n        var height = refObject.height || refObject.actualSize.height;\n        if (width !== undefined && height !== undefined) {\n            var x = refObject.offsetX - width * refObject.pivot.x;\n            var y = refObject.offsetY - height * refObject.pivot.y;\n            var refPoint = {\n                x: x + width * refObject.pivot.x,\n                y: y + height * refObject.pivot.y\n            };\n            refPoint = (0,_base_util__WEBPACK_IMPORTED_MODULE_20__.rotatePoint)(refObject.rotateAngle, refObject.offsetX, refObject.offsetY, refPoint);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateMatrix)(matrix, -refObject.rotateAngle, refPoint.x, refPoint.y);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.scaleMatrix)(matrix, sw, sh, refPoint.x, refPoint.y);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateMatrix)(matrix, refObject.rotateAngle, refPoint.x, refPoint.y);\n            for (var _i = 0, _a = element.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                if (child.width !== undefined && child.height !== undefined) {\n                    var newPosition = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(matrix, { x: child.offsetX, y: child.offsetY });\n                    child.offsetX = newPosition.x;\n                    child.offsetY = newPosition.y;\n                    scaleElement(child, sw, sh, refObject);\n                }\n            }\n        }\n    }\n}\n/**\n * scaleElement method \\\n *\n * @returns {void} scaleElement method .\\\n * @param { Node } obj - provide the obj  value.\n * @param {number} x - provide the x  value.\n * @param {number} y - provide the y  value.\n * @param {DiagramElement} nameTable - provide the refObject  value.\n * @param {DiagramElement} drop - provide the drop  value.\n * @param {DiagramElement} diagram - provide the diagram  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction arrangeChild(obj, x, y, nameTable, drop, diagram) {\n    var child = obj.children;\n    var node;\n    for (var i = 0; i < child.length; i++) {\n        node = nameTable[child[parseInt(i.toString(), 10)]];\n        if (node) {\n            if (node.children) {\n                arrangeChild(node, x, y, nameTable, drop, diagram);\n            }\n            else {\n                node.offsetX -= x;\n                node.offsetY -= y;\n                if (!drop) {\n                    //let content: DiagramElement;\n                    //let container: Container;\n                    nameTable[node.id] = node;\n                    var container = node.initContainer();\n                    if (!container.children) {\n                        container.children = [];\n                    }\n                    var content = node.init(diagram);\n                    container.children.push(content);\n                    container.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_0__.Size(node.width, node.height));\n                    container.arrange(container.desiredSize);\n                }\n            }\n        }\n    }\n}\n/**\n * insertObject method \\\n *\n * @returns {void} insertObject method .\\\n * @param { NodeModel | ConnectorModel } obj - provide the obj  value.\n * @param { string } key - provide the obj  value.\n * @param { Object[]} collection - provide the x  value.\n * @private\n */\nfunction insertObject(obj, key, collection) {\n    if (collection.length === 0) {\n        collection.push(obj);\n    }\n    else if (collection.length === 1) {\n        if (collection[0][\"\" + key] > obj[\"\" + key]) {\n            collection.splice(0, 0, obj);\n        }\n        else {\n            collection.push(obj);\n        }\n    }\n    else if (collection.length > 1) {\n        var low = 0;\n        var high = collection.length - 1;\n        var mid = Math.floor((low + high) / 2);\n        while (mid !== low) {\n            if (collection[parseInt(mid.toString(), 10)][\"\" + key] < obj[\"\" + key]) {\n                low = mid;\n                mid = Math.floor((low + high) / 2);\n            }\n            else if (collection[parseInt(mid.toString(), 10)][\"\" + key] > obj[\"\" + key]) {\n                high = mid;\n                mid = Math.floor((low + high) / 2);\n            }\n            else {\n                break;\n            }\n        }\n        if (collection[parseInt(high.toString(), 10)][\"\" + key] < obj[\"\" + key]) {\n            collection.push(obj);\n        }\n        else if (collection[parseInt(low.toString(), 10)][\"\" + key] > obj[\"\" + key]) {\n            collection.splice(low, 0, obj);\n        }\n        else if ((collection[parseInt(low.toString(), 10)][\"\" + key] < obj[\"\" + key]) && collection[parseInt(high.toString(), 10)][\"\" + key] > obj[\"\" + key]) {\n            collection.splice(high, 0, obj);\n        }\n    }\n}\n/**\n * getElement method \\\n *\n * @returns {Object} getElement method .\\\n * @param { DiagramHtmlElement | DiagramNativeElement } element - provide the obj  value.\n * @private\n */\nfunction getElement(element) {\n    var diagramElement = document.getElementById(element.diagramId);\n    var instance = 'ej2_instances';\n    // eslint-disable-next-line\n    var node = {};\n    var nodes = diagramElement[\"\" + instance][0].nodes;\n    if (nodes === undefined) {\n        nodes = getPaletteSymbols(diagramElement[\"\" + instance][0]);\n    }\n    var length = 'length';\n    for (var i = 0; nodes && i < nodes[\"\" + length]; i++) {\n        if (nodes[parseInt(i.toString(), 10)].id === element.nodeId) {\n            return getAnnotation(nodes[parseInt(i.toString(), 10)], element);\n        }\n    }\n    var connectors = diagramElement[\"\" + instance][0].connectors;\n    for (var i = 0; connectors && i < connectors[\"\" + length]; i++) {\n        if (connectors[parseInt(i.toString(), 10)].id === element.nodeId) {\n            return getAnnotation(connectors[parseInt(i.toString(), 10)], element);\n        }\n    }\n    // eslint-disable-next-line\n    var enterObject = diagramElement[instance][0].enterObject;\n    if (enterObject && (enterObject['id'] === element.nodeId || enterObject['children'])) {\n        if (enterObject['children'] && groupHasType(enterObject, 'HTML', diagramElement[\"\" + instance][0].enterTable)) {\n            return diagramElement[\"\" + instance][0].enterTable[element.nodeId];\n        }\n        else {\n            return enterObject;\n        }\n    }\n    return null;\n}\n/**\n * getAnnotation method \\\n *\n * @returns {Object} getAnnotation method .\\\n * @param { Object } obj - provide the obj  value.\n * @param {  DiagramHtmlElement | DiagramNativeElement } element - provide the obj  value.\n * @private\n */\nfunction getAnnotation(obj, element) {\n    var annotations = obj.annotations;\n    var length = 'length';\n    var j;\n    for (j = 0; annotations && j < annotations[\"\" + length]; j++) {\n        if (element.annotationId\n            && annotations[parseInt(j.toString(), 10)].id === element.annotationId) {\n            return annotations[parseInt(j.toString(), 10)];\n        }\n    }\n    return obj;\n}\n/**\n * getPaletteSymbols method \\\n *\n * @returns {NodeModel[]} getPaletteSymbols method .\\\n * @param { Object } symbolPalette - provide the symbolPalette  value.\n * @private\n */\nfunction getPaletteSymbols(symbolPalette) {\n    var nodes = [];\n    for (var i = 0; i < symbolPalette.palettes.length; i++) {\n        var symbols = symbolPalette.palettes[parseInt(i.toString(), 10)].symbols;\n        for (var j = 0; j < symbols.length; j++) {\n            if (symbols[parseInt(j.toString(), 10)] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node) {\n                nodes.push(symbols[parseInt(j.toString(), 10)]);\n            }\n        }\n    }\n    return nodes;\n}\n/**\n * getCollectionChangeEventArguements method \\\n *\n * @returns {IBlazorCollectionChangeEventArgs} getCollectionChangeEventArguements method .\\\n * @param { IBlazorCollectionChangeEventArgs } args1 - provide the args1  value.\n * @param { NodeModel | ConnectorModel } obj - provide the obj  value.\n * @param { EventState } state - provide the state  value.\n * @param { ChangeType } type - provide the type  value.\n * @private\n */\nfunction getCollectionChangeEventArguements(args1, obj, state, type) {\n    //Removed isBlazor code\n    return args1;\n}\n/**\n * getDropEventArguements method \\\n *\n * @returns {IBlazorDropEventArgs} getDropEventArguements method .\\\n * @param { MouseEventArgs } args - provide the args1  value.\n * @param { IBlazorDropEventArgs } arg - provide the obj  value.\n * @private\n */\nfunction getDropEventArguements(args, arg) {\n    //Removed isBlazor code\n    return arg;\n}\n/**\n * getPoint method \\\n *\n * @returns {PointModel} getPoint method .\\\n * @param { number } x - provide the x  value.\n * @param { number } y - provide the y  value.\n * @param { number } w - provide the w  value.\n * @param { number } h - provide the y  value.\n * @param { number } angle - provide the y  value.\n * @param { number } offsetX - provide the y  value.\n * @param { number } offsetY - provide the y  value.\n * @param { PointModel } cornerPoint - provide the y  value.\n * @private\n */\nfunction getPoint(x, y, w, h, angle, offsetX, offsetY, cornerPoint) {\n    var pivot = { x: 0, y: 0 };\n    var trans = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.identityMatrix)();\n    (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.rotateMatrix)(trans, angle, offsetX, offsetY);\n    switch (cornerPoint.x) {\n        case 0:\n            switch (cornerPoint.y) {\n                case 0:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x, y: y }));\n                    break;\n                case 0.5:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x, y: y + h / 2 }));\n                    break;\n                case 1:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x, y: y + h }));\n                    break;\n            }\n            break;\n        case 0.5:\n            switch (cornerPoint.y) {\n                case 0:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x + w / 2, y: y }));\n                    break;\n                case 0.5:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x + w / 2, y: y + h / 2 }));\n                    break;\n                case 1:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x + w / 2, y: y + h }));\n                    break;\n            }\n            break;\n        case 1:\n            switch (cornerPoint.y) {\n                case 0:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x + w, y: y }));\n                    break;\n                case 0.5:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x + w, y: y + h / 2 }));\n                    break;\n                case 1:\n                    pivot = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_2__.transformPointByMatrix)(trans, ({ x: x + w, y: y + h }));\n                    break;\n            }\n            break;\n    }\n    return { x: pivot.x, y: pivot.y };\n}\n/* eslint-disable */\n/**\n * Get the object as Node | Connector \\\n *\n * @returns {Object} Get the object as Node | Connector .\\\n * @param { number } obj - provide the x  value.\n * @private\n */\nvar getObjectType = function (obj) {\n    if (obj) {\n        if (obj.sourceID !== undefined || obj.sourcePoint !== undefined ||\n            obj.targetID !== undefined || obj.targetPoint !== undefined ||\n            obj.type !== undefined) {\n            obj = _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector;\n        }\n        else {\n            obj = _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node;\n        }\n    }\n    return obj;\n};\n/** @private */\nvar flipConnector = function (connector) {\n    if (!connector.sourceID && !connector.targetID) {\n        var source = { x: connector.sourcePoint.x, y: connector.sourcePoint.y };\n        var target = { x: connector.targetPoint.x, y: connector.targetPoint.y };\n        if (connector.flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Horizontal) {\n            connector.sourcePoint.x = target.x;\n            connector.targetPoint.x = source.x;\n        }\n        else if (connector.flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Vertical) {\n            connector.sourcePoint.y = target.y;\n            connector.targetPoint.y = source.y;\n        }\n        else if (connector.flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Both) {\n            connector.sourcePoint = target;\n            connector.targetPoint = source;\n        }\n    }\n};\n/** @private */\nvar updatePortEdges = function (portContent, flip, port) {\n    var offsetX = port.offset.x;\n    var offsetY = port.offset.y;\n    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Horizontal) {\n        offsetX = 1 - port.offset.x;\n        offsetY = port.offset.y;\n    }\n    else if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Vertical) {\n        offsetX = port.offset.x;\n        offsetY = 1 - port.offset.y;\n    }\n    else if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Both) {\n        offsetX = 1 - port.offset.x;\n        offsetY = 1 - port.offset.y;\n    }\n    portContent.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');\n    return portContent;\n};\n/** @private */\nvar alignElement = function (element, offsetX, offsetY, diagram, flip, isHorizontal, isVertical, isInitialRendering) {\n    if (element.hasChildren()) {\n        for (var _i = 0, _a = element.children; _i < _a.length; _i++) {\n            var child = _a[_i];\n            var nodeObj = void 0;\n            if (child instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_27__.Canvas) {\n                nodeObj = diagram.nameTable[child.id];\n                if (nodeObj) {\n                    if (isHorizontal) {\n                        nodeObj.flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Horizontal;\n                    }\n                    if (isVertical) {\n                        nodeObj.flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Vertical;\n                    }\n                }\n            }\n            var childX = ((offsetX - child.offsetX) + offsetX);\n            var childY = ((offsetY - child.offsetY) + offsetY);\n            if (!(child instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_10__.TextElement)) {\n                if (!(child.elementActions & _enum_enum__WEBPACK_IMPORTED_MODULE_7__.ElementAction.ElementIsPort)) {\n                    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Horizontal || isHorizontal) {\n                        child.offsetX = childX;\n                        if (nodeObj) {\n                            nodeObj.offsetX = childX;\n                        }\n                        child.flipOffset.x = childX - child.desiredSize.width / 2;\n                    }\n                    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Vertical || isVertical) {\n                        child.offsetY = childY;\n                        if (nodeObj) {\n                            nodeObj.offsetY = childY;\n                        }\n                        child.flipOffset.y = childY - child.desiredSize.height / 2;\n                    }\n                    else if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Both) {\n                        child.offsetX = childX;\n                        child.flipOffset.x = childX - child.desiredSize.width / 2;\n                        child.offsetY = childY;\n                        child.flipOffset.y = childY - child.desiredSize.height / 2;\n                        if (nodeObj) {\n                            nodeObj.offsetX = childX;\n                            nodeObj.offsetY = childY;\n                        }\n                    }\n                }\n            }\n            if (!isInitialRendering) {\n                if (child instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_27__.Canvas || child instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_4__.Container) {\n                    if (isHorizontal) {\n                        child.flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Horizontal;\n                    }\n                    if (isVertical) {\n                        child.flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Vertical;\n                    }\n                    if (!child.id.includes('group_container') && child.children) {\n                        if (isHorizontal) {\n                            child.children[0].flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Horizontal;\n                        }\n                        if (isVertical) {\n                            child.children[0].flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_7__.FlipDirection.Vertical;\n                        }\n                    }\n                    alignElement(child, offsetX, offsetY, diagram, flip, isHorizontal, isVertical, isInitialRendering);\n                }\n            }\n            child.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_0__.Size(child.bounds.width, child.bounds.height));\n            child.arrange(child.desiredSize);\n            var node = diagram.nameTable[child.id];\n            if (node) {\n                diagram.updateConnectorEdges(node);\n            }\n        }\n    }\n};\n/** @private */\nvar cloneSelectedObjects = function (diagram) {\n    var nodes = diagram.selectedItems.nodes;\n    var connectors = diagram.selectedItems.connectors;\n    var isProtectedOnChange = 'isProtectedOnChange';\n    var isEnableServerDatabind = diagram.allowServerDataBinding;\n    var isProtectedOnChangeValue = diagram[isProtectedOnChange];\n    diagram.protectPropertyChange(true);\n    diagram.allowServerDataBinding = false;\n    diagram.selectedItems.nodes = [];\n    diagram.selectedItems.connectors = [];\n    diagram.allowServerDataBinding = isEnableServerDatabind;\n    diagram.protectPropertyChange(isProtectedOnChangeValue);\n    var clonedSelectedItems = (0,_base_util__WEBPACK_IMPORTED_MODULE_20__.cloneObject)(diagram.selectedItems);\n    for (var i = 0; i < nodes.length; i++) {\n        diagram.selectedItems.nodes.push(diagram.nameTable[nodes[i].id]);\n    }\n    for (var i = 0; i < connectors.length; i++) {\n        diagram.selectedItems.connectors.push(diagram.nameTable[connectors[i].id]);\n    }\n    return clonedSelectedItems;\n};\n/** @private */\nvar updatePathElement = function (anglePoints, connector) {\n    var pathElement = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_8__.PathElement();\n    var pathseqData;\n    for (var j = 0; j < anglePoints.length - 1; j++) {\n        pathseqData = findPath(anglePoints[j], anglePoints[j + 1]);\n        pathElement.data = pathseqData[0];\n        pathElement.id = connector.id + '_' + (connector.shape.sequence);\n        //Bug 860251: Bpmn message flow and sequence flow connector child path is not rendered properly.\n        //To get the offset of default sequence path.\n        var pathOffset = getPathOffset(anglePoints, connector);\n        pathElement.offsetX = pathOffset.x;\n        pathElement.offsetY = pathOffset.y;\n        pathElement.rotateAngle = 45;\n        pathElement.transform = _enum_enum__WEBPACK_IMPORTED_MODULE_7__.Transform.Self;\n        break;\n    }\n    return pathElement;\n};\n/** @private */\nvar getPathOffset = function (anglePoints, connector, segmentOffset) {\n    var offsetDistance = 10; // Distance from the source point\n    var angle;\n    var pt;\n    var totalLength = 0;\n    // Calculate total length of the path\n    for (var i_1 = 0; i_1 < anglePoints.length - 1; i_1++) {\n        totalLength += findDistance(anglePoints[parseInt(i_1.toString(), 10)], anglePoints[i_1 + 1]);\n    }\n    var targetLength;\n    if (segmentOffset) {\n        targetLength = totalLength * segmentOffset;\n    }\n    else {\n        targetLength = (totalLength / 2) > 30 ? offsetDistance : (totalLength / 2);\n    }\n    // Find the segment where the position lies\n    var accumulatedLength = 0;\n    for (var i = 0; i < anglePoints.length - 1; i++) {\n        var segmentLength = findDistance(anglePoints[parseInt(i.toString(), 10)], anglePoints[i + 1]);\n        if (accumulatedLength + segmentLength >= targetLength) {\n            var remainingLength = targetLength - accumulatedLength;\n            angle = (0,_connector__WEBPACK_IMPORTED_MODULE_18__.findAngle)(anglePoints[i], anglePoints[i + 1]);\n            pt = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform(anglePoints[i], angle, remainingLength);\n            break;\n        }\n        accumulatedLength += segmentLength;\n    }\n    return pt;\n};\n/** @private */\nvar checkPort = function (node, element) {\n    if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_13__.Node || node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_14__.Connector) {\n        for (var i = 0; i < node.ports.length; i++) {\n            if (node.ports[i].id === element.id.split('_').splice(1).join('_')) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n/** @private */\nvar findPath = function (sourcePoint, targetPoint) {\n    var beginningpoint = { x: sourcePoint.x, y: sourcePoint.y };\n    var distance = findDistance(sourcePoint, targetPoint);\n    distance = Math.min(10, distance / 2);\n    var angle = (0,_connector__WEBPACK_IMPORTED_MODULE_18__.findAngle)(sourcePoint, targetPoint);\n    var transferpt = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform({ x: beginningpoint.x, y: beginningpoint.y }, angle, distance);\n    var startpoint = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform({ x: transferpt.x, y: transferpt.y }, angle, -11);\n    var endpoint = _primitives_point__WEBPACK_IMPORTED_MODULE_6__.Point.transform({ x: startpoint.x, y: startpoint.y }, angle, 11 * 2);\n    var path = 'M' + startpoint.x + ' ' + startpoint.y + ' L' + endpoint.x + ' ' + endpoint.y;\n    return [path, transferpt];\n};\n/** @private */\nvar getConnectorDirection = function (src, tar) {\n    if (Math.abs(tar.x - src.x) > Math.abs(tar.y - src.y)) {\n        return src.x < tar.x ? 'Right' : 'Left';\n    }\n    else {\n        return src.y < tar.y ? 'Bottom' : 'Top';\n    }\n};\n/** @private */\nvar findDistance = function (point1, point2) {\n    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\n/* eslint-enable */\n/**\n * cloneBlazorObject method \\\n *\n * @returns {Object} cloneBlazorObject method .\\\n * @param { object } args - provide the args  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction cloneBlazorObject(args) {\n    //Removed isBlazor code\n    return args;\n}\n/**\n * checkBrowserInfo method \\\n *\n * @returns {Object} checkBrowserInfo method .\\\n * @private\n */\nfunction checkBrowserInfo() {\n    if ((navigator.platform.indexOf('Mac') >= 0 || navigator.platform.indexOf('iPad') >= 0\n        || navigator.platform.indexOf('iPhone') >= 0 || navigator.platform.indexOf('MacIntel') >= 0)\n        && (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.Browser.info.name === 'safari' || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_31__.Browser.info.name === 'webkit')) {\n        return true;\n    }\n    return false;\n}\n/**\n * canMeasureDecoratorPath method \\\n *\n * @returns {boolean} canMeasureDecoratorPath method .\\\n * @param { string[] } objects - provide the args  value.\n * @private\n */\nfunction canMeasureDecoratorPath(objects) {\n    if (objects.indexOf('shape') !== -1 || objects.indexOf('pathData') !== -1 ||\n        objects.indexOf('width') !== -1 || objects.indexOf('height') !== -1) {\n        return true;\n    }\n    return false;\n}\n/**\n * getPreviewSize method \\\n *\n * @returns {Size} getPreviewSize method .\\\n * @param { SymbolPaletteModel } sourceElement - provide the args  value.\n * @param { Node } clonedObject - provide the args  value.\n * @param { DiagramElement } wrapper - provide the args  value.\n * @private\n */\nfunction getPreviewSize(sourceElement, clonedObject, wrapper) {\n    //let previewWidth: number;\n    //let previewHeight: number;\n    var previewWidth = getSymbolSize(sourceElement, clonedObject, wrapper, 'width');\n    var previewHeight = getSymbolSize(sourceElement, clonedObject, wrapper, 'height');\n    return new _primitives_size__WEBPACK_IMPORTED_MODULE_0__.Size(previewWidth, previewHeight);\n}\n/**\n * getSymbolSize method \\\n *\n * @returns {number} getSymbolSize method .\\\n * @param { SymbolPaletteModel } sourceElement - provide the sourceElement  value.\n * @param { Node } clonedObject - provide the clonedObject  value.\n * @param { DiagramElement } wrapper - provide the wrapper  value.\n * @param { string } size - provide the size  value.\n * @private\n */\nfunction getSymbolSize(sourceElement, clonedObject, wrapper, size) {\n    var previewSize = 0;\n    if (clonedObject.previewSize[\"\" + size] !== undefined) {\n        previewSize = clonedObject.previewSize[\"\" + size];\n    }\n    else if (sourceElement.symbolPreview[\"\" + size] !== undefined) {\n        previewSize = sourceElement.symbolPreview[\"\" + size];\n    }\n    else {\n        previewSize = clonedObject[\"\" + size] || wrapper.actualSize[\"\" + size];\n    }\n    return previewSize;\n}\n/**\n * findParent method \\\n *\n * @returns {string} findParent method .\\\n * @param { Node } node - provide the clonedObject  value.\n * @param { Diagram } diagram - provide the diagram  element.\n * @param { string } parent - provide the parent id.\n * @private\n */\nfunction findParentInSwimlane(node, diagram, parent) {\n    if (node && node.parentId) {\n        node = diagram.nameTable[node.parentId];\n        if (node.parentId) {\n            parent = findParentInSwimlane(node, diagram, parent);\n        }\n        else {\n            parent = node.id;\n        }\n    }\n    return parent;\n}\n/**\n * selectionHasConnector method \\\n *\n * @returns {boolean} selectionHasConnector method .\\\n * @param { Diagram } diagram - provide the diagram  element.\n * @param { selector } selector - provide the selector element.\n * @private\n */\nfunction selectionHasConnector(diagram, selector) {\n    if (diagram.selectedItems.connectors.length > 1 && diagram.selectedItems.nodes.length === 0 && selector.rotateAngle !== 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * To Get connector style based on the arrow type\n * @param {FlowChartData} data - provide the flow chart data.\n * @returns {ArrowStyle} - Connector style\n */\nfunction getConnectorArrowType(data) {\n    if (data.arrowType && data.arrowType.trim() !== '') {\n        switch (data.arrowType) {\n            case 'single-line-arrow':\n                return { targetDecorator: 'Arrow', strokeWidth: 1 };\n            case 'double-line-arrow':\n                return { targetDecorator: 'Arrow', strokeWidth: 2 };\n            case 'dotted-arrow':\n                return { targetDecorator: 'Arrow', strokeDashArray: '2,2' };\n            case 'single-line':\n                return { targetDecorator: 'None', strokeWidth: 1 };\n            case 'double-line':\n                return { targetDecorator: 'None', strokeWidth: 2 };\n            case 'dotted':\n                return { targetDecorator: 'None', strokeDashArray: '2,2' };\n            case 'wiggly-arrow':\n                return { targetDecorator: 'None', strokeWidth: 1, opacity: 0 };\n            default:\n                return { targetDecorator: 'Arrow', strokeWidth: 1 };\n        }\n    }\n    return { targetDecorator: 'Arrow', strokeWidth: 1 };\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js?");

/***/ })

}]);