"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_layout_flowChart_matrix-model_js-7dcc-b8db2812"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/matrix-model.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/matrix-model.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MatrixModel: () => (/* binding */ MatrixModel)\n/* harmony export */ });\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n\nvar MatrixModel = /** @class */ (function () {\n    function MatrixModel(model) {\n        this.flowchartModel = model;\n        this.matrix = [];\n        this.rowOffset = [];\n        this.rowMaxDimension = [];\n        this.siblingModel = null;\n    }\n    /**\n     * @private\n     * @returns {void} - Arranges the elements in the flowchart layout\n     */\n    MatrixModel.prototype.arrangeElements = function () {\n        if (this.flowchartModel === null) {\n            return;\n        }\n        var layoutSettings = this.flowchartModel.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        this.groupLayoutCells();\n        this.createMatrixCells();\n        for (var _i = 0, _a = this.matrix; _i < _a.length; _i++) {\n            var matrixRow = _a[_i];\n            for (var i = 1; i < matrixRow.length; i++) {\n                var cell = matrixRow[parseInt(i.toString(), 10)];\n                var prevCell = matrixRow[i - 1];\n                cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n            }\n        }\n        for (var _b = 0, _c = this.matrix[0]; _b < _c.length; _b++) {\n            var root = _c[_b];\n            this.arrangeMatrix(root, null);\n        }\n        for (var _d = 0, _e = this.matrix; _d < _e.length; _d++) {\n            var row = _e[_d];\n            for (var i = 0; i < row.length; i++) {\n                var cell = row[parseInt(i.toString(), 10)];\n                if (cell.visitedParents.length > 1) {\n                    var firstParent = cell.visitedParents[0];\n                    var lastParent = cell.visitedParents[cell.visitedParents.length - 1];\n                    var firstVertexParent = this.findParentVertexCellGroup(firstParent);\n                    var lastVertexParent = this.findParentVertexCellGroup(lastParent);\n                    if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {\n                        firstParent = firstVertexParent;\n                    }\n                    if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {\n                        lastParent = firstVertexParent;\n                    }\n                    var newOffset = (firstParent.offset + lastParent.offset) / 2;\n                    var interVertex = cell.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });\n                    if (this.flowchartModel.layout.yesBranchDirection === 'SameAsFlow') {\n                        var tempVisitedParents = cell.visitedParents.slice();\n                        if (interVertex && interVertex.cell.isYesChild) {\n                            for (var _f = 0, tempVisitedParents_1 = tempVisitedParents; _f < tempVisitedParents_1.length; _f++) {\n                                var tempParent = tempVisitedParents_1[_f];\n                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });\n                                if (!tempParentVertex) {\n                                    newOffset = tempParent.offset;\n                                    break;\n                                }\n                            }\n                        }\n                        else {\n                            if (this.flowchartModel.layout.noBranchDirection === 'LeftInFlow') {\n                                tempVisitedParents.reverse();\n                            }\n                            for (var _g = 0, tempVisitedParents_2 = tempVisitedParents; _g < tempVisitedParents_2.length; _g++) {\n                                var tempParent = tempVisitedParents_2[_g];\n                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });\n                                if (tempParentVertex) {\n                                    if (tempParentVertex.cell.isYesChild) {\n                                        newOffset = tempParent.offset;\n                                        break;\n                                    }\n                                }\n                                else {\n                                    var tempSuperParent = this.findParentVertexCellGroup(tempParent);\n                                    if (tempSuperParent) {\n                                        var superParentVertex = tempSuperParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });\n                                        if (superParentVertex && superParentVertex.cell.isYesChild) {\n                                            newOffset = tempParent.offset;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if (this.flowchartModel.layout.noBranchDirection === 'SameAsFlow') {\n                        var tempVisitedParents = cell.visitedParents.slice();\n                        if (interVertex && interVertex.cell.isNoChild) {\n                            for (var _h = 0, tempVisitedParents_3 = tempVisitedParents; _h < tempVisitedParents_3.length; _h++) {\n                                var tempParent = tempVisitedParents_3[_h];\n                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });\n                                if (!tempParentVertex) {\n                                    newOffset = tempParent.offset;\n                                    break;\n                                }\n                            }\n                        }\n                        else {\n                            if (this.flowchartModel.layout.yesBranchDirection === 'LeftInFlow') {\n                                tempVisitedParents.reverse();\n                            }\n                            for (var _j = 0, tempVisitedParents_4 = tempVisitedParents; _j < tempVisitedParents_4.length; _j++) {\n                                var tempParent = tempVisitedParents_4[_j];\n                                var tempParentVertex = tempParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });\n                                if (tempParentVertex) {\n                                    if (tempParentVertex.cell.isNoChild) {\n                                        newOffset = tempParent.offset;\n                                        break;\n                                    }\n                                }\n                                else {\n                                    var tempSuperParent = this.findParentVertexCellGroup(tempParent);\n                                    if (tempSuperParent) {\n                                        var superParentVertex = tempSuperParent.cells.find(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; });\n                                        if (superParentVertex && superParentVertex.cell.isNoChild) {\n                                            newOffset = tempParent.offset;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    var availOffsetMin = cell.initialOffset;\n                    var availOffsetMax = cell.offset;\n                    if (availOffsetMax !== availOffsetMin) {\n                        if (newOffset >= availOffsetMin && newOffset <= availOffsetMax) {\n                            this.translateMatrixCells(newOffset - cell.offset, cell);\n                        }\n                        else if (newOffset < availOffsetMin) {\n                            this.translateMatrixCells(availOffsetMin - cell.offset, cell);\n                        }\n                    }\n                }\n            }\n        }\n        this.setXYForMatrixCell();\n    };\n    MatrixModel.prototype.arrangeMatrix = function (cell, parent) {\n        var layoutSettings = this.flowchartModel.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var matrixRow = this.matrix[cell.level];\n        var matrixIndex = matrixRow.indexOf(cell);\n        if (cell.visitedParents.length) {\n            if (cell.visitedParents.length === 1) {\n                cell.initialOffset = cell.offset;\n            }\n            if (matrixIndex + 1 < matrixRow.length) {\n                var nextCell = matrixRow[matrixIndex + 1];\n                if (nextCell.visitedParents.length) {\n                    if (cell.visitedParents.indexOf(parent) === -1) {\n                        if (cell.level !== parent.level) {\n                            cell.visitedParents.push(parent);\n                            parent.ignoredChildren.push(cell);\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n        if (!cell.children.length) {\n            var validOffset = cell.offset;\n            if (matrixIndex > 0) {\n                var prevCell = matrixRow[matrixIndex - 1];\n                validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n            }\n            this.shiftMatrixCells(validOffset - cell.offset, cell);\n        }\n        else {\n            for (var _i = 0, _a = cell.children; _i < _a.length; _i++) {\n                var matrixCellChild = _a[_i];\n                if (cell.visitedChildren.indexOf(matrixCellChild)) {\n                    this.arrangeMatrix(matrixCellChild, cell);\n                    if (cell.level !== matrixCellChild.level) {\n                        cell.visitedChildren.push(matrixCellChild);\n                    }\n                    else {\n                        cell.loopChildren.push(matrixCellChild);\n                    }\n                }\n            }\n            if (cell.visitedChildren.length) {\n                var children = cell.visitedChildren.slice();\n                var _loop_1 = function (cellIgnoredChild) {\n                    children = children.filter(function (child) { return child !== cellIgnoredChild; });\n                };\n                for (var _b = 0, _c = cell.ignoredChildren; _b < _c.length; _b++) {\n                    var cellIgnoredChild = _c[_b];\n                    _loop_1(cellIgnoredChild);\n                }\n                if (children.length) {\n                    var firstChild = children[0];\n                    var lastChild = children[children.length - 1];\n                    var x1 = firstChild.offset;\n                    var x2 = lastChild.offset;\n                    var newOffset = (x1 + x2) / 2;\n                    if (cell.cells.length) {\n                        var interVertex = cell.cells.filter(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })[0];\n                        var firstChildVertex = firstChild.cells.filter(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })[0];\n                        var lastChildVertex = lastChild.cells.filter(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })[0];\n                        if (interVertex && interVertex.cell.isDecisionNode) {\n                            if (this.flowchartModel.layout.yesBranchDirection === 'SameAsFlow') {\n                                if (firstChildVertex) {\n                                    newOffset = firstChildVertex.cell.isYesChild ? firstChild.offset : lastChild.offset;\n                                }\n                                else if (lastChildVertex) {\n                                    newOffset = lastChildVertex.cell.isYesChild ? lastChild.offset : firstChild.offset;\n                                }\n                            }\n                            else if (this.flowchartModel.layout.noBranchDirection === 'SameAsFlow') {\n                                if (firstChildVertex) {\n                                    newOffset = firstChildVertex.cell.isNoChild ? firstChild.offset : lastChild.offset;\n                                }\n                                else if (lastChildVertex) {\n                                    newOffset = lastChildVertex.cell.isNoChild ? lastChild.offset : firstChild.offset;\n                                }\n                            }\n                        }\n                    }\n                    if (newOffset < cell.offset) {\n                        this.shiftMatrixCells(cell.offset - newOffset, firstChild, true, cell);\n                    }\n                    else if (newOffset > cell.offset) {\n                        this.shiftMatrixCells(newOffset - cell.offset, cell);\n                    }\n                }\n            }\n        }\n        if (cell.visitedParents.indexOf(parent) === -1) {\n            if (parent !== null && cell.level !== parent.level) {\n                cell.visitedParents.push(parent);\n            }\n        }\n    };\n    MatrixModel.prototype.shiftMatrixCells = function (value, startingCell, shiftChildren, parentCell) {\n        if (shiftChildren === void 0) { shiftChildren = false; }\n        if (parentCell === void 0) { parentCell = null; }\n        if (value !== 0) {\n            var matrixRow = this.matrix[startingCell.level];\n            var index = matrixRow.indexOf(startingCell);\n            for (var i = index; i < matrixRow.length; i++) {\n                matrixRow[parseInt(i.toString(), 10)].offset += value;\n            }\n            if (shiftChildren) {\n                if (startingCell.visitedChildren.length) {\n                    this.shiftMatrixCells(value, startingCell.visitedChildren[0], true, startingCell);\n                }\n                else {\n                    var i = 1;\n                    var nextSiblingWithChild = null;\n                    while (index + i < matrixRow.length) {\n                        var nextCell = matrixRow[index + i];\n                        if (parentCell !== null && nextCell.visitedParents.indexOf(parentCell) !== -1) {\n                            if (nextCell.visitedChildren.length) {\n                                nextSiblingWithChild = nextCell;\n                            }\n                            else {\n                                i++;\n                                continue;\n                            }\n                        }\n                        break;\n                    }\n                    if (nextSiblingWithChild !== null) {\n                        this.shiftMatrixCells(value, nextSiblingWithChild.visitedChildren[0], true, nextSiblingWithChild);\n                    }\n                }\n            }\n        }\n    };\n    MatrixModel.prototype.findParentVertexCellGroup = function (cell) {\n        if ('internalInEdges' in cell.cells[0] && 'internalOutEdges' in cell.cells[0]) {\n            return cell;\n        }\n        if (cell.parents.length) {\n            return this.findParentVertexCellGroup(cell.parents[0]);\n        }\n        return cell;\n    };\n    MatrixModel.prototype.translateMatrixCells = function (value, cell) {\n        if (value !== 0) {\n            cell.offset += value;\n            if (cell.visitedChildren.length) {\n                for (var _i = 0, _a = cell.visitedChildren; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    this.translateMatrixCells(value, child);\n                }\n                for (var _b = 0, _c = cell.loopChildren; _b < _c.length; _b++) {\n                    var loopChild = _c[_b];\n                    this.translateMatrixCells(value, loopChild);\n                }\n            }\n        }\n    };\n    MatrixModel.prototype.getObjectValues = function (obj) {\n        var values = [];\n        for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                values.push(obj[\"\" + key]);\n            }\n        }\n        return values;\n    };\n    MatrixModel.prototype.setXYForMatrixCell = function () {\n        var layoutSettings = this.flowchartModel.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var siblingSize = 0;\n        if (this.siblingModel) {\n            var rowMaxValues = this.getObjectValues(this.rowMaxDimension);\n            var maxRowValue = Math.max.apply(Math, rowMaxValues);\n            siblingSize = this.siblingModel.getSiblingDimension(maxRowValue);\n        }\n        for (var _i = 0, _a = this.getObjectValues(this.matrix); _i < _a.length; _i++) {\n            var matrixRow1 = _a[_i];\n            for (var _b = 0, matrixRow1_1 = matrixRow1; _b < matrixRow1_1.length; _b++) {\n                var matrixCell = matrixRow1_1[_b];\n                var start = matrixCell.offset - (matrixCell.size / 2);\n                if (siblingSize !== 0) {\n                    start += siblingSize + spacing;\n                }\n                for (var _c = 0, _d = matrixCell.cells; _c < _d.length; _c++) {\n                    var cell = _d[_c];\n                    if ('internalInEdges' in cell && 'internalOutEdges' in cell) {\n                        var internalVertex = cell;\n                        var width = internalVertex.cell.geometry.width;\n                        var height = internalVertex.cell.geometry.height;\n                        if (isHorizontal) {\n                            internalVertex.cell.geometry = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(this.rowOffset[matrixCell.level] - (width / 2), start, width, height);\n                        }\n                        else {\n                            internalVertex.cell.geometry = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(start, this.rowOffset[matrixCell.level] - (height / 2), width, height);\n                        }\n                        start += (isHorizontal ? height : width) + spacing;\n                    }\n                    else if ('edges' in cell) {\n                        var internalEdges = cell;\n                        var isContainSiblingVertex = internalEdges.isReversed;\n                        if (!isContainSiblingVertex) {\n                            var parent_1 = matrixCell.visitedParents[0];\n                            if (parent_1) {\n                                for (var _e = 0, _f = parent_1.visitedChildren; _e < _f.length; _e++) {\n                                    var child = _f[_e];\n                                    if (child.cells.some(function (c) { return 'internalInEdges' in c && 'internalOutEdges' in c; })) {\n                                        isContainSiblingVertex = true;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        var lineWidth = 1;\n                        var edgeSpacing = 5;\n                        for (var _g = 0, _h = internalEdges.edges; _g < _h.length; _g++) {\n                            var internalConnector = _h[_g];\n                            if (isContainSiblingVertex) {\n                                var pt = { x: start + (lineWidth / 2.0), y: this.rowOffset[matrixCell.level] };\n                                if (isHorizontal) {\n                                    pt = { x: this.rowOffset[matrixCell.level], y: start + (lineWidth / 2.0) };\n                                }\n                                if (this.flowchartModel.layout.edgesMapper.has(internalConnector)) {\n                                    this.flowchartModel.layout.edgesMapper.get(internalConnector).push(pt);\n                                    this.flowchartModel.layout.loopedgesMapper.set(internalConnector, internalEdges.isReversed);\n                                }\n                            }\n                            start += lineWidth + edgeSpacing;\n                        }\n                        start += spacing;\n                    }\n                }\n            }\n        }\n    };\n    MatrixModel.prototype.getSiblingDimension = function (maxHeight) {\n        var layoutSettings = this.flowchartModel.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight';\n        var spacing = isHorizontal ? layoutSettings.horizontalSpacing : layoutSettings.verticalSpacing;\n        var commonRowIndex = 0;\n        for (var key in this.rowMaxDimension) {\n            if (Object.prototype.hasOwnProperty.call(this.rowMaxDimension, key)) {\n                var value = this.rowMaxDimension[\"\" + key];\n                if (value < maxHeight) {\n                    commonRowIndex = parseInt(key, 10);\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        if (this.rowMaxDimension[parseInt(commonRowIndex.toString(), 10)] + spacing <= maxHeight\n            && this.rowMaxDimension[commonRowIndex + 1]) {\n            commonRowIndex++;\n        }\n        var commonRows = [];\n        for (var key in this.matrix) {\n            if (Object.prototype.hasOwnProperty.call(this.matrix, key) && parseInt(key, 10) <= commonRowIndex) {\n                commonRows[\"\" + key] = this.matrix[\"\" + key];\n            }\n        }\n        var maxSize = 0;\n        for (var key in commonRows) {\n            if (Object.prototype.hasOwnProperty.call(commonRows, key)) {\n                var matrixRow1 = commonRows[\"\" + key];\n                if (matrixRow1.length) {\n                    var firstCell = matrixRow1[0].cells[0];\n                    var rowStart = 0;\n                    if (firstCell && 'cell' in firstCell) {\n                        var geometry = firstCell.cell.geometry;\n                        rowStart = isHorizontal ? geometry.y : geometry.x;\n                    }\n                    else if (firstCell && 'edges' in firstCell) {\n                        var internalConnector = firstCell.edges[firstCell.edges.length - 1];\n                        var edgePts = this.flowchartModel.layout.edgesMapper.get(internalConnector);\n                        if (edgePts.length) {\n                            rowStart = isHorizontal ? edgePts[0].y : edgePts[0].x;\n                        }\n                    }\n                    var rowEnd = 0;\n                    var lastCell = matrixRow1[matrixRow1.length - 1]\n                        .cells[matrixRow1[matrixRow1.length - 1].cells.length - 1];\n                    if (lastCell && 'cell' in lastCell) {\n                        var geometry = lastCell.cell.geometry;\n                        rowEnd = isHorizontal ? geometry.y + geometry.height : geometry.x + geometry.width;\n                    }\n                    else if (lastCell && 'edges' in lastCell) {\n                        var internalConnector = lastCell.edges[lastCell.edges.length - 1];\n                        var edgePts = this.flowchartModel.layout.edgesMapper.get(internalConnector);\n                        if (edgePts.length) {\n                            rowEnd = isHorizontal ? edgePts[0].y : edgePts[0].x;\n                        }\n                    }\n                    maxSize = Math.max(maxSize, rowEnd - rowStart);\n                }\n            }\n        }\n        return maxSize;\n    };\n    MatrixModel.prototype.createMatrixCells = function () {\n        var layoutSettings = this.flowchartModel.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var spacingInverse = isHorizontal ? layoutSettings.horizontalSpacing : layoutSettings.verticalSpacing;\n        var rank = this.flowchartModel.ranks;\n        var ranks = Array.from(rank.values());\n        var matrixCellMapper = {};\n        var matrixRowOffset = -spacingInverse;\n        for (var j = ranks.length - 1; j >= 0; j--) {\n            var maxDimension = 0.0;\n            var index = (ranks.length - 1) - j;\n            var rank_1 = ranks[parseInt(j.toString(), 10)].slice();\n            // Creating new row and adding it to matrix\n            var matrixRow = [];\n            this.matrix[parseInt(index.toString(), 10)] = matrixRow;\n            // Creating new row mapper\n            var tempMatrixRow = {};\n            matrixCellMapper[parseInt(index.toString(), 10)] = tempMatrixRow;\n            while (rank_1.length > 0) {\n                var layoutCell = rank_1[0];\n                var matrixCell = {\n                    parents: [],\n                    children: [],\n                    visitedParents: [],\n                    visitedChildren: [],\n                    ignoredChildren: [],\n                    loopChildren: [],\n                    cells: [],\n                    level: index,\n                    initialOffset: 0,\n                    size: 0,\n                    offset: 0\n                };\n                matrixRow.push(matrixCell);\n                if ('internalInEdges' in layoutCell && 'internalOutEdges' in layoutCell) {\n                    matrixCell.cells.push(layoutCell);\n                    if (layoutCell.identicalSibling) {\n                        for (var i = 0; i < rank_1.length; i++) {\n                            var internalVertex = rank_1[parseInt(i.toString(), 10)];\n                            if ('internalInEdges' in internalVertex && 'internalOutEdges' in internalVertex) {\n                                if (layoutCell.identicalSibling.indexOf(internalVertex.id) !== -1) {\n                                    matrixCell.cells.push(internalVertex);\n                                    if (matrixCell.cells.length > layoutCell.identicalSibling.length) {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    var cells = matrixCell.cells;\n                    for (var i = 0; i < cells.length; i++) {\n                        var internalVertex = cells[parseInt(i.toString(), 10)];\n                        if ('internalInEdges' in internalVertex && 'internalOutEdges' in internalVertex) {\n                            var geometry = internalVertex.cell.geometry;\n                            matrixCell.size += isHorizontal ? geometry.height : geometry.width;\n                            maxDimension = Math.max(maxDimension, isHorizontal ? geometry.width : geometry.height);\n                            tempMatrixRow[internalVertex.id] = matrixCell;\n                            if (internalVertex.internalInEdges.length) {\n                                var internalInEdges = internalVertex.internalInEdges;\n                                for (var j_1 = 0; j_1 < internalInEdges.length; j_1++) {\n                                    var internalEdges = internalInEdges[parseInt(j_1.toString(), 10)];\n                                    if (internalEdges.isReversed) {\n                                        continue;\n                                    }\n                                    var key = null;\n                                    if (matrixCellMapper[index - 1] &&\n                                        Object.prototype.hasOwnProperty.call(matrixCellMapper[index - 1], internalEdges.ids)) {\n                                        key = internalEdges.ids;\n                                    }\n                                    else if (matrixCellMapper[index - 1] &&\n                                        Object.prototype.hasOwnProperty.call(matrixCellMapper[index - 1], internalEdges.source.id)) {\n                                        key = internalEdges.source.id;\n                                    }\n                                    if (key !== null) {\n                                        var parentMatrixCell = matrixCellMapper[index - 1][\"\" + key];\n                                        if (matrixCell.parents.indexOf(parentMatrixCell) === -1) {\n                                            matrixCell.parents.push(parentMatrixCell);\n                                        }\n                                        if (parentMatrixCell.children.indexOf(matrixCell) === -1) {\n                                            if (parentMatrixCell.children.length) {\n                                                if (parentMatrixCell.children[0].level === parentMatrixCell.level) {\n                                                    parentMatrixCell.children.unshift(matrixCell);\n                                                }\n                                                else {\n                                                    parentMatrixCell.children.push(matrixCell);\n                                                }\n                                            }\n                                            else {\n                                                parentMatrixCell.children.push(matrixCell);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            rank_1.splice(rank_1.indexOf(internalVertex), 1);\n                        }\n                    }\n                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n                }\n                else if ('edges' in layoutCell) {\n                    matrixCell.cells.push(layoutCell);\n                    var cells = matrixCell.cells;\n                    for (var i = 0; i < cells.length; i++) {\n                        var internalEdge = cells[parseInt(i.toString(), 10)];\n                        if ('edges' in internalEdge && internalEdge.edges) {\n                            var lineWidth = 1;\n                            var edgeSpacing = 5;\n                            var cellSize = -edgeSpacing;\n                            for (var j_2 = 0; j_2 < internalEdge.edges.length; j_2++) {\n                                var internalConnector = internalEdge.edges[parseInt(j_2.toString(), 10)];\n                                cellSize += lineWidth + edgeSpacing;\n                            }\n                            matrixCell.size += cellSize;\n                        }\n                        var key = null;\n                        if (internalEdge.isReversed) {\n                            if (matrixCellMapper[parseInt(index.toString(), 10)][internalEdge.ids]) {\n                                key = internalEdge.ids;\n                            }\n                            else if (matrixCellMapper[parseInt(index.toString(), 10)][internalEdge.source.id]) {\n                                key = internalEdge.source.id;\n                            }\n                        }\n                        else {\n                            if (matrixCellMapper[index - 1][internalEdge.ids]) {\n                                key = internalEdge.ids;\n                            }\n                            else if (matrixCellMapper[index - 1][internalEdge.source.id]) {\n                                key = internalEdge.source.id;\n                            }\n                        }\n                        if (key !== null) {\n                            var parentMatrixCell = matrixCellMapper[internalEdge.isReversed ?\n                                index : index - 1][\"\" + key];\n                            if (matrixCell.parents.indexOf(parentMatrixCell) === -1) {\n                                matrixCell.parents.push(parentMatrixCell);\n                            }\n                            if (parentMatrixCell.children.indexOf(matrixCell) === -1) {\n                                parentMatrixCell.children.push(matrixCell);\n                            }\n                        }\n                        tempMatrixRow[internalEdge.ids] = matrixCell;\n                        rank_1.splice(rank_1.indexOf(internalEdge), 1);\n                    }\n                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n                }\n            }\n            this.rowOffset[parseInt(index.toString(), 10)] = matrixRowOffset + (maxDimension / 2) + spacingInverse;\n            this.rowMaxDimension[parseInt(index.toString(), 10)] = this.rowOffset[parseInt(index.toString(), 10)] + maxDimension / 2;\n            matrixRowOffset += maxDimension + spacingInverse;\n        }\n    };\n    MatrixModel.prototype.groupLayoutCells = function () {\n        var rank = this.flowchartModel.ranks;\n        var ranks = Array.from(rank.values());\n        ranks.reverse();\n        for (var j = ranks.length - 1; j >= 0; j--) {\n            var vertices = ranks[parseInt(j.toString(), 10)].filter(function (v) { return 'internalInEdges' in v && 'internalOutEdges' in v; });\n            var edges = ranks[parseInt(j.toString(), 10)].filter(function (e) { return 'edges' in e && 'edges' in e; });\n            while (vertices.length > 1) {\n                var vertex1 = vertices[0];\n                if (vertex1.cell.isYesChild || vertex1.cell.isNoChild) {\n                    vertices.shift();\n                    continue;\n                }\n                var parentSet1 = vertex1.internalInEdges.map(function (e) { return e.source.id; });\n                var childSet1 = vertex1.internalOutEdges.map(function (e) { return e.target.id; });\n                while (vertices.length > 1) {\n                    var vertex2 = vertices[1];\n                    var parentSet2 = vertex2.internalInEdges.map(function (e) { return e.source.id; });\n                    var childSet2 = vertex2.internalOutEdges.map(function (e) { return e.target.id; });\n                    var parentEquals = this.compareLists(parentSet1, parentSet2);\n                    var childEquals = this.compareLists(childSet1, childSet2);\n                    if (parentEquals && childEquals) {\n                        this.updateMutualSharing(vertices[0], vertex2.id);\n                        this.updateMutualSharing(vertices[1], vertex1.id);\n                        vertices.splice(1, 1);\n                        continue;\n                    }\n                    break;\n                }\n                vertices.shift();\n            }\n            var _loop_2 = function () {\n                var internalEdge = edges[0];\n                var parentSet = internalEdge.source;\n                var childSet = internalEdge.target;\n                if (parentSet.identicalSibling) {\n                    var groupEdges = edges.filter(function (e) { return e.target === childSet; });\n                    for (var _i = 0, groupEdges_1 = groupEdges; _i < groupEdges_1.length; _i++) {\n                        var internalEdges = groupEdges_1[_i];\n                        if ((parentSet.identicalSibling).indexOf(internalEdges.source.id) !== -1) {\n                            internalEdges.source.identicalSibling = null;\n                        }\n                    }\n                    internalEdge.source.identicalSibling = null;\n                }\n                edges.shift();\n            };\n            while (edges.length > 1) {\n                _loop_2();\n            }\n        }\n    };\n    MatrixModel.prototype.updateMutualSharing = function (cell, id) {\n        if (cell.identicalSibling) {\n            cell.identicalSibling.push(id);\n        }\n        else {\n            cell.identicalSibling = [id];\n        }\n    };\n    MatrixModel.prototype.compareLists = function (list1, list2) {\n        var newList1 = list1.slice();\n        var newList2 = list2.slice();\n        if (newList1.length === newList2.length) {\n            if (newList1.length === 0) {\n                return true;\n            }\n            for (var _i = 0, newList2_1 = newList2; _i < newList2_1.length; _i++) {\n                var o = newList2_1[_i];\n                if (newList1.indexOf(o) === -1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    return MatrixModel;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/flowChart/matrix-model.js?");

/***/ })

}]);