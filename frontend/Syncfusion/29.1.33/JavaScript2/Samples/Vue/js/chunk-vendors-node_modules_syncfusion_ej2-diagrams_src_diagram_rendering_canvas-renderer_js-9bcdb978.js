"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_rendering_canvas-renderer_js-9bcdb978"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/canvas-renderer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/canvas-renderer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasRenderer: () => (/* binding */ CanvasRenderer)\n/* harmony export */ });\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _utility_path_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../utility/path-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/path-util.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _utility_dom_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../utility/dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _core_elements_image_element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/elements/image-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/image-element.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/elements/diagram-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/diagram-element.js\");\n/* eslint-disable no-case-declarations */\n/* eslint-disable @typescript-eslint/indent */\n\n\n\n\n\n\n\n\n\n\n/**\n * Canvas Renderer\n */\n/** @private */\nvar CanvasRenderer = /** @class */ (function () {\n    function CanvasRenderer() {\n    }\n    /**\n     * Provide the context value for the canvas \\\n     *\n     *  @returns {CanvasRenderingContext2D} Provide the context value for the canvas .\\\n     *  @param { HTMLCanvasElement} canvas - Return the dashed array values .\n     *  @private\n     */\n    CanvasRenderer.getContext = function (canvas) {\n        return canvas.getContext('2d');\n    };\n    CanvasRenderer.setCanvasSize = function (canvas, width, height) {\n        if (canvas) {\n            canvas.setAttribute('width', width.toString());\n            canvas.setAttribute('height', height.toString());\n        }\n    };\n    /**\n     * Draw the gradient for the diagram shapes .\\\n     *\n     *  @returns {SVGElement} Draw the gradient for the diagram shapes.\n     *  @param {StyleAttributes} options - Provide the options  for the gradient  element .\n     *  @param {SVGElement} ctx - Provide canvas values .\n     *  @param {string} x - Provide the x value for the gradient .\n     *  @param {string} y - Provide the x value for the gradient .\n     *  @private\n     */\n    CanvasRenderer.prototype.renderGradient = function (options, ctx, x, y) {\n        var max;\n        var min;\n        var grd;\n        if (options.gradient.type !== 'None') {\n            for (var i = 0; i < options.gradient.stops.length; i++) {\n                max = max !== undefined ? options.gradient.stops[parseInt(i.toString(), 10)].offset\n                    : Math.max(max, options.gradient.stops[parseInt(i.toString(), 10)].offset);\n                min = min !== undefined ? options.gradient.stops[parseInt(i.toString(), 10)].offset\n                    : Math.min(min, options.gradient.stops[parseInt(i.toString(), 10)].offset);\n            }\n            if (options.gradient.type === 'Linear') {\n                var linear = options.gradient;\n                grd = ctx.createLinearGradient(x + linear.x1, y + linear.y1, x + linear.x2, y + linear.y2);\n            }\n            else {\n                var radial = options.gradient;\n                grd = ctx.createRadialGradient(x + radial.fx, y + radial.fy, 0, x + radial.cx, y + radial.cy, radial.r);\n            }\n            for (var i = 0; i < options.gradient.stops.length; i++) {\n                var stop_1 = options.gradient.stops[parseInt(i.toString(), 10)];\n                var offset = min < 0 ? (max + stop_1.offset) / (2 * max) : stop_1.offset / max;\n                grd.addColorStop(offset, stop_1.color);\n            }\n            ctx.fillStyle = grd;\n        }\n        return ctx;\n    };\n    /**\n     * Draw the shawdow  for the rectangle shape in diagram \\\n     *\n     *  @returns {void}  Draw the shawdow  for the rectangle shape in diagram .\\\n     *\n     *  @param { SVGElement} options - Provide the base attributes .\n     *  @param { RectAttributes} canvas - Provide the canvas values .\n     *  @param { string} collection - Provide the collection value.\n     *  @private\n     */\n    CanvasRenderer.prototype.renderShadow = function (options, canvas, collection) {\n        if (collection === void 0) { collection = null; }\n        var ctx = CanvasRenderer.getContext(canvas);\n        ctx.save();\n        ctx.beginPath();\n        ctx.strokeStyle = ctx.fillStyle = options.shadow.color;\n        ctx.globalAlpha = options.shadow.opacity;\n        var ptModel = { x: 0, y: 0 };\n        var point = _primitives_point__WEBPACK_IMPORTED_MODULE_1__.Point.transform(ptModel, options.shadow.angle, options.shadow.distance);\n        var transX = options.x + point.x;\n        var transY = options.y + point.y;\n        var pivotX = transX + options.width * options.pivotX;\n        var pivotY = transY + options.height * options.pivotY;\n        this.rotateContext(canvas, options.angle, pivotX, pivotY);\n        if (collection) {\n            ctx.translate(transX, transY);\n            this.renderPath(canvas, options, collection);\n            ctx.translate(-transX, -transY);\n        }\n        else {\n            ctx.rect(transX, transY, options.width, options.height);\n            ctx.fillRect(transX, transY, options.width, options.height);\n        }\n        ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n    };\n    /**\n     * Create canvas element for the diagram \\\n     *\n     *  @returns {HTMLCanvasElement}    Create canvas element for the diagram .\\\n     *\n     *  @param { SVGElement} id - Provide the id for the canvas.\n     *  @param { Object} width - Provide the width for the canvas.\n     *  @param { Object} height - Provide the height for the canvas.\n     *  @private\n     */\n    CanvasRenderer.createCanvas = function (id, width, height) {\n        var canvasObj = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_4__.createHtmlElement)('canvas', { 'id': id });\n        this.setCanvasSize(canvasObj, width, height);\n        return canvasObj;\n    };\n    CanvasRenderer.prototype.setStyle = function (canvas, style) {\n        var ctx = CanvasRenderer.getContext(canvas);\n        if (style.fill === 'none') {\n            style.fill = 'transparent';\n        }\n        if (style.stroke === 'none') {\n            style.stroke = 'transparent';\n        }\n        ctx.strokeStyle = style.stroke;\n        ctx.lineWidth = style.strokeWidth;\n        if (style.strokeWidth === 0) {\n            ctx.strokeStyle = 'transparent';\n        }\n        ctx.globalAlpha = style.opacity;\n        var dashArray = [];\n        if (style.dashArray) {\n            dashArray = this.parseDashArray(style.dashArray);\n        }\n        ctx.setLineDash(dashArray);\n        if (style.gradient && style.gradient.type !== 'None') {\n            if (style.shapeType === 'Rectangle') {\n                this.renderGradient(style, ctx, style.x, style.y);\n            }\n            else {\n                this.renderGradient(style, ctx, 0, 0);\n            }\n        }\n        else {\n            ctx.fillStyle = style.fill;\n        }\n    };\n    CanvasRenderer.prototype.rotateContext = function (canvas, angle, x, y) {\n        var ctx = CanvasRenderer.getContext(canvas);\n        ctx.translate(x, y);\n        ctx.rotate(angle * Math.PI / 180);\n        ctx.translate(-x, -y);\n    };\n    CanvasRenderer.prototype.setFontStyle = function (canvas, text) {\n        var ctx = CanvasRenderer.getContext(canvas);\n        var font = '';\n        if (text.italic) {\n            font += 'italic ';\n        }\n        if (text.bold) {\n            font += 'bold ';\n        }\n        font += (text.fontSize) + 'px ';\n        font += text.fontFamily;\n        ctx.font = font;\n    };\n    /**\n     * Return the dashed array values \\\n     *\n     *  @returns {number[]}  Return the dashed array values .\\\n     *  @param { SVGElement} dashArray - Return the dashed array values .\n     *  @private\n     */\n    CanvasRenderer.prototype.parseDashArray = function (dashArray) {\n        var dashes = [];\n        var separator = dashArray.indexOf(' ') !== -1 ? ' ' : ',';\n        var splittedDashes = dashArray.split(separator);\n        for (var _i = 0, splittedDashes_1 = splittedDashes; _i < splittedDashes_1.length; _i++) {\n            var i = splittedDashes_1[_i];\n            dashes.push(Number(i));\n        }\n        return dashes;\n    };\n    CanvasRenderer.prototype.drawRoundedRect = function (canvas, options) {\n        var context = CanvasRenderer.getContext(canvas);\n        context.beginPath();\n        var x = options.x;\n        var y = options.y;\n        var w = options.width;\n        var h = options.height;\n        var mx = x + w / 2;\n        var my = y + h / 2;\n        context.beginPath();\n        this.setStyle(canvas, options);\n        context.moveTo(x, my);\n        context.quadraticCurveTo(x, y, mx, y);\n        context.quadraticCurveTo(x + w, y, x + w, my);\n        context.quadraticCurveTo(x + w, y + h, mx, y + h);\n        context.quadraticCurveTo(x, y + h, x, my);\n        //892454-Fill color not applied for BPMN activity shapes inside the symbol palette.\n        context.fill();\n        context.stroke();\n    };\n    //Rendering Part\n    /**\n     * Draw the Rectangle for the diagram \\\n     *\n     *  @returns {void}  Draw the Rectangle for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG .\n     *  @param { RectAttributes} options - Provide the Rect attributes .\n     *  @param { string} diagramId - Provide the diagram id .\n     *  @param { boolean} isExport - Provide the isExport .\n     *  @param { boolean} isSelector - Provide the selector possobilities .\n     *  @param { SVGSVGElement} parentSvg - Provide the parent svg element .\n     *  @param { Object} ariaLabel - Provide the Arial label attributes .\n     *  @param { boolean} isCircularHandle - Provide the boolean attribute for the circular handle .\n     *  @param { number} enableSelector - Provide the selector possobilities .\n     *  @param { any } renderer - Provide the renderer value .\n     *  @param { any } element - Provide the element value .\n     *  @private\n     */\n    CanvasRenderer.prototype.drawRectangle = function (canvas, options, diagramId, isExport, isSelector, parentSvg, ariaLabel, isCircularHandle, enableSelector, renderer, element) {\n        if (options.visible === true) {\n            if (options.cornerRadius) {\n                if (!isExport && (options.width < 30 || options.height < 30)) {\n                    this.drawRoundedRect(canvas, options);\n                }\n                else {\n                    options.data = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_2__.getRectanglePath)(options.cornerRadius, options.height, options.width);\n                    this.drawPath(canvas, options, diagramId, isSelector, parentSvg, ariaLabel, undefined, renderer, element);\n                }\n            }\n            else {\n                var ctx = CanvasRenderer.getContext(canvas);\n                if (options.shadow) {\n                    this.renderShadow(options, canvas);\n                }\n                ctx.save();\n                ctx.beginPath();\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var cornerRadius = options.cornerRadius;\n                var pivotX = options.x + options.width * options.pivotX;\n                var pivotY = options.y + options.height * options.pivotY;\n                var angle = options.isImage ? -options.angle : options.angle;\n                this.rotateContext(canvas, angle, pivotX, pivotY);\n                this.setStyle(canvas, options);\n                ctx.rect(options.x, options.y, options.width, options.height);\n                ctx.fillRect(options.x, options.y, options.width, options.height);\n                ctx.fill();\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n            }\n        }\n    };\n    // public updateSelectionRegion(canvas: HTMLCanvasElement, options: RectAttributes): void {\n    //     this.drawRectangle(canvas, options);\n    // }\n    // public drawLine(canvas: HTMLCanvasElement, options: LineAttributes): void {\n    //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);\n    //     ctx.save();\n    //     ctx.beginPath();\n    //     let pivotX: number = options.x + options.width * options.pivotX;\n    //     let pivotY: number = options.y + options.height * options.pivotY;\n    //     this.rotateContext(canvas, options.angle, pivotX, pivotY);\n    //     this.setStyle(canvas, options as StyleAttributes);\n    //     ctx.translate(options.x, options.y);\n    //     ctx.moveTo(options.startPoint.x, options.startPoint.y);\n    //     ctx.lineTo(options.endPoint.x, options.endPoint.y);\n    //     ctx.translate(-options.x, -options.y);\n    //     ctx.stroke();\n    //     ctx.closePath();\n    //     ctx.restore();\n    // }\n    // public drawCircle(canvas: HTMLCanvasElement, options: CircleAttributes): void {\n    //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);\n    //     ctx.save();\n    //     ctx.beginPath();\n    //     let pivotY: number = options.y + options.height * options.pivotY;\n    //     let pivotX: number = options.x + options.width * options.pivotX;\n    //     this.setStyle(canvas, options as StyleAttributes);\n    //     this.rotateContext(canvas, options.angle, pivotX, pivotY);\n    //     ctx.arc(options.centerX, options.centerY, options.radius, 0, 2 * Math.PI);\n    //     ctx.fill();\n    //     ctx.stroke();\n    //     ctx.closePath();\n    //     ctx.restore();\n    // }\n    /**\n     * Draw the path element for the diagram\\\n     *\n     *  @returns {void}  Draw the path element for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG element .\n     *  @param { PathAttributes} options - Provide the path element attributes .\n     *  @param {string} diagramId - Provide the diagram id .\n     *  @param {boolean} isSelector - Provide selector boolean value .\n     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .\n     *  @param {Object} ariaLabel - Provide arial label value .\n     *  @param {number} scale - Provide the scale value .\n     *  @param {any} renderer - Provide the renderer value .\n     *  @param {PathElement} element - Provide the path element value .\n     *  @private\n     */\n    CanvasRenderer.prototype.drawPath = function (canvas, options, diagramId, isSelector, parentSvg, ariaLabel, scale, renderer, element) {\n        var collection = [];\n        collection = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_2__.processPathData)(options.data);\n        collection = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_2__.pathSegmentCollection)(collection);\n        if (options.shadow) {\n            this.renderShadow(options, canvas, collection);\n        }\n        var ctx = CanvasRenderer.getContext(canvas);\n        ctx.save();\n        ctx.beginPath();\n        var pivotY = options.y + options.height * options.pivotY;\n        var pivotX = options.x + options.width * options.pivotX;\n        this.applyFlipAndRotate(ctx, options, canvas, pivotX, pivotY, renderer, element);\n        this.setStyle(canvas, options);\n        ctx.translate(options.x, options.y);\n        this.renderPath(canvas, options, collection);\n        ctx.fill();\n        ctx.translate(-options.x, -options.y);\n        ctx.stroke();\n        ctx.restore();\n    };\n    /**\n     * Draw the path element for the diagram\\\n     *\n     *  @returns {void}  Draw the path element for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG element .\n     *  @param {PathAttributes} options - Provide the path element attributes .\n     *  @param {Object[]} collection - Provide the parent SVG element .\n     *  @private\n     */\n    CanvasRenderer.prototype.renderPath = function (canvas, options, collection) {\n        if (options.visible === true) {\n            var arcCount = 0;\n            var ctx = CanvasRenderer.getContext(canvas);\n            var x0 = void 0;\n            var y0 = void 0;\n            var x1 = void 0;\n            var y1 = void 0;\n            var x2 = void 0;\n            var y2 = void 0;\n            var x = void 0;\n            var y = void 0;\n            var length_1;\n            var i = void 0;\n            var segs = collection;\n            for (x = 0, y = 0, i = 0, length_1 = segs.length; i < length_1; ++i) {\n                var obj = segs[parseInt(i.toString(), 10)];\n                var seg = obj;\n                var char = seg.command;\n                if ('x1' in seg) {\n                    x1 = seg.x1;\n                }\n                if ('x2' in seg) {\n                    x2 = seg.x2;\n                }\n                if ('y1' in seg) {\n                    y1 = seg.y1;\n                }\n                if ('y2' in seg) {\n                    y2 = seg.y2;\n                }\n                if ('x' in seg) {\n                    x = seg.x;\n                }\n                if ('y' in seg) {\n                    y = seg.y;\n                }\n                switch (char) {\n                    case 'M':\n                        ctx.moveTo(x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        break;\n                    case 'L':\n                        ctx.lineTo(x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        break;\n                    case 'C':\n                        ctx.bezierCurveTo(x1, y1, x2, y2, x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        seg.x1 = x1;\n                        seg.y1 = y1;\n                        seg.x2 = x2;\n                        seg.y2 = y2;\n                        break;\n                    case 'Q':\n                        ctx.quadraticCurveTo(x1, y1, x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        seg.x1 = x1;\n                        seg.y1 = y1;\n                        break;\n                    case 'A':\n                        // eslint-disable-next-line\n                        var curr = { x: x0, y: y0 };\n                        var rx = void 0;\n                        var ry = void 0;\n                        if (options.arc && options.arc.length > 0) {\n                            if (seg.r1 === 0) {\n                                rx = options.arc[parseInt(arcCount.toString(), 10)].r1;\n                            }\n                            else {\n                                rx = seg.r1;\n                            }\n                            if (seg.r2 === 0) {\n                                ry = options.arc[parseInt(arcCount.toString(), 10)].r2;\n                            }\n                            else {\n                                ry = seg.r2;\n                            }\n                            arcCount++;\n                        }\n                        else {\n                            rx = seg.r1;\n                            ry = seg.r2;\n                        }\n                        var xAxisRotation = seg.angle * (Math.PI / 180.0);\n                        var largeArc = seg.largeArc;\n                        var sweep = seg.sweep;\n                        var cp = { x: x, y: y };\n                        var currp = {\n                            x: Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,\n                            y: -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0\n                        };\n                        var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);\n                        if (l > 1) {\n                            rx *= Math.sqrt(l);\n                            ry *= Math.sqrt(l);\n                        }\n                        var k = (Math.pow(ry, 2) * Math.pow(currp.x, 2));\n                        var s = (largeArc === sweep ? -1 : 1) * Math.sqrt(((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - k) /\n                            (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));\n                        if (isNaN(s)) {\n                            s = 0;\n                        }\n                        var cpp = { x: s * rx * currp.y / ry, y: s * -ry * currp.x / rx };\n                        var centp = {\n                            x: (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,\n                            y: (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y\n                        };\n                        var a1 = this.a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);\n                        var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];\n                        var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];\n                        var ad = this.a(u, v);\n                        if (this.r(u, v) <= -1) {\n                            ad = Math.PI;\n                        }\n                        if (this.r(u, v) >= 1) {\n                            ad = 0;\n                        }\n                        var dir = !sweep ? -1.0 : 1.0;\n                        var ah = a1 + dir * (ad / 2.0);\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        var halfWay = {\n                            x: centp.x + rx * Math.cos(ah),\n                            y: centp.y + ry * Math.sin(ah)\n                        };\n                        seg.centp = centp;\n                        seg.xAxisRotation = xAxisRotation;\n                        seg.rx = rx;\n                        seg.ry = ry;\n                        seg.a1 = a1;\n                        seg.ad = ad;\n                        seg.sweep = sweep;\n                        if (ctx != null) {\n                            var ra = rx > ry ? rx : ry;\n                            var sx = rx > ry ? 1 : rx / ry;\n                            var sy = rx > ry ? ry / rx : 1;\n                            ctx.save();\n                            ctx.translate(centp.x, centp.y);\n                            ctx.rotate(xAxisRotation);\n                            ctx.scale(sx, sy);\n                            ctx.arc(0, 0, ra, a1, a1 + ad, !sweep);\n                            ctx.scale(1 / sx, 1 / sy);\n                            ctx.rotate(-xAxisRotation);\n                            ctx.translate(-centp.x, -centp.y);\n                            ctx.restore();\n                        }\n                        break;\n                    case 'Z':\n                    case 'z':\n                        ctx.closePath();\n                        x = x0;\n                        y = y0;\n                        break;\n                }\n                x0 = x;\n                y0 = y;\n            }\n        }\n    };\n    /**\n     * Draw the text element for the diagram\\\n     *\n     *  @returns {void}  Draw the text element for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG element .\n     *  @param {TextAttributes} options - Provide the text element attributes .\n     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .\n     *  @param {Object} ariaLabel - Provide the label properties .\n     *  @param {string} diagramId - Provide the diagram id .\n     *  @param {number} scaleValue - Provide the scale value .\n     *  @param {any} renderer - Provide the renderer value .\n     *  @param {element} element - Provide the text element value.\n     *  @private\n     */\n    CanvasRenderer.prototype.drawText = function (canvas, options, parentSvg, ariaLabel, diagramId, scaleValue, renderer, element) {\n        if (options.content && options.visible === true) {\n            var parentNode = renderer.groupElement;\n            var ctx = CanvasRenderer.getContext(canvas);\n            ctx.save();\n            this.setStyle(canvas, options);\n            if (scaleValue) {\n                options.fontSize *= scaleValue;\n            }\n            var pivotX = options.x + options.width * options.pivotX;\n            var pivotY = options.y + options.height * options.pivotY;\n            // 919944: Text Flip and Rotation Not Applied in Exported Image\n            this.applyFlipAndRotate(ctx, options, canvas, pivotX, pivotY, renderer, element);\n            this.setFontStyle(canvas, options);\n            var i = 0;\n            var childNodes = [];\n            childNodes = options.childNodes;\n            var wrapBounds = options.wrapBounds;\n            ctx.fillStyle = options.color;\n            if (wrapBounds) {\n                var position = this.labelAlign(options, wrapBounds, childNodes);\n                for (i = 0; i < childNodes.length; i++) {\n                    var child = childNodes[parseInt(i.toString(), 10)];\n                    child.x = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_4__.setChildPosition)(child, childNodes, i, options);\n                    var offsetX = position.x + (scaleValue ? child.x * scaleValue : child.x) - wrapBounds.x;\n                    var offsetY = position.y + (scaleValue ? child.dy * scaleValue : child.dy) * i + ((options.fontSize) * 0.8);\n                    if (wrapBounds.width > options.width && options.textOverflow !== 'Wrap' && options.textWrapping === 'NoWrap') {\n                        child.text = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.overFlow)(child.text, options);\n                    }\n                    if ((options.textOverflow === 'Clip' || options.textOverflow === 'Ellipsis') && options.textWrapping === 'Wrap') {\n                        if (offsetY < parentNode.actualSize.height + parentNode.bounds.y) {\n                            if (options.textOverflow === 'Ellipsis' && childNodes[i + 1]) {\n                                var temp = childNodes[i + 1];\n                                var y = position.y + temp.dy * (i + 1) + ((options.fontSize) * 0.8);\n                                if (y > parentNode.actualSize.height + parentNode.bounds.y) {\n                                    child.text = child.text.slice(0, child.text.length - 3);\n                                    child.text = child.text.concat('...');\n                                }\n                            }\n                            ctx.fillText(child.text, offsetX, offsetY);\n                        }\n                    }\n                    else {\n                        ctx.fillText(child.text, offsetX, offsetY);\n                    }\n                    if (options.textDecoration === 'Underline'\n                        || options.textDecoration === 'Overline'\n                        || options.textDecoration === 'LineThrough') {\n                        var startPointX = offsetX;\n                        var startPointY = void 0;\n                        var textlength = ctx.measureText(child.text).width;\n                        var endPointX = offsetX + textlength;\n                        var endPointY = void 0;\n                        switch (options.textDecoration) {\n                            case 'Underline':\n                                startPointY = offsetY + 2;\n                                endPointY = offsetY + 2;\n                                break;\n                            case 'Overline':\n                                startPointY = (position.y + child.dy * i);\n                                endPointY = (position.y + child.dy * i);\n                                break;\n                            case 'LineThrough':\n                                startPointY = ((offsetY + position.y + child.dy * i) / 2) + 2;\n                                endPointY = ((offsetY + position.y + child.dy * i) / 2) + 2;\n                        }\n                        ctx.beginPath();\n                        ctx.moveTo(startPointX, startPointY);\n                        ctx.lineTo(endPointX, endPointY);\n                        ctx.strokeStyle = options.color;\n                        ctx.lineWidth = options.fontSize * .08;\n                        ctx.globalAlpha = options.opacity;\n                        ctx.stroke();\n                    }\n                }\n            }\n            ctx.restore();\n        }\n    };\n    // 919944: Flip position and rotate angle calculation for elements\n    CanvasRenderer.prototype.applyFlipAndRotate = function (ctx, options, canvas, pivotX, pivotY, renderer, element) {\n        if (options.flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_8__.FlipDirection.None && renderer && element && !(element.elementActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ElementAction.ElementIsPort)) {\n            var parent_1 = renderer.groupElement;\n            var textWrapper = element;\n            var transform = void 0;\n            if ((element instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_6__.TextElement && element.position)) {\n                transform = renderer.renderFlipTextElement(parent_1, canvas, textWrapper, options.flip, options.flipMode, true);\n            }\n            else if (element instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_5__.PathElement || element instanceof _core_elements_image_element__WEBPACK_IMPORTED_MODULE_7__.ImageElement || (element instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_6__.TextElement\n                && !element.position) || element instanceof _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_9__.DiagramElement) {\n                transform = renderer.renderFlipElement(parent_1, canvas, options.flip, true);\n            }\n            //To set the translate and scale for the diagram elements while print and export.\n            if (transform && transform.transform) {\n                // Parse and apply the transform directly\n                var transformRegex = /(translate|scale|rotate)\\(([^)]+)\\)/g;\n                var match = void 0;\n                // eslint-disable-next-line no-cond-assign\n                while ((match = transformRegex.exec(transform.transform)) !== null) {\n                    var type = match[1]; // translate, scale, rotate\n                    var values = match[2].split(',').map(function (v) { return parseFloat(v.trim()); });\n                    switch (type) {\n                        case 'translate': {\n                            var tx = values[0] || 0;\n                            var ty = values[1] || 0;\n                            ctx.translate(tx, ty);\n                            break;\n                        }\n                        case 'scale': {\n                            var sx = values[0] || 1;\n                            var sy = values[1] || sx; // Use uniform scaling if sy is not specified\n                            ctx.scale(sx, sy);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        this.rotateContext(canvas, options.angle, pivotX, pivotY);\n    };\n    CanvasRenderer.prototype.loadImage = function (ctx, obj, canvas, pivotX, pivotY) {\n        // 919944: Image Node Flip and Rotation Not Applied in Exported Image\n        var image = new Image();\n        image.src = obj.source;\n        this.image(ctx, image, obj.x, obj.y, obj.width, obj.height, obj);\n    };\n    /**\n     * Draw the image element for the diagram\\\n     *\n     *  @returns {void} Draw the image element for the diagram .\n     *  @param { SVGElement | HTMLCanvasElement} canvas - Provide the SVG element .\n     *  @param {ImageAttributes} obj - Provide the image attributes .\n     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .\n     *  @param {boolean} fromPalette - Provide the pointer event value .\n     *  @param {any} renderer - provide renderer value\n     *  @param {ImageElement} element - provide image element\n     *  @private\n     */\n    CanvasRenderer.prototype.drawImage = function (canvas, obj, parentSvg, fromPalette, renderer, element) {\n        var _this = this;\n        if (obj.visible) {\n            var ctx_1 = CanvasRenderer.getContext(canvas);\n            ctx_1.save();\n            var pivotX_1 = obj.x + obj.width * obj.pivotX;\n            var pivotY_1 = obj.y + obj.height * obj.pivotY;\n            var imageObj = new Image();\n            imageObj.src = obj.source;\n            // 919867: Opacity for the image node is not applied to the exported image\n            this.setStyle(canvas, obj);\n            var id = ctx_1.canvas.id.split('_');\n            // eslint-disable-next-line\n            var value = id[id.length - 1] === ('diagram' || 0) ? true : false;\n            // eslint-disable-next-line\n            /**\n             *  Since Clipping portion for node with slice option is not calculated properly\n             * if (obj.sourceX !== undefined && obj.sourceY !== undefined && obj.sourceWidth !== undefined\n             *  && obj.sourceHeight !== undefined) {\n             *  ctx.drawImage(imageObj, obj.sourceX, obj.sourceY, obj.sourceWidth, obj.sourceHeight, obj.x, obj.y, obj.width, obj.height);\n             *  } else {\n             *             ctx.drawImage(imageObj, obj.x, obj.y, obj.width, obj.height);\n             * }\n             */\n            // 919944: Image Node Flip and Rotation Not Applied in Exported Image\n            this.applyFlipAndRotate(ctx_1, obj, canvas, pivotX_1, pivotY_1, renderer, element);\n            if (!fromPalette) {\n                this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);\n            }\n            else {\n                imageObj.onload = function () {\n                    _this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);\n                };\n            }\n            ctx_1.restore();\n        }\n    };\n    CanvasRenderer.prototype.image = function (ctx, image, x, y, width, height, alignOptions) {\n        ctx.beginPath();\n        var srcWidth = image.width;\n        var srcHeight = image.height;\n        var destinationW = width;\n        var destinationH = height;\n        var resultWidth = 0;\n        var resultHeight = 0;\n        if (alignOptions && alignOptions.alignment !== 'None') {\n            var xalign = alignOptions.alignment.toLowerCase().substr(1, 3);\n            var yalign = alignOptions.alignment.toLowerCase().substr(5, 3);\n            if (alignOptions.scale === 'Slice') {\n                // eslint-disable-next-line\n                var a = function () {\n                    resultWidth = destinationW;\n                    resultHeight = srcHeight * destinationW / srcWidth;\n                };\n                // eslint-disable-next-line\n                var b = function () {\n                    resultWidth = srcWidth * destinationH / srcHeight;\n                    resultHeight = destinationH;\n                };\n                if (destinationW > destinationH) {\n                    a();\n                    if (destinationH > resultHeight) {\n                        b();\n                    }\n                }\n                else if (destinationW === destinationH) {\n                    if (srcWidth > srcHeight) {\n                        b();\n                    }\n                    else {\n                        a();\n                    }\n                }\n                else {\n                    b();\n                    if (destinationW > resultWidth) {\n                        a();\n                    }\n                }\n                var x1 = this.getSliceOffset(xalign, resultWidth, destinationW, srcWidth);\n                var y1 = this.getSliceOffset(yalign, resultHeight, destinationH, srcHeight);\n                var sWidth = srcWidth - x1;\n                var sHeight = srcHeight - y1;\n                var dWidth = resultWidth - (x1 * (resultWidth / srcWidth));\n                var dHeight = resultHeight - (y1 * (resultHeight / srcHeight));\n                var canvas1 = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_4__.createHtmlElement)('canvas', { 'width': width.toString(), 'height': height.toString() });\n                var ctx1 = canvas1.getContext('2d');\n                ctx1.drawImage(image, x1, y1, sWidth, sHeight, 0, 0, dWidth, dHeight);\n                ctx.drawImage(canvas1, x, y, width, height);\n            }\n            else if (alignOptions.scale === 'Meet') {\n                var srcRatio = (srcHeight / srcWidth);\n                var destRatio = (destinationH / destinationW);\n                resultWidth = destRatio > srcRatio ? destinationW : destinationH / srcRatio;\n                resultHeight = destRatio > srcRatio ? destinationW * srcRatio : destinationH;\n                x += this.getMeetOffset(xalign, resultWidth, destinationW);\n                y += this.getMeetOffset(yalign, resultHeight, destinationH);\n                ctx.drawImage(image, 0, 0, srcWidth, srcHeight, x, y, resultWidth, resultHeight);\n            }\n            else {\n                ctx.drawImage(image, x, y, width, height);\n            }\n        }\n        else {\n            ctx.drawImage(image, x, y, width, height);\n        }\n        ctx.closePath();\n    };\n    CanvasRenderer.prototype.getSliceOffset = function (arg, res, dest, src) {\n        switch (arg) {\n            case 'min': return 0;\n            case 'mid': return (res - dest) / 2 * src / res;\n            case 'max': return (res - dest) * src / res;\n            default: return 0;\n        }\n    };\n    CanvasRenderer.prototype.getMeetOffset = function (arg, res, dest) {\n        var max = Math.max(res, dest);\n        var min = Math.min(res, dest);\n        switch (arg) {\n            case 'min': return 0;\n            case 'mid': return (max - min) / 2;\n            case 'max': return max - min;\n            default: return 0;\n        }\n    };\n    //end region\n    // vector magnitude\n    CanvasRenderer.prototype.m = function (v) { return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)); };\n    // ratio between two vectors\n    CanvasRenderer.prototype.r = function (u, v) { return (u[0] * v[0] + u[1] * v[1]) / (this.m(u) * this.m(v)); };\n    // angle between two vectors\n    CanvasRenderer.prototype.a = function (u, v) { return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(this.r(u, v)); };\n    // text utility\n    /**\n     * Draw the SVG label.\\\n     *\n     * @returns {PointModel} Draw the SVG label .\n     *  @param {TextAttributes} text - Provide the canvas element .\n     *  @param {Object} wrapBounds - Provide the canvas element .\n     *  @param {SubTextElement []} childNodes - Provide the canvas element .\n     * @private\n     */\n    CanvasRenderer.prototype.labelAlign = function (text, wrapBounds, childNodes) {\n        var bounds = new _primitives_size__WEBPACK_IMPORTED_MODULE_0__.Size(wrapBounds.width, childNodes.length * (text.fontSize * 1.2));\n        var position = { x: 0, y: 0 };\n        var labelX = text.x;\n        var labelY = text.y;\n        var offsetx = text.width * 0.5;\n        var offsety = text.height * 0.5;\n        var pointx = offsetx;\n        var pointy = offsety;\n        if (text.textAlign === 'left') {\n            pointx = 0;\n        }\n        else if (text.textAlign === 'center') {\n            if (wrapBounds.width > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {\n                if (text.textWrapping === 'NoWrap') {\n                    pointx = 0;\n                }\n                else {\n                    pointx = text.width * 0.5;\n                }\n            }\n            else {\n                pointx = text.width * 0.5;\n            }\n        }\n        else if (text.textAlign === 'right') {\n            pointx = (text.width * 1);\n        }\n        position.x = labelX + pointx + (wrapBounds ? wrapBounds.x : 0);\n        position.y = labelY + pointy - bounds.height / 2;\n        return position;\n    };\n    return CanvasRenderer;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/canvas-renderer.js?");

/***/ })

}]);