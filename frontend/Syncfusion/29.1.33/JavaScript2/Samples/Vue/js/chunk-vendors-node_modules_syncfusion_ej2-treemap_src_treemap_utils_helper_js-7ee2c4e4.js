"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-treemap_src_treemap_utils_helper_js-7ee2c4e4"],{

/***/ "./node_modules/@syncfusion/ej2-treemap/src/treemap/utils/helper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-treemap/src/treemap/utils/helper.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColorValue: () => (/* binding */ ColorValue),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   PathOption: () => (/* binding */ PathOption),\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   RectOption: () => (/* binding */ RectOption),\n/* harmony export */   Size: () => (/* binding */ Size),\n/* harmony export */   TextOption: () => (/* binding */ TextOption),\n/* harmony export */   TreeMapAjax: () => (/* binding */ TreeMapAjax),\n/* harmony export */   applyOptions: () => (/* binding */ applyOptions),\n/* harmony export */   colorCollections: () => (/* binding */ colorCollections),\n/* harmony export */   colorMap: () => (/* binding */ colorMap),\n/* harmony export */   colorNameToHex: () => (/* binding */ colorNameToHex),\n/* harmony export */   componentToHex: () => (/* binding */ componentToHex),\n/* harmony export */   convertElement: () => (/* binding */ convertElement),\n/* harmony export */   convertHexToColor: () => (/* binding */ convertHexToColor),\n/* harmony export */   convertToContainer: () => (/* binding */ convertToContainer),\n/* harmony export */   convertToHexCode: () => (/* binding */ convertToHexCode),\n/* harmony export */   convertToRect: () => (/* binding */ convertToRect),\n/* harmony export */   createTextStyle: () => (/* binding */ createTextStyle),\n/* harmony export */   deSaturationColor: () => (/* binding */ deSaturationColor),\n/* harmony export */   drawSymbol: () => (/* binding */ drawSymbol),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findHightLightItems: () => (/* binding */ findHightLightItems),\n/* harmony export */   findLabelLocation: () => (/* binding */ findLabelLocation),\n/* harmony export */   findPosition: () => (/* binding */ findPosition),\n/* harmony export */   formatValue: () => (/* binding */ formatValue),\n/* harmony export */   getArea: () => (/* binding */ getArea),\n/* harmony export */   getColorByValue: () => (/* binding */ getColorByValue),\n/* harmony export */   getElement: () => (/* binding */ getElement),\n/* harmony export */   getGradientColor: () => (/* binding */ getGradientColor),\n/* harmony export */   getLegendIndex: () => (/* binding */ getLegendIndex),\n/* harmony export */   getMousePosition: () => (/* binding */ getMousePosition),\n/* harmony export */   getPercentage: () => (/* binding */ getPercentage),\n/* harmony export */   getPercentageColor: () => (/* binding */ getPercentageColor),\n/* harmony export */   getShortestEdge: () => (/* binding */ getShortestEdge),\n/* harmony export */   getTemplateFunction: () => (/* binding */ getTemplateFunction),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   isContainsData: () => (/* binding */ isContainsData),\n/* harmony export */   isParentItem: () => (/* binding */ isParentItem),\n/* harmony export */   itemsToOrder: () => (/* binding */ itemsToOrder),\n/* harmony export */   legendMaintain: () => (/* binding */ legendMaintain),\n/* harmony export */   maintainSelection: () => (/* binding */ maintainSelection),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   measureText: () => (/* binding */ measureText),\n/* harmony export */   orderByArea: () => (/* binding */ orderByArea),\n/* harmony export */   pushCollection: () => (/* binding */ pushCollection),\n/* harmony export */   removeClassNames: () => (/* binding */ removeClassNames),\n/* harmony export */   removeElement: () => (/* binding */ removeElement),\n/* harmony export */   removeLegend: () => (/* binding */ removeLegend),\n/* harmony export */   removeSelectionWithHighlight: () => (/* binding */ removeSelectionWithHighlight),\n/* harmony export */   removeShape: () => (/* binding */ removeShape),\n/* harmony export */   renderLegendShape: () => (/* binding */ renderLegendShape),\n/* harmony export */   renderTextElement: () => (/* binding */ renderTextElement),\n/* harmony export */   rgbToHex: () => (/* binding */ rgbToHex),\n/* harmony export */   setColor: () => (/* binding */ setColor),\n/* harmony export */   setItemTemplateContent: () => (/* binding */ setItemTemplateContent),\n/* harmony export */   stringToNumber: () => (/* binding */ stringToNumber),\n/* harmony export */   textFormatter: () => (/* binding */ textFormatter),\n/* harmony export */   textTrim: () => (/* binding */ textTrim),\n/* harmony export */   textWrap: () => (/* binding */ textWrap),\n/* harmony export */   triggerDownload: () => (/* binding */ triggerDownload),\n/* harmony export */   wordWrap: () => (/* binding */ wordWrap)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n\n\n/**\n * Specifies the size parameters.\n */\nvar Size = /** @class */ (function () {\n    function Size(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    return Size;\n}());\n\n/**\n *\n * @param {string} value - specifies the text.\n * @param {number} containerSize - specifies the container size value.\n * @returns {number} - Returns the number value which is converted from string.\n */\nfunction stringToNumber(value, containerSize) {\n    if (value !== null && value !== undefined) {\n        return value.indexOf('%') !== -1 ? (containerSize / 100) * parseInt(value, 10) : parseInt(value, 10);\n    }\n    return null;\n}\n/**\n * Internal use of type rect\n *\n * @private\n */\nvar Rect = /** @class */ (function () {\n    function Rect(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    return Rect;\n}());\n\n/**\n * Internal use of rectangle options\n *\n * @private\n */\nvar RectOption = /** @class */ (function () {\n    function RectOption(id, fill, border, opacity, rect, dashArray) {\n        this.y = rect.y;\n        this.x = rect.x;\n        this.height = rect.height;\n        this.width = rect.width;\n        this.id = id;\n        this.fill = fill;\n        this.opacity = opacity;\n        this.stroke = border.color;\n        this['stroke-width'] = border.width;\n        this['stroke-dasharray'] = dashArray;\n    }\n    return RectOption;\n}());\n\nvar PathOption = /** @class */ (function () {\n    function PathOption(id, fill, width, color, opacity, dashArray, d) {\n        this.id = id;\n        this.opacity = opacity;\n        this.fill = fill;\n        this.stroke = color;\n        this['stroke-width'] = width;\n        this['stroke-dasharray'] = dashArray;\n        this.d = d;\n    }\n    return PathOption;\n}());\n\n/**\n * Function to measure the height and width of the text.\n *\n * @param  {string} text - Specifies the text.\n * @param  {FontModel} font - Specifies the font.\n * @returns {Size} - Returns the size.\n * @private\n */\nfunction measureText(text, font) {\n    var measureObject = document.getElementById('treeMapMeasureText');\n    if (measureObject === null) {\n        measureObject = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('text', { id: 'treeMapMeasureText' });\n        document.body.appendChild(measureObject);\n    }\n    measureObject.innerHTML = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.SanitizeHtmlHelper.sanitize(text);\n    measureObject.style.position = 'absolute';\n    measureObject.style.fontSize = font.size;\n    measureObject.style.fontWeight = font.fontWeight;\n    measureObject.style.fontStyle = font.fontStyle;\n    measureObject.style.fontFamily = font.fontFamily;\n    measureObject.style.visibility = 'hidden';\n    measureObject.style.top = '-100';\n    measureObject.style.left = '0';\n    measureObject.style.whiteSpace = 'nowrap';\n    // For bootstrap line height issue\n    measureObject.style.lineHeight = 'normal';\n    return new Size(measureObject.clientWidth, measureObject.clientHeight);\n}\n/**\n * Internal use of text options\n *\n * @private\n */\nvar TextOption = /** @class */ (function () {\n    function TextOption(id, x, y, anchor, text, transform, baseLine, connectorText) {\n        if (transform === void 0) { transform = ''; }\n        this.transform = '';\n        this.baseLine = 'auto';\n        this.id = id;\n        this.text = text;\n        this.transform = transform;\n        this.anchor = anchor;\n        this.x = x;\n        this.y = y;\n        this.baseLine = baseLine;\n        this.connectorText = connectorText;\n    }\n    return TextOption;\n}());\n\n/**\n * Trim the title text\n *\n * @param {number} maxWidth - Specifies the maximum width\n * @param {string} text - Specifies the text\n * @param {FontModel} font - Specifies the font\n * @returns {string} - Returns the string\n * @private\n */\nfunction textTrim(maxWidth, text, font) {\n    var label = text;\n    var size = measureText(text, font).width;\n    if (size > maxWidth) {\n        var textLength = text.length;\n        for (var i = textLength - 1; i >= 0; --i) {\n            label = text.substring(0, i) + '...';\n            size = measureText(label, font).width;\n            if (size <= maxWidth || label.length < 4) {\n                if (label.length < 4) {\n                    label = ' ';\n                }\n                return label;\n            }\n        }\n    }\n    return label;\n}\n/**\n * Specifies the location parameters.\n */\nvar Location = /** @class */ (function () {\n    function Location(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    return Location;\n}());\n\n/**\n * Method to calculate x position of title\n *\n * @param {Rect} location - Specifies the location of text.\n * @param {Alignment} alignment - Specifies the alignment of the text.\n * @param {Size} textSize - Specifies the size of the text.\n * @param {type} type - Specifies whether the provided text is title or subtitle.\n * @returns {Location} - Returns the location of text.\n * @private\n */\nfunction findPosition(location, alignment, textSize, type) {\n    var x;\n    switch (alignment) {\n        case 'Near':\n            x = location.x;\n            break;\n        case 'Center':\n            x = (type === 'title') ? (location.width / 2 - textSize.width / 2) :\n                ((location.x + (location.width / 2)) - textSize.width / 2);\n            break;\n        case 'Far':\n            x = (type === 'title') ? (location.width - location.y - textSize.width) :\n                ((location.x + location.width) - textSize.width);\n            break;\n    }\n    var y = (type === 'title') ? location.y + (textSize.height / 2) : ((location.y + location.height / 2) + textSize.height / 2);\n    return new Location(x, y);\n}\n/**\n *\n * @param {SvgRenderer} renderer - Specifies the rendering element of the SVG.\n * @param {any} renderOptions - Specifies the settings of the text.\n * @param {string} text - Specifies the text.\n * @returns {HTMLElement} - Returns the HTML element for the text.\n */\nfunction createTextStyle(renderer, renderOptions, text) {\n    var htmlObject = renderer.createText(renderOptions, text);\n    htmlObject.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n    htmlObject.style['user-select'] = 'none';\n    htmlObject.style['-moz-user-select'] = 'none';\n    htmlObject.style['-webkit-touch-callout'] = 'none';\n    htmlObject.style['-webkit-user-select'] = 'none';\n    htmlObject.style['-khtml-user-select'] = 'none';\n    htmlObject.style['-ms-user-select'] = 'none';\n    htmlObject.style['-o-user-select'] = 'none';\n    return htmlObject;\n}\n/**\n * Internal rendering of text\n *\n * @param {TextOption} options - Specifies the text option\n * @param {FontModel} font - Specifies the font model\n * @param {string} color - Specifies the color\n * @param {HTMLElement | Element} parent - Specifies the parent element of the text\n * @param {boolean} isMinus - Specifies the boolean value\n * @returns {Element} - Returns the element\n * @private\n */\nfunction renderTextElement(options, font, color, parent, isMinus) {\n    if (isMinus === void 0) { isMinus = false; }\n    var renderOptions = {\n        'font-size': font.size,\n        'font-style': font.fontStyle,\n        'font-family': font.fontFamily,\n        'font-weight': font.fontWeight,\n        'text-anchor': options.anchor,\n        'transform': options.transform,\n        'opacity': font.opacity,\n        'dominant-baseline': options.baseLine,\n        'id': options.id,\n        'x': options.x,\n        'y': options.y,\n        'fill': color\n    };\n    var text = typeof options.text === 'string' ? options.text : isMinus ? options.text[options.text.length - 1] : options.text[0];\n    var tspanElement;\n    var renderer = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.SvgRenderer('');\n    var height;\n    var htmlObject;\n    var breadCrumbText = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(text) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(options.connectorText) ?\n        (text.search(options.connectorText[1]) >= 0) : false;\n    if (breadCrumbText) {\n        var drilledLabel = text;\n        var spacing = 5;\n        var drillLevelText = drilledLabel.split('#');\n        for (var z = 0; z < drillLevelText.length; z++) {\n            var drillText = (drillLevelText[z].search(options.connectorText) !== -1 &&\n                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(options.connectorText)) ?\n                options.connectorText : drillLevelText[z];\n            renderOptions['id'] = options.id + '_' + z;\n            htmlObject = createTextStyle(renderer, renderOptions, drillText);\n            if (z % 2 === 0 && z !== 0) {\n                var re = /\\s+/g;\n                drillText = drillText.replace(re, '&nbsp');\n            }\n            var size = measureText(drillText, font);\n            renderOptions['x'] = z !== 0 ? renderOptions['x'] + size.width : renderOptions['x'] + size.width + spacing;\n            parent.appendChild(htmlObject);\n        }\n    }\n    else {\n        htmlObject = createTextStyle(renderer, renderOptions, text);\n        parent.appendChild(htmlObject);\n    }\n    if (typeof options.text !== 'string' && options.text.length > 1) {\n        for (var i = 1, len = options.text.length; i < len; i++) {\n            height = (measureText(options.text[i], font).height);\n            tspanElement = renderer.createTSpan({\n                'x': options.x, 'id': options.id,\n                'y': (options.y) + (i * height)\n            }, options.text[i]);\n            htmlObject.appendChild(tspanElement);\n        }\n        parent.appendChild(htmlObject);\n    }\n    return htmlObject;\n}\n/**\n *\n * @param {string} targetId - Specifies the id of the element to which template is to be appended.\n * @param {Element} targetElement - Specifies the element to which template is to be appended.\n * @param {string} contentItemTemplate - Specifies the content to be appended as template.\n * @returns {void}\n */\nfunction setItemTemplateContent(targetId, targetElement, contentItemTemplate) {\n    var itemSelect = targetId.split('_RectPath')[0];\n    var itemTemplate;\n    if (targetId.indexOf('_LabelTemplate') > -1) {\n        itemTemplate = targetElement;\n    }\n    else {\n        itemTemplate = document.querySelector('#' + itemSelect + '_LabelTemplate');\n    }\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(itemTemplate)) {\n        itemTemplate.innerHTML = contentItemTemplate;\n    }\n}\n/**\n *\n * @param {string} id - Specifies the id of the element.\n * @returns {Element} - Returns the element.\n */\nfunction getElement(id) {\n    return document.getElementById(id);\n}\n/**\n *\n * @param {any} a - Specifies the first order of TreeMap leaf elements.\n * @param {any} b - Specifies the second order of TreeMap leaf elements.\n * @returns {number} - Returns the order of the TreeMap leaf element.\n */\nfunction itemsToOrder(a, b) {\n    return a['weight'] === b['weight'] ? 0 : a['weight'] < b['weight'] ? 1 : -1;\n}\n/**\n *\n * @param {string[]} source - Specifies the data from the data source.\n * @param {string} pathName - Specifies the path name in the data source.\n * @param {any} processData - Specifies the data source object.\n * @param {TreeMap} treemap - Specifies the treemap instance.\n * @returns {boolean} - Specifies whether data is available in the data source or not.\n */\nfunction isContainsData(source, pathName, processData, treemap) {\n    var isExist = false;\n    var name = '';\n    var path;\n    var leaf = treemap.leafItemSettings;\n    for (var i = 0; i < source.length; i++) {\n        path = treemap.levels[i] ? treemap.levels[i].groupPath : leaf.labelPath ? leaf.labelPath :\n            treemap.weightValuePath;\n        var data = processData[path] || 'undefined';\n        if (source[i] === data) {\n            name += data + (i === source.length - 1 ? '' : '#');\n            if (name === pathName) {\n                isExist = true;\n                break;\n            }\n        }\n    }\n    return isExist;\n}\n/**\n *\n * @param {any} data - Specifies the data to which the children elements to be found.\n * @returns {any} - Returns the children elements of the TreeMap leaf element.\n */\nfunction findChildren(data) {\n    var children;\n    if (data) {\n        var keys = Object.keys(data);\n        children = {};\n        for (var i = 0; i < keys.length; i++) {\n            if (data[keys[i]] instanceof Array) {\n                children['values'] = data[keys[i]];\n                children['key'] = keys[i];\n                break;\n            }\n        }\n    }\n    return children;\n}\n/**\n *\n * @param {any} data - Specifies the data to which highlight must be done.\n * @param {items} items - Specifies the data source items.\n * @param {string} mode - Specifies the mode of highlight.\n * @param {TreeMap} treeMap - Specifies the treemap instance.\n * @returns {string[]} - Returns the highlighted items.\n */\nfunction findHightLightItems(data, items, mode, treeMap) {\n    if (mode === 'Child') {\n        items.push(data['levelOrderName']);\n        var children = findChildren(data)['values'];\n        if (children && children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n                if (items.indexOf(children[i]['levelOrderName']) === -1) {\n                    items.push(children[i]['levelOrderName']);\n                }\n            }\n            for (var j = 0; j < children.length; j++) {\n                findHightLightItems(children[j], items, mode, treeMap);\n            }\n        }\n    }\n    else if (mode === 'Parent') {\n        if (typeof data['levelOrderName'] === 'string' && items.indexOf(data['levelOrderName']) === -1) {\n            items.push(data['levelOrderName']);\n            findHightLightItems(data['parent'], items, mode, treeMap);\n        }\n    }\n    else if (mode === 'All') {\n        var parentName = data['levelOrderName'].split('#')[0];\n        var currentItem = void 0;\n        for (var i = 0; i < treeMap.layout.renderItems.length; i++) {\n            currentItem = treeMap.layout.renderItems[i];\n            if ((currentItem['levelOrderName']).indexOf(parentName) > -1 && items.indexOf(currentItem['levelOrderName']) === -1) {\n                items.push(currentItem['levelOrderName']);\n            }\n        }\n    }\n    else {\n        items.push(data['levelOrderName']);\n    }\n    return items;\n}\n/**\n * Function to compile the template function for maps.\n *\n * @param {string} template - Specifies the template\n * @returns {Function} - Returns the template function\n * @private\n */\nfunction getTemplateFunction(template) {\n    var templateFn = null;\n    try {\n        if (typeof template !== 'function' && document.querySelectorAll(template).length) {\n            templateFn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.compile)(document.querySelector(template).innerHTML.trim());\n        }\n        else {\n            templateFn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.compile)(template);\n        }\n    }\n    catch (e) {\n        templateFn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.compile)(template);\n    }\n    return templateFn;\n}\n/**\n * @private\n * @param {HTMLCollection} element - Specifies the element\n * @param {string} labelId - Specifies the label id\n * @param {Object} data - Specifies the data\n * @returns {HTMLElement} - Returns the element\n */\nfunction convertElement(element, labelId, data) {\n    var childElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n        id: labelId\n    });\n    childElement.style.cssText = 'position: absolute;pointer-events: auto;';\n    var elementLength = element.length;\n    while (elementLength > 0) {\n        childElement.appendChild(element[0]);\n        elementLength--;\n    }\n    var templateHtml = childElement.innerHTML;\n    var keys = Object.keys(data);\n    for (var i = 0; i < keys.length; i++) {\n        var regExp = RegExp;\n        templateHtml = templateHtml.replace(new regExp('{{:' + keys[i] + '}}', 'g'), data[keys[i].toString()]);\n    }\n    childElement.innerHTML = templateHtml;\n    return childElement;\n}\n/**\n *\n * @param {Rect} rect - Specifies the area.\n * @param {LabelPosition} position - Specifies the position\n * @param {Size} labelSize - Specifies the label size.\n * @param {string} type - Specifies the type.\n * @param {TreeMap} treemap - Specifies the treemap instance.\n * @returns {Location} - Returns the text location.\n */\nfunction findLabelLocation(rect, position, labelSize, type, treemap) {\n    var location = new Location(0, 0);\n    var padding = 5;\n    var paddings = 2;\n    var x = (type === 'Template') ? treemap.areaRect.x : 0;\n    var y = (type === 'Template') ? treemap.areaRect.y : 0;\n    location.x = (Math.abs(x - ((position.indexOf('Left') > -1) ? rect.x + padding : !(position.indexOf('Right') > -1) ?\n        rect.x + ((rect.width / 2) - (labelSize.width / 2)) : (rect.x + rect.width) - labelSize.width))) - paddings;\n    if (treemap.enableDrillDown && (treemap.renderDirection === 'BottomLeftTopRight'\n        || treemap.renderDirection === 'BottomRightTopLeft')) {\n        location.y = Math.abs((rect.y + rect.height) - labelSize.height + padding);\n    }\n    else {\n        location.y = Math.abs(y - ((position.indexOf('Top') > -1) ? (type === 'Template' ? rect.y : rect.y + labelSize.height) :\n            !(position.indexOf('Bottom') > -1) ? type === 'Template' ? (rect.y + ((rect.height / 2) - (labelSize.height / 2))) :\n                (rect.y + (rect.height / 2) + labelSize.height / 4) : (rect.y + rect.height) - labelSize.height));\n    }\n    return location;\n}\n/**\n *\n * @param {HTMLElement} element - Specifies the element to be measured.\n * @param {HTMLElement} parentElement - Specifies the parent element of the element to be measured.\n * @returns {Size} - Returns the element size.\n */\nfunction measureElement(element, parentElement) {\n    var size = new Size(0, 0);\n    parentElement.appendChild(element);\n    size.height = element.offsetHeight;\n    size.width = element.offsetWidth;\n    var measureElementId = document.getElementById(element.id);\n    measureElementId.parentNode.removeChild(measureElementId);\n    return size;\n}\n/**\n *\n * @param {Rect} rect - Specifies the area.\n * @returns {number} - Returns the area width.\n */\nfunction getArea(rect) {\n    return (rect.width - rect.x) * (rect.height - rect.y);\n}\n/**\n *\n * @param {Rect} input - Specifies input for the calculation.\n * @returns {number} - Returns the shortest edge.\n */\nfunction getShortestEdge(input) {\n    var container = convertToContainer(input);\n    var width = container.width;\n    var height = container.height;\n    var result = Math.min(width, height);\n    return result;\n}\n/**\n *\n * @param {Rect} rect - Specifies the rectangle bounds of the container.\n * @returns {Rect} - Returns the rectangle bounds.\n */\nfunction convertToContainer(rect) {\n    var x = rect.x;\n    var y = rect.y;\n    var width = rect.width;\n    var height = rect.height;\n    return {\n        x: x,\n        y: y,\n        width: width - x,\n        height: height - y\n    };\n}\n/**\n *\n * @param {Rect} container - Specifies the rectangle bounds of the container.\n * @returns {Rect} - Returns the rectangle bounds.\n */\nfunction convertToRect(container) {\n    var xOffset = container.x;\n    var yOffset = container.y;\n    var width = container.width;\n    var height = container.height;\n    return {\n        x: xOffset,\n        y: yOffset,\n        width: xOffset + width,\n        height: yOffset + height\n    };\n}\n/**\n *\n * @param {number} pageX - Specifies the horizontal position of the mouse location.\n * @param {number} pageY - Specifies the vertical position of the mouse location.\n * @param {Element} element - Specifies the element to which the click is done.\n * @returns {Location} - Returns the clicked location.\n */\nfunction getMousePosition(pageX, pageY, element) {\n    var elementRect = element.getBoundingClientRect();\n    var pageXOffset = element.ownerDocument.defaultView.pageXOffset;\n    var pageYOffset = element.ownerDocument.defaultView.pageYOffset;\n    var clientTop = element.ownerDocument.documentElement.clientTop;\n    var clientLeft = element.ownerDocument.documentElement.clientLeft;\n    var positionX = elementRect.left + pageXOffset - clientLeft;\n    var positionY = elementRect.top + pageYOffset - clientTop;\n    return new Location((pageX - positionX), (pageY - positionY));\n}\n/**\n *\n * @param {ColorMappingModel[]} colorMapping - Specifies the color mapping instance.\n * @param {string} equalValue - Specifies the equal value.\n * @param {number | string} value - Specifies the range value.\n * @returns {any} - Returns the color mapping object.\n * @private\n */\nfunction colorMap(colorMapping, equalValue, value) {\n    var fill;\n    var paths = [];\n    var opacity;\n    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(equalValue) && ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value) && isNaN(value))) {\n        return null;\n    }\n    for (var i = 0; i < colorMapping.length; i++) {\n        var isEqualColor = false;\n        var dataValue = value;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].from) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].to)\n            && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].value)) {\n            if ((value >= colorMapping[i].from && colorMapping[i].to >= value) &&\n                (colorMapping[i].value === equalValue)) {\n                isEqualColor = true;\n                if (Object.prototype.toString.call(colorMapping[i].color) === '[object Array]') {\n                    fill = !isEqualColor ? colorCollections(colorMapping[i], dataValue) : colorMapping[i].color[0];\n                }\n                else {\n                    fill = colorMapping[i].color;\n                }\n            }\n        }\n        else if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].from) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].to))\n            || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)((colorMapping[i].value))) {\n            if ((value >= colorMapping[i].from && colorMapping[i].to >= value)\n                || (colorMapping[i].value === equalValue)) {\n                if (colorMapping[i].value === equalValue) {\n                    isEqualColor = true;\n                }\n                if (Object.prototype.toString.call(colorMapping[i].color) === '[object Array]') {\n                    fill = !isEqualColor ? colorCollections(colorMapping[i], dataValue) : colorMapping[i].color[0];\n                }\n                else {\n                    fill = colorMapping[i].color;\n                }\n            }\n        }\n        if (((value >= colorMapping[i].from && value <= colorMapping[i].to)\n            || (colorMapping[i].value === equalValue))\n            && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].minOpacity) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].maxOpacity)\n            && fill) {\n            opacity = deSaturationColor(colorMapping[i], value);\n        }\n        if ((fill === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(fill))\n            && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].from) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].to)\n            && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].minOpacity) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].maxOpacity)\n            && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(colorMapping[i].value)) {\n            fill = (Object.prototype.toString.call(colorMapping[i].color) === '[object Array]') ?\n                colorMapping[i].color[0] : colorMapping[i].color;\n        }\n        opacity = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(opacity) ? opacity : '1';\n        paths.push(fill);\n    }\n    for (var j = paths.length - 1; j >= 0; j--) {\n        fill = paths[j];\n        j = (fill) ? -1 : j;\n    }\n    return { fill: fill, opacity: opacity };\n}\n/**\n *\n * @param {ColorMappingModel} colorMapping - Specifies the color mapping object.\n * @param {number} rangeValue - Specifies the range value.\n * @returns {string} - Returns the opacity for the color mapping.\n * @private\n */\nfunction deSaturationColor(colorMapping, rangeValue) {\n    var opacity = 1;\n    if ((rangeValue >= colorMapping.from && rangeValue <= colorMapping.to)) {\n        var ratio = (rangeValue - colorMapping.from) / (colorMapping.to - colorMapping.from);\n        opacity = (ratio * (colorMapping.maxOpacity - colorMapping.minOpacity)) + colorMapping.minOpacity;\n    }\n    return opacity.toString();\n}\n/**\n *\n * @param {ColorMappingModel} colorMap - Specifies the color mapping object.\n * @param {number} value - Specifies the range value.\n * @returns {string} - Returns the fill color.\n */\nfunction colorCollections(colorMap, value) {\n    var gradientFill = getColorByValue(colorMap, value);\n    return gradientFill;\n}\n/**\n *\n * @param {number} r - Specifies the red color value.\n * @param {number} g - Specifies the green color value.\n * @param {number} b - Specifies the blue color value.\n * @returns {string} - Returns the fill color.\n */\nfunction rgbToHex(r, g, b) {\n    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\n/**\n *\n * @param {ColorMappingModel} colorMap - Specifies the color mapping.\n * @param {number} value - Specifies the range value.\n * @returns {string} - Returns the fill color.\n */\nfunction getColorByValue(colorMap, value) {\n    var color = '';\n    var rbg;\n    if (Number(value) === colorMap.from) {\n        color = colorMap.color[0];\n    }\n    else if (Number(value) === colorMap.to) {\n        color = colorMap.color[colorMap.color.length - 1];\n    }\n    else {\n        rbg = getGradientColor(Number(value), colorMap);\n        color = rgbToHex(rbg.r, rbg.g, rbg.b);\n    }\n    return color;\n}\n/**\n *\n * @param {number} value - Specifies the range value.\n * @param {ColorMappingModel} colorMap - Specifies the color mapping.\n * @returns {ColorValue} - Returns the color value object.\n */\nfunction getGradientColor(value, colorMap) {\n    var previousOffset = colorMap.from;\n    var nextOffset = colorMap.to;\n    var percent = 0;\n    var full = nextOffset - previousOffset;\n    var midColor;\n    percent = (value - previousOffset) / full;\n    var previousColor;\n    var nextColor;\n    if (colorMap.color.length <= 2) {\n        previousColor = colorMap.color[0].charAt(0) === '#' ? colorMap.color[0] : colorNameToHex(colorMap.color[0]);\n        nextColor = colorMap.color[colorMap.color.length - 1].charAt(0) === '#' ?\n            colorMap.color[colorMap.color.length - 1] : colorNameToHex(colorMap.color[colorMap.color.length - 1]);\n    }\n    else {\n        previousColor = colorMap.color[0].charAt(0) === '#' ? colorMap.color[0] : colorNameToHex(colorMap.color[0]);\n        nextColor = colorMap.color[colorMap.color.length - 1].charAt(0) === '#' ?\n            colorMap.color[colorMap.color.length - 1] : colorNameToHex(colorMap.color[colorMap.color.length - 1]);\n        var a = full / (colorMap.color.length - 1);\n        var b = void 0;\n        var c = void 0;\n        var length_1 = colorMap.color.length - 1;\n        var splitColorValueOffset = [];\n        var splitColor = {};\n        for (var j = 1; j < length_1; j++) {\n            c = j * a;\n            b = previousOffset + c;\n            splitColor = { b: b, color: colorMap.color[j] };\n            splitColorValueOffset.push(splitColor);\n        }\n        for (var i = 0; i < splitColorValueOffset.length; i++) {\n            if (previousOffset <= value && value <= splitColorValueOffset[i]['b'] && i === 0) {\n                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\n                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n                nextColor = midColor;\n                percent = value < splitColorValueOffset[i]['b'] ? 1 - Math.abs((value - splitColorValueOffset[i]['b']) / a)\n                    : (value - splitColorValueOffset[i]['b']) / a;\n            }\n            else if (splitColorValueOffset[i]['b'] <= value && value <= nextOffset && i === (splitColorValueOffset.length - 1)) {\n                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\n                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n                previousColor = midColor;\n                percent = value < splitColorValueOffset[i]['b'] ?\n                    1 - Math.abs((value - splitColorValueOffset[i]['b']) / a) : (value - splitColorValueOffset[i]['b']) / a;\n            }\n            if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {\n                if (splitColorValueOffset[i]['b'] <= value && value <= splitColorValueOffset[i + 1]['b']) {\n                    midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\n                        splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n                    previousColor = midColor;\n                    nextColor = splitColorValueOffset[i + 1]['color'].charAt(0) === '#' ?\n                        splitColorValueOffset[i + 1]['color'] : colorNameToHex(splitColorValueOffset[i + 1]['color']);\n                    percent = Math.abs((value - splitColorValueOffset[i + 1]['b'])) / a;\n                }\n            }\n        }\n    }\n    return getPercentageColor(percent, previousColor, nextColor);\n}\n/**\n *\n * @param {number} percent - Specifies the percentage of the color.\n * @param {number} previous - Specifies the previous color.\n * @param {number} next - Specifies the next color.\n * @returns {ColorValue} - Returns the color value object.\n */\nfunction getPercentageColor(percent, previous, next) {\n    var nextColor = next.split('#')[1];\n    var prevColor = previous.split('#')[1];\n    var r = getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));\n    var g = getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));\n    var b = getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));\n    return new ColorValue(r, g, b);\n}\n/**\n *\n * @param {number} percent - Specifies the percentage of the color.\n * @param {number} previous - Specifies the previous color.\n * @param {number} next - Specifies the next color.\n * @returns {number} - Returns the color value.\n */\nfunction getPercentage(percent, previous, next) {\n    var full = next - previous;\n    return Math.round((previous + (full * percent)));\n}\n/**\n *\n * @param {number} maximumWidth - Specifies the length of the text.\n * @param {string} dataLabel - Specifies the label.\n * @param {FontModel} font - Specifies the font of the label.\n * @returns {string[]} - Returns the labels.\n */\nfunction wordWrap(maximumWidth, dataLabel, font) {\n    var textCollection = dataLabel.split(' ');\n    var label = '';\n    var labelCollection = [];\n    var text;\n    for (var i = 0, len = textCollection.length; i < len; i++) {\n        text = textCollection[i];\n        if (measureText(label.concat(text), font).width < maximumWidth) {\n            label = label.concat((label === '' ? '' : ' ') + text);\n        }\n        else {\n            if (label !== '') {\n                labelCollection.push(textTrim(maximumWidth, label, font));\n                label = text;\n            }\n            else {\n                labelCollection.push(textTrim(maximumWidth, text, font));\n                text = '';\n            }\n        }\n        if (label && i === len - 1) {\n            labelCollection.push(textTrim(maximumWidth, label, font));\n        }\n    }\n    return labelCollection;\n}\n/**\n *\n * @param {number} maxWidth - Specifies the length of the text.\n * @param {string} label - Specifies the label.\n * @param {FontModel} font - Specifies the font of the label.\n * @returns {string[]} - Returns the labels.\n */\nfunction textWrap(maxWidth, label, font) {\n    var resultText = [];\n    var currentLength = 0;\n    var totalWidth = measureText(label, font).width;\n    var totalLength = label.length;\n    if (maxWidth >= totalWidth) {\n        resultText.push(label);\n        return resultText;\n    }\n    else {\n        for (var i = label.length; i > currentLength; i--) {\n            var sliceString = label.slice(currentLength, i);\n            totalWidth = measureText(sliceString, font).width;\n            if (totalWidth <= maxWidth) {\n                resultText.push(sliceString);\n                currentLength += sliceString.length;\n                if (totalLength === currentLength) {\n                    return resultText;\n                }\n                i = totalLength + 1;\n            }\n        }\n    }\n    return resultText;\n}\n/**\n * hide function\n *\n * @param {number} maxWidth - Specifies the maximum width.\n * @param {number} maxHeight - Specifies the maximum height.\n * @param {string} text - Specifies the text.\n * @param {FontModel} font - Specifies the font.\n * @returns {string} - Returns the hidden text.\n * @private\n */\nfunction hide(maxWidth, maxHeight, text, font) {\n    var hideText = text;\n    var textSize = measureText(text, font);\n    hideText = (textSize.width > maxWidth || textSize.height > maxHeight) ? ' ' : text;\n    return hideText;\n}\n/**\n *\n * @param {number} a - Specifies the first value of the leaf.\n * @param {number} b - Specifies the second value of the leaf.\n * @returns {number} - Returns whether values are equal or not.\n */\nfunction orderByArea(a, b) {\n    if (a['itemArea'] === b['itemArea']) {\n        return 0;\n    }\n    else if (a['itemArea'] < b['itemArea']) {\n        return 1;\n    }\n    return -1;\n}\n/**\n *\n * @param {TreeMap} treemap - Specifies the treemap instance.\n * @param {Element} element - Specifies the selected TreeMap leaf item.\n * @param {string} className -Specifies the selected class name.\n * @returns {void}\n */\nfunction maintainSelection(treemap, element, className) {\n    var elementId = treemap.levelSelection;\n    if (elementId) {\n        for (var index = 0; index < elementId.length; index++) {\n            if (element.getAttribute('id') === elementId[index] ||\n                element.children[0].id === elementId[index]) {\n                if (element.childElementCount > 0 && element.children[0].id.indexOf('_Group') === -1) {\n                    element.children[0].setAttribute('class', className);\n                    applyOptions(element.childNodes[0], {\n                        border: treemap.selectionSettings.border, fill: treemap.selectionSettings.fill,\n                        opacity: treemap.selectionSettings.opacity\n                    });\n                }\n            }\n            else {\n                element.setAttribute('class', '');\n            }\n        }\n    }\n}\n/**\n *\n * @param {TreeMap} treemap - Specifies the treemap instance.\n * @param {Element} legendGroup - Specifies the selected element.\n * @returns {void}\n */\nfunction legendMaintain(treemap, legendGroup) {\n    var elementId = treemap.legendId;\n    if (elementId) {\n        for (var i = 0; i < elementId.length; i++) {\n            if (treemap.legendSettings.mode === 'Interactive') {\n                for (var j = 0; j < legendGroup.childElementCount; j++) {\n                    if (legendGroup.childNodes[j]['id'] === elementId[i] ||\n                        parseFloat(legendGroup.childNodes[j]['id'].split('Index_')[1]) === parseFloat(elementId[i].split('Index_')[1])) {\n                        var treemapSVGRectElement = legendGroup.childNodes[j];\n                        treemapSVGRectElement.setAttribute('fill', treemap.selectionSettings.fill);\n                        treemapSVGRectElement.setAttribute('opacity', treemap.selectionSettings.opacity);\n                        if (treemapSVGRectElement.id.indexOf('Text') === -1) {\n                            treemapSVGRectElement.setAttribute('stroke-width', (treemap.selectionSettings.border.width).toString());\n                            treemapSVGRectElement.setAttribute('stroke', treemap.selectionSettings.border.color);\n                        }\n                        else {\n                            treemapSVGRectElement.setAttribute('stroke', null);\n                            treemapSVGRectElement.setAttribute('stroke-width', null);\n                        }\n                    }\n                }\n            }\n            else {\n                var legendItem = document.getElementById(elementId[i]);\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(legendItem)) {\n                    legendItem.setAttribute('fill', treemap.selectionSettings.fill);\n                    legendItem.setAttribute('opacity', treemap.selectionSettings.opacity);\n                    if (legendItem.id.indexOf('Text') === -1) {\n                        legendItem.setAttribute('stroke', treemap.selectionSettings.border.color);\n                        legendItem.setAttribute('stroke-width', (treemap.selectionSettings.border.width).toString());\n                    }\n                    else {\n                        legendItem.setAttribute('stroke', null);\n                        legendItem.setAttribute('stroke-width', null);\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n *\n * @param {HTMLCollection} elements - Specifies the selected TreeMap element.\n * @param {string} type - Specifies the selection type.\n * @param {TreeMap} treemap - Specifies the TreeMap instance.\n * @returns {void}\n */\nfunction removeClassNames(elements, type, treemap) {\n    var element;\n    var options = {};\n    for (var j = 0; j < elements.length; j++) {\n        element = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(elements[j].childNodes[0]) ? elements[j] :\n            elements[j].childNodes[0];\n        options = treemap.layout.renderItems[parseFloat(element.id.split('_Item_Index_')[1])]['options'];\n        applyOptions(element, options);\n        elements[j].classList.remove(type);\n        j -= 1;\n    }\n}\n/**\n *\n * @param {SVGPathElement} element - Specifies the SVG path element.\n * @param {any} options - Specifies the settings for the SVG path element.\n * @returns {void}\n */\nfunction applyOptions(element, options) {\n    element.setAttribute('opacity', options['opacity']);\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(options['fill'])) {\n        element.setAttribute('fill', options['fill']);\n    }\n    else {\n        element.setAttribute('fill', 'black');\n    }\n    element.setAttribute('stroke', options['border']['color']);\n    element.setAttribute('stroke-width', options['border']['width']);\n}\n/**\n *\n * @param {string} format - Specifies the format value.\n * @param {any} data - Specifies the data source object.\n * @param {TreeMap} treemap - Specifies the TreeMap instance.\n * @returns {string} - Returns the formatted text.\n */\nfunction textFormatter(format, data, treemap) {\n    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(format)) {\n        return null;\n    }\n    var keys = Object.keys(data);\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        format = format.split('${' + key + '}').join(formatValue(data[key], treemap).toString());\n    }\n    return format;\n}\n/**\n *\n * @param {number} value - Specifies the text to be formatted.\n * @param {TreeMap} treemap - Specifies the TreeMap instance.\n * @returns {string | number} - Returns the formatted text.\n */\nfunction formatValue(value, treemap) {\n    var formatValue;\n    var formatFunction;\n    if (treemap.format && !isNaN(Number(value))) {\n        formatFunction = treemap.intl.getNumberFormat({ format: treemap.format, useGrouping: treemap.useGroupingSeparator });\n        formatValue = formatFunction(Number(value));\n    }\n    else {\n        formatValue = value;\n    }\n    return formatValue ? formatValue : '';\n}\n/**\n * @private\n */\nvar ColorValue = /** @class */ (function () {\n    function ColorValue(r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n    return ColorValue;\n}());\n\n/**\n * @param {ColorValue} value - Specfies the color value\n * @returns {string} - Returns the string\n * @private\n */\nfunction convertToHexCode(value) {\n    return '#' + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);\n}\n/**\n * @param {number} value - Specifies the value\n * @returns {string} - Returns the string\n * @private */\nfunction componentToHex(value) {\n    var hex = value.toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n}\n/**\n * @param {string} hex - Specifies the hex value\n * @returns {ColorValue} - Returns the color value\n * @private\n */\nfunction convertHexToColor(hex) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) :\n        new ColorValue(255, 255, 255);\n}\n/**\n * @param {string} color - Specifies the color\n * @returns {string} - Returns the string\n * @private\n */\nfunction colorNameToHex(color) {\n    color = color === 'transparent' ? 'white' : color;\n    var element = document.getElementById('treeMapMeasureText');\n    element.style.color = color;\n    color = window.getComputedStyle(element).color;\n    var isRGBValue = color.replace(/[()RGBrgba ]/g, '').split(',');\n    return convertToHexCode(new ColorValue(parseInt(isRGBValue[0], 10), parseInt(isRGBValue[1], 10), parseInt(isRGBValue[2], 10)));\n}\n/**\n * @param {Location} location - Specifies the location\n * @param {string} shape - Specifies the shape\n * @param {Size} size - Specifies the size\n * @param {string} url - Specifies the url\n * @param {PathOption} options - Specifies the options\n * @returns {Element} - Returns the element\n * @private\n */\nfunction drawSymbol(location, shape, size, url, options) {\n    var svgRenderer = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.SvgRenderer('');\n    var temp = renderLegendShape(location, size, shape, options, url);\n    var htmlElement = svgRenderer['draw' + temp.functionName](temp.renderOption);\n    return htmlElement;\n}\n/**\n * @param {Location} location - Specifies the location\n * @param {Size} size - Specifies the size\n * @param {string} shape - Specifies the shape\n * @param {PathOption} options - Specifies the path option\n * @param {string} url - Specifies the string\n * @returns {IShapes} - Returns the shapes\n * @private\n */\nfunction renderLegendShape(location, size, shape, options, url) {\n    var renderPath;\n    var functionName = 'Path';\n    var shapeWidth = size.width;\n    var shapeHeight = size.height;\n    var shapeX = location.x;\n    var shapeY = location.y;\n    var x = location.x + (-shapeWidth / 2);\n    var y = location.y + (-shapeHeight / 2);\n    switch (shape) {\n        case 'Circle':\n        case 'Bubble':\n            functionName = 'Ellipse';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'rx': shapeWidth / 2, 'ry': shapeHeight / 2, 'cx': shapeX, 'cy': shapeY });\n            break;\n        case 'VerticalLine':\n            renderPath = 'M' + ' ' + shapeX + ' ' + (shapeY + (shapeHeight / 2)) + ' ' + 'L' + ' ' + shapeX + ' '\n                + (shapeY + (-shapeHeight / 2));\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'Diamond':\n            renderPath = 'M' + ' ' + x + ' ' + shapeY + ' ' +\n                'L' + ' ' + shapeX + ' ' + (shapeY + (-shapeHeight / 2)) + ' ' +\n                'L' + ' ' + (shapeX + (shapeWidth / 2)) + ' ' + shapeY + ' ' +\n                'L' + ' ' + shapeX + ' ' + (shapeY + (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + shapeY + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'Rectangle':\n            renderPath = 'M' + ' ' + x + ' ' + (shapeY + (-shapeHeight / 2)) + ' ' +\n                'L' + ' ' + (shapeX + (shapeWidth / 2)) + ' ' + (shapeY + (-shapeHeight / 2)) + ' ' +\n                'L' + ' ' + (shapeX + (shapeWidth / 2)) + ' ' + (shapeY + (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + (shapeY + (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + (shapeY + (-shapeHeight / 2)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'Triangle':\n            renderPath = 'M' + ' ' + x + ' ' + (shapeY + (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + shapeX + ' ' + (shapeY + (-shapeHeight / 2)) + ' ' +\n                'L' + ' ' + (shapeX + (shapeWidth / 2)) + ' ' + (shapeY + (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + (shapeY + (shapeHeight / 2)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'InvertedTriangle':\n            renderPath = 'M' + ' ' + (shapeX + (shapeWidth / 2)) + ' ' + (shapeY - (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + shapeX + ' ' + (shapeY + (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + (shapeX - (shapeWidth / 2)) + ' ' + (shapeY - (shapeHeight / 2)) + ' ' +\n                'L' + ' ' + (shapeX + (shapeWidth / 2)) + ' ' + (shapeY - (shapeHeight / 2)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'Pentagon':\n            // eslint-disable-next-line no-case-declarations\n            var eq = 72;\n            // eslint-disable-next-line no-case-declarations\n            var xValue = void 0;\n            // eslint-disable-next-line no-case-declarations\n            var yValue = void 0;\n            for (var i = 0; i <= 5; i++) {\n                xValue = (shapeWidth / 2) * Math.cos((Math.PI / 180) * (i * eq));\n                yValue = (shapeWidth / 2) * Math.sin((Math.PI / 180) * (i * eq));\n                if (i === 0) {\n                    renderPath = 'M' + ' ' + (shapeX + xValue) + ' ' + (shapeY + yValue) + ' ';\n                }\n                else {\n                    renderPath = renderPath.concat('L' + ' ' + (shapeX + xValue) + ' ' + (shapeY + yValue) + ' ');\n                }\n            }\n            renderPath = renderPath.concat('Z');\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'Star':\n            renderPath = 'M ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + (location.x - size.width / 2)\n                + ' ' + (location.y + size.height / 6) + ' L ' + (location.x + size.width / 2) + ' ' + (location.y + size.height / 6)\n                + ' L ' + (location.x - size.width / 3) + ' ' + (location.y - size.height / 2) + ' L ' + location.x + ' ' +\n                (location.y + size.height / 2) + ' L ' + (location.x + size.width / 3) + ' ' + (location.y - size.height / 2) + ' Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'Cross':\n            renderPath = 'M' + ' ' + x + ' ' + shapeY + ' ' + 'L' + ' ' + (shapeX + (shapeWidth / 2)) + ' ' + shapeY + ' ' +\n                'M' + ' ' + shapeX + ' ' + (shapeY + (shapeHeight / 2)) + ' ' + 'L' + ' ' + shapeX + ' ' +\n                (shapeY + (-shapeHeight / 2));\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': renderPath });\n            break;\n        case 'Image':\n            functionName = 'Image';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'href': url, 'height': shapeHeight, 'width': shapeWidth, x: x, y: y });\n            break;\n    }\n    return { renderOption: options, functionName: functionName };\n}\n/**\n *\n * @param {any} data - Specifies the data source object.\n * @param {any} item - Specifies the leaf item.\n * @returns {boolean} - Returns whether the TreeMap item is level item or leaf item.\n */\nfunction isParentItem(data, item) {\n    var isParentItem = false;\n    for (var j = 0; j < data.length; j++) {\n        if (item['levelOrderName'] === data[j]['levelOrderName']) {\n            isParentItem = true;\n            break;\n        }\n    }\n    return isParentItem;\n}\n/**\n * Specifies the data to be received through Ajax request for treemap.\n */\nvar TreeMapAjax = /** @class */ (function () {\n    function TreeMapAjax(options, type, async, contentType, sendData) {\n        this.dataOptions = options;\n        this.type = type || 'GET';\n        this.async = async || true;\n        this.contentType = contentType;\n        this.sendData = sendData;\n    }\n    return TreeMapAjax;\n}());\n\n/**\n *\n * @param {any[]} collection - Specifies the legend collection.\n * @returns {void}\n * @private\n */\nfunction removeShape(collection) {\n    if (collection.length > 0) {\n        for (var i = 0; i < collection.length; i++) {\n            var item = collection[i];\n            setColor(item['legendEle'], item['oldFill'], item['oldOpacity'], item['oldBorderColor'], item['oldBorderWidth']);\n        }\n    }\n}\n/**\n *\n * @param {any[]} collection - Specifies the legend collection.\n * @param {TreeMap} treeMap - Specifies the treemap instance.\n * @returns {void}\n * @private\n */\nfunction removeLegend(collection, treeMap) {\n    if (collection.length > 0) {\n        for (var j = 0; j < collection.length; j++) {\n            var item = collection[j];\n            var legendIndex = parseFloat(item['legendEle'].id.split('_Index_')[1]);\n            var isText = item['legendEle'].id.indexOf('Text') > -1;\n            var shapeId = isText ? item['legendEle'].id.replace('_Text', '') : item['legendEle'].id;\n            var legendShape = treeMap.legendSettings.mode === 'Interactive'\n                ? document.getElementById(shapeId)\n                : document.getElementById(treeMap.element.id + '_Legend_Shape_Index_' + legendIndex);\n            var legendText = treeMap.legendSettings.mode === 'Interactive'\n                ? document.getElementById(shapeId + '_Text')\n                : document.getElementById(treeMap.element.id + '_Legend_Text_Index_' + legendIndex);\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(legendShape)) {\n                setColor(legendShape, item['oldFill'], item['oldOpacity'], 'none', '0px');\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(legendText)) {\n                setColor(legendText, treeMap.legendSettings.textStyle.color || treeMap.themeStyle.legendTextColor, item['oldOpacity'], null, null);\n            }\n            var dataCount = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(item['ShapeCollection']) ? item['ShapeCollection']['Elements'].length : 0;\n            for (var k = 0; k < dataCount; k++) {\n                var shapeElement = document.getElementById(item['ShapeCollection']['Elements'][k].id);\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shapeElement)) {\n                    setColor(shapeElement, item['shapeOldFill'], item['shapeOldOpacity'], item['shapeOldBorderColor'], item['shapeOldBorderWidth']);\n                }\n            }\n        }\n    }\n}\n/**\n *\n * @param {Element} element - Specifies the selected element.\n * @param {string} fill - Specifies the fill color.\n * @param {string} opacity - Specifies the opacity.\n * @param {string} borderColor - Specifies the border color.\n * @param {string} borderWidth - Specifies the border width.\n * @returns {void}\n */\nfunction setColor(element, fill, opacity, borderColor, borderWidth) {\n    element.setAttribute('fill', fill);\n    element.setAttribute('opacity', opacity);\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(borderColor)) {\n        element.setAttribute('stroke', borderColor);\n    }\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(borderWidth)) {\n        element.setAttribute('stroke-width', borderWidth);\n    }\n}\n/**\n *\n * @param {any[]} collection - Specifies the selected item collection.\n * @param {any[]} element - Specifies the selected element collection.\n * @param {TreeMap} treemap - Specifies the TreeMap instance.\n * @returns {void}\n */\nfunction removeSelectionWithHighlight(collection, element, treemap) {\n    removeLegend(collection, treemap);\n    element = [];\n    removeClassNames(document.getElementsByClassName('treeMapHighLight'), 'treeMapHighLight', treemap);\n}\n/**\n *\n * @param {number} length - Specifies the length of the legend group.\n * @param {any} item - Specifies the legend item.\n * @param {TreeMap} treemap - Specifies the TreeMap instance.\n * @returns {number} - Returns the legend index.\n */\nfunction getLegendIndex(length, item, treemap) {\n    var index;\n    var valuePath = (treemap.rangeColorValuePath !== '') ? treemap.rangeColorValuePath : null;\n    var indexFound = false;\n    for (var i = 0; i < length && !indexFound; i++) {\n        var dataLength = treemap.treeMapLegendModule.legendCollections[i]['legendData'].length;\n        if (dataLength > 0) {\n            for (var j = 0; j < dataLength; j++) {\n                if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(valuePath) && treemap.leafItemSettings.colorMapping.length > 0 ?\n                    (treemap.treeMapLegendModule.legendCollections[i]['legendData'][j]['data'][valuePath] === item['data'][valuePath])\n                    : treemap.treeMapLegendModule.legendCollections[i]['legendData'][j]['levelOrderName'] === item['levelOrderName']\n                        || item['levelOrderName'].indexOf(treemap.treeMapLegendModule.legendCollections[i]['legendName']) > -1)) {\n                    index = i;\n                    indexFound = true;\n                    break;\n                }\n            }\n        }\n        else if (treemap.palette && treemap.palette.length > 0) {\n            if ((treemap.treeMapLegendModule.legendCollections[i]['levelOrderName'] === item['levelOrderName'] ||\n                (item['levelOrderName'].indexOf(treemap.treeMapLegendModule.legendCollections[i]['levelOrderName'])) > -1)\n                && treemap.treeMapLegendModule.legendCollections[i]['legendName'] === item['name']) {\n                index = i;\n                break;\n            }\n        }\n    }\n    return index;\n}\n/**\n *\n * @param {any[]} collection - Specifies the legend collection.\n * @param {number} index - Specifies the index of legend.\n * @param {number} number - Specifies the leaf item index.\n * @param {Element} legendElement - Specifies the legend element.\n * @param {Element} shapeElement - Specifies the shape element.\n * @param {any[]} renderItems - Specifies the item index.\n * @param {any[]} legendCollection - Specifies the legend collection.\n * @returns {void}\n */\nfunction pushCollection(collection, index, number, legendElement, shapeElement, renderItems, legendCollection) {\n    collection.push({\n        legendEle: legendElement, oldFill: legendCollection[index]['legendFill'],\n        oldOpacity: legendCollection[index]['opacity'], oldBorderColor: legendCollection[index]['borderColor'],\n        oldBorderWidth: legendCollection[index]['borderWidth'],\n        shapeElement: shapeElement, shapeOldFill: renderItems[number]['options']['fill'],\n        shapeOldOpacity: renderItems[number]['options']['opacity'],\n        shapeOldBorderColor: renderItems[number]['options']['border']['color'],\n        shapeOldBorderWidth: renderItems[number]['options']['border']['width']\n    });\n}\n/**\n * To trigger the download element\n *\n * @param {string} fileName - Specifies the file name\n * @param {ExportType} type - Specifies the type\n * @param {string} url - Specifies the url\n * @param {boolean} isDownload - Specifies the boolean value\n * @returns {void}\n * @private\n */\nfunction triggerDownload(fileName, type, url, isDownload) {\n    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('a', {\n        attrs: {\n            'download': fileName + '.' + type.toLocaleLowerCase(),\n            'href': url\n        }\n    }).dispatchEvent(new MouseEvent(isDownload ? 'click' : 'move', {\n        view: window,\n        bubbles: false,\n        cancelable: true\n    }));\n}\n/**\n *\n * @param {string} id - Specifies the id of the element to be removed.\n * @returns {void}\n */\nfunction removeElement(id) {\n    var element = document.getElementById(id);\n    return element ? (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(element) : null;\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-treemap/src/treemap/utils/helper.js?");

/***/ })

}]);