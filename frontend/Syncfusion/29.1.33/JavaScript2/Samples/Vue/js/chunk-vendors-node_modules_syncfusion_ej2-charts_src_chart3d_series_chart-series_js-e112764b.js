"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart3d_series_chart-series_js-e112764b"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart3d/series/chart-series.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart3d/series/chart-series.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chart3DDataLabelSettings: () => (/* binding */ Chart3DDataLabelSettings),\n/* harmony export */   Chart3DEmptyPointSettings: () => (/* binding */ Chart3DEmptyPointSettings),\n/* harmony export */   Chart3DPoint: () => (/* binding */ Chart3DPoint),\n/* harmony export */   Chart3DSeries: () => (/* binding */ Chart3DSeries)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/model/base */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/base.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _model_chart3d_Interface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../model/chart3d-Interface */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/model/chart3d-Interface.js\");\n/* harmony import */ var _utils_chart3dRender__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/chart3dRender */ \"./node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Configures the data label in the series.\n */\nvar Chart3DDataLabelSettings = /** @class */ (function (_super) {\n    __extends(Chart3DDataLabelSettings, _super);\n    function Chart3DDataLabelSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], Chart3DDataLabelSettings.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DDataLabelSettings.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('transparent')\n    ], Chart3DDataLabelSettings.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DDataLabelSettings.prototype, \"format\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], Chart3DDataLabelSettings.prototype, \"opacity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Chart3DDataLabelSettings.prototype, \"angle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], Chart3DDataLabelSettings.prototype, \"enableRotation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Middle')\n    ], Chart3DDataLabelSettings.prototype, \"position\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ width: null, color: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Border)\n    ], Chart3DDataLabelSettings.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ left: 5, right: 5, top: 5, bottom: 5 }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Margin)\n    ], Chart3DDataLabelSettings.prototype, \"margin\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ size: null, color: null, fontStyle: null, fontWeight: null, fontFamily: null }, _model_chart3d_Interface__WEBPACK_IMPORTED_MODULE_6__.Chart3DTextFont)\n    ], Chart3DDataLabelSettings.prototype, \"font\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DDataLabelSettings.prototype, \"template\", void 0);\n    return Chart3DDataLabelSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Configures the Empty Points of series\n */\nvar Chart3DEmptyPointSettings = /** @class */ (function (_super) {\n    __extends(Chart3DEmptyPointSettings, _super);\n    function Chart3DEmptyPointSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DEmptyPointSettings.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Gap')\n    ], Chart3DEmptyPointSettings.prototype, \"mode\", void 0);\n    return Chart3DEmptyPointSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Points model for the series.\n *\n * @public\n */\nvar Chart3DPoint = /** @class */ (function () {\n    function Chart3DPoint() {\n        /** Point symbol location. */\n        this.symbolLocations = null;\n        /** Point percentage value. */\n        this.percentage = null;\n        /** To know the point is selected. */\n        this.isSelect = false;\n    }\n    return Chart3DPoint;\n}());\n\n/**\n * Configures the series in charts.\n *\n * @public\n */\nvar Chart3DSeries = /** @class */ (function (_super) {\n    __extends(Chart3DSeries, _super);\n    function Chart3DSeries(parent, propName, defaultValue, isArray) {\n        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n        /** @private */\n        _this.currentViewData = [];\n        /** @private */\n        _this.clipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, 0, 0);\n        _this.visibleSeriesCount = 0;\n        /** @private */\n        _this.category = 'Series';\n        /** @private */\n        _this.isRectSeries = false;\n        /** @private */\n        _this.all = false;\n        return _this;\n    }\n    /**\n     * This method is responsible for handling and processing JSON data.\n     *\n     * @returns {void}\n     * @hidden\n     */\n    Chart3DSeries.prototype.processJsonData = function () {\n        var i = 0;\n        var point = new Chart3DPoint();\n        var xName = this.xName;\n        var textMappingName = this instanceof Chart3DSeries && this.dataLabel.name ?\n            this.dataLabel.name : '';\n        var len = (this.currentViewData || []).length;\n        this.points = [];\n        this.xMin = Infinity;\n        this.xMax = -Infinity;\n        this.yMin = Infinity;\n        this.yMax = -Infinity;\n        this.sizeMax = -Infinity;\n        if (this.xAxis.valueType === 'Category') {\n            while (i < len) {\n                point = this.dataPoint(i, textMappingName, xName);\n                this.pushCategoryData(point, i, point.x);\n                this.pushData(point, i);\n                this.setEmptyPoint(point, i);\n                i++;\n            }\n        }\n        else if (this.xAxis.valueType.indexOf('DateTime') > -1) {\n            var option = {\n                skeleton: 'full',\n                type: 'dateTime'\n            };\n            var dateParser = this.chart.intl.getDateParser(option);\n            var dateFormatter = this.chart.intl.getDateFormat(option);\n            while (i < len) {\n                point = this.dataPoint(i, textMappingName, xName);\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x) && point.x !== '') {\n                    point.x = new Date(_syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.DataUtil.parse.parseJson({ val: point.x }).val);\n                    if (this.xAxis.valueType === 'DateTime') {\n                        point.xValue = Date.parse(point.x.toString());\n                    }\n                    else {\n                        this.pushCategoryData(point, i, Date.parse(dateParser(dateFormatter(point.x))).toString());\n                    }\n                    this.pushData(point, i);\n                    this.setEmptyPoint(point, i);\n                }\n                else {\n                    point.visible = false;\n                }\n                i++;\n            }\n        }\n        else {\n            while (i < len) {\n                point = this.dataPoint(i, textMappingName, xName);\n                point.xValue = point.x;\n                this.pushData(point, i);\n                this.setEmptyPoint(point, i);\n                i++;\n            }\n        }\n    };\n    /**\n     * Pushes data into a collection at a specified index.\n     *\n     * @param {Chart3DPoint} point - The Chart3DPoint object representing the data to be pushed.\n     * @param {number} i - The index at which the data should be pushed.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.pushData = function (point, i) {\n        point.index = i;\n        point.yValue = point.y;\n        point.series = this;\n        // To find the min, max for the axis range.\n        this.xMin = Math.min(this.xMin, point.xValue);\n        this.xMax = Math.max(this.xMax, point.xValue);\n        this.xData.push(point.xValue);\n    };\n    /**\n     * Creates and returns a Chart3DPoint object representing a data point at the specified index.\n     *\n     * @param {number} i - The index of the data point.\n     * @param {string} textMappingName - The name of the property containing text information for the data point.\n     * @param {string} xName - The name of the property containing X-axis information for the data point.\n     * @returns {Chart3DPoint} - The Chart3DPoint object representing the data point.\n     */\n    Chart3DSeries.prototype.dataPoint = function (i, textMappingName, xName) {\n        this.points[i] = new Chart3DPoint();\n        var point = this.points[i];\n        var currentViewData = this.currentViewData[i];\n        var getObjectValueByMappingString = this.get3DObjectValue;\n        point.x = getObjectValueByMappingString(xName, currentViewData);\n        point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData);\n        if (this instanceof Chart3DSeries) {\n            point.y = getObjectValueByMappingString(this.yName, currentViewData);\n            point.size = getObjectValueByMappingString(this.size, currentViewData);\n            point.text = getObjectValueByMappingString(textMappingName, currentViewData);\n            point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData);\n        }\n        return point;\n    };\n    /**\n     * Retrieves the value associated with a specified mapping name from a given data object.\n     *\n     * @param {string} mappingName - The mapping name used to retrieve the value from the data object.\n     * @param {Object} data - The data object from which the value is retrieved.\n     * @returns {Object} - The value associated with the specified mapping name in the data object.\n     */\n    Chart3DSeries.prototype.get3DObjectValue = function (mappingName, data) {\n        return data[mappingName];\n    };\n    /**\n     * Sets values for an empty data point at the specified index.\n     *\n     * @param {Chart3DPoint} point - The Chart3DPoint object representing the empty data point.\n     * @param {number} i - The index of the empty data point.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.setEmptyPoint = function (point, i) {\n        if (!this.findVisibility(point)) {\n            point.visible = true;\n            return null;\n        }\n        point.isEmpty = true;\n        var series = this instanceof Chart3DSeries && this;\n        var mode = series.emptyPointSettings.mode;\n        switch (mode) {\n            case 'Zero':\n                point.visible = true;\n                point.y = point.yValue = this.yData[i] = 0;\n                break;\n            case 'Average':\n                if (this instanceof Chart3DSeries) {\n                    point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);\n                }\n                point.visible = true;\n                break;\n            case 'Drop':\n            case 'Gap':\n                this.yData[i] = null;\n                point.visible = false;\n                break;\n        }\n    };\n    /**\n     * Determines the visibility status of a Chart3DPoint.\n     *\n     * @param {Chart3DPoint} point - The Chart3DPoint object for which visibility is determined.\n     * @returns {boolean} - A boolean indicating the visibility status of the Chart3DPoint.\n     */\n    Chart3DSeries.prototype.findVisibility = function (point) {\n        this.setXYMinMax(point.yValue);\n        this.yData.push(point.yValue);\n        return (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x) || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y) || isNaN(+point.y));\n    };\n    /**\n     * Sets the minimum and maximum values for the X and Y dimensions based on the provided Y value.\n     *\n     * @param {number} yValue - The Y value used to set the minimum and maximum values for the X and Y dimensions.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.setXYMinMax = function (yValue) {\n        var isLogAxis = (this.yAxis.valueType === 'Logarithmic' || this.xAxis.valueType === 'Logarithmic');\n        var isNegativeValue = yValue < 0 || this.yAxis.rangePadding === 'None';\n        var seriesMinY;\n        if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.yAxis)) {\n            seriesMinY = ((isLogAxis ? (yValue) : isNegativeValue ? yValue : 0));\n        }\n        else {\n            seriesMinY = yValue;\n        }\n        this.yMin = isLogAxis ?\n            Math.min(this.yMin, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(seriesMinY) || isNaN(seriesMinY) || (seriesMinY === 0) ||\n                (seriesMinY.toString() === '0') || (seriesMinY.toString() === '')) ? this.yMin : seriesMinY) :\n            Math.min(this.yMin, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(seriesMinY) || isNaN(seriesMinY)) ? this.yMin : seriesMinY);\n        this.yMax = Math.max(this.yMax, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(yValue) || isNaN(yValue)) ? this.yMax : yValue);\n    };\n    /**\n     * Pushes category data to the Chart3DPoint object at the specified index.\n     *\n     * @param {Chart3DPoint} point - The Chart3DPoint object to which category data is pushed.\n     * @param {number} index - The index at which the category data is pushed.\n     * @param {string} pointX - The X value of the category data to be pushed.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.pushCategoryData = function (point, index, pointX) {\n        if (this.chart.tooltip) {\n            if (!this.visible) {\n                return null;\n            }\n        }\n        if (!this.xAxis.isIndexed) {\n            if (this.xAxis.indexLabels[pointX] === undefined) {\n                this.xAxis.indexLabels[pointX] = this.xAxis.labels.length;\n                this.xAxis.labels.push(pointX);\n            }\n            point.xValue = this.xAxis.indexLabels[pointX];\n        }\n        else {\n            if (this.xAxis.labels[index]) {\n                this.xAxis.labels[index] += ', ' + pointX;\n            }\n            else {\n                this.xAxis.labels.push(pointX);\n            }\n            // this.xAxis.labels[index as number] ? this.xAxis.labels[index as number] += ', ' + pointX :\n            //     this.xAxis.labels.push(pointX);\n            point.xValue = index;\n        }\n    };\n    /**\n     * Calculates the average value of a specified member in the data object.\n     *\n     * @param {string} member - The member for which the average is calculated.\n     * @param {number} i - The index used for the calculation.\n     * @param {Object} data - The data object from which the average is calculated. Defaults to the current view data.\n     * @returns {number} - The calculated average value.\n     */\n    Chart3DSeries.prototype.getAverage = function (member, i, data) {\n        if (data === void 0) { data = this.currentViewData; }\n        var previous = data[i - 1] ? (data[i - 1][member] || 0) : 0;\n        var next = data[i + 1] ? (data[i + 1][member] || 0) : 0;\n        return (previous + next) / 2;\n    };\n    /**\n     * Refreshes the data manager for the 3D chart.\n     *\n     * @param {Chart3D} chart - The 3D chart for which the data manager is refreshed.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.refreshDataManager = function (chart) {\n        var _this = this;\n        this.chart = chart;\n        var dataSource;\n        var isAngular = 'isAngular';\n        if (chart[isAngular]) {\n            dataSource = Object.keys(this.dataSource).length ? this.dataSource : chart.dataSource;\n        }\n        else {\n            dataSource = this.dataSource || chart.dataSource;\n        }\n        if (!(dataSource instanceof _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.DataManager) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.query)) {\n            this.dataManagerSuccess({ result: dataSource, count: dataSource.length }, false);\n            return;\n        }\n        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());\n        dataManager.then(function (e) { return _this.dataManagerSuccess(e); });\n    };\n    /**\n     * Handles the success callback for the data manager operation.\n     *\n     * @param {Object} e - The success callback parameters containing the result and count.\n     * @param {Object} e.result - The result object returned by the data manager operation.\n     * @param {number} e.count - The count of items returned by the data manager operation.\n     * @param {boolean} [isRemoteData=true] - Indicates whether the data is fetched remotely. Defaults to true.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.dataManagerSuccess = function (e, isRemoteData) {\n        if (isRemoteData === void 0) { isRemoteData = true; }\n        this.currentViewData = e.count ? e.result : [];\n        this.chart.allowServerDataBinding = false;\n        if (this instanceof Chart3DSeries) {\n            var argsData = {\n                series: this, data: this.currentViewData, fill: this.interior\n            };\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_5__.seriesRender, argsData);\n            this.interior = argsData.fill;\n            this.currentViewData = argsData.data;\n        }\n        this.processJsonData();\n        this.refreshChart(isRemoteData);\n        this.currentViewData = null;\n    };\n    /**\n     * Refreshes the chart, updating its data and appearance.\n     *\n     * @param {boolean} isRemoteData - Indicates whether the data is fetched remotely.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.refreshChart = function (isRemoteData) {\n        var chart = this.chart;\n        if (this instanceof Chart3DSeries) {\n            chart.visibleSeriesCount += isRemoteData ? 1 : 0;\n        }\n        if (chart.visibleSeries.length === (chart.visibleSeriesCount)) {\n            chart.refreshBound();\n            chart.trigger('loaded', { chart: chart });\n        }\n        if (this instanceof Chart3DSeries) {\n            chart.visibleSeriesCount += isRemoteData ? 0 : 1;\n        }\n    };\n    /**\n     * Refreshes the axis labels in the chart.\n     * This method is responsible for updating and rendering the axis labels based on the chart's current state.\n     *\n     * @returns {void}\n     * @public\n     */\n    Chart3DSeries.prototype.refreshAxisLabel = function () {\n        if (this.xAxis.valueType !== 'Category') {\n            return null;\n        }\n        this.xAxis.labels = [];\n        this.xAxis.indexLabels = {};\n        for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {\n            var item = _a[_i];\n            if (item.visible) {\n                item.xMin = Infinity;\n                item.xMax = -Infinity;\n                for (var _b = 0, _c = item.points; _b < _c.length; _b++) {\n                    var point = _c[_b];\n                    item.pushCategoryData(point, point.index, point.x);\n                    item.xMin = Math.min(item.xMin, point.xValue);\n                    item.xMax = Math.max(item.xMax, point.xValue);\n                }\n            }\n        }\n    };\n    /**\n     * Finds the collection of Chart3DSeries associated with the given Chart3DColumn and Chart3DRow in the 3D chart.\n     *\n     * @param {Chart3DColumn} column - The Chart3DColumn object representing the column in the 3D chart.\n     * @param {Chart3DRow} row - The Chart3DRow object representing the row in the 3D chart.\n     * @param {boolean} isStack - Indicates whether the series should be stacked.\n     * @returns {Chart3DSeries[]} - An array of Chart3DSeries associated with the specified column and row.\n     * @public\n     */\n    Chart3DSeries.prototype.findSeriesCollection = function (column, row, isStack) {\n        var seriesCollection = [];\n        for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {\n            var rowAxis = _a[_i];\n            for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {\n                var rowSeries = _c[_b];\n                for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {\n                    var axis = _e[_d];\n                    for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {\n                        var series = _g[_f];\n                        if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {\n                            seriesCollection.push(series);\n                        }\n                    }\n                }\n            }\n        }\n        return seriesCollection;\n    };\n    /**\n     * Checks whether the given Chart3DSeries with rectangular data is present in the 3D chart.\n     *\n     * @param {Chart3DSeries} series - The Chart3DSeries object to check for presence in the chart.\n     * @param {boolean} isStack - Indicates whether the series should be stacked.\n     * @returns {boolean} - A boolean value indicating whether the series is present in the 3D chart.\n     * @private\n     */\n    Chart3DSeries.prototype.rectSeriesInChart = function (series, isStack) {\n        var type = (series.type).toLowerCase();\n        return type.indexOf('column') !== -1 || type.indexOf('bar') !== -1 || isStack;\n    };\n    /**\n     * Calculates the stacked values for the Chart3DSeries based on stacking type and chart context.\n     *\n     * @param {boolean} isStacking100 - Indicates whether the stacking type is 100% stacking.\n     * @param {Chart3D} chart - The parent Chart3D object providing context for the calculation.\n     * @returns {void}\n     * @private\n     */\n    Chart3DSeries.prototype.calculateStackedValue = function (isStacking100, chart) {\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var columnItem = _a[_i];\n            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n                var item = _c[_b];\n                this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);\n            }\n        }\n    };\n    /**\n     * Calculates stacking values for the given Chart3DSeries collection based on the stacking type.\n     *\n     * @param {Chart3DSeries[]} seriesCollection - The collection of Chart3DSeries to calculate stacking values for.\n     * @param {boolean} isStacking100 - Indicates whether the stacking type is 100% stacking.\n     * @returns {void}\n     * @private\n     */\n    Chart3DSeries.prototype.calculateStackingValues = function (seriesCollection, isStacking100) {\n        var startValues;\n        var endValues;\n        var yValues = [];\n        var lastPositive = [];\n        var lastNegative = [];\n        var stackingGroup;\n        var lastValue;\n        var value;\n        var frequencies = [];\n        if (isStacking100) {\n            frequencies = this.findFrequencies(seriesCollection);\n        }\n        var groupingValues = [];\n        var visiblePoints = [];\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var series = seriesCollection[i];\n            if (!groupingValues[series.stackingGroup]) {\n                groupingValues[series.stackingGroup] = [];\n                groupingValues[series.stackingGroup].push(series);\n            }\n            else if (groupingValues[series.stackingGroup] !== undefined) {\n                groupingValues[series.stackingGroup].push(series);\n            }\n        }\n        var keys = Object.keys(groupingValues);\n        for (var k = 0; k < keys.length; k++) {\n            var stackingSeies = [];\n            var stackedValues = [];\n            var seriesCollection_2 = groupingValues[keys[k]];\n            for (var _i = 0, seriesCollection_1 = seriesCollection_2; _i < seriesCollection_1.length; _i++) {\n                var series = seriesCollection_1[_i];\n                if (series.type.indexOf('Stacking') !== -1) {\n                    stackingGroup = series.stackingGroup;\n                    if (!lastPositive[stackingGroup]) {\n                        lastPositive[stackingGroup] = [];\n                        lastNegative[stackingGroup] = [];\n                    }\n                    yValues = series.yData;\n                    startValues = [];\n                    endValues = [];\n                    stackingSeies.push(series);\n                    visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getVisiblePoints)(series);\n                    for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {\n                        lastValue = 0;\n                        value = +yValues[j]; // Fix for chart not rendering while y value is given as string issue\n                        if (lastPositive[stackingGroup][visiblePoints[j].xValue] === undefined) {\n                            lastPositive[stackingGroup][visiblePoints[j].xValue] = 0;\n                        }\n                        if (lastNegative[stackingGroup][visiblePoints[j].xValue] === undefined) {\n                            lastNegative[stackingGroup][visiblePoints[j].xValue] = 0;\n                        }\n                        if (isStacking100) {\n                            value = value / frequencies[stackingGroup][visiblePoints[j].xValue] * 100;\n                            value = !isNaN(value) ? value : 0;\n                            visiblePoints[j].percentage = +(value.toFixed(2));\n                        }\n                        else {\n                            stackedValues[j] = stackedValues[j] ?\n                                stackedValues[j] + Math.abs(value) : Math.abs(value);\n                        }\n                        if (value >= 0) {\n                            lastValue = lastPositive[stackingGroup][visiblePoints[j].xValue];\n                            lastPositive[stackingGroup][visiblePoints[j].xValue] += value;\n                        }\n                        else {\n                            lastValue = lastNegative[stackingGroup][visiblePoints[j].xValue];\n                            lastNegative[stackingGroup][visiblePoints[j].xValue] += value;\n                        }\n                        startValues.push(lastValue);\n                        endValues.push(value + lastValue);\n                        if (isStacking100 && (endValues[j] > 100)) {\n                            endValues[j] = 100;\n                        }\n                    }\n                    series.stackedValues = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.StackValues(startValues, endValues);\n                    var isLogAxis = series.yAxis.valueType === 'Logarithmic';\n                    var isColumnBarType = (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1);\n                    series.yMin = isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin :\n                        Math.min.apply(0, isStacking100 ? startValues : endValues);\n                    series.yMax = Math.max.apply(0, endValues);\n                    if (series.yMin > Math.min.apply(0, endValues)) {\n                        series.yMin = (isStacking100) ? -100 :\n                            isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, endValues);\n                    }\n                    if (series.yMax < Math.max.apply(0, startValues)) {\n                        series.yMax = 0;\n                    }\n                }\n            }\n            this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);\n        }\n    };\n    /**\n     * Finds the percentage of stacking for the given Chart3DSeries collection and values.\n     *\n     * @param {Chart3DSeries[]} stackingSeries - The collection of Chart3DSeries to find the percentage of stacking for.\n     * @param {number[]} values - The values to calculate the percentage of stacking.\n     * @param {boolean} isStacking100 - Indicates whether the stacking type is 100% stacking.\n     * @returns {void}\n     */\n    Chart3DSeries.prototype.findPercentageOfStacking = function (stackingSeries, values, isStacking100) {\n        for (var _i = 0, stackingSeries_1 = stackingSeries; _i < stackingSeries_1.length; _i++) {\n            var item = stackingSeries_1[_i];\n            if (isStacking100) {\n                return null;\n            }\n            for (var _a = 0, _b = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getVisiblePoints)(item); _a < _b.length; _a++) {\n                var point = _b[_a];\n                point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));\n            }\n        }\n    };\n    /**\n     * Finds the frequencies for the given Chart3DSeries collection.\n     *\n     * @param {Chart3DSeries[]} seriesCollection - The collection of Chart3DSeries to find frequencies for.\n     * @returns {number[]} An array of frequencies for each series in the collection.\n     * @private\n     */\n    Chart3DSeries.prototype.findFrequencies = function (seriesCollection) {\n        var frequencies = [];\n        var stackingGroup;\n        var visiblePoints = [];\n        for (var _i = 0, seriesCollection_3 = seriesCollection; _i < seriesCollection_3.length; _i++) {\n            var series = seriesCollection_3[_i];\n            series.yAxis.isStack100 = series.type.indexOf('100') !== -1 ? true : false;\n            visiblePoints = this.getVisiblePoints();\n            if (series.type.indexOf('Stacking') !== -1) {\n                stackingGroup = series.stackingGroup;\n                if (!frequencies[stackingGroup]) {\n                    frequencies[stackingGroup] = [];\n                }\n                for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {\n                    if (frequencies[stackingGroup][visiblePoints[j].xValue] === undefined) {\n                        frequencies[stackingGroup][visiblePoints[j].xValue] = 0;\n                    }\n                    if (series.yData[j] > 0) {\n                        frequencies[stackingGroup][visiblePoints[j].xValue] += series.yData[j];\n                    }\n                    else {\n                        frequencies[stackingGroup][visiblePoints[j].xValue] -= series.yData[j];\n                    }\n                }\n            }\n        }\n        return frequencies;\n    };\n    /**\n     * Renders the Chart3DSeries on the given 3D chart.\n     *\n     * @param {Chart3D} chart - The 3D chart on which to render the series.\n     * @returns {void}\n     * @private\n     */\n    Chart3DSeries.prototype.renderSeries = function (chart) {\n        var seriesType = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(this.type);\n        seriesType = seriesType.replace('100', '');\n        if (chart[seriesType + 'Series3DModule']) {\n            this.visiblePoints = this.getVisiblePoints();\n            chart[seriesType + 'Series3DModule'].draw(this, chart);\n            if (this.dataLabel.visible && this.visible) {\n                chart.dataLabel3DModule.render(this, this.chart, this.dataLabel);\n            }\n        }\n    };\n    /**\n     * Retrieves the visible data points for the Chart3DSeries.\n     * The visibility of points may be influenced by factors such as data filtering or chart settings.\n     *\n     * @returns {Chart3DPoint[]} An array of Chart3DPoint objects representing the visible data points.\n     * @private\n     */\n    Chart3DSeries.prototype.getVisiblePoints = function () {\n        var points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.points, null, true);\n        var tempPoints = [];\n        var tempPoint;\n        var pointIndex = 0;\n        for (var i = 0; i < points.length; i++) {\n            tempPoint = points[i];\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(tempPoint.x)) {\n                continue;\n            }\n            else {\n                tempPoint.index = pointIndex++;\n                tempPoints.push(tempPoint);\n            }\n        }\n        return tempPoints;\n    };\n    /**\n     * Sets the color for a specific Chart3DPoint in the series.\n     * This method allows you to customize the color of an individual data point.\n     *\n     * @param {Chart3DPoint} point - The Chart3DPoint for which to set the color.\n     * @param {string} color - The color value to be applied to the data point.\n     * @returns {string} The updated color value after applying any modifications or validations.\n     * @private\n     */\n    Chart3DSeries.prototype.setPointColor = function (point, color) {\n        color = point.interior || color;\n        return point.isEmpty ? (this.emptyPointSettings.fill || color) : color;\n    };\n    /**\n     * Gets the Y values from an array of Chart3DPoint objects.\n     *\n     * @param {Chart3DPoint[]} points - An array of Chart3DPoint objects.\n     * @returns {number[]} An array containing the Y values extracted from the provided data points.\n     * @private\n     */\n    Chart3DSeries.prototype.getYValues = function (points) {\n        var values = [];\n        var length = points.length;\n        for (var i = 0; i < length; i++) {\n            values.push(points[i].yValue);\n        }\n        return values;\n    };\n    /**\n     * Gets the X values from an array of Chart3DPoint objects.\n     * This method extracts the X values from a collection of data points.\n     *\n     * @param {Chart3DPoint[]} points - An array of Chart3DPoint objects.\n     * @returns {number[]} An array containing the X values extracted from the provided data points.\n     * @private\n     */\n    Chart3DSeries.prototype.getXValues = function (points) {\n        var values = [];\n        var length = points.length;\n        for (var i = 0; i < length; i++) {\n            values.push(points[i].xValue);\n        }\n        return values;\n    };\n    /**\n     * Gets the segment depth information for a Chart3DSeries.\n     * This method retrieves the depth information for the segments of a Chart3DSeries.\n     *\n     * @param {Chart3DSeries} series - The Chart3DSeries for which segment depth is obtained.\n     * @returns {Chart3DDepthInfoType} The depth information for the segments of the specified series.\n     * @private\n     */\n    Chart3DSeries.prototype.getSegmentDepth = function (series) {\n        var actualDepth = this.chart.depth;\n        var start;\n        var end;\n        if (this.chart.enableSideBySidePlacement) {\n            var space = actualDepth / 4;\n            start = space;\n            end = space * (series.columnFacet === 'Rectangle' ? 2.5 : 3);\n        }\n        else {\n            var index = series.position - 1;\n            var count = series.rectCount;\n            var space = actualDepth / ((count * 2) + count + 1);\n            start = space + (space * index * 3);\n            end = start + space * (series.columnFacet === 'Rectangle' ? 1.5 : 2);\n        }\n        return { start: start, end: end, delta: end - start };\n    };\n    /**\n     * Calculates the side-by-side positions for segments in a Chart3DSeries.\n     * This method determines the positions of segments when they are arranged side-by-side.\n     *\n     * @param {Chart3DSeries} series - The Chart3DSeries for which side-by-side positions are calculated.\n     * @returns {void}\n     * @private\n     */\n    Chart3DSeries.prototype.getSideBySidePositions = function (series) {\n        var chart = series.chart;\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var columnItem = _a[_i];\n            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n                var item = _c[_b];\n                this.findRectPosition(series.findSeriesCollection(columnItem, item, false));\n            }\n        }\n    };\n    /**\n     * Finds the position of rectangles for a collection of Chart3DSeries.\n     * This method determines the position of rectangles based on the given series collection.\n     *\n     * @param {Chart3DSeries[]} seriesCollection - The collection of Chart3DSeries for which rectangle positions are determined.\n     * @returns {void}\n     * @private\n     */\n    Chart3DSeries.prototype.findRectPosition = function (seriesCollection) {\n        var groupingValues = [];\n        var vSeries = { rectCount: 0, position: null };\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            if (value.type.indexOf('Stacking') !== -1 || value.groupName !== '') {\n                var groupName = value.type.indexOf('Stacking') !== -1 ? value.stackingGroup : value.type + value.groupName;\n                if (groupName) {\n                    if (groupingValues[groupName] === undefined) {\n                        value.position = vSeries.rectCount;\n                        groupingValues[groupName] = vSeries.rectCount++;\n                    }\n                    else {\n                        value.position = groupingValues[groupName];\n                    }\n                }\n                else {\n                    if (vSeries.position === null) {\n                        vSeries.rectCount++;\n                        value.position = vSeries.rectCount;\n                        vSeries.position = vSeries.rectCount;\n                    }\n                    else {\n                        value.position = vSeries.position;\n                    }\n                }\n            }\n            else {\n                vSeries.rectCount++;\n                value.position = vSeries.rectCount;\n            }\n        }\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            value.rectCount = vSeries.rectCount;\n        }\n    };\n    /**\n     * Gets a range of values between the specified start and end points.\n     * This method returns a Chart3DRangeValues object representing the range of values between the given start and end points.\n     *\n     * @param {number} start - The starting point of the range.\n     * @param {number} end - The ending point of the range.\n     * @returns {Chart3DRangeValues} - An object representing the range of values between the start and end points.\n     */\n    Chart3DSeries.prototype.getDoubleRange = function (start, end) {\n        var mstart;\n        var mend;\n        if (start > end) {\n            mstart = end;\n            mend = start;\n        }\n        else {\n            mstart = start;\n            mend = end;\n        }\n        var mdelta = mend - mstart;\n        var mmedian = (mstart + mend) / 2;\n        var misEmpty = isNaN(mstart) || isNaN(mend);\n        return { start: mstart, end: mend, delta: mdelta, median: mmedian, isEmpty: misEmpty };\n    };\n    /**\n     * Sets the style options for the specified Chart3DSeries.\n     * This method applies the style options to customize the appearance of the specified series.\n     *\n     * @param {Chart3DSeries} series - The Chart3DSeries for which the style options should be set.\n     * @returns {Chart3DStyleOptions} - An object representing the style options applied to the series.\n     */\n    Chart3DSeries.prototype.setStyle = function (series) {\n        var options = {\n            interior: series.interior,\n            opacity: series.opacity,\n            dashArray: ''\n        };\n        return options;\n    };\n    /**\n     * Gets the side-by-side positioning information for the specified Chart3DSeries.\n     * This method calculates and returns the range values that define the position of the series in a side-by-side arrangement.\n     *\n     * @param {Chart3DSeries} series - The Chart3DSeries for which side-by-side positioning information is needed.\n     * @returns {Chart3DRangeValues} - An object representing the range values that define the position of the series in a side-by-side arrangement.\n     */\n    Chart3DSeries.prototype.getSideBySideInfo = function (series) {\n        this.chart.currentSeries = series;\n        var minimumPointDelta = (0,_utils_chart3dRender__WEBPACK_IMPORTED_MODULE_7__.getMinPointsDeltaValue)(series.xAxis, this.chart.visibleSeries);\n        var spacing = series.columnSpacing;\n        var columnWidth = (series.columnWidth === null || isNaN(+series.columnWidth)) ? 0.7 : Math.min(series.columnWidth, 1);\n        this.getSideBySidePositions(series);\n        var pos = series.position;\n        var all = series.rectCount;\n        var width = minimumPointDelta * columnWidth;\n        var loc = (pos - (series.stackingGroup === '' ? 1 : 0)) / all - 0.5;\n        var range = this.getDoubleRange(loc, loc + (1 / all));\n        if (!this.chart.enableSideBySidePlacement) {\n            return this.getDoubleRange(-width / 2, width / 2);\n        }\n        if (!range.isEmpty) {\n            range = this.getDoubleRange(range.start * width, range.end * width);\n            var radius = spacing * range.delta;\n            range = this.getDoubleRange(range.start + radius / 2, range.end - radius / 2);\n        }\n        return range;\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"xName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"pointColorMapping\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Chart3DSeries.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DSeries.prototype, \"xAxisName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DSeries.prototype, \"yAxisName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ duration: 2000 }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Animation)\n    ], Chart3DSeries.prototype, \"animation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DSeries.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"dataSource\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Chart3DSeries.prototype, \"query\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, Chart3DDataLabelSettings)\n    ], Chart3DSeries.prototype, \"dataLabel\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"yName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"size\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"stackingGroup\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], Chart3DSeries.prototype, \"opacity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"groupName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Column')\n    ], Chart3DSeries.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Chart3DSeries.prototype, \"enableTooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"tooltipFormat\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"tooltipMappingName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('SeriesType')\n    ], Chart3DSeries.prototype, \"legendShape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Chart3DSeries.prototype, \"legendImageUrl\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, Chart3DEmptyPointSettings)\n    ], Chart3DSeries.prototype, \"emptyPointSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Chart3DSeries.prototype, \"columnWidth\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Rectangle')\n    ], Chart3DSeries.prototype, \"columnFacet\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0.1)\n    ], Chart3DSeries.prototype, \"columnSpacing\", void 0);\n    return Chart3DSeries;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart3d/series/chart-series.js?");

/***/ })

}]);