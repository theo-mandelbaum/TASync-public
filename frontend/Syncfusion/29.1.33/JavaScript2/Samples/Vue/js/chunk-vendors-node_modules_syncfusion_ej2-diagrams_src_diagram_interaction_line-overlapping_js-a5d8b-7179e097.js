"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_line-overlapping_js-a5d8b-7179e097"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-overlapping.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-overlapping.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AvoidLineOverlapping: () => (/* binding */ AvoidLineOverlapping)\n/* harmony export */ });\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _utility_connector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js\");\n\n\n// Class representing a line segment\nvar LineSegment = /** @class */ (function () {\n    /**\n     * Constructor to initialize a LineSegment.\n     * @param {PointModel} start - The starting point of the line segment.\n     * @param {PointModel} end - The ending point of the line segment.\n     * @param {ILineSegment} [previousSegment] - The previous line segment in the sequence (optional).\n     * @returns {ILineSegment} The newly created line segment.\n     */\n    function LineSegment(start, end, previousSegment) {\n        this.startPoint = start;\n        this.endPoint = end;\n        this.previous = previousSegment;\n        // Link the previous segment to this one, if it exists\n        if (previousSegment) {\n            previousSegment.next = this;\n        }\n        // Determine if the segment is vertical or horizontal\n        var isVertical = start.x === end.x;\n        this.coordinate = isVertical ? start.x : start.y;\n        this.sortedStart = isVertical ? Math.min(start.y, end.y) : Math.min(start.x, end.x);\n        this.sortedEnd = isVertical ? Math.max(start.y, end.y) : Math.max(start.x, end.x);\n        this.direction = isVertical ? (start.y < end.y ? 'Bottom' : 'Top') : (start.x < end.x ? 'Right' : 'Left');\n        // Create sweep events for the start and end of the segment\n        this.startEvent = new SweepEvent(this, true);\n        this.endEvent = new SweepEvent(this, false);\n    }\n    /**\n     * Updates the coordinate of the line segment by a given delta.\n     * @param {number} delta - The amount to adjust the coordinate by.\n     * @returns {void}\n     * @private\n     */\n    LineSegment.prototype.updateCoordinate = function (delta) {\n        this.coordinate += delta;\n        var isHorizontal = this.direction === 'Left' || this.direction === 'Right';\n        // Calculate new start and end points based on the updated coordinate\n        var newStartPoint = isHorizontal\n            ? { x: this.startPoint.x, y: this.coordinate }\n            : { x: this.coordinate, y: this.startPoint.y };\n        var newEndPoint = isHorizontal\n            ? { x: this.endPoint.x, y: this.coordinate }\n            : { x: this.coordinate, y: this.endPoint.y };\n        // Update the start point and adjust the previous segment if it exists\n        this.startPoint = newStartPoint;\n        if (this.previous) {\n            this.previous.adjustEnd(newStartPoint);\n        }\n        // Update the end point and adjust the next segment if it exists\n        this.endPoint = newEndPoint;\n        if (this.next) {\n            this.next.adjustStart(newEndPoint);\n        }\n    };\n    /**\n     * Adjusts the start point of the segment and updates sorted values.\n     * @param {PointModel} point - The new start point.\n     * @returns {void}\n     */\n    LineSegment.prototype.adjustStart = function (point) {\n        this.startPoint = point;\n        this.updateSortedValues();\n    };\n    /**\n     * Adjusts the end point of the segment and updates sorted values.\n     * @param {PointModel} point - The new end point.\n     * @returns {void}\n     */\n    LineSegment.prototype.adjustEnd = function (point) {\n        this.endPoint = point;\n        this.updateSortedValues();\n    };\n    /**\n     * Updates the sorted start and end values based on the current points.\n     * @returns {void}\n     */\n    LineSegment.prototype.updateSortedValues = function () {\n        var isVertical = this.direction === 'Top' || this.direction === 'Bottom';\n        this.sortedStart = isVertical ? Math.min(this.startPoint.y, this.endPoint.y) : Math.min(this.startPoint.x, this.endPoint.x);\n        this.sortedEnd = isVertical ? Math.max(this.startPoint.y, this.endPoint.y) : Math.max(this.startPoint.x, this.endPoint.x);\n        // Refresh the start and end events to reflect the updated sorted values\n        this.startEvent.refresh();\n        this.endEvent.refresh();\n    };\n    return LineSegment;\n}());\n// Class representing an event in the sweep line algorithm\nvar SweepEvent = /** @class */ (function () {\n    /**\n     * Constructor to initialize a SweepEvent.\n     * @param {ILineSegment} segment - The line segment associated with this event.\n     * @param {boolean} isStart - Whether this event is the start of the segment.\n     */\n    function SweepEvent(segment, isStart) {\n        this.segment = segment;\n        this.isStart = isStart;\n        // Set the value based on whether this is a start or end event\n        this.value = isStart ? segment.sortedStart : segment.sortedEnd;\n    }\n    /**\n     * Refreshes the value of the event based on the segment's current sorted values.\n     * @returns {void}\n     */\n    SweepEvent.prototype.refresh = function () {\n        // Update the value to reflect the current position of the segment\n        this.value = this.isStart ? this.segment.sortedStart : this.segment.sortedEnd;\n    };\n    /**\n     * Compares this event to another event for sorting purposes.\n     * @param {SweepEvent} other - The other event to compare to.\n     * @returns {number} -1 if this event is less than the other, 1 if greater, 0 if equal.\n     */\n    SweepEvent.prototype.compareTo = function (other) {\n        // Compare based on the value of the events\n        if (this.value !== other.value) {\n            return this.value < other.value ? -1 : 1;\n        }\n        // If values are equal, prioritize start events over end events\n        return this.isStart ? -1 : other.isStart ? 1 : 0;\n    };\n    return SweepEvent;\n}());\n// Class representing a segment tree used for efficient line segment intersection detection\nvar SegmentTree = /** @class */ (function () {\n    function SegmentTree() {\n        // Maps to store horizontal and vertical branches of segments\n        this.horizontalBranches = new Map();\n        this.verticalBranches = new Map();\n    }\n    /**\n     * Adds a line segment to the segment tree.\n     * @param {ILineSegment} segment - The line segment to add.\n     * @returns {void}\n     * @private\n     */\n    SegmentTree.prototype.addSegment = function (segment) {\n        // Get the appropriate branches (horizontal or vertical) based on the segment's direction\n        var branches = this.getBranches(segment.direction);\n        this.addSegmentToBranch(branches, segment);\n    };\n    /**\n     * Adds a line segment to the appropriate branch (horizontal or vertical).\n     * @param {Map<number, Set<SweepEvent>>} branches - The map of branches to add the segment to.\n     * @param {ILineSegment} segment - The line segment to add.\n     * @returns {void}\n     */\n    SegmentTree.prototype.addSegmentToBranch = function (branches, segment) {\n        // If the branch for the segment's coordinate does not exist, create it\n        if (!branches.has(segment.coordinate)) {\n            branches.set(segment.coordinate, new Set());\n        }\n        var branch = branches.get(segment.coordinate);\n        if (branch) {\n            // Add the start and end events of the segment to the branch\n            branch.add(segment.startEvent);\n            branch.add(segment.endEvent);\n        }\n    };\n    /**\n     * Removes a line segment from the segment tree.\n     * @param {ILineSegment} segment - The line segment to remove.\n     * @returns {void}\n     * @private\n     */\n    SegmentTree.prototype.removeSegment = function (segment) {\n        // Get the appropriate branches (horizontal or vertical) based on the segment's direction\n        var branches = this.getBranches(segment.direction);\n        this.removeSegmentFromBranch(branches, segment);\n    };\n    /**\n     * Removes a line segment from the appropriate branch (horizontal or vertical).\n     * @param {Map<number, Set<SweepEvent>>} branches - The map of branches to remove the segment from.\n     * @param {ILineSegment} segment - The line segment to remove.\n     * @returns {void}\n     */\n    SegmentTree.prototype.removeSegmentFromBranch = function (branches, segment) {\n        var branch = branches.get(segment.coordinate);\n        if (branch) {\n            // Remove the start and end events of the segment from the branch\n            branch.delete(segment.startEvent);\n            branch.delete(segment.endEvent);\n            // If the branch is empty after removal, delete the branch\n            if (branch.size === 0) {\n                branches.delete(segment.coordinate);\n            }\n        }\n    };\n    /**\n     * Finds segments that overlap with the given segment.\n     * @param {ILineSegment} segment - The line segment to check for overlaps.\n     * @returns {ILineSegment[]} An array of overlapping line segments.\n     * @private\n     */\n    SegmentTree.prototype.findOverlappingSegments = function (segment) {\n        // Get the appropriate branches (horizontal or vertical) based on the segment's direction\n        var branches = this.getBranches(segment.direction);\n        return this.findOverlappingSegmentsInBranch(branches, segment);\n    };\n    /**\n     * Finds overlapping segments within the appropriate branch.\n     * @param {Map<number, Set<SweepEvent>>} branches - The map of branches to search for overlaps.\n     * @param {ILineSegment} segment - The line segment to check for overlaps.\n     * @returns {ILineSegment[]} An array of overlapping line segments.\n     */\n    SegmentTree.prototype.findOverlappingSegmentsInBranch = function (branches, segment) {\n        var result = [];\n        var seenSegments = new Set();\n        var branch = branches.get(segment.coordinate);\n        if (branch) {\n            var branchArray_1 = [];\n            branch.forEach(function (item) { return branchArray_1.push(item); });\n            for (var i = 0; i < branchArray_1.length; i++) {\n                var sweepEvent = branchArray_1[parseInt(i.toString(), 10)];\n                // Check if the segment overlaps with the current sweep event\n                if (!(sweepEvent.segment.sortedStart < segment.sortedStart && sweepEvent.segment.sortedEnd > segment.sortedEnd)) {\n                    if (sweepEvent.value < segment.sortedStart || sweepEvent.value > segment.sortedEnd) {\n                        continue;\n                    }\n                }\n                // Add the overlapping segment to the result if it hasn't been seen before\n                if (sweepEvent.segment !== segment && !seenSegments.has(sweepEvent.segment)) {\n                    seenSegments.add(sweepEvent.segment);\n                    var maxStart = Math.max(segment.sortedStart, sweepEvent.segment.sortedStart);\n                    var minEnd = Math.min(segment.sortedEnd, sweepEvent.segment.sortedEnd);\n                    if (maxStart < minEnd) {\n                        result.push(sweepEvent.segment);\n                    }\n                }\n            }\n        }\n        return result;\n    };\n    /**\n     * Gets the branches (horizontal or vertical) based on the segment's direction.\n     * @param {Direction} direction - The direction of the segment.\n     * @returns {Map<number, Set<SweepEvent>>} The map of branches.\n     */\n    SegmentTree.prototype.getBranches = function (direction) {\n        // Return horizontal branches for left/right direction, vertical branches for top/bottom direction\n        return direction === 'Left' || direction === 'Right' ? this.horizontalBranches : this.verticalBranches;\n    };\n    return SegmentTree;\n}());\n// Class responsible for managing line segment overlaps and ensuring connectors do not visually overlap in a diagram.\nvar AvoidLineOverlapping = /** @class */ (function () {\n    function AvoidLineOverlapping(parent) {\n        this.requireReroute = false;\n        this.reRoutedCount = 0;\n        this.considerNonWalkable = [];\n        this.diagram = parent;\n        this.segmentTree = new SegmentTree();\n        this.segmentMappings = new Map();\n        this.connectorMappings = new Map();\n        this.modifiedConnector = new Set();\n        this.modifiedSegments = new Map();\n        this.currentSegments = new Map();\n    }\n    ///**\n    // * Processes all connectors in the diagram to resolve line overlapping issues.\n    // * @returns {void}\n    // * @private\n    // */\n    //public refreshLineOverlapping(): void {\n    //    if (this.diagram && this.diagram.lineRoutingModule) {\n    //        if (this.diagram.connectors.length > 0) {\n    //            this.diagram.connectors.forEach((connector: Connector) => {\n    //                if (connector.type === 'Orthogonal' && connector.visible) {\n    //                    this.addConnector(connector);\n    //                }\n    //            });\n    //            this.refreshModifiedConnectors(this.diagram);\n    //        }\n    //    }\n    //}\n    /**\n     * Gets the set of connectors that have been modified.\n     * @returns {Set<Connector>} A set of modified connectors.\n     * @private\n     */\n    AvoidLineOverlapping.prototype.getModifiedConnector = function () {\n        return this.modifiedConnector;\n    };\n    /**\n     * Gets the modified segments of a given connector.\n     * @param {Connector} connector - The connector to get the modified segments for.\n     * @returns {OrthogonalSegmentModel[]} An array of orthogonal segment models representing the modified segments.\n     * @private\n     */\n    AvoidLineOverlapping.prototype.getModifiedConnectorSegments = function (connector) {\n        // Retrieve the segments associated with the given connector\n        var segments = this.segmentMappings.get(connector);\n        // Convert the segments to orthogonal segment models if they exist, otherwise return an empty array\n        return this.convertSegmentsToOrthogonal(segments);\n    };\n    /**\n     * Refreshes the modified connectors in the diagram.\n     * @param {Diagram} diagram - The diagram instance containing the connectors.\n     * @returns {void}\n     * @private\n     */\n    AvoidLineOverlapping.prototype.refreshModifiedConnectors = function (diagram) {\n        var _this = this;\n        // Iterate over each modified connector\n        this.modifiedConnector.forEach(function (modifiedConnector) {\n            // Get the segments of the modified connector\n            var segments = _this.getModifiedConnectorSegments(modifiedConnector);\n            if (segments.length) {\n                // Add the modified segments to the connector\n                modifiedConnector.segments = segments;\n                // Update the connector properties in the diagram\n                diagram.connectorPropertyChange(modifiedConnector, {}, { type: 'Orthogonal', segments: segments });\n            }\n        });\n        // Clear the modified connectors\n        this.modifiedConnector.clear();\n    };\n    /**\n     * Removes connectors and its associated segments from the internal mappings and segment tree.\n     * @param {any} connectors - The connectors to remove.\n     * @returns {void}\n     * @private\n     */\n    AvoidLineOverlapping.prototype.removeConnectors = function (connectors) {\n        for (var i = 0; i < connectors.length; i++) {\n            var obj = connectors[parseInt(i.toString(), 10)];\n            var connector = void 0;\n            if (typeof obj === 'string') {\n                connector = this.diagram.nameTable[obj];\n            }\n            else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n                connector = obj;\n            }\n            if (connector && connector.type === 'Orthogonal') {\n                this.removeConnector(connector);\n            }\n        }\n    };\n    /**\n     * Removes a connector and its associated segments from the internal mappings and segment tree.\n     * @param {Connector} connector - The connector to remove.\n     * @returns {void}\n     * @private\n     */\n    AvoidLineOverlapping.prototype.removeConnector = function (connector) {\n        var _this = this;\n        // Retrieve the line segments associated with the connector\n        var segments = this.segmentMappings.get(connector);\n        if (segments) {\n            // Remove each line segment from the segment tree and delete its mapping\n            segments.forEach(function (segment) {\n                _this.segmentTree.removeSegment(segment);\n                _this.connectorMappings.delete(segment);\n            });\n        }\n        // Remove the mapping between the connector and its segments\n        this.segmentMappings.delete(connector);\n    };\n    /**\n     * Adds a connector and processes it to remove overlapping lines in its segments.\n     * @param {Connector} connector - The connector to process.\n     * @param {PointModel[]} points - The points to adjust (optional).\n     * @param {OrthogonalSegmentModel[]} segments - The segments to adjust (optional).\n     * @returns {void} The adjusted segments.\n     * @private\n     */\n    AvoidLineOverlapping.prototype.addConnector = function (connector, points, segments) {\n        var _this = this;\n        if (points === void 0) { points = []; }\n        if (segments === void 0) { segments = []; }\n        if (this.diagram.lineDistributionModule) {\n            return;\n        }\n        // Generate points based on the provided segments or use the connector's intermediate points\n        // Needed in case of without using line routing\n        // if (!points.length) {\n        //     points = segments.length ? this.generatePoints(connector, segments) : connector.intermediatePoints;\n        // }\n        if (points.length === 0) {\n            points = connector.intermediatePoints;\n        }\n        // Remove the connector from the current mappings\n        this.removeConnector(connector);\n        // Create line segments from the points\n        var lineSegments = this.createLineSegments(points);\n        // Map the segments to the connector\n        this.mapSegmentsToConnector(connector, lineSegments);\n        // If there are more than 3 points, process the connector to remove overlapping\n        if (points.length > 3) {\n            // Adjust the connector to resolve overlaps in the segments\n            this.adjustConnector(connector);\n        }\n        else {\n            var overlappingConnectors = new Set();\n            for (var _i = 0, lineSegments_1 = lineSegments; _i < lineSegments_1.length; _i++) {\n                var lineSegment = lineSegments_1[_i];\n                // Find overlapping segments of current connector\n                var overlappingsegments = this.segmentTree.findOverlappingSegments(lineSegment);\n                for (var _a = 0, overlappingsegments_1 = overlappingsegments; _a < overlappingsegments_1.length; _a++) {\n                    var overlappingSegment = overlappingsegments_1[_a];\n                    // Fetch overlapping connector\n                    var overlappingConnector = this.connectorMappings.get(overlappingSegment);\n                    // Add overlapping connector to the set\n                    overlappingConnectors.add(overlappingConnector);\n                }\n            }\n            // Adjust the overlapping connector to resolve overlaps in the segments\n            overlappingConnectors.forEach(function (overlappingConnector) { return _this.adjustConnector(overlappingConnector); });\n        }\n    };\n    // Needed in case of without using line routing\n    // /**\n    //  * Generates points based on the connector and segments.\n    //  * @param {Connector} connector - The connector to process.\n    //  * @param {OrthogonalSegmentModel[]} segments - The segments to adjust.\n    //  * @returns {PointModel[]} An array of points representing the connector's path.\n    //  */\n    // private generatePoints(connector: Connector, segments: OrthogonalSegmentModel[]): PointModel[] {\n    //     const points: PointModel[] = [];\n    //     let currentPoint: PointModel = connector.sourcePoint;\n    //     points.push(currentPoint);\n    //     // Iterate through each segment to generate the corresponding points\n    //     segments.forEach((segment: OrthogonalSegmentModel) => {\n    //         const newPoint: PointModel = { x: currentPoint.x, y: currentPoint.y };\n    //         switch (segment.direction) {\n    //         case 'Left':\n    //             newPoint.x -= segment.length;\n    //             break;\n    //         case 'Right':\n    //             newPoint.x += segment.length;\n    //             break;\n    //         case 'Top':\n    //             newPoint.y -= segment.length;\n    //             break;\n    //         case 'Bottom':\n    //             newPoint.y += segment.length;\n    //             break;\n    //         }\n    //         points.push(newPoint);\n    //         currentPoint = newPoint;\n    //     });\n    //     return points;\n    // }\n    /**\n     * Creates line segments from the given points.\n     * @param {PointModel[]} points - The points to create segments from.\n     * @returns {ILineSegment[]} An array of line segments.\n     */\n    AvoidLineOverlapping.prototype.createLineSegments = function (points) {\n        var lineSegments = [];\n        // Iterate through the points to create line segments\n        for (var i = 0; i < points.length - 1; i++) {\n            // Create a new line segment from the current point to the next point\n            var segment = new LineSegment(points[parseInt(i.toString(), 10)], points[parseInt((i + 1).toString(), 10)], i === 0 ? null : lineSegments[parseInt((i - 1).toString(), 10)]);\n            lineSegments.push(segment);\n        }\n        return lineSegments;\n    };\n    /**\n     * Maps line segments to the given connector.\n     * @param {Connector} connector - The connector to map segments to.\n     * @param {ILineSegment[]} lineSegments - The line segments to map.\n     * @returns {void}\n     */\n    AvoidLineOverlapping.prototype.mapSegmentsToConnector = function (connector, lineSegments) {\n        var _this = this;\n        // Store the mapping of segments to the connector\n        this.segmentMappings.set(connector, lineSegments);\n        // Add each segment to the segment tree and update connector mappings\n        lineSegments.forEach(function (lineSegment) {\n            _this.segmentTree.addSegment(lineSegment);\n            if (!_this.connectorMappings.has(lineSegment)) {\n                _this.connectorMappings.set(lineSegment, connector);\n            }\n        });\n    };\n    /**\n     * Converts line segments to orthogonal segments.\n     * @param {ILineSegment[]} lineSegments - The line segments to convert.\n     * @returns {OrthogonalSegmentModel[]} An array of orthogonal segments.\n     */\n    AvoidLineOverlapping.prototype.convertSegmentsToOrthogonal = function (lineSegments) {\n        var modifiedSegments = [];\n        if (lineSegments) {\n            // Iterate through each line segment to create corresponding orthogonal segments\n            lineSegments.forEach(function (lineSegment) {\n                var orthogonalSegment = {\n                    type: 'Orthogonal',\n                    direction: lineSegment.direction,\n                    length: Math.abs(lineSegment.sortedEnd - lineSegment.sortedStart)\n                };\n                modifiedSegments.push(orthogonalSegment);\n            });\n        }\n        return modifiedSegments;\n    };\n    /**\n     * Adjusts the connector to resolve overlapping segments.\n     * @param {Connector} connector - The connector to adjust.\n     * @returns {void}\n     */\n    AvoidLineOverlapping.prototype.adjustConnector = function (connector) {\n        var _this = this;\n        this.requireReroute = false;\n        // Retrieve the line segments associated with the connector\n        var segments = this.segmentMappings.get(connector);\n        if (segments.length > 2) {\n            var firstSegment = segments[0];\n            var sourceNode = this.diagram.nameTable[connector.sourceID];\n            if (sourceNode && sourceNode.outEdges.length > 0) {\n                var refLineSegment = void 0;\n                for (var j = 0; j < sourceNode.outEdges.length; j++) {\n                    var outConnector = this.diagram.nameTable[sourceNode.outEdges[parseInt(j.toString(), 10)]];\n                    if (outConnector === connector) {\n                        continue;\n                    }\n                    var refSegments = this.segmentMappings.get(outConnector);\n                    if (refSegments && refSegments.length > 2) {\n                        var refFirstSegment = refSegments[0];\n                        if (refFirstSegment.direction === firstSegment.direction &&\n                            refFirstSegment.next.direction === firstSegment.next.direction) {\n                            if (!refLineSegment) {\n                                refLineSegment = refFirstSegment;\n                            }\n                            else if (Math.abs(firstSegment.coordinate - refFirstSegment.coordinate) <\n                                Math.abs(firstSegment.coordinate - refLineSegment.coordinate)) {\n                                refLineSegment = refFirstSegment;\n                            }\n                        }\n                    }\n                }\n                if (refLineSegment) {\n                    var shiftDelta = refLineSegment.next.coordinate - firstSegment.next.coordinate;\n                    if (shiftDelta) {\n                        var superNext = firstSegment.next.next;\n                        var canShift = firstSegment.direction !== superNext.direction;\n                        if (firstSegment.direction === superNext.direction) {\n                            var maximumShift = this.calculateMaximumSegmentShift(firstSegment, superNext, superNext.direction);\n                            canShift = Math.abs(shiftDelta) <= maximumShift;\n                        }\n                        if (canShift) {\n                            this.modifiedSegments.clear();\n                            this.segmentTree.removeSegment(firstSegment.next);\n                            firstSegment.next.updateCoordinate(shiftDelta);\n                            this.segmentTree.addSegment(firstSegment.next);\n                            this.modifiedSegments.set(firstSegment.next, firstSegment.next.coordinate);\n                            this.modifiedConnector.add(connector);\n                        }\n                    }\n                }\n            }\n        }\n        var failedSegment = undefined;\n        // Iterate through each segment to check for overlaps\n        for (var i = 0; i < segments.length - 1; i++) {\n            var segment = segments[parseInt(i.toString(), 10)];\n            if (segment.previous && segment.next) {\n                // Find overlapping segments for this segment\n                var overlappingSegments = this.segmentTree.findOverlappingSegments(segment);\n                if (overlappingSegments.length > 0) {\n                    // Resolve any overlapping segments found\n                    if (!this.resolveOverlappingSegments(segment, overlappingSegments)) {\n                        if (this.requireReroute) {\n                            failedSegment = segment;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // If a failed segment is found and rerouting is required, attempt to reroute the connector\n        if (failedSegment && this.diagram.lineRoutingModule) {\n            if (this.reRoutedCount <= AvoidLineOverlapping.maxReRouteLimit) {\n                // Reset the walkable state of previously considered non-walkable grids\n                while (this.considerNonWalkable.length > 0) {\n                    var grid = this.considerNonWalkable.pop();\n                    grid.walkable = true;\n                }\n                // Fetch the grids that intersect with the segment path\n                var grids = this.diagram.lineRoutingModule\n                    .getGridsIntersect(failedSegment.startPoint, failedSegment.endPoint);\n                // Mark the grids in the segment path as non-walkable temporarily\n                grids.forEach(function (grid) {\n                    grid.walkable = false;\n                    _this.considerNonWalkable.push(grid);\n                });\n                this.reRoutedCount++;\n                // Refresh the connector segments to attempt rerouting\n                this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, false);\n            }\n        }\n        // Reset the rerouted count and restore the walkable state of grids\n        this.reRoutedCount = 0;\n        while (this.considerNonWalkable.length > 0) {\n            var grid = this.considerNonWalkable.pop();\n            grid.walkable = true;\n        }\n    };\n    /**\n     * Resolves overlapping segments by adjusting their positions.\n     * @param {ILineSegment} segment - The segment to adjust.\n     * @param {ILineSegment[]} overlappingSegments - The overlapping segments to resolve.\n     * @returns {boolean} whether the shifted segments get resolved with overlapping segment in finding a free coordinate\n     */\n    AvoidLineOverlapping.prototype.resolveOverlappingSegments = function (segment, overlappingSegments) {\n        // Clear maps to track modified and current segments\n        this.modifiedSegments.clear();\n        this.currentSegments.clear();\n        this.rootShiftingSegment = segment;\n        var adjustSelfFirst = this.shouldAdjustSelfFirst(segment, overlappingSegments);\n        // Get the first overlapping segment\n        var overlapSegment = overlappingSegments[0];\n        // Calculate the direction to shift the segment\n        var shiftDirection = adjustSelfFirst\n            ? this.calculateShiftDirection(segment, overlappingSegments)\n            : this.calculateShiftDirection(overlapSegment, this.segmentTree.findOverlappingSegments(overlapSegment));\n        var shifted = false;\n        if (adjustSelfFirst) {\n            var secondarySegment = overlappingSegments.length === 1 ? overlapSegment : undefined;\n            // Adjust the segment in calculated direction\n            shifted = this.attemptAdjustment(segment, shiftDirection, secondarySegment);\n            if (!shifted) {\n                // Adjust the segment in the opposite direction\n                shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(shiftDirection);\n                shifted = this.attemptAdjustment(segment, shiftDirection, secondarySegment, true);\n            }\n        }\n        else {\n            // Adjust the segment in calculated direction\n            shifted = this.attemptAdjustment(overlapSegment, shiftDirection, segment);\n            if (!shifted) {\n                // Adjust the segment in the opposite direction\n                shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(shiftDirection);\n                shifted = this.attemptAdjustment(overlapSegment, shiftDirection, segment, true);\n            }\n        }\n        // Update the segment tree with the modified segments\n        this.updateSegmentTreeWithModifiedSegments();\n        this.rootShiftingSegment = undefined;\n        return shifted;\n    };\n    /**\n     * Determines whether the current segment should be adjusted before its overlapping segment.\n     * @param {ILineSegment } segment - The current segment.\n     * @param {ILineSegment[]} overlappingSegments - The list of overlapping segments.\n     * @returns {boolean} True if the current segment should be adjusted first, otherwise false.\n     */\n    AvoidLineOverlapping.prototype.shouldAdjustSelfFirst = function (segment, overlappingSegments) {\n        var adjustSelfFirst = overlappingSegments.length > 1;\n        // Determine if the current segment should be adjusted first\n        if (overlappingSegments.length === 1) {\n            // Get the first overlapping segment\n            var overlapSegment = overlappingSegments[0];\n            if (overlapSegment.previous && overlapSegment.next) {\n                var maxStart = Math.max(segment.sortedStart, overlapSegment.sortedStart);\n                var minEnd = Math.min(segment.sortedEnd, overlapSegment.sortedEnd);\n                var currentRatio = (minEnd - maxStart) / (segment.sortedEnd - segment.sortedStart);\n                var overlapRatio = (minEnd - maxStart) / (overlapSegment.sortedEnd - overlapSegment.sortedStart);\n                if (currentRatio >= overlapRatio) {\n                    adjustSelfFirst = true;\n                }\n            }\n            else {\n                adjustSelfFirst = true;\n            }\n        }\n        return adjustSelfFirst;\n    };\n    /**\n     * Attempts to adjust the primary segment and optionally a secondary segment to resolve overlaps.\n     * @param {ILineSegment} primarySegment - The primary line segment to adjust.\n     * @param {Direction} shiftDirection - The direction to shift the primary segment.\n     * @param {ILineSegment} secondarySegment - The secondary line segment to adjust in the opposite direction (optional).\n     * @param {boolean} isOppositeShifting - Enabled when shifting segment in opposite direction.\n     * @returns {boolean} True if any segment was adjusted, otherwise false.\n     */\n    AvoidLineOverlapping.prototype.attemptAdjustment = function (primarySegment, shiftDirection, secondarySegment, isOppositeShifting) {\n        if (isOppositeShifting === void 0) { isOppositeShifting = false; }\n        // Adjust the primary segment first in shift direction\n        var isShifted = this.adjustSegment(primarySegment, shiftDirection, isOppositeShifting);\n        this.updateModifiedSegments(isShifted);\n        if (!isShifted) {\n            if (secondarySegment && secondarySegment.previous && secondarySegment.next) {\n                // Adjust the secondary segment in the opposite direction\n                shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(shiftDirection);\n                isShifted = this.adjustSegment(secondarySegment, shiftDirection, isOppositeShifting);\n                this.updateModifiedSegments(isShifted);\n            }\n        }\n        return isShifted;\n    };\n    ///**\n    // * Gets dependent segments based on a reference segment and a map of segments.\n    // * @param {ILineSegment} segment - The reference segment.\n    // * @param {Map<ILineSegment, number>} segmentMap - The map of segments.\n    // * @returns {ILineSegment[]} An array of dependent segments.\n    // */\n    //private getDependentSegments(segment: ILineSegment, segmentMap: Map<ILineSegment, number>): ILineSegment[] {\n    //    const dependentSegments: ILineSegment[] = [];\n    //    segmentMap.forEach((newCoordinate: number, dependentSegment: ILineSegment) => {\n    //        if (dependentSegment !== segment) { dependentSegments.push(dependentSegment); }\n    //    });\n    //    return dependentSegments;\n    //}\n    /**\n     * Updates the modified segments by adjusting their coordinates and re-adding them to the segment tree.\n     * @param {boolean} resetModifiedSegments - Indicates if the segments have been shifted.\n     * @returns {void}\n     */\n    AvoidLineOverlapping.prototype.updateModifiedSegments = function (resetModifiedSegments) {\n        var _this = this;\n        if (resetModifiedSegments) {\n            this.modifiedSegments.clear();\n        }\n        // Update each current segment's coordinate and re-add it to the segment tree\n        this.currentSegments.forEach(function (oldCoordinate, currentSegment) {\n            if (resetModifiedSegments) {\n                _this.modifiedSegments.set(currentSegment, currentSegment.coordinate);\n            }\n            _this.segmentTree.removeSegment(currentSegment);\n            currentSegment.updateCoordinate(oldCoordinate - currentSegment.coordinate);\n            _this.segmentTree.addSegment(currentSegment);\n        });\n        // Clear the current segments\n        this.currentSegments.clear();\n    };\n    /**\n     * Updates the segment tree with the modified segments.\n     * Removes the old segments and adds the new segments with their updated positions.\n     * @returns {void}\n     */\n    AvoidLineOverlapping.prototype.updateSegmentTreeWithModifiedSegments = function () {\n        var _this = this;\n        if (this.modifiedSegments.size > 0) {\n            this.modifiedSegments.forEach(function (newCoordinate, modifiedSegment) {\n                // Update the segment tree with shifted segments\n                _this.segmentTree.removeSegment(modifiedSegment);\n                modifiedSegment.updateCoordinate(newCoordinate - modifiedSegment.coordinate);\n                _this.segmentTree.addSegment(modifiedSegment);\n                // Add the connector to the set of modified connectors\n                var connector = _this.connectorMappings.get(modifiedSegment);\n                if (!_this.modifiedConnector.has(connector)) {\n                    _this.modifiedConnector.add(connector);\n                }\n            });\n        }\n    };\n    /**\n     * Resolves overlapping segments in a given direction.\n     * @param {ILineSegment} segment - The line segment to resolve overlaps for.\n     * @param {ILineSegment[]} overlappingSegments - The list of overlapping segments.\n     * @param {Direction} shiftDirection - The direction to shift the segment.\n     * @param {boolean} isOppositeShifting - Enabled when tried to shift secondary segment in opposite direction\n     * @param {boolean} adjustOverlapsOnly - Enabled only when overlapping segments need to be adjusted.\n     * @returns {boolean} True if the segment was adjusted, otherwise false.\n     */\n    AvoidLineOverlapping.prototype.resolveOverlappingAtGivenDirection = function (segment, overlappingSegments, shiftDirection, isOppositeShifting, adjustOverlapsOnly) {\n        if (adjustOverlapsOnly) {\n            var isShifted = false;\n            for (var _i = 0, overlappingSegments_1 = overlappingSegments; _i < overlappingSegments_1.length; _i++) {\n                var overlapSegment = overlappingSegments_1[_i];\n                if (overlapSegment.previous && overlapSegment.next) {\n                    isShifted = this.adjustSegment(overlapSegment, shiftDirection, isOppositeShifting, adjustOverlapsOnly);\n                    if (!isShifted) {\n                        return false;\n                    }\n                }\n            }\n            return isShifted;\n        }\n        var segmentToShift = segment;\n        if (overlappingSegments.length === 1) {\n            var adjustSelfFirst = this.shouldAdjustSelfFirst(segment, overlappingSegments);\n            var overlapSegment = overlappingSegments[0];\n            var directionToShift = adjustSelfFirst\n                ? this.calculateShiftDirection(segment, overlappingSegments)\n                : this.calculateShiftDirection(overlapSegment, this.segmentTree.findOverlappingSegments(overlapSegment));\n            if (isOppositeShifting) {\n                directionToShift = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(directionToShift);\n            }\n            if (adjustSelfFirst) {\n                segmentToShift = directionToShift === shiftDirection ? segment : overlapSegment;\n            }\n            else {\n                segmentToShift = directionToShift === shiftDirection ? overlapSegment : segment;\n            }\n            if (segmentToShift === overlapSegment && (!overlapSegment.previous || !overlapSegment.next)) {\n                segmentToShift = segment;\n            }\n        }\n        // Adjust the segment or the overlapping segment based on the direction\n        return this.adjustSegment(segmentToShift, shiftDirection, isOppositeShifting);\n    };\n    /**\n     * Calculates the direction to shift a line segment to resolve overlaps.\n     * @param {ILineSegment} lineSegment - The line segment to calculate the shift direction for.\n     * @param {ILineSegment[]} overlappingSegments - The list of overlapping segments.\n     * @returns {Direction} The direction to shift the segment.\n     */\n    AvoidLineOverlapping.prototype.calculateShiftDirection = function (lineSegment, overlappingSegments) {\n        var overlapSegment = overlappingSegments[0];\n        var segment = lineSegment;\n        var previousSegment = segment.previous;\n        var nextSegment = segment.next;\n        var nonSortedStart = segment.direction === 'Left' || segment.direction === 'Right' ? segment.startPoint.x : segment.startPoint.y;\n        var nonSortedEnd = segment.direction === 'Left' || segment.direction === 'Right' ? segment.endPoint.x : segment.endPoint.y;\n        var shiftDirection = segment.direction;\n        // Determine the shift direction based on the previous and next segments\n        if (previousSegment.direction === nextSegment.direction) {\n            var overlapsPrevious = overlapSegment.previous;\n            var overlapsNext = overlapSegment.next;\n            var isStartCovered = overlapSegment.sortedStart <= nonSortedStart && nonSortedStart <= overlapSegment.sortedEnd;\n            var isEndCovered = overlapSegment.sortedStart <= nonSortedEnd && nonSortedEnd <= overlapSegment.sortedEnd;\n            // Determine if the start or end of the segment is covered by the overlap\n            if (isStartCovered && isEndCovered) {\n                var nonSortedStart1 = overlapSegment.direction === 'Left' || overlapSegment.direction === 'Right' ? overlapSegment.startPoint.x : overlapSegment.startPoint.y;\n                var nonSortedEnd1 = overlapSegment.direction === 'Left' || overlapSegment.direction === 'Right' ? overlapSegment.endPoint.x : overlapSegment.endPoint.y;\n                if (segment.direction !== overlapSegment.direction) {\n                    var temp = nonSortedStart1;\n                    nonSortedStart1 = nonSortedEnd1;\n                    nonSortedEnd1 = temp;\n                }\n                var startDistance = Math.abs(nonSortedStart - nonSortedStart1);\n                var endDistance = Math.abs(nonSortedEnd - nonSortedEnd1);\n                if (startDistance >= endDistance) {\n                    isEndCovered = false;\n                }\n                else {\n                    if (nextSegment.next && segment.direction === nextSegment.next.direction &&\n                        this.segmentTree.findOverlappingSegments(nextSegment).length !== 0) {\n                        isEndCovered = false;\n                    }\n                    else {\n                        isStartCovered = false;\n                    }\n                }\n            }\n            // Determine the shift direction based on the overlap and segment directions\n            if (isStartCovered) {\n                if (segment.direction === overlapSegment.direction && overlapsNext) {\n                    shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(overlapsNext.direction);\n                }\n                else if (segment.direction !== overlapSegment.direction && overlapsPrevious) {\n                    //shiftDirection = overlapsPrevious.direction;\n                    shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(overlapsPrevious.direction);\n                }\n                else {\n                    shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(previousSegment.direction);\n                }\n            }\n            else if (isEndCovered) {\n                if (segment.direction === overlapSegment.direction && overlapsPrevious) {\n                    shiftDirection = overlapsPrevious.direction;\n                }\n                else if (segment.direction !== overlapSegment.direction && overlapsNext) {\n                    shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(overlapsNext.direction);\n                }\n                else {\n                    shiftDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(previousSegment.direction);\n                }\n            }\n            else {\n                shiftDirection = nextSegment.direction;\n            }\n        }\n        else {\n            if (!overlapSegment.previous || !overlapSegment.next ||\n                overlapSegment.previous.direction === overlapSegment.next.direction) {\n                shiftDirection = nextSegment.direction;\n            }\n            else {\n                var maxStart = Math.max(segment.sortedStart, overlapSegment.sortedStart);\n                var minEnd = Math.min(segment.sortedEnd, overlapSegment.sortedEnd);\n                var currentRatio = (minEnd - maxStart) / (segment.sortedEnd - segment.sortedStart);\n                var overlapRatio = (minEnd - maxStart) / (overlapSegment.sortedEnd - overlapSegment.sortedStart);\n                shiftDirection = currentRatio >= overlapRatio ? nextSegment.direction : previousSegment.direction;\n            }\n        }\n        return shiftDirection;\n    };\n    /**\n     * Adjusts a segment by shifting it in a given direction.\n     * @param {ILineSegment} segment - The segment to adjust.\n     * @param {Direction} directionToShift - The direction to shift the segment.\n     * @param {boolean} isOppositeShifting - Enabled when shifting secondary segment in opposite direction.\n     * @param {boolean} adjustOverlapsOnly - Enabled only when overlapping segments need to be adjusted.\n     * @returns {boolean} True if the segment was adjusted, false otherwise.\n     */\n    AvoidLineOverlapping.prototype.adjustSegment = function (segment, directionToShift, isOppositeShifting, adjustOverlapsOnly) {\n        if (adjustOverlapsOnly === void 0) { adjustOverlapsOnly = false; }\n        var currentCoord = segment.coordinate;\n        var previousSegment = segment.previous;\n        var nextSegment = segment.next;\n        // Calculate the maximum allowed shift for the segment\n        var maximumAllowedShift = this.calculateMaximumSegmentShift(previousSegment, nextSegment, directionToShift);\n        // Determine the shift delta based on the direction\n        var directionMultiplier = directionToShift === 'Right' || directionToShift === 'Bottom' ? 1 : -1;\n        var shiftDelta = directionMultiplier * AvoidLineOverlapping.ConnectorSpacing;\n        // Adjust the segment if the shift delta is within the allowed range\n        if (Math.abs(shiftDelta) <= maximumAllowedShift) {\n            this.segmentTree.removeSegment(segment);\n            segment.updateCoordinate(shiftDelta);\n            this.segmentTree.addSegment(segment);\n            // Store the segment's initial routed coordinate.\n            if (!this.currentSegments.has(segment)) {\n                this.currentSegments.set(segment, currentCoord);\n            }\n            if (this.diagram.lineRoutingModule) {\n                // Check if the shifted segment overlaps with a node.\n                var startPoint = segment.startPoint;\n                var endPoint = segment.endPoint;\n                if (!this.diagram.lineRoutingModule.isPathWalkable(startPoint, endPoint, this.diagram)) {\n                    if (!adjustOverlapsOnly && segment === this.rootShiftingSegment) {\n                        this.segmentTree.removeSegment(segment);\n                        segment.updateCoordinate(shiftDelta * -1);\n                        this.segmentTree.addSegment(segment);\n                        var overlappingSegments_2 = this.segmentTree.findOverlappingSegments(segment);\n                        if (overlappingSegments_2.length !== 0) {\n                            var oppositeDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(directionToShift);\n                            return this.resolveOverlappingAtGivenDirection(segment, overlappingSegments_2, oppositeDirection, isOppositeShifting, true);\n                        }\n                    }\n                    this.requireReroute = true;\n                    return false;\n                }\n            }\n            var overlappingSegments = this.segmentTree.findOverlappingSegments(segment);\n            if (overlappingSegments.length !== 0) {\n                if (this.modifiedSegments.size !== 0 && this.modifiedSegments.size > (this.currentSegments.size + 1)) {\n                    return false;\n                }\n                return this.resolveOverlappingAtGivenDirection(segment, overlappingSegments, directionToShift, isOppositeShifting, adjustOverlapsOnly);\n            }\n        }\n        else if (!adjustOverlapsOnly && segment === this.rootShiftingSegment) {\n            var overlappingSegments = this.segmentTree.findOverlappingSegments(segment);\n            if (overlappingSegments.length !== 0) {\n                var oppositeDirection = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_1__.getOppositeDirection)(directionToShift);\n                return this.resolveOverlappingAtGivenDirection(segment, overlappingSegments, oppositeDirection, isOppositeShifting, true);\n            }\n        }\n        return segment.coordinate !== currentCoord;\n    };\n    /**\n     * Calculates the maximum allowed shift for segments.\n     * @param {ILineSegment} previousSegment - The previous segment.\n     * @param {ILineSegment} nextSegment - The next segment.\n     * @param {Direction} directionToShift - The direction to shift the segment.\n     * @returns {number} The maximum allowed shift.\n     */\n    AvoidLineOverlapping.prototype.calculateMaximumSegmentShift = function (previousSegment, nextSegment, directionToShift) {\n        // Calculate the lengths of the previous and next segments\n        var previousLength = Math.abs(previousSegment.sortedEnd - previousSegment.sortedStart);\n        var nextLength = Math.abs(nextSegment.sortedEnd - nextSegment.sortedStart);\n        var connector = this.connectorMappings.get(previousSegment);\n        if (connector) {\n            if (!previousSegment.previous) {\n                var sourceDecoratorLength = 5;\n                if (connector.sourceDecorator.shape !== 'None') {\n                    sourceDecoratorLength = Math.max(connector.sourceDecorator.width, connector.sourceDecorator.height);\n                }\n                previousLength -= sourceDecoratorLength + 5;\n            }\n            if (!nextSegment.next) {\n                var targetDecoratorLength = 5;\n                if (connector.targetDecorator.shape !== 'None') {\n                    targetDecoratorLength = Math.max(connector.targetDecorator.width, connector.targetDecorator.height);\n                }\n                nextLength -= targetDecoratorLength + 5;\n            }\n        }\n        if (previousSegment.direction === nextSegment.direction) {\n            return directionToShift === nextSegment.direction ? nextLength : previousLength;\n        }\n        else {\n            return directionToShift === nextSegment.direction ? Math.min(previousLength, nextLength) : Number.MAX_VALUE;\n        }\n    };\n    /**\n     *To destroy the line overlapping\n     *\n     * @returns {void} To destroy the line overlapping\n     */\n    AvoidLineOverlapping.prototype.destroy = function () {\n        /**\n         * Destroys the line overlapping module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    AvoidLineOverlapping.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'AvoidLineOverlapping';\n    };\n    // Constant defining the default spacing between connectors\n    AvoidLineOverlapping.ConnectorSpacing = 5;\n    // Constant defining the maximum number of times to re-route a connector to resolve overlaps\n    AvoidLineOverlapping.maxReRouteLimit = 5;\n    return AvoidLineOverlapping;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-overlapping.js?");

/***/ })

}]);