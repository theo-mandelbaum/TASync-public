"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_common_user-interaction_tooltip_js-ca2e7a01"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/common/user-interaction/tooltip.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/common/user-interaction/tooltip.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTooltip: () => (/* binding */ BaseTooltip)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _chart_utils_get_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../chart/utils/get-data */ \"./node_modules/@syncfusion/ej2-charts/src/chart/utils/get-data.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _chart_user_interaction_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../chart/user-interaction/selection */ \"./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/selection.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n/**\n * `Tooltip` module is used to render the tooltip for series.\n */\nvar BaseTooltip = /** @class */ (function (_super) {\n    __extends(BaseTooltip, _super);\n    /**\n     * Constructor for tooltip module.\n     *\n     * @private\n     */\n    function BaseTooltip(chart) {\n        var _this = _super.call(this, chart) || this;\n        _this.element = _this.chart.element;\n        _this.textStyle = chart.tooltip.textStyle;\n        _this.control = chart;\n        _this.template = chart.tooltip.template;\n        return _this;\n    }\n    BaseTooltip.prototype.getElement = function (id) {\n        return document.getElementById(id);\n    };\n    /**\n     * Renders the tooltip.\n     *\n     * @returns {void}\n     * @private\n     */\n    BaseTooltip.prototype.getTooltipElement = function (isTooltip) {\n        this.inverted = this.chart.requireInvertedAxis;\n        this.header = (this.control.tooltip.header === null) ?\n            ((this.control.tooltip.shared) ? '${point.x}' : '${series.name}')\n            : (this.control.tooltip.header);\n        this.formattedText = [];\n        var tooltipDiv = document.getElementById(this.chart.element.id + '_tooltip');\n        var isStockChart = this.chart.element.id.indexOf('stockChart') > -1;\n        if (!isTooltip && !tooltipDiv || isStockChart) {\n            return this.createElement();\n        }\n        return null;\n    };\n    BaseTooltip.prototype.createElement = function () {\n        var tooltipDiv = document.createElement('div');\n        tooltipDiv.id = this.element.id + '_tooltip';\n        tooltipDiv.className = 'ejSVGTooltip';\n        tooltipDiv.style.pointerEvents = 'none';\n        tooltipDiv.style.position = 'absolute';\n        tooltipDiv.style.zIndex = '1';\n        return tooltipDiv;\n    };\n    BaseTooltip.prototype.pushData = function (data, isFirst, tooltipDiv, isChart, enable3D) {\n        if (data.series.enableTooltip) {\n            if (enable3D) {\n                this.currentPoints.push(data);\n            }\n            else if (isChart) {\n                this.currentPoints.push(data);\n            }\n            else {\n                this.currentPoints.push(data);\n            }\n            this.stopAnimation();\n            if (tooltipDiv && !document.getElementById(tooltipDiv.id)) {\n                if (!this.chart.stockChart) {\n                    document.getElementById(this.element.id + '_Secondary_Element').appendChild(tooltipDiv);\n                }\n                else {\n                    document.getElementById(this.chart.stockChart.element.id + '_Secondary_Element').appendChild(tooltipDiv);\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    BaseTooltip.prototype.removeHighlight = function () {\n        var item;\n        // let series: Series;\n        for (var i = 0, len = this.previousPoints.length; i < len; i++) {\n            item = this.previousPoints[i];\n            if (item.series.isRectSeries || this.chart.tooltip.enableHighlight) {\n                if (item.series.visible) {\n                    this.highlightPoint(item.series, item.point.index, false);\n                }\n                continue;\n            }\n            // series = item.series as Series;\n        }\n    };\n    /**\n     * Animates the opacity change of the given element to simulate a highlight effect.\n     *\n     * @param {number} targetOpacity - The final opacity value to which the element's opacity will be animated.\n     * @param {HTMLElement} targetElement - The DOM element whose opacity is to be animated.\n     * @param {number} duration - The duration of the animation effect.\n     * @param {number} targetStrokeWidth - The final stroke-width value to which the element's stroke-width will be animated.\n     * @returns {void}\n     * @private\n     */\n    BaseTooltip.prototype.animateHighlight = function (targetOpacity, targetElement, duration, targetStrokeWidth) {\n        var _this = this;\n        var initialOpacity = parseFloat(targetElement.getAttribute('opacity'));\n        var initialStrokeWidth = null;\n        if (targetStrokeWidth !== null) {\n            initialStrokeWidth = parseFloat(targetElement.getAttribute('stroke-width'));\n        }\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(targetElement, {\n            duration: duration,\n            progress: function (args) {\n                targetElement.style.animation = '';\n                if (_this.svgTooltip) {\n                    return;\n                }\n                if (targetStrokeWidth !== null) {\n                    var newStrokeWidth = initialStrokeWidth\n                        + (args.timeStamp / args.duration) * (targetStrokeWidth - initialStrokeWidth);\n                    targetElement.setAttribute('stroke-width', Math.max(newStrokeWidth, targetStrokeWidth).toString());\n                }\n                var newOpacity = initialOpacity + (args.timeStamp / args.duration) * (targetOpacity - initialOpacity);\n                targetElement.setAttribute('opacity', Math.min(newOpacity, targetOpacity).toString());\n            },\n            end: function () {\n                if (_this.svgTooltip) {\n                    return;\n                }\n                if (targetStrokeWidth !== null) {\n                    targetElement.setAttribute('stroke-width', targetStrokeWidth.toString());\n                }\n                targetElement.setAttribute('opacity', targetOpacity.toString());\n            }\n        });\n    };\n    BaseTooltip.prototype.highlightPoint = function (series, pointIndex, highlight) {\n        var _this = this;\n        var element = this.getElement(this.element.id + '_Series_' + series.index + '_Point_' + pointIndex);\n        var selectionModule = this.control.accumulationSelectionModule;\n        var isAccumulation = this.chart.getModuleName() === 'accumulationchart';\n        var isSelectedElement = selectionModule && selectionModule.selectedDataIndexes.length > 0 ? true : false;\n        if ((element) || (!series.isRectSeries)) {\n            if ((!isSelectedElement || isSelectedElement && element.getAttribute('class')\n                && element.getAttribute('class').indexOf('_ej2_chart_selection_series_') === -1) || (!series.isRectSeries)) {\n                if (series.isRectSeries && this.chart.highlightColor !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.chart.highlightColor)) {\n                    element.setAttribute('fill', (highlight && this.chart.highlightColor !== 'transparent' ? this.chart.highlightColor : series.pointColorMapping !== '' ? (series.points[0]).color : series.points[pointIndex].color || series.interior));\n                }\n                else {\n                    if ((this.control.highlightMode === 'None') && (this.chart.tooltip.enableHighlight) && ((!this.chart.tooltip.shared) || (isAccumulation))) {\n                        if (highlight && (isAccumulation ? this.control.accumulationSelectionModule\n                            && this.control.accumulationSelectionModule.selectedDataIndexes.length > 0\n                            : this.chart.selectionModule && this.chart.selectionModule.selectedDataIndexes.length > 0)) {\n                            return;\n                        }\n                        var target_1 = this.element.id + '_Series_' + series.index + '_Point_' + pointIndex;\n                        var _loop_1 = function (currentSeries) {\n                            var seriesElementsGroupCollections = [];\n                            var currentSeriesWidth = typeof currentSeries.width === 'number' ? currentSeries.width : parseFloat(currentSeries.width);\n                            seriesElementsGroupCollections = isAccumulation\n                                ? [this_1.getElement(this_1.chart.element.id + '_Series_' + currentSeries.index)]\n                                : new _chart_user_interaction_selection__WEBPACK_IMPORTED_MODULE_4__.Selection(this_1.chart).getSeriesElements(currentSeries);\n                            if (isAccumulation && this_1.control.series[0].dataLabel.visible) {\n                                var dataLabelCollection = this_1.getElement(this_1.element.id + '_datalabel_Series_0');\n                                if (dataLabelCollection) {\n                                    seriesElementsGroupCollections.push(dataLabelCollection);\n                                }\n                            }\n                            seriesElementsGroupCollections.forEach(function (seriesElementsGroup) {\n                                seriesElementsGroup.childNodes.forEach(function (seriesElement) {\n                                    var targetOpacity = seriesElement.id.indexOf('border') > -1 ? 1 :\n                                        seriesElement.id.indexOf('Symbol') > -1 ? currentSeries.marker.opacity : currentSeries.opacity;\n                                    var targetStrokeWidth = seriesElement.id.indexOf('border') > -1 && currentSeries.border.width\n                                        ? parseFloat(currentSeries.border.width.toString())\n                                        : seriesElement.id.indexOf('Symbol') > -1 && currentSeries.marker.border.width\n                                            ? parseFloat(currentSeries.marker.border.width.toString())\n                                            : currentSeriesWidth;\n                                    if (highlight && _this.chart.highlightColor !== 'transparent' && seriesElement.id !== '') {\n                                        if (isAccumulation ? (seriesElementsGroup.getAttribute('id').indexOf('datalabel') > -1 ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.indexFinder)(seriesElement.id).point === pointIndex :\n                                            seriesElement.id === target_1) : (seriesElementsGroup.getAttribute('id') === _this.element.id + 'DataLabelCollection' ? ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.indexFinder)(seriesElement.id).series === series.index) : (currentSeries.index === series.index))) {\n                                            seriesElement.setAttribute('opacity', targetOpacity.toString());\n                                            if ((!series.isRectSeries || (seriesElement.id.indexOf('border') > -1)) && (!isAccumulation)) {\n                                                seriesElement.setAttribute('stroke-width', (targetStrokeWidth + 1).toString());\n                                            }\n                                        }\n                                        else {\n                                            seriesElement.setAttribute('opacity', isAccumulation ? seriesElement.id.indexOf('datalabel') > -1 ? '0.5' : '0.3'\n                                                : (seriesElement.getAttribute('id').indexOf('Text') > -1 ? '0.5' : '0.3'));\n                                            if ((!series.isRectSeries || (seriesElement.id.indexOf('border') > -1)) && (!isAccumulation)) {\n                                                seriesElement.setAttribute('stroke-width', (targetStrokeWidth).toString());\n                                            }\n                                        }\n                                    }\n                                    else if (!_this.currentPoints[0] && seriesElement.id !== '') {\n                                        _this.animateHighlight(targetOpacity, seriesElement, _this.chart.tooltip.duration, ((!series.isRectSeries || (seriesElement.id.indexOf('border') > -1)) && (!isAccumulation)) ? targetStrokeWidth : null);\n                                    }\n                                });\n                            });\n                        };\n                        var this_1 = this;\n                        for (var _i = 0, _a = this.chart.visibleSeries; _i < _a.length; _i++) {\n                            var currentSeries = _a[_i];\n                            _loop_1(currentSeries);\n                        }\n                    }\n                    else if (series.isRectSeries) {\n                        element.setAttribute('opacity', (highlight && this.chart.highlightColor !== 'transparent' ? series.opacity / 2 : series.opacity).toString());\n                    }\n                }\n            }\n            else {\n                element.setAttribute('opacity', series.opacity.toString());\n            }\n        }\n    };\n    BaseTooltip.prototype.highlightPoints = function () {\n        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {\n            var item = _a[_i];\n            if ((item.series.isRectSeries || this.chart.tooltip.enableHighlight) && item.series.category === 'Series') {\n                this.highlightPoint(item.series, item.point.index, true);\n            }\n        }\n    };\n    BaseTooltip.prototype.createTooltip = function (chart, isFirst, location, clipLocation, point, shapes, offset, bounds, crosshairEnabled, extraPoints, templatePoint, customTemplate) {\n        if (crosshairEnabled === void 0) { crosshairEnabled = false; }\n        if (extraPoints === void 0) { extraPoints = null; }\n        if (templatePoint === void 0) { templatePoint = null; }\n        var series = this.currentPoints[0].series;\n        var tooltipModule = chart.tooltipModule || chart.tooltip3DModule ||\n            chart.accumulationTooltipModule;\n        if (!tooltipModule || location === null) { // For the tooltip enable is false.\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(this.chart.element.id + '_tooltip');\n            return;\n        }\n        if (isFirst) {\n            this.svgTooltip = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Tooltip({\n                opacity: chart.tooltip.opacity ? chart.tooltip.opacity : ((this.chart.theme === 'Material3' || this.chart.theme === 'Material3Dark' || this.chart.theme.indexOf('Bootstrap5') > -1) ? 1 : 0.75),\n                header: this.headerText,\n                content: this.text,\n                fill: chart.tooltip.fill,\n                border: chart.tooltip.border,\n                enableAnimation: chart.tooltip.enableAnimation,\n                location: location,\n                shared: this.control.tooltip.shared,\n                crosshair: crosshairEnabled,\n                shapes: shapes,\n                clipBounds: this.chart.chartAreaType === 'PolarRadar' ? new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(0, 0) : clipLocation,\n                areaBounds: bounds,\n                palette: this.findPalette(),\n                template: customTemplate || this.template,\n                data: templatePoint,\n                theme: chart.theme,\n                offset: offset,\n                textStyle: chart.tooltip.textStyle,\n                isNegative: (series.isRectSeries && series.type !== 'Waterfall' && point && point.y < 0),\n                inverted: this.chart.requireInvertedAxis && series.isRectSeries,\n                arrowPadding: this.text.length > 1 || this.chart.stockChart || (this.chart.tooltip.location.x !== null\n                    || this.chart.tooltip.location.y !== null) ? 0 : 7,\n                availableSize: chart.availableSize,\n                duration: this.chart.tooltip.duration,\n                isCanvas: this.chart.enableCanvas,\n                isFixed: (this.chart.tooltip.location.x !== null || this.chart.tooltip.location.y !== null),\n                isTextWrap: chart.tooltip.enableTextWrap && chart.getModuleName() === 'chart',\n                blazorTemplate: { name: 'Template', parent: this.chart.tooltip },\n                controlInstance: this.chart,\n                enableRTL: chart.enableRtl,\n                controlName: 'Chart',\n                allowHighlight: chart.getModuleName() === 'chart' && !series.marker.allowHighlight,\n                tooltipRender: function () {\n                    tooltipModule.removeHighlight();\n                    tooltipModule.highlightPoints();\n                    tooltipModule.updatePreviousPoint(extraPoints);\n                },\n                animationComplete: function (args) {\n                    if (args.tooltip.fadeOuted) {\n                        tooltipModule.fadeOut(tooltipModule.previousPoints);\n                    }\n                },\n                showHeaderLine: this.chart.tooltip.showHeaderLine,\n                showNearestTooltip: this.chart.tooltip.showNearestTooltip\n            });\n            this.svgTooltip.appendTo(this.getElement(this.element.id + '_tooltip'));\n        }\n        else {\n            if (this.svgTooltip) {\n                this.svgTooltip.location = location;\n                this.svgTooltip.content = this.text;\n                this.svgTooltip.header = this.headerText;\n                this.svgTooltip.offset = offset;\n                this.svgTooltip.palette = this.findPalette();\n                this.svgTooltip.shapes = shapes;\n                this.svgTooltip.data = templatePoint;\n                this.svgTooltip.template = this.template;\n                this.svgTooltip.controlName = 'Chart';\n                this.svgTooltip.crosshair = crosshairEnabled;\n                this.svgTooltip.textStyle = chart.tooltip.textStyle;\n                this.svgTooltip.isNegative = (series.isRectSeries && series.type !== 'Waterfall' && point && point.y < 0);\n                this.svgTooltip.clipBounds = this.chart.chartAreaType === 'PolarRadar' ? new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(0, 0) : clipLocation;\n                this.svgTooltip.arrowPadding = this.text.length > 1 || this.chart.stockChart || (this.chart.tooltip.location.x !== null\n                    || this.chart.tooltip.location.y !== null) ? 0 : 7;\n                this.svgTooltip.allowHighlight = chart.getModuleName() === 'chart' && !series.marker.allowHighlight;\n                this.svgTooltip.dataBind();\n            }\n        }\n        if (this.chart.isReact) {\n            this.chart.renderReactTemplates();\n        }\n    };\n    BaseTooltip.prototype.findPalette = function () {\n        var colors = [];\n        for (var _i = 0, _a = this.currentPoints; _i < _a.length; _i++) {\n            var data = _a[_i];\n            colors.push(this.findColor(data, data.series));\n        }\n        return colors;\n    };\n    BaseTooltip.prototype.findColor = function (data, series) {\n        if (series.isRectSeries && (series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose')) {\n            return data.point.color;\n        }\n        else {\n            return (data.point.color && data.point.color !== '#ffffff' ? data.point.color\n                : data.point.interior) ||\n                series.marker.fill || series.interior;\n        }\n    };\n    BaseTooltip.prototype.updatePreviousPoint = function (extraPoints) {\n        if (extraPoints) {\n            this.currentPoints = this.currentPoints.concat(extraPoints);\n        }\n        this.previousPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.currentPoints, null, true);\n    };\n    BaseTooltip.prototype.fadeOut = function (data) {\n        var svgElement = this.chart.enableCanvas ? this.getElement(this.element.id + '_tooltip_group') :\n            this.getElement(this.element.id + '_tooltip_svg') || this.getElement(this.element.id + '_tooltipparent_template');\n        var isTooltip = (svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0);\n        if (!isTooltip) {\n            this.valueX = null;\n            this.valueY = null;\n            this.currentPoints = [];\n            this.removeHighlight();\n            this.removeHighlightedMarker(data, true);\n            this.svgTooltip = null;\n            this.control.trigger('animationComplete', {});\n        }\n    };\n    /*\n    * @hidden\n    */\n    BaseTooltip.prototype.removeHighlightedMarker = function (data, fadeOut) {\n        if (this.chart.markerRender) {\n            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n                var item = data_1[_i];\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.removeElement)(this.element.id + '_Series_' + item.series.index +\n                    '_Point_' + item.point.index + '_Trackball');\n                this.chart.markerRender.removeHighlightedMarker(item.series, item.point, fadeOut);\n            }\n        }\n        this.previousPoints = [];\n    };\n    // public triggerEvent(point: PointData | AccPointData, isFirst: boolean, textCollection: string, firstText: boolean = true): boolean {\n    //     let argsData: ITooltipRenderEventArgs = {\n    //         cancel: false, name: tooltipRender, text: textCollection,\n    //         point: point.point, series: point.series, textStyle: this.textStyle\n    //     };\n    //     this.chart.trigger(tooltipRender, argsData);\n    //     if (!argsData.cancel) {\n    //         if (point.series.type === 'BoxAndWhisker') {\n    //             this.removeText();\n    //             isFirst = true;\n    //         }\n    //         this.formattedText = this.formattedText.concat(argsData.text);\n    //         this.text = this.formattedText;\n    //     }\n    //     return !argsData.cancel;\n    // }\n    BaseTooltip.prototype.removeText = function () {\n        this.textElements = [];\n        var element = this.getElement(this.element.id + '_tooltip_group');\n        if (element && element.childNodes.length > 0) {\n            while (element.lastChild && element.childNodes.length !== 1) {\n                element.removeChild(element.lastChild);\n            }\n        }\n    };\n    BaseTooltip.prototype.stopAnimation = function () {\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stopTimer)(this.toolTipInterval);\n    };\n    /**\n     * Removes the tooltip on mouse leave.\n     *\n     * @returns {void}\n     * @private\n     */\n    BaseTooltip.prototype.removeTooltip = function (duration) {\n        var _this = this;\n        var tooltipElement = this.getElement(this.element.id + '_tooltip');\n        // const tooltipTemplate: HTMLElement = tooltipElement ? this.getElement(tooltipElement.id + 'parent_template') : null;\n        // const isTemplateRendered: boolean = tooltipTemplate && tooltipTemplate.innerText !== '<div></div>';\n        this.stopAnimation();\n        if (tooltipElement && this.previousPoints.length > 0) {\n            this.toolTipInterval = +setTimeout(function () {\n                if (_this.svgTooltip) {\n                    _this.svgTooltip.fadeOut();\n                }\n            }, duration);\n        }\n    };\n    return BaseTooltip;\n}(_chart_utils_get_data__WEBPACK_IMPORTED_MODULE_2__.ChartData));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/common/user-interaction/tooltip.js?");

/***/ })

}]);