"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-image-editor_src_image-editor_action_freehand-draw_js-5fbe-398e26a0"],{

/***/ "./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/freehand-draw.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/freehand-draw.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FreehandDrawing: () => (/* binding */ FreehandDrawing)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-image-editor/src/image-editor/index.js\");\n\n\nvar FreehandDrawing = /** @class */ (function () {\n    function FreehandDrawing(parent) {\n        this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };\n        this.isFreehandDrawing = false;\n        this.freehandDownPoint = { x: 0, y: 0 };\n        this.isFreehandPointMoved = false;\n        this.pointCounter = 0;\n        // eslint-disable-next-line\n        this.selPointColl = {};\n        this.currFHDIdx = 0; // Specifies id for every freehand drawing - uses while deleting\n        this.selPoints = [];\n        this.dummyPoints = [];\n        this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };\n        this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };\n        this.straightenPointAngle = 0;\n        this.isMasking = false;\n        this.parent = parent;\n        this.addEventListener();\n    }\n    FreehandDrawing.prototype.destroy = function () {\n        if (this.parent.isDestroyed) {\n            return;\n        }\n        this.removeEventListener();\n    };\n    FreehandDrawing.prototype.addEventListener = function () {\n        this.parent.on('freehand-draw', this.draw, this);\n        this.parent.on('destroyed', this.destroy, this);\n    };\n    FreehandDrawing.prototype.removeEventListener = function () {\n        this.parent.off('freehand-draw', this.draw);\n        this.parent.off('destroyed', this.destroy);\n    };\n    FreehandDrawing.prototype.draw = function (args) {\n        this.updateFhdPvtVar();\n        switch (args.prop) {\n            case 'hoverFhd': {\n                this.hoverFhd(args.value['strokeColor'], args.value['strokeWidth']);\n                break;\n            }\n            case 'freehandDownHandler':\n                this.freehandDownHandler(args.value['e'], args.value['canvas']);\n                break;\n            case 'freehandUpHandler':\n                this.freehandUpHandler(args.value['e'], args.value['canvas'], args.value['context']);\n                break;\n            case 'handle-freehand-draw': {\n                var id = parseInt(args.value['id'].split('_')[1], 10) - 1;\n                if (this.isFHDIdx(id)) {\n                    this.deleteFhd(id, true);\n                }\n                break;\n            }\n            case 'freehandRedraw':\n                this.freehandRedraw(args.value['context'], args.value['points']);\n                break;\n            case 'deleteFhd': {\n                var id = parseInt(args.value['id'].split('_')[1], 10) - 1;\n                this.deleteFhd(id, true);\n                break;\n            }\n            case 'selectFhd': {\n                var id = null;\n                if (args.value['id']) {\n                    id = parseInt(args.value['id'].split('_')[1], 10) - 1;\n                }\n                this.selectFhd(id);\n                break;\n            }\n            case 'applyFhd':\n                this.applyFhd();\n                break;\n            case 'cancelFhd':\n                this.cancelFhd();\n                break;\n            case 'updateFHDCurPts':\n                this.updateFHDCurPts();\n                break;\n            case 'rotateFhdColl':\n                this.rotateFhdColl();\n                break;\n            case 'flipFHDColl':\n                this.flipFHDColl(args.value['value']);\n                break;\n            case 'panFHDColl':\n                this.panFHDColl(args.value['xDiff'], args.value['yDiff'], args.value['panRegion']);\n                break;\n            case 'updateFHDColl':\n                if (args.value && args.value['isPreventApply']) {\n                    this.updateFHDColl(args.value['isPreventApply']);\n                }\n                else {\n                    this.updateFHDColl();\n                }\n                break;\n            case 'zoomFHDColl':\n                this.zoomFHDColl(args.value['isPreventApply']);\n                break;\n            case 'apply-pen-draw':\n                this.applyPenDraw();\n                break;\n            case 'freeHandDraw':\n                this.freeHandDraw(args.value['value']);\n                break;\n            case 'isFHDIdx':\n                this.isFHDIdx(args.value['index'], args.value['obj']);\n                break;\n            case 'getSqPtFD':\n                this.getSqPtFD(args.value['idx'], args.value['obj']);\n                break;\n            case 'getSelPointColl':\n                args.value['obj']['selPointColl'] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl);\n                break;\n            case 'setSelPointColl':\n                this.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], args.value['obj']['selPointColl']);\n                break;\n            case 'pushSelPointColl':\n                this.selPointColl.push((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], args.value['obj']['selPointColl']));\n                break;\n            case 'setFreehandDrawHoveredIndex':\n                this.fhdHovIdx = args.value['index'];\n                break;\n            case 'getFreehandDrawHoveredIndex':\n                args.value['obj']['index'] = this.fhdHovIdx;\n                break;\n            case 'setPointCounter':\n                this.pointCounter = args.value['value'];\n                break;\n            case 'getPenStrokeWidth':\n                args.value['obj']['penStrokeWidth'] = this.penStrokeWidth;\n                break;\n            case 'setPenStrokeWidth':\n                this.penStrokeWidth = args.value['value'];\n                break;\n            case 'getCurrentFreehandDrawIndex':\n                args.value['obj']['currentFreehandDrawIndex'] = this.currFHDIdx;\n                break;\n            case 'setCurrentFreehandDrawIndex':\n                this.currFHDIdx = args.value['value'];\n                break;\n            case 'updateCropPtsForSel':\n                this.updateCropPtsForSel();\n                break;\n            case 'getFreehandDrawSelectedId':\n                args.value['obj']['freehandDrawSelectedId'] = this.fhdSelID;\n                break;\n            case 'resetFreehandDrawSelectedId':\n                this.fhdSelID = null;\n                break;\n            case 'getTempFreeHandDrawEditingStyles':\n                args.value['obj']['tempFreeHandDrawEditingStyles'] = this.tempFHDStyles;\n                break;\n            case 'setFreehandSelectedIndex':\n                this.fhdSelIdx = args.value['index'];\n                break;\n            case 'getFreehandSelectedIndex':\n                args.value['obj']['freehandSelectedIndex'] = this.fhdSelIdx;\n                break;\n            case 'setCenterSelPoints':\n                this.setCenterSelPoints();\n                break;\n            case 'getStraightenPoint':\n                args.value['obj']['straightenPoint'] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.straightenPoint, {}, true);\n                break;\n            case 'setStraightenPoint':\n                this.straightenPoint.x = args.value['x'];\n                this.straightenPoint.y = args.value['y'];\n                if (args.value['ratioX'] && args.value['ratioY']) {\n                    this.straightenPoint.ratioX = args.value['ratioX'];\n                    this.straightenPoint.ratioY = args.value['ratioY'];\n                }\n                break;\n            case 'resetStraightenPoint':\n                this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };\n                this.prevStraightenObj = null;\n                this.straightenPointAngle = 0;\n                break;\n            case 'getStraightenPointAngle':\n                args.value['obj']['angle'] = this.straightenPointAngle;\n                break;\n            case 'reset':\n                this.reset();\n                break;\n            case 'triggerShapeChanging':\n                this.triggerShapeChanging(args.value['shapeChangingArgs']);\n                break;\n            case 'setMasking':\n                this.isMasking = args.value['value'];\n                break;\n            case 'resetSelPoints':\n                this.selPoints = [];\n                break;\n        }\n    };\n    FreehandDrawing.prototype.updateFhdPvtVar = function () {\n        var parent = this.parent;\n        if (parent.lowerCanvas) {\n            this.lowerContext = parent.lowerCanvas.getContext('2d');\n        }\n        if (parent.upperCanvas) {\n            this.upperContext = parent.upperCanvas.getContext('2d');\n        }\n    };\n    FreehandDrawing.prototype.reset = function () {\n        this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };\n        this.isFreehandDrawing = this.isFreehandPointMoved = false;\n        this.selPoints = [];\n        this.dummyPoints = [];\n        this.freehandDownPoint = { x: 0, y: 0 };\n        this.selPointColl = {};\n        this.straightenPointAngle = 0;\n        this.fhdHovIdx = null;\n        this.pointCounter = 0;\n        this.fhdSelID = null;\n        this.isMasking = false;\n        this.penStrokeWidth = undefined;\n        this.currFHDIdx = 0;\n        this.fhdSelIdx = null;\n        this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };\n        this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };\n        this.prevStraightenObj = null;\n    };\n    FreehandDrawing.prototype.getModuleName = function () {\n        return 'freehand-draw';\n    };\n    FreehandDrawing.prototype.hoverFhd = function (fillStyle, strokeWidth) {\n        var parent = this.parent;\n        var context = this.upperContext;\n        var idx = -1;\n        if (this.fhdHovIdx > -1) {\n            idx = this.fhdHovIdx;\n        }\n        else {\n            idx = this.fhdSelIdx;\n        }\n        parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[idx].points);\n        this.pointCounter = 0;\n        var len = parent.points.length;\n        var controlPoint1;\n        var controlPoint2;\n        var startPoint;\n        var endPoint;\n        var minStrokeWidth = 0;\n        var maxStrokeWidth = 0;\n        context.fillStyle = fillStyle ? fillStyle : parent.pointColl[idx].strokeColor;\n        context.strokeStyle = context.fillStyle;\n        minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = strokeWidth ?\n            strokeWidth : parent.pointColl[idx].strokeWidth;\n        if (len === 1) {\n            controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];\n            this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);\n        }\n        for (var l = 0; l < len - 3; l++) {\n            if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {\n                controlPoint1 = (this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2])).controlPoint2;\n                controlPoint2 = (this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3])).controlPoint1;\n                if (l === 0) {\n                    startPoint = parent.points[l];\n                }\n                else {\n                    startPoint = parent.points[l + 1];\n                }\n                endPoint = parent.points[l + 2];\n                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);\n            }\n        }\n        context.closePath();\n        // Outer selection\n        var point = this.getSqPtFD(idx);\n        var tempLineWidth = context.lineWidth;\n        context.lineWidth = 2;\n        context.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];\n        context.beginPath();\n        context.rect(point.startX, point.startY, point.width, point.height);\n        context.stroke();\n        context.closePath();\n        context.lineWidth = tempLineWidth;\n    };\n    FreehandDrawing.prototype.freehandDownHandler = function (e, canvas) {\n        var parent = this.parent;\n        parent.lowerCanvas = document.querySelector('#' + parent.element.id + '_lowerCanvas');\n        this.lowerContext = parent.lowerCanvas.getContext('2d');\n        parent.upperCanvas = document.querySelector('#' + parent.element.id + '_upperCanvas');\n        this.upperContext = parent.upperCanvas.getContext('2d');\n        this.fhdObj.time = new Date().getTime();\n        this.isFreehandDrawing = true;\n        if (e.type === 'mousedown') {\n            this.freehandDownPoint = { x: e.clientX, y: e.clientY };\n        }\n        else {\n            this.freehandDownPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };\n        }\n        this.isFreehandPointMoved = false;\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(canvas, 'mousemove touchmove', this.freehandMoveHandler, this);\n        var shapeSettings = { id: 'pen_' + (this.currFHDIdx + 1), type: _index__WEBPACK_IMPORTED_MODULE_1__.ShapeType.FreehandDraw,\n            startX: this.freehandDownPoint.x, startY: this.freehandDownPoint.y,\n            strokeColor: parent.activeObj.strokeSettings.strokeColor, strokeWidth: this.penStrokeWidth,\n            points: null, index: parent.objColl.length + parent.freehandCounter + 1 };\n        var shapeChangingArgs = { cancel: false, action: 'draw-start', previousShapeSettings: shapeSettings,\n            currentShapeSettings: shapeSettings };\n        this.triggerShapeChanging(shapeChangingArgs);\n    };\n    FreehandDrawing.prototype.freehandUpHandler = function (e, canvas, context) {\n        var rect = canvas.getBoundingClientRect();\n        var parent = this.parent;\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(canvas, 'mousemove touchmove', this.freehandMoveHandler);\n        if (parent.points.length === 0) {\n            if (e.type === 'mouseup') {\n                this.processPoint(e.clientX - rect.left, e.clientY - rect.top, true, context);\n            }\n            else if (e.type === 'touchend' && e.changedTouches) {\n                this.processPoint(e.changedTouches[0].clientX - rect.left, e.changedTouches[0].clientY - rect.top, true, context);\n            }\n            else {\n                if (!this.isFreehandPointMoved) {\n                    this.processPoint(this.freehandDownPoint.x - rect.left, this.freehandDownPoint.y - rect.top, true, context);\n                }\n            }\n        }\n        context.closePath();\n        var prevCropObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.cropObj, {}, true);\n        var object = { currObj: {} };\n        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });\n        var prevObj = object['currObj'];\n        prevObj.objColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.objColl, [], true);\n        prevObj.pointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl, [], true);\n        prevObj.afterCropActions = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.afterCropActions, [], true);\n        var selPointCollObj = { selPointColl: null };\n        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });\n        prevObj.selPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], selPointCollObj['selPointColl'], [], true);\n        var fhCnt = parent.freehandCounter;\n        var order = parent.objColl.length + parent.freehandCounter + 1;\n        parent.pointColl[fhCnt] = { points: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.points), strokeColor: parent.activeObj.strokeSettings.strokeColor,\n            strokeWidth: this.penStrokeWidth, flipState: parent.transform.currFlipState,\n            id: 'pen_' + (this.currFHDIdx + 1), order: order };\n        parent.points = [];\n        this.dummyPoints = [];\n        this.selPointColl[fhCnt] = { points: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPoints) };\n        this.selPoints = [];\n        this.pointCounter = 0;\n        parent.freehandCounter++;\n        this.isFreehandDrawing = false;\n        if (!parent.isMaskImage) {\n            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,\n                value: { operation: 'freehand-draw', previousObj: prevObj, previousObjColl: prevObj.objColl,\n                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,\n                    previousCropObj: prevCropObj, previousText: null,\n                    currentText: null, previousFilter: null, isCircleCrop: null } });\n        }\n        var shapeSettings = { id: 'pen_' + (this.currFHDIdx + 1), type: _index__WEBPACK_IMPORTED_MODULE_1__.ShapeType.FreehandDraw,\n            startX: this.freehandDownPoint.x, startY: this.freehandDownPoint.y,\n            strokeColor: parent.activeObj.strokeSettings.strokeColor, strokeWidth: this.penStrokeWidth,\n            points: parent.pointColl[this.currFHDIdx].points, index: order };\n        var shapeChangingArgs = { cancel: false, action: 'draw-end', previousShapeSettings: shapeSettings,\n            currentShapeSettings: shapeSettings };\n        this.triggerShapeChanging(shapeChangingArgs);\n        this.currFHDIdx++;\n    };\n    FreehandDrawing.prototype.freehandMoveHandler = function (e) {\n        this.isFreehandPointMoved = true;\n        var rect = this.parent.upperCanvas.getBoundingClientRect();\n        var x;\n        var y;\n        if (e.type === 'mousemove') {\n            x = e.clientX - rect.left;\n            y = e.clientY - rect.top;\n        }\n        else {\n            x = e.touches[0].clientX - rect.left;\n            y = e.touches[0].clientY - rect.top;\n        }\n        if (this.isFreehandDrawing) {\n            this.upperContext.fillStyle = this.parent.activeObj.strokeSettings.strokeColor;\n            if (this.parent.isMaskImage) {\n                this.upperContext.globalCompositeOperation = 'xor';\n            }\n            this.processPoint(x, y, false, this.upperContext);\n        }\n    };\n    FreehandDrawing.prototype.processPoint = function (x, y, mouseDown, context) {\n        var parent = this.parent;\n        var lastPoint = this.point(x, y, new Date().getTime());\n        lastPoint = parent.points.length > 0 && parent.points[parent.points.length - 1];\n        var isLastPointTooClose = lastPoint ? this.distanceTo(lastPoint) <= 5 : false;\n        var controlPoint1;\n        var controlPoint2;\n        var startPoint;\n        var endPoint;\n        this.selPoints.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,\n            ratioY: (y - parent.img.destTop) / parent.img.destHeight, time: this.fhdObj.time });\n        if (!lastPoint || !(lastPoint && isLastPointTooClose) || mouseDown) {\n            this.fhdObj.time = new Date().getTime();\n            parent.points.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,\n                ratioY: (y - parent.img.destTop) / parent.img.destHeight,\n                time: this.fhdObj.time });\n            this.dummyPoints.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,\n                ratioY: (y - parent.img.destTop) / parent.img.destHeight,\n                time: this.fhdObj.time });\n            if (this.dummyPoints.length > 2) {\n                if (this.dummyPoints.length === 3) {\n                    this.dummyPoints.unshift(this.dummyPoints[0]);\n                }\n                var p0 = this.dummyPoints[0];\n                var p1 = this.dummyPoints[1];\n                var p2 = this.dummyPoints[2];\n                var p3 = this.dummyPoints[3];\n                controlPoint1 = this.calcCurveCP(p0, p1, p2).controlPoint2;\n                controlPoint2 = this.calcCurveCP(p1, p2, p3).controlPoint1;\n                startPoint = this.dummyPoints[1];\n                endPoint = this.dummyPoints[2];\n                var minStrokeWidth = 0.5;\n                var maxStrokeWidth = 5;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.penStrokeWidth)) {\n                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;\n                }\n                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);\n                this.pointCounter++;\n                this.dummyPoints.shift();\n            }\n            if (mouseDown) {\n                controlPoint1 = controlPoint2 = startPoint = endPoint = { x: x, y: y, time: new Date().getTime() };\n                var minStrokeWidth = 0.5;\n                var maxStrokeWidth = 5;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.penStrokeWidth)) {\n                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;\n                }\n                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);\n            }\n        }\n    };\n    FreehandDrawing.prototype.calcCurveCP = function (p1, p2, p3) {\n        if (!p2) {\n            p2 = p1;\n        }\n        if (!p3) {\n            p3 = p2;\n        }\n        var dx1 = p1.x - p2.x;\n        var dy1 = p1.y - p2.y;\n        var dx2 = p2.x - p3.x;\n        var dy2 = p2.y - p3.y;\n        var m1 = { x: (p1.x + p2.x) / 2.0, y: (p1.y + p2.y) / 2.0 };\n        var m2 = { x: (p2.x + p3.x) / 2.0, y: (p2.y + p3.y) / 2.0 };\n        var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        var dxm = (m1.x - m2.x);\n        var dym = (m1.y - m2.y);\n        var k = l2 / (l1 + l2);\n        var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n        var tx = p2.x - cm.x;\n        var ty = p2.y - cm.y;\n        return {\n            controlPoint1: this.point(m1.x + tx, m1.y + ty, 0),\n            controlPoint2: this.point(m2.x + tx, m2.y + ty, 0)\n        };\n    };\n    FreehandDrawing.prototype.point = function (x, y, time) {\n        this.fhdObj.pointX = x;\n        this.fhdObj.pointY = y;\n        return { x: this.fhdObj.pointX, y: this.fhdObj.pointY, time: time };\n    };\n    FreehandDrawing.prototype.startDraw = function (context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth) {\n        var tempVelocity;\n        tempVelocity = this.pointVelocity(startPoint);\n        tempVelocity = 0.7 * tempVelocity + (1 - 0.7) * this.fhdObj.lastVelocity;\n        var newWidth = Math.max(maxStrokeWidth / (0.7 + 1), minStrokeWidth);\n        this.drawCurve(this.fhdObj.time, newWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth);\n        this.fhdObj.lastVelocity = tempVelocity;\n        this.fhdObj.time = newWidth;\n    };\n    FreehandDrawing.prototype.pointVelocity = function (startPoint) {\n        return (this.fhdObj.time !== startPoint.time) ? this.distanceTo(startPoint) /\n            (this.fhdObj.time - startPoint.time) : 0;\n    };\n    FreehandDrawing.prototype.distanceTo = function (start) {\n        return Math.sqrt(Math.pow(this.fhdObj.pointX - start.x, 2) + Math.pow(this.fhdObj.pointY - start.y, 2));\n    };\n    FreehandDrawing.prototype.drawCurve = function (startWidth, endWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth) {\n        var width;\n        var i;\n        var t1;\n        var t2;\n        var t3;\n        var u1;\n        var u2;\n        var u3;\n        var x;\n        var y;\n        var widthValue = endWidth - startWidth;\n        var bezierLength = this.bezierLength(controlPoint1, controlPoint2, startPoint, endPoint);\n        var drawSteps = Math.ceil(bezierLength) * 2;\n        context.beginPath();\n        for (i = 0; i < drawSteps; i++) {\n            t1 = i / drawSteps;\n            t2 = t1 * t1;\n            t3 = t2 * t1;\n            u1 = 1 - t1;\n            u2 = u1 * u1;\n            u3 = u2 * u1;\n            x = u3 * startPoint.x;\n            x += 3 * u2 * t1 * controlPoint1.x;\n            x += 3 * u1 * t2 * controlPoint2.x;\n            x += t3 * endPoint.x;\n            y = u3 * startPoint.y;\n            y += 3 * u2 * t1 * controlPoint1.y;\n            y += 3 * u1 * t2 * controlPoint2.y;\n            y += t3 * endPoint.y;\n            width = Math.min(startWidth + t3 * widthValue, maxStrokeWidth);\n            this.drawArc(x, y, width, context);\n        }\n        context.closePath();\n        context.fill();\n    };\n    FreehandDrawing.prototype.bezierLength = function (controlPoint1, controlPoint2, startPoint, endPoint) {\n        var steps = 10;\n        var length = 0;\n        var i;\n        var t;\n        var pointX1;\n        var pointY1;\n        var pointX2;\n        var pointY2;\n        var pointX3;\n        var pointY3;\n        for (i = 0; i <= steps; i++) {\n            t = i / steps;\n            pointX1 = this.bezierPoint(t, startPoint.x, controlPoint1.x, controlPoint2.x, endPoint.x);\n            pointY1 = this.bezierPoint(t, startPoint.y, controlPoint1.y, controlPoint2.y, endPoint.y);\n            if (i > 0) {\n                pointX3 = pointX1 - pointX2;\n                pointY3 = pointY1 - pointY2;\n                length += Math.sqrt(pointX3 * pointX3 + pointY3 * pointY3);\n            }\n            pointX2 = pointX1;\n            pointY2 = pointY1;\n        }\n        return length;\n    };\n    FreehandDrawing.prototype.bezierPoint = function (t, startPoint, cp1, cp2, endPoint) {\n        return startPoint * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * cp1 * (1.0 - t) * (1.0 - t) * t + 3.0 *\n            cp2 * (1.0 - t) * t * t + endPoint * t * t * t;\n    };\n    FreehandDrawing.prototype.drawArc = function (x, y, size, context) {\n        var img = this.parent.img;\n        if ((x > img.destLeft && y > img.destTop && x < (img.destLeft + img.destWidth) &&\n            y < (img.destTop + img.destHeight) ||\n            (context !== this.lowerContext && context !== this.upperContext))) {\n            context.moveTo(x, y);\n            context.arc(x, y, size, 0, 2 * Math.PI, false);\n        }\n    };\n    FreehandDrawing.prototype.freehandRedraw = function (context, points) {\n        var parent = this.parent;\n        var temp = context.filter;\n        context.filter = 'none';\n        if (points) {\n            parent.pointColl[parent.freehandCounter] = { points: points, strokeColor: parent.activeObj.strokeSettings.strokeColor,\n                strokeWidth: this.penStrokeWidth, flipState: parent.transform.currFlipState,\n                id: 'pen_' + (parent.freehandCounter + 1), order: parent.objColl.length + parent.freehandCounter + 1 };\n            this.selPointColl[parent.freehandCounter] = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.pointColl[parent.freehandCounter], {}, true);\n            parent.freehandCounter++;\n        }\n        if (parent.freehandCounter > 0) {\n            for (var n = 0; n < parent.freehandCounter; n++) {\n                parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points);\n                this.pointCounter = 0;\n                var len = parent.points.length;\n                var controlPoint1 = void 0;\n                var controlPoint2 = void 0;\n                var startPoint = void 0;\n                var endPoint = void 0;\n                var minStrokeWidth = void 0;\n                var maxStrokeWidth = void 0;\n                if (len > 0) {\n                    context.fillStyle = parent.pointColl[n].strokeColor;\n                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = parent.pointColl[n].strokeWidth;\n                }\n                if (len === 1) {\n                    controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];\n                    this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);\n                }\n                for (var l = 0; l < len - 3; l++) {\n                    if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {\n                        controlPoint1 = (this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2])).controlPoint2;\n                        controlPoint2 = (this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3])).controlPoint1;\n                        if (l === 0) {\n                            startPoint = parent.points[l];\n                        }\n                        else {\n                            startPoint = parent.points[l + 1];\n                        }\n                        endPoint = parent.points[l + 2];\n                        this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);\n                    }\n                }\n                context.closePath();\n            }\n            if (context === this.lowerContext) {\n                parent.notify('draw', { prop: 'applyFrame', value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });\n                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            }\n        }\n        context.filter = temp;\n    };\n    FreehandDrawing.prototype.getSqPtFD = function (idx, obj) {\n        var activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };\n        var sPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl[idx].points, []);\n        this.parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.parent.pointColl[idx].points);\n        this.pointCounter = 0;\n        var len = sPoints.length;\n        for (var l = 0; l < len; l++) {\n            if (activePoint.startX === 0 && activePoint.startY === 0 && activePoint.endX === 0 && activePoint.endY === 0) {\n                activePoint.startX = sPoints[l].x;\n                activePoint.startY = sPoints[l].y;\n                activePoint.endX = sPoints[l].x;\n                activePoint.endY = sPoints[l].y;\n            }\n            else {\n                activePoint.startX = Math.min(activePoint.startX, sPoints[l].x);\n                activePoint.startY = Math.min(activePoint.startY, sPoints[l].y);\n                activePoint.endX = Math.max(activePoint.endX, sPoints[l].x);\n                activePoint.endY = Math.max(activePoint.endY, sPoints[l].y);\n            }\n        }\n        activePoint.startX -= this.penStrokeWidth;\n        activePoint.startY -= this.penStrokeWidth;\n        activePoint.endX += this.penStrokeWidth;\n        activePoint.endY += this.penStrokeWidth;\n        activePoint.width = activePoint.endX - activePoint.startX;\n        activePoint.height = activePoint.endY - activePoint.startY;\n        if (obj) {\n            obj['activePoint'] = activePoint;\n        }\n        return activePoint;\n    };\n    FreehandDrawing.prototype.applyPenDraw = function () {\n        var parent = this.parent;\n        if (parent.currObjType.shape === 'freehanddraw') {\n            parent.notify('shape', { prop: 'apply', onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });\n            parent.upperCanvas.style.cursor = parent.cursor = 'default';\n            parent.currObjType.shape = '';\n        }\n        parent.notify('shape', { prop: 'clearActObj' });\n    };\n    FreehandDrawing.prototype.applyFhd = function () {\n        var parent = this.parent;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var selectedPoint = parent.pointColl[this.fhdSelIdx];\n        if (selectedPoint.strokeColor === '#42a5f5') {\n            selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;\n        }\n        parent.notify('toolbar', { prop: 'setSelectedFreehandColor', value: { color: '#42a5f5' } });\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);\n        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });\n        parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n        if (selectedPoint) {\n            selectedPoint.isSelected = false;\n        }\n        parent.notify('selection', { prop: 'resetFreehandDrawVariables' });\n        this.fhdHovIdx = this.fhdSelIdx = null;\n    };\n    FreehandDrawing.prototype.cancelFhd = function () {\n        var parent = this.parent;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var selectedPoint = parent.pointColl[this.fhdSelIdx];\n        parent.notify('toolbar', { prop: 'setSelectedFreehandColor', value: { color: '#42a5f5' } });\n        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n        this.pointCounter = 0;\n        if (selectedPoint) {\n            selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;\n            selectedPoint.strokeWidth = this.tempFHDStyles.strokeWidth;\n            selectedPoint.isSelected = false;\n        }\n        this.fhdHovIdx = this.fhdSelIdx = this.fhdSelID = null;\n        parent.notify('selection', { prop: 'resetFreehandDrawVariables' });\n        parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor;\n        parent.activeObj.strokeSettings.strokeWidth = this.penStrokeWidth = this.tempFHDStyles.strokeWidth;\n        this.tempFHDStyles = { strokeColor: null, strokeWidth: null, fillColor: null };\n        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });\n        parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n    };\n    FreehandDrawing.prototype.selectFhd = function (index) {\n        var parent = this.parent;\n        var tempFHDStyles = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.tempFHDStyles, {}, true);\n        parent.notify('selection', { prop: 'setFreehandDrawEditing', onPropertyChange: false, value: { bool: true } });\n        if (index || index === 0) {\n            if (this.isFHDIdx(index)) {\n                this.fhdSelIdx = this.fhdHovIdx = index;\n                this.hoverFhd();\n                parent.upperCanvas.style.cursor = parent.cursor = 'pointer';\n            }\n            else {\n                return;\n            }\n        }\n        this.fhdSelIdx = this.fhdHovIdx;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var point = parent.pointColl[this.fhdSelIdx];\n        point.isSelected = true;\n        this.fhdSelID = point.id;\n        if (point.strokeColor !== '#42a5f5') {\n            parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor = point.strokeColor;\n        }\n        parent.activeObj.strokeSettings.strokeWidth = this.tempFHDStyles.strokeWidth =\n            parent.pointColl[this.fhdHovIdx].strokeWidth;\n        var obj = { bool: false };\n        parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });\n        if (obj['bool']) {\n            var shapeSettings = { id: 'pen_' + (this.fhdSelIdx + 1), type: _index__WEBPACK_IMPORTED_MODULE_1__.ShapeType.FreehandDraw,\n                startX: point.points[0].x, startY: point.points[0].y, strokeColor: point.strokeColor,\n                strokeWidth: point.strokeWidth, points: point.points, opacity: point.opacity,\n                index: point.order };\n            var shapeChangingArgs = { cancel: false, action: 'select', previousShapeSettings: shapeSettings,\n                currentShapeSettings: shapeSettings };\n            this.triggerShapeChanging(shapeChangingArgs);\n        }\n        else {\n            parent.okBtn(null, true);\n        }\n        if (parent.isUndoRedoStack) {\n            this.tempFHDStyles = tempFHDStyles;\n        }\n    };\n    // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n    FreehandDrawing.prototype.deleteFhd = function (index, isId) {\n        var parent = this.parent;\n        if (this.isFHDIdx(index)) {\n            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var tempPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.pointColl, {}, true);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var tempSelPointColl = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.selPointColl, {}, true);\n            parent.pointColl = {};\n            this.selPointColl = {};\n            var count = 0;\n            for (var i = 0; i < parent.freehandCounter; i++) {\n                if (parseInt(tempPointColl[i].id.split('_')[1], 10) - 1 !== index) {\n                    parent.pointColl[count] = tempPointColl[i];\n                    this.selPointColl[count] = tempSelPointColl[i];\n                    count++;\n                }\n            }\n            parent.freehandCounter -= 1;\n            this.fhdHovIdx = this.fhdSelIdx = null;\n            parent.notify('selection', { prop: 'resetFreehandDrawVariables' });\n            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });\n            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n        }\n    };\n    FreehandDrawing.prototype.zoomX = function (x) {\n        return (x * this.parent.img.destWidth) + this.parent.img.destLeft;\n    };\n    FreehandDrawing.prototype.zoomY = function (y) {\n        return (y * this.parent.img.destHeight) + this.parent.img.destTop;\n    };\n    FreehandDrawing.prototype.zoomFHDColl = function (isPreventApply) {\n        var parent = this.parent;\n        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,\n            width: parent.img.destWidth, height: parent.img.destHeight };\n        parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n            this.pointCounter = 0;\n            var len = parent.points.length;\n            for (var l = 0; l < len; l++) {\n                var point = parent.points[l];\n                point.x = this.zoomX(point.ratioX);\n                point.y = this.zoomY(point.ratioY);\n            }\n        }\n        this.updateFHDCurPts();\n        if (this.straightenPoint.x && this.straightenPoint.y) {\n            this.straightenPoint.x = this.zoomX(this.straightenPoint.ratioX);\n            this.straightenPoint.y = this.zoomY(this.straightenPoint.ratioY);\n        }\n        if (parent.transform.straighten !== 0) {\n            parent.notify('shape', { prop: 'straightenFHD', onPropertyChange: false });\n        }\n        parent.img.destLeft = destPoints.startX;\n        parent.img.destTop = destPoints.startY;\n        parent.img.destWidth = destPoints.width;\n        parent.img.destHeight = destPoints.height;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isPreventApply)) {\n            this.freehandRedraw(this.lowerContext, null);\n        }\n    };\n    FreehandDrawing.prototype.updateFHDCurPts = function () {\n        var parent = this.parent;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (this.selPointColl[n]) {\n                this.selPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl[n].points, []);\n                this.pointCounter = 0;\n                var len = this.selPoints.length;\n                for (var l = 0; l < len; l++) {\n                    var point = this.selPoints[l];\n                    point.x = this.zoomX(point.ratioX);\n                    point.y = this.zoomY(point.ratioY);\n                }\n            }\n        }\n    };\n    FreehandDrawing.prototype.rotateFhdColl = function () {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n            this.pointCounter = 0;\n            var len = parent.points.length;\n            for (var l = 0; l < len; l++) {\n                var point = parent.points[l];\n                point.y = destTop + (destHeight * point.ratioX);\n                point.x = (destLeft + destWidth) - (destWidth * point.ratioY);\n                point.ratioX = (point.x - destLeft) / destWidth;\n                point.ratioY = (point.y - destTop) / destHeight;\n            }\n        }\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (this.selPointColl[n]) {\n                this.selPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl[n].points, []);\n                this.pointCounter = 0;\n                var len = this.selPoints.length;\n                for (var l = 0; l < len; l++) {\n                    var point = this.selPoints[l];\n                    point.y = destTop + (destHeight * point.ratioX);\n                    point.x = (destLeft + destWidth) - (destWidth * point.ratioY);\n                    point.ratioX = (point.x - destLeft) / destWidth;\n                    point.ratioY = (point.y - destTop) / destHeight;\n                }\n            }\n        }\n        this.updateFHDCurPts();\n    };\n    FreehandDrawing.prototype.flipFHDColl = function (value) {\n        var lowercaseValue = value.toLowerCase();\n        if (lowercaseValue === 'horizontal') {\n            this.pointsHorizontalFlip();\n        }\n        else if (lowercaseValue === 'vertical') {\n            this.pointsVerticalFlip();\n        }\n        else {\n            this.pointsHorizontalFlip();\n            for (var i = 0; i < this.parent.freehandCounter; i++) {\n                this.parent.pointColl[i].shapeFlip = '';\n            }\n            this.pointsVerticalFlip();\n        }\n    };\n    FreehandDrawing.prototype.pointsHorizontalFlip = function () {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {\n                parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n                this.pointCounter = 0;\n                var len = parent.points.length;\n                for (var l = 0; l < len; l++) {\n                    var point = parent.points[l];\n                    if (point.x <= destLeft + (destWidth / 2)) {\n                        point.x = (destLeft + destWidth) - (point.x - destLeft);\n                    }\n                    else if (point.x >= destLeft + (destWidth / 2)) {\n                        point.x = destLeft + (destLeft + destWidth - point.x);\n                    }\n                    point.ratioX = (point.x - destLeft) / destWidth;\n                    point.ratioY = (point.y - destTop) / destHeight;\n                }\n                parent.pointColl[n].shapeFlip = parent.transform.currFlipState;\n            }\n        }\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (this.selPointColl[n]) {\n                if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {\n                    this.selPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl[n].points, []);\n                    this.pointCounter = 0;\n                    var len = this.selPoints.length;\n                    for (var l = 0; l < len; l++) {\n                        var point = this.selPoints[l];\n                        if (point.x <= destLeft + (destWidth / 2)) {\n                            point.x = (destLeft + destWidth) - (point.x - destLeft);\n                        }\n                        else if (point.x >= destLeft + (destWidth / 2)) {\n                            point.x = destLeft + (destLeft + destWidth - point.x);\n                        }\n                        point.ratioX = (point.x - destLeft) / destWidth;\n                        point.ratioY = (point.y - destTop) / destHeight;\n                    }\n                }\n            }\n        }\n        this.updateFHDCurPts();\n    };\n    FreehandDrawing.prototype.pointsVerticalFlip = function () {\n        var parent = this.parent;\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {\n                parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n                this.pointCounter = 0;\n                var len = parent.points.length;\n                for (var l = 0; l < len; l++) {\n                    var point = parent.points[l];\n                    if (point.y <= destTop + (destHeight / 2)) {\n                        point.y = (destTop + destHeight) - (point.y - destTop);\n                    }\n                    else if (point.y >= destTop + (destHeight / 2)) {\n                        point.y = destTop + (destTop + destHeight - point.y);\n                    }\n                    point.ratioX = (point.x - destLeft) / destWidth;\n                    point.ratioY = (point.y - destTop) / destHeight;\n                }\n                parent.pointColl[n].shapeFlip = parent.transform.currFlipState;\n            }\n        }\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (this.selPointColl[n]) {\n                if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {\n                    this.selPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl[n].points, []);\n                    this.pointCounter = 0;\n                    var len = this.selPoints.length;\n                    for (var l = 0; l < len; l++) {\n                        var point = this.selPoints[l];\n                        if (point.y <= destTop + (destHeight / 2)) {\n                            point.y = (destTop + destHeight) - (point.y - destTop);\n                        }\n                        else if (point.y >= destTop + (destHeight / 2)) {\n                            point.y = destTop + (destTop + destHeight - point.y);\n                        }\n                        point.ratioX = (point.x - destLeft) / destWidth;\n                        point.ratioY = (point.y - destTop) / destHeight;\n                    }\n                }\n            }\n        }\n        this.updateFHDCurPts();\n    };\n    FreehandDrawing.prototype.updateFHDColl = function (isPreventApply) {\n        var parent = this.parent;\n        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,\n            width: parent.img.destWidth, height: parent.img.destHeight };\n        parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        for (var i = 0, iLen = parent.objColl.length; i < iLen; i++) {\n            var currObj = parent.objColl[i];\n            if (currObj.shape === 'line' || currObj.shape === 'arrow') {\n                parent.notify('shape', { prop: 'straightenShapePoints', value: { obj: currObj, isReverse: true } });\n            }\n            else if (currObj.shape === 'path') {\n                var temp = parent.transform.straighten;\n                parent.transform.straighten = -parent.transform.straighten;\n                parent.notify('shape', { prop: 'straightenPath', onPropertyChange: false, value: { obj: currObj } });\n                parent.transform.straighten = temp;\n            }\n            currObj.imageRatio = { startX: ((currObj.activePoint.startX - destLeft) /\n                    destWidth), startY: ((currObj.activePoint.startY - destTop) / destHeight),\n                endX: ((currObj.activePoint.endX - destLeft) / destWidth),\n                endY: ((currObj.activePoint.endY - destTop) / destHeight),\n                width: destWidth / currObj.activePoint.width, height: destHeight /\n                    currObj.activePoint.height };\n            if (currObj.shape === 'path') {\n                for (var j = 0, jLen = currObj.pointColl.length; j < jLen; j++) {\n                    currObj.pointColl[j].ratioX =\n                        (currObj.pointColl[j].x - destLeft) / destWidth;\n                    currObj.pointColl[j].ratioY =\n                        (currObj.pointColl[j].y - destTop) / destHeight;\n                }\n            }\n            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n        }\n        if (parent.freehandCounter > 0 && parent.transform.straighten !== 0) {\n            var temp = parent.transform.straighten;\n            parent.transform.straighten = -parent.transform.straighten;\n            parent.notify('shape', { prop: 'straightenFHD', onPropertyChange: false });\n            parent.transform.straighten = temp;\n        }\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n            this.pointCounter = 0;\n            var len = parent.points.length;\n            for (var l = 0; l < len; l++) {\n                var point = parent.points[l];\n                point.ratioX = (point.x - destLeft) / destWidth;\n                point.ratioY = (point.y - destTop) / destHeight;\n            }\n        }\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (this.selPointColl[n]) {\n                this.selPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl[n].points, []);\n                this.pointCounter = 0;\n                var len = this.selPoints.length;\n                for (var l = 0; l < len; l++) {\n                    var point = this.selPoints[l];\n                    point.ratioX = (point.x - destLeft) / destWidth;\n                    point.ratioY = (point.y - destTop) / destHeight;\n                }\n            }\n        }\n        if (this.straightenPoint.x && this.straightenPoint.y) {\n            this.straightenPoint.ratioX = (this.straightenPoint.x - destLeft) / destWidth;\n            this.straightenPoint.ratioY = (this.straightenPoint.y - destTop) / destHeight;\n        }\n        parent.img.destLeft = destPoints.startX;\n        parent.img.destTop = destPoints.startY;\n        parent.img.destWidth = destPoints.width;\n        parent.img.destHeight = destPoints.height;\n        parent.notify('shape', { prop: 'drawAnnotations', onPropertyChange: false,\n            value: { ctx: this.lowerContext, shape: 'zoom', pen: 'zoom', isPreventApply: isPreventApply } });\n    };\n    FreehandDrawing.prototype.panFHDColl = function (xDiff, yDiff, panRegion) {\n        var parent = this.parent;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            parent.points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], parent.pointColl[n].points, []);\n            this.pointCounter = 0;\n            var len = parent.points.length;\n            for (var l = 0; l < len; l++) {\n                var point = parent.points[l];\n                if (panRegion === '' || panRegion === 'vertical') {\n                    point.x += xDiff;\n                }\n                else {\n                    point.x -= xDiff;\n                }\n                if (panRegion === '' || panRegion === 'horizontal') {\n                    point.y += yDiff;\n                }\n                else {\n                    point.y -= yDiff;\n                }\n            }\n        }\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            if (this.selPointColl[n]) {\n                this.selPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl[n].points, []);\n                this.pointCounter = 0;\n                var len = this.selPoints.length;\n                for (var l = 0; l < len; l++) {\n                    var point = this.selPoints[l];\n                    if (panRegion === '' || panRegion === 'vertical') {\n                        point.x += xDiff;\n                    }\n                    else {\n                        point.x -= xDiff;\n                    }\n                    if (panRegion === '' || panRegion === 'horizontal') {\n                        point.y += yDiff;\n                    }\n                    else {\n                        point.y -= yDiff;\n                    }\n                }\n            }\n        }\n        if (this.straightenPoint.x && this.straightenPoint.y) {\n            if (panRegion === '' || panRegion === 'vertical') {\n                this.straightenPoint.x += xDiff;\n            }\n            else {\n                this.straightenPoint.x -= xDiff;\n            }\n            if (panRegion === '' || panRegion === 'horizontal') {\n                this.straightenPoint.y += yDiff;\n            }\n            else {\n                this.straightenPoint.y -= yDiff;\n            }\n        }\n        this.freehandRedraw(this.lowerContext, null);\n    };\n    FreehandDrawing.prototype.freeHandDraw = function (value) {\n        var parent = this.parent;\n        if (value) {\n            parent.points = [];\n            this.dummyPoints = [];\n            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });\n            parent.togglePen = true;\n            parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';\n            parent.upperCanvas.style.display = 'block';\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.strokeSettings)) {\n                var obj = { strokeSettings: {} };\n                parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false,\n                    value: { obj: obj } });\n                parent.activeObj.strokeSettings = obj['strokeSettings'];\n            }\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(parent.activeObj.strokeSettings.strokeWidth)) {\n                parent.activeObj.strokeSettings.strokeWidth = 2;\n            }\n            if (parent.isMaskImage) {\n                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n            }\n            else {\n                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',\n                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n            }\n        }\n        else {\n            parent.upperCanvas.style.cursor = parent.cursor = 'default';\n            var strokeWidth = this.penStrokeWidth;\n            parent.notify('shape', { prop: 'apply', onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });\n            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });\n            parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });\n            parent.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: false } });\n            this.penStrokeWidth = strokeWidth;\n        }\n    };\n    FreehandDrawing.prototype.isFHDIdx = function (index, obj) {\n        var isIndex = false;\n        for (var i = 0; i < this.parent.freehandCounter; i++) {\n            if (this.parent.pointColl[i].id &&\n                parseInt(this.parent.pointColl[i].id.split('_')[1], 10) - 1 === index) {\n                isIndex = true;\n                break;\n            }\n        }\n        if (obj) {\n            obj['isIndex'] = isIndex;\n        }\n        return isIndex;\n    };\n    FreehandDrawing.prototype.updateCropPtsForSel = function () {\n        var parent = this.parent;\n        var actPoint = parent.activeObj.activePoint;\n        for (var n = 0; n < parent.freehandCounter; n++) {\n            var obj = { selPointColl: (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.selPointColl) };\n            if (obj['selPointColl'][n]) {\n                this.selPoints = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], obj['selPointColl'][n].points, []);\n                this.pointCounter = 0;\n                var len = this.selPoints.length;\n                for (var l = 0; l < len; l++) {\n                    var point = this.selPoints[l];\n                    point.ratioX = (point.x - actPoint.startX) / actPoint.width;\n                    point.ratioY = (point.y - actPoint.startY) / actPoint.height;\n                }\n            }\n        }\n    };\n    FreehandDrawing.prototype.triggerShapeChanging = function (shapeChangingArgs) {\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        var parent = this.parent;\n        var point = parent.pointColl[this.fhdSelIdx];\n        parent.trigger('shapeChanging', shapeChangingArgs);\n        if (parent.element.getAttribute('data-value') === 'mask-drawing' && !this.isMasking) {\n            this.isMasking = true;\n            parent.upperCanvas.style.cursor = 'crosshair';\n            parent.notify('draw', { prop: 'updateTempObjColl' });\n            parent.notify('draw', { prop: 'updateTempPointColl' });\n            parent.discard();\n            parent.selectMaskImage();\n            return;\n        }\n        parent.editCompleteArgs = shapeChangingArgs;\n        if (shapeChangingArgs.currentShapeSettings.id.indexOf('pen_') === -1 &&\n            (shapeChangingArgs.action === 'draw-end' || shapeChangingArgs.action === 'select')) {\n            var id = 'pen_' + shapeChangingArgs.currentShapeSettings.id;\n            if (this.fhdSelIdx) {\n                parent.pointColl[this.fhdSelIdx].id = id;\n            }\n            else {\n                parent.pointColl[parent.freehandCounter - 1].id = id;\n            }\n        }\n        this.penStrokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;\n        if (parent.activeObj.strokeSettings.strokeColor !== shapeChangingArgs.currentShapeSettings.strokeColor) {\n            parent.activeObj.strokeSettings.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;\n            parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });\n        }\n        if (this.fhdSelID && point && shapeChangingArgs.currentShapeSettings) {\n            point.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;\n            point.strokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;\n            point.points = shapeChangingArgs.currentShapeSettings.points;\n            point.opacity = shapeChangingArgs.currentShapeSettings.opacity;\n        }\n        if (shapeChangingArgs.action === 'select') {\n            this.freehandRedraw(this.upperContext);\n            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',\n                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });\n        }\n    };\n    FreehandDrawing.prototype.setCenterSelPoints = function () {\n        var parent = this.parent;\n        var destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop,\n            width: parent.img.destWidth, height: parent.img.destHeight };\n        parent.notify('shape', { prop: 'straightenShapes', onPropertyChange: false });\n        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;\n        var actPoint = parent.activeObj.activePoint;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.prevStraightenObj) ||\n            (JSON.stringify(this.prevStraightenObj.activePoint) !== JSON.stringify(actPoint))) {\n            this.straightenPoint = { x: actPoint.startX + (actPoint.width / 2),\n                y: actPoint.startY + (actPoint.height / 2),\n                ratioX: (actPoint.startX + (actPoint.width / 2) - destLeft) / destWidth,\n                ratioY: (actPoint.startY + (actPoint.height / 2) - destTop) / destHeight };\n            this.prevStraightenObj = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, parent.activeObj, {}, true);\n            this.straightenPointAngle = parent.transform.straighten;\n        }\n        parent.img.destLeft = destPoints.startX;\n        parent.img.destTop = destPoints.startY;\n        parent.img.destWidth = destPoints.width;\n        parent.img.destHeight = destPoints.height;\n    };\n    return FreehandDrawing;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-image-editor/src/image-editor/action/freehand-draw.js?");

/***/ })

}]);