"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_print-export_export_js-2067d863"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/print-export/export.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/print-export/export.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Export: () => (/* binding */ Export)\n/* harmony export */ });\n/* harmony import */ var _common_utils_export__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/export */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/export.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _syncfusion_ej2_excel_export__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-excel-export */ \"./node_modules/@syncfusion/ej2-excel-export/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\n\n/**\n * The `Export` module is used to print and export the rendered chart.\n */\nvar Export = /** @class */ (function () {\n    /**\n     * Constructor for export module.\n     *\n     * @private\n     */\n    function Export(chart) {\n        this.actualRowCount = 0;\n        this.series = [];\n        this.axisCollection = [];\n        this.requiredValuesLength = 0;\n        this.histogramSeriesCount = 0;\n        this.chart = chart;\n    }\n    /**\n     * Exports the chart or charts to the specified file format.\n     *\n     * @param {ExportType} type - The type of export (e.g., 'PNG', 'JPEG', 'PDF', etc.).\n     * @param {string} fileName - The name of the file to save.\n     * @param {PdfPageOrientation} [orientation] - The orientation of the PDF page. Defaults to 'Portrait'.\n     * @param {(Chart | AccumulationChart | RangeNavigator | StockChart)[]} [controls] - An array of chart or chart-like components to export.\n     * @param {number} [width] - The width of the exported image or PDF page.\n     * @param {number} [height] - The height of the exported image or PDF page.\n     * @param {boolean} [isVertical] - Specifies whether to export the chart vertically. Defaults to false.\n     * @param {IPDFArgs} [header] - The header options for the PDF.\n     * @param {IPDFArgs} [footer] - The footer options for the PDF.\n     * @param {boolean} [exportToMultiplePage] - Specifies whether to export the charts to multiple pages in PDF. Defaults to false.\n     * @returns {void}\n     * @public\n     */\n    Export.prototype.export = function (type, fileName, orientation, controls, width, height, isVertical, header, footer, exportToMultiplePage) {\n        var exportChart = new _common_utils_export__WEBPACK_IMPORTED_MODULE_0__.ExportUtils(this.chart);\n        controls = controls ? controls : [this.chart];\n        if (type === 'CSV' || type === 'XLSX') {\n            this.excelExport(controls, fileName, type, width, height);\n        }\n        else {\n            var argsData = {\n                cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_1__.beforeExport, width: width, height: height, excelProperties: {\n                    rows: undefined,\n                    columns: undefined\n                }\n            };\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_1__.beforeExport, argsData);\n            if (!argsData.cancel) {\n                exportChart.export(type, fileName, orientation, controls, width = argsData.width, height = argsData.height, isVertical, header, footer, exportToMultiplePage);\n            }\n        }\n    };\n    /**\n     * Exports the specified chart or charts to Excel format.\n     *\n     * @param {(Chart | AccumulationChart | RangeNavigator | StockChart)[]} controls - An array of chart or chart-like components to export.\n     * @param {string} fileName - The name of the Excel file to save.\n     * @param {ExportType} type - The type of export (e.g., 'XLSX', 'CSV', etc.).\n     * @param {number} [width] - The width of the exported Excel sheet.\n     * @param {number} [height] - The width of the exported Excel sheet.\n     * @returns {void}\n     * @private\n     */\n    Export.prototype.excelExport = function (controls, fileName, type, width, height) {\n        this.rows = [];\n        this.actualRowCount = 1;\n        var workSheets = [];\n        var requiredValues = [];\n        var headerStyle = { bold: true, hAlign: 'Center', vAlign: 'Center', wrapText: true };\n        var xValues = [];\n        for (var i = 0; i < controls.length; i++) {\n            var isRangeNavigator = controls[i].getModuleName() === 'rangeNavigator';\n            var isAccumulation = controls[i].getModuleName() === 'accumulationchart';\n            this.series = isRangeNavigator ? controls[i].series :\n                controls[i].visibleSeries;\n            if (isRangeNavigator && this.series.length === 0) {\n                if (controls[i].dataSource) {\n                    //To create an Excel sheet when the Rangenavigator series is not given.\n                    this.createRangeNavigatorExcelSheet(controls[i], headerStyle, type);\n                }\n            }\n            else {\n                this.histogramSeriesCount = 0;\n                this.requiredValuesLength = 0;\n                this.axisCollection = [];\n                if (isAccumulation || isRangeNavigator) {\n                    this.axisCollection.push(null);\n                }\n                else {\n                    this.axisCollection = controls[i].getModuleName() === 'stockChart' ? controls[i].chart.horizontalAxes : controls[i].horizontalAxes;\n                }\n                //To get the number of columns for the excel.\n                requiredValues = this.getRequiredValues(isRangeNavigator);\n                if (this.requiredValuesLength === 0 && this.series.length === this.histogramSeriesCount) {\n                    return;\n                }\n                //To get all x values in the series.\n                xValues = this.getXValue(requiredValues, controls[i], isRangeNavigator, isAccumulation);\n                //To get the the chart title and series name.\n                this.getTitle(requiredValues, headerStyle, controls[i], isRangeNavigator, isAccumulation, type, xValues[0].length);\n                //To create an Excel sheet.\n                this.createExcelSheet(isRangeNavigator, isAccumulation, xValues, type, requiredValues, headerStyle, controls[i]);\n            }\n        }\n        var columns = [];\n        this.requiredValuesLength = this.requiredValuesLength === 0 ? 1 : this.requiredValuesLength;\n        for (var columnCount = 0; columnCount < this.requiredValuesLength; columnCount++) {\n            columns.push({ index: columnCount + 1, width: 100 });\n        }\n        var argsData = {\n            cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_1__.beforeExport, width: width, height: height, excelProperties: {\n                rows: this.rows,\n                columns: columns\n            }\n        };\n        controls[0].trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_1__.beforeExport, argsData);\n        if (!argsData.cancel) {\n            workSheets.push({ columns: argsData.excelProperties.columns, rows: argsData.excelProperties.rows });\n            var book = new _syncfusion_ej2_excel_export__WEBPACK_IMPORTED_MODULE_2__.Workbook({ worksheets: workSheets }, type === 'XLSX' ? 'xlsx' : 'csv');\n            fileName = fileName ? fileName : type === 'XLSX' ? 'XLSX' : 'CSV';\n            book.save(fileName + (type === 'XLSX' ? '.xlsx' : '.csv'));\n        }\n    };\n    /**\n     * Creates an Excel sheet for exporting RangeNavigator control data.\n     *\n     * @param {RangeNavigator} controls - The RangeNavigator control to export.\n     * @param {ExcelCellStyle} headerStyle - The style to apply to the header cells in the Excel sheet.\n     * @param {ExportType} type - The type of export (e.g., 'XLSX', 'CSV', etc.).\n     * @returns {void}\n     * @private\n     */\n    Export.prototype.createRangeNavigatorExcelSheet = function (controls, headerStyle, type) {\n        var xName = controls.xName;\n        var yName = controls.yName;\n        this.rows.push({\n            index: this.actualRowCount, cells: [{ index: 1, value: controls.valueType.indexOf('DateTime') > -1 ? controls.valueType : 'Category', colSpan: 1, rowSpan: 1,\n                    style: headerStyle },\n                { index: 2, value: yName, colSpan: 1, rowSpan: 1, style: headerStyle }]\n        });\n        this.actualRowCount++;\n        var dataSource = controls.dataSource;\n        for (var dataCount = 0; dataCount < dataSource.length; dataCount++) {\n            this.rows.push({ index: this.actualRowCount, cells: [{ index: 1, value: (type === 'CSV' && dataSource[dataCount][xName] === null) ? '' :\n                            dataSource[dataCount][xName], colSpan: 1, rowSpan: 1, style: headerStyle },\n                    { index: 2, value: (type === 'CSV' && dataSource[dataCount][yName] === null) ? '' : dataSource[dataCount][yName], colSpan: 1, rowSpan: 1, style: {} }] });\n            this.actualRowCount++;\n        }\n        this.requiredValuesLength = 2;\n    };\n    /**\n     * Gets the number of columns for the Excel sheet.\n     *\n     * @param {boolean} isRangeNavigator - Specifies whether the data is for a RangeNavigator control.\n     * @returns {string[][]} - An array containing the required values for the Excel sheet.\n     * @private\n     */\n    Export.prototype.getRequiredValues = function (isRangeNavigator) {\n        var requiredValues = [];\n        var _loop_1 = function (seriesCount) {\n            var seriesType = this_1.series[seriesCount].type;\n            if ((!isRangeNavigator && !this_1.series[seriesCount].visible) || this_1.series[seriesCount].category === 'TrendLine') {\n                requiredValues.push([]);\n                return \"continue\";\n            }\n            if (seriesType === 'Histogram') {\n                requiredValues.push([]);\n                this_1.histogramSeriesCount++;\n            }\n            else if (this_1.series[seriesCount].category === 'Pareto') {\n                requiredValues.push([this_1.series[seriesCount]['xName'], 'y']);\n            }\n            else if (seriesType.indexOf('Range') !== -1 || seriesType === 'Hilo') {\n                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['high'], this_1.series[seriesCount]['low']]);\n            }\n            else if (seriesType === 'HiloOpenClose' || seriesType === 'Candle') {\n                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['high'], this_1.series[seriesCount]['low'], this_1.series[seriesCount]['open'], this_1.series[seriesCount]['close']]);\n                if (seriesType === 'Candle' && this_1.series[seriesCount]['volume'] !== '') {\n                    requiredValues[seriesCount].push(this_1.series[seriesCount]['volume']);\n                }\n            }\n            else if (seriesType === 'BoxAndWhisker') {\n                requiredValues.push([this_1.series[seriesCount]['xName'], 'maximum', 'upperQuartile', 'median', 'lowerQuartile', 'minimum', 'outliers']);\n            }\n            else if (seriesType === 'Bubble') {\n                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['yName']]);\n                if (this_1.series[seriesCount]['size'] !== '') {\n                    requiredValues[seriesCount].push(this_1.series[seriesCount]['size']);\n                }\n            }\n            else if (seriesType === 'Pie') {\n                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['yName']]);\n                if (this_1.series[seriesCount]['radius'].match(/[a-zA-Z]/)) {\n                    requiredValues[seriesCount].push(this_1.series[seriesCount]['radius']);\n                }\n            }\n            else {\n                requiredValues.push([this_1.series[seriesCount]['xName'], this_1.series[seriesCount]['yName']]);\n            }\n            if (this_1.series[seriesCount].errorBar &&\n                this_1.series[seriesCount].errorBar.visible) {\n                var errorBar_1 = this_1.series[seriesCount].errorBar;\n                var errorTypes = ['verticalError', 'horizontalError', 'verticalNegativeError', 'horizontalNegativeError', 'verticalPositiveError', 'horizontalPositiveError'];\n                errorTypes.forEach(function (errorType) {\n                    if (typeof errorBar_1[errorType] === 'string') {\n                        requiredValues[seriesCount].push(errorBar_1[errorType]);\n                    }\n                });\n            }\n            this_1.requiredValuesLength += requiredValues[seriesCount].length;\n        };\n        var this_1 = this;\n        for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {\n            _loop_1(seriesCount);\n        }\n        return requiredValues;\n    };\n    /**\n     * Gets the title for the Excel sheet.\n     *\n     * @param {string[][]} requiredValues - The required values for the Excel sheet.\n     * @param {ExcelCellStyle} headerStyle - The style for the header.\n     * @param {(Chart | AccumulationChart | RangeNavigator | StockChart)[]} controls - The controls to export.\n     * @param {boolean} isRangeNavigator - Specifies whether the data is for a RangeNavigator control.\n     * @param {boolean} isAccumulation - Specifies whether the data is for an AccumulationChart.\n     * @param {ExportType} type - The type of export.\n     * @param {number} xValueLength - The length of X values.\n     * @returns {void}\n     * @private\n     */\n    Export.prototype.getTitle = function (requiredValues, headerStyle, control, isRangeNavigator, isAccumulation, type, xValueLength) {\n        var cells = [];\n        var additionalCells = [];\n        var index = 1;\n        var isTitle = false;\n        var titlePushRowIndex;\n        if (!isRangeNavigator && type === 'XLSX' && control.title) {\n            this.rows.push({});\n            titlePushRowIndex = this.rows.length > 0 ? this.rows.length - 1 : -1;\n            this.actualRowCount++;\n            isTitle = true;\n        }\n        for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {\n            if (isAccumulation && xValueLength === 0) {\n                break;\n            }\n            var isYName = false;\n            var valueType = '';\n            var currentIndex = index;\n            var isXValue = false;\n            for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {\n                var axisName = this.axisCollection[axisCount] !== null ? (this.axisCollection[axisCount].name === 'primaryXAxis' || (this.axisCollection[axisCount].name === 'primaryYAxis' && this.series[seriesCount].type.indexOf('Bar') > -1)) ? null : this.axisCollection[axisCount].name : '';\n                if (!isRangeNavigator && ((!isAccumulation && (axisName !==\n                    this.series[seriesCount].xAxisName)) ||\n                    !this.series[seriesCount].visible ||\n                    this.series[seriesCount].category === 'TrendLine' || this.series[seriesCount].type === 'Histogram')) {\n                    continue;\n                }\n                if (!isXValue) {\n                    cells.push({});\n                    index++;\n                }\n                isXValue = true;\n                var seriesName = this.series[seriesCount].name;\n                var requiredValuesLength = this.series[seriesCount].type === 'BoxAndWhisker' ? requiredValues[seriesCount].length - 1 : requiredValues[seriesCount].length;\n                if (requiredValues[seriesCount][1] === this.series[seriesCount].yName) {\n                    for (var requiredValuesCount = 1; requiredValuesCount < requiredValuesLength; requiredValuesCount++) {\n                        cells.push({ index: index, value: (requiredValuesCount === 1 ? seriesName ? seriesName : 'Series-' + (seriesCount + 1) : requiredValues[seriesCount][requiredValuesCount]), colSpan: 1, rowSpan: 1, style: headerStyle });\n                        index++;\n                    }\n                }\n                else {\n                    cells.push({ index: index, value: seriesName ? seriesName : 'Series-' + (seriesCount + 1), colSpan: requiredValuesLength - 1, rowSpan: 1, style: headerStyle });\n                    var localIndex = index;\n                    for (var requiredValuesCount = 1; requiredValuesCount < requiredValuesLength; requiredValuesCount++) {\n                        additionalCells.push({\n                            index: localIndex, value: requiredValues[seriesCount][requiredValuesCount],\n                            colSpan: 1, rowSpan: 1, style: headerStyle\n                        });\n                        localIndex++;\n                    }\n                    if (this.series[seriesCount].type === 'BoxAndWhisker') {\n                        cells.push({ index: localIndex, value: requiredValues[seriesCount][requiredValuesLength],\n                            colSpan: 1, rowSpan: 2, style: headerStyle\n                        });\n                        localIndex++;\n                    }\n                    index = localIndex;\n                    isYName = true;\n                }\n                valueType = isAccumulation ? requiredValues[0][0] : isRangeNavigator ? control.valueType :\n                    this.axisCollection[axisCount].valueType;\n                valueType = (isAccumulation || valueType.indexOf('DateTime') > -1) ? valueType : 'Category';\n            }\n            if (isXValue) {\n                cells[(currentIndex - 1)] = { index: currentIndex, value: valueType, colSpan: 1,\n                    rowSpan: isYName ? 2 : 1, style: headerStyle };\n            }\n        }\n        if (cells.length) {\n            this.rows.push({ index: this.actualRowCount, cells: cells });\n            this.actualRowCount++;\n        }\n        if (additionalCells.length) {\n            this.rows.push({ index: this.actualRowCount, cells: additionalCells });\n            this.actualRowCount++;\n        }\n        if (isTitle) {\n            cells = [];\n            cells.push({ index: 1, value: control.title,\n                colSpan: (index === 1 ? index : index - 1), rowSpan: 1, style: headerStyle });\n            this.rows[titlePushRowIndex] = ({ index: titlePushRowIndex + 1, cells: cells });\n        }\n        this.requiredValuesLength = index - 1;\n    };\n    /**\n     * Gets the X values for the Excel sheet.\n     *\n     * @param {string[][]} requiredValues - The required values for the Excel sheet.\n     * @param {(Chart | AccumulationChart | RangeNavigator | StockChart)[]} controls - The controls to export.\n     * @param {boolean} isRangeNavigator - Specifies whether the data is for a RangeNavigator control.\n     * @param {boolean} isAccumulation - Specifies whether the data is for an AccumulationChart.\n     * @returns {number[][]} - The X values.\n     * @private\n     */\n    Export.prototype.getXValue = function (requiredValues, control, isRangeNavigator, isAccumulation) {\n        var xValues = [];\n        for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {\n            var xValue = [];\n            var valueType = isAccumulation ? '' : isRangeNavigator ? control.valueType : this.axisCollection[axisCount].valueType;\n            for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {\n                var axisName = this.axisCollection[axisCount] !== null ? (this.axisCollection[axisCount].name === 'primaryXAxis' || (this.axisCollection[axisCount].name === 'primaryYAxis' && this.series[seriesCount].type.indexOf('Bar') > -1)) ? null : this.axisCollection[axisCount].name : '';\n                if ((!isRangeNavigator && ((!isAccumulation && (axisName !==\n                    this.series[seriesCount].xAxisName)) ||\n                    !this.series[seriesCount].visible) ||\n                    this.series[seriesCount].category === 'TrendLine' || this.series[seriesCount].type === 'Histogram')) {\n                    continue;\n                }\n                for (var dataCount = 0; dataCount < this.series[seriesCount].dataSource.length; dataCount++) {\n                    if (isAccumulation && !this.series[seriesCount].points[dataCount].visible) {\n                        continue;\n                    }\n                    xValue.push((valueType.indexOf('DateTime') > -1) ? new Date(this.series[seriesCount].\n                        dataSource[dataCount][requiredValues[seriesCount][0]]).getTime() :\n                        this.series[seriesCount].dataSource[dataCount][requiredValues[seriesCount][0]]);\n                }\n            }\n            xValues.push(xValue);\n        }\n        var _loop_2 = function (xValuesLength) {\n            xValues[xValuesLength] = xValues[xValuesLength].filter(function (item, index) {\n                return xValues[xValuesLength].indexOf(item) === index;\n            });\n        };\n        for (var xValuesLength = 0; xValuesLength < xValues.length; xValuesLength++) {\n            _loop_2(xValuesLength);\n        }\n        return (xValues);\n    };\n    /**\n     * Creates an Excel sheet.\n     *\n     * @param {boolean} isRangeNavigator - Specifies whether the data is for a RangeNavigator control.\n     * @param {boolean} isAccumulation - Specifies whether the data is for an AccumulationChart.\n     * @param {number[][]} xValues - The X values for the Excel sheet.\n     * @param {ExportType} type - The type of export.\n     * @param {string[][]} requiredValues - The required values for the Excel sheet.\n     * @param {ExcelCellStyle} headerStyle - The style for the header in Excel.\n     * @param {(Chart | AccumulationChart | RangeNavigator | StockChart)[]} controls - The controls to export.\n     * @private\n     */\n    Export.prototype.createExcelSheet = function (isRangeNavigator, isAccumulation, xValues, type, requiredValues, headerStyle, controls) {\n        var startIndex = 0;\n        var index = 0;\n        for (var axisCount = 0; axisCount < this.axisCollection.length; axisCount++) {\n            var valueType = isAccumulation ? '' : isRangeNavigator ? controls[0].valueType : this.axisCollection[axisCount].valueType;\n            for (var xValueLength = 0; xValueLength < xValues[axisCount].length; xValueLength++) {\n                index = startIndex ? startIndex : 1;\n                var cells = [];\n                var isXValue = true;\n                for (var seriesCount = 0; seriesCount < this.series.length; seriesCount++) {\n                    var axisName = this.axisCollection[axisCount] !== null ? (this.axisCollection[axisCount].name === 'primaryXAxis' || (this.axisCollection[axisCount].name === 'primaryYAxis' && this.series[seriesCount].type.indexOf('Bar') > -1)) ? null : this.axisCollection[axisCount].name : '';\n                    if ((!isRangeNavigator && ((!isAccumulation &&\n                        this.series[seriesCount].xAxisName !== axisName) ||\n                        !this.series[seriesCount].visible) ||\n                        this.series[seriesCount].category === 'TrendLine' || this.series[seriesCount].type === 'Histogram')) {\n                        continue;\n                    }\n                    var isExist = false;\n                    var dataSource = this.series[seriesCount].dataSource;\n                    for (var dataCount = 0; dataCount < dataSource.length; dataCount++) {\n                        var xValue = (valueType.indexOf('DateTime') > -1) ? this.series[seriesCount].category === 'Pareto' ? new Date(this.series[seriesCount].points[dataCount][requiredValues[seriesCount][0]]).getTime() :\n                            new Date(dataSource[dataCount][requiredValues[seriesCount][0]]).getTime() :\n                            this.series[seriesCount].category === 'Pareto' ? this.series[seriesCount].points[dataCount][requiredValues[seriesCount][0]] : dataSource[dataCount][requiredValues[seriesCount][0]];\n                        if (xValues[axisCount][xValueLength] === xValue) {\n                            var usedValueCount = isXValue ? 0 : 1;\n                            var usedValueLength = this.series[seriesCount].type === 'BoxAndWhisker' ? requiredValues[seriesCount].length - 1 : requiredValues[seriesCount].length;\n                            for (; usedValueCount < usedValueLength; usedValueCount++) {\n                                var cellValue = this.series[seriesCount].enableComplexProperty ?\n                                    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_3__.getValue)(requiredValues[seriesCount][usedValueCount], dataSource[dataCount]) :\n                                    dataSource[dataCount][requiredValues[seriesCount][usedValueCount]];\n                                var value = (usedValueCount !== 0 && (this.series[seriesCount].type === 'BoxAndWhisker' || this.series[seriesCount].category === 'Pareto')) ? this.series[seriesCount].points[dataCount][requiredValues[seriesCount][usedValueCount]] : cellValue;\n                                if (value === null && type === 'CSV') {\n                                    value = '';\n                                }\n                                cells.push({\n                                    index: (usedValueCount === 0 ? startIndex === 0 ? 1 : startIndex : index), value: value,\n                                    colSpan: 1, rowSpan: 1, style: usedValueCount === 0 ? headerStyle : {}\n                                });\n                                index++;\n                            }\n                            if (this.series[seriesCount].type === 'BoxAndWhisker') {\n                                cells.push({ index: index, value: this.series[seriesCount].points[dataCount]['outliers'][0], colSpan: 1, rowSpan: 1, style: {} });\n                                index++;\n                            }\n                            isXValue = false;\n                            isExist = true;\n                            break;\n                        }\n                    }\n                    if (!isExist) {\n                        index += (requiredValues[seriesCount].length - 1);\n                    }\n                }\n                this.rows.push({ index: this.actualRowCount, cells: cells });\n                this.actualRowCount++;\n            }\n            startIndex = index;\n        }\n    };\n    /**\n     * Gets the data URL of the chart or accumulation chart.\n     *\n     * @param {Chart | AccumulationChart} chart - The chart or accumulation chart.\n     * @returns {{ element: HTMLCanvasElement, dataUrl?: string, blobUrl?: string}} - The data URL information.\n     */\n    Export.prototype.getDataUrl = function (chart) {\n        var exportUtil = new _common_utils_export__WEBPACK_IMPORTED_MODULE_0__.ExportUtils(chart);\n        return exportUtil.getDataUrl(chart);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    Export.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'Export';\n    };\n    /**\n     * To destroy the chart.\n     *\n     * @returns {void}\n     * @private\n     */\n    Export.prototype.destroy = function () {\n        // Destroy method performed here\n    };\n    return Export;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/print-export/export.js?");

/***/ })

}]);