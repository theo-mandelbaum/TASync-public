"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_rendering_renderer_js-5d780219"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/renderer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/renderer.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiagramRenderer: () => (/* binding */ DiagramRenderer)\n/* harmony export */ });\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _core_elements_image_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/elements/image-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/image-element.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _core_containers_container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/containers/container */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/container.js\");\n/* harmony import */ var _primitives_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../primitives/matrix */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _utility_dom_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utility/dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _svg_renderer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./svg-renderer */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/svg-renderer.js\");\n/* harmony import */ var _canvas_renderer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./canvas-renderer */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/canvas-renderer.js\");\n/* harmony import */ var _utility_path_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utility/path-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/path-util.js\");\n/* harmony import */ var _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../core/elements/native-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/native-element.js\");\n/* harmony import */ var _core_elements_html_element__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../core/elements/html-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/html-element.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _utility_constraints_util__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utility/constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n/* harmony import */ var _diagram__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../diagram */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js\");\n/* harmony import */ var _objects_dictionary_common__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../objects/dictionary/common */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/dictionary/common.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Renderer module is used to render basic diagram elements\n */\n/** @private */\nvar DiagramRenderer = /** @class */ (function () {\n    function DiagramRenderer(name, svgRender, isSvgMode) {\n        /**   @private  */\n        this.renderer = null;\n        /** @private */\n        this.isSvgMode = true;\n        /** @private */\n        this.touchMove = undefined;\n        this.transform = { x: 0, y: 0 };\n        this.diagramId = name;\n        this.element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.getDiagramElement)(this.diagramId);\n        this.svgRenderer = svgRender;\n        this.isSvgMode = isSvgMode;\n        this.renderer = isSvgMode ? new _svg_renderer__WEBPACK_IMPORTED_MODULE_10__.SvgRenderer() : new _canvas_renderer__WEBPACK_IMPORTED_MODULE_11__.CanvasRenderer();\n    }\n    /**\n     * Method used to set the cur \\\n     *\n     *  @param {HTMLElement} canvas - Provide the canvas .\n     *  @param {string} cursor - Provide the element .\n     * @returns {void }   Method used to set the layer  .\\\n     * @private\n     */\n    DiagramRenderer.prototype.setCursor = function (canvas, cursor) {\n        canvas.style.cursor = cursor;\n    };\n    /**\n     * Method used to set the layer \\\n     *\n     * @returns {void }   Method used to set the layer  .\\\n     *\n     * @private\n     */\n    DiagramRenderer.prototype.setLayers = function () {\n        this.iconSvgLayer = this.element.getElementsByClassName('e-ports-expand-layer')[0];\n        this.adornerSvgLayer = this.element.getElementsByClassName('e-adorner-layer')[0];\n        this.nativeSvgLayer = this.element.getElementsByClassName('e-native-layer')[0];\n        this.diagramSvgLayer = this.element.getElementsByClassName('e-diagram-layer')[0];\n    };\n    DiagramRenderer.prototype.getAdornerLayer = function () {\n        var adornerLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.getAdornerLayer)(this.diagramId);\n        return adornerLayer;\n    };\n    DiagramRenderer.prototype.getParentSvg = function (element, targetElement, canvas) {\n        if (this.diagramId && element && element.id) {\n            if (element.id.split('_icon_content').length > 1 || element.id.split('_nodeport').length > 1 ||\n                (element.elementActions & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ElementAction.ElementIsPort)) {\n                return this.iconSvgLayer;\n            }\n            if (targetElement && targetElement === 'selector') {\n                return this.adornerSvgLayer;\n            }\n            else if (element instanceof _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__.DiagramNativeElement) {\n                return this.nativeSvgLayer;\n            }\n            else {\n                return this.diagramSvgLayer;\n            }\n        }\n        return canvas;\n    };\n    DiagramRenderer.prototype.getParentElement = function (element, defaultParent, svgElement, indexValue) {\n        var layerGElement = defaultParent;\n        if (svgElement && this.diagramId && element && element.id) {\n            if (element.id.split('_icon_content').length > 1) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramExpander');\n                defaultParent = null;\n            }\n            else if (element.id.split('_nodeport').length > 1) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');\n            }\n            else if (element instanceof _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__.DiagramNativeElement) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_nativeLayer');\n                defaultParent = null;\n            }\n            else if (element.elementActions & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ElementAction.ElementIsPort) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');\n                defaultParent = null;\n            }\n            else {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramLayer');\n            }\n            var groupElement = this.getGroupElement(element, defaultParent || layerGElement, indexValue);\n            layerGElement = groupElement.g;\n            if (groupElement.svg) {\n                svgElement = groupElement.svg;\n            }\n        }\n        return { g: layerGElement, svg: svgElement };\n    };\n    DiagramRenderer.prototype.getGroupElement = function (element, canvas, indexValue) {\n        var gElement;\n        var parentSvg = this.getParentSvg(element);\n        var svgElement;\n        if (canvas && parentSvg) {\n            if (parentSvg) {\n                gElement = parentSvg.getElementById(element.id + '_groupElement');\n                if (!gElement && parentSvg !== this.nativeSvgLayer) { //code added\n                    var nativeSvg = this.nativeSvgLayer;\n                    gElement = nativeSvg.getElementById(element.id + '_groupElement');\n                    svgElement = nativeSvg;\n                }\n            }\n            if (!gElement) {\n                gElement = this.svgRenderer.createGElement('g', { id: element.id + '_groupElement' });\n                if (indexValue !== undefined && canvas.childNodes.length > indexValue) {\n                    canvas.insertBefore(gElement, canvas.childNodes[parseInt(indexValue.toString(), 10)]);\n                }\n                else {\n                    canvas.appendChild(gElement);\n                }\n            }\n        }\n        return { g: gElement, svg: svgElement };\n    };\n    /**\n     * Method used to render the diagram element \\\n     *\n     * @returns {void }   Method used to render the diagram element  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas value.\n     * @param {HTMLElement } htmlLayer - Provide the HTMLElement value.\n     * @param {Transforms } transform - Provide the Transforms value.\n     * @param {SVGSVGElement} parentSvg - Provide the SVGSVGElement value.\n     * @param {boolean } createParent - Provide the boolean value.\n     * @param {boolean } fromPalette - Provide the boolean value.\n     * @param {number } indexValue - Provide the indexValue value.\n     * @param {boolean } isPreviewNode - Provide the isPreviewNode value.\n     * @param {object } centerPoint - Provide the centerPoint value.\n     * @param {object} portCenterPoint - Provide the portCenterPoint value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderElement = function (element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint) {\n        var isElement = true;\n        if (element instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_3__.Container) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            isElement = false;\n            element.id = element.id ? element.id : (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_6__.randomId)();\n            this.renderContainer(element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint);\n        }\n        else if (element instanceof _core_elements_image_element__WEBPACK_IMPORTED_MODULE_1__.ImageElement) {\n            this.renderImageElement(element, canvas, transform, parentSvg, fromPalette);\n        }\n        else if (element instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_0__.PathElement) {\n            this.renderPathElement(element, canvas, transform, parentSvg, fromPalette, isPreviewNode, portCenterPoint);\n        }\n        else if (element instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_2__.TextElement) {\n            this.renderTextElement(element, canvas, transform, parentSvg, fromPalette, centerPoint);\n        }\n        else if (element instanceof _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__.DiagramNativeElement) {\n            this.renderNativeElement(element, canvas, transform, parentSvg, fromPalette);\n        }\n        else if (element instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_14__.DiagramHtmlElement) {\n            this.renderHTMLElement(element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue);\n        }\n        else {\n            this.renderRect(element, canvas, transform, parentSvg, isPreviewNode);\n        }\n    };\n    /**\n     * Method used to draw the selection rectangle for the node \\\n     *\n     * @returns {void }  Method used to draw the selection rectangle for the node  .\\\n     *\n     * @param {number} x - Provide the DiagramElement value.\n     * @param {number } y - Provide the SVGElement value.\n     * @param {number } w - Provide the Transforms value.\n     * @param {number } h - Provide the Transforms value.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the Transforms value.\n     * @param {number } t - Provide the Transforms value.\n     * @private\n     */\n    DiagramRenderer.prototype.drawSelectionRectangle = function (x, y, w, h, canvas, t) {\n        x = (x + t.tx) * t.scale;\n        y = (y + t.ty) * t.scale;\n        var options = {\n            width: w * t.scale, height: h * t.scale,\n            x: x + 0.5, y: y + 0.5, fill: 'transparent', stroke: 'gray', angle: 0,\n            pivotX: 0.5, pivotY: 0.5, strokeWidth: 1,\n            dashArray: '6 3', opacity: 1,\n            visible: true, id: canvas.id + '_selected_region'\n        };\n        var adornerLayer = this.getAdornerLayer();\n        this.svgRenderer.updateSelectionRegion(adornerLayer, options);\n    };\n    /**\n     * Method used to render the highlighter \\\n     *\n     * @returns {void }  Method used to render the highlighter  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {SVGElement } canvas - Provide the SVGElement value.\n     * @param {Transforms } transform - Provide the Transforms value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderHighlighter = function (element, canvas, transform) {\n        var width = element.actualSize.width || 2;\n        var height = element.actualSize.height || 2;\n        var x = element.offsetX - width * element.pivot.x;\n        var y = element.offsetY - height * element.pivot.y;\n        x = (x + transform.tx) * transform.scale;\n        y = (y + transform.ty) * transform.scale;\n        var options = {\n            width: width * transform.scale, height: height * transform.scale,\n            x: x, y: y, fill: 'transparent', stroke: '#8CC63F', angle: element.rotateAngle,\n            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: 4,\n            dashArray: '', opacity: 1, cornerRadius: 0,\n            visible: true, id: canvas.id + '_highlighter', class: 'e-diagram-highlighter'\n        };\n        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, canvas);\n    };\n    /**\n     * Method used to render the node selection rectangle \\\n     *\n     * @returns {void }  Method used to render the node selection rectangle  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {SVGElement } canvas - Provide the SVGElement value.\n     * @param {Transforms } transform - Provide the Transforms value.\n     * @param {number } isFirst - Provide the boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderSelectionRectangle = function (element, canvas, transform, isFirst) {\n        var width = element.actualSize.width || 2;\n        var height = element.actualSize.height || 2;\n        var x = element.offsetX - width * element.pivot.x;\n        var y = element.offsetY - height * element.pivot.y;\n        x = (x + transform.tx) * transform.scale;\n        y = (y + transform.ty) * transform.scale;\n        var options = {\n            width: width * transform.scale, height: height * transform.scale,\n            x: x, y: y, fill: 'transparent', stroke: '#00cc00', angle: element.rotateAngle,\n            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: isFirst ? 2 : 1,\n            dashArray: '', opacity: 1, cornerRadius: 0,\n            visible: true, id: element.id + '_highlighter', class: isFirst ? 'e-diagram-first-selection-indicator e-diagram-selection-indicator' : 'e-diagram-selection-indicator'\n        };\n        var parentSvg = this.getParentSvg(element, 'selector');\n        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n    };\n    /**\n     * Method used to render the selection line for connector  \\\n     *\n     * @returns {void } Method used to render the selection line for connector .\\\n     *\n     * @param {PathElement} element - Provide the path element of the diagram .\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value.\n     * @param { boolean } isFirst - Provide the boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderSelectionLine = function (element, canvas, transform, isFirst) {\n        var options = this.getBaseAttributes(element, transform);\n        options.data = element.absolutePath;\n        options.id = options.id + '_highlighter';\n        var ariaLabel = element.description ? element.description : element.id;\n        if (!this.isSvgMode) {\n            options.x = element.flipOffset.x ? element.flipOffset.x : options.x;\n            options.y = element.flipOffset.y ? element.flipOffset.y : options.y;\n        }\n        if (transform) {\n            options.x = options.x * transform.scale;\n            options.y = options.y * transform.scale;\n        }\n        options.stroke = '#00cc00';\n        options.strokeWidth = isFirst ? 2 : 1;\n        options.class = isFirst ? 'e-diagram-first-selection-indicator e-diagram-selection-indicator' : 'e-diagram-selection-indicator';\n        var parentSvg = this.getParentSvg(element, 'selector');\n        this.svgRenderer.drawPath(canvas, options, this.diagramId, undefined, parentSvg, ariaLabel, transform.scale);\n    };\n    /**\n     * Method used to render the stack highlighter \\\n     *\n     * @returns {void }  Method used to render the stack highlighter  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {SVGElement } canvas - Provide the SVGElement value.\n     * @param {Transforms } transform - Provide the Transforms value.\n     * @param {boolean} isVertical - Provide the Boolean value.\n     * @param {PointModel } position - Provide the PointModel value.\n     * @param {boolean } isUml - Provide the boolean value.\n     * @param {boolean } isSwimlane - Provide the boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderStackHighlighter = function (element, canvas, transform, isVertical, position, isUml, isSwimlane) {\n        var width = element.actualSize.width || 2;\n        var x = element.offsetX - width * element.pivot.x;\n        var height = element.actualSize.height || 2;\n        var y = element.offsetY - height * element.pivot.y;\n        x = (x + transform.tx) * transform.scale;\n        var data;\n        var bounds = element.bounds;\n        var newPathString = '';\n        y = (y + transform.ty) * transform.scale;\n        if (!isVertical) {\n            var d = height * transform.scale;\n            data = 'M 10 -10 L 0 0 Z M -10 -10 L 0 0 Z M 0 0 L 0 ' + (d) + ' Z M 0  ' + (d) +\n                ' L -10  ' + (d + 10) + ' Z L 10  ' + (d + 10) + ' Z';\n            if (position.x >= element.offsetX) {\n                //879085- swimlane helper guides not rendered properly when zoomed\n                x += width * transform.scale;\n            }\n        }\n        else {\n            if (isUml) {\n                var d = width * transform.scale;\n                data = 'M 0 0 L ' + (d + 2) + ' 0 Z';\n                var scaleX = -bounds.x;\n                var scaleY = -bounds.y;\n                var arrayCollection = [];\n                scaleX = element.actualSize.width / Number(bounds.width ? bounds.width : 1) * transform.scale;\n                scaleY = element.actualSize.height / Number(bounds.height ? bounds.height : 1) * transform.scale;\n                var umlData = 'M7,4 L8,4 8,7 11,7 11,8 8,8 8,11 7,11 7,8 4,8 4,7 7,7 z M7.5,0.99999994' +\n                    'C3.9160004,1 1,3.9160004 0.99999994,7.5 1,11.084 3.9160004,14 7.5,14 11.084,14 14,11.084 14,7.5 14,' +\n                    '3.9160004 11.084,1 7.5,0.99999994 z M7.5,0 C11.636002,0 15,3.3639984 15,7.5 15,11.636002 11.636002,15 7.5,' +\n                    '15 3.3640003,15 0,11.636002 0,7.5 0,3.3639984 3.3640003,0 7.5,0 z';\n                arrayCollection = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_12__.processPathData)(umlData);\n                arrayCollection = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_12__.splitArrayCollection)(arrayCollection);\n                newPathString = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_12__.transformPath)(arrayCollection, scaleX + d + 2, scaleY - 8, false, bounds.x, bounds.y, 0, 0);\n                if (position.y >= element.offsetY) {\n                    y += height;\n                }\n            }\n            else {\n                if (isSwimlane) {\n                    if (position.y >= element.offsetY) {\n                        //879085- swimlane helper guides not rendered properly when zoomed\n                        y += height * transform.scale;\n                    }\n                }\n                var d = width * transform.scale;\n                data = 'M -10 -10 L 0 0 Z M -10 10 L 0 0 Z M 0 0 L ' + (d) + ' 0 Z M ' + (d) + ' 0 L ' +\n                    (d + 10) + ' 10 Z L ' + (d + 10) + ' -10 Z';\n            }\n        }\n        var options = {\n            data: data + newPathString,\n            width: width * transform.scale, height: height * transform.scale,\n            x: x, y: y, fill: 'transparent', stroke: '#8CC63F', angle: element.rotateAngle,\n            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: 1,\n            dashArray: '', opacity: 1,\n            visible: true, id: canvas.id + '_stack_highlighter', class: 'e-diagram-highlighter'\n        };\n        this.svgRenderer.drawPath(canvas, options, this.diagramId);\n    };\n    /**\n     * Method used to draw the line \\\n     *\n     * @returns {void }  Method used to draw the line  .\\\n     *\n     * @param {SVGElement} canvas - Provide the SVGElement value.\n     * @param {LineAttributes } options - Provide the LineAttributes value.\n     * @private\n     */\n    DiagramRenderer.prototype.drawLine = function (canvas, options) {\n        this.svgRenderer.drawLine(canvas, options);\n    };\n    /**\n     * Method used to draw the path \\\n     *\n     * @returns {void }  Method used to draw the path  .\\\n     *\n     * @param {SVGElement} canvas - Provide the canvas value.\n     * @param {PathAttributes } options - Provide the PathAttributes value.\n     * @private\n     */\n    DiagramRenderer.prototype.drawPath = function (canvas, options) {\n        this.svgRenderer.drawPath(canvas, options, this.diagramId);\n    };\n    /**\n     * Method used to render the resize handle \\\n     *\n     * @returns {void }  Method used to render the resize handle  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param {  ThumbsConstraints } constraints - Provide the constraints value  .\n     * @param { number} currentZoom - Provide the currentZoom value.\n     * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value .\n     * @param { Transforms } transform - Provide the transform  value.\n     * @param { boolean } canMask - Provide the canMask boolean value.\n     * @param { number } enableNode - Provide the enableNode value.\n     * @param { boolean } nodeConstraints - Provide the nodeConstraints  value.\n     * @param { boolean } isSwimlane - Provide the isSwimlane boolean value.\n     * @param { number } handleSize - Provide the handleSize value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderResizeHandle = function (element, canvas, constraints, currentZoom, selectorConstraints, transform, canMask, enableNode, nodeConstraints, isSwimlane, handleSize) {\n        var left = element.offsetX - element.actualSize.width * element.pivot.x;\n        var top = element.offsetY - element.actualSize.height * element.pivot.y;\n        var height = element.actualSize.height;\n        var width = element.actualSize.width;\n        if (!isSwimlane &&\n            (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.Rotate && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_16__.canDrawThumbs)(this.rendererActions) && (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_16__.avoidDrawSelector)(this.rendererActions)))) {\n            this.renderPivotLine(element, canvas, transform, selectorConstraints, canMask);\n            this.renderRotateThumb(element, canvas, transform, selectorConstraints, canMask);\n        }\n        else {\n            if (this.touchMove) {\n                var rotateThumb = document.getElementById('rotateThumb');\n                if (rotateThumb) {\n                    rotateThumb.setAttribute('visibility', 'hidden');\n                }\n            }\n        }\n        this.renderBorder(element, canvas, transform, enableNode, nodeConstraints, isSwimlane);\n        var nodeWidth = element.actualSize.width * currentZoom;\n        var nodeHeight = element.actualSize.height * currentZoom;\n        if (!nodeConstraints && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_16__.canDrawThumbs)(this.rendererActions) && (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_16__.avoidDrawSelector)(this.rendererActions))) {\n            //Bug 860033: Bpmn text annotation path size not rendered properly while dragging.\n            //Added below condition to prevent the resize thumbs for bpmn text annotation.\n            if (!element.isTextAnnotation) {\n                if (nodeWidth >= 40 && nodeHeight >= 40) {\n                    //Hide corners when the size is less than 40\n                    if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeNorthWest) {\n                        this.renderCircularHandle('resizeNorthWest', element, left, top, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeNorthWest'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeNorthWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top left side direction' }, undefined, 'e-diagram-resize-handle e-northwest', handleSize);\n                    }\n                    if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeNorthEast) {\n                        this.renderCircularHandle('resizeNorthEast', element, left + width, top, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeNorthEast'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeNorthEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top right side direction' }, undefined, 'e-diagram-resize-handle e-northeast', handleSize);\n                    }\n                    if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeSouthWest) {\n                        this.renderCircularHandle('resizeSouthWest', element, left, top + height, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeSouthWest'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeSouthWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom left side direction' }, undefined, 'e-diagram-resize-handle e-southwest', handleSize);\n                    }\n                    if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeSouthEast) {\n                        this.renderCircularHandle('resizeSouthEast', element, left + width, top + height, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeSouthEast'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeSouthEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom right side direction' }, undefined, 'e-diagram-resize-handle e-southeast', handleSize);\n                    }\n                }\n                if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeNorth) {\n                    this.renderCircularHandle('resizeNorth', element, left + width / 2, top, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeNorth'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeNorth, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top side direction' }, undefined, 'e-diagram-resize-handle e-north', handleSize);\n                }\n                if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeSouth) {\n                    this.renderCircularHandle('resizeSouth', element, left + width / 2, top + height, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeSouth'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeSouth, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom side direction' }, undefined, 'e-diagram-resize-handle e-south', handleSize);\n                }\n                if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeWest) {\n                    this.renderCircularHandle('resizeWest', element, left, top + height / 2, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeWest'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on left side direction' }, undefined, 'e-diagram-resize-handle e-west', handleSize);\n                }\n                if (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.ResizeEast) {\n                    this.renderCircularHandle('resizeEast', element, left + width, top + height / 2, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ResizeEast'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ResizeEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on right side direction' }, undefined, 'e-diagram-resize-handle e-east', handleSize);\n                }\n            }\n        }\n    };\n    /**\n     * Method used to render the end point of the handle \\\n     *\n     * @returns {void }  Method used to render the end point of the handle  .\\\n     *\n     * @param {ConnectorModel} selector - Provide the ConnectorModel.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the element.\n     * @param {  ThumbsConstraints } constraints - Provide the constraints value  .\n     * @param { SelectorConstraints} selectorConstraints - Provide the selectorConstraints value.\n     * @param { Transforms } transform - Provide the transform value .\n     * @param { boolean } connectedSource - Provide the connectedSource boolean value.\n     * @param { boolean } connectedTarget - Provide the connectedTarget boolean value.\n     * @param { boolean } isSegmentEditing - Provide the isSegmentEditing boolean value.\n     * @param { boolean } canShowBezierPoints - Provide the canShowBezierPoints boolean value.\n     * @param {number} handleSize - Provide the handleSize value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderEndPointHandle = function (selector, canvas, constraints, selectorConstraints, transform, connectedSource, connectedTarget, isSegmentEditing, canShowBezierPoints, handleSize) {\n        var sourcePoint = selector.sourcePoint;\n        var targetPoint = selector.targetPoint;\n        var wrapper = selector.wrapper;\n        var i;\n        var segment;\n        this.renderCircularHandle('connectorSourceThumb', wrapper, sourcePoint.x, sourcePoint.y, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorSourceThumb'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ConnectorSource, transform, connectedSource, undefined, { 'aria-label': 'Thumb to move the source point of the connector' }, undefined, 'e-diagram-endpoint-handle e-sourceend', handleSize);\n        this.renderCircularHandle('connectorTargetThumb', wrapper, targetPoint.x, targetPoint.y, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorTargetThumb'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ConnectorTarget, transform, connectedTarget, undefined, { 'aria-label': 'Thumb to move the target point of the connector' }, undefined, 'e-diagram-endpoint-handle e-targetend', handleSize);\n        if (isSegmentEditing) {\n            if ((selector.type === 'Straight') && selector.segments.length > 0) {\n                for (i = 0; i < selector.segments.length - 1; i++) {\n                    segment = selector.segments[parseInt(i.toString(), 10)];\n                    var className = 'e-diagram-straight-segment-handle';\n                    this.renderCircularHandle(('segementThumb_' + (i + 1)), wrapper, segment.point.x, segment.point.y, canvas, true, constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ConnectorSource, transform, connectedSource, null, null, i, className, handleSize);\n                }\n            } //824805-Support to modify bezier connector segment thumb shape and style\n            else if ((selector.type === 'Bezier') && selector.segments.length > 0) {\n                for (i = 0; i < selector.segments.length - 1; i++) {\n                    segment = selector.segments[parseInt(i.toString(), 10)];\n                    var className = 'e-diagram-bezier-segment-handle';\n                    this.renderBezierHandle(('segementThumb_' + (i + 1)), wrapper, segment.point.x, segment.point.y, canvas, true, selector, transform, connectedSource, null, i, className, handleSize);\n                }\n            }\n            else {\n                // (EJ2-57115) - Added below code to check if maxSegmentThumb is zero or not\n                if (!selector.maxSegmentThumb) {\n                    for (i = 0; i < selector.segments.length; i++) {\n                        var seg = selector.segments[parseInt(i.toString(), 10)];\n                        this.renderOrthogonalThumbs('orthoThumb_' + (i + 1), wrapper, seg, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorSourceThumb'), transform, selector);\n                    }\n                }\n                else {\n                    // (EJ2-57115) - Added below code to check if maxSegmentThumb is non zero then we have ignore the rendering of\n                    // first and last segment thumb\n                    var start = selector.segments.length <= selector.maxSegmentThumb ? 0 : 1;\n                    var end = selector.segments.length <= selector.maxSegmentThumb\n                        ? selector.segments.length : selector.segments.length - 1;\n                    // (EJ2-57115) - If maxSegmentThumb is greater than or equal to 3 means then set start as second segment(1) and end as last before segment\n                    if (selector.maxSegmentThumb >= 3 && selector.segments.length === 3) {\n                        start = 1;\n                        end = selector.segments.length - 1;\n                    }\n                    // (EJ2-57115) - If segments length is greater than maxSegmentThumb + 2 means then set start as 2\n                    start = selector.segments.length > selector.maxSegmentThumb + 2 ? 2 : start;\n                    // (EJ2-57115) - If segments length is greater than maxSegmentThumb + 2 means then set end as last before segment\n                    end = selector.segments.length > selector.maxSegmentThumb + 2 ? selector.segments.length - 2 : end;\n                    if (selector.segments.length === 1 && selector.segments[0].points.length <= 2) {\n                        start = 1;\n                        end = selector.segments.length;\n                    }\n                    for (i = start; i < end; i++) {\n                        var seg = selector.segments[parseInt(i.toString(), 10)];\n                        this.renderOrthogonalThumbs('orthoThumb_' + (i + 1), wrapper, seg, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorSourceThumb'), transform, selector);\n                    }\n                }\n            }\n        }\n        if (selector.type === 'Bezier' && canShowBezierPoints) {\n            var segmentCount = selector.segments.length - 1;\n            var controlPointsVisibility = selector.bezierSettings != null\n                ? selector.bezierSettings.controlPointsVisibility : null;\n            for (i = 0; i <= segmentCount; i++) {\n                var segment_1 = selector.segments[parseInt(i.toString(), 10)];\n                var bezierPoint = !_primitives_point__WEBPACK_IMPORTED_MODULE_15__.Point.isEmptyPoint(segment_1.point1) ? segment_1.point1\n                    : segment_1.bezierPoint1;\n                if (controlPointsVisibility != null && (i === 0 && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowControlPoints)(controlPointsVisibility, 'Source'))\n                    || (i !== 0 && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowControlPoints)(controlPointsVisibility, 'Intermediate'))) {\n                    this.renderCircularHandle('bezierPoint_' + (i + 1) + '_1', wrapper, bezierPoint.x, bezierPoint.y, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorSourceThumb'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ConnectorSource, transform, undefined, undefined, { 'aria-label': 'Thumb to move the source point of the connector' }, undefined, 'e-diagram-bezier-control-handle e-source', handleSize);\n                    if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorSourceThumb')) {\n                        this.renderBezierLine('bezierLine_' + (i + 1) + '_1', wrapper, canvas, segment_1.points[0], !_primitives_point__WEBPACK_IMPORTED_MODULE_15__.Point.isEmptyPoint(segment_1.point1) ? segment_1.point1 : segment_1.bezierPoint1, transform);\n                    }\n                }\n                bezierPoint = !_primitives_point__WEBPACK_IMPORTED_MODULE_15__.Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2;\n                if (controlPointsVisibility != null && (i === segmentCount && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowControlPoints)(controlPointsVisibility, 'Target'))\n                    || (i !== segmentCount && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowControlPoints)(controlPointsVisibility, 'Intermediate'))) {\n                    this.renderCircularHandle('bezierPoint_' + (i + 1) + '_2', wrapper, bezierPoint.x, bezierPoint.y, canvas, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorTargetThumb'), constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ThumbsConstraints.ConnectorTarget, transform, undefined, undefined, { 'aria-label': 'Thumb to move the target point of the connector' }, undefined, 'e-diagram-bezier-control-handle e-target', handleSize);\n                    if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.canShowCorner)(selectorConstraints, 'ConnectorTargetThumb')) {\n                        this.renderBezierLine('bezierLine_' + (i + 1) + '_2', wrapper, canvas, segment_1.points[1], !_primitives_point__WEBPACK_IMPORTED_MODULE_15__.Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2, transform);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Method used to render the orthogonal thumb \\\n     *\n     * @returns {void }  Method used to render the orthogonal thumb  .\\\n     *\n     * @param {string} id - Provide the id for the element.\n     * @param {DiagramElement } selector - Provide the selector element.\n     * @param {  OrthogonalSegment } segment - Provide the segment value  .\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { boolean } visibility - Provide the visibility value .\n     * @param { Transforms } t - Provide the Transforms value.\n     * @param { ConnectorModel } connector - Provide the connector value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderOrthogonalThumbs = function (id, selector, segment, canvas, visibility, t, connector) {\n        var orientation;\n        var visible;\n        var length;\n        var j = 0;\n        var direction;\n        // (EJ2-57115) - Added below code to check if maxSegmentThumb is zero or not\n        if (!connector.maxSegmentThumb) {\n            for (j = 0; j < segment.points.length - 1; j++) {\n                length = _primitives_point__WEBPACK_IMPORTED_MODULE_15__.Point.distancePoints(segment.points[parseInt(j.toString(), 10)], segment.points[j + 1]);\n                orientation = (segment.points[parseInt(j.toString(), 10)].y.toFixed(2) === segment.points[j + 1].y.toFixed(2)) ? 'horizontal' : 'vertical';\n                //850501-Added below code to check the direction of the segments\n                direction = _primitives_point__WEBPACK_IMPORTED_MODULE_15__.Point.direction(segment.points[parseInt(j.toString(), 10)], segment.points[j + 1]);\n                visible = (length >= 50 && segment.allowDrag) ? true : false;\n                this.renderOrthogonalThumb((id + '_' + (j + 1)), selector, (((segment.points[parseInt(j.toString(), 10)].x + segment.points[j + 1].x) / 2)), (((segment.points[parseInt(j.toString(), 10)].y + segment.points[j + 1].y) / 2)), canvas, visible, orientation, t, connector, direction);\n            }\n        }\n        else {\n            // (EJ2-57115) - Added below code to check if maxSegmentThumb greater then 3 means then we have ignore the rendering of\n            // first and last segment thumb\n            // Set the start value as 1 if segment points is greater than 3\n            var start = segment.points.length < 3 ? 0 : 1;\n            // set the end value as segment.points.length - 2 if segment points is greater then 3\n            var end = segment.points.length < 3 ? segment.points.length - 1 : segment.points.length - 2;\n            start = connector.segments.length === 1 ? start : 0;\n            end = connector.segments.length === 1 ? end : segment.points.length - 1;\n            for (j = start; j < end; j++) {\n                length = _primitives_point__WEBPACK_IMPORTED_MODULE_15__.Point.distancePoints(segment.points[parseInt(j.toString(), 10)], segment.points[j + 1]);\n                orientation = (segment.points[parseInt(j.toString(), 10)].y.toFixed(2) === segment.points[j + 1].y.toFixed(2)) ? 'horizontal' : 'vertical';\n                visible = (length >= 50 && segment.allowDrag) ? true : false;\n                this.renderOrthogonalThumb((id + '_' + (j + 1)), selector, (((segment.points[parseInt(j.toString(), 10)].x + segment.points[j + 1].x) / 2)), (((segment.points[parseInt(j.toString(), 10)].y + segment.points[j + 1].y) / 2)), canvas, visible, orientation, t, connector, direction);\n            }\n        }\n    };\n    /**\n     * Method used to render the orthogonal thumb \\\n     *\n     * @returns {void }  Method used to render the orthogonal thumb  .\\\n     *\n     * @param {string} id - Provide the id for the element.\n     * @param {DiagramElement } selector - Provide the selector element.\n     * @param {  Transforms } x - Provide the x value  .\n     * @param { Transforms } y - Provide the y value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param { boolean } visible - Provide the visible boolean value.\n     * @param { string } orientation - Provide the orientation value.\n     * @param { Transforms } t - Provide the Transforms value.\n     * @param { ConnectorModel } connector - Provide the connector value.\n     * @param { string } direction - Provide the direction of the segment.\n     * @private\n     */\n    DiagramRenderer.prototype.renderOrthogonalThumb = function (id, selector, x, y, canvas, visible, orientation, t, connector, direction) {\n        var path;\n        var segmentThumbAngle = 0;\n        var diagramElement = document.getElementById(this.diagramId);\n        var instance = 'ej2_instances';\n        var diagram;\n        if (diagramElement) {\n            diagram = diagramElement[\"\" + instance][0];\n        }\n        //824805-Support to modify connector segment thumb shape and style based on constraints\n        var inheritsegmentThumbShape = (connector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ConnectorConstraints.InheritSegmentThumbShape);\n        var segmentThumbShape = inheritsegmentThumbShape ? diagram.segmentThumbShape : connector.segmentThumbShape;\n        //850501-Added below code to modify connector segment thumb size based on constraints\n        var inheritSegmentThumbSize = (connector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ConnectorConstraints.InheritSegmentThumbSize);\n        var segmentThumbSize = inheritSegmentThumbSize ? diagram.segmentThumbSize : connector.segmentThumbSize;\n        if (orientation === 'horizontal') {\n            path = (0,_objects_dictionary_common__WEBPACK_IMPORTED_MODULE_18__.getSegmentThumbShapeHorizontal)(segmentThumbShape);\n        }\n        else {\n            path = (0,_objects_dictionary_common__WEBPACK_IMPORTED_MODULE_18__.getSegmentThumbShapeVertical)(segmentThumbShape);\n        }\n        //850501-Added the below code to change the angles of the segmentThumbShape(arrows) based on the direction\n        if (segmentThumbShape === 'Arrow' || segmentThumbShape === 'DoubleArrow' || segmentThumbShape === 'OpenArrow') {\n            switch (direction) {\n                case 'Bottom':\n                case 'Right':\n                    segmentThumbAngle = 180;\n                    break;\n                default:\n                    segmentThumbAngle = 0;\n            }\n        }\n        else if (segmentThumbShape === 'Fletch' || segmentThumbShape === 'OpenFetch' || segmentThumbShape === 'IndentedArrow' || segmentThumbShape === 'OutdentedArrow') {\n            switch (direction) {\n                case 'Bottom':\n                    segmentThumbAngle = -90;\n                    break;\n                case 'Top':\n                    segmentThumbAngle = 90;\n                    break;\n                case 'Right':\n                    segmentThumbAngle = 180;\n                    break;\n                default:\n                    segmentThumbAngle = 0;\n            }\n        }\n        var options = {\n            x: ((x + t.tx) * t.scale) - segmentThumbSize / 2, y: ((y + t.ty) * t.scale) - segmentThumbSize / 2, angle: segmentThumbAngle,\n            fill: '#e2e2e2', stroke: 'black', strokeWidth: 1, dashArray: '', data: path,\n            width: segmentThumbSize, height: segmentThumbSize, pivotX: 0.5, pivotY: 0.5, opacity: 1, visible: visible, id: id,\n            class: 'e-diagram-ortho-segment-handle'\n        };\n        //850501-Added the below code to adjust size for the segment thumb shape based on the size given\n        var absoluteBounds = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.measurePath)(options.data);\n        var desiredSize = new _primitives_size__WEBPACK_IMPORTED_MODULE_5__.Size(options.width, options.height);\n        var pathElement = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_0__.PathElement();\n        options.data = pathElement.updatePath(options.data, absoluteBounds, desiredSize);\n        //Bug 914365: Node is not resizable using touch interaction\n        //Added below code to update the element if it is already rendered during touch move interaction\n        if (this.touchMove) {\n            var thumb = document.getElementById(id);\n            if (thumb) {\n                this.updateSegmentPosition(thumb, options);\n            }\n            else {\n                this.svgRenderer.drawPath(canvas, options, this.diagramId);\n            }\n        }\n        else {\n            this.svgRenderer.drawPath(canvas, options, this.diagramId);\n        }\n    };\n    /**\n     * Method used to render the pivot line line\\\n     *\n     * @returns {void } Method used to render the pivot line line .\\\n     *\n     * @param {DiagramElement} element - Provide the diagram element value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param {  Transforms } transform - Provide the transform value  .\n     * @param { SelectorConstraints } selectorConstraints - Provide the selector constraints value.\n     * @param { boolean } canMask - Provide the canMask boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderPivotLine = function (element, canvas, transform, selectorConstraints, canMask) {\n        var wrapper = element;\n        var dashArray = '2,3';\n        var visible = (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.Rotate) ? true : false;\n        if (canMask) {\n            visible = false;\n        }\n        var options = this.getBaseAttributes(wrapper, transform);\n        options.fill = 'None';\n        options.stroke = 'black';\n        options.strokeWidth = 1;\n        options.dashArray = dashArray;\n        options.visible = visible;\n        var scale = transform.scale;\n        options.x *= scale;\n        options.y *= scale;\n        options.width *= scale;\n        options.height *= scale;\n        options.id = 'pivotLine';\n        options.class = 'e-diagram-pivot-line';\n        var startPoint = { x: wrapper.actualSize.width * wrapper.pivot.x * scale, y: -20 };\n        var endPoint = { x: wrapper.actualSize.width * wrapper.pivot.x * scale, y: 0 };\n        options.startPoint = startPoint;\n        options.endPoint = endPoint;\n        this.svgRenderer.drawLine(canvas, options);\n    };\n    /**\n     * Method used to render the bezier line for the connector  \\\n     *\n     * @returns {void } Method used to render the bezier line for the connector .\\\n     *\n     * @param {string} id - Provide the id value for the bezier line.\n     * @param { DiagramElement } wrapper - Provide the wrapper for the element.\n     * @param {  HTMLCanvasElement | SVGElement } canvas - Provide the canvas element  .\n     * @param { PointModel } start - Provide the pointmodel value.\n     * @param { PointModel } end - Provide the pointmodel value.\n     * @param { Transforms } transform - Provide the itransform value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderBezierLine = function (id, wrapper, canvas, start, end, transform) {\n        var dashArray = '3,3';\n        var options = this.getBaseAttributes(wrapper, transform);\n        options.id = id;\n        options.stroke = 'black';\n        options.strokeWidth = 1;\n        options.dashArray = dashArray;\n        options.fill = 'None';\n        options.class = 'e-diagram-bezier-control-line';\n        options.x = 0;\n        options.y = 0;\n        var scale = transform.scale;\n        var x1 = (start.x + transform.tx) * scale;\n        var y1 = (start.y + transform.ty) * scale;\n        var x2 = (end.x + transform.tx) * scale;\n        var y2 = (end.y + transform.ty) * scale;\n        var startPoint = { x: x1, y: y1 };\n        var endPoint = { x: x2, y: y2 };\n        options.startPoint = startPoint;\n        options.endPoint = endPoint;\n        this.svgRenderer.drawLine(canvas, options);\n    };\n    /**\n     * Method used to render the circular handle for the node element  \\\n     *\n     * @returns {void } Method used to render the circular handle for the node element .\\\n     *\n     * @param {string} id - Provide the id value.\n     * @param { DiagramElement } selector - Provide the selector element value.\n     * @param { number } cx - Provide cx value  .\n     * @param { number } cy - Provide cx value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param { boolean } visible - Provide the visible property for the handle .\n     * @param { number } enableSelector - Provide the value for the enableSelector .\n     * @param { Transforms } t - Provide the transform value .\n     * @param { boolean } connected - Provide the connected boolean value .\n     * @param { boolean } canMask - Provide the canMask boolean value .\n     * @param { Object } ariaLabel - Provide the label properties .\n     * @param { number } count - Provide the count value  .\n     * @param { string } className - Provide the class name for this element .\n     * @param { number } handleSize - Provide the handle size value .\n     *\n     * @private\n     */\n    // Feature (EJ2-44346) Provide support to increase the size of the resize thumb\n    DiagramRenderer.prototype.renderCircularHandle = function (id, selector, cx, cy, canvas, visible, enableSelector, t, connected, canMask, ariaLabel, count, className, handleSize) {\n        var wrapper = selector;\n        var newPoint = { x: cx, y: cy };\n        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.identityMatrix)();\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.rotateMatrix)(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);\n            newPoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.transformPointByMatrix)(matrix, newPoint);\n        }\n        var options = this.getBaseAttributes(wrapper);\n        options.stroke = 'black';\n        options.strokeWidth = 1;\n        if (count !== undefined) {\n            options.id = 'segmentEnd_' + count;\n            options.fill = '#e2e2e2';\n        }\n        else {\n            options.fill = connected ? '#8CC63F' : 'white';\n        }\n        options.cornerRadius = handleSize / 2;\n        options.angle = selector.rotateAngle;\n        options.id = id;\n        options.visible = visible;\n        options.class = className;\n        options.width = handleSize;\n        options.height = handleSize;\n        // EJ2-65895 - Added below code to calculate the rect x and y if node pivot is not equal to 0.5\n        options.x = (newPoint.x + t.tx) * t.scale;\n        options.y = (newPoint.y + t.ty) * t.scale;\n        options.x = options.x - options.width / 2;\n        options.y = options.y - options.height / 2;\n        if (connected) {\n            options.class += ' e-connected';\n        }\n        if (canMask) {\n            options.visible = false;\n        }\n        //Bug 914365: Node is not resizable using touch interaction\n        //Added below code to update the element if it is already rendered during touch move interaction\n        if (this.touchMove) {\n            var handle = document.getElementById(id);\n            if (handle) {\n                this.updateResizeHandle(handle, options);\n            }\n            else {\n                var parentSvg = this.getParentSvg(selector, 'selector');\n                this.svgRenderer.drawRectangle(canvas, options, this.diagramId, true, true, parentSvg, ariaLabel, true, enableSelector);\n            }\n        }\n        else {\n            var parentSvg = this.getParentSvg(selector, 'selector');\n            this.svgRenderer.drawRectangle(canvas, options, this.diagramId, true, true, parentSvg, ariaLabel, true, enableSelector);\n        }\n    };\n    DiagramRenderer.prototype.updateResizeHandle = function (handle, options) {\n        var attr = {\n            'id': options.id, 'x': options.x.toString(), 'y': options.y.toString(), 'width': options.width.toString(),\n            'height': options.height.toString(), 'visibility': options.visible ? 'visible' : 'hidden',\n            'transform': 'rotate(' + options.angle + ','\n                + (options.x + options.width / 2) + ',' + (options.y + options.height / 2) + ')',\n            'rx': options.cornerRadius || 0, 'ry': options.cornerRadius || 0, 'opacity': options.opacity\n        };\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(handle, attr);\n    };\n    //824805-Support to modify bezier connector segmentThumbShape\n    /**\n     * Method used to render the segment thumb shape for Bezier connector  \\\n     *\n     * @returns {void } Method used to render the segment thumb shape for Bezier connector .\\\n     *\n     * @param {string} id - Provide the id value.\n     * @param { DiagramElement } selector - Provide the selector element value.\n     * @param { number } cx - Provide cx value  .\n     * @param { number } cy - Provide cx value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param { boolean } visible - Provide the visible property for the handle .\n     * @param { ConnectorModel } connector - Provide the value for the connector .\n     * @param { Transforms } t - Provide the transform value .\n     * @param { boolean } connected - Provide the connected boolean value .\n     * @param { boolean } canMask - Provide the canMask boolean value .\n     * @param { number } count - Provide the count value  .\n     * @param { string } className - Provide the class name for this element .\n     * @param { number } handleSize - Provide the handle size value .\n     *\n     * @private\n     */\n    DiagramRenderer.prototype.renderBezierHandle = function (id, selector, cx, cy, canvas, visible, connector, t, connected, canMask, count, className, handleSize) {\n        var diagramElement = document.getElementById(this.diagramId);\n        var instance = 'ej2_instances';\n        var diagram;\n        if (diagramElement) {\n            diagram = diagramElement[\"\" + instance][0];\n        }\n        var wrapper = selector;\n        var newPoint = { x: cx, y: cy };\n        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.identityMatrix)();\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.rotateMatrix)(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);\n            newPoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.transformPointByMatrix)(matrix, newPoint);\n        }\n        var inheritsegmentThumbShape = (connector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ConnectorConstraints.InheritSegmentThumbShape);\n        var segmentThumbShape = inheritsegmentThumbShape ? diagram.segmentThumbShape : connector.segmentThumbShape;\n        //850501-Added below code to modify connector segment thumb size based on constraints\n        var inheritSegmentThumbSize = (connector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ConnectorConstraints.InheritSegmentThumbSize);\n        var segmentThumbSize = inheritSegmentThumbSize ? diagram.segmentThumbSize : connector.segmentThumbSize;\n        var path = (0,_objects_dictionary_common__WEBPACK_IMPORTED_MODULE_18__.getSegmentThumbShapeVertical)(segmentThumbShape);\n        var options = this.getBaseAttributes(wrapper);\n        options.stroke = 'black';\n        options.strokeWidth = 1;\n        if (count !== undefined) {\n            options.id = 'segmentEnd_' + count;\n            options.fill = '#e2e2e2';\n        }\n        else {\n            options.fill = connected ? '#8CC63F' : 'white';\n        }\n        options.angle = selector.rotateAngle;\n        options.id = id;\n        options.visible = visible;\n        options.class = className;\n        options.width = segmentThumbSize;\n        options.height = segmentThumbSize;\n        // EJ2-65895 - Added below code to calculate the rect x and y if node pivot is not equal to 0.5\n        options.data = path;\n        options.x = ((newPoint.x + t.tx) * t.scale);\n        options.y = ((newPoint.y + t.ty) * t.scale);\n        options.x = options.x - options.width / 2;\n        options.y = options.y - options.height / 2;\n        if (connected) {\n            options.class += ' e-connected';\n        }\n        if (canMask) {\n            options.visible = false;\n        }\n        //850501-Added the below code to adjust size for the segment thumb shape based on the size given\n        var absoluteBounds = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.measurePath)(options.data);\n        var desiredSize = new _primitives_size__WEBPACK_IMPORTED_MODULE_5__.Size(options.width, options.height);\n        var pathElement = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_0__.PathElement();\n        options.data = pathElement.updatePath(options.data, absoluteBounds, desiredSize);\n        //Bug 914365: Node is not resizable using touch interaction\n        //Added below code to update the element if it is already rendered during touch move interaction\n        if (this.touchMove) {\n            var handle = document.getElementById(id);\n            if (handle) {\n                this.updateSegmentPosition(handle, options);\n            }\n            else {\n                var parentSvg = this.getParentSvg(selector, 'selector');\n                this.svgRenderer.drawPath(canvas, options, this.diagramId, true, parentSvg);\n            }\n        }\n        else {\n            var parentSvg = this.getParentSvg(selector, 'selector');\n            this.svgRenderer.drawPath(canvas, options, this.diagramId, true, parentSvg);\n        }\n    };\n    DiagramRenderer.prototype.updateSegmentPosition = function (handle, options) {\n        var attr = {\n            'id': options.id, 'transform': 'rotate(' + options.angle + ',' + (options.x + options.width * options.pivotX) + ','\n                + (options.y + options.height * options.pivotY) + ')' + 'translate(' + (options.x) + ',' + (options.y) + ')',\n            'visibility': options.visible ? 'visible' : 'hidden', 'opacity': options.opacity\n        };\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(handle, attr);\n    };\n    /**\n     * Method used to render border for the node element  \\\n     *\n     * @returns {void } Method used to render border for the node element .\\\n     *\n     * @param {SelectorModel} selector - Provide the selector model instance.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { number } enableNode - Provide enableNode boolean value.\n     * @param { boolean } isBorderTickness - Provide the thickness value for the node.\n     * @param { boolean } isSwimlane - Provide the isSwimlane boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderBorder = function (selector, canvas, transform, enableNode, isBorderTickness, isSwimlane) {\n        var wrapper = selector;\n        var options = this.getBaseAttributes(wrapper, transform);\n        options.x *= transform.scale;\n        options.y *= transform.scale;\n        options.width *= transform.scale;\n        options.height *= transform.scale;\n        options.fill = 'transparent';\n        options.stroke = '#097F7F';\n        options.strokeWidth = 1.2;\n        options.gradient = null;\n        options.dashArray = '6,3';\n        options.class = 'e-diagram-selector';\n        if (isSwimlane) {\n            options.class += ' e-diagram-lane';\n        }\n        options.id = 'borderRect';\n        options.id = (this.rendererActions & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.RendererAction.DrawSelectorBorder) ? 'borderRect_symbol' : 'borderRect';\n        if (!enableNode) {\n            options.class += ' e-disabled';\n        }\n        if (isBorderTickness) {\n            options.class += ' e-thick-border';\n        }\n        options.cornerRadius = 0;\n        var parentSvg = this.getParentSvg(selector, 'selector');\n        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, true, parentSvg);\n    };\n    /**\n     * Method used to render user handle for the node element\\\n     *\n     * @returns {void } Method used to render user handle for the node element .\\\n     *\n     * @param {SelectorModel} selectorItem - Provide the selector model instance.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value.\n     * @param { HTMLElement } diagramUserHandlelayer - Provide the HTMLElement value.\n     * @param { Actions } currentAction - Provide the currentAction value.\n     * @param { boolean } inAction - Provide the inAction value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderUserHandler = function (selectorItem, canvas, transform, diagramUserHandlelayer, currentAction, inAction) {\n        var wrapper = selectorItem.wrapper;\n        var canDraw;\n        for (var _i = 0, _a = selectorItem.userHandles; _i < _a.length; _i++) {\n            var obj = _a[_i];\n            canDraw = true;\n            //879279 : Userhandle should be removed on dragging the node/connector in mousemove action\n            if ((obj.disableConnectors && selectorItem.connectors.length > 0) ||\n                (obj.disableNodes && selectorItem.nodes.length > 0) ||\n                (currentAction === 'Drag' && inAction)) {\n                canDraw = false;\n            }\n            var div = document.getElementById(obj.name + '_template_hiddenUserHandle');\n            if (div) {\n                obj.template = (div.childNodes[0]).cloneNode(true);\n            }\n            //const newPoint: PointModel;\n            var newPoint = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.getUserHandlePosition)(selectorItem, obj, transform);\n            newPoint.x = (newPoint.x + transform.tx) * transform.scale;\n            newPoint.y = (newPoint.y + transform.ty) * transform.scale;\n            if (obj.visible) {\n                obj.visible = (selectorItem.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.UserHandle) ? true : false;\n            }\n            if (canDraw) {\n                if (obj.pathData) {\n                    var data = obj.pathData ? obj.pathData : obj.content;\n                    var option = this.getBaseAttributes(wrapper);\n                    option.id = obj.name + '_userhandle';\n                    option.fill = obj.backgroundColor;\n                    option.stroke = obj.borderColor;\n                    option.strokeWidth = obj.borderWidth;\n                    option.centerX = newPoint.x;\n                    option.centerY = newPoint.y;\n                    option.radius = obj.size * 0.5;\n                    option.class = 'e-diagram-userhandle-circle';\n                    option.angle = 0;\n                    option.visible = obj.visible;\n                    option.opacity = 1;\n                    this.svgRenderer.drawCircle(canvas, option, 1, { 'aria-label': obj.name + 'user handle' });\n                    var pathPading = 5;\n                    var arrayCollection = [];\n                    arrayCollection = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_12__.processPathData)(data);\n                    arrayCollection = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_12__.splitArrayCollection)(arrayCollection);\n                    var pathSize = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.measurePath)(data);\n                    //requiredSize/contentSize\n                    var scaleX = (obj.size - 0.45 * obj.size) / pathSize.width;\n                    var scaleY = (obj.size - 0.45 * obj.size) / pathSize.height;\n                    var newData = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_12__.transformPath)(arrayCollection, scaleX, scaleY, true, pathSize.x, pathSize.y, 0, 0);\n                    pathSize = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.measurePath)(newData);\n                    var options = {\n                        x: newPoint.x - pathSize.width / 2,\n                        y: newPoint.y - pathSize.height / 2, angle: 0, id: '',\n                        class: 'e-diagram-userhandle-path', fill: obj.pathColor,\n                        stroke: obj.backgroundColor, strokeWidth: 0.5, dashArray: '', data: newData,\n                        width: obj.size - pathPading, height: obj.size - pathPading, pivotX: 0, pivotY: 0, opacity: 1, visible: obj.visible\n                    };\n                    this.svgRenderer.drawPath(canvas, options, this.diagramId, undefined, undefined, { 'aria-label': obj.name + 'user handle' });\n                }\n                else if (obj.content) {\n                    //const handleContent: DiagramNativeElement;\n                    var handleContent = new _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__.DiagramNativeElement(obj.name, this.diagramId);\n                    handleContent.content = obj.content;\n                    handleContent.offsetX = newPoint.x;\n                    handleContent.offsetY = newPoint.y;\n                    handleContent.id = obj.name + '_shape';\n                    handleContent.horizontalAlignment = 'Center';\n                    handleContent.verticalAlignment = 'Center';\n                    handleContent.visible = obj.visible;\n                    handleContent.setOffsetWithRespectToBounds(newPoint.x, newPoint.y, 'Fraction');\n                    handleContent.relativeMode = 'Object';\n                    handleContent.description = obj.name || 'User handle';\n                    handleContent.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_5__.Size(obj.size, obj.size));\n                    handleContent.arrange(handleContent.desiredSize);\n                    this.svgRenderer.drawNativeContent(handleContent, canvas, obj.size, obj.size, this.adornerSvgLayer);\n                }\n                else if (obj.source) {\n                    var element = new _core_elements_image_element__WEBPACK_IMPORTED_MODULE_1__.ImageElement();\n                    var options = this.getBaseAttributes(element, transform);\n                    options.width = obj.size;\n                    options.height = obj.size;\n                    options.x = newPoint.x - (obj.size / 2);\n                    options.y = newPoint.y - (obj.size / 2);\n                    options.sourceWidth = obj.size;\n                    options.sourceHeight = obj.size;\n                    options.alignment = element.imageAlign;\n                    options.source = obj.source;\n                    options.scale = element.imageScale;\n                    options.visible = obj.visible;\n                    options.description = obj.name || 'User handle';\n                    options.id = obj.name + '_';\n                    this.renderer.drawImage(canvas, options, this.adornerSvgLayer, false);\n                }\n                else {\n                    //const templateContent: DiagramHtmlElement;\n                    var templateContent = new _core_elements_html_element__WEBPACK_IMPORTED_MODULE_14__.DiagramHtmlElement(obj.name, this.diagramId);\n                    templateContent.offsetX = newPoint.x;\n                    templateContent.offsetY = newPoint.y;\n                    templateContent.id = obj.name + '_shape';\n                    templateContent.visible = obj.visible;\n                    templateContent.relativeMode = 'Object';\n                    templateContent.template = obj.template;\n                    templateContent.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_5__.Size(obj.size, obj.size));\n                    templateContent.arrange(templateContent.desiredSize);\n                    this.svgRenderer.drawHTMLContent(templateContent, diagramUserHandlelayer, undefined, true, undefined);\n                }\n            }\n        }\n    };\n    /**\n     * Method used to render rotate thumb of the diagramnode element  \\\n     *\n     * @returns {void } Method used to render rotate thumb of the diagramnode element .\\\n     *\n     * @param {DiagramElement} wrapper - Provide the wrapper  element value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value.\n     * @param { boolean } canMask - Provide the boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderRotateThumb = function (wrapper, canvas, transform, selectorConstraints, canMask) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var element = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_0__.PathElement();\n        var newPoint;\n        var size = new _primitives_size__WEBPACK_IMPORTED_MODULE_5__.Size();\n        size.width = 18;\n        size.height = 16;\n        var top = wrapper.offsetY - wrapper.actualSize.height * wrapper.pivot.y;\n        var left = wrapper.offsetX - wrapper.actualSize.width * wrapper.pivot.x;\n        var visible = (selectorConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SelectorConstraints.Rotate) ? true : false;\n        if (canMask) {\n            visible = false;\n        }\n        var data = 'M 16.856144362449648 10.238890446662904 L 18.000144362449646 3.437890446662903' +\n            'L 15.811144362449646 4.254890446662903 C 14.837144362449646 2.5608904466629028 13.329144362449647 ' +\n            ' 1.2598904466629026 11.485144362449645 0.5588904466629026 C 9.375144362449646 - 0.24510955333709716 7.071144362449646 ' +\n            ' - 0.18010955333709716 5.010144362449646 0.7438904466629028 C 2.942144362449646 1.6678904466629028 1.365144362449646' +\n            ' 3.341890446662903 0.558144362449646 5.452890446662903 C - 0.244855637550354 7.567890446662903 - 0.17985563755035394' +\n            ' 9.866890446662904 0.7431443624496461 11.930890446662904 C 1.6681443624496461 13.994890446662904 3.343144362449646' +\n            ' 15.575890446662903 5.457144362449647 16.380890446662903 C 6.426144362449647 16.7518904466629 7.450144362449647' +\n            ' 16.9348904466629 8.470144362449647 16.9348904466629 C 9.815144362449647 16.9348904466629 11.155144362449647 ' +\n            '16.6178904466629 12.367144362449647 15.986890446662901 L 11.351144362449647 14.024890446662901 C 9.767144362449647' +\n            ' 14.8468904466629 7.906144362449647 14.953890446662902 6.237144362449647 14.3178904466629 C 4.677144362449647' +\n            ' 13.7218904466629 3.444144362449647 12.5558904466629 2.758144362449647 11.028890446662901 C 2.078144362449646 ' +\n            '9.501890446662903 2.031144362449646 7.802890446662903 2.622144362449646 6.243890446662903 C 3.216144362449646' +\n            ' 4.6798904466629025 4.387144362449646 3.442890446662903 5.914144362449646 2.760890446662903 C 7.437144362449646 ' +\n            '2.078890446662903 9.137144362449646 2.0298904466629026 10.700144362449645 2.6258904466629027 C 11.946144362449646 ' +\n            '3.100890446662903 12.971144362449646 3.9538904466629026 13.686144362449646 5.049890446662903 L 11.540144362449645 ' +\n            '5.850890446662903 L 16.856144362449648 10.238890446662904 Z';\n        var pivotX = left + wrapper.pivot.x * wrapper.actualSize.width;\n        var pivotY = top;\n        pivotX = (pivotX + transform.tx) * transform.scale;\n        pivotY = (pivotY + transform.ty) * transform.scale;\n        newPoint = { x: pivotX - size.width * 0.5, y: pivotY - 30 - size.height * 0.5 };\n        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.identityMatrix)();\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.rotateMatrix)(matrix, wrapper.rotateAngle + wrapper.parentTransform, (transform.tx + wrapper.offsetX) * transform.scale, (transform.ty + wrapper.offsetY) * transform.scale);\n            newPoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_4__.transformPointByMatrix)(matrix, newPoint);\n        }\n        var options = {\n            x: newPoint.x,\n            y: newPoint.y,\n            angle: wrapper.rotateAngle + wrapper.parentTransform,\n            fill: '#231f20', stroke: 'black', strokeWidth: 0.5, dashArray: '', data: data,\n            width: 20, height: 20, pivotX: 0, pivotY: 0, opacity: 1, visible: visible, id: wrapper.id, class: 'e-diagram-rotate-handle'\n        };\n        options.id = 'rotateThumb';\n        //Bug 914365: Node is not resizable using touch interaction\n        //Added below code to update the element if it is already rendered during touch move interaction\n        if (this.touchMove) {\n            var thumb = document.getElementById('rotateThumb');\n            if (thumb) {\n                this.updateSegmentPosition(thumb, options);\n            }\n            else {\n                this.svgRenderer.drawPath(canvas, options, this.diagramId, true, undefined, { 'aria-label': 'Thumb to rotate the selected object' });\n            }\n        }\n        else {\n            this.svgRenderer.drawPath(canvas, options, this.diagramId, true, undefined, { 'aria-label': 'Thumb to rotate the selected object' });\n        }\n    };\n    /**\n     * Method used to render the path element for the diagram  \\\n     *\n     * @returns {void } Method used to render the path element for the diagram .\\\n     *\n     * @param {PathElement} element - Provide the path element of the diagram .\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SVGSVGElement } parentSvg - Provide the parent SVG element .\n     * @param { boolean } fromPalette - Provide the boolean value .\n     * @param { boolean } isPreviewNode - Provide the boolean value .\n     * @param {object} portCenterPoint - provide the portCenterPoint value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderPathElement = function (element, canvas, transform, parentSvg, fromPalette, isPreviewNode, portCenterPoint) {\n        var options = this.getBaseAttributes(element, transform, isPreviewNode);\n        options.data = element.absolutePath;\n        options.data = element.absolutePath;\n        // Feature 826644: Support to add ports to the connector. Added below condition to position port based on its alignment and offset.\n        if (element.isPathPort && portCenterPoint) {\n            options.x = portCenterPoint[element.id] ? portCenterPoint[element.id].cx : options.x;\n            options.y = portCenterPoint[element.id] ? portCenterPoint[element.id].cy : options.y;\n            element.bounds.x = options.x;\n            element.bounds.y = options.y;\n            var diagramElement = document.getElementById(this.diagramId);\n            var instance = 'ej2_instances';\n            var diagram = void 0;\n            if (diagramElement) {\n                diagram = diagramElement[\"\" + instance][0];\n                if (diagram.eventHandler.currentAction !== 'PortDrag') {\n                    element.offsetX = options.x + (element.width / 2);\n                    element.offsetY = options.y + (element.height / 2);\n                }\n            }\n        }\n        var ariaLabel = element.description ? element.description : element.id;\n        if (element.isExport) {\n            var pathBounds = element.absoluteBounds;\n            //Bug 857388: Connector with bridging is not properly exported.\n            //Below we save the arc values of bridge and use it in renderPath method.\n            var collection = (0,_utility_path_util__WEBPACK_IMPORTED_MODULE_12__.processPathData)(options.data);\n            // Get r1 and r2 values for 'A' commands\n            var arc = this.findAndStoreArcValues(collection);\n            options.arc = arc;\n            options.data = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.updatePath)(element, pathBounds, undefined, options);\n        }\n        this.renderer.drawPath(canvas, options, this.diagramId, undefined, parentSvg, ariaLabel, undefined, this, element);\n    };\n    // Function to filter 'A' commands and extract r1 and r2 values\n    DiagramRenderer.prototype.findAndStoreArcValues = function (arr) {\n        var rValues = [];\n        arr.forEach(function (obj) {\n            if (obj.command === 'A') {\n                // Store r1 and r2 values in an object\n                var rObj = { r1: obj.r1 / 2, r2: obj.r2 / 2 };\n                rValues.push(rObj);\n            }\n        });\n        // Return array of r1 and r2 values\n        return rValues;\n    };\n    /**\n     * Method used to update the grid line for the diagram  \\\n     *\n     * @returns {void } Method used to update the grid line for the diagram .\\\n     *\n     * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .\n     * @param { SVGSVGElement } gridSvg - Provide the SVG grid  element value.\n     * @param { Transforms } t - Provide the transform value  .\n     * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .\n     * @param { RulerModel } hRuler - Provide the horizontal ruler property value .\n     * @param { RulerModel } vRuler - Provide the vertical ruler property value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderSvgGridlines = function (snapSettings, gridSvg, t, rulerSettings, hRuler, vRuler) {\n        var pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n        var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n        defs.setAttribute('id', this.diagramId + '_grid_pattern_defn');\n        if (snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SnapConstraints.ShowHorizontalLines ||\n            snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SnapConstraints.ShowVerticalLines) {\n            pattern.setAttribute('id', this.diagramId + '_pattern');\n        }\n        var hWidth = 0;\n        var hHeight = 0;\n        var hSegmentwidth = 0;\n        var vSegmentwidth = 0;\n        var scale = 1;\n        var isRulerGrid = false;\n        var isLine = snapSettings.gridType === 'Lines';\n        var verticalLineIntervals = isLine ?\n            snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;\n        var horizontalLineIntervals = isLine ?\n            snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;\n        if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler && vRuler) {\n            hSegmentwidth = vRuler.updateSegmentWidth(t.scale);\n            vSegmentwidth = hRuler.updateSegmentWidth(t.scale);\n            snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];\n            snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];\n            isRulerGrid = true;\n        }\n        else {\n            for (var i = 0; i < verticalLineIntervals.length; i = i + 1) {\n                hWidth += verticalLineIntervals[parseInt(i.toString(), 10)];\n            }\n            for (var i = 0; i < horizontalLineIntervals.length; i = i + 1) {\n                hHeight += horizontalLineIntervals[parseInt(i.toString(), 10)];\n            }\n            scale = this.scaleSnapInterval(snapSettings, t.scale);\n        }\n        hWidth = isRulerGrid ? vSegmentwidth : hWidth * scale;\n        hHeight = isRulerGrid ? hSegmentwidth : hHeight * scale;\n        var attr = {\n            id: this.diagramId + '_pattern', x: 0, y: 0, width: hWidth,\n            height: hHeight, patternUnits: 'userSpaceOnUse'\n        };\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(pattern, attr);\n        this.horizontalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);\n        this.verticalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);\n        defs.appendChild(pattern);\n        gridSvg.appendChild(defs);\n    };\n    DiagramRenderer.prototype.horizontalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, intervals) {\n        var space = 0;\n        var dashArray = [];\n        var hLine;\n        if (snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SnapConstraints.ShowHorizontalLines) {\n            if (snapSettings.horizontalGridlines.lineDashArray) {\n                dashArray = this.renderer.parseDashArray(snapSettings.horizontalGridlines.lineDashArray);\n            }\n            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler) {\n                intervals = this.updateLineIntervals(intervals, rulerSettings, vRuler, hHeight, isLine);\n            }\n            intervals = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.getInterval)(intervals, isLine);\n            for (var i = 0; i < intervals.length; i = i + 2) {\n                space = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.getSpaceValue)(intervals, isLine, i, space);\n                var spaceY = 0;\n                hLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');\n                var attr = void 0;\n                var d = isLine ? space + intervals[parseInt(i.toString(), 10)] / 2 : space;\n                d = isRulerGrid ? d : d * scale;\n                if (isLine) {\n                    if (dashArray.toString() === '') {\n                        attr = {\n                            'stroke-width': intervals[parseInt(i.toString(), 10)],\n                            'd': 'M0,' + (d) + ' L' + hWidth + ',' + (d) + ' Z',\n                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'stroke': snapSettings.horizontalGridlines.lineColor\n                        };\n                    }\n                    else {\n                        attr = {\n                            'stroke-width': intervals[parseInt(i.toString(), 10)], 'stroke': snapSettings.horizontalGridlines.lineColor,\n                            'd': 'M0,' + (d) + ' L' + hWidth + ',' + (d) + ' Z',\n                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'dashArray': dashArray.toString()\n                        };\n                    }\n                    (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(hLine, attr);\n                    pattern.appendChild(hLine);\n                    space += intervals[i + 1] + intervals[parseInt(i.toString(), 10)];\n                }\n                else {\n                    this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, true);\n                    space += intervals[parseInt(i.toString(), 10)];\n                }\n            }\n        }\n    };\n    DiagramRenderer.prototype.renderDotGrid = function (i, pattern, snapSettings, spacey, d, scale, isHorizontal) {\n        var intervals = !isHorizontal ?\n            snapSettings.horizontalGridlines.dotIntervals : snapSettings.verticalGridlines.dotIntervals;\n        intervals = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.getInterval)(intervals, false);\n        var r;\n        var hLine;\n        //const doubleRadius: boolean;\n        var dy;\n        var attr;\n        for (var j = 1; j < intervals.length; j = j + 2) {\n            r = j === intervals.length - 1 ? intervals[0] : intervals[j - 1];\n            hLine = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n            dy = spacey;\n            dy = dy * scale;\n            attr = {\n                'cx': isHorizontal ? dy : d, 'cy': isHorizontal ? d : dy, 'fill': snapSettings.horizontalGridlines.lineColor, 'r': r\n            };\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(hLine, attr);\n            pattern.appendChild(hLine);\n            spacey += intervals[parseInt(j.toString(), 10)] + intervals[j - 1];\n        }\n    };\n    DiagramRenderer.prototype.verticalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, intervals) {\n        var space = 0;\n        var dashArray = [];\n        var vLine;\n        if (snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.SnapConstraints.ShowVerticalLines) {\n            if (snapSettings.verticalGridlines.lineDashArray) {\n                dashArray = this.renderer.parseDashArray(snapSettings.verticalGridlines.lineDashArray);\n            }\n            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler) {\n                intervals = this.updateLineIntervals(intervals, rulerSettings, hRuler, hWidth, isLine);\n            }\n            var spaceY = 0;\n            intervals = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.getInterval)(intervals, isLine);\n            for (var i = 0; i < intervals.length; i = i + 2) {\n                space = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.getSpaceValue)(intervals, isLine, i, space);\n                var d = isLine ? space + intervals[parseInt(i.toString(), 10)] / 2 : space;\n                d = isRulerGrid ? d : d * scale;\n                vLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');\n                var attr = void 0;\n                if (isLine) {\n                    if (dashArray.toString() === '') {\n                        attr = {\n                            'stroke-width': intervals[parseInt(i.toString(), 10)],\n                            'd': 'M' + (d) + ',0 L' + (d) + ',' + hHeight + ' Z',\n                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'stroke': snapSettings.verticalGridlines.lineColor\n                        };\n                    }\n                    else {\n                        attr = {\n                            'stroke-width': intervals[parseInt(i.toString(), 10)],\n                            'class': intervals[parseInt(i.toString(), 10)] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'stroke': snapSettings.verticalGridlines.lineColor,\n                            'd': 'M' + (d) + ',0 L' + (d) + ',' + hHeight + ' Z',\n                            'dashArray': dashArray.toString()\n                        };\n                    }\n                    (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(vLine, attr);\n                    pattern.appendChild(vLine);\n                    space += intervals[i + 1] + intervals[parseInt(i.toString(), 10)];\n                }\n                else {\n                    this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, false);\n                    space += intervals[parseInt(i.toString(), 10)];\n                }\n            }\n        }\n    };\n    /**\n     * Method used to update the grid line for the diagram  \\\n     *\n     * @returns {void } Method used to update the grid line for the diagram .\\\n     *\n     * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .\n     * @param { SVGSVGElement } svgGrid - Provide the SVG grid  element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .\n     * @param { RulerModel } hRuler - Provide the horizontal ruler property value .\n     * @param { RulerModel } vRuler - Provide the vertical ruler property value .\n     * @private\n     */\n    DiagramRenderer.prototype.updateGrid = function (snapSettings, svgGrid, transform, rulerSettings, hRuler, vRuler) {\n        var grid = svgGrid.getElementById(this.diagramId + '_grid_rect');\n        //let i: number;\n        var isRulerGrid = false;\n        if (grid) {\n            var pattern = svgGrid.getElementById(this.diagramId + '_pattern');\n            if (pattern) {\n                pattern.parentNode.removeChild(pattern);\n            }\n            var hSegmentwidth = 0;\n            var vSegmentwidth = 0;\n            var scale = 1;\n            var isLine = snapSettings.gridType === 'Lines';\n            var verticalLineIntervals = isLine ?\n                snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;\n            var horizontalLineIntervals = isLine ?\n                snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;\n            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler && hRuler) {\n                hSegmentwidth = vRuler.updateSegmentWidth(transform.scale);\n                vSegmentwidth = hRuler.updateSegmentWidth(transform.scale);\n                isRulerGrid = true;\n                snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];\n                snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];\n            }\n            else {\n                scale = this.scaleSnapInterval(snapSettings, transform.scale);\n            }\n            var height = 0;\n            for (var j = 0; j < horizontalLineIntervals.length; j = j + 1) {\n                height += horizontalLineIntervals[parseInt(j.toString(), 10)];\n            }\n            var width = 0;\n            for (var j = 0; j < verticalLineIntervals.length; j = j + 1) {\n                width += verticalLineIntervals[parseInt(j.toString(), 10)];\n            }\n            var attr = {\n                x: -transform.tx * transform.scale,\n                y: -transform.ty * transform.scale\n            };\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(grid, attr);\n            width = isRulerGrid ? vSegmentwidth : width * scale;\n            height = isRulerGrid ? hSegmentwidth : height * scale;\n            attr = {\n                id: this.diagramId + '_pattern', x: 0, y: 0, width: width,\n                height: height, patternUnits: 'userSpaceOnUse'\n            };\n            pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(pattern, attr);\n            this.horizontalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);\n            this.verticalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);\n            var defs = svgGrid.getElementById(this.diagramId + '_grid_pattern_defn');\n            if (defs) {\n                defs.appendChild(pattern);\n            }\n        }\n    };\n    DiagramRenderer.prototype.updateLineIntervals = function (intervals, rulerSettings, ruler, segmentWidth, isLine) {\n        var newInterval = [];\n        var tickInterval = segmentWidth / ruler.interval;\n        var interval = isLine ? ruler.interval : ruler.interval + 1;\n        for (var i = 0; i < interval * 2; i++) {\n            if (i % 2 === 0) {\n                newInterval[parseInt(i.toString(), 10)] = isLine ? ((i === 0) ? 1.25 : 0.25) : 0;\n            }\n            else {\n                newInterval[parseInt(i.toString(), 10)] = isLine ? (tickInterval - newInterval[i - 1]) : tickInterval;\n            }\n        }\n        return newInterval;\n    };\n    DiagramRenderer.prototype.scaleSnapInterval = function (snapSettings, scale) {\n        if (scale >= 2) {\n            while (scale >= 2) {\n                scale /= 2;\n            }\n        }\n        else if (scale <= 0.5) {\n            while (scale <= 0.5) {\n                scale *= 2;\n            }\n        }\n        var i;\n        snapSettings.horizontalGridlines.scaledIntervals = snapSettings.horizontalGridlines.snapIntervals;\n        snapSettings.verticalGridlines.scaledIntervals = snapSettings.verticalGridlines.snapIntervals;\n        if (scale !== 1) {\n            var gridlines = snapSettings.horizontalGridlines;\n            gridlines.scaledIntervals = [];\n            for (i = 0; i < gridlines.snapIntervals.length; i++) {\n                gridlines.scaledIntervals[parseInt(i.toString(), 10)] = gridlines.snapIntervals[parseInt(i.toString(), 10)] * scale;\n            }\n            gridlines = snapSettings.verticalGridlines;\n            gridlines.scaledIntervals = [];\n            for (i = 0; i < gridlines.snapIntervals.length; i++) {\n                gridlines.scaledIntervals[parseInt(i.toString(), 10)] = gridlines.snapIntervals[parseInt(i.toString(), 10)] * scale;\n            }\n        }\n        return scale;\n    };\n    /**\n     * Method used to render the text element  \\\n     *\n     * @returns {void }Method used to render the text element  .\\\n     *\n     * @param {TextElement} element - Provide the text element .\n     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n     * @param { boolean } fromPalette - Provide the boolean value .\n     * @param { object } centerPoint - Provide the center point value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderTextElement = function (element, canvas, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transform, parentSvg, fromPalette, centerPoint) {\n        var options = this.getBaseAttributes(element, transform);\n        if (centerPoint) {\n            //Bug 827039: Bezier annotation content alignment is not working properly.\n            // Removed -2 cx-2 and cy-2 from the below two line to resolve the alignment issue.\n            options.x = centerPoint[element.id] ? centerPoint[element.id].cx : options.x;\n            options.y = centerPoint[element.id] ? centerPoint[element.id].cy : options.y;\n            // (EJ2-56874) - Set the calculated x and y position to the bezier connector annotation's(text element) bounds x,y position\n            element.bounds.x = options.x;\n            element.bounds.y = options.y;\n            // (EJ2-58802) - Calculate the center point x and y with the element export scale value if element is in export mode\n            if (element.isExport) {\n                options.x = options.x * Math.min(element.exportScaleValue.x || element.exportScaleValue.y);\n                options.y = options.y * Math.min(element.exportScaleValue.x || element.exportScaleValue.y);\n            }\n        }\n        options.cornerRadius = 0;\n        options.whiteSpace = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_6__.whiteSpaceToString)(element.style.whiteSpace, element.style.textWrapping);\n        options.content = element.content;\n        options.breakWord = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_6__.wordBreakToString)(element.style.textWrapping);\n        options.textAlign = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_6__.textAlignToString)(element.style.textAlign);\n        options.color = element.style.color;\n        options.italic = element.style.italic;\n        options.bold = element.style.bold;\n        options.fontSize = element.style.fontSize;\n        options.fontFamily = element.style.fontFamily;\n        options.textOverflow = element.style.textOverflow;\n        options.textWrapping = element.style.textWrapping;\n        options.textDecoration = element.style.textDecoration;\n        options.doWrap = element.doWrap;\n        options.wrapBounds = element.wrapBounds;\n        options.childNodes = element.childNodes;\n        options.isHorizontalLane = element.isLaneOrientation;\n        options.id = element.id ? element.id : (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_6__.randomId)();\n        if (element.isLaneOrientation) {\n            options.parentOffsetX = this.groupElement.offsetX;\n            options.parentOffsetY = this.groupElement.offsetY;\n            options.parentWidth = this.groupElement.actualSize.width;\n            options.parentHeight = this.groupElement.actualSize.height;\n        }\n        options.dashArray = '';\n        options.strokeWidth = 0;\n        options.fill = element.style.fill;\n        var ariaLabel = element.description ? element.description : element.content ? element.content : element.id;\n        if ((element.style.textWrapping === 'Wrap' || element.style.textWrapping === 'WrapWithOverflow') &&\n            this.groupElement && options.height > this.groupElement.actualSize.height &&\n            (element.style.textOverflow === 'Clip' || element.style.textOverflow === 'Ellipsis')) {\n            options.y = options.y + (options.height - this.groupElement.actualSize.height) / 2;\n        }\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        this.renderer.drawText(canvas, options, parentSvg, ariaLabel, this.diagramId, (element.isExport && Math.min(element.exportScaleValue.x || element.exportScaleValue.y)), this, element);\n        if (this.isSvgMode) {\n            element.doWrap = false;\n        }\n    };\n    DiagramRenderer.prototype.renderNativeElement = function (element, canvas, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transform, parentSvg, fromPalette) {\n        var templateWidth;\n        var templateHeight;\n        var nativeSvg = this.getParentSvg(element, undefined, canvas) || parentSvg;\n        var nativeLayer = this.getParentElement(element, canvas, nativeSvg).g || canvas;\n        var options = this.getBaseAttributes(element, transform);\n        options.fill = 'transparent';\n        options.cornerRadius = element.cornerRadius;\n        options.stroke = 'transparent';\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        switch (element.scale) {\n            case 'None':\n                templateWidth = element.contentSize.width;\n                templateHeight = element.contentSize.height;\n                break;\n            case 'Stretch':\n                templateWidth = element.actualSize.width;\n                templateHeight = element.actualSize.height;\n                break;\n            case 'Meet':\n                if (element.actualSize.width <= element.actualSize.height) {\n                    templateWidth = templateHeight = element.actualSize.width;\n                }\n                else {\n                    templateWidth = templateHeight = element.actualSize.height;\n                }\n                break;\n            case 'Slice':\n                if (element.actualSize.width >= element.actualSize.height) {\n                    templateWidth = templateHeight = element.actualSize.width;\n                }\n                else {\n                    templateWidth = templateHeight = element.actualSize.height;\n                }\n                break;\n        }\n        if (this.svgRenderer) {\n            this.svgRenderer.drawNativeContent(element, nativeLayer, templateHeight, templateWidth, nativeSvg);\n        }\n    };\n    DiagramRenderer.prototype.renderHTMLElement = function (element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue) {\n        var options = this.getBaseAttributes(element, transform);\n        options.fill = 'transparent';\n        options.cornerRadius = element.cornerRadius;\n        options.stroke = 'transparent';\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        if (this.svgRenderer) {\n            this.svgRenderer.drawHTMLContent(element, htmlLayer.children[0], transform, (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_7__.isDiagramChild)(htmlLayer), indexValue);\n        }\n    };\n    /**\n     * Method used to render the image element  \\\n     *\n     * @returns {void }Method used to render the image element  .\\\n     *\n     * @param {ImageElement} element - Provide the image element .\n     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n     * @param { boolean } fromPalette - Provide the boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderImageElement = function (element, canvas, transform, parentSvg, fromPalette) {\n        var options = this.getBaseAttributes(element, transform);\n        options.cornerRadius = 0;\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        // let sx: number; let sy: number;\n        var imageWidth;\n        var imageHeight;\n        var sourceWidth;\n        var sourceHeight;\n        var contentWidth = element.contentSize.width;\n        var contentHeight = element.contentSize.height;\n        var widthRatio = options.width / contentWidth;\n        var heightRatio = options.height / contentHeight;\n        var ratio;\n        if (element.stretch === 'Stretch') {\n            // 909174: Image node is not exported properly Issue Fix\n            ratio = Math.min(widthRatio, heightRatio);\n            imageWidth = contentWidth * ratio;\n            imageHeight = contentHeight * ratio;\n        }\n        else {\n            switch (element.stretch) {\n                case 'Meet':\n                    ratio = Math.min(widthRatio, heightRatio);\n                    imageWidth = contentWidth * ratio;\n                    imageHeight = contentHeight * ratio;\n                    options.x += Math.abs(options.width - imageWidth) / 2;\n                    options.y += Math.abs(options.height - imageHeight) / 2;\n                    break;\n                case 'Slice':\n                    ratio = Math.max(widthRatio, heightRatio);\n                    imageWidth = contentWidth * ratio;\n                    imageHeight = contentHeight * ratio;\n                    sourceWidth = options.width / imageWidth * contentWidth;\n                    sourceHeight = options.height / imageHeight * contentHeight;\n                    break;\n                case 'None':\n                    imageWidth = contentWidth;\n                    imageHeight = contentHeight;\n                    break;\n            }\n        }\n        options.width = imageWidth;\n        options.height = imageHeight;\n        //Commented for code coverage\n        //(options as ImageAttributes).sourceX = sx;\n        //(options as ImageAttributes).sourceY = sy;\n        options.sourceWidth = sourceWidth;\n        options.sourceHeight = sourceHeight;\n        options.source = element.source;\n        options.alignment = element.imageAlign;\n        options.scale = element.imageScale;\n        options.description = element.description ? element.description : element.id;\n        this.renderer.drawImage(canvas, options, parentSvg, fromPalette, this, element);\n    };\n    /**\n     * Method used to render the container  \\\n     *\n     * @returns {void} Method used to render the container .\\\n     *\n     * @param {Container} group - Provide the container .\n     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n     * @param { HTMLElement } htmlLayer - Provide the html layer element  .\n     * @param { Transforms } transform - Provide the transform value .\n     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n     * @param { boolean } createParent - Provide the boolean value .\n     * @param { boolean } fromPalette - Provide the boolean value  .\n     * @param { number } indexValue - Provide the indexValue value .\n     * @param { boolean } isPreviewNode - Provide the boolean value .\n     * @param { object } centerPoint - Provide the centerPoint value .\n     * @param {object} portCenterPoint - provide the portCenterPoint value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderContainer = function (group, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint) {\n        var svgParent = { svg: parentSvg, g: canvas };\n        var diagramElement = document.getElementById(this.diagramId);\n        var instance = 'ej2_instances';\n        var diagram;\n        if (diagramElement) {\n            diagram = diagramElement[\"\" + instance][0];\n        }\n        if (this.diagramId) {\n            parentSvg = this.getParentSvg(group) || parentSvg;\n            if (this.isSvgMode) {\n                //const groupElement: HTMLCanvasElement | SVGElement;\n                // eslint-disable-next-line max-len\n                var groupElement = this.getParentElement(group, canvas, parentSvg, indexValue).g || canvas;\n                parentSvg = this.getParentSvg(this.hasNativeParent(group.children)) || parentSvg;\n                var svgNativeParent = this.getParentElement(this.hasNativeParent(group.children), groupElement, parentSvg, indexValue);\n                svgParent.svg = svgNativeParent.svg || parentSvg;\n                svgParent.g = svgNativeParent.g || groupElement;\n                if (createParent) {\n                    if (parentSvg) {\n                        if (!parentSvg.getElementById(svgParent.g.id)) {\n                            canvas.appendChild(svgParent.g);\n                        }\n                    }\n                    canvas = svgParent.g;\n                }\n                else {\n                    canvas = svgParent.g;\n                }\n            }\n        }\n        this.renderRect(group, canvas, transform, parentSvg);\n        this.groupElement = group;\n        if (group.hasChildren()) {\n            var parentG = void 0;\n            var svgParent_1;\n            for (var _i = 0, _a = group.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                this.groupElement = group;\n                parentSvg = this.getParentSvg(this.hasNativeParent(group.children) || child) || parentSvg;\n                if (this.isSvgMode) {\n                    svgParent_1 = this.getParentElement(this.hasNativeParent(group.children) || child, canvas, parentSvg);\n                    parentG = svgParent_1.g || canvas;\n                    if (svgParent_1.svg) {\n                        parentSvg = svgParent_1.svg;\n                    }\n                }\n                if (!this.isSvgMode) {\n                    if (child.relativeMode === 'Object') {\n                        child.flip = group.flip;\n                        //To update the compensation and adhoc child flip in print and export.\n                        if (child.id && (child.id.includes('_0_compensation') || child.id.includes('_0_adhoc'))) {\n                            if (group.children[0].flip) {\n                                child.flip = group.children[0].flip;\n                            }\n                        }\n                    }\n                }\n                var parentGElement = parentG;\n                this.renderElement(child, parentG || canvas, htmlLayer, transform, parentSvg, true, fromPalette, indexValue, isPreviewNode, centerPoint, portCenterPoint);\n                if (group.children && group.children[0] instanceof _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__.DiagramNativeElement) {\n                    if (child instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_2__.TextElement || (child.elementActions & _enum_enum__WEBPACK_IMPORTED_MODULE_9__.ElementAction.ElementIsPort)) {\n                        parentGElement = document.getElementById(child.id + '_groupElement');\n                    }\n                }\n                if (child instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_2__.TextElement && parentGElement) {\n                    this.renderFlipTextElement(group, parentGElement, child, child.flip, child.flipMode);\n                }\n            }\n            var selectedNode = void 0;\n            if (diagram && diagram.selectedItems && diagram.selectedItems.nodes\n                && diagram.selectedItems.nodes.length > 0) {\n                selectedNode = diagram.selectedItems.nodes[0];\n            }\n            var innerNodeContent = void 0;\n            var innerLabelContent = void 0;\n            var isNodeSelected = false;\n            var Node_1;\n            var objId = group.id.includes('group_container')\n                ? group.id.split('group_container')[0]\n                : group.id;\n            if (diagram && diagram.selectedItems) {\n                Node_1 = diagram.getObject(objId);\n            }\n            selectedNode = Node_1;\n            if (selectedNode && selectedNode.flipMode) {\n                isNodeSelected = true;\n            }\n            var containerId = '';\n            if (selectedNode) {\n                containerId = selectedNode.children ? selectedNode.id + 'group_container' : selectedNode.id + '_content_groupElement';\n            }\n            if (diagram instanceof _diagram__WEBPACK_IMPORTED_MODULE_17__.Diagram && diagram.nameTable[\"\" + objId] && diagram.nameTable[\"\" + objId].propName !== 'connectors') {\n                if (isNodeSelected && selectedNode) {\n                    if (group.children && group.children[0] instanceof _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__.DiagramNativeElement) {\n                        innerNodeContent = document.getElementById(selectedNode.id + '_content_inner_native_element');\n                    }\n                    else if (group.children && group.children[0] instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_14__.DiagramHtmlElement) {\n                        innerNodeContent = document.getElementById(selectedNode.id + '_content_html_element');\n                        if (!innerNodeContent) {\n                            innerNodeContent = document.getElementById(containerId);\n                        }\n                    }\n                    else {\n                        innerNodeContent = document.getElementById(containerId);\n                    }\n                    this.renderFlipElement(group, innerNodeContent, group.flip);\n                }\n            }\n        }\n    };\n    /**\n     * Method used to flip the text element   \\\n     *\n     * @returns {void} Method used to flip the text element.\\\n     *\n     * @param {DiagramElement} element - Provide the node element.\n     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the text canvas element.\n     * @param { DiagramElement } textElement - Provide the text element.\n     * @param { FlipDirection } flip - Provide the node flip direction.\n     * @param { FlipMode } flipMode - Provide the node flipMode.\n     * @param { boolean } isCanvasMode - Provide the isCanvas mode.\n     */\n    DiagramRenderer.prototype.renderFlipTextElement = function (element, canvas, textElement, flip, flipMode, isCanvasMode) {\n        var attr = {};\n        var scaleX = 1;\n        var scaleY = 1;\n        var posX = 0;\n        var posY = 0;\n        var offsetX = 0;\n        var offsetY = 0;\n        if (flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.None) {\n            var rotateAngle = element.rotateAngle;\n            if (element.rotateAngle === 0 && element.id.includes('group_container')) {\n                rotateAngle = element.parentTransform;\n            }\n            // Fetch annotation offset\n            var textPos = textElement.getAbsolutePosition(textElement.desiredSize);\n            if (!textPos) {\n                var size = textElement.desiredSize;\n                textPos = { x: 0.5 * size.width, y: 0.5 * size.height };\n            }\n            if (textPos && textElement.content !== '') {\n                // Inverting and translating Annotation\n                if (flipMode === 'All' || flipMode === 'LabelAndLabelText') {\n                    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Horizontal || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both) {\n                        posX = element.bounds.center.x;\n                        offsetX = -element.bounds.center.x;\n                        scaleX = -1;\n                    }\n                    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Vertical || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both) {\n                        posY = element.bounds.center.y;\n                        offsetY = -element.bounds.center.y;\n                        scaleY = -1;\n                    }\n                    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Horizontal || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Vertical) {\n                        var angle = Math.sin(rotateAngle * Math.PI / 180);\n                        //918299 - Issue with Polygon Shape Node Rotation After Grouping and Flipping\n                        if (textPos.y !== undefined && !isNaN(textPos.y)) {\n                            var textPosY = textPos.y / textElement.desiredSize.height;\n                            if (!isNaN(textPosY)) {\n                                offsetX += -element.desiredSize.height * angle * (-2 * textPosY + 1);\n                            }\n                        }\n                        if (textPos.x !== undefined && !isNaN(textPos.x)) {\n                            var textPosX = textPos.x / textElement.desiredSize.width;\n                            if (!isNaN(textPosX)) {\n                                offsetY += element.desiredSize.width * angle * (-2 * textPosX + 1);\n                            }\n                        }\n                    }\n                    attr = {\n                        'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ','\n                            + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'\n                    };\n                }\n                // Inverting Annotation without flipping position\n                else if (flipMode === 'LabelText' || flipMode === 'PortAndLabelText') {\n                    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Horizontal || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both) {\n                        posX = textElement.offsetX;\n                        offsetX = -textElement.offsetX;\n                        scaleX = -1;\n                    }\n                    if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Vertical || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both) {\n                        posY = textElement.offsetY;\n                        offsetY = -textElement.offsetY;\n                        scaleY = -1;\n                    }\n                    attr = {\n                        'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ','\n                            + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'\n                    };\n                }\n                // Translating Annotation\n                else if (flipMode === 'PortAndLabel' || flipMode === 'Label') {\n                    var labelPosX = 0;\n                    var labelPosY = 0;\n                    var labelPos = this.flipLabel(element, textElement, textPos, flip);\n                    labelPosX = labelPos.x - textElement.offsetX;\n                    labelPosY = labelPos.y - textElement.offsetY;\n                    attr = { 'transform': 'translate(' + labelPosX + ',' + labelPosY + ')' };\n                }\n            }\n        }\n        else {\n            attr = {\n                'transform': 'translate(' + 0 + ',' + 0 + ')'\n            };\n        }\n        if (!isCanvasMode) {\n            this.setFlipAttributes(element, canvas, attr, scaleX, scaleY, false);\n            return {};\n        }\n        else {\n            return attr;\n        }\n    };\n    DiagramRenderer.prototype.renderFlipElement = function (element, canvas, flip, isCanvasMode) {\n        var attr = {};\n        var scaleX = 1;\n        var scaleY = 1;\n        var posX = 0;\n        var posY = 0;\n        var offsetX = 0;\n        var offsetY = 0;\n        if (flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.None) {\n            if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Horizontal || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both) {\n                posX = element.bounds.center.x;\n                offsetX = -element.bounds.center.x;\n                scaleX = -1;\n            }\n            if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Vertical || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both) {\n                posY = element.bounds.center.y;\n                offsetY = -element.bounds.center.y;\n                scaleY = -1;\n            }\n            attr = {\n                'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ','\n                    + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'\n            };\n        }\n        else {\n            attr = {\n                'transform': 'translate(' + 0 + ',' + 0 + ')'\n            };\n        }\n        var isHtml = element && element.children &&\n            element.children.length && (element.children[0] instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_14__.DiagramHtmlElement);\n        if (!isCanvasMode) {\n            this.setFlipAttributes(element, canvas, attr, scaleX, scaleY, isHtml);\n            return {};\n        }\n        else {\n            return attr;\n        }\n    };\n    DiagramRenderer.prototype.setFlipAttributes = function (element, canvas, attr, scaleX, scaleY, isHtml) {\n        if (attr) {\n            if (isHtml) {\n                var id = canvas.id.split('_preview');\n                var layer = document.getElementById(id[0] + '_html_div') ||\n                    ((0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.getHTMLLayer)(this.diagramId).children[0]);\n                canvas = layer.querySelector(('#' + element.id + '_content_html_element'));\n                var flipAngle = (element.flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.None || element.flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both) ? 1 : -1;\n                if (canvas) {\n                    canvas.style.transform =\n                        'scale(' + scaleX + ',' + scaleY + ')' + 'rotate(' + ((flipAngle * element.rotateAngle) + element.parentTransform) + 'deg)';\n                }\n            }\n            else {\n                (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(canvas, attr);\n            }\n        }\n    };\n    /**\n     * Calculates Flipped Position of textElement considering annotation offset\n     *\n     * @returns {PointModel} - flipped point of textElement current point\n     *\n     * @param {NodeModel} element - Provide node wrapper element containing the text element.\n     * @param {TextElement} textElement - Provide the textElememt to flip.\n     * @param {PointModel} labelPos - Provide the annotation offset.\n     * @param {FlipDirection} flip - Provide the node flip direction.\n     */\n    DiagramRenderer.prototype.flipLabel = function (element, textElement, labelPos, flip) {\n        var flippedOffset;\n        if (flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.None) {\n            var flippedOffsetX = void 0;\n            var flippedOffsetY = void 0;\n            // Node's topLeft Position\n            var topLeft = {\n                x: element.offsetX - element.desiredSize.width / 2,\n                y: element.offsetY - element.desiredSize.height / 2\n            };\n            flippedOffsetX = topLeft.x + (element.desiredSize.width * ((labelPos.x / textElement.desiredSize.width)));\n            flippedOffsetY = topLeft.y + (element.desiredSize.height * ((labelPos.y / textElement.desiredSize.height)));\n            if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Horizontal) {\n                flippedOffsetX = topLeft.x + (element.desiredSize.width * (1 - (labelPos.x / textElement.desiredSize.width)));\n            }\n            if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Both || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Vertical) {\n                flippedOffsetY = topLeft.y + (element.desiredSize.height * (1 - (labelPos.y / textElement.desiredSize.height)));\n            }\n            // Flipped Position\n            flippedOffset = { x: flippedOffsetX, y: flippedOffsetY };\n            // FlippedPoint after rotating, with node offset as its pivot\n            flippedOffset = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_6__.rotatePoint)(element.rotateAngle + element.parentTransform, element.offsetX, element.offsetY, flippedOffset);\n        }\n        return flippedOffset;\n    };\n    /**\n     * Method used to check the native parent  \\\n     *\n     * @returns {void} Method used to check the native parent .\\\n     *\n     * @param { DiagramElement[]} children - Provide the diagram element .\n     * @param { number} count - Provide the count value .\n     * @private\n     */\n    DiagramRenderer.prototype.hasNativeParent = function (children, count) {\n        if (children && children.length > 0 && (count || 0 < 3)) {\n            var child = children[0];\n            if (child instanceof _core_elements_native_element__WEBPACK_IMPORTED_MODULE_13__.DiagramNativeElement) {\n                return child;\n            }\n            else if (child.children && child.children.length) {\n                this.hasNativeParent(child.children, count++ || 0);\n            }\n        }\n        return undefined;\n    };\n    /**\n     * Method used the draw the reactangle for the diagram  \\\n     *\n     * @returns {void} Method used the draw the reactangle for the diagram .\\\n     *\n     * @param { SVGElement} element - Provide the SVG elements .\n     * @param { RectAttributes} canvas - Provide the Canvas element  .\n     * @param { RectAttributes} transform - Provide transform value for the node  .\n     * @param { RectAttributes} parentSvg -provide the parent SVG  .\n     * @param { RectAttributes} isPreviewNode - Provide the preview boolean value  .\n     * @private\n     */\n    DiagramRenderer.prototype.renderRect = function (element, canvas, transform, parentSvg, isPreviewNode) {\n        var options = this.getBaseAttributes(element, transform, isPreviewNode);\n        options.cornerRadius = element.cornerRadius || 0;\n        if (element.isExport) {\n            options.cornerRadius *= element.exportScaleValue.x;\n        }\n        var ariaLabel = element.description ? element.description : element.id;\n        this.renderer.drawRectangle(canvas, options, this.diagramId, element.isExport, undefined, parentSvg, ariaLabel, undefined, undefined, this, element);\n    };\n    /**\n     * Method used the draw the reactangle for the diagram  \\\n     *\n     * @returns {void} Method used the draw the reactangle for the diagram .\\\n     *\n     * @param { SVGElement} canvas - Provide the SVG elements .\n     * @param { RectAttributes} options - Provide the attributes to draw the rectangle  .\n     * @private\n     */\n    DiagramRenderer.prototype.drawRect = function (canvas, options) {\n        options.cornerRadius = 0;\n        this.svgRenderer.drawRectangle(canvas, options, this.diagramId);\n    };\n    /**\n     * Will get the base attributes for all the elements  \\\n     *\n     * @returns {BaseAttributes} Will get the base attributes for all the elements .\\\n     *\n     * @param { DiagramElement} element - Provide the diagram elements .\n     * @param { Transforms} transform - Provide the transform value for the  elements .\n     * @param { boolean} isPreviewNode - Provide the preview boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.getBaseAttributes = function (element, transform, isPreviewNode) {\n        var options = {\n            width: element.actualSize.width, height: element.actualSize.height,\n            //EJ2-840163-Draw highlighter not rendered properly while hovering ports\n            x: element.offsetX - element.actualSize.width * element.pivot.x,\n            y: element.offsetY - element.actualSize.height * element.pivot.y,\n            fill: element.style.fill, stroke: element.style.strokeColor, angle: element.rotateAngle + element.parentTransform,\n            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: element.style.strokeWidth,\n            dashArray: element.style.strokeDashArray || '', opacity: element.style.opacity, shadow: element.shadow,\n            gradient: element.style.gradient, visible: element.visible, id: element.id, description: element.description,\n            canApplyStyle: element.canApplyStyle, shapeType: element.shapeType\n        };\n        if (element.rotationReference === 'Page') {\n            options.angle = element.rotateAngle;\n        }\n        if (isPreviewNode) {\n            options.x = options.x - .5;\n            options.y = options.y - .5;\n        }\n        if (element.isExport) {\n            options.width *= element.exportScaleValue.x;\n            options.height *= element.exportScaleValue.y;\n            options.x *= element.exportScaleValue.x;\n            options.y *= element.exportScaleValue.y;\n            options.strokeWidth *= element.exportScaleValue.x;\n        }\n        if (element.flip) {\n            options.flip = element.flip;\n            if ((element.flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Horizontal || element.flip === _enum_enum__WEBPACK_IMPORTED_MODULE_9__.FlipDirection.Vertical) &&\n                element instanceof _core_elements_image_element__WEBPACK_IMPORTED_MODULE_1__.ImageElement && !this.isSvgMode) {\n                options.isImage = true;\n            }\n        }\n        if (element.flipMode) {\n            options.flipMode = element.flipMode;\n        }\n        if (transform) {\n            options.x += transform.tx;\n            options.y += transform.ty;\n        }\n        return options;\n    };\n    /**\n     * Will render the SVG background image  \\\n     *\n     * @returns {void} Will render the SVG background image  .\\\n     *\n     * @param { Transforms} background - Provide the transforms values .\n     * @param { boolean} diagramElement - Provide element for the daigram.\n     * @param { boolean} x - Provide the rendering mode of the daigram.\n     * @param { boolean} y - Provide the rendering mode of the daigram.\n     * @param { boolean} width - Provide the rendering mode of the daigram.\n     * @param { boolean} height - Provide the rendering mode of the daigram.\n     * @private\n     */\n    DiagramRenderer.renderSvgBackGroundImage = function (background, diagramElement, x, y, width, height) {\n        if (background.source) {\n            var backgroundLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.getBackgroundLayerSvg)(diagramElement.id);\n            var target = backgroundLayer.getElementById(diagramElement.id + '_image');\n            if (!target) {\n                var bgimageLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.getBackgroundImageLayer)(diagramElement.id);\n                target = document.createElementNS('http://www.w3.org/2000/svg', 'image');\n                target.setAttribute('id', diagramElement.id + '_image');\n                bgimageLayer.appendChild(target);\n            }\n            var imageObj = new Image();\n            imageObj.src = background.source;\n            target.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', imageObj.src.toString());\n            var scale = background.scale !== 'None' ? background.scale : '';\n            var imgAlign = background.align;\n            var aspectRatio = imgAlign.charAt(0).toLowerCase() + imgAlign.slice(1);\n            if (scale) {\n                aspectRatio += ' ' + scale.charAt(0).toLowerCase() + scale.slice(1);\n            }\n            var attr = {\n                'id': diagramElement.id + '_image', 'x': x, 'y': y,\n                'width': width, 'height': height,\n                'preserveAspectRatio': aspectRatio\n            };\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.setAttributeSvg)(target, attr);\n        }\n    };\n    /**\n     * Method used to transform the layer  \\\n     *\n     *  @returns {boolean} Method used to transform the layer  .\\\n     *  @param { Transforms} transform - Provide the transforms values .\n     *  @param { boolean} svgMode - Provide the rendering mode of the daigram.\n     *  @private\n     */\n    DiagramRenderer.prototype.transformLayers = function (transform, svgMode) {\n        var tx = transform.tx * transform.scale;\n        var ty = transform.ty * transform.scale;\n        var domTable = 'domTable';\n        if (tx !== this.transform.x || ty !== this.transform.y || (tx === 0 || ty === 0)) {\n            //diagram layer\n            if (svgMode) {\n                if (!window[\"\" + domTable][this.diagramId + '_diagramLayer']) {\n                    window[\"\" + domTable][this.diagramId + '_diagramLayer'] =\n                        this.diagramSvgLayer.getElementById(this.diagramId + '_diagramLayer');\n                }\n                var diagramLayer = window[\"\" + domTable][this.diagramId + '_diagramLayer'];\n                diagramLayer.setAttribute('transform', 'translate('\n                    + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                    + transform.scale + ')');\n            }\n            //background\n            //gridline\n            var gridLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.getGridLayer)(this.diagramId);\n            gridLayer.setAttribute('transform', 'translate(' + (transform.tx * transform.scale) + ','\n                + (transform.ty * transform.scale) + ')');\n            //portslayer\n            if (!window[\"\" + domTable][this.diagramId + '_diagramPorts']) {\n                window[\"\" + domTable][this.diagramId + '_diagramPorts'] = this.iconSvgLayer.getElementById(this.diagramId + '_diagramPorts');\n            }\n            var portsLayer = window[\"\" + domTable][this.diagramId + '_diagramPorts'];\n            portsLayer.setAttribute('transform', 'translate('\n                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                + transform.scale + ')');\n            //expandlayer\n            if (!window[\"\" + domTable][this.diagramId + '_diagramExpander']) {\n                window[\"\" + domTable][this.diagramId + '_diagramExpander'] =\n                    this.iconSvgLayer.getElementById(this.diagramId + '_diagramExpander');\n            }\n            var expandLayer = window[\"\" + domTable][this.diagramId + '_diagramExpander'];\n            expandLayer.setAttribute('transform', 'translate('\n                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                + transform.scale + ')');\n            //nativelayer\n            if (!window[\"\" + domTable][this.diagramId + '_nativeLayer']) {\n                window[\"\" + domTable][this.diagramId + '_nativeLayer'] = this.nativeSvgLayer.getElementById(this.diagramId + '_nativeLayer');\n            }\n            var nativeLayer = window[\"\" + domTable][this.diagramId + '_nativeLayer'];\n            nativeLayer.setAttribute('transform', 'translate('\n                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                + transform.scale + ')');\n            //htmlLayer\n            var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_8__.getHTMLLayer)(this.diagramId).children[0];\n            htmlLayer.style.transform = 'translate('\n                + (transform.tx * transform.scale) + 'px,' + (transform.ty * transform.scale) + 'px)scale('\n                + transform.scale + ')';\n            this.transform = { x: transform.tx * transform.scale, y: transform.ty * transform.scale };\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Method used to update the nodes in the diagram  \\\n     *\n     *  @returns {void} Method used to update the nodes in the diagram  .\\\n     *  @param { HTMLCanvasElement} element - Provide the diagram element .\n     *  @param { HTMLCanvasElement} diagramElementsLayer - Provide the diagram layer element .\n     *  @param { HTMLCanvasElement} htmlLayer -Provide the html element .\n     *  @param { HTMLCanvasElement} transform - Provide the transform value .\n     *  @param { HTMLCanvasElement} insertIndex - Provide the index value.\n     *  @param { object} centerPoint - Provide the center point value.\n     *  @param {object} portCenterPoint - provide the portCenterPoint value.\n     *  @private\n     */\n    DiagramRenderer.prototype.updateNode = function (element, diagramElementsLayer, htmlLayer, transform, insertIndex, centerPoint, portCenterPoint) {\n        this.renderElement(element, diagramElementsLayer, htmlLayer, transform, this.getParentSvg(element), undefined, undefined, insertIndex, null, centerPoint, portCenterPoint);\n    };\n    return DiagramRenderer;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/renderer.js?");

/***/ })

}]);