"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-lineargauge_src_linear-gauge_linear-gauge_js-aeee243c"],{

/***/ "./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/linear-gauge.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/linear-gauge.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinearGauge: () => (/* binding */ LinearGauge)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _model_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/base */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/model/base.js\");\n/* harmony import */ var _axes_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./axes/axis */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/axis.js\");\n/* harmony import */ var _model_constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/constant */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/model/constant.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/helper */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/utils/helper.js\");\n/* harmony import */ var _axes_axis_panel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./axes/axis-panel */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/axis-panel.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _axes_axis_renderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./axes/axis-renderer */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/axis-renderer.js\");\n/* harmony import */ var _annotations_annotations__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./annotations/annotations */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/annotations/annotations.js\");\n/* harmony import */ var _user_interaction_tooltip__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./user-interaction/tooltip */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/user-interaction/tooltip.js\");\n/* harmony import */ var _model_theme__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./model/theme */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/model/theme.js\");\n/* harmony import */ var _axes_gradient__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./axes/gradient */ \"./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/axes/gradient.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable valid-jsdoc */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Represents the linear gauge control. This is used to customize the properties of the linear gauge to visualize the data in linear scale.\n * ```html\n * <div id=\"container\"/>\n * <script>\n *   var gaugeObj = new LinearGauge({ });\n *   gaugeObj.appendTo(\"#container\");\n * </script>\n * ```\n */\nvar LinearGauge = /** @class */ (function (_super) {\n    __extends(LinearGauge, _super);\n    /**\n     * Constructor for creating the widget\n     *\n     * @private\n     * @hidden\n     */\n    function LinearGauge(options, element) {\n        var _this = _super.call(this, options, element) || this;\n        /**\n         * Specifies the gradient count of the linear gauge.\n         *\n         * @private\n         */\n        _this.gradientCount = 0;\n        /** @private */\n        _this.isDrag = false;\n        /** @private */\n        _this.splitUpCount = 0;\n        /** @private */\n        _this.allowLoadingAnimation = false;\n        /** @private */\n        _this.isPointerAnimationInProgress = false;\n        /** @private */\n        _this.isOverAllAnimationComplete = false;\n        /** @private */\n        _this.pointerDrag = false;\n        _this.isTouchPointer = false;\n        /** @private */\n        _this.isCheckPointerDrag = false;\n        /** @private */\n        _this.mouseX = 0;\n        /** @private */\n        _this.mouseY = 0;\n        /** @private */\n        _this.gaugeResized = false;\n        return _this;\n    }\n    /**\n     * Initialize the preRender method.\n     */\n    LinearGauge.prototype.preRender = function () {\n        this.unWireEvents();\n        this.isPointerAnimationInProgress = false;\n        this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.load, { gauge: this });\n        this.initPrivateVariable();\n        this.setCulture();\n        this.createSvg();\n        this.wireEvents();\n    };\n    LinearGauge.prototype.setTheme = function () {\n        this.themeStyle = (0,_model_theme__WEBPACK_IMPORTED_MODULE_10__.getThemeStyle)(this.theme);\n    };\n    LinearGauge.prototype.initPrivateVariable = function () {\n        if (this.element.id === '') {\n            var collection = document.getElementsByClassName('e-lineargauge').length;\n            this.element.id = 'lineargauge_' + 'control_' + collection;\n        }\n        this.renderer = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_6__.SvgRenderer(this.element.id);\n        this.gaugeAxisLayoutPanel = new _axes_axis_panel__WEBPACK_IMPORTED_MODULE_5__.AxisLayoutPanel(this);\n        this.axisRenderer = new _axes_axis_renderer__WEBPACK_IMPORTED_MODULE_7__.AxisRenderer(this);\n    };\n    /**\n     * Method to set culture for chart\n     */\n    LinearGauge.prototype.setCulture = function () {\n        this.intl = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Internationalization();\n    };\n    /**\n     * Methods to create svg element\n     */\n    LinearGauge.prototype.createSvg = function () {\n        this.removeSvg();\n        this.calculateSize();\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.renderer)) {\n            this.renderer = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_6__.SvgRenderer(this.element.id);\n        }\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.gaugeAxisLayoutPanel)) {\n            this.gaugeAxisLayoutPanel = new _axes_axis_panel__WEBPACK_IMPORTED_MODULE_5__.AxisLayoutPanel(this);\n        }\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.axisRenderer)) {\n            this.axisRenderer = new _axes_axis_renderer__WEBPACK_IMPORTED_MODULE_7__.AxisRenderer(this);\n        }\n        this.svgObject = this.renderer.createSvg({\n            id: this.element.id + '_svg',\n            width: this.availableSize.width,\n            height: this.availableSize.height\n        });\n    };\n    /**\n     * To Remove the SVG.\n     *\n     * @return {boolean}\n     * @private\n     */\n    LinearGauge.prototype.removeSvg = function () {\n        (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.removeElement)(this.element.id + '_Secondary_Element');\n        if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.svgObject)) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.svgObject.parentNode)) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(this.svgObject);\n        }\n        this.clearTemplate();\n    };\n    LinearGauge.prototype.renderAnimation = function () {\n        var _this = this;\n        if (this.allowLoadingAnimation) {\n            var element = document.getElementById(this.element.id + '_RangesGroup_0');\n            this.axisElementAnimate(element);\n            if (this.styleRemove) {\n                clearTimeout(this.styleRemove);\n            }\n            this.styleRemove = setTimeout(function () {\n                var styleElement = document.querySelectorAll('style.' + _this.element.id + 'animation');\n                if (styleElement.length > 0) {\n                    styleElement[0].remove();\n                }\n            }, (this.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 1000 : this.animationDuration);\n        }\n    };\n    LinearGauge.prototype.axisElementAnimate = function (element) {\n        var _this = this;\n        var tempOpacity = 0;\n        var opacity = 1;\n        var elements = document.querySelectorAll('style.' + this.element.id + 'animation');\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n            duration: (this.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') ? 1000 : this.animationDuration > 0 ?\n                this.animationDuration / this.splitUpCount : 0,\n            progress: function (args) {\n                if (args.timeStamp > args.delay) {\n                    tempOpacity = ((args.timeStamp - args.delay) / args.duration);\n                    elements[0].style.cssText = \"opacity: \" + opacity * tempOpacity + \";\";\n                }\n            },\n            end: function () {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(elements) && elements.length !== 0) {\n                    elements[0].style.cssText = 'opacity: 1;';\n                }\n                for (var i = 0; i < _this.axes.length; i++) {\n                    _this.axisRenderer.pointerAnimation(_this.axes[i], i);\n                    if ((_this.axes.length - 1) === 0 && _this.axes[i].pointers.length === 0) {\n                        _this.isOverAllAnimationComplete = true;\n                    }\n                }\n            }\n        });\n    };\n    /**\n     * Method to calculate the size of the gauge\n     */\n    LinearGauge.prototype.calculateSize = function () {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.height)) {\n            this.element.style.height = this.height;\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.width)) {\n            this.element.style.width = this.width;\n        }\n        var width = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.stringToNumberSize)(this.width, this.element.offsetWidth) || this.element.offsetWidth || 600;\n        var height = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.stringToNumberSize)(this.height, this.element.offsetHeight) || this.element.offsetHeight || 450;\n        this.availableSize = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Size(width, height);\n    };\n    LinearGauge.prototype.renderElements = function () {\n        this.setTheme();\n        this.renderGaugeElements();\n        this.calculateBounds();\n        this.renderAxisElements();\n        this.renderAnimation();\n        this.renderComplete();\n    };\n    /**\n     * To Initialize the control rendering\n     */\n    LinearGauge.prototype.render = function () {\n        this.isPropertyChange = false;\n        this.isCheckPointerDrag = false;\n        this.allowLoadingAnimation = ((this.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') || this.animationDuration > 0)\n            && !this.isOverAllAnimationComplete;\n        if (this.allowLoadingAnimation) {\n            var styleClass = document.getElementsByClassName(this.element.id + 'animation');\n            if (styleClass.length === 0) {\n                var styleClass_1 = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('style', {\n                    className: this.element.id + 'animation'\n                });\n                styleClass_1.style.cssText = '.' + this.element.id + 'animation' + '{opacity: 0}';\n                document.body.appendChild(styleClass_1);\n            }\n        }\n        this.renderElements();\n    };\n    /**\n     * To render the gauge elements\n     *\n     * @private\n     */\n    LinearGauge.prototype.renderGaugeElements = function () {\n        this.appendSecondaryElement();\n        this.renderBorder();\n        this.renderTitle();\n        this.renderContainer();\n    };\n    LinearGauge.prototype.appendSecondaryElement = function () {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)((0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.element.id + '_Secondary_Element'))) {\n            var secondaryElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div');\n            secondaryElement.id = this.element.id + '_Secondary_Element';\n            secondaryElement.style.position = 'relative';\n            this.element.appendChild(secondaryElement);\n        }\n    };\n    /**\n     * To calculate axes bounds\n     *\n     * @private\n     */\n    LinearGauge.prototype.calculateBounds = function () {\n        this.gaugeAxisLayoutPanel.calculateAxesBounds();\n    };\n    /**\n     * To render axis elements\n     *\n     * @private\n     */\n    LinearGauge.prototype.renderAxisElements = function () {\n        this.axisRenderer.renderAxes();\n        this.element.appendChild(this.svgObject);\n        if (this.annotationsModule) {\n            this.annotationsModule.renderAnnotationElements(this);\n        }\n        if (!this.isCheckPointerDrag) {\n            this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.loaded, { gauge: this });\n        }\n        (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.removeElement)('gauge-measuretext');\n    };\n    LinearGauge.prototype.renderBorder = function () {\n        var width = this.border.width;\n        if (width > 0 || (this.background || this.themeStyle.backgroundColor)) {\n            var rect = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.RectOption(this.element.id + '_LinearGaugeBorder', this.background || this.themeStyle.backgroundColor, this.border, 1, new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Rect(width / 2, width / 2, this.availableSize.width - width, this.availableSize.height - width));\n            this.svgObject.appendChild(this.renderer.drawRectangle(rect));\n        }\n    };\n    LinearGauge.prototype.renderTitle = function () {\n        var width = (this.availableSize.width - this.margin.left - this.margin.right);\n        var style = {\n            size: this.titleStyle.size || this.themeStyle.titleFontSize,\n            color: this.titleStyle.color,\n            fontFamily: this.titleStyle.fontFamily || this.themeStyle.fontFamily,\n            fontWeight: this.titleStyle.fontWeight || this.themeStyle.titleFontWeight,\n            fontStyle: this.titleStyle.fontStyle || this.themeStyle.titleFontStyle,\n            opacity: this.titleStyle.opacity\n        };\n        var trimmedTitle = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.textTrim)(width, this.title, style);\n        var size = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.measureText)(trimmedTitle, style);\n        var options = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.TextOption(this.element.id + '_LinearGaugeTitle', this.availableSize.width / 2, this.margin.top + (size.height / 2), 'middle', trimmedTitle);\n        var titleBounds = {\n            x: options.x - (size.width / 2),\n            y: options.y,\n            width: size.width,\n            height: size.height\n        };\n        var x = this.margin.left;\n        var y = titleBounds.y;\n        var height = (this.availableSize.height - y - this.margin.bottom);\n        this.actualRect = { x: x, y: y, width: width, height: height };\n        if (this.title) {\n            var element = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.textElement)(options, style, style.color || this.themeStyle.titleFontColor, null, this.svgObject);\n            element.setAttribute('aria-label', this.description || this.title);\n            element.setAttribute('role', 'region');\n            element.setAttribute('tabindex', this.tabIndex.toString());\n        }\n    };\n    /*\n     * Method to unbind the gauge events\n     */\n    LinearGauge.prototype.unWireEvents = function () {\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.gaugeOnMouseDown);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseEnd);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.element, 'contextmenu', this.gaugeRightClick);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.element, (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer ? 'pointerleave' : 'mouseleave'), this.mouseLeave);\n        window.removeEventListener((_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeEvent);\n    };\n    /*\n     * Method to bind the gauge events\n     */\n    LinearGauge.prototype.wireEvents = function () {\n        /*! Bind the Event handler */\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.gaugeOnMouseDown, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseEnd, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.element, 'contextmenu', this.gaugeRightClick, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.element, (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer ? 'pointerleave' : 'mouseleave'), this.mouseLeave, this);\n        this.resizeEvent = this.gaugeResize.bind(this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        window, (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resizeEvent);\n        this.setStyle(this.element);\n    };\n    LinearGauge.prototype.setStyle = function (element) {\n        element.style.touchAction = 'element';\n        element.style.msTouchAction = 'element';\n        element.style.msContentZooming = 'none';\n        element.style.msUserSelect = 'none';\n        element.style.webkitUserSelect = 'none';\n        element.style.position = 'relative';\n    };\n    /**\n     * Handles the gauge resize.\n     *\n     * @return {boolean} check whether the Linear Gauge is resized or not.\n     * @private\n     */\n    LinearGauge.prototype.gaugeResize = function () {\n        var _this = this;\n        if (!this.isDestroyed) {\n            var args = {\n                gauge: this,\n                previousSize: new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Size(this.availableSize.width, this.availableSize.height),\n                name: _model_constant__WEBPACK_IMPORTED_MODULE_3__.resized,\n                currentSize: new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Size(0, 0),\n                cancel: false\n            };\n            var currentSize = this.element.getBoundingClientRect();\n            args.currentSize = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Size(currentSize.width, currentSize.height);\n            this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.resized, args);\n            if (!args.cancel) {\n                if (this.resizeTo) {\n                    clearTimeout(this.resizeTo);\n                }\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.element) && this.element.classList.contains('e-lineargauge')) {\n                    this.resizeTo = window.setTimeout(function () {\n                        _this.gaugeResized = true;\n                        _this.createSvg();\n                        _this.allowLoadingAnimation = false;\n                        _this.renderElements();\n                    }, 500);\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * This method destroys the linear gauge. This method removes the events associated with the linear gauge and disposes the objects created for rendering and updating the linear gauge.\n     */\n    LinearGauge.prototype.destroy = function () {\n        this.unWireEvents();\n        _super.prototype.destroy.call(this);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.gaugeAxisLayoutPanel)) {\n            this.gaugeAxisLayoutPanel.destroy();\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.axisRenderer)) {\n            this.axisRenderer.destroy();\n        }\n        this.gaugeAxisLayoutPanel = null;\n        this.axisRenderer = null;\n        this.activePointer = null;\n        this.activeAxis = null;\n        this.actualRect = null;\n        this.containerObject = null;\n        this.containerBounds = null;\n        this.availableSize = null;\n        this.mouseElement = null;\n        this.nearSizes = [];\n        this.farSizes = [];\n        this.themeStyle = null;\n        this.intl = null;\n        this.removeSvg();\n        this.resizeEvent = null;\n        this.svgObject = null;\n        this.renderer = null;\n    };\n    /**\n     * To render the gauge container\n     *\n     * @private\n     */\n    LinearGauge.prototype.renderContainer = function () {\n        var width;\n        var height;\n        var x;\n        var y;\n        var options;\n        var labelPadding = 20;\n        var extraPadding = 30;\n        var path = '';\n        var fill = (this.container.backgroundColor !== 'transparent'\n            || (this.theme !== 'Bootstrap4' && this.theme !== 'Material' && this.theme !== 'Material3' && this.theme !== 'Material3Dark'\n                && this.theme !== 'Fluent2' && this.theme !== 'Fluent2Dark' && this.theme !== 'Bootstrap5' && this.theme !== 'Bootstrap5Dark'\n                && this.theme !== 'Tailwind' && this.theme !== 'TailwindDark' && this.theme !== 'Tailwind3' && this.theme !== 'Tailwind3Dark'))\n            ? this.container.backgroundColor : this.themeStyle.containerBackground;\n        var rect;\n        var radius = this.container.width;\n        var bottomRadius = radius + ((radius / 2) / Math.PI);\n        var topRadius = radius / 2;\n        var allowContainerRender = false;\n        for (var i = 0; i < this.axes.length; i++) {\n            if (this.axes[i].minimum !== this.axes[i].maximum) {\n                allowContainerRender = true;\n                break;\n            }\n        }\n        if (this.orientation === 'Vertical') {\n            if (this.allowMargin) {\n                height = this.actualRect.height;\n                height = (this.container.height > 0) ? this.container.height :\n                    ((height / 2) - ((height / 2) / 4)) * 2;\n                height = (this.container.type === 'Thermometer') ? height - (bottomRadius * 2) - topRadius : height;\n            }\n            else {\n                height = this.actualRect.height - labelPadding - extraPadding;\n                height = (this.container.type === 'Thermometer') ? (radius !== 0) ? (this.actualRect.height - (bottomRadius * 2) - topRadius - extraPadding) : height : height;\n            }\n            width = this.container.width;\n            x = (this.actualRect.x + ((this.actualRect.width / 2) - (this.container.width / 2))) + this.container.offset;\n            y = this.actualRect.y + ((this.actualRect.height / 2) - ((this.container.type === 'Thermometer') ?\n                ((height + (bottomRadius * 2) - topRadius)) / 2 : height / 2));\n        }\n        else {\n            if (this.allowMargin) {\n                width = (this.container.height > 0) ? this.container.height :\n                    ((this.actualRect.width / 2) - ((this.actualRect.width / 2) / 4)) * 2;\n                width = (this.container.type === 'Thermometer') ? width - (bottomRadius * 2) - topRadius : width;\n            }\n            else {\n                width = this.actualRect.width - labelPadding;\n                width = (this.container.type === 'Thermometer') ? (this.actualRect.width - (bottomRadius * 2) - topRadius) : width;\n            }\n            x = this.actualRect.x + ((this.actualRect.width / 2) - ((this.container.type === 'Thermometer') ?\n                (width - (bottomRadius * 2) + topRadius) / 2 : width / 2));\n            y = (this.actualRect.y + ((this.actualRect.height / 2) - (this.container.width / 2))) + this.container.offset;\n            height = this.container.width;\n        }\n        this.containerBounds = (!allowContainerRender) ? { x: 0, y: 0, width: 0, height: 0 } : { x: x, y: y, width: width, height: height };\n        if ((this.containerBounds.width > 0 && this.orientation === 'Vertical') || (this.containerBounds.height > 0 && this.orientation === 'Horizontal')) {\n            this.containerObject = this.renderer.createGroup({ id: this.element.id + '_Container_Group', transform: 'translate( 0, 0)' });\n            if (this.container.type === 'Normal') {\n                var containerBorder = { color: this.container.border.color || this.themeStyle.containerBorderColor,\n                    width: this.container.border.width, dashArray: this.container.border.dashArray };\n                rect = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.RectOption(this.element.id + '_' + this.container.type + '_Layout', fill, containerBorder, 1, new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Rect(x, y, width, height));\n                this.containerObject.appendChild(this.renderer.drawRectangle(rect));\n                if (this.allowLoadingAnimation) {\n                    this.containerObject.classList.add(this.element.id + 'animation');\n                }\n            }\n            else {\n                path = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getBox)(this.containerBounds, this.container.type, this.orientation, new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Size(this.container.height, this.container.width), 'container', null, null, this.container.roundedCornerRadius);\n                options = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.PathOption(this.element.id + '_' + this.container.type + '_Layout', fill, this.container.border.width, this.container.border.color || this.themeStyle.containerBorderColor, 1, this.container.border.dashArray, path);\n                this.containerObject.appendChild(this.renderer.drawPath(options));\n                if (this.allowLoadingAnimation) {\n                    this.containerObject.classList.add(this.element.id + 'animation');\n                }\n            }\n            this.svgObject.appendChild(this.containerObject);\n        }\n    };\n    /**\n     * Method to set mouse x, y from events\n     */\n    LinearGauge.prototype.setMouseXY = function (e) {\n        var pageX;\n        var pageY;\n        var svgRect = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.element.id + '_svg').getBoundingClientRect();\n        var rect = this.element.getBoundingClientRect();\n        if (e.type.indexOf('touch') > -1) {\n            this.isTouch = true;\n            var touchArg = e;\n            pageY = touchArg.changedTouches[0].clientY;\n            pageX = touchArg.changedTouches[0].clientX;\n        }\n        else {\n            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2';\n            pageX = e.clientX;\n            pageY = e.clientY;\n        }\n        this.mouseY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);\n        this.mouseX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);\n    };\n    /**\n     * Handles the mouse down on gauge.\n     *\n     * @param {PointerEvent} e - Specifies the event argument.\n     * @return {boolean}\n     * @private\n     */\n    LinearGauge.prototype.gaugeOnMouseDown = function (e) {\n        var _this = this;\n        var current;\n        var currentPointer;\n        this.setMouseXY(e);\n        var args = this.getMouseArgs(e, 'touchstart', _model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseDown);\n        this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseDown, args, function () {\n            _this.mouseX = args.x;\n            _this.mouseY = args.y;\n            if (_this.isTouch) {\n                e.preventDefault();\n                _this.isTouchPointer = true;\n            }\n            if (args.target) {\n                if (!args.cancel && ((args.target.id.indexOf('MarkerPointer') > -1) || (args.target.id.indexOf('BarPointer') > -1))) {\n                    _this.isOverAllAnimationComplete = true;\n                    current = _this.moveOnPointer(args.target);\n                    currentPointer = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getPointer)(args.target, _this);\n                    _this.activeAxis = _this.axes[currentPointer.axisIndex];\n                    _this.activePointer = _this.activeAxis.pointers[currentPointer.pointerIndex];\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(_this.activePointer.pathElement)) {\n                        _this.activePointer.pathElement = [e.target];\n                    }\n                    var pointInd = parseInt(_this.activePointer.pathElement[0].id.slice(-1), 10);\n                    var axisInd = parseInt(_this.activePointer.pathElement[0].id.match(/\\d/g)[0], 10);\n                    if (currentPointer.pointer.enableDrag) {\n                        _this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.dragStart, {\n                            axis: _this.activeAxis,\n                            name: _model_constant__WEBPACK_IMPORTED_MODULE_3__.dragStart,\n                            pointer: _this.activePointer,\n                            currentValue: _this.activePointer.currentValue,\n                            pointerIndex: pointInd,\n                            axisIndex: axisInd\n                        });\n                    }\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(current) && current.pointer) {\n                        _this.pointerDrag = true;\n                        _this.mouseElement = args.target;\n                    }\n                }\n            }\n        });\n        return false;\n    };\n    /**\n     * Handles the mouse move.\n     *\n     * @return {boolean}\n     * @private\n     */\n    LinearGauge.prototype.mouseMove = function (e) {\n        var _this = this;\n        var current;\n        this.setMouseXY(e);\n        var args = this.getMouseArgs(e, 'touchmove', _model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseMove);\n        this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseMove, args, function () {\n            _this.mouseX = args.x;\n            _this.mouseY = args.y;\n            var dragArgs;\n            if (args.target && !args.cancel) {\n                if (_this.pointerDrag && _this.activePointer) {\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(_this.activePointer.pathElement)) {\n                        if (_this.isTouch) {\n                            _this.isTouchPointer = true;\n                            e.preventDefault();\n                        }\n                        var pointerIndex = parseInt(_this.activePointer.pathElement[0].id.slice(-1), 10);\n                        var axisIndex = parseInt(_this.activePointer.pathElement[0].id.split('AxisIndex_')[1].match(/\\d/g)[0], 10);\n                        if (_this.axes[axisIndex].pointers[pointerIndex].enableDrag) {\n                            current = _this.moveOnPointer(_this.activePointer.pathElement[0]);\n                            if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(current)) && current.pointer) {\n                                _this.element.style.cursor = current.style;\n                            }\n                            _this.isDrag = _this.isCheckPointerDrag = true;\n                            dragArgs = {\n                                axis: _this.activeAxis,\n                                pointer: _this.activePointer,\n                                previousValue: _this.activePointer.currentValue,\n                                name: _model_constant__WEBPACK_IMPORTED_MODULE_3__.dragMove,\n                                currentValue: null,\n                                axisIndex: axisIndex,\n                                pointerIndex: pointerIndex\n                            };\n                            if (_this.activePointer.pathElement[0].id.indexOf('MarkerPointer') > -1) {\n                                _this.markerDrag(_this.activeAxis, (_this.activeAxis.pointers[pointerIndex]));\n                            }\n                            else {\n                                _this.barDrag(_this.activeAxis, (_this.activeAxis.pointers[pointerIndex]));\n                            }\n                            dragArgs.currentValue = _this.activePointer.currentValue;\n                            _this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.dragMove, dragArgs);\n                        }\n                    }\n                }\n                else {\n                    if (args.target.id.indexOf('Pointer') > -1 && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(_this.activePointer)) {\n                        var pointerIndex = parseInt(args.target.id.split('Pointer_')[1], 10);\n                        var axisIndex = parseInt(args.target.id.split('AxisIndex_')[1].match(/\\d/g)[0], 10);\n                        if (_this.axes[axisIndex].pointers[pointerIndex].enableDrag) {\n                            _this.element.style.cursor = 'pointer';\n                        }\n                    }\n                    else {\n                        _this.element.style.cursor = (_this.pointerDrag) ? _this.element.style.cursor : 'auto';\n                    }\n                }\n                _this.gaugeOnMouseMove();\n            }\n        });\n        this.notify(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, e);\n        if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(args.target) && args.target.id === (this.element.id + '_LinearGaugeTitle')) || document.getElementById(this.element.id + '_EJ2_Title_Tooltip')) {\n            this.titleTooltip(e, false);\n        }\n        return false;\n    };\n    LinearGauge.prototype.titleTooltip = function (event, isTitleTouch) {\n        var targetId = event.target.id;\n        if ((targetId === (this.element.id + '_LinearGaugeTitle')) && (event.target.textContent.indexOf('...') > -1)) {\n            clearTimeout(this.tooltipTimeout);\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.showTooltip)(this.title, this);\n            if (isTitleTouch) {\n                this.tooltipTimeout = setTimeout(_utils_helper__WEBPACK_IMPORTED_MODULE_4__.removeTooltip.bind(this), 2000);\n            }\n        }\n        else {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.removeElement)(this.element.id + '_EJ2_Title_Tooltip');\n        }\n    };\n    /**\n     * To find the mouse move on pointer.\n     *\n     * @param element\n     */\n    LinearGauge.prototype.moveOnPointer = function (element) {\n        var clientRect = this.element.getBoundingClientRect();\n        var isPointer = false;\n        var top;\n        var left;\n        var pointerElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(element.id);\n        var svgPath = pointerElement;\n        var cursorStyle;\n        var process;\n        var current = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getPointer)(element, this);\n        var axis = current.axis;\n        var pointer = current.pointer;\n        if (pointer.enableDrag) {\n            if (pointer.type === 'Bar') {\n                if (this.orientation === 'Vertical') {\n                    top = pointerElement.getBoundingClientRect().top - clientRect.top;\n                    top = (!axis.isInversed) ? top : top + svgPath.getBBox().height;\n                    isPointer = !axis.isInversed ? (this.mouseY < (top + 10) && this.mouseY >= top) :\n                        (this.mouseY <= top && this.mouseY > (top - 10));\n                    cursorStyle = 'grabbing';\n                }\n                else {\n                    left = pointerElement.getBoundingClientRect().left - clientRect.left;\n                    left = (!axis.isInversed) ? left + svgPath.getBBox().width : left;\n                    isPointer = !axis.isInversed ? (this.mouseX > (left - 10) && this.mouseX <= left) :\n                        (this.mouseX >= left && this.mouseX < (left + 10));\n                    cursorStyle = 'grabbing';\n                }\n            }\n            else {\n                isPointer = true;\n                cursorStyle = 'grabbing';\n            }\n        }\n        if (isPointer) {\n            process = { pointer: isPointer, style: cursorStyle };\n        }\n        return process;\n    };\n    /**\n     * Handle the right click\n     *\n     * @param {PointerEvent | TouchEvent} event - Specifies the pointer event argument.\n     * @returns {boolean} - Specifies whether right click is performed on the Linear Gauge.\n     * @private\n     *\n     */\n    LinearGauge.prototype.gaugeRightClick = function (event) {\n        if (event.buttons === 2 || event.pointerType === 'touch') {\n            event.preventDefault();\n            event.stopPropagation();\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Handles the mouse leave.\n     *\n     * @return {boolean}\n     * @private\n     */\n    LinearGauge.prototype.mouseLeave = function (e) {\n        this.activeAxis = null;\n        this.activePointer = null;\n        var args = this.getMouseArgs(e, 'touchmove', _model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseLeave);\n        this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseLeave, args);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.mouseElement)) {\n            this.mouseElement = null;\n            this.pointerDrag = false;\n        }\n        return false;\n    };\n    /**\n     * Handles the mouse move on gauge.\n     *\n     * @param {PointerEvent | TouchEvent} e - Specifies the pointer event argument.\n     * @return {boolean}\n     * @private\n     */\n    LinearGauge.prototype.gaugeOnMouseMove = function () {\n        var current;\n        if (this.pointerDrag) {\n            current = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getPointer)(this.mouseElement, this);\n            if (current.pointer.enableDrag && current.pointer.animationComplete) {\n                this[current.pointer.type.toLowerCase() + 'Drag'](current.axis, current.pointer);\n            }\n        }\n        return true;\n    };\n    /**\n     * Handles the mouse up.\n     *\n     * @return {boolean}\n     * @private\n     */\n    LinearGauge.prototype.mouseEnd = function (e) {\n        this.isTouchPointer = false;\n        this.setMouseXY(e);\n        var isImage = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.activePointer) ? false : this.activePointer.markerType === 'Image';\n        var args = this.getMouseArgs(e, 'touchend', _model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseUp);\n        this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.gaugeMouseUp, args);\n        if (this.activeAxis && this.activePointer) {\n            var pointerInd = parseInt(this.activePointer.pathElement[0].id.slice(-1), 10);\n            var axisInd = parseInt(this.activePointer.pathElement[0].id.split('_AxisIndex_')[1], 10);\n            if (this.activePointer.enableDrag) {\n                this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.dragEnd, {\n                    name: _model_constant__WEBPACK_IMPORTED_MODULE_3__.dragEnd,\n                    axis: this.activeAxis,\n                    pointer: this.activePointer,\n                    currentValue: this.activePointer.currentValue,\n                    axisIndex: axisInd,\n                    pointerIndex: pointerInd\n                });\n                this.axes[axisInd].pointers[pointerInd].value = this.activePointer.currentValue;\n                this.activeAxis = null;\n                this.activePointer = null;\n                this.isDrag = false;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.mouseElement && !isImage)) {\n                    this.triggerDragEvent(this.mouseElement);\n                }\n            }\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.mouseElement)) {\n            this.mouseElement = null;\n            this.pointerDrag = false;\n        }\n        this.element.style.cursor = 'auto';\n        this.notify(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, e);\n        if (args.target.id === (this.element.id + '_LinearGaugeTitle') || document.getElementById(this.element.id + '_EJ2_Title_Tooltip')) {\n            this.titleTooltip(e, true);\n        }\n        return true;\n    };\n    /**\n     * This method handles the print functionality for linear gauge.\n     *\n     * @param id - Specifies the element to print the linear gauge.\n     */\n    LinearGauge.prototype.print = function (id) {\n        if ((this.allowPrint) && (this.printModule)) {\n            this.printModule.print(this, id);\n        }\n    };\n    /**\n     * This method handles the export functionality for linear gauge.\n     *\n     * @param {ExportType} type - Specifies the extension type of the exported document.\n     * @param {string} fileName - Specifies file name for exporting the rendered Linear Gauge.\n     * @param {PdfPageOrientation} orientation - Specifies the orientation of the PDF document.\n     * @param {boolean} allowDownload - Specifies whether the exported file should be downloaded or not.\n     * @returns {string} - Specifies the base64 string of the exported image which is returned when the allowDownload is set to false.\n     */\n    LinearGauge.prototype.export = function (type, fileName, orientation, allowDownload) {\n        var _this = this;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(allowDownload)) {\n            allowDownload = true;\n        }\n        if ((type !== 'PDF') && (this.allowImageExport) && (this.imageExportModule)) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n            return new Promise(function (resolve, reject) {\n                resolve(_this.imageExportModule.export(_this, type, fileName, allowDownload));\n            });\n        }\n        else if ((this.allowPdfExport) && (this.pdfExportModule)) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n            return new Promise(function (resolve, reject) {\n                resolve(_this.pdfExportModule.export(_this, type, fileName, orientation, allowDownload));\n            });\n        }\n        return null;\n    };\n    /**\n     * Handles the mouse event arguments.\n     *\n     * @return {IMouseEventArgs}\n     * @private\n     */\n    LinearGauge.prototype.getMouseArgs = function (e, type, name) {\n        var rect = this.element.getBoundingClientRect();\n        var location = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.GaugeLocation(-rect.left, -rect.top);\n        var isTouch = (e.type === type);\n        location.x += isTouch ? e.changedTouches[0].clientX : e.clientX;\n        location.y += isTouch ? e.changedTouches[0].clientY : e.clientY;\n        return {\n            cancel: false, name: name,\n            model: this,\n            x: location.x, y: location.y,\n            target: isTouch ? e.target : e.target\n        };\n    };\n    /**\n     * @private\n     * @param axis\n     * @param pointer\n     */\n    LinearGauge.prototype.markerDrag = function (axis, pointer) {\n        var options;\n        var textOptions;\n        var x;\n        var y;\n        var value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.convertPixelToValue)(this.element, this.mouseElement, this.orientation, axis, 'drag', new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.GaugeLocation(this.mouseX, this.mouseY));\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.withInRange)(value, null, null, axis.visibleRange.max, axis.visibleRange.min, 'pointer')) {\n            options = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.PathOption('pointerID', pointer.color || this.themeStyle.pointerColor, pointer.border.width, pointer.border.color, pointer.opacity, pointer.border.dashArray, null, '');\n            if (this.orientation === 'Vertical') {\n                pointer.bounds.y = this.mouseY;\n            }\n            else {\n                pointer.bounds.x = this.mouseX + (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getExtraWidth)(this.element);\n            }\n            pointer.currentValue = this.isTouch ? (pointer.startValue = value) : (pointer.value = value);\n            if (pointer.markerType === 'Text') {\n                textOptions = new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.TextOption('pointerID', x, y, 'middle', pointer.text, null, 'auto');\n                textOptions = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.calculateTextPosition)(pointer.bounds, pointer.markerType, textOptions, this.orientation, axis, pointer);\n            }\n            options = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.calculateShapes)(pointer.bounds, pointer.markerType, new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Size(pointer.width, pointer.height), pointer.imageUrl, options, this.orientation, axis, pointer);\n            if (pointer.markerType === 'Image' || pointer.markerType === 'Text') {\n                this.mouseElement.setAttribute('x', (pointer.markerType === 'Text' ? textOptions.x : pointer.bounds.x - (pointer.bounds.width / 2)).toString());\n                this.mouseElement.setAttribute('y', (pointer.markerType === 'Text' ? textOptions.y : pointer.bounds.y - (pointer.bounds.height / 2)).toString());\n            }\n            else if (pointer.markerType === 'Circle') {\n                this.mouseElement.setAttribute('cx', (options.cx).toString());\n                this.mouseElement.setAttribute('cy', (options.cy).toString());\n                this.mouseElement.setAttribute('r', (options.r).toString());\n            }\n            else {\n                this.mouseElement.setAttribute('d', options.d);\n            }\n        }\n    };\n    /**\n     * @private\n     * @param axis\n     * @param pointer\n     */\n    LinearGauge.prototype.barDrag = function (axis, pointer) {\n        var line = axis.lineBounds;\n        var range = axis.visibleRange;\n        var isDrag;\n        var lineHeight = (this.orientation === 'Vertical') ? line.height : line.width;\n        var lineY = (this.orientation === 'Vertical') ? line.y : line.x;\n        var path;\n        var value1 = (((0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.valueToCoefficient)(range.min, axis, this.orientation, range) * lineHeight) + lineY);\n        var value2 = (((0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.valueToCoefficient)(range.max, axis, this.orientation, range) * lineHeight) + lineY);\n        if (this.orientation === 'Vertical') {\n            isDrag = (!axis.isInversed) ? (this.mouseY > value2 && this.mouseY < value1) : (this.mouseY > value1 && this.mouseY < value2);\n            if (isDrag) {\n                if ((this.container.type === 'Normal' || this.container.width === 0) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.mouseElement)) {\n                    if (!axis.isInversed) {\n                        this.mouseElement.setAttribute('y', this.mouseY.toString());\n                    }\n                    this.mouseElement.setAttribute('height', Math.abs(value1 - this.mouseY).toString());\n                }\n                else {\n                    if (!axis.isInversed) {\n                        pointer.bounds.y = this.mouseY;\n                    }\n                    pointer.bounds.height = Math.abs(value1 - this.mouseY);\n                }\n            }\n        }\n        else {\n            var extraWidth = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getExtraWidth)(this.element);\n            isDrag = (!axis.isInversed) ? (this.mouseX + extraWidth > value1 && this.mouseX + extraWidth < value2) :\n                (this.mouseX + extraWidth > value2 && this.mouseX + extraWidth < value1);\n            if (isDrag) {\n                if ((this.container.type === 'Normal' || this.container.width === 0) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.mouseElement)) {\n                    if (axis.isInversed) {\n                        this.mouseElement.setAttribute('x', (this.mouseX + extraWidth).toString());\n                    }\n                    this.mouseElement.setAttribute('width', Math.abs(value1 - (this.mouseX + extraWidth)).toString());\n                }\n                else {\n                    if (axis.isInversed) {\n                        pointer.bounds.x = this.mouseX + extraWidth;\n                    }\n                    pointer.bounds.width = Math.abs(value1 - (this.mouseX + extraWidth));\n                }\n            }\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.mouseElement)) {\n            var value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.convertPixelToValue)(this.element, this.mouseElement, this.orientation, axis, 'drag', new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.GaugeLocation(this.mouseX, this.mouseY));\n            pointer.currentValue = this.isTouch ? (pointer.startValue = value) : (pointer.value = value);\n        }\n        if (isDrag && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.mouseElement) && this.mouseElement.tagName === 'path') {\n            path = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getBox)(pointer.bounds, this.container.type, this.orientation, new _utils_helper__WEBPACK_IMPORTED_MODULE_4__.Size(pointer.bounds.width, pointer.bounds.height), 'bar', this.container.width, axis, pointer.roundedCornerRadius);\n            this.mouseElement.setAttribute('d', path);\n        }\n    };\n    /**\n     * Triggers when drag the pointer\n     *\n     * @param activeElement\n     */\n    LinearGauge.prototype.triggerDragEvent = function (activeElement) {\n        var _this = this;\n        var active = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getPointer)(activeElement, this);\n        var value = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.convertPixelToValue)(this.element, activeElement, this.orientation, active.axis, 'tooltip', null);\n        var dragArgs = {\n            name: 'valueChange',\n            gauge: this,\n            element: activeElement,\n            axisIndex: active.axisIndex,\n            axis: active.axis,\n            pointerIndex: active.pointerIndex,\n            pointer: active.pointer,\n            value: value\n        };\n        this.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_3__.valueChange, dragArgs, function (pointerArgs) {\n            if (value !== pointerArgs.value) {\n                _this.setPointerValue(pointerArgs.axisIndex, pointerArgs.pointerIndex, pointerArgs.value);\n            }\n        });\n    };\n    /**\n     * This method is used to set the pointer value in the linear gauge.\n     *\n     * @param {number} axisIndex - Specifies the index of the axis.\n     * @param {number} pointerIndex - Specifies the index of the pointer.\n     * @param {number} value - Specifies the pointer value.\n     */\n    LinearGauge.prototype.setPointerValue = function (axisIndex, pointerIndex, value) {\n        if (!this.isDestroyed) {\n            var axis = this.axes[axisIndex];\n            var pointer = axis.pointers[pointerIndex];\n            this.gaugeResized = false;\n            if (this.allowLoadingAnimation) {\n                this.allowLoadingAnimation = false;\n                this.createSvg();\n                this.renderGaugeElements();\n                this.calculateBounds();\n                this.renderAxisElements();\n            }\n            if (pointer.startValue !== value) {\n                this.isPointerAnimationInProgress = false;\n                var id = this.element.id + '_AxisIndex_' + axisIndex + '_' + pointer.type + 'Pointer_' + pointerIndex;\n                var pointerElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(id);\n                value = (value < axis.visibleRange.min) ? axis.visibleRange.min : ((value > axis.visibleRange.max) ?\n                    axis.visibleRange.max : value);\n                pointer.currentValue = value;\n                pointer.isPointerAnimation = true;\n                this.isPropertyChange = true;\n                if ((pointerElement !== null) && (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.withInRange)(pointer.currentValue, null, null, axis.visibleRange.max, axis.visibleRange.min, 'pointer')) {\n                    pointer.value = this.pointerDrag ? this.isTouch ? pointer.startValue : value : pointer.value;\n                    this.gaugeAxisLayoutPanel['calculate' + pointer.type + 'Bounds'](axis, pointer);\n                    this.axisRenderer['draw' + pointer.type + 'Pointer'](axis, axisIndex, pointer, pointerIndex, pointerElement.parentElement);\n                }\n                this.isProtectedOnChange = true;\n                pointer.startValue = pointer.currentValue;\n                pointer.currentValue = value;\n                pointer.value = value;\n                this.isProtectedOnChange = false;\n            }\n        }\n    };\n    /**\n     * This method is used to set the annotation value in the linear gauge.\n     *\n     * @param {number} annotationIndex - Specifies the index value for the annotation in linear gauge.\n     * @param {string | Function} content - Specifies the content for the annotation in linear gauge.\n     * @param {number} axisValue - Specifies the axis value to which the annotation must be positioned.\n     */\n    LinearGauge.prototype.setAnnotationValue = function (annotationIndex, content, axisValue) {\n        if (!this.isDestroyed) {\n            var elementExist = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.element.id + '_Annotation_' + annotationIndex) === null;\n            var element = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.element.id + '_AnnotationsGroup') ||\n                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n                    id: this.element.id + '_AnnotationsGroup'\n                });\n            var annotation = this.annotations[annotationIndex];\n            if (content !== null) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.removeElement)(this.element.id + '_Annotation_' + annotationIndex);\n                annotation.content = content;\n                annotation.axisValue = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axisValue) ? axisValue : annotation.axisValue;\n                this.annotationsModule.createAnnotationTemplate(element, annotationIndex, this);\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(annotation.axisIndex)) {\n                    var axis = this.axes[annotation.axisIndex];\n                    var range = axis.visibleRange;\n                    var annotationElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.element.id + '_Annotation_' + annotationIndex);\n                    if (!elementExist && annotation.axisValue >= range.min && annotation.axisValue <= range.max\n                        && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(annotationElement) && typeof (annotationElement) === 'object') {\n                        element.appendChild(annotationElement);\n                    }\n                }\n                else if (!elementExist) {\n                    var annotationElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_4__.getElement)(this.element.id + '_Annotation_' + annotationIndex);\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(annotationElement) && typeof (annotationElement) === 'object') {\n                        element.appendChild(annotationElement);\n                    }\n                }\n            }\n        }\n    };\n    LinearGauge.prototype.isGradientVisible = function () {\n        var isVisible = false;\n        for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            for (var _b = 0, _c = axis.pointers; _b < _c.length; _b++) {\n                var pointer = _c[_b];\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointer.linearGradient) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointer.radialGradient)) {\n                    isVisible = true;\n                    break;\n                }\n            }\n            for (var _d = 0, _e = axis.ranges; _d < _e.length; _d++) {\n                var range = _e[_d];\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(range.linearGradient) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(range.radialGradient)) {\n                    isVisible = true;\n                    break;\n                }\n            }\n        }\n        return isVisible;\n    };\n    /**\n     * To provide the array of modules needed for control rendering\n     *\n     * @return {ModuleDeclaration[]}\n     * @private\n     */\n    LinearGauge.prototype.requiredModules = function () {\n        var modules = [];\n        var annotationEnable = false;\n        this.annotations.map(function (annotation) {\n            if (!annotationEnable) {\n                annotationEnable = ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(annotation.content) && annotation.content.length !== 0) || typeof (annotation.content) === 'function');\n            }\n        });\n        if (annotationEnable) {\n            modules.push({\n                member: 'Annotations',\n                args: [this, _annotations_annotations__WEBPACK_IMPORTED_MODULE_8__.Annotations],\n                name: 'Annotations'\n            });\n        }\n        if (this.tooltip.enable) {\n            modules.push({\n                member: 'Tooltip',\n                args: [this, _user_interaction_tooltip__WEBPACK_IMPORTED_MODULE_9__.GaugeTooltip],\n                name: 'GaugeTooltip'\n            });\n        }\n        if (this.allowPrint) {\n            modules.push({\n                member: 'Print',\n                args: [this],\n                name: 'Print'\n            });\n        }\n        if (this.allowImageExport) {\n            modules.push({\n                member: 'ImageExport',\n                args: [this],\n                name: 'ImageExport'\n            });\n        }\n        if (this.allowPdfExport) {\n            modules.push({\n                member: 'PdfExport',\n                args: [this],\n                name: 'PdfExport'\n            });\n        }\n        if (this.isGradientVisible()) {\n            modules.push({\n                member: 'Gradient',\n                args: [this, _axes_gradient__WEBPACK_IMPORTED_MODULE_11__.Gradient],\n                name: 'Gradient'\n            });\n        }\n        return modules;\n    };\n    /**\n     * Get the properties to be maintained in the persisted state.\n     *\n     * @private\n     */\n    LinearGauge.prototype.getPersistData = function () {\n        var keyEntity = ['loaded'];\n        return this.addOnPersist(keyEntity);\n    };\n    /**\n     * Get component name\n     *\n     * @private\n     */\n    LinearGauge.prototype.getModuleName = function () {\n        return 'lineargauge';\n    };\n    /**\n     * Called internally if any of the property value changed.\n     *\n     * @private\n     */\n    LinearGauge.prototype.onPropertyChanged = function (newProp, oldProp) {\n        if (!this.isDestroyed) {\n            var renderer = false;\n            var refreshBounds = false;\n            this.allowLoadingAnimation = this.animationDuration > 0 && !this.isOverAllAnimationComplete ? true : false;\n            this.isPropertyChange = this.animationDuration > 0 && !this.isOverAllAnimationComplete ? false : true;\n            this.gaugeResized = false;\n            for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n                var prop = _a[_i];\n                switch (prop) {\n                    case 'height':\n                    case 'width':\n                    case 'margin':\n                        this.createSvg();\n                        refreshBounds = true;\n                        break;\n                    case 'title':\n                        refreshBounds = (newProp.title === '' || oldProp.title === '');\n                        renderer = !(newProp.title === '' || oldProp.title === '');\n                        break;\n                    case 'titleStyle':\n                        if (newProp.titleStyle && newProp.titleStyle.size) {\n                            refreshBounds = true;\n                        }\n                        else {\n                            renderer = true;\n                        }\n                        break;\n                    case 'border':\n                        renderer = true;\n                        break;\n                    case 'background':\n                        renderer = true;\n                        break;\n                    case 'container':\n                        refreshBounds = true;\n                        break;\n                    case 'orientation':\n                        this.isOverAllAnimationComplete = true;\n                        this.isPointerAnimationInProgress = this.allowLoadingAnimation = false;\n                        for (var i = 0; i < this.axes.length; i++) {\n                            for (var j = 0; j < this.axes[i].pointers.length; j++) {\n                                this.axes[i].pointers[j]['startValue'] = this.axes[i].minimum;\n                                this.axes[i].pointers[j]['isPointerAnimation'] = true;\n                            }\n                        }\n                        refreshBounds = true;\n                        break;\n                    case 'axes':\n                        for (var x = 0; x < this.axes.length; x++) {\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(newProp.axes[x])) {\n                                var collection = Object.keys(newProp.axes[x]);\n                                for (var _b = 0, collection_1 = collection; _b < collection_1.length; _b++) {\n                                    var collectionProp = collection_1[_b];\n                                    if (collectionProp === 'pointers') {\n                                        var pointerPropertyLength = Object.keys(newProp.axes[x].pointers).length;\n                                        for (var y = 0; y < pointerPropertyLength; y++) {\n                                            var index = parseInt(Object.keys(newProp.axes[x].pointers)[y], 10);\n                                            if (!isNaN(index) &&\n                                                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(Object.keys(newProp.axes[x].pointers[index]))) {\n                                                this.allowLoadingAnimation = false;\n                                                this.isPointerAnimationInProgress = false;\n                                                this.axes[x].pointers[index]['startValue'] = this.axes[x].pointers[index]['currentValue'];\n                                                this.axes[x].pointers[index]['isPointerAnimation'] = Object.keys(newProp.axes[x].pointers[index]).indexOf('value') > -1;\n                                                if (this.pointerDrag) {\n                                                    this.axes[x].pointers[index]['isPointerAnimation'] = false;\n                                                    if (this.isTouchPointer &&\n                                                        newProp.axes[x].pointers[index].text\n                                                            !== oldProp.axes[x].pointers[index].text) {\n                                                        var currentPointer = this.axes[x].pointers[index];\n                                                        var pointerId = this.element.id + '_AxisIndex_' + x + '_' + currentPointer.type + 'Pointer' + '_' + index;\n                                                        this.axisRenderer.updateTextPointer(pointerId, currentPointer, this.axes[x]);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        refreshBounds = true;\n                        break;\n                }\n            }\n            if (!this.isTouchPointer && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.activePointer)) {\n                if (!refreshBounds && renderer) {\n                    this.removeSvg();\n                    this.renderGaugeElements();\n                    this.renderAxisElements();\n                }\n                if (refreshBounds || this.allowLoadingAnimation) {\n                    this.createSvg();\n                    this.renderGaugeElements();\n                    this.calculateBounds();\n                    this.renderAxisElements();\n                    if (this.allowLoadingAnimation) {\n                        this.allowLoadingAnimation = this.animationDuration > 0 && !this.isOverAllAnimationComplete ? true : false;\n                        this.renderAnimation();\n                    }\n                }\n            }\n        }\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], LinearGauge.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], LinearGauge.prototype, \"allowMargin\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], LinearGauge.prototype, \"height\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], LinearGauge.prototype, \"animationDuration\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Vertical')\n    ], LinearGauge.prototype, \"orientation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('None')\n    ], LinearGauge.prototype, \"edgeLabelPlacement\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], LinearGauge.prototype, \"allowPrint\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], LinearGauge.prototype, \"allowImageExport\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], LinearGauge.prototype, \"allowPdfExport\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _model_base__WEBPACK_IMPORTED_MODULE_1__.Margin)\n    ], LinearGauge.prototype, \"margin\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ color: '', width: 0 }, _model_base__WEBPACK_IMPORTED_MODULE_1__.Border)\n    ], LinearGauge.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], LinearGauge.prototype, \"background\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], LinearGauge.prototype, \"title\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ size: null, color: null, fontFamily: null, fontStyle: null, fontWeight: null }, _model_base__WEBPACK_IMPORTED_MODULE_1__.Font)\n    ], LinearGauge.prototype, \"titleStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _model_base__WEBPACK_IMPORTED_MODULE_1__.Container)\n    ], LinearGauge.prototype, \"container\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([{}], _axes_axis__WEBPACK_IMPORTED_MODULE_2__.Axis)\n    ], LinearGauge.prototype, \"axes\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _model_base__WEBPACK_IMPORTED_MODULE_1__.TooltipSettings)\n    ], LinearGauge.prototype, \"tooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([{}], _model_base__WEBPACK_IMPORTED_MODULE_1__.Annotation)\n    ], LinearGauge.prototype, \"annotations\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)([])\n    ], LinearGauge.prototype, \"rangePalettes\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], LinearGauge.prototype, \"useGroupingSeparator\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], LinearGauge.prototype, \"description\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], LinearGauge.prototype, \"tabIndex\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], LinearGauge.prototype, \"format\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Material')\n    ], LinearGauge.prototype, \"theme\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"loaded\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"load\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"animationComplete\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"axisLabelRender\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"dragStart\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"dragMove\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"dragEnd\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"annotationRender\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"tooltipRender\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"gaugeMouseMove\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"gaugeMouseLeave\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"gaugeMouseDown\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"gaugeMouseUp\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"valueChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"resized\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], LinearGauge.prototype, \"beforePrint\", void 0);\n    LinearGauge = __decorate([\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.NotifyPropertyChanges\n    ], LinearGauge);\n    return LinearGauge;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Component));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-lineargauge/src/linear-gauge/linear-gauge.js?");

/***/ })

}]);