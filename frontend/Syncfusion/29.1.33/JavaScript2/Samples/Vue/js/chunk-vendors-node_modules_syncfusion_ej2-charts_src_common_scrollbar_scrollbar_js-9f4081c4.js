"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_common_scrollbar_scrollbar_js-9f4081c4"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/common/scrollbar/scrollbar.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/common/scrollbar/scrollbar.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollBar: () => (/* binding */ ScrollBar)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _scrollbar_elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scrollbar-elements */ \"./node_modules/@syncfusion/ej2-charts/src/common/scrollbar/scrollbar-elements.js\");\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _model_theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/theme */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/theme.js\");\n/* harmony import */ var _model_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n\n\n\n\n\n/**\n * Configures the scrollbar base.\n *\n * @private\n */\nvar ScrollBar = /** @class */ (function () {\n    /**\n     * Constructor for creating scrollbar\n     *\n     * @param component\n     * @param axis\n     */\n    function ScrollBar(component, axis) {\n        /** @private */\n        this.scrollRange = { max: null, min: null, interval: null, delta: null };\n        this.component = component;\n        this.elements = [];\n        this.scrollElements = new _scrollbar_elements__WEBPACK_IMPORTED_MODULE_1__.ScrollElements(component);\n        this.axis = axis;\n        this.mouseMoveListener = this.scrollMouseMove.bind(this);\n        this.mouseUpListener = this.scrollMouseUp.bind(this);\n        this.animateDuration = 500;\n        this.isPointer = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer;\n        this.browserName = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.info.name;\n    }\n    /**\n     * To Mouse x and y position\n     *\n     * @param e\n     */\n    ScrollBar.prototype.getMouseXY = function (e) {\n        var pageX;\n        var pageY;\n        var touchArg;\n        if (e.type.indexOf('touch') > -1) {\n            touchArg = e;\n            pageX = touchArg.changedTouches[0].clientX;\n            pageY = touchArg.changedTouches[0].clientY;\n        }\n        else {\n            pageX = e.clientX;\n            pageY = e.clientY;\n        }\n        var svgRect = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.component.element.id + '_scrollBar_svg' + this.axis.name).getBoundingClientRect();\n        this.mouseX = pageX - Math.max(svgRect.left, 0);\n        this.mouseY = pageY - Math.max(svgRect.top, 0);\n    };\n    /**\n     * Method to bind events for scrollbar svg object\n     *\n     * @param element\n     * @returns {void}\n     */\n    ScrollBar.prototype.wireEvents = function (element) {\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.scrollMouseDown, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.scrollMouseMove, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.scrollMouseUp, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(element, 'mousewheel', this.scrollMouseWheel, this);\n        window.addEventListener('mousemove', this.mouseMoveListener, false);\n        window.addEventListener('mouseup', this.mouseUpListener, false);\n    };\n    /**\n     * Method to remove events for srcollbar svg object\n     *\n     * @param element\n     */\n    ScrollBar.prototype.unWireEvents = function (element) {\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.scrollMouseDown);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.scrollMouseMove);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.scrollMouseUp);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(element, 'mousewheel', this.scrollMouseWheel);\n        window.removeEventListener('mousemove', this.mouseMoveListener, false);\n        window.removeEventListener('mouseup', this.mouseUpListener, false);\n    };\n    /**\n     * Handles the mouse down on scrollbar.\n     *\n     * @param e\n     */\n    ScrollBar.prototype.scrollMouseDown = function (e) {\n        var id = e.target.id;\n        var elem = this.scrollElements;\n        var isInverse = this.axis.isAxisInverse;\n        this.getMouseXY(e);\n        this.isResizeLeft = this.isExist(id, '_leftCircle_') || this.isExist(id, '_leftArrow_');\n        this.isResizeRight = this.isExist(id, '_rightCircle_') || this.isExist(id, '_rightArrow_');\n        //  this.previousXY = this.isVertical ? this.mouseY : this.mouseX;\n        this.previousXY = (this.isVertical && isInverse) ? this.mouseY : this.isVertical ? this.width -\n            this.mouseY : isInverse ? this.width - this.mouseX : this.mouseX;\n        this.previousWidth = elem.thumbRectWidth;\n        this.previousRectX = elem.thumbRectX;\n        this.startZoomPosition = this.axis.zoomPosition;\n        this.startZoomFactor = this.axis.zoomFactor;\n        this.startRange = this.axis.visibleRange;\n        this.scrollStarted = true;\n        this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollStart, this.getArgs(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollStart));\n        if (this.isExist(id, 'scrollBarThumb_') || this.isExist(id, 'gripCircle')) {\n            this.isThumbDrag = true;\n            if (this.axis.scrollbarSettings.height >= 12) {\n                this.svgObject.style.cursor = '-webkit-grabbing';\n            }\n        }\n        else if (this.isExist(id, 'scrollBarBackRect_')) {\n            var currentX = this.moveLength(this.previousXY, this.previousRectX);\n            elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;\n            this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);\n            this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);\n            this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;\n            if (this.isLazyLoad) {\n                var thumbMove = elem.thumbRectX > this.previousRectX ? 'RightMove' : 'LeftMove';\n                var args = this.calculateLazyRange(elem.thumbRectX, elem.thumbRectWidth, thumbMove);\n                if (args) {\n                    this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollEnd, args);\n                }\n            }\n        }\n        /**\n         * Customer issue\n         * Task ID - EJ2-28898\n         * Issue: While element's height is smaller than chart'height, html scroll bar presents. On that case while moving chart scrollbar,\n         * html scrollbar goes up due to chart's svg removed from the dom when zoomFactor and zoomPosition chnaged\n         * Fix: Only for scrolling purpose, height for element is set to chart's available height\n         */\n        if (this.component.element.style.height === '') {\n            this.isCustomHeight = true;\n            this.component.element.style.height = this.component.availableSize.height + 'px';\n        }\n    };\n    /**\n     * To check the matched string\n     *\n     * @param id\n     * @param match\n     */\n    ScrollBar.prototype.isExist = function (id, match) {\n        return id.indexOf(match) > -1;\n    };\n    /**\n     * To check current poisition is within scrollbar region\n     *\n     * @param currentX\n     */\n    ScrollBar.prototype.isWithIn = function (currentX) {\n        var circleRadius = this.axis.scrollbarSettings.height / 2;\n        return (currentX - circleRadius >= 0 &&\n            currentX + this.scrollElements.thumbRectWidth + circleRadius <= this.width);\n    };\n    /**\n     * Method to find move length of thumb\n     *\n     * @param mouseXY\n     * @param thumbX\n     * @param circleRadius\n     */\n    ScrollBar.prototype.moveLength = function (mouseXY, thumbX, circleRadius) {\n        if (circleRadius === void 0) { circleRadius = this.axis.scrollbarSettings.height / 2; }\n        var moveLength = (10 / 100) * (this.width - circleRadius * 2);\n        if (mouseXY < thumbX) {\n            moveLength = thumbX - (thumbX - moveLength > circleRadius ? moveLength : circleRadius);\n        }\n        else {\n            moveLength = thumbX + (thumbX + this.scrollElements.thumbRectWidth + moveLength < this.width - circleRadius ?\n                moveLength : circleRadius);\n        }\n        return moveLength;\n    };\n    /**\n     * Method to calculate zoom factor and position\n     *\n     * @param currentX\n     * @param currentWidth\n     */\n    ScrollBar.prototype.setZoomFactorPosition = function (currentX, currentWidth) {\n        this.isScrollUI = true;\n        var axis = this.axis;\n        var circleRadius = this.axis.scrollbarSettings.height / 2;\n        var circleWidth = 1;\n        var currentScrollWidth = currentX + currentWidth + circleRadius + circleWidth;\n        var currentZPWidth = circleRadius + (circleWidth / 2);\n        var axisSize = this.isVertical ? axis.rect.height : this.width;\n        this.zoomFactor = (currentWidth + (currentScrollWidth >= this.width ? circleRadius + circleWidth : 0)) / axisSize;\n        this.zoomPosition = currentScrollWidth > axisSize ? (1 - axis.zoomFactor) : currentX < (circleRadius + circleWidth) ? 0 :\n            (currentX - (currentX - currentZPWidth <= 0 ? currentZPWidth : 0)) / axisSize;\n        this.zoomPosition = (this.component.enableRtl && !this.isVertical && !axis.isInversed) || (axis.isInversed &&\n            !(this.component.enableRtl && !this.isVertical)) ? 1 - (this.zoomPosition + axis.zoomFactor) : this.zoomPosition;\n    };\n    /**\n     * Handles the mouse move on scrollbar.\n     *\n     * @param e\n     */\n    ScrollBar.prototype.scrollMouseMove = function (e) {\n        var target = e.target;\n        var elem = this.scrollElements;\n        var isInverse = this.axis.isAxisInverse;\n        if (!(0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.svgObject.id)) {\n            return null;\n        }\n        this.getMouseXY(e);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(target.id)) {\n            this.setCursor(target);\n            this.setTheme(target);\n        }\n        //let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;\n        var mouseXY = (this.isVertical && isInverse) ? this.width - this.mouseY : this.isVertical ?\n            this.mouseY : this.mouseX;\n        var range = this.axis.visibleRange;\n        var zoomPosition = this.zoomPosition;\n        var zoomFactor = this.zoomFactor;\n        var moveLength = this.previousRectX - elem.thumbRectX;\n        var thumbMove = moveLength < 0 ? 'RightMove' : 'LeftMove';\n        var args;\n        if (this.isLazyLoad && (this.isThumbDrag || this.isResizeLeft || this.isResizeRight)) {\n            args = this.calculateLazyRange(elem.thumbRectX, elem.thumbRectWidth, thumbMove);\n        }\n        var currentRange = args ? args.currentRange : null;\n        if (this.isThumbDrag) {\n            this.component.isScrolling = this.isThumbDrag;\n            mouseXY = (this.isVertical || isInverse) ? this.width - mouseXY : mouseXY;\n            var currentX = elem.thumbRectX + (mouseXY - this.previousXY);\n            if (mouseXY >= currentX + elem.thumbRectWidth) {\n                this.setCursor(target);\n            }\n            else {\n                if (this.axis.scrollbarSettings.height >= 12) {\n                    this.svgObject.style.cursor = '-webkit-grabbing';\n                }\n            }\n            if (mouseXY >= 0 && mouseXY <= currentX + elem.thumbRectWidth) {\n                elem.thumbRectX = this.isWithIn(currentX) ? currentX : elem.thumbRectX;\n                this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);\n                this.previousXY = mouseXY;\n                this.setZoomFactorPosition(currentX, elem.thumbRectWidth);\n                this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;\n            }\n            this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged, this.getArgs(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged, range, zoomPosition, zoomFactor, currentRange));\n        }\n        else if (this.isResizeLeft || this.isResizeRight) {\n            this.resizeThumb();\n        }\n    };\n    /**\n     * Handles the mouse wheel on scrollbar.\n     *\n     * @param e\n     */\n    ScrollBar.prototype.scrollMouseWheel = function (e) {\n        if (!this.axis.scrollbarSettings.enableZoom) {\n            return null;\n        }\n        var svgRect = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.component.element.id + '_scrollBar_svg' + this.axis.name).getBoundingClientRect();\n        this.mouseX = e.clientX - Math.max(svgRect.left, 0);\n        this.mouseY = e.clientY - Math.max(svgRect.top, 0);\n        var origin = 0.5;\n        var elem = this.scrollElements;\n        var axis = this.axis;\n        var direction = (this.browserName === 'mozilla' && !this.isPointer) ?\n            -(e.detail) / 3 > 0 ? 1 : -1 : (e['wheelDelta'] / 120) > 0 ? 1 : -1;\n        var cumulative = Math.max(Math.max(1 / (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.minMax)(axis.zoomFactor, 0, 1), 1) + (0.25 * direction), 1);\n        var range = this.axis.visibleRange;\n        var zoomPosition = this.zoomPosition;\n        var zoomFactor = this.zoomFactor;\n        var args;\n        if (cumulative >= 1) {\n            origin = axis.orientation === 'Horizontal' ? this.mouseX / axis.rect.width : 1 - (this.mouseY / axis.rect.height);\n            origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;\n            this.zoomFactor = (cumulative === 1) ? 1 : (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.minMax)(1 / cumulative, 0, 1);\n            this.zoomPosition = (cumulative === 1) ? 0 : axis.zoomPosition + ((axis.zoomFactor - this.zoomFactor) * origin);\n        }\n        elem.thumbRectX = this.isWithIn(this.zoomPosition * this.width) ? this.zoomPosition * this.width : elem.thumbRectX;\n        this.isScrollUI = true;\n        this.positionThumb(elem.thumbRectX, elem.thumbRectWidth);\n        if (this.isLazyLoad) {\n            this.setZoomFactorPosition(elem.thumbRectX, elem.thumbRectWidth);\n            this.axis.zoomFactor = this.zoomFactor;\n            this.axis.zoomPosition = this.zoomPosition < 0 ? 0 : this.zoomPosition > 0.9 ? 1 : this.zoomPosition;\n        }\n        axis.zoomFactor = this.zoomFactor;\n        axis.zoomPosition = this.zoomPosition;\n        if (this.isLazyLoad) {\n            args = this.calculateMouseWheelRange(elem.thumbRectX, elem.thumbRectWidth);\n            if (args) {\n                if ((args.currentRange.minimum !== args.previousAxisRange.minimum) && (args.currentRange.maximum !==\n                    args.previousAxisRange.maximum)) {\n                    this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollEnd, args);\n                    this.isScrollEnd = false;\n                }\n            }\n        }\n        if (!this.isLazyLoad) {\n            this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged, this.getArgs(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged, range, zoomPosition, zoomFactor));\n        }\n    };\n    /**\n     * Handles the mouse up on scrollbar.\n     *\n     * @param e\n     */\n    ScrollBar.prototype.scrollMouseUp = function () {\n        var args;\n        this.startX = this.scrollElements.thumbRectX;\n        var circleRadius = this.axis.scrollbarSettings.height / 2;\n        var circleWidth = 1;\n        var currentScrollWidth = this.startX + this.scrollElements.thumbRectWidth + circleRadius + circleWidth;\n        var currentZPWidth = circleRadius + (circleWidth / 2);\n        if ((this.isResizeLeft || this.isResizeRight) && !this.isLazyLoad) {\n            this.axis.zoomFactor = (currentScrollWidth >= this.width - 1 && (this.startX - currentZPWidth) <= 0) ? 1 : this.zoomFactor;\n        }\n        if (this.isLazyLoad) {\n            var moveLength = this.previousRectX - this.startX;\n            if ((moveLength > 0 || moveLength < 0) && this.isThumbDrag) {\n                var thumbMove = moveLength < 0 ? 'RightMove' : 'LeftMove';\n                if (thumbMove === 'RightMove') {\n                    this.startX = (this.startX + Math.abs(moveLength)) < this.width - circleRadius ? this.startX :\n                        this.width - circleRadius - this.scrollElements.thumbRectWidth;\n                }\n                else {\n                    this.startX = (this.startX + this.scrollElements.thumbRectWidth - Math.abs(moveLength)) > circleRadius ?\n                        this.startX : circleRadius;\n                }\n                args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth, thumbMove);\n                if (args) {\n                    this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollEnd, args);\n                    this.scrollStarted = false;\n                }\n            }\n            if (this.isResizeLeft || this.isResizeRight) {\n                args = this.calculateLazyRange(this.startX, this.scrollElements.thumbRectWidth);\n                if (args) {\n                    this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollEnd, args);\n                    this.scrollStarted = false;\n                }\n            }\n        }\n        this.isThumbDrag = false;\n        this.isResizeLeft = false;\n        this.isResizeRight = false;\n        this.isScrollEnd = false;\n        this.component.isScrolling = false;\n        if (this.scrollStarted && !this.isLazyLoad) {\n            this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollEnd, this.getArgs(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged, this.startRange, this.startZoomPosition, this.startZoomFactor));\n            this.scrollStarted = false;\n        }\n        /**\n         * Customer issue\n         * Task ID - EJ2-28898\n         * Chart's height setted is removed here.\n         */\n        if (this.isCustomHeight) {\n            this.component.element.style.height = null;\n        }\n    };\n    ScrollBar.prototype.calculateMouseWheelRange = function (scrollThumbX, scrollThumbWidth) {\n        var zoomFactor;\n        var zoomPosition;\n        var args;\n        var range = this.scrollRange;\n        var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);\n        var circleRadius = this.axis.scrollbarSettings.height / 2;\n        if ((scrollThumbX + scrollThumbWidth + circleRadius) <= this.width) {\n            zoomPosition = (scrollThumbX - circleRadius) / this.width;\n            zoomFactor = scrollThumbWidth / (this.width);\n        }\n        var currentStart = range.min + zoomPosition * range.delta;\n        var currentEnd = currentStart + zoomFactor * range.delta;\n        if (currentEnd) {\n            args = { axis: this.axis, currentRange: this.getStartEnd(currentStart, currentEnd, true), previousAxisRange: previousRange };\n        }\n        return args;\n    };\n    /**\n     * Range calculation for lazy loading.\n     *\n     * @param scrollThumbX\n     * @param scrollThumbWidth\n     * @param thumbMove\n     * @param scrollThumbX\n     * @param scrollThumbWidth\n     * @param thumbMove\n     * @param scrollThumbX\n     * @param scrollThumbWidth\n     * @param thumbMove\n     */\n    ScrollBar.prototype.calculateLazyRange = function (scrollThumbX, scrollThumbWidth, thumbMove) {\n        var currentScrollWidth = scrollThumbWidth;\n        var zoomFactor;\n        var zoomPosition;\n        var currentStart;\n        var currentEnd;\n        var args;\n        var range = this.scrollRange;\n        var previousRange = this.getStartEnd(this.previousStart, this.previousEnd, false);\n        var circleRadius = this.axis.scrollbarSettings.height / 2;\n        var circleWidth = 16;\n        if (this.isResizeRight || thumbMove === 'RightMove') {\n            currentScrollWidth = this.isResizeRight ? currentScrollWidth + circleWidth : currentScrollWidth;\n            zoomFactor = (currentScrollWidth) / this.width;\n            zoomPosition = thumbMove === 'RightMove' ? (scrollThumbX + circleRadius) / this.width : this.axis.zoomPosition;\n            currentStart = thumbMove === 'RightMove' ? (range.min + zoomPosition * range.delta) : this.previousStart;\n            currentEnd = currentStart + zoomFactor * range.delta;\n        }\n        else if (this.isResizeLeft || thumbMove === 'LeftMove') {\n            zoomPosition = (scrollThumbX - circleRadius) / this.width;\n            zoomFactor = currentScrollWidth / this.width;\n            currentStart = range.min + zoomPosition * range.delta;\n            currentStart = currentStart >= range.min ? currentStart : range.min;\n            currentEnd = thumbMove === 'LeftMove' ? (currentStart + zoomFactor * range.delta) : this.previousEnd;\n        }\n        else if (this.isThumbDrag) {\n            zoomPosition = thumbMove === 'RightMove' ? (scrollThumbX + circleRadius) / this.width : (scrollThumbX - circleRadius) / this.width;\n            zoomFactor = (this.scrollElements.thumbRectWidth) / this.width;\n            currentStart = range.min + zoomPosition * range.delta;\n            currentStart = currentStart >= range.min ? currentStart : range.min;\n            currentEnd = currentStart + zoomFactor * range.delta;\n        }\n        if (currentEnd) {\n            args = { axis: (this.component.isBlazor ? {} : this.axis), currentRange: this.getStartEnd(currentStart, currentEnd, true),\n                previousAxisRange: previousRange };\n        }\n        return args;\n    };\n    /**\n     * Get start and end values\n     *\n     * @param start\n     * @param end\n     * @param isCurrentStartEnd\n     * @param start\n     * @param end\n     * @param isCurrentStartEnd\n     * @param start\n     * @param end\n     * @param isCurrentStartEnd\n     */\n    ScrollBar.prototype.getStartEnd = function (start, end, isCurrentStartEnd) {\n        var valueType = this.valueType;\n        if ((valueType === 'DateTime' || valueType === 'DateTimeCategory') && isCurrentStartEnd) {\n            this.previousStart = start;\n            this.previousEnd = end;\n        }\n        else if (isCurrentStartEnd) {\n            var currentStart = Math.round(start);\n            var currentEnd = Math.ceil(end);\n            if (this.axis.valueType === 'Category') {\n                currentEnd -= (!this.axis.scrollbarSettings.enableZoom && currentEnd - currentStart >\n                    this.previousEnd - this.previousStart) ? (currentEnd - currentStart) - (this.previousEnd - this.previousStart) : 0;\n            }\n            this.previousStart = start = currentStart;\n            this.previousEnd = end = currentEnd;\n        }\n        switch (valueType) {\n            case 'Double':\n            case 'Category':\n            case 'Logarithmic':\n                start = Math.round(start);\n                end = Math.ceil(end);\n                break;\n            case 'DateTime':\n            case 'DateTimeCategory':\n                start = new Date(start);\n                end = new Date(end);\n                break;\n        }\n        return { minimum: start, maximum: end };\n    };\n    /**\n     * To render scroll bar\n     *\n     * @param isScrollExist\n     * @private\n     */\n    ScrollBar.prototype.render = function (isScrollExist) {\n        if (this.component.zoomModule || (isScrollExist && this.axis.scrollbarSettings.enable)) {\n            this.getDefaults();\n        }\n        this.getTheme();\n        this.removeScrollSvg();\n        (0,_scrollbar_elements__WEBPACK_IMPORTED_MODULE_1__.createScrollSvg)(this, this.component.svgRenderer);\n        this.wireEvents(this.svgObject);\n        this.svgObject.appendChild(this.scrollElements.renderElements(this, this.component.svgRenderer));\n        return this.svgObject;\n    };\n    /**\n     * Theming for scrollabr\n     *\n     * @returns {void}\n     */\n    ScrollBar.prototype.getTheme = function () {\n        this.scrollbarThemeStyle = (0,_model_theme__WEBPACK_IMPORTED_MODULE_3__.getScrollbarThemeColor)(this.component.theme);\n    };\n    /**\n     * Method to remove existing scrollbar.\n     *\n     * @returns {void}\n     */\n    ScrollBar.prototype.removeScrollSvg = function () {\n        if (document.getElementById(this.component.element.id + '_scrollBar_svg' + this.axis.name)) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(document.getElementById(this.component.element.id + '_scrollBar_svg' + this.axis.name));\n        }\n    };\n    /**\n     * Method to set cursor fpr scrollbar\n     *\n     * @param target\n     */\n    ScrollBar.prototype.setCursor = function (target) {\n        var id = target.id;\n        this.svgObject.style.cursor = ((id.indexOf('scrollBarThumb_') > -1 || id.indexOf('_gripCircle') > -1) && this.axis.scrollbarSettings.height >= 12) ?\n            '-webkit-grab' : (id.indexOf('Circle_') > -1 || id.indexOf('Arrow_') > -1) ? this.isVertical ? 'ns-resize' :\n            'ew-resize' : 'auto';\n    };\n    /**\n     * Method to set theme for sollbar\n     *\n     * @param target\n     */\n    ScrollBar.prototype.setTheme = function (target) {\n        var id = target.id;\n        var isLeftHover = id.indexOf('_leftCircle_') > -1 || id.indexOf('_leftArrow_') > -1;\n        var isRightHover = id.indexOf('_rightCircle_') > -1 || id.indexOf('_rightArrow_') > -1;\n        var style = this.scrollbarThemeStyle;\n        var leftArrowEle = this.scrollElements.leftArrowEle;\n        var rightArrowEle = this.scrollElements.rightArrowEle;\n        var leftCircleEle = this.scrollElements.leftCircleEle;\n        var rightCircleEle = this.scrollElements.rightCircleEle;\n        var isAxis = this.isCurrentAxis(target, leftArrowEle);\n        leftCircleEle.style.fill = isLeftHover && isAxis ? style.circleHover : style.circle;\n        rightCircleEle.style.fill = isRightHover && isAxis ? style.circleHover : style.circle;\n        leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;\n        rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;\n        if (this.component.theme === 'HighContrastLight') {\n            leftArrowEle.style.fill = isLeftHover && isAxis ? style.arrowHover : style.arrow;\n            leftArrowEle.style.stroke = isLeftHover && isAxis ? style.arrowHover : style.arrow;\n            rightArrowEle.style.fill = isRightHover && isAxis ? style.arrowHover : style.arrow;\n            rightArrowEle.style.stroke = isRightHover && isAxis ? style.arrowHover : style.arrow;\n            leftCircleEle.style.stroke = isLeftHover && isAxis ? style.circleHover : style.circle;\n            rightCircleEle.style.stroke = isRightHover && isAxis ? style.circleHover : style.circle;\n        }\n    };\n    /**\n     * To check current axis\n     *\n     * @param target\n     * @param ele\n     */\n    ScrollBar.prototype.isCurrentAxis = function (target, ele) {\n        return (target.id.split('_')[2] === ele.id.split('_')[2]);\n    };\n    /**\n     * Method to resize thumb\n     *\n     * @param e\n     */\n    ScrollBar.prototype.resizeThumb = function () {\n        var currentWidth;\n        var circleRadius = this.axis.scrollbarSettings.height / 2;\n        var padding = 5;\n        var gripWidth = 14;\n        var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;\n        var thumbX = this.previousRectX;\n        var isInverse = this.axis.isAxisInverse;\n        // let mouseXY: number = this.isVertical ? this.mouseY : this.mouseX;\n        var mouseXY = (this.isVertical && isInverse) ? this.mouseY : this.isVertical ? this.width -\n            this.mouseY : isInverse ? this.width - this.mouseX : this.mouseX;\n        var diff = Math.abs(this.previousXY - mouseXY);\n        if (this.isResizeLeft && mouseXY >= 0) {\n            var currentX = thumbX + (mouseXY > this.previousXY ? diff : -diff);\n            currentWidth = currentX - circleRadius >= 0 ? this.previousWidth + (mouseXY > this.previousXY ? -diff : diff) :\n                this.previousWidth;\n            currentX = currentX - circleRadius >= 0 ? currentX : thumbX;\n            if (currentWidth >= minThumbWidth && mouseXY < currentX + currentWidth) {\n                this.scrollElements.thumbRectX = this.previousRectX = currentX;\n                this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;\n                this.previousXY = mouseXY;\n                this.setZoomFactorPosition(currentX, currentWidth);\n                var argsData = {\n                    axis: (this.component.isBlazor ? {} : this.axis),\n                    name: _model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged,\n                    range: this.axis.visibleRange,\n                    zoomFactor: this.zoomFactor,\n                    zoomPosition: this.zoomPosition,\n                    previousRange: this.axis.visibleRange,\n                    previousZoomFactor: this.axis.zoomFactor,\n                    previousZoomPosition: this.axis.zoomPosition,\n                    currentRange: null,\n                    cancel: false\n                };\n                this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged, argsData);\n                if (!argsData.cancel) {\n                    this.positionThumb(currentX, currentWidth);\n                    this.axis.zoomFactor = argsData.zoomFactor;\n                    this.axis.zoomPosition = argsData.zoomPosition;\n                }\n                else {\n                    this.zoomFactor = argsData.previousZoomFactor;\n                    this.zoomPosition = argsData.previousZoomPosition;\n                }\n            }\n        }\n        else if (this.isResizeRight) {\n            currentWidth = mouseXY >= minThumbWidth + this.scrollElements.thumbRectX && mouseXY <= this.width - circleRadius ?\n                mouseXY - this.scrollElements.thumbRectX : this.previousWidth;\n            this.scrollElements.thumbRectWidth = this.previousWidth = currentWidth;\n            this.previousXY = mouseXY;\n            this.setZoomFactorPosition(this.startX, currentWidth);\n            if (!this.isLazyLoad) {\n                this.setZoomFactorPosition(this.startX, currentWidth);\n            }\n            var argsData = {\n                axis: (this.component.isBlazor ? {} : this.axis),\n                name: _model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged,\n                range: this.axis.visibleRange,\n                zoomFactor: this.zoomFactor,\n                zoomPosition: this.zoomPosition,\n                previousRange: this.axis.visibleRange,\n                previousZoomFactor: this.axis.zoomFactor,\n                previousZoomPosition: this.axis.zoomPosition,\n                currentRange: null,\n                cancel: false\n            };\n            this.component.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_4__.scrollChanged, argsData);\n            if (!argsData.cancel) {\n                this.positionThumb(this.startX, currentWidth);\n                this.axis.zoomFactor = argsData.zoomFactor;\n                this.axis.zoomPosition = argsData.zoomPosition;\n            }\n            else {\n                this.zoomFactor = argsData.previousZoomFactor;\n                this.zoomPosition = argsData.previousZoomPosition;\n            }\n        }\n    };\n    /**\n     * Method to position the scrollbar thumb\n     *\n     * @param currentX\n     * @param currentWidth\n     */\n    ScrollBar.prototype.positionThumb = function (currentX, currentWidth) {\n        var elem = this.scrollElements;\n        var gripWidth = 14;\n        var gripCircleDiameter = 2;\n        var padding = gripWidth / 2 - gripCircleDiameter;\n        elem.slider.setAttribute('x', this.axis.scrollbarSettings.enableZoom ? currentX.toString() : (currentX - this.axis.scrollbarSettings.height / 2).toString());\n        elem.slider.setAttribute('width', this.axis.scrollbarSettings.enableZoom ? currentWidth.toString() : (currentWidth + this.axis.scrollbarSettings.height).toString());\n        elem.leftCircleEle.setAttribute('cx', currentX.toString());\n        elem.rightCircleEle.setAttribute('cx', (currentX + currentWidth).toString());\n        elem.setArrowDirection(currentX, currentWidth, this.height);\n        elem.gripCircle.setAttribute('transform', 'translate(' + (currentX + currentWidth / 2 + ((this.isVertical ? 1 : -1) * padding)) +\n            ',' + (this.isVertical ? (this.axis.scrollbarSettings.height / 2 + padding / 2) - 0.5 : (this.axis.scrollbarSettings.height / 2 - padding / 2) - 0.5) + ') rotate(' + (this.isVertical ? '180' : '0') + ')');\n    };\n    /**\n     * Method to get default values\n     *\n     * @returns {void}\n     */\n    ScrollBar.prototype.getDefaults = function () {\n        var axis = this.axis;\n        var circleRadius = this.axis.scrollbarSettings.height / 2;\n        var padding = 5;\n        var gripWidth = 14;\n        var minThumbWidth = circleRadius * 2 + padding * 2 + gripWidth;\n        if (this.axis.scrollbarSettings.enable) {\n            this.isLazyLoad = true;\n            this.getLazyDefaults(axis);\n        }\n        this.isVertical = axis.orientation === 'Vertical';\n        var isRtlEnabled = (this.component.enableRtl && !this.isVertical && !axis.isInversed) ||\n            (axis.isInversed && !(this.component.enableRtl && !this.isVertical));\n        this.zoomFactor = this.isLazyLoad ? this.zoomFactor : axis.zoomFactor;\n        this.zoomPosition = this.isLazyLoad ? isRtlEnabled ? 1 - (this.zoomPosition + this.zoomFactor) : this.zoomPosition : isRtlEnabled ?\n            1 - (axis.zoomPosition + axis.zoomFactor) : axis.zoomPosition;\n        var currentWidth = this.zoomFactor * (this.isVertical ? axis.rect.height : axis.rect.width);\n        currentWidth = (this.isLazyLoad && !this.axis.scrollbarSettings.enableZoom) ||\n            currentWidth > minThumbWidth ? currentWidth : minThumbWidth;\n        this.scrollX = axis.rect.x;\n        this.scrollY = axis.rect.y;\n        this.width = this.isVertical ? axis.rect.height : axis.rect.width;\n        this.height = this.axis.scrollbarSettings.height;\n        var currentX = this.zoomPosition * (this.isVertical ? axis.rect.height : this.width);\n        var minThumbX = (this.width - minThumbWidth - circleRadius);\n        this.scrollElements.thumbRectX = currentX > minThumbX ? minThumbX : currentX < circleRadius ? circleRadius : currentX;\n        this.scrollElements.thumbRectWidth = this.isThumbDrag ? this.scrollElements.thumbRectWidth :\n            ((currentWidth + this.scrollElements.thumbRectX) < this.width - (circleRadius * 2))\n                ? currentWidth : this.width - this.scrollElements.thumbRectX - circleRadius;\n    };\n    /**\n     * Lazy load default values.\n     *\n     * @param axis\n     */\n    ScrollBar.prototype.getLazyDefaults = function (axis) {\n        var start;\n        var end;\n        var valueType = axis.valueType;\n        var scrollbarSettings = axis.scrollbarSettings;\n        var range = axis.scrollbarSettings.range;\n        var visibleRange = axis.visibleRange;\n        var pointsLength = axis.scrollbarSettings.pointsLength;\n        this.valueType = valueType = (!scrollbarSettings.range.minimum || !scrollbarSettings.range.maximum) &&\n            scrollbarSettings.pointsLength ? 'Double' : valueType;\n        var option = {\n            skeleton: 'full',\n            type: 'dateTime'\n        };\n        var dateParser = this.component.intl.getDateParser(option);\n        var dateFormatter = this.component.intl.getDateFormat(option);\n        switch (valueType) {\n            case 'Double':\n            case 'Category':\n            case 'Logarithmic':\n                start = range.minimum ? range.minimum : pointsLength ? 0 : visibleRange.min;\n                end = range.maximum ? range.maximum : pointsLength ? (pointsLength - 1) : visibleRange.max;\n                break;\n            case 'DateTime':\n            case 'DateTimeCategory':\n                start = range.minimum ? Date.parse(dateParser(dateFormatter(range.minimum))) : visibleRange.min;\n                end = range.maximum ? Date.parse(dateParser(dateFormatter(range.maximum))) : visibleRange.max;\n                break;\n        }\n        start = Math.min(start, visibleRange.min);\n        end = Math.max(end, visibleRange.max);\n        var zoomFactor = (visibleRange.max - visibleRange.min) / (end - start);\n        var zoomPosition = (visibleRange.min - start) / (end - start);\n        this.zoomFactor = range.minimum || range.maximum ? zoomFactor : (this.axis.maxPointLength / axis.scrollbarSettings.pointsLength);\n        this.zoomPosition = range.minimum || range.maximum ? zoomPosition : axis.zoomPosition;\n        this.zoomPosition = (this.component.enableRtl && axis.orientation === 'Horizontal' && !axis.isInversed) || (axis.isInversed && !(this.component.enableRtl && axis.orientation === 'Horizontal')) ? 1 - (this.zoomPosition + this.zoomFactor) : this.zoomPosition;\n        this.scrollRange.min = start;\n        this.scrollRange.max = end;\n        this.scrollRange.delta = end - start;\n        this.previousStart = visibleRange.min;\n        this.previousEnd = visibleRange.max;\n    };\n    /**\n     * Method to get log range\n     *\n     * @param axis\n     */\n    ScrollBar.prototype.getLogRange = function (axis) {\n        var range = axis.scrollbarSettings.range;\n        var start = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.logBase)(range.minimum, axis.logBase);\n        var end = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_2__.logBase)(range.maximum, axis.logBase);\n        start = isFinite(start) ? start : range.minimum;\n        end = isFinite(start) ? end : range.maximum;\n        return { minimum: Math.floor(start / 1), maximum: Math.ceil(end / 1) };\n    };\n    /**\n     * Method for injecting scrollbar module.\n     *\n     * @param axis\n     * @param component\n     */\n    ScrollBar.prototype.injectTo = function (axis, component) {\n        axis.zoomingScrollBar = new ScrollBar(component, axis);\n    };\n    /**\n     * Method to destroy scrollbar.\n     *\n     * @returns {void}\n     */\n    ScrollBar.prototype.destroy = function () {\n        var _this = this;\n        if (this.axes) {\n            this.axes.map(function (axis) {\n                axis.zoomingScrollBar.destroy();\n            });\n        }\n        else {\n            this.elements.map(function (element) {\n                _this.unWireEvents(element);\n                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(element.firstChild);\n            });\n            this.elements = [];\n        }\n    };\n    /**\n     * Method to get scrollbar module name.\n     *\n     * @returns {string}\n     */\n    ScrollBar.prototype.getModuleName = function () {\n        return 'ScrollBar';\n    };\n    ScrollBar.prototype.getArgs = function (eventName, range, zoomPosition, zoomFactor, currentRanges) {\n        var scrollArgs = {\n            axis: (this.component.isBlazor ? {} : this.axis),\n            name: eventName,\n            range: this.axis.visibleRange,\n            zoomFactor: this.axis.zoomFactor,\n            zoomPosition: this.axis.zoomPosition,\n            previousRange: range,\n            previousZoomFactor: zoomFactor,\n            previousZoomPosition: zoomPosition,\n            currentRange: currentRanges\n        };\n        return scrollArgs;\n    };\n    return ScrollBar;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/common/scrollbar/scrollbar.js?");

/***/ })

}]);