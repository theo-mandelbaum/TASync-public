"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_common_utils_helper_js-fbaa4598"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js":
/*!************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccPointData: () => (/* binding */ AccPointData),\n/* harmony export */   ChartLocation: () => (/* binding */ ChartLocation),\n/* harmony export */   CircleOption: () => (/* binding */ CircleOption),\n/* harmony export */   CoefficientToVector: () => (/* binding */ CoefficientToVector),\n/* harmony export */   ColorValue: () => (/* binding */ ColorValue),\n/* harmony export */   ControlPoints: () => (/* binding */ ControlPoints),\n/* harmony export */   CustomizeOption: () => (/* binding */ CustomizeOption),\n/* harmony export */   ImageOption: () => (/* binding */ ImageOption),\n/* harmony export */   LabelLocation: () => (/* binding */ LabelLocation),\n/* harmony export */   Mean: () => (/* binding */ Mean),\n/* harmony export */   Point3D: () => (/* binding */ Point3D),\n/* harmony export */   PointData: () => (/* binding */ PointData),\n/* harmony export */   PolarArc: () => (/* binding */ PolarArc),\n/* harmony export */   PolygonOption: () => (/* binding */ PolygonOption),\n/* harmony export */   RectOption: () => (/* binding */ RectOption),\n/* harmony export */   StackValues: () => (/* binding */ StackValues),\n/* harmony export */   Thickness: () => (/* binding */ Thickness),\n/* harmony export */   TransformToVisible: () => (/* binding */ TransformToVisible),\n/* harmony export */   accReactTemplate: () => (/* binding */ accReactTemplate),\n/* harmony export */   animateAddPoints: () => (/* binding */ animateAddPoints),\n/* harmony export */   animateRectElement: () => (/* binding */ animateRectElement),\n/* harmony export */   animateRedrawElement: () => (/* binding */ animateRedrawElement),\n/* harmony export */   animateTextElement: () => (/* binding */ animateTextElement),\n/* harmony export */   appendChildElement: () => (/* binding */ appendChildElement),\n/* harmony export */   appendClipElement: () => (/* binding */ appendClipElement),\n/* harmony export */   appendElement: () => (/* binding */ appendElement),\n/* harmony export */   applyZLight: () => (/* binding */ applyZLight),\n/* harmony export */   blazorTemplatesReset: () => (/* binding */ blazorTemplatesReset),\n/* harmony export */   calculateLegendShapes: () => (/* binding */ calculateLegendShapes),\n/* harmony export */   calculateRect: () => (/* binding */ calculateRect),\n/* harmony export */   calculateScrollbarOffset: () => (/* binding */ calculateScrollbarOffset),\n/* harmony export */   calculateShapes: () => (/* binding */ calculateShapes),\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   chartReactTemplate: () => (/* binding */ chartReactTemplate),\n/* harmony export */   checkBounds: () => (/* binding */ checkBounds),\n/* harmony export */   checkColorFormat: () => (/* binding */ checkColorFormat),\n/* harmony export */   colorNameToHex: () => (/* binding */ colorNameToHex),\n/* harmony export */   componentToHex: () => (/* binding */ componentToHex),\n/* harmony export */   containsRect: () => (/* binding */ containsRect),\n/* harmony export */   convertHexToColor: () => (/* binding */ convertHexToColor),\n/* harmony export */   convertToHexCode: () => (/* binding */ convertToHexCode),\n/* harmony export */   createSvg: () => (/* binding */ createSvg),\n/* harmony export */   createTemplate: () => (/* binding */ createTemplate),\n/* harmony export */   createTooltip: () => (/* binding */ createTooltip),\n/* harmony export */   createZoomingLabels: () => (/* binding */ createZoomingLabels),\n/* harmony export */   degreeToLocation: () => (/* binding */ degreeToLocation),\n/* harmony export */   degreeToRadian: () => (/* binding */ degreeToRadian),\n/* harmony export */   drawSymbol: () => (/* binding */ drawSymbol),\n/* harmony export */   findClipRect: () => (/* binding */ findClipRect),\n/* harmony export */   findCrosshairDirection: () => (/* binding */ findCrosshairDirection),\n/* harmony export */   findlElement: () => (/* binding */ findlElement),\n/* harmony export */   firstToLowerCase: () => (/* binding */ firstToLowerCase),\n/* harmony export */   getActualDesiredIntervalsCount: () => (/* binding */ getActualDesiredIntervalsCount),\n/* harmony export */   getAngle: () => (/* binding */ getAngle),\n/* harmony export */   getAnimationFunction: () => (/* binding */ getAnimationFunction),\n/* harmony export */   getColorByValue: () => (/* binding */ getColorByValue),\n/* harmony export */   getDraggedRectLocation: () => (/* binding */ getDraggedRectLocation),\n/* harmony export */   getElement: () => (/* binding */ getElement),\n/* harmony export */   getFontStyle: () => (/* binding */ getFontStyle),\n/* harmony export */   getGradientColor: () => (/* binding */ getGradientColor),\n/* harmony export */   getLabelText: () => (/* binding */ getLabelText),\n/* harmony export */   getMedian: () => (/* binding */ getMedian),\n/* harmony export */   getMinPointsDelta: () => (/* binding */ getMinPointsDelta),\n/* harmony export */   getPercentage: () => (/* binding */ getPercentage),\n/* harmony export */   getPercentageColor: () => (/* binding */ getPercentageColor),\n/* harmony export */   getPoint: () => (/* binding */ getPoint),\n/* harmony export */   getRectLocation: () => (/* binding */ getRectLocation),\n/* harmony export */   getRotatedRectangleCoordinates: () => (/* binding */ getRotatedRectangleCoordinates),\n/* harmony export */   getSaturationColor: () => (/* binding */ getSaturationColor),\n/* harmony export */   getTemplateFunction: () => (/* binding */ getTemplateFunction),\n/* harmony export */   getTextAnchor: () => (/* binding */ getTextAnchor),\n/* harmony export */   getTitle: () => (/* binding */ getTitle),\n/* harmony export */   getTransform: () => (/* binding */ getTransform),\n/* harmony export */   getUnicodeText: () => (/* binding */ getUnicodeText),\n/* harmony export */   getValueXByPoint: () => (/* binding */ getValueXByPoint),\n/* harmony export */   getValueYByPoint: () => (/* binding */ getValueYByPoint),\n/* harmony export */   getVisiblePoints: () => (/* binding */ getVisiblePoints),\n/* harmony export */   indexFinder: () => (/* binding */ indexFinder),\n/* harmony export */   inside: () => (/* binding */ inside),\n/* harmony export */   isBreakLabel: () => (/* binding */ isBreakLabel),\n/* harmony export */   isCollide: () => (/* binding */ isCollide),\n/* harmony export */   isOverlap: () => (/* binding */ isOverlap),\n/* harmony export */   isRotatedRectIntersect: () => (/* binding */ isRotatedRectIntersect),\n/* harmony export */   isZoomSet: () => (/* binding */ isZoomSet),\n/* harmony export */   lineBreakLabelTrim: () => (/* binding */ lineBreakLabelTrim),\n/* harmony export */   linear: () => (/* binding */ linear),\n/* harmony export */   logBase: () => (/* binding */ logBase),\n/* harmony export */   logWithIn: () => (/* binding */ logWithIn),\n/* harmony export */   markerAnimate: () => (/* binding */ markerAnimate),\n/* harmony export */   measureElementRect: () => (/* binding */ measureElementRect),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   pathAnimation: () => (/* binding */ pathAnimation),\n/* harmony export */   redrawElement: () => (/* binding */ redrawElement),\n/* harmony export */   removeElement: () => (/* binding */ removeElement),\n/* harmony export */   rotateTextSize: () => (/* binding */ rotateTextSize),\n/* harmony export */   setRange: () => (/* binding */ setRange),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   sort: () => (/* binding */ sort),\n/* harmony export */   stopTimer: () => (/* binding */ stopTimer),\n/* harmony export */   stringToNumber: () => (/* binding */ stringToNumber),\n/* harmony export */   subArray: () => (/* binding */ subArray),\n/* harmony export */   subArraySum: () => (/* binding */ subArraySum),\n/* harmony export */   subtractRect: () => (/* binding */ subtractRect),\n/* harmony export */   subtractThickness: () => (/* binding */ subtractThickness),\n/* harmony export */   sum: () => (/* binding */ sum),\n/* harmony export */   templateAnimate: () => (/* binding */ templateAnimate),\n/* harmony export */   textElement: () => (/* binding */ textElement),\n/* harmony export */   textTrim: () => (/* binding */ textTrim),\n/* harmony export */   textWrap: () => (/* binding */ textWrap),\n/* harmony export */   textWrapAnyWhere: () => (/* binding */ textWrapAnyWhere),\n/* harmony export */   titlePositionX: () => (/* binding */ titlePositionX),\n/* harmony export */   triggerLabelRender: () => (/* binding */ triggerLabelRender),\n/* harmony export */   valueToCoefficient: () => (/* binding */ valueToCoefficient),\n/* harmony export */   valueToPolarCoefficient: () => (/* binding */ valueToPolarCoefficient),\n/* harmony export */   withIn: () => (/* binding */ withIn),\n/* harmony export */   withInBounds: () => (/* binding */ withInBounds),\n/* harmony export */   withInRange: () => (/* binding */ withInRange)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_model_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/model/base */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/base.js\");\n/* harmony import */ var _chart_axis_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../chart/axis/axis */ \"./node_modules/@syncfusion/ej2-charts/src/chart/axis/axis.js\");\n/* harmony import */ var _model_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n/**\n * Function to sort the dataSource, by default it sort the data in ascending order.\n *\n * @param  {Object} data chart data\n * @param  {string} fields date fields\n * @param  {boolean} isDescending boolean values of descending\n * @returns {Object[]} It returns chart data which be sorted.\n */\nfunction sort(data, fields, isDescending) {\n    var sortData = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], data, null);\n    for (var i = 0; i < sortData.length; i++) {\n        for (var j = 0; j < fields.length; j++) {\n            if (sortData[i][fields[j]] instanceof Date) {\n                sortData[i][fields[j]] = sortData[i][fields[j]].getTime();\n            }\n        }\n    }\n    sortData.sort(function (a, b) {\n        var first = 0;\n        var second = 0;\n        for (var i = 0; i < fields.length; i++) {\n            first += a[fields[i]];\n            second += b[fields[i]];\n        }\n        if ((!isDescending && first < second) || (isDescending && first > second)) {\n            return -1;\n        }\n        else if (first === second) {\n            return 0;\n        }\n        return 1;\n    });\n    return sortData;\n}\n/**\n * Checks if a label contains a line break.\n *\n * @param {string} label - The label to check.\n * @returns {boolean} - True if the label contains a line break, otherwise false.\n */\nfunction isBreakLabel(label) {\n    return label.indexOf('<br>') !== -1;\n}\n/**\n * Retrieves the visible data points from a series.\n *\n * @param {Series | Chart3DSeries} series - The series to retrieve the visible data points.\n * @returns {Points[]} - An array containing the visible data points.\n */\nfunction getVisiblePoints(series) {\n    var points = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], series.points, null, true);\n    var tempPoints = [];\n    var tempPoint;\n    var pointIndex = 0;\n    for (var i = 0; i < points.length; i++) {\n        tempPoint = points[i];\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(tempPoint.x)) {\n            continue;\n        }\n        else {\n            tempPoint.index = pointIndex++;\n            tempPoints.push(tempPoint);\n        }\n    }\n    return tempPoints;\n}\n/**\n * Calculates the offset for positioning a scrollbar on a chart axis.\n *\n * @param {ScrollBar} scrollbar - The scrollbar object to position.\n * @param {boolean} isHorizontalAxis - Indicates whether the axis is horizontal.\n * @returns {number} An object containing the calculated top and left offsets for the scrollbar.\n */\nfunction calculateScrollbarOffset(scrollbar, isHorizontalAxis) {\n    var scrollbarPadding = 5;\n    var chart = scrollbar.component;\n    var titleHeight = 0;\n    var subTitleHeight = 0;\n    var titlePadding = chart.titleStyle.position === 'Top' || (chart.titleStyle.position === 'Bottom' && !chart.legendSettings.visible) ? 15 : 5;\n    if (chart.title) {\n        titleHeight = ((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(chart.title, chart.titleStyle, chart.themeStyle.chartTitleFont).height *\n            chart.titleCollection.length) + titlePadding;\n        if (chart.subTitle) {\n            subTitleHeight = ((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(chart.subTitle, chart.subTitleStyle, chart.themeStyle.chartSubTitleFont).height *\n                chart.subTitleCollection.length);\n        }\n    }\n    var scrollbarOffsetValue;\n    if (isHorizontalAxis) {\n        if (scrollbar.axis.scrollbarSettings.position === 'Top') {\n            scrollbarOffsetValue = chart.margin.top + scrollbarPadding + ((scrollbar.height + scrollbarPadding) * chart.scrollBarModule.topScrollBarCount) + (chart.titleStyle.position === 'Top' ? titleHeight\n                + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === 'Top' ? chart.subTitleStyle.border.width + subTitleHeight : 0);\n            chart.scrollBarModule.topScrollBarCount++;\n        }\n        else if (scrollbar.axis.scrollbarSettings.position === 'Bottom') {\n            scrollbarOffsetValue = chart.availableSize.height - (((scrollbar.height + scrollbarPadding) * chart.scrollBarModule.bottomScrollBarCount) + scrollbar.height + chart.margin.bottom + scrollbarPadding + (chart.titleStyle.position === 'Bottom' ? titleHeight\n                + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === 'Bottom' ? chart.subTitleStyle.border.width + subTitleHeight : 0));\n            chart.scrollBarModule.bottomScrollBarCount++;\n        }\n    }\n    else {\n        if (scrollbar.axis.scrollbarSettings.position === 'Right') {\n            scrollbarOffsetValue = chart.availableSize.width - (((scrollbar.height + scrollbarPadding) * chart.scrollBarModule.rightScrollBarCount) + scrollbar.height + scrollbarPadding + chart.margin.right + (chart.titleStyle.position === 'Right' ? titleHeight\n                + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === 'Right' ? chart.subTitleStyle.border.width + subTitleHeight : 0));\n            chart.scrollBarModule.rightScrollBarCount++;\n        }\n        else if (scrollbar.axis.scrollbarSettings.position === 'Left') {\n            scrollbarOffsetValue = chart.margin.left + scrollbarPadding + ((scrollbar.height + scrollbarPadding) * chart.scrollBarModule.leftScrollBarCount) + (chart.titleStyle.position === 'Left' ? titleHeight\n                + chart.titleStyle.border.width : 0) + (chart.subTitleStyle.position === 'Left' ? chart.subTitleStyle.border.width + subTitleHeight : 0);\n            chart.scrollBarModule.leftScrollBarCount++;\n        }\n    }\n    return scrollbarOffsetValue;\n}\n/**\n * Rotates the size of text based on the provided angle.\n *\n * @param {FontModel} font - The font style of the text.\n * @param {string} text - The text to be rotated.\n * @param {number} angle - The angle of rotation.\n * @param {Chart | Chart3D} chart - The chart instance.\n * @param {FontModel} themeFontStyle - The font style based on the theme.\n * @returns {Size} - The rotated size of the text.\n */\nfunction rotateTextSize(font, text, angle, chart, themeFontStyle) {\n    var transformValue = chart.element.style.transform;\n    if (transformValue) {\n        chart.element.style.transform = '';\n    }\n    var renderer = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.SvgRenderer(chart.element.id);\n    var labelText;\n    var textCollection = [];\n    var height;\n    var dy;\n    var label;\n    var tspanElement;\n    var options = {\n        id: 'rotate_text',\n        x: chart.initialClipRect.x,\n        y: chart.initialClipRect.y,\n        'font-size': font.size || themeFontStyle.size,\n        'font-style': font.fontStyle || themeFontStyle.fontStyle,\n        'font-family': font.fontFamily,\n        'font-weight': font.fontWeight || themeFontStyle.fontWeight,\n        'transform': 'rotate(' + angle + ', 0, 0)',\n        'text-anchor': 'middle'\n    };\n    if (isBreakLabel(text)) {\n        textCollection = text.split('<br>');\n        labelText = textCollection[0];\n    }\n    else {\n        labelText = text;\n    }\n    var htmlObject = renderer.createText(options, labelText);\n    if (!chart.delayRedraw && !chart.redraw && !chart.stockChart) {\n        chart.element.appendChild(chart.svgObject);\n    }\n    // for line break label\n    if (typeof textCollection !== 'string' && textCollection.length > 1) {\n        for (var i = 1, len = textCollection.length; i < len; i++) {\n            height = ((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(textCollection[i], font, chart.themeStyle.axisLabelFont).height);\n            dy = (options.y) + ((i * height));\n            label = textCollection[i];\n            tspanElement = renderer.createTSpan({\n                'x': options.x, 'id': options.id,\n                'y': dy\n            }, label);\n            htmlObject.appendChild(tspanElement);\n        }\n    }\n    var axisSvgObject = chart.svgRenderer.createSvg({\n        id: 'AxisLabelMax_svg', width: chart.availableSize.width,\n        height: chart.availableSize.height\n    });\n    document.body.appendChild(axisSvgObject);\n    axisSvgObject.appendChild(htmlObject);\n    var box = htmlObject.getBoundingClientRect();\n    if (transformValue) {\n        chart.element.style.transform = transformValue;\n    }\n    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(axisSvgObject);\n    if (!chart.delayRedraw && !chart.redraw && !chart.stockChart && !chart.pointsAdded) {\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(chart.svgObject);\n    }\n    if (chart.enableCanvas) {\n        var textWidth = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(text, font, chart.themeStyle.axisLabelFont).width;\n        var textHeight = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(text, font, chart.themeStyle.axisLabelFont).height;\n        var angleInRadians = (angle * Math.PI) / 180; // Convert the rotation angle to radians\n        var rotatedTextWidth = Math.abs(Math.cos(angleInRadians) * textWidth) + Math.abs(Math.sin(angleInRadians) * textHeight);\n        var rotatedTextHeight = Math.abs(Math.sin(angleInRadians) * textWidth) + Math.abs(Math.cos(angleInRadians) * textHeight);\n        return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Size(rotatedTextWidth, rotatedTextHeight);\n    }\n    return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Size((box.right - box.left), (box.bottom - box.top));\n}\n/**\n * Removes the specified element.\n *\n * @param {string | Element} id - The id or reference of the element to be removed.\n * @returns {void}\n */\nfunction removeElement(id) {\n    if (!id) {\n        return null;\n    }\n    var element = typeof id === 'string' ? getElement(id) : id;\n    if (element) {\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(element);\n    }\n}\n/**\n * Calculates the logarithm of a specified value with respect to a specified base.\n *\n * @param {number} value - The value for which to calculate the logarithm.\n * @param {number} base - The base of the logarithm.\n * @returns {number} - The logarithm of the value with respect to the specified base.\n */\nfunction logBase(value, base) {\n    return Math.log(value) / Math.log(base);\n}\n/**\n * Displays a tooltip at the specified coordinates with the given text.\n *\n * @param {string} text - The text content of the tooltip.\n * @param {number} x - The x-coordinate where the tooltip should be displayed.\n * @param {number} y - The y-coordinate where the tooltip should be displayed.\n * @param {number} areaWidth - The width of the area where the tooltip is displayed.\n * @param {string} id - The id of the tooltip element.\n * @param {Element} element - The element to which the tooltip is appended.\n * @param {boolean} isTouch - Indicates whether the tooltip is displayed on a touch device.\n * @param {boolean} isTitleOrLegendEnabled - Indicates whether the tooltip is enabled for title or legend.\n * @param {Rect} bound - The bounding rectangle in which the tooltip should be confined.\n * @returns {void}\n * @private\n */\nfunction showTooltip(text, x, y, areaWidth, id, element, isTouch, isTitleOrLegendEnabled, bound) {\n    //let id1: string = 'EJ2_legend_tooltip';\n    var tooltip = document.getElementById(id);\n    var size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(text, {\n        fontFamily: 'Segoe UI', size: '12px',\n        fontStyle: 'Normal', fontWeight: 'Regular'\n    });\n    var width = size.width + 5;\n    x = (x + width > areaWidth) ? x - (width + 15) : x;\n    if (bound && x < bound.x) {\n        x = bound.x;\n    }\n    y = isTitleOrLegendEnabled ? (y - size.height / 2) : y + 15;\n    if (!tooltip) {\n        tooltip = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n            id: id,\n            styles: 'top:' + (y).toString() + 'px;left:' + (x + 15).toString() +\n                'px;background-color: rgb(255, 255, 255) !important; color:black !important; ' +\n                'position:absolute;border:1px solid rgb(112, 112, 112); padding-left : 3px; padding-right : 2px;' +\n                'padding-bottom : 2px; padding-top : 2px; font-size:12px; font-family: \"Segoe UI\"'\n        });\n        tooltip.innerText = text;\n        element.appendChild(tooltip);\n        var left = parseInt(tooltip.style.left.replace('px', ''), 10);\n        if (left < 0) {\n            tooltip.style.left = '0px';\n        }\n    }\n    else {\n        tooltip.innerText = text;\n        tooltip.style.top = (y).toString() + 'px';\n        tooltip.style.left = (x + 15).toString() + 'px';\n    }\n    if (isTouch) {\n        setTimeout(function () { removeElement(id); }, 1500);\n    }\n}\n/**\n * Checks if a value is within the specified range.\n *\n * @param {number} value - The value to check.\n * @param {VisibleRangeModel} range - The range to check against.\n * @returns {boolean} - True if the value is inside the range, otherwise false.\n */\nfunction inside(value, range) {\n    return (value < range.max) && (value > range.min);\n}\n/**\n * Checks if a value is within the specified range.\n *\n * @param {number} value - The value to check.\n * @param {VisibleRangeModel} range - The range to check against.\n * @returns {boolean} - True if the value is inside the range, otherwise false.\n */\nfunction withIn(value, range) {\n    return (value <= range.max) && (value >= range.min);\n}\n/**\n * Adjusts the value based on the axis type.\n *\n * @param {number} value - The value to adjust.\n * @param {Axis} axis - The axis used for adjustment.\n * @returns {number} - The adjusted value.\n */\nfunction logWithIn(value, axis) {\n    return axis.valueType === 'Logarithmic' ? logBase(value, axis.logBase) : value;\n}\n/**\n * Checks if a point is within the range of the previous and next points in a series.\n *\n * @param {Points} previousPoint - The previous point in the series.\n * @param {Points} currentPoint - The current point to check.\n * @param {Points} nextPoint - The next point in the series.\n * @param {Series} series - The series to which the points belong.\n * @returns {boolean} - A boolean indicating if the point is within the range.\n * @private\n */\nfunction withInRange(previousPoint, currentPoint, nextPoint, series) {\n    if (series.chart.zoomModule && series.chart.zoomSettings.enableAnimation) {\n        return true;\n    }\n    var mX2 = logWithIn(currentPoint.xValue, series.xAxis);\n    var mX1 = previousPoint ? logWithIn(previousPoint.xValue, series.xAxis) : mX2;\n    var mX3 = nextPoint ? logWithIn(nextPoint.xValue, series.xAxis) : mX2;\n    var xStart = Math.floor(series.xAxis.visibleRange.min);\n    var xEnd = Math.ceil(series.xAxis.visibleRange.max);\n    return ((mX1 >= xStart && mX1 <= xEnd) || (mX2 >= xStart && mX2 <= xEnd) ||\n        (mX3 >= xStart && mX3 <= xEnd) || (xStart >= mX1 && xStart <= mX3));\n}\n/**\n * Calculates the sum of an array of numbers.\n *\n * @param {number[]} values - An array of numbers.\n * @returns {number} - The sum of the numbers in the array.\n */\nfunction sum(values) {\n    var sum = 0;\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n        var value = values_1[_i];\n        sum += value;\n    }\n    return sum;\n}\n/**\n * Calculates the sum of elements in a subarray.\n *\n * @param {Object[]} values - The array containing elements.\n * @param {number} first - The index of the first element in the subarray.\n * @param {number} last - The index of the last element in the subarray.\n * @param {number[]} index - The array of indices.\n * @param {Series} series - The series object.\n * @returns {number} - The sum of elements in the subarray.\n * @private\n */\nfunction subArraySum(values, first, last, index, series) {\n    var sum = 0;\n    var sumIndex = 0;\n    var isFirst = true;\n    if (index !== null) {\n        for (var i = (first + 1); i < last; i++) {\n            if (index.indexOf(i) === -1 && (i === series.intermediateSumIndexes[sumIndex] ||\n                series.intermediateSumIndexes[series.intermediateSumIndexes.length - 1] < i)) {\n                sum += values[i][series.yName];\n                if (i === series.intermediateSumIndexes[sumIndex]) {\n                    isFirst = false;\n                    sumIndex += 1;\n                }\n            }\n        }\n    }\n    else {\n        for (var i = (first + 1); i < last; i++) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(values[i][series.yName]) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series.sumIndexes) &&\n                series.sumIndexes.indexOf(i) === -1) {\n                sum += values[i][series.yName];\n            }\n        }\n    }\n    return sum;\n}\n/**\n * Subtracts thickness from the given rectangle.\n *\n * @param {Rect} rect - The rectangle from which to subtract thickness.\n * @param {Thickness} thickness - The thickness to subtract.\n * @returns {Rect} - The resulting rectangle after subtracting thickness.\n */\nfunction subtractThickness(rect, thickness) {\n    rect.x += thickness.left;\n    rect.y += thickness.top;\n    rect.width -= thickness.left + thickness.right;\n    rect.height -= thickness.top + thickness.bottom;\n    return rect;\n}\n/**\n * Subtracts a rectangle representing thickness from the given rectangle.\n *\n * @param {Rect} rect - The rectangle from which to subtract the thickness rectangle.\n * @param {Thickness} thickness - The rectangle representing the thickness to subtract.\n * @returns {Rect} - The resulting rectangle after subtracting the thickness rectangle.\n */\nfunction subtractRect(rect, thickness) {\n    rect.x += thickness.x;\n    rect.y += thickness.y;\n    rect.width -= thickness.x + thickness.width;\n    rect.height -= thickness.y + thickness.height;\n    return rect;\n}\n/**\n * Converts a degree value to a location on the chart based on the provided radius and center point.\n *\n * @param {number} degree - The degree value to convert.\n * @param {number} radius - The radius from the center point.\n * @param {ChartLocation} center - The center point of the chart.\n * @returns {ChartLocation} - The location on the chart corresponding to the degree value.\n */\nfunction degreeToLocation(degree, radius, center) {\n    var radian = (degree * Math.PI) / 180;\n    return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);\n}\n/**\n * Converts a degree value to radians.\n *\n * @param {number} degree - The degree value to convert.\n * @returns {number} - The equivalent value in radians.\n */\nfunction degreeToRadian(degree) {\n    return degree * (Math.PI / 180);\n}\n/**\n * Get the coordinates of a rotated rectangle.\n *\n * @param {ChartLocation[]} actualPoints - The coordinates of the original rectangle.\n * @param {number} centerX - The x-coordinate of the center of rotation.\n * @param {number} centerY - The y-coordinate of the center of rotation.\n * @param {number} angle - The angle of rotation in degrees.\n * @returns {ChartLocation[]} - The coordinates of the rotated rectangle.\n */\nfunction getRotatedRectangleCoordinates(actualPoints, centerX, centerY, angle) {\n    var coordinatesAfterRotation = [];\n    for (var i = 0; i < 4; i++) {\n        var point = actualPoints[i];\n        // translate point to origin\n        var tempX = point.x - centerX;\n        var tempY = point.y - centerY;\n        // now apply rotation\n        var rotatedX = tempX * Math.cos(degreeToRadian(angle)) - tempY * Math.sin(degreeToRadian(angle));\n        var rotatedY = tempX * Math.sin(degreeToRadian(angle)) + tempY * Math.cos(degreeToRadian(angle));\n        // translate back\n        point.x = rotatedX + centerX;\n        point.y = rotatedY + centerY;\n        coordinatesAfterRotation.push(new ChartLocation(point.x, point.y));\n    }\n    return coordinatesAfterRotation;\n}\n/**\n * Helper function to determine whether there is an intersection between the two polygons described\n * by the lists of vertices. Uses the Separating Axis Theorem.\n *\n * @param {ChartLocation[]} a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon.\n * @param {ChartLocation[]} b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon.\n * @returns {boolean} if there is any intersection between the 2 polygons, false otherwise.\n */\nfunction isRotatedRectIntersect(a, b) {\n    var polygons = [a, b];\n    var minA;\n    var maxA;\n    var projected;\n    var i;\n    var i1;\n    var j;\n    var minB;\n    var maxB;\n    for (i = 0; i < polygons.length; i++) {\n        // for each polygon, look at each edge of the polygon, and determine if it separates\n        // the two shapes\n        var polygon = polygons[i];\n        for (i1 = 0; i1 < polygon.length; i1++) {\n            // grab 2 vertices to create an edge\n            var i2 = (i1 + 1) % polygon.length;\n            var p1 = polygon[i1];\n            var p2 = polygon[i2];\n            // find the line perpendicular to this edge\n            var normal = new ChartLocation(p2.y - p1.y, p1.x - p2.x);\n            minA = maxA = undefined;\n            // for each vertex in the first shape, project it onto the line perpendicular to the edge\n            // and keep track of the min and max of these values\n            for (j = 0; j < a.length; j++) {\n                projected = normal.x * a[j].x + normal.y * a[j].y;\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(minA) || projected < minA) {\n                    minA = projected;\n                }\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(maxA) || projected > maxA) {\n                    maxA = projected;\n                }\n            }\n            // for each vertex in the second shape, project it onto the line perpendicular to the edge\n            // and keep track of the min and max of these values\n            minB = maxB = undefined;\n            for (j = 0; j < b.length; j++) {\n                projected = normal.x * b[j].x + normal.y * b[j].y;\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(minB) || projected < minB) {\n                    minB = projected;\n                }\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(maxB) || projected > maxB) {\n                    maxB = projected;\n                }\n            }\n            // if there is no overlap between the projects, the edge we are looking at separates the two\n            // polygons, and we know there is no overlap\n            if (maxA < minB || maxB < minA) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Generates the legend for accumulation chart.\n *\n * @param {number} locX - The x-coordinate of the legend position.\n * @param {number} locY - The y-coordinate of the legend position.\n * @param {number} r - The radius of the chart.\n * @param {number} height - The height of the legend.\n * @param {number} width - The width of the legend.\n * @returns {string} - The generated legend.\n */\nfunction getAccumulationLegend(locX, locY, r, height, width) {\n    var cartesianlarge = degreeToLocation(270, r, new ChartLocation(locX, locY));\n    var cartesiansmall = degreeToLocation(270, r, new ChartLocation(locX + (width / 10), locY));\n    return 'M' + ' ' + locX + ' ' + locY + ' ' + 'L' + ' ' + (locX + r) + ' ' + (locY) + ' ' + 'A' + ' ' + (r) + ' ' + (r) +\n        ' ' + 0 + ' ' + 1 + ' ' + 1 + ' ' + cartesianlarge.x + ' ' + cartesianlarge.y + ' ' + 'Z' + ' ' + 'M' + ' ' + (locX +\n        (width / 10)) + ' ' + (locY - (height / 10)) + ' ' + 'L' + (locX + (r)) + ' ' + (locY - height / 10) + ' ' + 'A' + ' '\n        + (r) + ' ' + (r) + ' ' + 0 + ' ' + 0 + ' ' + 0 + ' ' + cartesiansmall.x + ' ' + cartesiansmall.y + ' ' + 'Z';\n}\n/**\n * Calculates the angle between two points.\n *\n * @param {ChartLocation} center - The center point.\n * @param {ChartLocation} point - The point to calculate the angle from the center.\n * @returns {number} - The angle in degrees.\n */\nfunction getAngle(center, point) {\n    var angle = Math.atan2((point.y - center.y), (point.x - center.x));\n    angle = angle < 0 ? (6.283 + angle) : angle;\n    return angle * (180 / Math.PI);\n}\n/**\n * Returns a sub-array of values starting from the specified index.\n *\n * @param {number[]} values - The array of numbers.\n * @param {number} index - The index from which the sub-array starts.\n * @returns {number[]} - The sub-array of values.\n */\nfunction subArray(values, index) {\n    var subArray = [];\n    for (var i = 0; i <= index - 1; i++) {\n        subArray.push(values[i]);\n    }\n    return subArray;\n}\n/**\n * Converts a value to its corresponding coefficient based on the axis range.\n *\n * @param {number} value - The value to be converted.\n * @param {Axis} axis - The axis object containing range information.\n * @returns {number} - The coefficient value corresponding to the input value.\n */\nfunction valueToCoefficient(value, axis) {\n    var range = axis.visibleRange;\n    var result = (value - range.min) / (range.delta);\n    var isInverse = axis.isChart ? axis.isAxisInverse : axis.isInversed;\n    return isInverse ? (1 - result) : result;\n}\n/**\n * Transforms a point to its visible position based on the axes range and inversion.\n *\n * @param {number} x - The x-coordinate of the point.\n * @param {number} y - The y-coordinate of the point.\n * @param {Axis} xAxis - The x-axis object containing range information.\n * @param {Axis} yAxis - The y-axis object containing range information.\n * @param {boolean} [isInverted=false] - Specifies if the chart is inverted.\n * @param {Series} [series] - The series object for additional information (optional).\n * @returns {ChartLocation} - The transformed visible position of the point.\n */\nfunction TransformToVisible(x, y, xAxis, yAxis, isInverted, series) {\n    x = (xAxis.valueType === 'Logarithmic' ? logBase(x > 1 ? x : 1, xAxis.logBase) : x);\n    y = (yAxis.valueType === 'Logarithmic' ?\n        logBase(y > 1 ? y : 1, yAxis.logBase) : y);\n    x += xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' && series.type !== 'Radar' ? 0.5 : 0;\n    var radius = series.chart.radius * valueToCoefficient(y, yAxis);\n    var point = CoefficientToVector(valueToPolarCoefficient(x, xAxis), series.chart.primaryXAxis.startAngle);\n    return {\n        x: (series.clipRect.width / 2 + series.clipRect.x) + radius * point.x,\n        y: (series.clipRect.height / 2 + series.clipRect.y) + radius * point.y\n    };\n}\n/**\n * Finds the index from the given id.\n *\n * @param {string} id - The id to search for.\n * @param {boolean} [isPoint=false] - Specifies if the id represents a data point (optional).\n * @returns {Index} - The index found from the id.\n */\nfunction indexFinder(id, isPoint) {\n    if (isPoint === void 0) { isPoint = false; }\n    var ids = ['NaN', 'NaN'];\n    if (id.indexOf('_polygon') > -1) {\n        ids = ['NaN', 'NaN'];\n    }\n    else if (id.indexOf('_Point_') > -1) {\n        ids = id.split('_Series_')[1].split('_Point_');\n    }\n    else if (id.indexOf('_shape_') > -1 && (!isPoint || (isPoint && id.indexOf('_legend_') === -1))) {\n        ids = id.split('_shape_');\n        ids[0] = '0';\n    }\n    else if (id.indexOf('_text_') > -1 && (!isPoint || (isPoint && id.indexOf('_legend_') === -1))) {\n        ids = id.split('_text_');\n        ids[0] = '0';\n    }\n    else if (id.indexOf('_datalabel_') > -1) {\n        ids = id.split('_datalabel_')[1].split('_g_');\n        ids[0] = ids[0].replace('Series_', '');\n    }\n    else if (id.indexOf('TextGroup') > -1) {\n        ids = id.split('TextGroup');\n        ids[0] = ids[1];\n    }\n    else if (id.indexOf('ShapeGroup') > -1) {\n        ids = id.split('ShapeGroup');\n        ids[0] = ids[1];\n    }\n    return new _common_model_base__WEBPACK_IMPORTED_MODULE_1__.Index(parseInt(ids[0], 10), parseInt(ids[1], 10));\n}\n/**\n * Converts a coefficient value to a vector representing a point on the circumference of a circle.\n *\n * @param {number} coefficient - The coefficient value to convert.\n * @param {number} startAngle - The starting angle of the circle.\n * @returns {ChartLocation} - The vector representing the point on the circle.\n */\nfunction CoefficientToVector(coefficient, startAngle) {\n    startAngle = startAngle < 0 ? startAngle + 360 : startAngle;\n    var angle = Math.PI * (1.5 - 2 * coefficient);\n    angle = angle + (startAngle * Math.PI) / 180;\n    return { x: Math.cos(angle), y: Math.sin(angle) };\n}\n/**\n * Converts a value to a polar coefficient value based on the axis.\n *\n * @param {number} value - The value to convert.\n * @param {Axis} axis - The axis object.\n * @returns {number} - The polar coefficient value.\n */\nfunction valueToPolarCoefficient(value, axis) {\n    var range = axis.visibleRange;\n    var delta;\n    var length;\n    if (axis.valueType !== 'Category') {\n        delta = (range.max - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : range.interval)) - range.min;\n        length = axis.visibleLabels.length - 1;\n        delta = delta === 0 ? 1 : delta;\n    }\n    else {\n        // To split an interval equally based on visible labels count\n        delta = axis.visibleLabels.length === 1 ? 1 :\n            (axis.visibleLabels[axis.visibleLabels.length - 1].value - axis.visibleLabels[0].value);\n        length = axis.visibleLabels.length;\n    }\n    return axis.isAxisInverse ? ((value - range.min) / delta) * (1 - 1 / (length)) :\n        1 - ((value - range.min) / delta) * (1 - 1 / (length));\n}\n/** @private */\nvar Mean = /** @class */ (function () {\n    function Mean(verticalStandardMean, verticalSquareRoot, horizontalStandardMean, horizontalSquareRoot, verticalMean, horizontalMean) {\n        this.verticalStandardMean = verticalStandardMean;\n        this.horizontalStandardMean = horizontalStandardMean;\n        this.verticalSquareRoot = verticalSquareRoot;\n        this.horizontalSquareRoot = horizontalSquareRoot;\n        this.verticalMean = verticalMean;\n        this.horizontalMean = horizontalMean;\n    }\n    return Mean;\n}());\n\n/** @private */\nvar PolarArc = /** @class */ (function () {\n    function PolarArc(startAngle, endAngle, innerRadius, radius, currentXPosition) {\n        this.startAngle = startAngle;\n        this.endAngle = endAngle;\n        this.innerRadius = innerRadius;\n        this.radius = radius;\n        this.currentXPosition = currentXPosition;\n    }\n    return PolarArc;\n}());\n\n/**\n * Creates a tooltip element with the specified id, text, position, and font size.\n *\n * @param {string} id - The id of the tooltip element.\n * @param {string} text - The text content of the tooltip.\n * @param {number} top - The top position of the tooltip.\n * @param {number} left - The left position of the tooltip.\n * @param {string} fontSize - The font size of the tooltip text.\n * @returns {void}\n */\nfunction createTooltip(id, text, top, left, fontSize) {\n    var tooltip = getElement(id);\n    var style = 'top:' + top.toString() + 'px;' +\n        'left:' + left.toString() + 'px;' +\n        'color:black !important; ' +\n        'background:#FFFFFF !important; ' +\n        'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:1';\n    if (!tooltip) {\n        tooltip = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n            id: id, innerHTML: '&nbsp;' + text + '&nbsp;', styles: style\n        });\n        document.body.appendChild(tooltip);\n    }\n    else {\n        tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');\n        tooltip.style.cssText = style;\n    }\n}\n/**\n * Creates zooming labels for the specified axis and adds them to the parent element.\n *\n * @param {Chart} chart - The chart instance.\n * @param {Axis} axis - The axis for which to create zooming labels.\n * @param {Element} parent - The parent element to which the labels will be appended.\n * @param {number} index - The index of the label.\n * @param {boolean} isVertical - Indicates whether the axis is vertical.\n * @param {Rect} rect - The bounding rectangle of the label.\n * @returns {Element} - The created zooming label element.\n */\nfunction createZoomingLabels(chart, axis, parent, index, isVertical, rect) {\n    var margin = 5;\n    var opposedPosition = axis.isAxisOpposedPosition;\n    var anchor = chart.enableRtl ? 'end' : isVertical ? 'start' : 'auto';\n    var size;\n    var chartRect = chart.availableSize.width;\n    var pathElement;\n    var x;\n    var y;\n    var rx = 3;\n    var arrowLocation;\n    var direction;\n    var scrollBarHeight = axis.scrollbarSettings.enable || (axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject)\n        ? axis.scrollBarHeight : 0;\n    var isRtlEnabled = (chart.enableRtl && !isVertical && !axis.isInversed) ||\n        (axis.isInversed && !(chart.enableRtl && !isVertical));\n    for (var i = 0; i < 2; i++) {\n        size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(i ? (isRtlEnabled ? axis.startLabel : axis.endLabel) : (isRtlEnabled ? axis.endLabel : axis.startLabel), axis.labelStyle, chart.themeStyle.axisLabelFont);\n        if (isVertical) {\n            arrowLocation = i ? new ChartLocation(rect.x - scrollBarHeight, rect.y + rx) :\n                new ChartLocation(axis.rect.x - scrollBarHeight, (rect.y + rect.height - rx));\n            x = (rect.x + (opposedPosition ? (rect.width + margin + scrollBarHeight) : -(size.width + margin + margin + scrollBarHeight)));\n            y = (rect.y + (i ? 0 : rect.height - size.height - margin));\n            x += (x < 0 || ((chartRect) < (x + size.width + margin))) ? (opposedPosition ? -(size.width / 2) : size.width / 2) : 0;\n            direction = findCrosshairDirection(rx, rx, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, false, false, !opposedPosition, arrowLocation.x, arrowLocation.y + (i ? -rx : rx));\n        }\n        else {\n            arrowLocation = i ? new ChartLocation((rect.x + rect.width - rx), (rect.y + rect.height + scrollBarHeight)) :\n                new ChartLocation(rect.x + rx, (rect.y + rect.height + scrollBarHeight));\n            x = (rect.x + (i ? (rect.width - size.width - margin) : 0));\n            y = (opposedPosition ? (rect.y - size.height - 10 - scrollBarHeight) : (rect.y + rect.height + margin + scrollBarHeight));\n            direction = findCrosshairDirection(rx, rx, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, opposedPosition, !opposedPosition, false, arrowLocation.x + (i ? rx : -rx), arrowLocation.y);\n        }\n        x = x + (margin / 2);\n        y = y + (3 * (size.height / 4)) + (margin / 2);\n        pathElement = chart.renderer.drawPath({\n            'id': chart.element.id + '_Zoom_' + index + '_AxisLabel_Shape_' + i,\n            'fill': chart.themeStyle.crosshairFill, 'width': 2, 'color': chart.themeStyle.crosshairFill,\n            'opacity': 1, 'stroke-dasharray': null, 'd': direction\n        }, null);\n        parent.appendChild(pathElement);\n        if (chart.theme === 'Fluent' || chart.theme === 'FluentDark') {\n            var shadowId = chart.element.id + '_shadow';\n            pathElement.setAttribute('filter', _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIE ? '' : 'url(#' + shadowId + ')');\n            var shadow = '<filter id=\"' + shadowId + '\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"3\"/>';\n            shadow += '<feOffset dx=\"3\" dy=\"3\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"0.5\"/>';\n            shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n            var defElement = chart.renderer.createDefs();\n            defElement.setAttribute('id', chart.element.id + 'SVG_tooltip_definition');\n            parent.appendChild(defElement);\n            defElement.innerHTML = shadow;\n            pathElement.setAttribute('stroke', '#cccccc');\n            pathElement.setAttribute('stroke-width', '0.5');\n        }\n        textElement(chart.renderer, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.TextOption(chart.element.id + '_Zoom_' + index + '_AxisLabel_' + i, x, y, anchor, i ? (isRtlEnabled ? axis.startLabel : axis.endLabel) : (isRtlEnabled ? axis.endLabel : axis.startLabel)), { color: chart.themeStyle.crosshairLabelFont.color, fontFamily: 'Segoe UI', fontWeight: 'Regular', size: '11px' }, chart.themeStyle.crosshairLabelFont.color, parent, null, null, null, null, null, null, null, null, null, null, chart.themeStyle.crosshairLabelFont);\n    }\n    return parent;\n}\n/**\n * Finds the direction of the crosshair based on the provided parameters.\n *\n * @param {number} rX - The x-coordinate of the crosshair line.\n * @param {number} rY - The y-coordinate of the crosshair line.\n * @param {Rect} rect - The bounding rectangle of the crosshair.\n * @param {ChartLocation} arrowLocation - The location of the arrow in the crosshair.\n * @param {number} arrowPadding - The padding for the arrow.\n * @param {boolean} top - Indicates whether the crosshair is positioned at the top.\n * @param {boolean} bottom - Indicates whether the crosshair is positioned at the bottom.\n * @param {boolean} left - Indicates whether the crosshair is positioned at the left.\n * @param {number} tipX - The x-coordinate of the crosshair tip.\n * @param {number} tipY - The y-coordinate of the crosshair tip.\n * @returns {string} - The direction of the crosshair ('Top', 'Bottom', 'Left', 'Right', 'Center').\n */\nfunction findCrosshairDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY) {\n    var direction = '';\n    var startX = rect.x;\n    var startY = rect.y;\n    var width = rect.x + rect.width;\n    var height = rect.y + rect.height;\n    if (top) {\n        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '\n            + startY + ' ' + (startX + rX) + ' ' + startY);\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + width + ' '\n            + startY + ' ' + (width) + ' ' + (startY + rY));\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' '\n            + (height) + ' ' + (width - rX) + ' ' + (height));\n        if (arrowPadding !== 0) {\n            direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (height));\n            direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (height + arrowPadding)\n                + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + height);\n        }\n        if ((arrowLocation.x - arrowPadding / 2) > startX) {\n            direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '\n                + height + ' ' + (startX) + ' ' + (height - rY) + ' z');\n        }\n        else {\n            if (arrowPadding === 0) {\n                direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '\n                    + height + ' ' + (startX) + ' ' + (height - rY) + ' z');\n            }\n            else {\n                direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height + rY) + ' z');\n            }\n        }\n    }\n    else if (bottom) {\n        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '\n            + (startY) + ' ' + (startX + rX) + ' ' + (startY) + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + (startY));\n        direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (arrowLocation.y));\n        direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (startY));\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY)\n            + ' Q ' + (width) + ' ' + (startY) + ' ' + (width) + ' ' + (startY + rY));\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + (width) + ' '\n            + (height) + ' ' + (width - rX) + ' ' + (height));\n        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + (startX) + ' '\n            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');\n    }\n    else if (left) {\n        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '\n            + (startY) + ' ' + (startX + rX) + ' ' + (startY));\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + (width) + ' '\n            + (startY) + ' ' + (width) + ' ' + (startY + rY) + ' L' + ' ' + (width) + ' ' + (arrowLocation.y - arrowPadding / 2));\n        direction = direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + (tipY));\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (arrowLocation.y + arrowPadding / 2));\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' ' + (height) + ' ' + (width - rX) + ' ' + (height));\n        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + startX + ' '\n            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');\n    }\n    else {\n        direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + (startY) + ' Q ' + (startX) + ' '\n            + (startY) + ' ' + (startX) + ' ' + (startY + rY) + ' L' + ' ' + (startX) + ' ' + (arrowLocation.y - arrowPadding / 2));\n        direction = direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + (tipY));\n        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (arrowLocation.y + arrowPadding / 2));\n        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height - rY) + ' Q ' + startX + ' '\n            + (height) + ' ' + (startX + rX) + ' ' + (height));\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (height) + ' Q ' + width + ' '\n            + (height) + ' ' + (width) + ' ' + (height - rY));\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (startY + rY) + ' Q ' + width + ' '\n            + (startY) + ' ' + (width - rX) + ' ' + (startY) + ' z');\n    }\n    return direction;\n}\n//Within bounds\n/**\n * Checks if the provided coordinates are within the bounds of the rectangle.\n *\n * @param {number} x - The x-coordinate to check.\n * @param {number} y - The y-coordinate to check.\n * @param {Rect} bounds - The bounding rectangle.\n * @param {number} width - The width of the area to include in the bounds check.\n * @param {number} height - The height of the area to include in the bounds check.\n * @returns {boolean} - Returns true if the coordinates are within the bounds; otherwise, false.\n */\nfunction withInBounds(x, y, bounds, width, height) {\n    if (width === void 0) { width = 0; }\n    if (height === void 0) { height = 0; }\n    return (x >= bounds.x - width && x <= bounds.x + bounds.width + width && y >= bounds.y - height\n        && y <= bounds.y + bounds.height + height);\n}\n/**\n * Gets the x-coordinate value for a given point value on the axis.\n *\n * @param {number} value - The point value.\n * @param {number} size - The size of the axis.\n * @param {Axis} axis - The axis.\n * @returns {number} - Returns the x-coordinate value.\n */\nfunction getValueXByPoint(value, size, axis) {\n    var actualValue = !axis.isAxisInverse ? value / size : (1 - (value / size));\n    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;\n}\n/**\n * Gets the y-coordinate value for a given point value on the axis.\n *\n * @param {number} value - The point value.\n * @param {number} size - The size of the axis.\n * @param {Axis} axis - The axis.\n * @returns {number} - Returns the y-coordinate value.\n */\nfunction getValueYByPoint(value, size, axis) {\n    var actualValue = axis.isAxisInverse ? value / size : (1 - (value / size));\n    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;\n}\n/**\n * Finds the clip rectangle for a series.\n *\n * @param {Series} series - The series for which to find the clip rectangle.\n * @param {boolean} isCanvas - Indicates whether the rendering is on a canvas.\n * @returns {void}\n */\nfunction findClipRect(series, isCanvas) {\n    if (isCanvas === void 0) { isCanvas = false; }\n    var rect = series.clipRect;\n    if (isCanvas && (series.type === 'Polar' || series.type === 'Radar')) {\n        if (series.drawType === 'Scatter') {\n            rect.x = series.xAxis.rect.x;\n            rect.y = series.yAxis.rect.y;\n            rect.width = series.xAxis.rect.width;\n            rect.height = series.yAxis.rect.height;\n        }\n        else {\n            rect.x = series.xAxis.rect.x / 2;\n            rect.y = series.yAxis.rect.y / 2;\n            rect.width = series.xAxis.rect.width;\n            rect.height = series.yAxis.rect.height;\n        }\n    }\n    else {\n        if (series.chart.requireInvertedAxis) {\n            rect.x = series.yAxis.rect.x;\n            rect.y = series.xAxis.rect.y;\n            rect.width = series.yAxis.rect.width;\n            rect.height = series.xAxis.rect.height;\n        }\n        else {\n            rect.x = series.xAxis.rect.x;\n            rect.y = series.yAxis.rect.y;\n            rect.width = series.xAxis.rect.width;\n            rect.height = series.yAxis.rect.height;\n        }\n    }\n}\n/**\n * Converts the first character of a string to lowercase.\n *\n * @param {string} str - The string to convert.\n * @returns {string} The converted string.\n */\nfunction firstToLowerCase(str) {\n    return str.substr(0, 1).toLowerCase() + str.substr(1);\n}\n/**\n * Gets the transformation of the chart area based on the provided axes and inverted axis state.\n *\n * @param {Axis} xAxis - The X-axis of the chart.\n * @param {Axis} yAxis - The Y-axis of the chart.\n * @param {boolean} invertedAxis - Indicates whether the chart axis is inverted.\n * @returns {Rect} The transformed chart area.\n */\nfunction getTransform(xAxis, yAxis, invertedAxis) {\n    var x;\n    var y;\n    var width;\n    var height;\n    if (invertedAxis) {\n        x = yAxis.rect.x;\n        y = xAxis.rect.y;\n        width = yAxis.rect.width;\n        height = xAxis.rect.height;\n    }\n    else {\n        x = xAxis.rect.x;\n        y = yAxis.rect.y;\n        width = xAxis.rect.width;\n        height = yAxis.rect.height;\n    }\n    return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect(x, y, width, height);\n}\n/**\n * Calculates the minimum points delta between data points on the provided axis.\n *\n * @param {Axis | Chart3DAxis} axis - The axis for which to calculate the minimum points delta.\n * @param {Series[]} seriesCollection - The collection of series in the chart.\n * @returns {number} The minimum points delta.\n */\nfunction getMinPointsDelta(axis, seriesCollection) {\n    var minDelta = Number.MAX_VALUE;\n    var xValues;\n    var minVal;\n    var seriesMin;\n    var stackingGroups = [];\n    for (var index = 0; index < seriesCollection.length; index++) {\n        var series = seriesCollection[index];\n        xValues = [];\n        if (series.visible &&\n            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null)\n                || (axis.name === series.chart.primaryXAxis.name && !series.xAxisName))) {\n            if (series.type.indexOf('Stacking') > -1 && stackingGroups.indexOf(series.stackingGroup) === -1) {\n                stackingGroups.push(series.stackingGroup);\n            }\n            xValues = series.points.map(function (point) {\n                return point.xValue;\n            });\n            xValues.sort(function (first, second) { return first - second; });\n            if (xValues.length === 1) {\n                var timeOffset = seriesCollection.length === 1 ? 25920000 : 2592000000;\n                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - timeOffset) : series.xMin;\n                minVal = xValues[0] - (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(seriesMin) ?\n                    seriesMin : axis.visibleRange.min);\n                if (minVal !== 0) {\n                    minDelta = Math.min(minDelta, minVal);\n                }\n            }\n            else {\n                for (var index_1 = 0; index_1 < xValues.length; index_1++) {\n                    var value = xValues[index_1];\n                    if (index_1 > 0 && value) {\n                        minVal = series.type.indexOf('Stacking') > -1 && axis.valueType === 'Category' ? stackingGroups.length : value - xValues[index_1 - 1];\n                        if (minVal !== 0) {\n                            minDelta = Math.min(minDelta, minVal);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (minDelta === Number.MAX_VALUE) {\n        minDelta = 1;\n    }\n    return minDelta;\n}\n/**\n * Retrieves the animation function based on the specified effect.\n *\n * @param {string} effect - The name of the animation effect.\n * @returns {Function} The animation function corresponding to the effect.\n */\nfunction getAnimationFunction(effect) {\n    var functionName;\n    switch (effect) {\n        case 'Linear':\n            functionName = linear;\n            break;\n    }\n    return functionName;\n}\n/**\n * Linear animation function.\n *\n * @param {number} currentTime - The current time of the animation.\n * @param {number} startValue - The starting value of the animation.\n * @param {number} endValue - The ending value of the animation.\n * @param {number} duration - The duration of the animation.\n * @returns {number} The interpolated value at the current time.\n * @private\n */\nfunction linear(currentTime, startValue, endValue, duration) {\n    return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;\n}\n/**\n * Animates the marker element.\n *\n * @param {Element} element - The marker element to animate.\n * @param {number} delay - The delay before starting the animation.\n * @param {number} duration - The duration of the animation.\n * @param {Series | AccumulationSeries} series - The series associated with the marker.\n * @param {number} pointIndex - The index of the point in the series.\n * @param {ChartLocation} point - The location of the point.\n * @param {boolean} isLabel - Specifies whether the marker is a data label.\n * @returns {void}\n */\nfunction markerAnimate(element, delay, duration, series, pointIndex, point, isLabel) {\n    var isAccumulation = series.accumulation ? true : false;\n    element.style.visibility = 'hidden';\n    var transform = element.getAttribute('transform');\n    new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n        duration: duration,\n        delay: delay,\n        progress: function (args) {\n            if (args.timeStamp > args.delay) {\n                args.element.style.visibility = 'visible';\n            }\n            if (isAccumulation ? args.element.id.indexOf('_datalabel_Series_') > -1 : (args.element.parentElement.parentElement.id.indexOf('DataLabel') > -1\n                && !(series.chart.stackLabels.visible && element.getAttribute('data-collide')))) {\n                args.element.style.visibility = 'visible';\n                var dataLabelOpacity = isAccumulation ? series.opacity\n                    : series.marker.dataLabel.opacity;\n                var calculatedOpacity = (args.timeStamp / 500) * (dataLabelOpacity);\n                if (isAccumulation) {\n                    element.setAttribute('opacity', Math.min(calculatedOpacity, dataLabelOpacity).toString());\n                }\n                else {\n                    series.textElement.setAttribute('opacity', Math.min(calculatedOpacity, dataLabelOpacity).toString());\n                    series.shapeElement.setAttribute('opacity', Math.min(calculatedOpacity, dataLabelOpacity).toString());\n                }\n            }\n        },\n        end: function () {\n            var annotations = document.getElementById(series.chart.element.id + '_Annotation_Collections');\n            if (annotations && series.type !== 'Line') {\n                annotations.style.visibility = 'visible';\n            }\n            if (element.parentElement.parentElement.id.indexOf('DataLabel') > -1 || element.id.indexOf('_datalabel_Series_') > -1) {\n                if (isAccumulation) {\n                    element.setAttribute('opacity', (series.opacity).toString());\n                }\n                else {\n                    series.textElement.setAttribute('opacity', (series.marker.dataLabel.opacity).toString());\n                    series.shapeElement.setAttribute('opacity', (series.marker.dataLabel.opacity).toString());\n                }\n            }\n            if (!(series.chart.stackLabels.visible && element.getAttribute('data-collide'))) {\n                element.style.visibility = '';\n            }\n            element.setAttribute('transform', transform ? transform : '');\n            if ((series.type === 'Scatter' || series.type === 'Bubble') && !isLabel && (pointIndex === series.points.length - 1)) {\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        }\n    });\n}\n/**\n * Animates the rectangle element.\n *\n * @param {Element} element - The rectangle element to animate.\n * @param {number} delay - The delay before starting the animation.\n * @param {number} duration - The duration of the animation.\n * @param {Rect} currentRect - The current rectangle dimensions.\n * @param {Rect} previousRect - The previous rectangle dimensions.\n * @returns {void}\n */\nfunction animateRectElement(element, delay, duration, currentRect, previousRect) {\n    var setStyle = function (rect) {\n        element.setAttribute('x', rect.x + '');\n        element.setAttribute('y', rect.y + '');\n        element.setAttribute('width', rect.width + '');\n        element.setAttribute('height', rect.height + '');\n    };\n    new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div'), {\n        duration: duration,\n        delay: delay,\n        //name: name,\n        progress: function (args) {\n            setStyle(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect(linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));\n        },\n        end: function () {\n            setStyle(currentRect);\n        }\n    });\n}\n/**\n * Animation after legend click a path.\n *\n * @param {Element} element - element to be animated\n * @param {string} direction - current direction of the path\n * @param {boolean} redraw - chart redraw\n * @param {string} previousDirection - previous direction of the path\n * @param {number} animateDuration - animateDuration of the path\n * @returns {void}\n */\nfunction pathAnimation(element, direction, redraw, previousDirection, animateDuration) {\n    if (!redraw || (!previousDirection && !element)) {\n        return null;\n    }\n    var duration = 300;\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(animateDuration)) {\n        duration = animateDuration;\n    }\n    var startDirections = previousDirection || element.getAttribute('d');\n    var splitDirections = startDirections.split(/(?=[LMCZAQ])/);\n    var endDirections = direction.split(/(?=[LMCZAQ])/);\n    var currentDireciton;\n    var startPath = [];\n    var endPath = [];\n    var c;\n    var end;\n    element.setAttribute('d', startDirections);\n    new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div'), {\n        duration: duration,\n        progress: function (args) {\n            currentDireciton = '';\n            splitDirections.map(function (directions, index) {\n                startPath = directions.split(' ');\n                endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;\n                if (startPath[0] === 'Z') {\n                    currentDireciton += 'Z' + ' ';\n                }\n                else if (startPath[0] === '') {\n                    currentDireciton = '';\n                }\n                else {\n                    currentDireciton += startPath[0] + ' ' +\n                        linear(args.timeStamp, +startPath[1], (+endPath[1] - +startPath[1]), args.duration) + ' ' +\n                        linear(args.timeStamp, +startPath[2], (+endPath[2] - +startPath[2]), args.duration) + ' ';\n                }\n                if (startPath[0] === 'C' || startPath[0] === 'Q') {\n                    c = 3;\n                    end = startPath[0] === 'Q' ? 4 : 6;\n                    while (c < end) {\n                        currentDireciton += linear(args.timeStamp, +startPath[c], (+endPath[c] - +startPath[c]), args.duration) + ' ' +\n                            linear(args.timeStamp, +startPath[++c], (+endPath[c] - +startPath[c]), args.duration) + ' ';\n                        ++c;\n                    }\n                }\n                if (startPath[0] === 'A') {\n                    currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' +\n                        linear(args.timeStamp, +startPath[6], (+endPath[6] - +startPath[6]), args.duration) + ' ' +\n                        linear(args.timeStamp, +startPath[7], (+endPath[7] - +startPath[7]), args.duration) + ' ';\n                }\n            });\n            element.setAttribute('d', currentDireciton);\n        },\n        end: function () {\n            element.setAttribute('d', direction);\n        }\n    });\n}\n/**\n * Point based animation in chart series.\n *\n * @param {Element} element element to be animated.\n * @param {string} direction current direction of the path.\n * @param {boolean} redraw chart redraw.\n * @param {string} previousDirection previous direction of the path.\n * @param {number} animateDuration animateDuration of the path.\n * @param {string} removeDirection removeDirection of the path.\n * @returns {void}\n */\nfunction animateAddPoints(element, direction, redraw, previousDirection, animateDuration, removeDirection) {\n    if (!redraw || (!previousDirection && !element)) {\n        return null;\n    }\n    var duration = 300;\n    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(animateDuration)) {\n        duration = animateDuration;\n    }\n    var startDirections = previousDirection || element.getAttribute('d');\n    var endDirections = direction;\n    var currentDirection = '';\n    element.setAttribute('d', startDirections);\n    new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div'), {\n        duration: duration,\n        progress: function (args) {\n            currentDirection = '';\n            var startPathCommands = startDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = endDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            for (var i = 0; i < maxLength; i++) {\n                var startPathCommand = startPathCommands[i] || '';\n                var endPathCommand = endPathCommands[i] || '';\n                var startCoords = startPathCommand.trim().split(/\\s+/);\n                var endCoords = endPathCommand.trim().split(/\\s+/);\n                var interpolatedCoords = [];\n                for (var j = 1; j < startCoords.length; j++) {\n                    var startCoord = parseFloat(startCoords[j]);\n                    var endCoord = parseFloat(endCoords[j]);\n                    if (!isNaN(startCoord) && !isNaN(endCoord) && startCoords.length === endCoords.length) {\n                        var interpolatedValue = linear(args.timeStamp, startCoord, (endCoord - startCoord), duration);\n                        if (i === maxLength - 1) {\n                            interpolatedCoords.push(interpolatedValue);\n                        }\n                        else {\n                            interpolatedCoords.push(interpolatedValue);\n                        }\n                    }\n                }\n                if (startCoords.length !== endCoords.length) {\n                    currentDirection += 'L';\n                }\n                else {\n                    currentDirection += startCoords[0];\n                }\n                currentDirection += ' ' + interpolatedCoords.join(' ');\n                currentDirection += ' ';\n            }\n            element.setAttribute('d', currentDirection);\n        },\n        end: function () {\n            element.setAttribute('d', removeDirection || direction);\n        }\n    });\n}\n/**\n * To append the clip rect element.\n *\n * @param {boolean} redraw - chart redraw value.\n * @param {BaseAttibutes} options - element options.\n * @param {SvgRenderer} renderer - svg renderer values.\n * @param {string} clipPath - clipPath of the element.\n * @returns {Element} - Returns clip rect element.\n */\nfunction appendClipElement(redraw, options, renderer, clipPath) {\n    if (clipPath === void 0) { clipPath = 'drawClipPath'; }\n    var clipElement = redrawElement(redraw, options.id, options, renderer);\n    if (clipElement) {\n        var def = renderer.createDefs();\n        def.appendChild(clipElement);\n        return def;\n    }\n    else {\n        return renderer[clipPath](options);\n    }\n}\n/**\n * Triggers the label render event.\n *\n * @param {Chart | RangeNavigator | Chart3D} chart - The chart or range navigator instance.\n * @param {number} tempInterval - The temporary interval value.\n * @param {string} text - The label text.\n * @param {FontModel} labelStyle - The style of the label.\n * @param {Axis | Chart3DAxis} axis - The axis associated with the label.\n * @returns {void}\n */\nfunction triggerLabelRender(chart, tempInterval, text, labelStyle, axis) {\n    var argsData = {\n        cancel: false, name: _model_constants__WEBPACK_IMPORTED_MODULE_3__.axisLabelRender, axis: axis,\n        text: text, value: tempInterval, labelStyle: labelStyle\n    };\n    chart.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_3__.axisLabelRender, argsData);\n    if (!argsData.cancel) {\n        var isLineBreakLabels = argsData.text.indexOf('<br>') !== -1;\n        var text_1 = (axis.enableTrim) ? (isLineBreakLabels ?\n            lineBreakLabelTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.themeStyle.axisLabelFont) :\n            textTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont))\n            : argsData.text;\n        axis.visibleLabels.push(new _chart_axis_axis__WEBPACK_IMPORTED_MODULE_2__.VisibleLabels(text_1, argsData.value, argsData.labelStyle, argsData.text));\n    }\n}\n/**\n * The function used to find whether the range is set.\n *\n * @param {Axis | Chart3DAxis} axis - The axis to check.\n * @returns {boolean} - It returns true if the axis range is set otherwise false.\n * @private\n */\nfunction setRange(axis) {\n    return (axis.minimum != null && axis.maximum != null);\n}\n/**\n * Checks if zooming is enabled for the axis.\n *\n * @param {Axis} axis - The axis to check for zooming.\n * @returns {boolean} - Returns true if zooming is enabled for the axis, otherwise false.\n */\nfunction isZoomSet(axis) {\n    return (axis.zoomFactor < 1 && axis.zoomPosition >= 0);\n}\n/**\n * Calculates the actual desired intervals count based on the available size and axis.\n *\n * @param {Size} availableSize - The available size for rendering.\n * @param {Axis | Chart3DAxis} axis - The axis for which to calculate the intervals count.\n * @returns {number} - The actual desired intervals count.\n */\nfunction getActualDesiredIntervalsCount(availableSize, axis) {\n    var size = axis.orientation === 'Horizontal' ? availableSize.width : availableSize.height;\n    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.desiredIntervals)) {\n        var desiredIntervalsCount = (axis.orientation === 'Horizontal' ? 0.533 : 1) * axis.maximumLabels;\n        desiredIntervalsCount = Math.max((size * (desiredIntervalsCount / 100)), 1);\n        return desiredIntervalsCount;\n    }\n    else {\n        return axis.desiredIntervals;\n    }\n}\n/**\n * Animates the template element.\n *\n * @param {Element} element - The element to animate.\n * @param {number} delay - The delay before starting the animation.\n * @param {number} duration - The duration of the animation.\n * @param {Effect} name - The name of the animation effect.\n * @param {boolean} [isRemove] - Indicates whether to remove the element after animation completion.\n * @returns {void}\n */\nfunction templateAnimate(element, delay, duration, name, isRemove) {\n    new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n        duration: duration,\n        delay: delay,\n        name: name,\n        progress: function (args) {\n            args.element.style.visibility = 'visible';\n        },\n        end: function (args) {\n            if (isRemove) {\n                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(args.element);\n            }\n            else {\n                args.element.style.visibility = 'visible';\n            }\n        }\n    });\n}\n/**\n * Draws a symbol at the specified location.\n *\n * @param {ChartLocation} location - The location to draw the symbol.\n * @param {string} shape - The shape of the symbol.\n * @param {Size} size - The size of the symbol.\n * @param {string} url - The URL of the image symbol.\n * @param {PathOption} options - The options for drawing the symbol.\n * @param {string} label - The label for the symbol.\n * @param {SvgRenderer | CanvasRenderer} [renderer] - The renderer for drawing the symbol.\n * @param {Rect} [clipRect] - The clipping rectangle.\n * @param {boolean} [isChartControl] - Indicates whether it is a chart control.\n * @param {BulletChart} [control] - The bullet chart control.\n * @returns {Element} - The element representing the drawn symbol.\n */\nfunction drawSymbol(location, shape, size, url, options, label, renderer, clipRect, isChartControl, control) {\n    var chartRenderer = renderer ? renderer : new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.SvgRenderer('');\n    var shapeOption = calculateShapes(location, size, shape, options, url, isChartControl, control);\n    var drawElement = chartRenderer['draw' + shapeOption.functionName](shapeOption.renderOption, clipRect ? new Int32Array([clipRect.x, clipRect.y]) : null);\n    //drawElement.setAttribute('aria-label', label);\n    return drawElement;\n}\n/**\n * Calculates the shapes based on the specified parameters.\n *\n * @param {ChartLocation} location - The location for the shapes.\n * @param {Size} size - The size of the shapes.\n * @param {string} shape - The shape of the symbols.\n * @param {PathOption} options - The options for drawing the shapes.\n * @param {string} url - The URL of the image symbols.\n * @param {boolean} [isChart] - Indicates whether it is a chart.\n * @param {BulletChart} [control] - The bullet chart control.\n * @returns {IShapes} - The calculated shapes.\n */\nfunction calculateShapes(location, size, shape, options, url, isChart, control) {\n    var dir;\n    var functionName = 'Path';\n    var isBulletChart = isChart;\n    var width = (isBulletChart && shape === 'Circle') ? (size.width - 2) : size.width;\n    var height = (isBulletChart && shape === 'Circle') ? (size.height - 2) : size.height;\n    var sizeBullet = (isBulletChart) ? control.targetWidth : 0;\n    var lx = location.x;\n    var ly = location.y;\n    var y = location.y + (-height / 2);\n    var x = location.x + (-width / 2);\n    var eq = 72;\n    var xVal;\n    var yVal;\n    switch (shape) {\n        case 'Bubble':\n        case 'Circle':\n            functionName = 'Ellipse';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'rx': width / 2, 'ry': height / 2, 'cx': lx, 'cy': ly });\n            break;\n        case 'Plus':\n            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +\n                'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' +\n                (ly + (-height / 2));\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Cross':\n            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\n                'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2));\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Multiply':\n            dir = 'M ' + (lx - sizeBullet) + ' ' + (ly - sizeBullet) + ' L ' +\n                (lx + sizeBullet) + ' ' + (ly + sizeBullet) + ' M ' +\n                (lx - sizeBullet) + ' ' + (ly + sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly - sizeBullet);\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir, stroke: options.fill });\n            break;\n        case 'HorizontalLine':\n            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly;\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'VerticalLine':\n            dir = 'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' + (ly + (-height / 2));\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Diamond':\n            dir = 'M' + ' ' + x + ' ' + ly + ' ' +\n                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +\n                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + ly + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'ActualRect':\n            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 8)) + ' ' +\n                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (-height / 8)) + ' ' +\n                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (height / 8)) + ' ' +\n                'L' + ' ' + x + ' ' + (ly + (height / 8)) + ' ' +\n                'L' + ' ' + x + ' ' + (ly + (-height / 8)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'TargetRect':\n            dir = 'M' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' ' +\n                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (-height / 2)) + ' ' +\n                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Rectangle':\n        case 'Hilo':\n        case 'HiloOpenClose':\n        case 'Candle':\n        case 'Waterfall':\n        case 'BoxAndWhisker':\n        case 'StepArea':\n        case 'RangeStepArea':\n        case 'StackingStepArea':\n        case 'Square':\n        case 'Flag':\n            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + (ly + (-height / 2)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Pyramid':\n        case 'Triangle':\n            dir = 'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Funnel':\n        case 'InvertedTriangle':\n            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\n                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Pentagon':\n            for (var i = 0; i <= 5; i++) {\n                xVal = (width / 2) * Math.cos((Math.PI / 180) * (i * eq));\n                yVal = (height / 2) * Math.sin((Math.PI / 180) * (i * eq));\n                if (i === 0) {\n                    dir = 'M' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ';\n                }\n                else {\n                    dir = dir.concat('L' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ');\n                }\n            }\n            dir = dir.concat('Z');\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Image':\n            functionName = 'Image';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'href': url, 'height': height, 'width': width, x: x, y: y });\n            break;\n        case 'Star': {\n            var cornerPoints = 5;\n            var outerRadius = Math.min(width, height) / 2;\n            var innerRadius = outerRadius / 2;\n            var angle = Math.PI / cornerPoints;\n            var starPath = '';\n            for (var i = 0; i < 2 * cornerPoints; i++) {\n                var radius = (i % 2 === 0) ? outerRadius : innerRadius;\n                var currentX = lx + radius * Math.cos(i * angle - Math.PI / 2);\n                var currentY = ly + radius * Math.sin(i * angle - Math.PI / 2);\n                starPath += (i === 0 ? 'M' : 'L') + currentX + ',' + currentY;\n            }\n            starPath += 'Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': starPath });\n            break;\n        }\n    }\n    options = calculateLegendShapes(location, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Size(width, height), shape, options).renderOption;\n    return { renderOption: options, functionName: functionName };\n}\n/**\n * Gets the location of the rectangle based on the specified start and end locations and the outer rectangle.\n *\n * @param {ChartLocation} startLocation - The start location.\n * @param {ChartLocation} endLocation - The end location.\n * @param {Rect} outerRect - The outer rectangle.\n * @returns {Rect} - The location of the rectangle.\n */\nfunction getRectLocation(startLocation, endLocation, outerRect) {\n    var x = (endLocation.x < outerRect.x) ? outerRect.x :\n        (endLocation.x > (outerRect.x + outerRect.width)) ? outerRect.x + outerRect.width : endLocation.x;\n    var y = (endLocation.y < outerRect.y) ? outerRect.y :\n        (endLocation.y > (outerRect.y + outerRect.height)) ? outerRect.y + outerRect.height : endLocation.y;\n    return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect((x > startLocation.x ? startLocation.x : x), (y > startLocation.y ? startLocation.y : y), Math.abs(x - startLocation.x), Math.abs(y - startLocation.y));\n}\n/**\n * Returns the value constrained within the specified minimum and maximum limits.\n *\n * @param {number} value - The input value.\n * @param {number} min - The minimum limit.\n * @param {number} max - The maximum limit.\n * @returns {number} - The constrained value.\n */\nfunction minMax(value, min, max) {\n    return value > max ? max : (value < min ? min : value);\n}\n/**\n * Retrieves the DOM element with the specified ID.\n *\n * @param {string} id - The ID of the element to retrieve.\n * @returns {Element} - The DOM element.\n */\nfunction getElement(id) {\n    return document.getElementById(id);\n}\n/**\n * Gets the template function from the provided template string or function.\n *\n * @param {string | Function} template - The template string or function.\n * @returns {Function} - The template function.\n */\nfunction getTemplateFunction(template) {\n    var templateFn = null;\n    try {\n        if (typeof template !== 'function' && document.querySelectorAll(template).length) {\n            templateFn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.compile)(document.querySelector(template).innerHTML.trim());\n        }\n        else {\n            templateFn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.compile)(template);\n        }\n    }\n    catch (e) {\n        templateFn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.compile)(template);\n    }\n    return templateFn;\n}\n/**\n * Renders the accumulation chart data labels using template.\n *\n * @param {HTMLElement} childElement - The child element.\n * @param {AccumulationChart} chart - The accumulation chart instance.\n * @param {boolean} isTemplate - Defines whether the template is applied or not.\n * @param {AccPoints[]} points - The accumulation chart points.\n * @param {IAccTextRenderEventArgs} argsData - The accumulation chart text render event arguments.\n * @param {AccPoints} [point] - The accumulation chart point.\n * @param {Element} [datalabelGroup] - The data label group element.\n * @param {string} [id] - The id of the element.\n * @param {AccumulationDataLabelSettingsModel} [dataLabel] - The accumulation chart data label settings.\n * @param {boolean} [redraw] - Defines whether to redraw the chart or not.\n * @returns {void}\n */\nfunction accReactTemplate(childElement, chart, isTemplate, points, argsData, point, datalabelGroup, id, dataLabel, redraw) {\n    var clientRect = childElement.getBoundingClientRect();\n    chart.accumulationDataLabelModule.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, true);\n}\n/**\n * Renders the chart data labels using template.\n *\n * @param {HTMLElement} childElement - The child element.\n * @param {Chart} chart - The chart instance.\n * @param {Points} point - The chart point.\n * @param {Series} series - The chart series.\n * @param {number} labelIndex - The index of the label.\n * @param {boolean} [redraw] - Defines whether to redraw the chart or not.\n * @returns {void}\n */\nfunction chartReactTemplate(childElement, chart, point, series, labelIndex, redraw) {\n    var parentElement = document.getElementById(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections');\n    if (parentElement) {\n        if (point.index === 0) {\n            chart.dataLabelCollections = []; // clear old datalabel bounds for react callback\n        }\n        chart.dataLabelModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.marker.dataLabel, labelIndex, series.clipRect, redraw, true);\n    }\n}\n/**\n * Creates a template.\n *\n * @param {HTMLElement} childElement - The child element of the template.\n * @param {number} pointIndex - The index of the point.\n * @param {string | Function} content - The content of the template.\n * @param {Chart | AccumulationChart | RangeNavigator} chart - The chart instance.\n * @param {Points | AccPoints} point - The chart or accumulation point.\n * @param {Series | AccumulationSeries} series - The chart or accumulation series.\n * @param {string} dataLabelId - The id of the data label.\n * @param {number} labelIndex - The index of the label.\n * @param {IAccTextRenderEventArgs} argsData - The event arguments for text rendering.\n * @param {boolean} isTemplate - Indicates whether it is a template.\n * @param {AccPoints[]} points - The accumulation points.\n * @param {Element} datalabelGroup - The group element of the data label.\n * @param {string} id - The id of the element.\n * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\n * @param {boolean} redraw - Indicates whether to redraw.\n * @returns {HTMLElement} - The created template element.\n * @private\n */\nfunction createTemplate(childElement, pointIndex, content, chart, point, series, dataLabelId, labelIndex, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw) {\n    var templateFn = getTemplateFunction(content);\n    var templateElement;\n    try {\n        var blazor = 'Blazor';\n        var tempObject = window[blazor] ? (dataLabelId ? point : { point: point }) :\n            { chart: chart, series: series, point: point };\n        var templateId = dataLabelId ? dataLabelId + '_template' : 'template';\n        var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId ||\n            childElement.id.replace(/[^a-zA-Z0-9]/g, '')) : [];\n        if (elementData.length) {\n            templateElement = Array.prototype.slice.call(elementData);\n            var len = templateElement.length;\n            for (var i = 0; i < len; i++) {\n                childElement.appendChild(templateElement[i]);\n            }\n        }\n        var reactCallback = void 0;\n        if (chart.getModuleName() === 'accumulationchart') {\n            reactCallback = accReactTemplate.bind(this, childElement, chart, isTemplate, points, argsData, points[pointIndex], datalabelGroup, id, dataLabel, redraw);\n            if (chart.isReact) {\n                chart.renderReactTemplates(reactCallback);\n            }\n        }\n        else if (chart.getModuleName() === 'chart') {\n            reactCallback = (point && series) ? chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw) : reactCallback;\n            if (chart.isReact) {\n                chart.renderReactTemplates(reactCallback);\n            }\n        }\n    }\n    catch (e) {\n        return childElement;\n    }\n    return childElement;\n}\n/**\n * Gets the font style.\n *\n * @param {FontModel} font - The font settings.\n * @param {FontModel} themeFontStyle - The theme font settings.\n * @returns {string} - The font style.\n * @private\n */\nfunction getFontStyle(font, themeFontStyle) {\n    var style = '';\n    style = 'font-size:' + (font.size || themeFontStyle.size) +\n        '; font-style:' + (font.fontStyle || themeFontStyle.fontStyle) + '; font-weight:' + (font.fontWeight || themeFontStyle.fontWeight) +\n        '; font-family:' + font.fontFamily + ';opacity:' + font.opacity +\n        '; color:' + font.color + ';';\n    return style;\n}\n/**\n * Measures the bounding rectangle of an HTML element.\n *\n * @param {HTMLElement} element - The HTML element to measure.\n * @param {boolean} redraw - Indicates whether to redraw.\n * @param {boolean} isReactCallback - Indicates whether it's a React callback.\n * @returns {ClientRect} - The bounding rectangle of the element.\n * @private\n */\nfunction measureElementRect(element, redraw, isReactCallback) {\n    if (redraw === void 0) { redraw = false; }\n    if (!isReactCallback) { // If the element is already in DOM, no need to append in the body.\n        document.body.appendChild(element);\n    }\n    var bounds = element.getBoundingClientRect();\n    if (redraw) {\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(element);\n    }\n    else if (!isReactCallback) { // for react chart data label template - (callback function)\n        removeElement(element.id);\n    }\n    return bounds;\n}\n/**\n * Finds an element in a NodeList based on its id.\n *\n * @param {NodeList} elements - The NodeList to search.\n * @param {string} id - The id of the element to find.\n * @returns {Element} - The found element.\n * @private\n */\nfunction findlElement(elements, id) {\n    var element;\n    for (var i = 0, length_1 = elements.length; i < length_1; i++) {\n        if (elements[i].id.indexOf(id) > -1) {\n            element = elements[i];\n            continue;\n        }\n    }\n    return element;\n}\n/**\n * Gets the point on the chart based on the provided coordinates and axes.\n *\n * @param {number} x - The x-coordinate of the point.\n * @param {number} y - The y-coordinate of the point.\n * @param {Axis} xAxis - The x-axis of the chart.\n * @param {Axis} yAxis - The y-axis of the chart.\n * @param {boolean} isInverted - Indicates whether the chart is inverted.\n * @returns {ChartLocation} - The calculated point.\n * @private\n */\nfunction getPoint(x, y, xAxis, yAxis, isInverted) {\n    x = ((xAxis.valueType === 'Logarithmic') ?\n        logBase(((x > 0) ? x : Math.pow(xAxis.logBase, xAxis.visibleRange.min)), xAxis.logBase) : x);\n    y = ((yAxis.valueType === 'Logarithmic') ?\n        logBase(((y > 0) ? y : Math.pow(yAxis.logBase, yAxis.visibleRange.min)), yAxis.logBase) : y);\n    x = valueToCoefficient(x, xAxis);\n    y = valueToCoefficient(y, yAxis);\n    var xLength = (isInverted ? xAxis.rect.height : xAxis.rect.width);\n    var yLength = (isInverted ? yAxis.rect.width : yAxis.rect.height);\n    var locationX = isInverted ? y * (yLength) : x * (xLength);\n    var locationY = isInverted ? (1 - x) * (xLength) : (1 - y) * (yLength);\n    return new ChartLocation(locationX, locationY);\n}\n/**\n * Appends an element to a parent element.\n *\n * @param {Element} child - The child element to be appended.\n * @param {Element} parent - The parent element to which the child element will be appended.\n * @param {boolean} [redraw=false] - A boolean value indicating whether to redraw. Default is false.\n * @param {boolean} [animate=false] - A boolean value indicating whether to animate the appending operation. Default is false.\n * @param {string} [x='x'] - The x-coordinate for the position of the child element. Default is 'x'.\n * @param {string} [y='y'] - The y-coordinate for the position of the child element. Default is 'y'.\n * @param {number} duration - duration of the animation\n * @returns {void}\n */\nfunction appendElement(child, parent, redraw, animate, x, y, duration) {\n    if (redraw === void 0) { redraw = false; }\n    if (animate === void 0) { animate = false; }\n    if (x === void 0) { x = 'x'; }\n    if (y === void 0) { y = 'y'; }\n    if (child && child.hasChildNodes() && parent) {\n        appendChildElement(false, parent, child, redraw, animate, x, y, undefined, undefined, undefined, undefined, undefined, duration);\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Method to append child element.\n *\n * @param {boolean} isCanvas - canvas mode value\n * @param {Element | HTMLElement} parent - parent element\n * @param {Element | HTMLElement} childElement - childElement element\n * @param {boolean} redraw - chart redraw value\n * @param {boolean} isAnimate - animation value\n * @param {string} x - x position\n * @param {string} y - y position\n * @param {ChartLocation} start - start location value\n * @param {string} direction - direction of the element\n * @param {boolean} forceAnimate - forceAnimate\n * @param {boolean} isRect - isRect\n * @param {Rect} previousRect - previousRect\n * @param {number} animateDuration - duration of the animation\n * @param {boolean} scatterElement - The scatter element.\n * @param {number} angle - The angle of the element.\n * @param {ChartLocation} currentTransform - The current transform of the element.\n * @param {string} previousTranslate - The previous translate of the element.\n * @returns {void}\n * @private\n */\nfunction appendChildElement(isCanvas, parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration, scatterElement, angle, currentTransform, previousTranslate) {\n    if (isAnimate === void 0) { isAnimate = false; }\n    if (x === void 0) { x = 'x'; }\n    if (y === void 0) { y = 'y'; }\n    if (forceAnimate === void 0) { forceAnimate = false; }\n    if (isRect === void 0) { isRect = false; }\n    if (previousRect === void 0) { previousRect = null; }\n    if (scatterElement === void 0) { scatterElement = false; }\n    if (angle === void 0) { angle = 0; }\n    if (isCanvas) {\n        return null;\n    }\n    var existChild = scatterElement ? null : parent.querySelector('#' + childElement.id);\n    var element = (existChild || getElement(childElement.id));\n    var child = childElement;\n    var duration = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(animateDuration) ? animateDuration : 300;\n    if (redraw && isAnimate && element) {\n        start = start || (element.tagName === 'DIV' ?\n            new ChartLocation(+(element.style[x].split('px')[0]), +(element.style[y].split('px')[0])) :\n            new ChartLocation(+element.getAttribute(x), +element.getAttribute(y)));\n        if (direction && direction !== 'undefined') {\n            pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);\n        }\n        else if (isRect && previousRect) {\n            animateRectElement(child, 0, duration, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);\n        }\n        else {\n            var end = child.tagName === 'DIV' ?\n                new ChartLocation(+(child.style[x].split('px')[0]), +(child.style[y].split('px')[0])) :\n                new ChartLocation(+child.getAttribute(x), +child.getAttribute(y));\n            var previousTranform = element.getAttribute('transform');\n            animateRedrawElement(child, duration, start, end, x, y, angle, currentTransform, previousTranslate !== undefined ? new ChartLocation(previousTranslate.match(/\\d+/g).map(Number)[0], previousTranslate.match(/\\d+/g).map(Number)[1]) : previousTranform ? new ChartLocation(parseFloat(previousTranform.split(',')[1]), parseFloat(previousTranform.split(',')[2])) : new ChartLocation(0, 0), previousTranslate !== undefined);\n        }\n    }\n    else if (redraw && isAnimate && !element && forceAnimate) {\n        templateAnimate(child, 0, 600, 'FadeIn');\n    }\n    if (existChild) {\n        parent.replaceChild(child, element);\n    }\n    else {\n        parent.appendChild(child);\n    }\n}\n/**\n * Calculates the location of the dragged rectangle.\n *\n * @param {number} x1 - The x-coordinate of the starting point.\n * @param {number} y1 - The y-coordinate of the starting point.\n * @param {number} x2 - The x-coordinate of the ending point.\n * @param {number} y2 - The y-coordinate of the ending point.\n * @param {Rect} outerRect - The outer rectangle containing the dragged rectangle.\n * @returns {Rect} - The location of the dragged rectangle.\n * @private\n */\nfunction getDraggedRectLocation(x1, y1, x2, y2, outerRect) {\n    var width = Math.abs(x1 - x2);\n    var height = Math.abs(y1 - y2);\n    var x = Math.max(checkBounds(Math.min(x1, x2), width, outerRect.x, outerRect.width), outerRect.x);\n    var y = Math.max(checkBounds(Math.min(y1, y2), height, outerRect.y, outerRect.height), outerRect.y);\n    return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect(x, y, Math.min(width, outerRect.width), Math.min(height, outerRect.height));\n}\n/**\n * Checks if a value is within bounds defined by minimum and maximum values.\n *\n * @param {number} start - The start value.\n * @param {number} size - The size of the value.\n * @param {number} min - The minimum value of the bound.\n * @param {number} max - The maximum value of the bound.\n * @returns {number} - The adjusted value within the bounds.\n * @private\n */\nfunction checkBounds(start, size, min, max) {\n    if (start < min) {\n        start = min;\n    }\n    else if ((start + size) > (max + min)) {\n        start = (max + min) - size;\n    }\n    return start;\n}\n/**\n * Retrieves label text for a data point.\n *\n * @param {Points} currentPoint - The current data point.\n * @param {Series} series - The series to which the data point belongs.\n * @param {Chart} chart - The chart instance.\n * @returns {string[]} - The label text.\n * @private\n */\nfunction getLabelText(currentPoint, series, chart) {\n    var labelFormat = series.marker.dataLabel.format ? series.marker.dataLabel.format : series.yAxis.labelFormat;\n    var text = [];\n    var customLabelFormat = labelFormat.match('{value}') !== null;\n    switch (series.seriesType) {\n        case 'XY':\n            /**\n             * I255790\n             * For Polar radar series, the dataLabel appears out of range when axis range is given for yaxis\n             * Cause: Since symbol location for the points which did not lies in within range, lies outside of seriesRect.\n             * Fix: DataLabel rendered after checking WithIn for the points\n             */\n            if (series.chart.chartAreaType === 'PolarRadar') {\n                if (series.drawType.indexOf('Stacking') !== -1) {\n                    if ((series.yAxis.valueType === 'Logarithmic' &&\n                        logWithIn(series.stackedValues.endValues[currentPoint.index], series.yAxis)) ||\n                        withIn(series.stackedValues.endValues[currentPoint.index], series.yAxis.visibleRange)) {\n                        text.push(currentPoint.text || currentPoint.yValue.toString());\n                    }\n                }\n                else {\n                    if ((series.yAxis.valueType === 'Logarithmic' && logWithIn(currentPoint.yValue, series.yAxis)) ||\n                        withIn(currentPoint.yValue, series.yAxis.visibleRange)) {\n                        text.push(currentPoint.text || currentPoint.yValue.toString());\n                    }\n                }\n            }\n            else {\n                text.push(currentPoint.text || currentPoint.yValue.toString());\n            }\n            break;\n        case 'HighLow':\n            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\n            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\n            break;\n        case 'HighLowOpenClose':\n            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\n            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\n            text.push(currentPoint.text || Math.max(currentPoint.open, currentPoint.close).toString());\n            text.push(currentPoint.text || Math.min(currentPoint.open, currentPoint.close).toString());\n            break;\n        case 'BoxPlot':\n            text.push(currentPoint.text || currentPoint.median.toString());\n            text.push(currentPoint.text || currentPoint.maximum.toString());\n            text.push(currentPoint.text || currentPoint.minimum.toString());\n            text.push(currentPoint.text || currentPoint.upperQuartile.toString());\n            text.push(currentPoint.text || currentPoint.lowerQuartile.toString());\n            for (var _i = 0, _a = currentPoint.outliers; _i < _a.length; _i++) {\n                var liers = _a[_i];\n                text.push(currentPoint.text || liers.toString());\n            }\n            break;\n    }\n    if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {\n        series.yAxis.format = chart.intl.getNumberFormat({\n            format: customLabelFormat ? '' : labelFormat,\n            useGrouping: chart.useGroupingSeparator\n        });\n        for (var i = 0; i < text.length; i++) {\n            text[i] = customLabelFormat ? labelFormat.replace('{value}', series.yAxis.format(parseFloat(text[i]))) :\n                series.yAxis.format(parseFloat(text[i]));\n        }\n    }\n    return text;\n}\n/**\n * Stops the specified timer.\n *\n * @param {number} timer - The timer to stop.\n * @returns {void}\n */\nfunction stopTimer(timer) {\n    window.clearInterval(timer);\n}\n/**\n * Checks if the specified rect collides with any of the rect in the collection within the given clip rect.\n *\n * @param {Rect} rect - The rect to check for collision.\n * @param {Rect[]} collections - The collection of rect to check against.\n * @param {Rect} clipRect - The clip rect.\n * @returns {boolean} - Returns true if collision occurs; otherwise, false.\n */\nfunction isCollide(rect, collections, clipRect) {\n    var currentRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect(rect.x + clipRect.x, rect.y + clipRect.y, rect.width, rect.height);\n    var isCollide = collections.some(function (rect) {\n        return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&\n            currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);\n    });\n    return isCollide;\n}\n/**\n * Checks if the specified rect overlap each other.\n *\n * @param {Rect} currentRect - The first rect.\n * @param {Rect} rect - The second rect.\n * @returns {boolean} - Returns true if the rect overlap; otherwise, false.\n */\nfunction isOverlap(currentRect, rect) {\n    return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&\n        currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);\n}\n/**\n * Checks if the specified rect is completely contained within another rect.\n *\n * @param {Rect} currentRect - The rect to check if it's contained.\n * @param {Rect} rect - The containing rect.\n * @returns {boolean} - Returns true if the specified rect is completely contained within the containing rect; otherwise, false.\n */\nfunction containsRect(currentRect, rect) {\n    return (currentRect.x <= rect.x && currentRect.x + currentRect.width >= rect.x + rect.width &&\n        currentRect.y <= rect.y && currentRect.height + currentRect.y >= rect.y + rect.height);\n}\n/**\n * Calculates the rect based on the specified location, text size, and margin.\n *\n * @param {ChartLocation} location - The location of the rect.\n * @param {Size} textSize - The size of the text.\n * @param {MarginModel} margin - The margin to be applied around the text.\n * @returns {Rect} - Returns the calculated rect.\n */\nfunction calculateRect(location, textSize, margin) {\n    return new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Rect((location.x - (textSize.width / 2) - margin.left), (location.y - (textSize.height / 2) - margin.top), textSize.width + margin.left + margin.right, textSize.height + margin.top + margin.bottom);\n}\n/**\n * Converts the color value to hexadecimal code.\n *\n * @param {ColorValue} value - The color value to convert.\n * @returns {string} - Returns the hexadecimal representation of the color.\n */\nfunction convertToHexCode(value) {\n    return '#' + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);\n}\n/**\n * Converts a component value to its hexadecimal representation.\n *\n * @param {number} value - The component value to convert.\n * @returns {string} - Returns the hexadecimal representation of the component.\n */\nfunction componentToHex(value) {\n    var hex = value.toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n}\n/**\n * Converts a hexadecimal color code to its RedGreenBlue representation.\n *\n * @param {string} hex - The hexadecimal color code to convert.\n * @returns {ColorValue} - Returns the RedGreenBlue representation of the hexadecimal color code.\n */\nfunction convertHexToColor(hex) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) :\n        new ColorValue(255, 255, 255);\n}\n/**\n * Converts a color name to its corresponding hexadecimal color code.\n *\n * @param {string} color - The color name to convert.\n * @returns {string} - Returns the hexadecimal color code.\n */\nfunction colorNameToHex(color) {\n    color = color === 'transparent' ? 'white' : color;\n    var element = document.getElementById('chartmeasuretext');\n    if (!element) {\n        element = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('text', { id: 'chartmeasuretext' });\n        document.body.appendChild(element);\n    }\n    element.style.color = color;\n    color = window.getComputedStyle(element).color;\n    element.style.color = '';\n    var isRGBValue;\n    if (color.indexOf('rgb') === 0 || color.indexOf('hsl') === 0) {\n        color = color.replace(/\\s/g, '').replace(/[()]/g, '');\n        isRGBValue = color.slice(3).split(',');\n    }\n    if (isRGBValue && isRGBValue.length) {\n        var _a = isRGBValue.map(function (value) { return parseInt(value, 10); }), r = _a[0], g = _a[1], b = _a[2];\n        return convertToHexCode(new ColorValue(r, g, b));\n    }\n    return '';\n}\n/**\n * Checks if the provided color string is in a valid format.\n *\n * @param {string} color - The color string to check.\n * @returns {boolean} - Returns true if the color string is in a valid format, otherwise returns false.\n */\nfunction checkColorFormat(color) {\n    if (color.indexOf('rgba(') === 0 || color.indexOf('rgb(') === 0) {\n        var rgbaValues = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(',');\n        if (rgbaValues.length === 3 || rgbaValues.length === 4) {\n            return rgbaValues.every(function (val) {\n                var num = parseFloat(val);\n                return !isNaN(num) && num >= 0 && num <= 255;\n            });\n        }\n    }\n    else if (color.indexOf('#') === 0) {\n        var hex = color.substring(1);\n        return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);\n    }\n    return false;\n}\n/**\n * Gets the color with adjusted saturation.\n *\n * @param {string} color - The input color string.\n * @param {number} factor - The factor by which to adjust the saturation.\n * @returns {string} - The modified color string.\n */\nfunction getSaturationColor(color, factor) {\n    color = colorNameToHex(color);\n    color = color.replace(/[^0-9a-f]/gi, '');\n    if (color.length < 6) {\n        color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\n    }\n    factor = factor || 0;\n    // convert to decimal and change luminosity\n    var rgb = '#';\n    var colorCode;\n    for (var i = 0; i < 3; i++) {\n        colorCode = parseInt(color.substr(i * 2, 2), 16);\n        colorCode = Math.round(Math.min(Math.max(0, colorCode + (colorCode * factor)), 255));\n        rgb += ('00' + colorCode.toString(16)).substr(colorCode.toString(16).length);\n    }\n    return rgb;\n}\n/**\n * Applies a lightness adjustment to the given color.\n *\n * @param {string} color - The input color string.\n * @param {number} value - The value by which to adjust the lightness.\n * @returns {string} - The modified color string.\n */\nfunction applyZLight(color, value) {\n    var RGB = convertHexToColor(color);\n    RGB.r = parseInt(Math.floor(RGB.r * value).toString(), 10);\n    RGB.g = parseInt(Math.floor(RGB.g * value).toString(), 10);\n    RGB.b = parseInt(Math.floor(RGB.b * value).toString(), 10);\n    return '#' + componentToHex(RGB.r).toUpperCase() + componentToHex(RGB.g).toUpperCase() + componentToHex(RGB.b).toUpperCase();\n}\n/**\n * Calculates the median value of an array of numbers.\n *\n * @param {number[]} values - The array of numbers.\n * @returns {number} - The median value.\n */\nfunction getMedian(values) {\n    var half = Math.floor(values.length / 2);\n    return values.length % 2 ? values[half] : ((values[half - 1] + values[half]) / 2.0);\n}\n/**\n * Calculates the legend shapes based on the provided parameters.\n *\n * @param {ChartLocation} location - The location to position the legend shape.\n * @param {Size} size - The size of the legend shape.\n * @param {string} shape - The shape of the legend.\n * @param {PathOption} options - The options for drawing the legend shape.\n * @returns {IShapes} - The calculated legend shape.\n */\nfunction calculateLegendShapes(location, size, shape, options) {\n    var padding = 10;\n    var dir = '';\n    var space = 2;\n    var height = size.height;\n    var width = size.width;\n    var lx = location.x;\n    var ly = location.y;\n    switch (shape) {\n        case 'MultiColoredLine':\n        case 'Line':\n        case 'StackingLine':\n        case 'StackingLine100':\n            dir = 'M' + ' ' + (lx + (-width * (3 / 4))) + ' ' + (ly) + ' ' +\n                'L' + ' ' + (lx + (width * (3 / 4))) + ' ' + (ly);\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'StepLine':\n            options.fill = 'transparent';\n            dir = 'M' + ' ' + (lx + (-width / 2) - (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx +\n                (-width / 2) + (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 2) + (width / 10))\n                + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10)) + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10))\n                + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' +\n                ' ' + (lx + (width / 5)) + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly +\n                (-height / 2)) + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + '' + (lx + (width / 2)\n                + (padding / 4)) + ' ' + (ly + (height / 2));\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'UpArrow':\n            options.fill = options.stroke;\n            options.stroke = 'transparent';\n            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + (lx) + ' ' + (ly - (height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) +\n                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + (lx) + ' ' + (ly - (height / 2) + (2 * space)) +\n                'L' + (lx - (width / 2) + space) + ' ' + (ly + (height / 2)) + ' Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'DownArrow':\n            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\n                'L' + ' ' + (lx) + ' ' + (ly + (height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) +\n                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly - (height / 2)) + ' ' +\n                'L' + ' ' + (lx) + ' ' + (ly + (height / 2) - (2 * space)) +\n                'L' + (lx - (width / 2) + space) + ' ' + (ly - (height / 2)) + ' Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'RightArrow':\n            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +\n                (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' L' + ' ' + (lx + (-width / 2)) + ' ' +\n                (ly + (height / 2) - space) + ' ' + 'L' + ' ' + (lx + (width / 2) - (2 * space)) + ' ' + (ly) +\n                ' L' + (lx + (-width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'LeftArrow':\n            options.fill = options.stroke;\n            options.stroke = 'transparent';\n            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\n                'L' + ' ' + (lx + (-width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +\n                (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' +\n                (lx + (width / 2)) + ' ' + (ly + (height / 2) - space) + ' L' + ' ' + (lx + (-width / 2) + (2 * space))\n                + ' ' + (ly) + ' L' + (lx + (width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Column':\n        case 'Pareto':\n        case 'StackingColumn':\n        case 'StackingColumn100':\n        case 'RangeColumn':\n        case 'Histogram':\n            dir = 'M' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +\n                (lx + 3 * (-width / 10)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +\n                (lx + 3 * (-width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx - 3 *\n                (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' +\n                (lx + (-width / 10) - (width / 20)) + ' ' + (ly - (height / 4) - (padding / 2))\n                + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly - (height / 4) -\n                (padding / 2)) + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly\n                + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 10) - (width / 20)) + ' ' + (ly +\n                (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly) + ' ' +\n                'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + (ly) + ' ' + 'L' + ' '\n                + (lx + 3 * (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' '\n                + (lx + 3 * (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Bar':\n        case 'StackingBar':\n        case 'StackingBar100':\n            dir = 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 5)) + ' '\n                + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' +\n                (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'L' + ' ' +\n                (lx - (width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'Z' + ' '\n                + 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - (height / 5)\n                + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4)) + ' ' + (ly\n                - (height / 5) + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4))\n                + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'L' + ' ' + (lx - (width / 2)\n                + (-padding / 4)) + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'Z' + ' ' + 'M'\n                + ' ' + (lx - (width / 2) + (-padding / 4)) + ' ' + (ly + (height / 5)\n                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 5)\n                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 2)\n                + (padding / 10)) + ' ' + 'L' + ' ' + (lx - (width / 2) + (-padding / 4))\n                + ' ' + (ly + (height / 2) + (padding / 10)) + ' ' + 'Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Spline':\n            options.fill = 'transparent';\n            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' '\n                + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5))\n                + ' ' + 'M' + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx\n                + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '\n                + (ly - (height / 2));\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Area':\n        case 'MultiColoredArea':\n        case 'RangeArea':\n        case 'StackingArea':\n        case 'StackingArea100':\n            dir = 'M' + ' ' + (lx - (width / 2) - (padding / 4)) + ' ' + (ly + (height / 2))\n                + ' ' + 'L' + ' ' + (lx + (-width / 4) + (-padding / 8)) + ' ' + (ly - (height / 2))\n                + ' ' + 'L' + ' ' + (lx) + ' ' + (ly + (height / 4)) + ' ' + 'L' + ' ' + (lx\n                + (width / 4) + (padding / 8)) + ' ' + (ly + (-height / 2) + (height / 4)) + ' '\n                + 'L' + ' ' + (lx + (height / 2) + (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'SplineArea':\n        case 'SplineRangeArea':\n            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + lx\n                + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Z' + ' ' + 'M'\n                + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx + (width / 2)) + ' '\n                + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '\n                + (ly - (height / 2)) + ' ' + ' Z';\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        case 'Pie':\n        case 'Doughnut': {\n            options.stroke = 'transparent';\n            var r = Math.min(height, width) / 2;\n            dir = getAccumulationLegend(lx, ly, r, height, width);\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.merge)(options, { 'd': dir });\n            break;\n        }\n    }\n    return { renderOption: options };\n}\n/**\n * Trims the text to fit within the specified maximum width.\n *\n * @param {number} maxWidth - The maximum width for the text.\n * @param {string} text - The text to be trimmed.\n * @param {FontModel} font - The font settings for the text.\n * @param {boolean} isRtlEnabled - Indicates whether right-to-left text rendering is enabled.\n * @param {FontModel} [themeFontStyle] - The font style to be used for theme-specific settings.\n * @returns {string} - The trimmed text.\n */\nfunction textTrim(maxWidth, text, font, isRtlEnabled, themeFontStyle) {\n    var label = text;\n    var size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(text, font, themeFontStyle).width;\n    if (size > maxWidth) {\n        var textLength = text.length;\n        for (var i = textLength - 1; i >= 0; --i) {\n            label = isRtlEnabled ? '...' + text.substring(0, i) : text.substring(0, i) + '...';\n            size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(label, font, themeFontStyle).width;\n            if (size <= maxWidth) {\n                return label;\n            }\n        }\n    }\n    return label;\n}\n/**\n * Trims the text and performs line breaks based on the maximum width and font settings.\n *\n * @param {number} maxWidth - The maximum width allowed for the text.\n * @param {string} text - The text to be trimmed.\n * @param {FontModel} font - The font settings for the text.\n * @param {FontModel} [themeFontStyle] - Optional. The font style based on the theme.\n * @returns {string[]} - An array of trimmed text lines with line breaks.\n */\nfunction lineBreakLabelTrim(maxWidth, text, font, themeFontStyle) {\n    var labelCollection = [];\n    var breakLabels = text.split('<br>');\n    for (var i = 0; i < breakLabels.length; i++) {\n        text = breakLabels[i];\n        var size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(text, font, themeFontStyle).width;\n        if (size > maxWidth) {\n            var textLength = text.length;\n            for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {\n                text = text.substring(0, i_1) + '...';\n                size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(text, font, themeFontStyle).width;\n                if (size <= maxWidth) {\n                    labelCollection.push(text);\n                    break;\n                }\n            }\n        }\n        else {\n            labelCollection.push(text);\n        }\n    }\n    return labelCollection;\n}\n/**\n * Converts a string value to a number, considering the container size for percentage values.\n *\n * @param {string} value - The string value to convert to a number.\n * @param {number} containerSize - The size of the container, used for percentage values.\n * @returns {number} - The converted numeric value.\n */\nfunction stringToNumber(value, containerSize) {\n    if (value !== null && value !== undefined) {\n        return value.indexOf('%') !== -1 ? (containerSize / 100) * parseInt(value, 10) : parseInt(value, 10);\n    }\n    return null;\n}\n/**\n * Redraws the SVG or canvas element based on the provided options.\n *\n * @param {boolean} redraw - Specifies whether to redraw the element.\n * @param {string} id - The id of the element to redraw.\n * @param {PathAttributes | RectAttributes | CircleAttributes} [options] - The attributes of the element to redraw.\n * @param {SvgRenderer | CanvasRenderer} [renderer] - The renderer to use for redrawing.\n * @returns {Element} - The redrawn element.\n */\nfunction redrawElement(redraw, id, options, renderer) {\n    if (!redraw) {\n        return null;\n    }\n    var element = getElement(id);\n    if (element && options) {\n        renderer.setElementAttributes(options, element.tagName === 'clipPath' ? element.childNodes[0] : element);\n    }\n    return element;\n}\n/**\n * Animates the redrawn element from its start to end location over a specified duration.\n *\n * @param {Element | HTMLElement} element - The element to animate.\n * @param {number} duration - The duration of the animation in milliseconds.\n * @param {ChartLocation} start - The start location of the element.\n * @param {ChartLocation} end - The end location of the element.\n * @param {string} [x='x'] - The attribute representing the horizontal position of the element.\n * @param {string} [y='y'] - The attribute representing the vertical position of the element.\n * @param {number} [angle=0] - The angle of rotation for the element.\n * @param {ChartLocation} [newTransform=new ChartLocation(0, 0)] - The new transform location of the element.\n * @param {ChartLocation} [previousTransform=new ChartLocation(0, 0)] - The previous transform location of the element.\n * @param {boolean} [pointAnimation] - Specifies the animation based on points.\n * @returns {void}\n */\nfunction animateRedrawElement(element, duration, start, end, x, y, angle, newTransform, previousTransform, pointAnimation) {\n    if (x === void 0) { x = 'x'; }\n    if (y === void 0) { y = 'y'; }\n    if (angle === void 0) { angle = 0; }\n    if (newTransform === void 0) { newTransform = new ChartLocation(0, 0); }\n    if (previousTransform === void 0) { previousTransform = new ChartLocation(0, 0); }\n    var isDiv = element.tagName === 'DIV';\n    var setStyle = function (xValue, yValue, rotateX, rotateY) {\n        if (isDiv) {\n            element.style[x] = xValue + 'px';\n            element.style[y] = yValue + 'px';\n        }\n        else {\n            element.setAttribute(x, xValue + '');\n            element.setAttribute(y, yValue + '');\n            if (angle && newTransform.x && newTransform.y && previousTransform.x && previousTransform.y && rotateX && rotateY) {\n                element.setAttribute('transform', 'rotate(' + angle + ',' + rotateX + ',' + rotateY + ')');\n            }\n            if (pointAnimation) {\n                element.setAttribute('transform', 'translate(' + rotateX + ',' + rotateY + ')');\n            }\n        }\n    };\n    setStyle(start.x, start.y, previousTransform.x, previousTransform.y);\n    new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div'), {\n        duration: duration,\n        progress: function (args) {\n            setStyle(linear(args.timeStamp, start.x, end.x - start.x, args.duration), linear(args.timeStamp, start.y, end.y - start.y, args.duration), linear(args.timeStamp, previousTransform.x, newTransform.x - previousTransform.x, args.duration), linear(args.timeStamp, previousTransform.y, newTransform.y - previousTransform.y, args.duration));\n        },\n        end: function () {\n            setStyle(end.x, end.y, newTransform.x, newTransform.y);\n        }\n    });\n}\n/**\n * Animates the text content of an HTML element from a start value to an end value over a specified duration.\n *\n * @param {HTMLElement} element - The HTML element whose text content will be animated.\n * @param {number} duration - The duration of the animation in milliseconds.\n * @param {number} start - The starting value of the animation.\n * @param {number} end - The ending value of the animation.\n * @param {string} customLabelFormat - A custom format string that includes a placeholder for the value.\n * @returns {void}\n */\nfunction animateTextElement(element, duration, start, end, customLabelFormat) {\n    if (element && start && end) {\n        var formatText_1 = function (value) {\n            return customLabelFormat ? customLabelFormat.replace('{value}', value.toString()) : value.toString();\n        };\n        new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div'), {\n            duration: duration,\n            progress: function (args) {\n                element.style.animation = '';\n                var progress = args.timeStamp / args.duration;\n                var currentValue = start + (end - start) * progress;\n                if (start % 1 !== 0 || end % 1 !== 0) {\n                    currentValue = parseFloat(currentValue.toFixed(1));\n                }\n                else {\n                    currentValue = Math.round(currentValue);\n                }\n                element.textContent = formatText_1(currentValue);\n            },\n            end: function () {\n                element.textContent = formatText_1(end);\n            }\n        });\n    }\n}\n/**\n * Renders a text element using the specified renderer and options.\n *\n * @param {SvgRenderer | CanvasRenderer} renderer - The renderer used for rendering.\n * @param {TextOption} option - The options for the text element.\n * @param {FontModel} font - The font settings for the text.\n * @param {string} color - The color of the text.\n * @param {HTMLElement | Element} parent - The parent element to which the text element is appended.\n * @param {boolean} [isMinus=false] - Indicates whether the text represents a negative value.\n * @param {boolean} [redraw] - Indicates whether to redraw the element.\n * @param {boolean} [isAnimate] - Indicates whether to animate the element.\n * @param {boolean} [forceAnimate=false] - Indicates whether to force animation.\n * @param {number} [animateDuration] - The duration of the animation in milliseconds.\n * @param {Rect} [seriesClipRect] - The clipping rectangle for the series.\n * @param {Size} [labelSize] - The size of the label.\n * @param {boolean} [isRotatedLabelIntersect] - Indicates whether rotated labels intersect.\n * @param {boolean} [isCanvas] - Indicates whether the rendering is done on a canvas.\n * @param {boolean} [isDataLabelWrap] - Indicates whether data labels are wrapped.\n * @param {FontModel} [themeFontStyle] - The font settings based on the theme.\n * @param {ChartLocation} [transform] - The location to transform the text element.\n * @param {string} [previousTransform] - The previous transform of the text element.\n * @returns {Element} - The rendered text element.\n */\nfunction textElement(renderer, option, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration, seriesClipRect, labelSize, isRotatedLabelIntersect, isCanvas, isDataLabelWrap, themeFontStyle, transform, previousTransform) {\n    if (isMinus === void 0) { isMinus = false; }\n    if (forceAnimate === void 0) { forceAnimate = false; }\n    var renderOptions = {};\n    var tspanElement;\n    //let renderer: SvgRenderer = new SvgRenderer('');\n    var height;\n    var dy;\n    var label;\n    var width = 0;\n    var dx;\n    var maxWidth = 0;\n    if (option.text.length > 1 && isDataLabelWrap) {\n        for (var i = 0, len = option.text.length; i < len; i++) {\n            maxWidth = Math.max(maxWidth, (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(option.text[i], font, themeFontStyle).width);\n        }\n        width = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(option.text[0], font, themeFontStyle).width;\n    }\n    dx = (option.text.length > 1 && isDataLabelWrap) ? (option.x + maxWidth / 2 - width / 2) : option.x;\n    renderOptions = {\n        'id': option.id,\n        'x': dx,\n        'y': option.y,\n        'fill': color ? color : 'black',\n        'font-size': font.size || themeFontStyle.size,\n        'font-style': font.fontStyle || themeFontStyle.fontStyle,\n        'font-family': font.fontFamily || themeFontStyle.fontFamily,\n        'font-weight': font.fontWeight || themeFontStyle.fontWeight,\n        'text-anchor': option.anchor,\n        'labelRotation': option.labelRotation,\n        'transform': option.transform,\n        'opacity': font.opacity,\n        'dominant-baseline': option.baseLine\n    };\n    var text = typeof option.text === 'string' ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];\n    var transX = seriesClipRect ? seriesClipRect.x : 0;\n    var transY = seriesClipRect ? seriesClipRect.y : 0;\n    var htmlObject = renderer.createText(renderOptions, text, transX, transY);\n    if (typeof option.text !== 'string' && option.text.length > 1) {\n        for (var i = 1, len = option.text.length; i < len; i++) {\n            height = ((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(option.text[i], font, themeFontStyle).height);\n            width = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(option.text[i], font, themeFontStyle).width;\n            dy = (option.y) + ((isMinus) ? -(i * height) : (i * height));\n            dx = isDataLabelWrap ? (option.x + maxWidth / 2 - width / 2) : option.x;\n            label = isMinus ? option.text[option.text.length - (i + 1)] : option.text[i];\n            if (isCanvas) {\n                tspanElement = renderer.createText(renderOptions, label, null, null, dy, true);\n            }\n            else {\n                tspanElement = renderer.createTSpan({\n                    'x': dx, 'id': option.id,\n                    'y': dy\n                }, label);\n                htmlObject.appendChild(tspanElement);\n            }\n        }\n    }\n    if (!isRotatedLabelIntersect) {\n        appendChildElement(renderer instanceof _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.CanvasRenderer, parent, htmlObject, redraw, isAnimate, 'x', 'y', null, null, forceAnimate, false, null, animateDuration, false, option.labelRotation, transform, previousTransform);\n    }\n    return htmlObject;\n}\n/**\n * Calculates the size of the chart.\n *\n * @param {Chart | AccumulationChart | RangeNavigator | StockChart | Chart3D | CircularChart3D} chart - The chart for which to calculate the size.\n * @returns {void}\n */\nfunction calculateSize(chart) {\n    // fix for Chart rendered with default width in IE issue\n    var containerWidth = chart.element.clientWidth || chart.element.offsetWidth;\n    var containerHeight = chart.element.clientHeight;\n    if (chart.stockChart) {\n        containerWidth = chart.stockChart.availableSize.width;\n        containerHeight = chart.stockChart.availableSize.height;\n    }\n    var height = 450;\n    var marginHeight;\n    if (chart.getModuleName() === 'rangeNavigator') {\n        var range = chart;\n        var tooltipSpace = range.tooltip.enable ? 35 : 0;\n        var periodHeight = range.periodSelectorSettings.periods.length ?\n            range.periodSelectorSettings.height : 0;\n        marginHeight = range.margin.top + range.margin.bottom + tooltipSpace;\n        var labelSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)('tempString', range.labelStyle, range.themeStyle.axisLabelFont).height;\n        var labelPadding = 15;\n        height = (chart.series.length ? (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice ? 80 : 120) : ((range.enableGrouping ? (40 + labelPadding + labelSize) : 40)\n            + marginHeight)) + periodHeight;\n        if (range.disableRangeSelector) {\n            height = periodHeight;\n        }\n        if (chart.stockChart && chart.stockChart.chart && chart.stockChart.chart.axisCollections[1].labelPosition === 'Outside') {\n            var padding = chart.stockChart.chart.axisCollections[1].labelPadding +\n                chart.stockChart.chart.axisCollections[1].lineStyle.width * 0.5;\n            chart.width = (chart.stockChart.availableSize.width -\n                (chart.stockChart.chart.axisCollections[1].maxLabelSize.width + padding)).toString();\n        }\n    }\n    chart.availableSize = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.Size(stringToNumber(chart.width, containerWidth) || containerWidth || 600, stringToNumber(chart.height, containerHeight || height) || containerHeight || height);\n    if (chart.getModuleName() === 'chart') {\n        chart.scaleX = 1;\n        chart.scaleY = 1;\n    }\n}\n/**\n * Creates an SVG element for the specified chart or chart element.\n *\n * @param {Chart | AccumulationChart | RangeNavigator | Chart3D | CircularChart3D} chart - The chart or chart element for which to create the SVG element.\n * @returns {void}\n */\nfunction createSvg(chart) {\n    chart.canvasRender = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.CanvasRenderer(chart.element.id);\n    chart.renderer = chart.enableCanvas ? chart.canvasRender : new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.SvgRenderer(chart.element.id);\n    calculateSize(chart);\n    if (chart.stockChart && chart.getModuleName() === 'chart') {\n        chart.svgObject = chart.stockChart.chartObject;\n    }\n    else if (chart.stockChart && chart.getModuleName() === 'rangeNavigator' && chart.stockChart.selectorObject) {\n        chart.svgObject = chart.stockChart.selectorObject;\n    }\n    else {\n        if (chart.enableCanvas) {\n            chart.svgObject = chart.renderer.createCanvas({\n                id: chart.element.id + '_canvas',\n                width: chart.availableSize.width,\n                height: chart.availableSize.height\n            });\n        }\n        else {\n            chart.svgObject = chart.renderer.createSvg({\n                id: chart.element.id + '_svg',\n                width: chart.availableSize.width,\n                height: chart.availableSize.height\n            });\n        }\n    }\n    if (chart.enableCanvas) {\n        chart.renderer.ctx.direction = chart.enableRtl ? 'rtl' : 'ltr';\n    }\n}\n/**\n * Gets the title text with specified style and width, and supports right-to-left rendering.\n *\n * @param {string} title - The title text.\n * @param {FontModel} style - The font style for the title.\n * @param {number} width - The width available for rendering the title.\n * @param {boolean} isRtlEnabled - Specifies whether right-to-left rendering is enabled.\n * @param {FontModel} [themeFontStyle] - The font style used for theme rendering.\n * @returns {string[]} An array of strings containing the title text with line breaks if needed.\n */\nfunction getTitle(title, style, width, isRtlEnabled, themeFontStyle) {\n    var titleCollection = [];\n    switch (style.textOverflow) {\n        case 'Wrap':\n            titleCollection = textWrap(title, width, style, isRtlEnabled, title.indexOf(' ') < 0 ? true : null, null, themeFontStyle);\n            break;\n        case 'Trim':\n            titleCollection.push(textTrim(width, title, style, isRtlEnabled, themeFontStyle));\n            break;\n        default:\n            titleCollection.push(title);\n            break;\n    }\n    return titleCollection;\n}\n/**\n * Calculates the x-coordinate position for rendering the title text within the specified rect.\n *\n * @param {Rect} rect - The rect within which the title text is to be rendered.\n * @param {FontModel} titleStyle - The font style used for rendering the title text.\n * @returns {number} The x-coordinate position for rendering the title text.\n */\nfunction titlePositionX(rect, titleStyle) {\n    var positionX;\n    if (titleStyle.textAlignment === 'Near') {\n        positionX = rect.x;\n    }\n    else if (titleStyle.textAlignment === 'Center') {\n        positionX = rect.x + rect.width / 2;\n    }\n    else {\n        positionX = rect.x + rect.width;\n    }\n    return positionX;\n}\n/**\n * Wraps the input text into multiple lines based on the specified maximum width and font style.\n *\n * @param {string} currentLabel - The text to be wrapped.\n * @param {number} maximumWidth - The maximum width allowed for each line of text.\n * @param {FontModel} font - The font style used for rendering the text.\n * @param {boolean} isRtlEnabled - Specifies whether right-to-left text direction is enabled.\n * @param {boolean} [wrapAnyWhere=false] - Indicates whether the text can be wrapped at any position.\n * @param {boolean} [clip=false] - Specifies whether text exceeding the maximum width should be clipped.\n * @param {FontModel} [themeFontStyle] - The font style used as the base for the text wrapping operation.\n * @param {number} [maximumLabelHeight] - The total height available for the wrapped text.\n * @returns {string[]} An array of strings representing the wrapped lines of text.\n */\nfunction textWrap(currentLabel, maximumWidth, font, isRtlEnabled, wrapAnyWhere, clip, themeFontStyle, maximumLabelHeight) {\n    if (wrapAnyWhere) {\n        return (textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle));\n    }\n    var textCollection = currentLabel.split(' ');\n    var label = '';\n    var labelCollection = [];\n    var text;\n    var lineHeight = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)('chartMeasureText', font, themeFontStyle).height;\n    var textHeight = 0;\n    for (var i = 0, len = textCollection.length; i < len; i++) {\n        text = textCollection[i];\n        if ((0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(label.concat(label === '' ? '' : ' ' + text), font, themeFontStyle).width < maximumWidth) {\n            label = label.concat((label === '' ? '' : ' ') + text);\n        }\n        else {\n            if (label !== '') {\n                textHeight += lineHeight;\n                if (maximumLabelHeight && textHeight > maximumLabelHeight) {\n                    labelCollection[labelCollection.length - 1] += '...';\n                    return labelCollection;\n                }\n                labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));\n                label = text;\n            }\n            else {\n                textHeight += lineHeight;\n                if (maximumLabelHeight && textHeight > maximumLabelHeight) {\n                    labelCollection[labelCollection.length - 1] += '...';\n                    return labelCollection;\n                }\n                labelCollection.push(clip ? text : textTrim(maximumWidth, text, font, isRtlEnabled, themeFontStyle));\n            }\n        }\n        if (label && i === len - 1) {\n            textHeight += lineHeight;\n            if (maximumLabelHeight && textHeight > maximumLabelHeight) {\n                labelCollection[labelCollection.length - 1] += '...';\n                return labelCollection;\n            }\n            labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));\n        }\n    }\n    return labelCollection;\n}\n/**\n * Wraps the input text into multiple lines, allowing wrapping at any position.\n *\n * @param {string} currentLabel - The text to be wrapped.\n * @param {number} maximumWidth - The maximum width allowed for each line of text.\n * @param {FontModel} font - The font style used for rendering the text.\n * @param {FontModel} [themeFontStyle] - The font style used as the base for the text wrapping operation.\n * @returns {string[]} An array of strings representing the wrapped lines of text.\n * @private\n */\nfunction textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle) {\n    var size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(currentLabel, font, themeFontStyle).width;\n    var labelCollection = [];\n    if (size > maximumWidth) {\n        var label = '';\n        var startIndex = 0;\n        var labelIndex = 1;\n        while (labelIndex < currentLabel.length) {\n            label = currentLabel.substring(startIndex, labelIndex);\n            size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.measureText)(label, font, themeFontStyle).width;\n            if (size < maximumWidth) {\n                labelIndex++;\n            }\n            else if (size === maximumWidth) {\n                startIndex = labelIndex;\n                labelCollection.push(label);\n                labelIndex++;\n                label = '';\n            }\n            else if (size > maximumWidth) {\n                label = label.slice(0, -1);\n                startIndex = labelIndex - 1;\n                labelCollection.push(label);\n                label = '';\n            }\n        }\n        if (label.length > 0) {\n            labelCollection.push(label);\n        }\n    }\n    else {\n        labelCollection.push(currentLabel);\n    }\n    return labelCollection;\n}\n/**\n * Gets the Unicode text from the input string based on the provided regular expression.\n *\n * @param {string} text - The input string.\n * @param {RegExp} regexp - The regular expression pattern to match Unicode characters.\n * @returns {string} The Unicode text extracted from the input string.\n */\nfunction getUnicodeText(text, regexp) {\n    var title = text.replace(regexp, ' ');\n    var digit = text.match(regexp);\n    var digitSpecific = ' ';\n    var convertedText = ' ';\n    var k = 0;\n    var unicodeSub = {\n        '0': '\\u2080', '1': '\\u2081', '2': '\\u2082', '3': '\\u2083', '4': '\\u2084',\n        '5': '\\u2085', '6': '\\u2086', '7': '\\u2087', '8': '\\u2088', '9': '\\u2089'\n    };\n    var unicodeSup = {\n        '0': '\\u2070', '1': '\\u00B9', '2': '\\u00B2', '3': '\\u00B3', '4': '\\u2074',\n        '5': '\\u2075', '6': '\\u2076', '7': '\\u2077', '8': '\\u2078', '9': '\\u2079'\n    };\n    for (var i = 0; i <= title.length - 1; i++) {\n        if (title[i] === ' ') {\n            digitSpecific = (regexp === _model_constants__WEBPACK_IMPORTED_MODULE_3__.regSub) ? digit[k].replace(/~/g, '') : digit[k].replace(/\\^/g, '');\n            for (var j = 0; j < digitSpecific.length; j++) {\n                convertedText += (regexp === _model_constants__WEBPACK_IMPORTED_MODULE_3__.regSub) ? unicodeSub[digitSpecific[j]] : unicodeSup[digitSpecific[j]];\n            }\n            k++;\n        }\n        else {\n            convertedText += title[i];\n        }\n    }\n    return convertedText.trim();\n}\n/**\n * Resets the Blazor templates of the given control (Chart or AccumulationChart).\n *\n * @param {Chart | AccumulationChart} control - The control to reset Blazor templates for.\n * @returns {void}\n */\nfunction blazorTemplatesReset(control) {\n    for (var i = 0; i < control.annotations.length; i++) {\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.resetBlazorTemplate)((control.element.id + '_Annotation_' + i).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate');\n    }\n    //This reset the tooltip templates\n    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.resetBlazorTemplate)(control.element.id + '_tooltipparent_template' + '_blazorTemplate', 'Template');\n    //Datalabel templates reset\n    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.resetBlazorTemplate)(control.element.id + '_DataLabel');\n}\n/** @private */\nvar CustomizeOption = /** @class */ (function () {\n    function CustomizeOption(id) {\n        this.id = id;\n    }\n    return CustomizeOption;\n}());\n\n/** @private */\nvar StackValues = /** @class */ (function () {\n    function StackValues(startValue, endValue) {\n        this.startValues = startValue;\n        this.endValues = endValue;\n    }\n    return StackValues;\n}());\n\n/** @private */\nvar RectOption = /** @class */ (function (_super) {\n    __extends(RectOption, _super);\n    function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {\n        var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;\n        _this.y = rect.y;\n        _this.x = rect.x;\n        _this.height = rect.height;\n        _this.width = rect.width;\n        _this.rx = rx ? rx : 0;\n        _this.ry = ry ? ry : 0;\n        _this.transform = transform ? transform : '';\n        _this.stroke = (border.width !== 0 && _this.stroke !== '') ? border.color === null ? '' : border.color : 'transparent';\n        return _this;\n    }\n    return RectOption;\n}(_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.PathOption));\n\n/** @private */\nvar ImageOption = /** @class */ (function () {\n    function ImageOption(height, width, href, x, y, id, visibility, preserveAspectRatio) {\n        this.height = height;\n        this.width = width;\n        this.href = href;\n        this.x = x;\n        this.y = y;\n        this.id = id;\n        this.visibility = visibility;\n        this.preserveAspectRatio = preserveAspectRatio;\n    }\n    return ImageOption;\n}());\n\n/** @private */\nvar CircleOption = /** @class */ (function (_super) {\n    __extends(CircleOption, _super);\n    function CircleOption(id, fill, border, opacity, cx, cy, r) {\n        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;\n        _this.cy = cy;\n        _this.cx = cx;\n        _this.r = r;\n        return _this;\n    }\n    return CircleOption;\n}(_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_4__.PathOption));\n\n/** @private */\nvar PolygonOption = /** @class */ (function () {\n    function PolygonOption(id, points, fill) {\n        this.id = id;\n        this.points = points;\n        this.fill = fill;\n    }\n    return PolygonOption;\n}());\n\n/** @private */\nvar ChartLocation = /** @class */ (function () {\n    function ChartLocation(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    return ChartLocation;\n}());\n\n/** @private */\nvar LabelLocation = /** @class */ (function () {\n    function LabelLocation(x, y) {\n        this.x = 0;\n        this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    return LabelLocation;\n}());\n\n/** @private */\nvar Thickness = /** @class */ (function () {\n    function Thickness(left, right, top, bottom) {\n        this.left = left;\n        this.right = right;\n        this.top = top;\n        this.bottom = bottom;\n    }\n    return Thickness;\n}());\n\n/** @private */\nvar ColorValue = /** @class */ (function () {\n    function ColorValue(r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n    return ColorValue;\n}());\n\n/** @private */\nvar PointData = /** @class */ (function () {\n    function PointData(point, series, index) {\n        if (index === void 0) { index = 0; }\n        this.point = point;\n        this.series = series;\n        this.lierIndex = index;\n    }\n    return PointData;\n}());\n\n/** @private */\nvar AccPointData = /** @class */ (function () {\n    function AccPointData(point, series, index) {\n        if (index === void 0) { index = 0; }\n        this.point = point;\n        this.series = series;\n        this.index = index;\n    }\n    return AccPointData;\n}());\n\n/** @private */\nvar Point3D = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the Chart3DData class.\n     *\n     * @param {Chart3DPoint} point - The 3D point object.\n     * @param {Chart3DSeries} series - The 3D series object.\n     * @private\n     */\n    function Point3D(point, series) {\n        this.point = point;\n        this.series = series;\n    }\n    return Point3D;\n}());\n\n/** @private */\nvar ControlPoints = /** @class */ (function () {\n    function ControlPoints(controlPoint1, controlPoint2) {\n        this.controlPoint1 = controlPoint1;\n        this.controlPoint2 = controlPoint2;\n    }\n    return ControlPoints;\n}());\n\n/**\n * Gets the color from the range color setting model based on the specified value.\n *\n * @param {RangeColorSettingModel} colorMap - The range color setting model.\n * @param {number} value - The value for which to get the color.\n * @returns {string} - The color corresponding to the specified value.\n */\nfunction getColorByValue(colorMap, value) {\n    var color = '';\n    var rbgColorValue;\n    if (Number(value) === colorMap.start) {\n        color = colorMap.colors[0];\n    }\n    else if (Number(value) === colorMap.end) {\n        color = colorMap.colors[colorMap.colors.length - 1];\n    }\n    else {\n        rbgColorValue = getGradientColor(Number(value), colorMap);\n        color = convertToHexCode(rbgColorValue);\n    }\n    return color;\n}\n/**\n * Gets the gradient color from the range color setting model based on the specified value.\n *\n * @param {number} value - The value for which to get the gradient color.\n * @param {RangeColorSettingModel} colorMap - The range color setting model.\n * @returns {ColorValue} - The gradient color corresponding to the specified value.\n */\nfunction getGradientColor(value, colorMap) {\n    var previousOffset = colorMap.start;\n    var nextOffset = colorMap.end;\n    var percent = 0;\n    var full = nextOffset - previousOffset;\n    var midColor;\n    percent = (value - previousOffset) / full;\n    var previousColor;\n    var nextColor;\n    if (colorMap.colors.length <= 2) {\n        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);\n        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?\n            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);\n    }\n    else {\n        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);\n        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?\n            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);\n        var a = full / (colorMap.colors.length - 1);\n        var b = void 0;\n        var c = void 0;\n        var length_2 = colorMap.colors.length - 1;\n        var splitColorValueOffset = [];\n        var splitColor = {};\n        for (var j = 1; j < length_2; j++) {\n            c = j * a;\n            b = previousOffset + c;\n            splitColor = { b: b, color: colorMap.colors[j] };\n            splitColorValueOffset.push(splitColor);\n        }\n        for (var i = 0; i < splitColorValueOffset.length; i++) {\n            if (previousOffset <= value && value <= splitColorValueOffset[i]['b'] && i === 0) {\n                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\n                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n                nextColor = midColor;\n                percent = value <= splitColorValueOffset[i]['b'] ? 1 - Math.abs((value - splitColorValueOffset[i]['b']) / a)\n                    : (value - splitColorValueOffset[i]['b']) / a;\n            }\n            else if (splitColorValueOffset[i]['b'] <= value && value <= nextOffset && i === (splitColorValueOffset.length - 1)) {\n                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\n                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n                previousColor = midColor;\n                percent = value < splitColorValueOffset[i]['b'] ?\n                    1 - Math.abs((value - splitColorValueOffset[i]['b']) / a) : (value - splitColorValueOffset[i]['b']) / a;\n            }\n            if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {\n                if (splitColorValueOffset[i]['b'] <= value && value <= splitColorValueOffset[i + 1]['b']) {\n                    midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\n                        splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n                    previousColor = midColor;\n                    nextColor = splitColorValueOffset[i + 1]['color'].charAt(0) === '#' ?\n                        splitColorValueOffset[i + 1]['color'] : colorNameToHex(splitColorValueOffset[i + 1]['color']);\n                    percent = Math.abs((value - splitColorValueOffset[i + 1]['b'])) / a;\n                }\n            }\n        }\n    }\n    return getPercentageColor(percent, previousColor, nextColor);\n}\n/**\n * Calculates the color based on the percentage change between two values.\n *\n * @param {number} percent - The percentage change.\n * @param {string} previous - The color for the previous value.\n * @param {string} next - The color for the next value.\n * @returns {ColorValue} - The calculated color value.\n */\nfunction getPercentageColor(percent, previous, next) {\n    var nextColor = next.split('#')[1];\n    var prevColor = previous.split('#')[1];\n    var r = getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));\n    var g = getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));\n    var b = getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));\n    return new ColorValue(r, g, b);\n}\n/**\n * Calculates the percentage change between two values.\n *\n * @param {number} percent - The percentage to calculate.\n * @param {number} previous - The previous value.\n * @param {number} next - The next value.\n * @returns {number} - The calculated percentage change.\n */\nfunction getPercentage(percent, previous, next) {\n    var full = next - previous;\n    return Math.round((previous + (full * percent)));\n}\n/**\n * Gets the text anchor based on the specified alignment and Right-to-Left setting.\n *\n * @param {Alignment} alignment - The alignment of the text.\n * @param {boolean} enableRtl - Specifies whether Right-to-Left is enabled.\n * @returns {string} - The text anchor value.\n */\nfunction getTextAnchor(alignment, enableRtl) {\n    switch (alignment) {\n        case 'Near':\n            return enableRtl ? 'end' : 'start';\n        case 'Far':\n            return enableRtl ? 'start' : 'end';\n        default:\n            return 'middle';\n    }\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js?");

/***/ })

}]);