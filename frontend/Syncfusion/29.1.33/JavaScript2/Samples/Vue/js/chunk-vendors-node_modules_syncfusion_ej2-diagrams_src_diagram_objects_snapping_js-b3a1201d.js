"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_objects_snapping_js-b3a1201d"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/snapping.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/snapping.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snapping: () => (/* binding */ Snapping)\n/* harmony export */ });\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _interaction_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../interaction/actions */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/actions.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _core_elements_html_element__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/elements/html-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/html-element.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Snapping\n */\nvar Snapping = /** @class */ (function () {\n    function Snapping(diagram) {\n        this.line = [];\n        this.diagram = diagram;\n    }\n    /** @private */\n    Snapping.prototype.canSnap = function () {\n        return (this.diagram.snapSettings.constraints\n            & (_enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToLines)) !== 0;\n    };\n    Snapping.prototype.getWrapperObject = function (selectedObject, nameTable) {\n        if (selectedObject.nodes && selectedObject.nodes.length > 0\n            && (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToLines || this.diagram.snapSettings.constraints\n                & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject)) {\n            for (var i = 0; i < selectedObject.nodes.length; i++) {\n                if (((selectedObject.nodes[parseInt(i.toString(), 10)].shape.type === 'SwimLane' || selectedObject.nodes[parseInt(i.toString(), 10)].isLane)\n                    || selectedObject.nodes[parseInt(i.toString(), 10)].parentId !== ''\n                        && nameTable[(selectedObject.nodes[parseInt(i.toString(), 10)].parentId)]\n                        && nameTable[(selectedObject.nodes[parseInt(i.toString(), 10)].parentId)].isLane) && nameTable['helper']) {\n                    return nameTable['helper'].wrapper;\n                }\n                else {\n                    return selectedObject.wrapper;\n                }\n            }\n        }\n        return selectedObject.wrapper;\n    };\n    Snapping.prototype.setSnapLineColor = function () {\n        return this.diagram.snapSettings.snapLineColor;\n    };\n    /**\n     * Snap to object\n     *\n     * @private\n     */\n    Snapping.prototype.snapPoint = function (diagram, selectedObject, towardsLeft, towardsTop, delta, startPoint, endPoint) {\n        var snapSettings = this.diagram.snapSettings;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        var offset = { x: 0, y: 0 };\n        var wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(wrapper);\n        var horizontallysnapped = { snapped: false, offset: 0 };\n        var verticallysnapped = { snapped: false, offset: 0 };\n        if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject) {\n            //let snapLine: SVGElement;\n            var snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            snapLine.setAttribute('id', '_SnappingLines');\n            snapLine.setAttribute('shapeRendering', 'crispEdges');\n            this.getAdornerLayerSvg().appendChild(snapLine);\n            this.snapObject(diagram, selectedObject, snapLine, horizontallysnapped, verticallysnapped, delta, startPoint === endPoint);\n        }\n        //original position\n        var left = bounds.x + delta.x;\n        var top = bounds.y + delta.y;\n        var right = bounds.x + bounds.width + delta.x;\n        var bottom = bounds.y + bounds.height + delta.y;\n        var scaledIntervals = snapSettings.verticalGridlines.scaledIntervals;\n        //snapped positions\n        var roundedRight = this.round(right, scaledIntervals, zoomFactor);\n        var roundedLeft = this.round(left, scaledIntervals, zoomFactor);\n        scaledIntervals = snapSettings.horizontalGridlines.scaledIntervals;\n        var roundedTop = this.round(top, scaledIntervals, zoomFactor);\n        var roundedBottom = this.round(bottom, scaledIntervals, zoomFactor);\n        //currentposition\n        var currentright = bounds.x + bounds.width;\n        var currentbottom = bounds.y + bounds.height;\n        if (!horizontallysnapped.snapped) {\n            if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToVerticalLines) {\n                if (Math.abs(delta.x) >= 1) {\n                    if (towardsLeft) {\n                        if (Math.abs(roundedRight - currentright) > Math.abs(roundedLeft - bounds.x)) {\n                            offset.x += roundedLeft - bounds.x;\n                        }\n                        else {\n                            offset.x += roundedRight - currentright;\n                        }\n                    }\n                    else {\n                        if (Math.abs(roundedRight - currentright) < Math.abs(roundedLeft - bounds.x)) {\n                            offset.x += roundedRight - currentright;\n                        }\n                        else {\n                            offset.x += roundedLeft - bounds.x;\n                        }\n                    }\n                }\n            }\n            else {\n                offset.x = endPoint.x - startPoint.x;\n            }\n        }\n        else {\n            if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject) {\n                offset.x = horizontallysnapped.offset;\n            }\n            else {\n                offset.x = endPoint.x - startPoint.x;\n            }\n        }\n        if (!verticallysnapped.snapped) {\n            if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToHorizontalLines) {\n                if (Math.abs(delta.y) >= 1) {\n                    if (towardsTop) {\n                        if (Math.abs(roundedBottom - currentbottom) > Math.abs(roundedTop - bounds.y)) {\n                            offset.y += roundedTop - bounds.y;\n                        }\n                        else {\n                            offset.y += roundedBottom - currentbottom;\n                        }\n                    }\n                    else {\n                        if (Math.abs(roundedBottom - currentbottom) < Math.abs(roundedTop - bounds.y)) {\n                            offset.y += roundedBottom - currentbottom;\n                        }\n                        else {\n                            offset.y += roundedTop - bounds.y;\n                        }\n                    }\n                }\n            }\n            else {\n                offset.y = endPoint.y - startPoint.y;\n            }\n        }\n        else {\n            offset.y = verticallysnapped.offset;\n        }\n        return offset;\n    };\n    /**\n     * @private\n     */\n    Snapping.prototype.round = function (value, snapIntervals, scale) {\n        if (scale === 1) {\n            scale = Math.pow(2, Math.floor(Math.log(scale) / Math.log(2)));\n        }\n        else {\n            scale = scale;\n        }\n        var cutoff = 0;\n        var i = 0;\n        for (i = 0; i < snapIntervals.length; i++) {\n            cutoff += snapIntervals[parseInt(i.toString(), 10)];\n        }\n        cutoff /= scale;\n        var quotient = Math.floor(Math.abs(value) / cutoff);\n        var bal = value % cutoff;\n        var prev = quotient * cutoff;\n        if (prev !== value) {\n            if (value >= 0) {\n                for (i = 0; i < snapIntervals.length; i++) {\n                    if (bal <= snapIntervals[parseInt(i.toString(), 10)] / scale) {\n                        return prev + (bal < (snapIntervals[parseInt(i.toString(), 10)] / (2 * scale))\n                            ? 0 : snapIntervals[parseInt(i.toString(), 10)] / scale);\n                    }\n                    else {\n                        prev += snapIntervals[parseInt(i.toString(), 10)] / scale;\n                        bal -= snapIntervals[parseInt(i.toString(), 10)] / scale;\n                    }\n                }\n            }\n            else {\n                prev = prev * -1;\n                for (i = snapIntervals.length - 1; i >= 0; i--) {\n                    if (Math.abs(bal) <= snapIntervals[parseInt(i.toString(), 10)] / scale) {\n                        return prev - (Math.abs(bal) < (snapIntervals[parseInt(i.toString(), 10)] / (2 * scale))\n                            ? 0 : snapIntervals[parseInt(i.toString(), 10)] / scale);\n                    }\n                    else {\n                        prev -= snapIntervals[parseInt(i.toString(), 10)] / scale;\n                        bal += snapIntervals[parseInt(i.toString(), 10)] / scale;\n                    }\n                }\n            }\n        }\n        return value;\n    };\n    //Snap to Object\n    Snapping.prototype.snapObject = function (diagram, selectedObject, g, horizontalSnap, verticalSnap, delta, ended) {\n        var lengthX = null;\n        var lengthY;\n        var hTarget;\n        var vTarget;\n        var scroller = this.diagram.scroller;\n        var snapSettings = this.diagram.snapSettings;\n        var objectsAtLeft = [];\n        var objectsAtRight = [];\n        var objectsAtTop = [];\n        var objectsAtBottom = [];\n        var wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(wrapper);\n        var scale = diagram.scroller.currentZoom;\n        var hoffset = -scroller.horizontalOffset;\n        var voffset = -scroller.verticalOffset;\n        var snapObjDistance = snapSettings.snapObjectDistance / scale;\n        var viewPort = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);\n        var hIntersectRect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(hoffset / scale, (bounds.y - snapObjDistance - 5), viewPort.width / scale, (bounds.height + 2 * snapObjDistance + 10));\n        var vIntersectRect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect((bounds.x - snapObjDistance - 5), voffset / scale, (bounds.width + 2 * snapObjDistance + 10), viewPort.height / scale);\n        viewPort = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);\n        var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vIntersectRect, viewPort);\n        var i;\n        var target;\n        var targetBounds;\n        var nameTable = diagram.nameTable;\n        for (i = 0; i < nodes.length; i++) {\n            target = nodes[parseInt(i.toString(), 10)];\n            if (this.canBeTarget(diagram, target)) {\n                if (!(this.diagram.nameTable[target.id] instanceof _connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && this.canConsider(nameTable, selectedObject, target)) {\n                    targetBounds = target.bounds;\n                    if (targetBounds.height + targetBounds.y < delta.y + bounds.y) {\n                        objectsAtTop.push({\n                            obj: target, distance: Math.abs(bounds.y + delta.y - targetBounds.y - targetBounds.height)\n                        });\n                    }\n                    else if (targetBounds.y > bounds.y + delta.y + bounds.height) {\n                        objectsAtBottom.push({ obj: target, distance: Math.abs(bounds.y + delta.y + bounds.height - targetBounds.y) });\n                    }\n                    if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y - delta.y)) {\n                        if (Math.abs(targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2 + delta.x)) <=\n                            snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'centerX');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'right');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x - (bounds.x + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'left');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                    }\n                }\n            }\n        }\n        nodes = this.findNodes(diagram.spatialSearch, selectedObject, hIntersectRect, viewPort);\n        for (var j = 0; j < nodes.length; j++) {\n            target = nodes[parseInt(j.toString(), 10)];\n            if (this.canBeTarget(diagram, target)) {\n                if (!(this.diagram.nameTable[target.id] instanceof _connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && this.canConsider(nameTable, selectedObject, target)) {\n                    targetBounds = target.bounds;\n                    if (targetBounds.x + targetBounds.width < bounds.x + delta.x) {\n                        objectsAtLeft[objectsAtLeft.length] = {\n                            obj: target, distance: Math.abs((bounds.x + delta.x) - targetBounds.x - targetBounds.width)\n                        };\n                    }\n                    if (targetBounds.x > bounds.x + delta.x + bounds.width) {\n                        objectsAtRight[objectsAtRight.length] = {\n                            obj: target, distance: Math.abs(bounds.x + delta.x + bounds.width - targetBounds.x)\n                        };\n                    }\n                    if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x - delta.x)) {\n                        if (Math.abs(targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2 + delta.y))\n                            <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'centerY');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y - bounds.y - delta.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'top');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y + targetBounds.height - (bounds.y + bounds.height + delta.y)) <=\n                            snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'bottom');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y + targetBounds.height - bounds.y - delta.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'topBottom');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y - (bounds.y + bounds.height + delta.y)) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'bottomTop');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                    }\n                }\n            }\n        }\n        this.createGuidelines(diagram, hTarget, vTarget, g, horizontalSnap, verticalSnap, ended);\n        if (!horizontalSnap.snapped) {\n            this.createHSpacingLines(diagram, g, selectedObject, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);\n        }\n        if (!verticalSnap.snapped) {\n            this.createVSpacingLines(diagram, g, selectedObject, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);\n        }\n    };\n    /**\n     * @private\n     */\n    Snapping.prototype.snapConnectorEnd = function (point) {\n        var snapSettings = this.diagram.snapSettings;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        if (snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToLines) {\n            point.x = this.round(point.x, snapSettings.verticalGridlines.scaledIntervals, zoomFactor);\n            point.y = this.round(point.y, snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n        }\n        return point;\n    };\n    Snapping.prototype.canBeTarget = function (diagram, node) {\n        node = this.diagram.nameTable[node.id];\n        return !((0,_interaction_actions__WEBPACK_IMPORTED_MODULE_6__.isSelected)(this.diagram, node, false));\n    };\n    Snapping.prototype.snapSize = function (diagram, horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, selectedObject, ended) {\n        var lengthX;\n        var lengthY;\n        var snapSettings = this.diagram.snapSettings;\n        var scroller = this.diagram.scroller;\n        var hTarget;\n        var vTarget;\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(selectedObject.wrapper);\n        var nameTable = diagram.nameTable;\n        var sameWidth = [];\n        var sameHeight = [];\n        var scale = diagram.scroller.currentZoom;\n        var hoffset = -scroller.horizontalOffset;\n        var voffset = -scroller.verticalOffset;\n        var snapObjDistance = snapSettings.snapObjectDistance / scale;\n        var viewPort = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);\n        var hintersectedrect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(hoffset / scale, (bounds.y - 5) / scale, viewPort.width / scale, (bounds.height + 10) / scale);\n        var vintersectedrect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect((bounds.x - 5) / scale, voffset / scale, (bounds.width + 10) / scale, viewPort.height / scale);\n        viewPort = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);\n        var nodesInView = [];\n        var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vintersectedrect, viewPort, nodesInView);\n        var i;\n        var target;\n        var targetBounds;\n        for (i = 0; i < nodes.length; i++) {\n            target = nodes[parseInt(i.toString(), 10)];\n            if (this.canConsider(nameTable, selectedObject, target) && !(this.diagram.nameTable[target.id] instanceof _connector__WEBPACK_IMPORTED_MODULE_3__.Connector)) {\n                targetBounds = target.bounds;\n                if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y)) {\n                    if (horizontalSnap.left) {\n                        if (Math.abs(bounds.x + deltaX - targetBounds.x) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'left');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(bounds.x + deltaX - targetBounds.x - targetBounds.width) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                    }\n                    else if (horizontalSnap.right) {\n                        if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x - targetBounds.width) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'right');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                    }\n                }\n            }\n        }\n        nodes = this.findNodes(diagram.spatialSearch, selectedObject, hintersectedrect, viewPort);\n        for (var i_1 = 0; i_1 < nodes.length; i_1++) {\n            var target_1 = nodes[parseInt(i_1.toString(), 10)];\n            if (this.canConsider(nameTable, selectedObject, target_1) && !(this.diagram.nameTable[target_1.id] instanceof _connector__WEBPACK_IMPORTED_MODULE_3__.Connector)) {\n                var targetBounds_1 = target_1.bounds;\n                if (lengthY == null || lengthY > Math.abs(targetBounds_1.x - bounds.x)) {\n                    if (verticalSnap.top) {\n                        if (Math.abs(bounds.y + deltaY - targetBounds_1.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'top');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                        else if (Math.abs(bounds.y + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'topBottom');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                    }\n                    else if (verticalSnap.bottom) {\n                        if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottom');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                        else if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottomTop');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                    }\n                }\n            }\n        }\n        for (i = 0; i < nodesInView.length; i++) {\n            target = nodesInView[parseInt(i.toString(), 10)];\n            if (this.canConsider(nameTable, selectedObject, target)) {\n                var targetBounds_2 = target.bounds;\n                var delta = horizontalSnap.left ? -deltaX : deltaX;\n                var difference = Math.abs(bounds.width + delta - targetBounds_2.width);\n                var actualDiff = void 0;\n                if (difference <= snapObjDistance) {\n                    actualDiff = horizontalSnap.left ? -targetBounds_2.width + bounds.width : targetBounds_2.width - bounds.width;\n                    sameWidth[sameWidth.length] = { source: target, difference: difference, offset: actualDiff };\n                }\n                delta = verticalSnap.top ? -deltaY : deltaY;\n                var dify = Math.abs(bounds.height + delta - targetBounds_2.height);\n                if (dify <= snapObjDistance) {\n                    actualDiff = verticalSnap.top ? -targetBounds_2.height + bounds.height : targetBounds_2.height - bounds.height;\n                    sameHeight[sameHeight.length] = { source: target, difference: dify, offset: actualDiff };\n                }\n            }\n        }\n        var g;\n        if (!diagram.getTool) {\n            var g_1 = this.createGuidelines(diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended);\n        }\n        if (!horizontalSnap.snapped && sameWidth.length > 0 && (horizontalSnap.left || horizontalSnap.right)) {\n            this.addSameWidthLines(diagram, snapLine, sameWidth, horizontalSnap, ended, selectedObject);\n        }\n        if (!verticalSnap.snapped && sameHeight.length > 0 && (verticalSnap.top || verticalSnap.bottom)) {\n            this.addSameHeightLines(diagram, snapLine, sameHeight, verticalSnap, ended, selectedObject);\n        }\n    };\n    /**\n     * Snap to object on top\n     *\n     * @private\n     */\n    Snapping.prototype.snapTop = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsT) {\n        var dify = deltaY;\n        verticalSnap.top = true;\n        var y;\n        horizontalSnap.left = horizontalSnap.right = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        //let initialBoundsT: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            y = initialBoundsT.y - initialBoundsT.height * shape.pivot.y + deltaY - (shape.offsetY - shape.height * shape.pivot.y);\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);\n        }\n        if (!verticalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToHorizontalLines) {\n                var top_1 = initialBoundsT.y - initialBoundsT.height * shape.pivot.y;\n                var actualTop = top_1 + deltaY;\n                var roundedTop = this.round(actualTop, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n                dify = roundedTop - top_1;\n            }\n        }\n        else {\n            dify = (deltaY - y) + verticalSnap.offset;\n        }\n        return dify;\n    };\n    /**\n     * Snap to object on right\n     *\n     * @private\n     */\n    Snapping.prototype.snapRight = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBound) {\n        var difx = deltaX;\n        var x;\n        horizontalSnap.right = true;\n        verticalSnap.top = verticalSnap.bottom = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        //let initialBound: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            x = initialBound.x + initialBound.width * (1 - shape.pivot.x) + deltaX - (shape.offsetX + shape.width * (1 - shape.pivot.x));\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);\n        }\n        if (!horizontalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToVerticalLines) {\n                var right = initialBound.x + initialBound.width * (1 - shape.pivot.x);\n                var actualRight = right + deltaX;\n                var roundedRight = this.round(actualRight, this.diagram.snapSettings.verticalGridlines.scaledIntervals, zoomFactor);\n                difx = roundedRight - right;\n            }\n        }\n        else {\n            difx = (deltaX - x) + horizontalSnap.offset;\n        }\n        return difx;\n    };\n    /**\n     * Snap to object on left\n     *\n     * @private\n     */\n    Snapping.prototype.snapLeft = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsB) {\n        var difx = deltaX;\n        var x = 0;\n        horizontalSnap.left = true;\n        verticalSnap.top = verticalSnap.bottom = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        //let initialBoundsB: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            x = initialBoundsB.x - initialBoundsB.width * shape.pivot.x + deltaX - (shape.offsetX - shape.width * shape.pivot.x);\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);\n        }\n        if (!horizontalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToVerticalLines) {\n                var left = initialBoundsB.x - initialBoundsB.width * shape.pivot.x;\n                var actualLeft = left + deltaX;\n                var roundedLeft = this.round(actualLeft, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n                difx = roundedLeft - left;\n            }\n        }\n        else {\n            difx = (deltaX - x) + horizontalSnap.offset;\n        }\n        return difx;\n    };\n    /**\n     * Snap to object on bottom\n     *\n     * @private\n     */\n    Snapping.prototype.snapBottom = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialRect) {\n        var dify = deltaY;\n        verticalSnap.bottom = true;\n        horizontalSnap.left = horizontalSnap.right = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        var y = 0;\n        //let initialRect: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            y = initialRect.y + initialRect.height * (1 - shape.pivot.y) + deltaY - (shape.offsetY + shape.height * (1 - shape.pivot.y));\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);\n        }\n        // eslint-disable-next-line max-len\n        var bounds = ((shape instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_7__.TextElement) || (shape instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_8__.DiagramHtmlElement)) ? (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(shape) :\n            (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(shape.wrapper);\n        if (!verticalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToHorizontalLines) {\n                var bottom = initialRect.y + initialRect.height * (1 - shape.pivot.y);\n                var actualBottom = bottom + deltaY;\n                var roundedBottom = this.round(actualBottom, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n                dify = roundedBottom - bottom;\n            }\n        }\n        else {\n            dify = (deltaY - y) + verticalSnap.offset;\n        }\n        return dify;\n    };\n    //To create the same width and same size lines\n    Snapping.prototype.createGuidelines = function (diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended) {\n        if (hTarget) {\n            horizontalSnap.offset = hTarget.offsetX;\n            horizontalSnap.snapped = true;\n            if (!ended) {\n                if (hTarget.type === 'sideAlign') {\n                    this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);\n                }\n                else {\n                    this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);\n                }\n            }\n        }\n        if (vTarget) {\n            verticalSnap.offset = vTarget.offsetY;\n            verticalSnap.snapped = true;\n            if (!ended) {\n                if (vTarget.type === 'sideAlign') {\n                    this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);\n                }\n                else {\n                    this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);\n                }\n            }\n        }\n        return snapLine;\n    };\n    //To create the alignment lines\n    Snapping.prototype.renderAlignmentLines = function (start, end, svg, transform) {\n        start = {\n            x: (start.x + transform.tx) * transform.scale,\n            y: (start.y + transform.ty) * transform.scale\n        };\n        end = {\n            x: (end.x + transform.tx) * transform.scale,\n            y: (end.y + transform.ty) * transform.scale\n        };\n        var line1 = {\n            stroke: this.setSnapLineColor(), strokeWidth: 1, startPoint: { x: start.x, y: start.y },\n            endPoint: { x: end.x, y: end.y }, fill: this.setSnapLineColor(), dashArray: '', width: 1,\n            x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n            pivotY: 0, visible: true, opacity: 1, id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.randomId)()\n        };\n        var i = 0;\n        this.line.push(line1);\n        for (i = 0; i < this.line.length; i++) {\n            this.diagram.diagramRenderer.drawLine(svg, this.line.pop());\n        }\n    };\n    //To create Horizontal spacing lines\n    Snapping.prototype.createHSpacingLines = function (diagram, g, shape, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {\n        var top = 0;\n        this.sortByDistance(objectsAtLeft, 'distance', true);\n        this.sortByDistance(objectsAtRight, 'distance', true);\n        var equallySpaced = [];\n        var bounds;\n        if (diagram.selectedObject.helperObject) {\n            bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(diagram.selectedObject.helperObject.wrapper);\n        }\n        else {\n            bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(shape.wrapper);\n        }\n        var nearestleft;\n        var nearestright;\n        var targetBounds;\n        var equaldistance;\n        if (objectsAtLeft.length > 0) {\n            equallySpaced[equallySpaced.length] = objectsAtLeft[0];\n            nearestleft = ((objectsAtLeft[0].obj).bounds);\n            top = nearestleft.y;\n            if (objectsAtLeft.length > 1) {\n                targetBounds = ((objectsAtLeft[1].obj).bounds);\n                equaldistance = nearestleft.x - targetBounds.x - targetBounds.width;\n                if (Math.abs(equaldistance - objectsAtLeft[0].distance) <= snapObjDistance) {\n                    top = this.findEquallySpacedNodesAtLeft(objectsAtLeft, equaldistance, top, equallySpaced);\n                }\n                else {\n                    equaldistance = objectsAtLeft[0].distance;\n                }\n            }\n            else {\n                equaldistance = objectsAtLeft[0].distance;\n            }\n        }\n        this.sortByDistance(equallySpaced, 'distance');\n        equallySpaced[equallySpaced.length] = { obj: shape, distance: 0 };\n        top = bounds.y < top || !top ? bounds.y : top;\n        if (objectsAtRight.length > 0) {\n            var dist = void 0;\n            nearestright = ((objectsAtRight[0].obj).bounds);\n            top = nearestright.y < top ? nearestright.y : top;\n            if (objectsAtRight.length > 1) {\n                targetBounds = ((objectsAtRight[1].obj).bounds);\n                dist = targetBounds.x - nearestright.x - nearestright.width;\n            }\n            if (objectsAtLeft.length > 0) {\n                if (Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) <= snapObjDistance) {\n                    var adjustablevalue = Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) / 2;\n                    (objectsAtRight[0].distance < objectsAtLeft[0].distance) ?\n                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;\n                    equallySpaced[equallySpaced.length] = objectsAtRight[0];\n                }\n                else if (objectsAtLeft.length === 1) {\n                    nearestleft = undefined;\n                    equallySpaced.splice(0, 1);\n                    equallySpaced[equallySpaced.length] = objectsAtRight[0];\n                    equaldistance = dist;\n                }\n            }\n            else {\n                equaldistance = dist;\n                equallySpaced[equallySpaced.length] = objectsAtRight[0];\n            }\n            if (objectsAtRight.length > 1 && nearestright.x + nearestright.width < targetBounds.x) {\n                top = this.findEquallySpacedNodesAtRight(objectsAtRight, dist, top, equallySpaced, snapObjDistance);\n            }\n        }\n        if (equallySpaced.length > 2) {\n            this.addHSpacingLines(diagram, g, equallySpaced, ended, top);\n            var deltaHorizontal = 0;\n            if (ended) {\n                deltaHorizontal = delta.x;\n            }\n            if (nearestleft) {\n                horizontalSnap.offset = equaldistance - Math.abs(bounds.x + deltaHorizontal - nearestleft.x - nearestleft.width)\n                    + deltaHorizontal;\n            }\n            else if (nearestright) {\n                horizontalSnap.offset = Math.abs(bounds.x + bounds.width + deltaHorizontal - nearestright.x)\n                    - equaldistance + deltaHorizontal;\n            }\n            horizontalSnap.snapped = true;\n        }\n    };\n    //To create vertical spacing lines\n    Snapping.prototype.createVSpacingLines = function (diagram, g, shape, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {\n        var right = 0;\n        this.sortByDistance(objectsAtTop, 'distance', true);\n        this.sortByDistance(objectsAtBottom, 'distance', true);\n        var equallySpaced = [];\n        var wrapper = this.getWrapperObject(shape, diagram.nameTable);\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(wrapper);\n        var nearesttop;\n        var nearestbottom;\n        var targetBounds;\n        var equaldistance;\n        if (objectsAtTop.length > 0) {\n            equallySpaced[equallySpaced.length] = objectsAtTop[0];\n            nearesttop = ((objectsAtTop[0].obj).bounds);\n            right = nearesttop.x + nearesttop.width;\n            if (objectsAtTop.length > 1) {\n                targetBounds = ((objectsAtTop[1].obj).bounds);\n                equaldistance = nearesttop.y - targetBounds.y - targetBounds.height;\n                if (Math.abs(equaldistance - objectsAtTop[0].distance) <= snapObjDistance) {\n                    right = this.findEquallySpacedNodesAtTop(objectsAtTop, equaldistance, right, equallySpaced);\n                }\n                else {\n                    equaldistance = objectsAtTop[0].distance;\n                }\n            }\n            else {\n                equaldistance = objectsAtTop[0].distance;\n            }\n        }\n        this.sortByDistance(equallySpaced, 'distance');\n        equallySpaced[equallySpaced.length] = { obj: shape, distance: 0 };\n        right = bounds.x + bounds.width > right || !right ? bounds.x + bounds.width : right;\n        var dist;\n        if (objectsAtBottom.length > 0) {\n            nearestbottom = ((objectsAtBottom[0].obj).bounds);\n            right = nearestbottom.x + nearestbottom.width > right ? nearestbottom.x + nearestbottom.width : right;\n            if (objectsAtBottom.length > 1) {\n                targetBounds = ((objectsAtBottom[1].obj).bounds);\n                dist = targetBounds.y - nearestbottom.y - nearestbottom.height;\n            }\n            if (objectsAtTop.length > 0) {\n                if (Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) <= snapObjDistance) {\n                    var adjustablevalue = Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) / 2;\n                    (objectsAtBottom[0].distance < objectsAtTop[0].distance) ?\n                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;\n                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n                }\n                else if (objectsAtTop.length === 1) {\n                    nearesttop = undefined;\n                    equallySpaced.splice(0, 1);\n                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n                    equaldistance = dist;\n                }\n            }\n            else {\n                equaldistance = dist;\n                equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n            }\n            if (objectsAtBottom.length > 1 && targetBounds.y > nearestbottom.y + nearestbottom.height) {\n                right = this.findEquallySpacedNodesAtBottom(objectsAtBottom, dist, right, equallySpaced, snapObjDistance);\n            }\n        }\n        if (equallySpaced.length > 2) {\n            this.addVSpacingLines(diagram, g, equallySpaced, ended, right);\n            var deltaVertical = 0;\n            if (ended) {\n                deltaVertical = delta.y;\n            }\n            if (nearesttop) {\n                verticalSnap.offset = equaldistance - Math.abs(bounds.y + deltaVertical - nearesttop.y - nearesttop.height) + deltaVertical;\n            }\n            else if (nearestbottom) {\n                verticalSnap.offset = Math.abs(bounds.y + bounds.height + deltaVertical - nearestbottom.y) - equaldistance + deltaVertical;\n            }\n            verticalSnap.snapped = true;\n        }\n    };\n    //Add the Horizontal spacing lines\n    Snapping.prototype.addHSpacingLines = function (diagram, g, equallySpaced, ended, top) {\n        var i;\n        var start;\n        var end;\n        if (!ended) {\n            for (i = 0; i < equallySpaced.length - 1; i++) {\n                var crnt = equallySpaced[parseInt(i.toString(), 10)].obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_4__.Selector ?\n                    (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)((equallySpaced[parseInt(i.toString(), 10)].obj).wrapper)\n                    : ((equallySpaced[parseInt(i.toString(), 10)].obj).bounds);\n                var next = equallySpaced[i + 1].obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_4__.Selector ?\n                    (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)((equallySpaced[i + 1].obj).wrapper) : ((equallySpaced[i + 1].obj).bounds);\n                start = { x: crnt.x + crnt.width, y: top - 15 };\n                end = { x: next.x, y: top - 15 };\n                this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n    };\n    //Add the vertical spacing lines\n    Snapping.prototype.addVSpacingLines = function (diagram, g, equallySpacedObjects, ended, right) {\n        var start;\n        var end;\n        if (!ended) {\n            for (var i = 0; i < equallySpacedObjects.length - 1; i++) {\n                var crnt = equallySpacedObjects[parseInt(i.toString(), 10)].obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_4__.Selector ?\n                    (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)((equallySpacedObjects[parseInt(i.toString(), 10)].obj).wrapper)\n                    : ((equallySpacedObjects[parseInt(i.toString(), 10)].obj).bounds);\n                var next = equallySpacedObjects[i + 1].obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_4__.Selector ?\n                    (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)((equallySpacedObjects[i + 1].obj).wrapper) :\n                    ((equallySpacedObjects[i + 1].obj).bounds);\n                start = { x: right + 15, y: crnt.y + crnt.height };\n                end = { x: right + 15, y: next.y };\n                this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n    };\n    //To add same width lines\n    Snapping.prototype.addSameWidthLines = function (diagram, snapLine, sameWidths, horizontalSnap, ended, shape) {\n        this.sortByDistance(sameWidths, 'offset');\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(shape.wrapper);\n        var target = sameWidths[0];\n        var startPt;\n        var endPt;\n        var targetBounds = (target.source).bounds;\n        var sameSizes = [];\n        sameSizes.push(sameWidths[0]);\n        var i;\n        var crntbounds;\n        for (i = 1; i < sameWidths.length; i++) {\n            crntbounds = (sameWidths[parseInt(i.toString(), 10)].source).bounds;\n            if (crntbounds.width === targetBounds.width) {\n                sameSizes.push(sameWidths[parseInt(i.toString(), 10)]);\n            }\n        }\n        if (!ended) {\n            startPt = { x: bounds.x + target.offset, y: bounds.y - 15 };\n            endPt = { x: bounds.x + bounds.width + target.offset, y: bounds.y - 15 };\n            this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            for (i = 0; i < sameSizes.length; i++) {\n                bounds = (sameSizes[parseInt(i.toString(), 10)].source).bounds;\n                startPt = { x: bounds.x, y: bounds.y - 15 };\n                endPt = { x: bounds.x + bounds.width, y: bounds.y - 15 };\n                this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n        horizontalSnap.offset = target.offset;\n        horizontalSnap.snapped = true;\n    };\n    //To add same height lines\n    Snapping.prototype.addSameHeightLines = function (diagram, snapLine, sameHeights, verticalSnap, ended, shape) {\n        this.sortByDistance(sameHeights, 'offset');\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(shape.wrapper);\n        var target = sameHeights[0];\n        var targetBounds = (target.source).bounds;\n        var start;\n        var end;\n        var sameSizes = [];\n        sameSizes.push(sameHeights[0]);\n        var i;\n        var crntbounds;\n        for (i = 0; i < sameHeights.length; i++) {\n            crntbounds = (sameHeights[parseInt(i.toString(), 10)].source).bounds;\n            if (crntbounds.height === targetBounds.height) {\n                sameSizes.push(sameHeights[parseInt(i.toString(), 10)]);\n            }\n        }\n        if (!ended) {\n            start = { x: bounds.x + bounds.width + 15, y: bounds.y + target.offset };\n            end = { x: bounds.x + bounds.width + 15, y: bounds.y + target.offset + bounds.height };\n            this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            for (i = 0; i < sameSizes.length; i++) {\n                bounds = (sameSizes[parseInt(i.toString(), 10)].source).bounds;\n                start = { x: bounds.x + bounds.width + 15, y: bounds.y };\n                end = { x: bounds.x + bounds.width + 15, y: bounds.y + bounds.height };\n                this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n        verticalSnap.offset = target.offset;\n        verticalSnap.snapped = true;\n    };\n    //Render spacing lines\n    Snapping.prototype.renderSpacingLines = function (start, end, snapLine, svg, transform) {\n        var d;\n        var d1;\n        var line1;\n        var element = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_1__.PathElement();\n        var options = {};\n        start = {\n            x: (start.x + transform.tx) * transform.scale,\n            y: (start.y + transform.ty) * transform.scale\n        };\n        end = {\n            x: (end.x + transform.tx) * transform.scale,\n            y: (end.y + transform.ty) * transform.scale\n        };\n        if (start.x === end.x) {\n            d = 'M' + (start.x - 5) + ' ' + (start.y + 5) + 'L' + start.x + ' ' + start.y +\n                'L' + (start.x + 5) + ' ' + (start.y + 5) + 'z' + 'M' + (end.x - 5) + ' ' +\n                (end.y - 5) + ' L' + end.x + ' ' + end.y + ' L' +\n                (end.x + 5) + ' ' + (end.y - 5) + 'z';\n            line1 = {\n                startPoint: { x: start.x - 8, y: start.y - 1 },\n                endPoint: { x: start.x + 8, y: start.y - 1 },\n                stroke: this.setSnapLineColor(),\n                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0, visible: true, opacity: 1, id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.randomId)()\n            };\n            element.data = d;\n            options.data = element.data;\n            options.angle = 0;\n            options.pivotX = 0;\n            options.pivotY = 0;\n            options.x = 0;\n            options.y = 0;\n            options.height = 0;\n            options.width = 1;\n            options.id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.randomId)();\n            this.diagram.diagramRenderer.drawPath(snapLine, options);\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n            line1 = {\n                startPoint: { x: end.x - 8, y: end.y + 1 },\n                endPoint: { x: end.x + 8, y: end.y + 1 },\n                stroke: this.setSnapLineColor(),\n                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0, visible: true, opacity: 1, id: this.getAdornerLayerSvg().id + 'spacing'\n            };\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n        }\n        else {\n            d = 'M' + (start.x + 5) + ' ' + (start.y + 5) + ' L' + start.x + ' ' + start.y +\n                ' L' + (start.x + 5) + ' ' + (start.y - 5) + 'z' + 'M' + (end.x - 5) + ' ' +\n                (end.y - 5) + ' L' + end.x + ' ' + end.y +\n                ' L' + (end.x - 5) + ' ' + (end.y + 5) + 'z';\n            element.data = d;\n            options.data = d;\n            options.angle = 0;\n            options.pivotX = 0;\n            options.pivotY = 0;\n            options.x = 0;\n            options.y = 0;\n            options.height = 0;\n            options.width = 1;\n            options.id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.randomId)();\n            this.diagram.diagramRenderer.drawPath(snapLine, options);\n            line1 = {\n                visible: true, opacity: 1, id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.randomId)(),\n                startPoint: { x: start.x - 1, y: start.y - 8 },\n                endPoint: { x: start.x - 1, y: start.y + 8 },\n                stroke: this.setSnapLineColor(),\n                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '0', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0\n            };\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n            line1 = {\n                width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0, visible: true, opacity: 1, id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.randomId)(),\n                startPoint: { x: end.x + 1, y: end.y - 8 },\n                endPoint: { x: end.x + 1, y: end.y + 8 },\n                stroke: this.setSnapLineColor(),\n                strokeWidth: 1, fill: this.setSnapLineColor(), dashArray: '0'\n            };\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n        }\n        line1 = {\n            startPoint: { x: start.x, y: start.y },\n            endPoint: { x: end.x, y: end.y }, stroke: this.setSnapLineColor(), strokeWidth: 1, fill: this.setSnapLineColor(),\n            dashArray: '0', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n            pivotY: 0, visible: true, opacity: 1, id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.randomId)()\n        };\n        this.line.push(line1);\n        this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n    };\n    /**\n     * To Create Snap object with position, initial bounds, and final bounds \\\n     *\n     * @returns {  void }  To Create Snap object with position, initial bounds, and final bounds .\\\n     * @param {Diagram} targetBounds - provide the targetBounds value.\n     * @param {Rect} bounds - provide the angle value.\n     * @param {string} snap - provide the angle value.\n     * @private\n     */\n    Snapping.prototype.createSnapObject = function (targetBounds, bounds, snap) {\n        var snapObject;\n        switch (snap) {\n            case 'left':\n                snapObject = {\n                    start: { x: (targetBounds.x), y: Math.min(targetBounds.y, bounds.y) },\n                    end: { x: (targetBounds.x), y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height) },\n                    offsetX: targetBounds.x - bounds.x, offsetY: 0, type: 'sideAlign'\n                };\n                break;\n            case 'right':\n                snapObject = {\n                    type: 'sideAlign',\n                    start: { x: (targetBounds.x + targetBounds.width), y: Math.min(targetBounds.y, bounds.y) },\n                    offsetX: targetBounds.x + targetBounds.width - bounds.x - bounds.width,\n                    offsetY: 0,\n                    end: {\n                        x: (targetBounds.x + targetBounds.width),\n                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n                    }\n                };\n                break;\n            case 'top':\n                snapObject = {\n                    offsetY: targetBounds.y - bounds.y, offsetX: 0, type: 'sideAlign',\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y },\n                    end: { x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)), y: targetBounds.y }\n                };\n                break;\n            case 'bottom':\n                snapObject = {\n                    type: 'sideAlign', offsetY: targetBounds.y + targetBounds.height - bounds.y - bounds.height, offsetX: 0,\n                    end: {\n                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),\n                        y: targetBounds.y + targetBounds.height\n                    },\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height }\n                };\n                break;\n            case 'topBottom':\n                snapObject = {\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height },\n                    end: {\n                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),\n                        y: targetBounds.y + targetBounds.height\n                    },\n                    offsetY: targetBounds.y + targetBounds.height - bounds.y, offsetX: 0, type: 'sideAlign'\n                };\n                break;\n            case 'bottomTop':\n                snapObject = {\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y },\n                    end: { x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)), y: targetBounds.y },\n                    offsetY: targetBounds.y - bounds.y - bounds.height, offsetX: 0, type: 'sideAlign'\n                };\n                break;\n            case 'leftRight':\n                snapObject = {\n                    start: { x: (targetBounds.x + targetBounds.width), y: Math.min(targetBounds.y, bounds.y) },\n                    end: {\n                        x: (targetBounds.x + targetBounds.width),\n                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n                    },\n                    offsetX: targetBounds.x + targetBounds.width - bounds.x, offsetY: 0, type: 'sideAlign'\n                };\n                break;\n            case 'rightLeft':\n                snapObject = {\n                    start: { x: (targetBounds.x), y: (Math.min(targetBounds.y, bounds.y)) },\n                    end: { x: (targetBounds.x), y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height) },\n                    offsetX: targetBounds.x - bounds.x - bounds.width, offsetY: 0, type: 'sideAlign'\n                };\n                break;\n            case 'centerX':\n                snapObject = {\n                    start: { x: (targetBounds.x + targetBounds.width / 2), y: (Math.min(targetBounds.y, bounds.y)) },\n                    end: {\n                        x: (targetBounds.x + targetBounds.width / 2),\n                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n                    },\n                    offsetX: targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2), offsetY: 0, type: 'centerAlign'\n                };\n                break;\n            case 'centerY':\n                snapObject = {\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height / 2 },\n                    end: {\n                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),\n                        y: targetBounds.y + targetBounds.height / 2\n                    },\n                    offsetY: targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2), offsetX: 0, type: 'centerAlign'\n                };\n                break;\n        }\n        return snapObject;\n    };\n    /**\n     *  Calculate the snap angle \\\n     *\n     * @returns {  void }  Calculate the snap angle .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     * @param {number} angle - provide the angle value.\n     * @private\n     */\n    Snapping.prototype.snapAngle = function (diagram, angle) {\n        var snapSettings = this.diagram.snapSettings;\n        var snapAngle = snapSettings.snapAngle;\n        var width = angle % (snapAngle || 0);\n        if (width >= (snapAngle / 2)) {\n            return angle + snapAngle - width;\n        }\n        else {\n            return angle - width;\n        }\n    };\n    //Check whether the node to be snapped or not.\n    Snapping.prototype.canConsider = function (nameTable, selectedObject, target) {\n        var consider = false;\n        if (this.diagram.selectedItems.nodes.length && this.diagram.selectedItems.nodes[0].id === target.id) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    //Find the total number of nodes in diagram using SpatialSearch\n    Snapping.prototype.findNodes = function (spatialSearch, node, child, viewPort, nodesInView) {\n        var nodes = [];\n        var nd;\n        var bounds;\n        var quads = spatialSearch.findQuads(nodesInView ? viewPort : child);\n        for (var i = 0; i < quads.length; i++) {\n            var quad = quads[parseInt(i.toString(), 10)];\n            if (quad.objects.length > 0) {\n                for (var j = 0; j < quad.objects.length; j++) {\n                    nd = quad.objects[parseInt(j.toString(), 10)];\n                    if (!(this.diagram.nameTable[nd.id] instanceof _connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && nd.visible\n                        && !(this.diagram.nameTable[nd.id].shape.type === 'SwimLane') && !(this.diagram.nameTable[nd.id].isLane) &&\n                        !(this.diagram.nameTable[nd.id].isPhase) && !(this.diagram.nameTable[nd.id].isHeader) && nd.id !== 'helper') {\n                        bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_5__.getBounds)(nd);\n                        if (nodes.indexOf(nd) === -1 && this.intersectsRect(child, bounds)) {\n                            nodes.push(nd);\n                        }\n                        if (nodesInView && nodesInView.indexOf(nd) && this.intersectsRect(viewPort, bounds)) {\n                            nodesInView.push(nd);\n                        }\n                    }\n                }\n            }\n        }\n        return nodes;\n    };\n    Snapping.prototype.intersectsRect = function (child, bounds) {\n        return ((((bounds.x < (child.x + child.width)) && (child.x < (bounds.x + bounds.width)))\n            && (bounds.y < (child.y + child.height))) && (child.y < (bounds.y + bounds.height)));\n    };\n    Snapping.prototype.getAdornerLayerSvg = function () {\n        return this.diagram.diagramRenderer.adornerSvgLayer;\n    };\n    /**\n     *  To remove grid lines on mouse move and mouse up \\\n     *\n     * @returns {  void }  To remove grid lines on mouse move and mouse up .\\\n     * @param {Diagram} diagram - provide the source value.\n     * @private\n     */\n    Snapping.prototype.removeGuidelines = function (diagram) {\n        var selectionRect = this.getAdornerLayerSvg().getElementById('_SnappingLines');\n        var line = this.getAdornerLayerSvg().getElementById('pivotLine');\n        if (selectionRect) {\n            selectionRect.parentNode.removeChild(selectionRect);\n        }\n        if (line) {\n            line.parentNode.removeChild(line);\n        }\n    };\n    //Sort the objects by its distance\n    Snapping.prototype.sortByDistance = function (obj, value, ascending) {\n        var i;\n        var j;\n        var temp;\n        if (ascending) {\n            for (i = 0; i < obj.length; i++) {\n                for (j = i + 1; j < obj.length; j++) {\n                    if (obj[parseInt(i.toString(), 10)][\"\" + value] > obj[parseInt(j.toString(), 10)][\"\" + value]) {\n                        temp = obj[parseInt(i.toString(), 10)];\n                        obj[parseInt(i.toString(), 10)] = obj[parseInt(j.toString(), 10)];\n                        obj[parseInt(j.toString(), 10)] = temp;\n                    }\n                }\n            }\n        }\n        else {\n            for (i = 0; i < obj.length; i++) {\n                for (j = i + 1; j < obj.length; j++) {\n                    if (obj[parseInt(i.toString(), 10)][\"\" + value] < obj[parseInt(j.toString(), 10)][\"\" + value]) {\n                        temp = obj[parseInt(i.toString(), 10)];\n                        obj[parseInt(i.toString(), 10)] = obj[parseInt(j.toString(), 10)];\n                        obj[parseInt(j.toString(), 10)] = temp;\n                    }\n                }\n            }\n        }\n    };\n    //To find nodes that are equally placed at left of the selected node\n    Snapping.prototype.findEquallySpacedNodesAtLeft = function (objectsAtLeft, equalDistance, top, equallySpaced) {\n        var prevBounds;\n        var targetBounds;\n        var dist;\n        var i;\n        for (i = 1; i < objectsAtLeft.length; i++) {\n            prevBounds = ((objectsAtLeft[i - 1].obj).bounds);\n            targetBounds = ((objectsAtLeft[parseInt(i.toString(), 10)].obj).bounds);\n            dist = prevBounds.x - targetBounds.x - targetBounds.width;\n            if (Math.abs(dist - equalDistance) <= 1) {\n                equallySpaced[equallySpaced.length] = objectsAtLeft[parseInt(i.toString(), 10)];\n                if (targetBounds.y < top) {\n                    top = targetBounds.y;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return top;\n    };\n    //To find nodes that are equally placed at right of the selected node\n    Snapping.prototype.findEquallySpacedNodesAtRight = function (objectsAtRight, equalDistance, top, equallySpaced, snapObjDistance) {\n        var actualDistance = objectsAtRight[0].distance;\n        var target;\n        var targetBounds;\n        var prevBounds;\n        var dist;\n        if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {\n            for (var i = 0; i < objectsAtRight.length - 1; i++) {\n                target = objectsAtRight[parseInt(i.toString(), 10)].obj;\n                targetBounds = ((objectsAtRight[i + 1].obj).bounds);\n                prevBounds = (target.bounds);\n                dist = targetBounds.x - prevBounds.x - prevBounds.width;\n                if (Math.abs(dist - equalDistance) <= 1) {\n                    equallySpaced[equallySpaced.length] = objectsAtRight[i + 1];\n                    if (prevBounds.y < top) {\n                        top = prevBounds.y;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return top;\n    };\n    Snapping.prototype.findEquallySpacedNodesAtTop = function (objectsAtTop, equalDistance, right, equallySpaced) {\n        var prevBounds;\n        var targetBounds;\n        var dist;\n        for (var i = 1; i < objectsAtTop.length; i++) {\n            prevBounds = ((objectsAtTop[i - 1].obj).bounds);\n            targetBounds = ((objectsAtTop[parseInt(i.toString(), 10)].obj).bounds);\n            dist = prevBounds.y - targetBounds.y - targetBounds.height;\n            if (Math.abs(dist - equalDistance) <= 1) {\n                equallySpaced[equallySpaced.length] = objectsAtTop[parseInt(i.toString(), 10)];\n                if (targetBounds.x + targetBounds.width > right) {\n                    right = targetBounds.x + targetBounds.width;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return right;\n    };\n    //To find nodes that are equally placed at bottom of the selected node\n    Snapping.prototype.findEquallySpacedNodesAtBottom = function (objectsAtBottom, equalDistance, right, equallySpaced, snapObjDistance) {\n        var actualDistance = objectsAtBottom[0].distance;\n        var target;\n        var targetBounds;\n        var prevBounds;\n        var dist;\n        if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {\n            for (var i = 0; i < objectsAtBottom.length - 1; i++) {\n                target = objectsAtBottom[parseInt(i.toString(), 10)].obj;\n                targetBounds = ((objectsAtBottom[i + 1].obj).bounds);\n                prevBounds = (target.bounds);\n                dist = targetBounds.y - prevBounds.y - prevBounds.height;\n                if (Math.abs(dist - equalDistance) <= 1) {\n                    equallySpaced[equallySpaced.length] = objectsAtBottom[i + 1];\n                    if (prevBounds.x + prevBounds.width > right) {\n                        right = prevBounds.x + prevBounds.width;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return right;\n    };\n    /**\n     * To get Adoner layer to draw snapLine\n     *\n     * @private\n     */\n    Snapping.prototype.getLayer = function () {\n        var snapLine;\n        if (this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.SnapConstraints.SnapToObject) {\n            snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            snapLine.setAttribute('id', '_SnappingLines');\n            snapLine.setAttribute('shapeRendering', 'crispEdges');\n            this.getAdornerLayerSvg().appendChild(snapLine);\n        }\n        return snapLine;\n    };\n    /**\n     * Constructor for the snapping module\n     *\n     * @private\n     */\n    // constructor() {\n    //     //constructs the snapping module\n    // }\n    /**\n     *To destroy the ruler\n     *\n     * @returns {void} To destroy the ruler\n     */\n    Snapping.prototype.destroy = function () {\n        /**\n         * Destroys the snapping module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    Snapping.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'Snapping';\n    };\n    return Snapping;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/snapping.js?");

/***/ })

}]);