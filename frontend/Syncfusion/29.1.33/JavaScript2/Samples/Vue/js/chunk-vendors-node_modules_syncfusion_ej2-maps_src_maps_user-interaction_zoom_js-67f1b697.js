"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-maps_src_maps_user-interaction_zoom_js-67f1b697"],{

/***/ "./node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/zoom.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/zoom.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Zoom: () => (/* binding */ Zoom)\n/* harmony export */ });\n/* harmony import */ var _utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helper */ \"./node_modules/@syncfusion/ej2-maps/src/maps/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-maps/src/maps/index.js\");\n/* harmony import */ var _model_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/constants */ \"./node_modules/@syncfusion/ej2-maps/src/maps/model/constants.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Zoom module used to process the zoom for maps\n */\nvar Zoom = /** @class */ (function () {\n    function Zoom(maps) {\n        /** @private */\n        this.isPanModeEnabled = false;\n        /** @private */\n        this.mouseEnter = false;\n        /** @private */\n        this.isTouch = false;\n        /** @private */\n        this.rectZoomingStart = false;\n        /** @private */\n        this.browserName = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.info.name;\n        /** @private */\n        this.isPointer = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isPointer;\n        this.handled = false;\n        /** @private */\n        this.isPanningInProgress = false;\n        this.isPan = false;\n        this.isZoomFinal = false;\n        this.isZoomSelection = false;\n        this.pinchFactor = 1;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.startTouches = [];\n        /** @private */\n        this.isCancellation = false;\n        this.pinchTileZoomScale = 1;\n        this.tileZoomLevel = 1;\n        this.pinchZoomScale = 1;\n        this.isPinchZooming = false;\n        /** @private */\n        this.mouseDownLatLong = { x: 0, y: 0 };\n        /** @private */\n        this.mouseMoveLatLong = { x: 0, y: 0 };\n        /** @private */\n        this.isSingleClick = false;\n        this.maps = maps;\n        this.wheelEvent = this.browserName === 'mozilla' ? (this.isPointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';\n        this.cancelEvent = this.isPointer ? 'pointerleave' : 'mouseleave';\n        this.selectionColor = this.maps.zoomSettings.toolbarSettings.buttonSettings.selectionColor;\n        this.fillColor = this.maps.zoomSettings.toolbarSettings.buttonSettings.color;\n        this.addEventListener();\n    }\n    /**\n     * To perform zooming for maps.\n     *\n     * @param {Point} position - Specifies the position.\n     * @param {number} newZoomFactor - Specifies the zoom factor.\n     * @param {string} type - Specifies the type.\n     * @param {boolean} isMouseWheel - Indicates whether the zoom operation was triggered by the mouse wheel.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.performZooming = function (position, newZoomFactor, type, isMouseWheel) {\n        var _this = this;\n        if (isMouseWheel === void 0) { isMouseWheel = false; }\n        var map = this.maps;\n        map.previousProjection = newZoomFactor <= 1.5 ? undefined : map.projectionType;\n        map.defaultState = false;\n        map.initialCheck = false;\n        map.markerZoomedState = map.isMarkerZoomCompleted = false;\n        map.zoomPersistence = map.enablePersistence;\n        var prevLevel = map.tileZoomLevel;\n        var maxZoom = map.zoomSettings.maxZoom;\n        var minZoom = map.zoomSettings.minZoom;\n        newZoomFactor = maxZoom >= newZoomFactor ? newZoomFactor : maxZoom;\n        var isToolbarPerform = true;\n        switch (type.toLowerCase()) {\n            case 'zoomin':\n                isToolbarPerform = newZoomFactor <= this.maps.zoomSettings.maxZoom;\n                break;\n            case 'zoomout':\n                isToolbarPerform = newZoomFactor >= this.maps.zoomSettings.minZoom;\n                break;\n        }\n        if (isToolbarPerform) {\n            var scale = map.previousScale = map.scale;\n            var prevTilePoint = map.tileTranslatePoint;\n            if ((!map.isTileMap) && ((type === 'ZoomIn' ? newZoomFactor >= minZoom && newZoomFactor <= maxZoom : newZoomFactor >= minZoom)\n                || map.isReset)) {\n                var availSize = map.mapAreaRect;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var minBounds = map.baseMapRectBounds['min'];\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var maxBounds = map.baseMapRectBounds['max'];\n                var mapTotalWidth = Math.abs(minBounds['x'] - maxBounds['x']);\n                var mapTotalHeight = Math.abs(minBounds['y'] - maxBounds['y']);\n                var translatePointX = void 0;\n                var translatePointY = void 0;\n                if (newZoomFactor < 1.2 && map.projectionType !== 'Eckert5') {\n                    if (mapTotalWidth === 0 || mapTotalHeight === 0 || mapTotalWidth === mapTotalHeight) {\n                        mapTotalWidth = availSize.width / 2;\n                        mapTotalHeight = availSize.height;\n                    }\n                    newZoomFactor = parseFloat(Math.min(availSize.width / mapTotalWidth, availSize.height / mapTotalHeight).toFixed(2));\n                    newZoomFactor = newZoomFactor > 1.05 ? 1 : newZoomFactor;\n                    map.translatePoint = this.calculateInitalZoomTranslatePoint(newZoomFactor, mapTotalWidth, mapTotalHeight, availSize, minBounds, map);\n                }\n                else {\n                    var point = map.translatePoint;\n                    translatePointX = point.x - (((availSize.width / scale) - (availSize.width / newZoomFactor)) / (availSize.width / position.x));\n                    translatePointY = point.y - (((availSize.height / scale) - (availSize.height / newZoomFactor)) / (availSize.height / position.y));\n                    var currentHeight = Math.abs(map.baseMapRectBounds['max']['y'] - map.baseMapRectBounds['min']['y']) * newZoomFactor;\n                    translatePointX = (currentHeight < map.mapAreaRect.height) ? (availSize.x + ((-(minBounds['x'])) + ((availSize.width / 2) - (mapTotalWidth / 2)))) : translatePointX;\n                    translatePointY = (currentHeight < map.mapAreaRect.height) ? (availSize.y + ((-(minBounds['y'])) + ((availSize.height / 2) - (mapTotalHeight / 2)))) : translatePointY;\n                    map.translatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(translatePointX, translatePointY);\n                }\n                map.scale = newZoomFactor;\n                map.zoomTranslatePoint = map.translatePoint;\n                if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {\n                    map.translatePoint = map.previousPoint;\n                    map.scale = map.mapScaleValue = map.previousScale;\n                }\n                else {\n                    this.applyTransform(map, isMouseWheel);\n                }\n            }\n            else if ((map.isTileMap) && (newZoomFactor >= minZoom && newZoomFactor <= maxZoom)) {\n                this.getTileTranslatePosition(prevLevel, newZoomFactor, position, type);\n                map.tileZoomLevel = newZoomFactor;\n                map.zoomSettings.zoomFactor = newZoomFactor;\n                map.scale = Math.pow(2, newZoomFactor - 1);\n                if (type === 'ZoomOut' && map.zoomSettings.resetToInitial && map.applyZoomReset && newZoomFactor <= map.initialZoomLevel) {\n                    map.initialCheck = true;\n                    map.zoomPersistence = false;\n                    map.tileTranslatePoint.x = map.initialTileTranslate.x;\n                    map.tileTranslatePoint.y = map.initialTileTranslate.y;\n                    newZoomFactor = map.tileZoomLevel = map.mapScaleValue = map.initialZoomLevel;\n                    map.scale = Math.pow(2, newZoomFactor - 1);\n                }\n                map.mapScaleValue = isNaN(map.mapScaleValue) ? 1 : map.mapScaleValue;\n                map.translatePoint.y = (map.tileTranslatePoint.y - (0.01 * map.mapScaleValue)) / map.scale;\n                map.translatePoint.x = (map.tileTranslatePoint.x - (0.01 * map.mapScaleValue)) / map.scale;\n                if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {\n                    map.translatePoint = map.tileTranslatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);\n                    map.scale = map.previousScale;\n                    map.tileZoomLevel = prevLevel;\n                    map.zoomSettings.zoomFactor = map.previousScale;\n                }\n                else {\n                    if (document.querySelector('.GroupElement')) {\n                        document.querySelector('.GroupElement').style.display = 'none';\n                    }\n                    if (document.getElementById(this.maps.element.id + '_LayerIndex_1')) {\n                        document.getElementById(this.maps.element.id + '_LayerIndex_1').style.display = 'none';\n                    }\n                    this.markerLineAnimation(map);\n                    map.mapLayerPanel.generateTiles(newZoomFactor, map.tileTranslatePoint, type + 'wheel', null, position);\n                    var animationDuration = this.maps.layersCollection[0].animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable' ? 1000 : this.maps.layersCollection[0].animationDuration;\n                    setTimeout(function () {\n                        // if (type === 'ZoomOut') {\n                        //     element1.removeChild(element1.children[element1.childElementCount - 1]);\n                        //     if (element1.childElementCount) {\n                        //         element1.removeChild(element1.children[element1.childElementCount - 1]);\n                        //     } else {\n                        //         element1 = element1;\n                        //     }\n                        // }\n                        _this.applyTransform(_this.maps, isMouseWheel);\n                        if (document.getElementById(_this.maps.element.id + '_LayerIndex_1')) {\n                            document.getElementById(_this.maps.element.id + '_LayerIndex_1').style.display = 'block';\n                        }\n                    }, animationDuration);\n                }\n            }\n            this.triggerZoomComplete(map, prevLevel, type);\n        }\n        this.maps.zoomNotApplied = false;\n        if (this.maps.isDevice) {\n            this.removeToolbarOpacity(map.isTileMap ? Math.round(map.tileZoomLevel) : map.scale, map.element.id + '_Zooming_');\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Zoom.prototype.calculateInitalZoomTranslatePoint = function (newZoomFactor, mapTotalWidth, mapTotalHeight, availSize, minBounds, map) {\n        mapTotalWidth *= newZoomFactor;\n        mapTotalHeight *= newZoomFactor;\n        var widthDiff = minBounds['x'] !== 0 && map.translateType === 'layers' ? map.availableSize.width - availSize.width : 0;\n        var translatePointX = availSize.x + ((-(minBounds['x'])) + ((availSize.width / 2) - (mapTotalWidth / 2))) - widthDiff;\n        var translatePointY = availSize.y + ((-(minBounds['y'])) + ((availSize.height / 2) - (mapTotalHeight / 2)));\n        return new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(translatePointX, translatePointY);\n    };\n    Zoom.prototype.triggerZoomEvent = function (prevTilePoint, prevLevel, type) {\n        var map = this.maps;\n        var zoomArgs;\n        if (map.isTileMap) {\n            map.mapScaleValue = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(map.mapScaleValue) ? 1 : map.mapScaleValue;\n            map.translatePoint.y = (map.tileTranslatePoint.y - (0.01 * map.mapScaleValue)) / map.scale;\n            map.translatePoint.x = (map.tileTranslatePoint.x - (0.01 * map.mapScaleValue)) / map.scale;\n        }\n        var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();\n        if (!map.isTileMap) {\n            zoomArgs = {\n                cancel: false, name: 'zoom', type: type, maps: map,\n                tileTranslatePoint: {}, translatePoint: { previous: map.previousPoint, current: map.translatePoint },\n                tileZoomLevel: {}, scale: { previous: map.previousScale, current: map.scale },\n                minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n            };\n        }\n        else {\n            zoomArgs = {\n                cancel: false, name: 'zoom', type: type, maps: map,\n                tileTranslatePoint: { previous: prevTilePoint, current: map.tileTranslatePoint }, translatePoint: { previous: map.previousPoint, current: map.translatePoint },\n                tileZoomLevel: { previous: prevLevel, current: map.tileZoomLevel }, scale: { previous: map.previousScale, current: map.scale },\n                minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n            };\n        }\n        map.trigger('zoom', zoomArgs);\n        return zoomArgs.cancel;\n    };\n    Zoom.prototype.getTileTranslatePosition = function (prevLevel, currentLevel, position, type) {\n        var map = this.maps;\n        var tileDefaultSize = 256;\n        var padding = type === 'ZoomOut' ? 10 : (type === 'Reset' && currentLevel > 1) ? 0 : 10;\n        var bounds = map.availableSize;\n        var prevSize = Math.pow(2, prevLevel) * 256;\n        var totalSize = Math.pow(2, currentLevel) * 256;\n        var x = ((position.x - map.tileTranslatePoint.x) / prevSize) * 100;\n        var y = ((position.y - map.tileTranslatePoint.y) / prevSize) * 100;\n        map.tileTranslatePoint.x = (currentLevel === 1) ? (bounds.width / 2) - ((tileDefaultSize * 2) / 2) :\n            position.x - ((x * totalSize) / 100);\n        map.tileTranslatePoint.y = (currentLevel === 1) ? ((bounds.height / 2) - ((tileDefaultSize * 2) / 2) + (padding * 2)) :\n            position.y - ((y * totalSize) / 100);\n    };\n    Zoom.prototype.getTileTranslate = function (currentLevel, type) {\n        var map = this.maps;\n        var padding = type === 'ZoomOut' ? 10 : (type === 'Reset' && currentLevel > 1) ? 0 : 10;\n        var bounds = map.availableSize;\n        var totalSize = Math.pow(2, currentLevel) * 256;\n        var x = (bounds.width / 2) - (totalSize / 2);\n        var y = (bounds.height / 2) - (totalSize / 2);\n        var position = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.convertTileLatLongToPoint)(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.MapLocation(this.pinchStartLatLong['longitude'], this.pinchStartLatLong['latitude']), currentLevel, { x: x, y: y }, true);\n        x -= position.x - (bounds.width / 2);\n        y = y - (position.y - (bounds.height / 2)) + padding;\n        var scale = Math.pow(2, currentLevel - 1);\n        map.tileTranslatePoint.x = x;\n        map.tileTranslatePoint.y = y;\n        map.translatePoint.x = (x - (0.01 * this.tileZoomLevel)) / scale;\n        map.translatePoint.y = (y - (0.01 * this.tileZoomLevel)) / scale;\n    };\n    /**\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.performRectZooming = function () {\n        this.isDragZoom = true;\n        var map = this.maps;\n        var size = map.availableSize;\n        map.previousProjection = map.projectionType;\n        var prevLevel = map.tileZoomLevel;\n        var prevTilePoint = map.tileTranslatePoint;\n        var zoomRect = this.zoomingRect;\n        var maxZoom = map.zoomSettings.maxZoom;\n        var minZoom = map.zoomSettings.minZoom;\n        var isZoomCancelled;\n        if (zoomRect.height > 0 && zoomRect.width > 0) {\n            var x = this.zoomingRect.x + (this.zoomingRect.width / 2);\n            var y = this.zoomingRect.y + (this.zoomingRect.height / 2);\n            var zoomCalculationFactor = void 0;\n            if (!map.isTileMap) {\n                var scale = map.previousScale = map.scale;\n                zoomCalculationFactor = scale + Math.round((((size.width / zoomRect.width) + (size.height / zoomRect.height)) / 2));\n                zoomCalculationFactor = zoomCalculationFactor < this.maps.zoomSettings.maxZoom ? zoomCalculationFactor : this.maps.zoomSettings.maxZoom;\n                var translatePoint = map.previousPoint = map.translatePoint;\n                if (zoomCalculationFactor <= maxZoom) {\n                    var translatePointX = translatePoint.x - (((size.width / scale) - (size.width / zoomCalculationFactor)) / (size.width / x));\n                    var translatePointY = translatePoint.y - (((size.height / scale) - (size.height / zoomCalculationFactor)) / (size.height / y));\n                    map.translatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(translatePointX, translatePointY);\n                }\n                map.scale = zoomCalculationFactor < this.maps.zoomSettings.maxZoom ? zoomCalculationFactor : this.maps.zoomSettings.maxZoom;\n                isZoomCancelled = this.triggerZoomEvent(prevTilePoint, prevLevel, '');\n                if (isZoomCancelled) {\n                    map.translatePoint = map.previousPoint;\n                    map.scale = map.previousScale;\n                }\n                map.zoomTranslatePoint = map.translatePoint;\n            }\n            else {\n                zoomCalculationFactor = prevLevel + (Math.round(prevLevel + (((size.width / zoomRect.width) + (size.height / zoomRect.height)) / 2)));\n                zoomCalculationFactor = (zoomCalculationFactor >= minZoom && zoomCalculationFactor <= maxZoom) ? zoomCalculationFactor : maxZoom;\n                map.zoomSettings.zoomFactor = zoomCalculationFactor;\n                this.getTileTranslatePosition(prevLevel, zoomCalculationFactor, { x: x, y: y });\n                map.tileZoomLevel = zoomCalculationFactor;\n                map.translatePoint.x = (map.tileTranslatePoint.x - (0.5 * Math.pow(2, zoomCalculationFactor))) /\n                    (Math.pow(2, zoomCalculationFactor));\n                map.translatePoint.y = (map.tileTranslatePoint.y - (0.5 * Math.pow(2, zoomCalculationFactor))) /\n                    (Math.pow(2, zoomCalculationFactor));\n                map.scale = (Math.pow(2, zoomCalculationFactor));\n                isZoomCancelled = this.triggerZoomEvent(prevTilePoint, prevLevel, '');\n                if (isZoomCancelled) {\n                    map.translatePoint = map.tileTranslatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);\n                    map.scale = map.tileZoomLevel = map.zoomSettings.zoomFactor = prevLevel;\n                }\n                else {\n                    map.mapLayerPanel.generateTiles(zoomCalculationFactor, map.tileTranslatePoint);\n                }\n            }\n            if (!isZoomCancelled) {\n                map.mapScaleValue = zoomCalculationFactor;\n                this.applyTransform(map, false, true);\n                this.maps.zoomNotApplied = false;\n                this.zoomingRect = null;\n            }\n        }\n        this.isZoomFinal = this.isZoomSelection && Math.round(map.scale) === this.maps.zoomSettings.maxZoom;\n        this.triggerZoomComplete(map, prevLevel, '');\n        this.removeToolbarOpacity(map.scale, this.maps.element.id + '_Zooming_');\n    };\n    Zoom.prototype.setInteraction = function (newInteraction) {\n        this.lastScale = 1;\n        this.interaction = newInteraction;\n    };\n    Zoom.prototype.updateInteraction = function () {\n        if (this.fingers === 2) {\n            this.setInteraction('zoom');\n        }\n        else {\n            this.setInteraction(null);\n        }\n    };\n    Zoom.prototype.tilePinchingProcess = function (scale) {\n        this.tileZoomLevel = Math.round(scale);\n        this.getTileTranslate(this.tileZoomLevel);\n        this.maps.mapLayerPanel.generateTiles(this.tileZoomLevel, this.maps.tileTranslatePoint, null, null, null, true);\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the vent in the map\n     * @returns {void}\n     * @private\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Zoom.prototype.performPinchZooming = function (e) {\n        var map = this.maps;\n        var prevLevel = map.tileZoomLevel;\n        var zoomCalculationFactor = this.pinchFactor;\n        var isZoomCancelled;\n        var prevTilePoint = map.tileTranslatePoint;\n        this.maps.mergeCluster();\n        if (!map.isTileMap) {\n            var availSize = map.mapAreaRect;\n            map.isMarkerZoomCompleted = false;\n            map.previousScale = map.scale;\n            map.previousPoint = map.translatePoint;\n            map.previousProjection = map.projectionType;\n            var scale = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.calculateScale)(this.touchStartList, this.touchMoveList);\n            var touchCenter = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getTouchCenter)((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getTouches)(this.touchMoveList, this.maps));\n            var newScale = scale / this.lastScale;\n            this.lastScale = scale;\n            this.pinchFactor *= newScale;\n            this.pinchFactor = Math.min(this.maps.zoomSettings.maxZoom, Math.max(this.pinchFactor, this.maps.zoomSettings.minZoom));\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var minBounds = map.baseMapRectBounds['min'];\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var maxBounds = map.baseMapRectBounds['max'];\n            var mapTotalHeight = Math.abs(minBounds['y'] - maxBounds['y']);\n            var mapTotalWidth = Math.abs(minBounds['x'] - maxBounds['x']);\n            var translatePoint = map.translatePoint;\n            var translatePointX = void 0;\n            var translatePointY = void 0;\n            if (zoomCalculationFactor < 1.2 && map.projectionType !== 'Eckert5') {\n                if (mapTotalWidth === 0 || mapTotalHeight === 0 || mapTotalWidth === mapTotalHeight) {\n                    mapTotalWidth = availSize.width / 2;\n                    mapTotalHeight = availSize.height;\n                }\n                zoomCalculationFactor = parseFloat(Math.min(availSize.width / mapTotalWidth, availSize.height / mapTotalHeight).toFixed(2));\n                zoomCalculationFactor = zoomCalculationFactor > 1.05 ? 1 : zoomCalculationFactor;\n                map.translatePoint = this.calculateInitalZoomTranslatePoint(zoomCalculationFactor, mapTotalWidth, mapTotalHeight, availSize, minBounds, map);\n            }\n            else {\n                var currentHeight = Math.abs(map.baseMapRectBounds['max']['y'] - map.baseMapRectBounds['min']['y']) * zoomCalculationFactor;\n                translatePointX = translatePoint.x - (((availSize.width / map.scale) - (availSize.width / zoomCalculationFactor)) / (availSize.width / touchCenter.x));\n                translatePointY = translatePoint.y - (((availSize.height / map.scale) - (availSize.height / zoomCalculationFactor)) / (availSize.height / touchCenter.y));\n                translatePointX = (currentHeight < map.mapAreaRect.height) ? (availSize.x + ((-(minBounds['x'])) + ((availSize.width / 2) - (mapTotalWidth / 2)))) : translatePointX;\n                translatePointY = (currentHeight < map.mapAreaRect.height) ? (availSize.y + ((-(minBounds['y'])) + ((availSize.height / 2) - (mapTotalHeight / 2)))) : translatePointY;\n                map.translatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(translatePointX, translatePointY);\n            }\n            map.scale = zoomCalculationFactor;\n            isZoomCancelled = this.triggerZoomEvent(prevTilePoint, prevLevel, '');\n            if (isZoomCancelled) {\n                map.translatePoint = map.previousPoint;\n                map.scale = map.previousScale;\n            }\n        }\n        else {\n            this.isPinchZooming = true;\n            var touchCenter = this.touchCenter;\n            var touchOnePoint = this.getMousePosition(this.touchMoveList[0].pageX, this.touchMoveList[0].pageY);\n            var touchTwoPoint = this.getMousePosition(this.touchMoveList[1].pageX, this.touchMoveList[1].pageY);\n            var distance = Math.sqrt(Math.pow((touchOnePoint.x - touchTwoPoint.x), 2) + Math.pow((touchOnePoint.y - touchTwoPoint.y), 2));\n            var pinchScale = distance / this.startDistance;\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pinchDistance)) {\n                var pinchZoomFactor = Math.log2(pinchScale * (256 * Math.pow(2, prevLevel)) / 256);\n                pinchZoomFactor = Math.min(map.zoomSettings.maxZoom, Math.max(map.zoomSettings.minZoom, pinchZoomFactor));\n                var scaleFactor = this.pinchDistance > distance ? (prevLevel * pinchScale) : pinchZoomFactor;\n                var factor = pinchZoomFactor;\n                var isZoomOut = false;\n                if (this.pinchDistance > distance) {\n                    factor = (scaleFactor % 1);\n                    isZoomOut = true;\n                }\n                else if (this.pinchDistance < distance) {\n                    factor = (scaleFactor % 1) + 1;\n                }\n                var zoomFactor = Math.ceil(scaleFactor);\n                if (zoomFactor > map.zoomSettings.minZoom && zoomFactor <= map.zoomSettings.maxZoom) {\n                    var element = document.getElementById(map.element.id);\n                    if (element) {\n                        element.style.overflow = 'hidden';\n                    }\n                    this.tileZoomLevel = zoomFactor;\n                    var transformOriginX = (touchCenter.x / (map.mapAreaRect.width - map.mapAreaRect.x)) * 100;\n                    var transformOriginY = (touchCenter.y / (map.mapAreaRect.height - map.mapAreaRect.y)) * 100;\n                    var tilesParent = document.getElementById(map.element.id + '_tile_parent');\n                    var copyTilesParent = document.getElementById(map.element.id + '_tiles');\n                    if (!copyTilesParent) {\n                        copyTilesParent = document.createElement('div');\n                        copyTilesParent.id = map.element.id + '_tiles';\n                        map.element.appendChild(copyTilesParent);\n                        this.copyStyles(tilesParent, copyTilesParent);\n                        copyTilesParent.style.zIndex = '0';\n                    }\n                    copyTilesParent.style.visibility = 'hidden';\n                    tilesParent.style.transformOrigin = transformOriginX + \"% \" + transformOriginY + \"%\";\n                    tilesParent.style.transform = \"scale(\" + factor + \")\";\n                    var svgElement = document.getElementById(map.element.id + '_Tile_SVG_Parent');\n                    svgElement.style.transformOrigin = transformOriginX + \"% \" + transformOriginY + \"%\";\n                    svgElement.style.transform = \"scale(\" + factor + \")\";\n                    if (!this.isCancellation && (0.2 >= scaleFactor % 1 && scaleFactor % 1 >= 0.1 && !isZoomOut) || (scaleFactor % 1 <= 0.9 && isZoomOut)) {\n                        var animateTile = document.getElementById(map.element.id + '_animates_tiles');\n                        if (!animateTile) {\n                            animateTile = document.createElement('div');\n                            animateTile.id = map.element.id + '_animates_tiles';\n                            animateTile.classList.add(this.tileZoomLevel.toString());\n                            copyTilesParent.appendChild(animateTile);\n                        }\n                        if (animateTile.childElementCount === 0) {\n                            this.pinchZoomScale = isZoomOut ? Math.floor(scaleFactor) : Math.ceil(scaleFactor);\n                            this.tilePinchingProcess(this.pinchZoomScale);\n                            this.isCancellation = true;\n                        }\n                    }\n                    if (this.isCancellation && (scaleFactor % 1 >= 0.99 && !isZoomOut) || (scaleFactor % 1 <= 0.1 && isZoomOut)) {\n                        if (tilesParent.style.transformOrigin !== '' && this.isCancellation) {\n                            tilesParent.style.transformOrigin = '';\n                            tilesParent.style.transform = '';\n                            svgElement.style.transformOrigin = '';\n                            svgElement.style.transform = '';\n                            this.pinchTileZoomScale = isZoomOut ? Math.floor(scaleFactor) : Math.ceil(scaleFactor);\n                            this.getTileTranslate(this.pinchTileZoomScale);\n                            var targetElement_1 = document.getElementById(map.element.id + '_animated_tiles');\n                            var sourceElement = document.getElementById(map.element.id + '_animates_tiles');\n                            while (targetElement_1.firstChild) {\n                                targetElement_1.removeChild(targetElement_1.firstChild);\n                            }\n                            Array.from(sourceElement.children).forEach(function (child) {\n                                targetElement_1.appendChild(child.cloneNode(true));\n                            });\n                            document.getElementById(map.element.id + '_animated_tiles')['className'] = this.pinchTileZoomScale.toFixed(0);\n                            if (sourceElement) {\n                                while (sourceElement.firstChild) {\n                                    sourceElement.removeChild(sourceElement.firstChild);\n                                }\n                            }\n                            this.isCancellation = false;\n                            map.mapScaleValue = this.pinchTileZoomScale;\n                            map.scale = Math.pow(2, this.pinchTileZoomScale - 1);\n                            this.applyTransform(map);\n                        }\n                    }\n                }\n            }\n            this.pinchDistance = distance;\n        }\n        if (!map.isTileMap) {\n            map.mapScaleValue = zoomCalculationFactor;\n            if (!isZoomCancelled) {\n                this.applyTransform(map);\n            }\n            this.triggerZoomComplete(map, prevLevel, '');\n        }\n        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice) {\n            this.removeToolbarOpacity(map.isTileMap ? Math.round(map.tileZoomLevel) : map.scale, map.element.id + '_Zooming_');\n        }\n    };\n    Zoom.prototype.copyStyles = function (sourceElement, targetElement) {\n        var sourceStyles = window.getComputedStyle(sourceElement);\n        Array.from(sourceStyles).forEach(function (style) {\n            targetElement.style[style] = sourceStyles.getPropertyValue(style);\n        });\n    };\n    Zoom.prototype.getTouchCenterPoint = function () {\n        var touchList = [];\n        for (var i = 0; i < this.touchMoveList.length; i++) {\n            touchList.push(this.getMousePosition(this.touchMoveList[i].pageX, this.touchMoveList[i].pageY));\n        }\n        return {\n            x: (touchList[0].x + touchList[1].x) / 2,\n            y: (touchList[0].y + touchList[1].y) / 2\n        };\n    };\n    Zoom.prototype.triggerZoomComplete = function (map, prevLevel, type) {\n        if (map.zoomSettings.enable) {\n            var zoomArgs = void 0;\n            if (map.isTileMap) {\n                map.mapScaleValue = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(map.mapScaleValue) ? 1 : map.mapScaleValue;\n                map.translatePoint.y = (map.tileTranslatePoint.y - (0.01 * map.mapScaleValue)) / map.scale;\n                map.translatePoint.x = (map.tileTranslatePoint.x - (0.01 * map.mapScaleValue)) / map.scale;\n            }\n            var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();\n            if (!map.isTileMap) {\n                zoomArgs = {\n                    cancel: false, name: 'zoomComplete', type: type, maps: map,\n                    tileTranslatePoint: {}, translatePoint: { previous: map.previousPoint, current: map.translatePoint },\n                    tileZoomLevel: {}, scale: { previous: map.previousScale, current: map.scale },\n                    minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                    minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n                };\n            }\n            else {\n                zoomArgs = {\n                    cancel: false, name: 'zoomComplete', type: type, maps: map,\n                    tileTranslatePoint: { previous: map.tileTranslatePoint, current: map.tileTranslatePoint }, translatePoint: { previous: map.previousPoint, current: map.translatePoint },\n                    tileZoomLevel: { previous: prevLevel, current: map.tileZoomLevel }, scale: { previous: map.previousScale, current: map.scale },\n                    minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                    minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n                };\n            }\n            this.maps.trigger('zoomComplete', zoomArgs);\n        }\n    };\n    /**\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.drawZoomRectangle = function () {\n        var map = this.maps;\n        var down = this.mouseDownPoints;\n        var move = this.mouseMovePoints;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var border = { width: 1, color: this.maps.themeStyle.rectangleZoomBorderColor };\n        var width = Math.abs(move.x - down.x);\n        var height = Math.abs(move.y - down.y);\n        var x = ((move.x > down.x) ? down.x : down.x - width);\n        var y = ((move.y > down.y) ? down.y : down.y - height);\n        if ((x > map.mapAreaRect.x && x < (map.mapAreaRect.x + map.mapAreaRect.width)) &&\n            (y > map.mapAreaRect.y) && (y < map.mapAreaRect.y + map.mapAreaRect.height)) {\n            this.zoomingRect = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Rect(x, y, width, height);\n            var rectSVGObject = map.renderer.createSvg({\n                id: map.element.id + '_Selection_Rect_Zooming',\n                width: map.availableSize.width,\n                height: map.availableSize.height,\n                style: 'position: absolute;'\n            });\n            rectSVGObject.style.position = 'absolute';\n            var rectOption = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.RectOption(map.element.id + '_ZoomRect', this.maps.themeStyle.rectangleZoomFillColor, border, this.maps.themeStyle.rectangleZoomFillOpacity, this.zoomingRect, 0, 0, '', '3');\n            rectSVGObject.appendChild(map.renderer.drawRectangle(rectOption));\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_Secondary_Element').appendChild(rectSVGObject);\n        }\n    };\n    /**\n     * To animate the zooming process.\n     *\n     * @param {Element} element - Specifies the element\n     * @param {boolean} animate - Specifies the boolean value\n     * @param {number} x - Specifies the x value\n     * @param {number} y - Specifies the y value\n     * @param {number} scale - Specifies the scale value\n     * @returns {void}\n     */\n    Zoom.prototype.animateTransform = function (element, animate, x, y, scale) {\n        var duration = this.currentLayer.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable' ? 1000 : this.currentLayer.animationDuration;\n        if (!animate || duration === 0 || this.maps.isTileMap) {\n            if (!(this.maps.isTileMap && element.id.indexOf('_Polygons_Group') > -1)) {\n                element.setAttribute('transform', 'scale(' + (scale) + ') translate( ' + x + ' ' + y + ' )');\n            }\n            return;\n        }\n        if (!this.maps.isTileMap) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.zoomAnimate)(element, 0, duration, new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.MapLocation(x, y), scale, this.maps.mapAreaRect, this.maps);\n        }\n    };\n    /**\n     * @param {Maps} maps - Specifies the Map control\n     * @param {boolean} isMouseWheel - Indicates whether the zoom operation was triggered by the mouse wheel.\n     * @param {boolean} animate - Specifies the animation is available or not\n     * @param {boolean} isPanning - Specifies that it is panning or not\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.applyTransform = function (maps, isMouseWheel, animate, isPanning) {\n        var _this = this;\n        var layerIndex;\n        this.templateCount = 0;\n        var markerStyle;\n        var scale = maps.scale;\n        var x = maps.translatePoint.x;\n        var y = maps.translatePoint.y;\n        var currentLabelIndex = 0;\n        maps.zoomShapeCollection = [];\n        this.isPanningInProgress = isPanning || false;\n        if (document.getElementById(maps.element.id + '_mapsTooltip')) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.removeElement)(maps.element.id + '_mapsTooltip');\n        }\n        if (maps.isTileMap) {\n            var element = document.getElementById(maps.element.id + '_svg');\n            if (element) {\n                for (var k = 0; k < maps.layers.length; k++) {\n                    var layerElement = element.querySelector('#' + maps.element.id + '_LayerIndex_' + k);\n                    if (layerElement) {\n                        element.removeChild(layerElement);\n                    }\n                }\n            }\n        }\n        if (this.layerCollectionEle) {\n            var _loop_1 = function (i) {\n                var layerElement = this_1.layerCollectionEle.childNodes[i];\n                if (layerElement.tagName === 'g') {\n                    this_1.templateCount++;\n                    this_1.index = layerElement.id.indexOf('_LayerIndex_') > -1 && parseFloat(layerElement.id.split('_LayerIndex_')[1].split('_')[0]);\n                    this_1.currentLayer = maps.layersCollection[this_1.index];\n                    var factor_1 = maps.mapLayerPanel.calculateFactor(this_1.currentLayer);\n                    var elementCount = layerElement.childElementCount;\n                    var templateElement = document.getElementById(maps.element.id + '_LayerIndex_' + this_1.index + '_Markers_Template_Group');\n                    var _loop_2 = function (j) {\n                        var currentEle = layerElement.childNodes[j];\n                        if (!(currentEle.id.indexOf('_Markers_Group') > -1) && (!(currentEle.id.indexOf('_bubble_Group') > -1))\n                            && (!(currentEle.id.indexOf('_dataLableIndex_Group') > -1))) {\n                            if (maps.isTileMap && (currentEle.id.indexOf('_line_Group') > -1)) {\n                                currentEle.remove();\n                                if (layerElement.children.length > 0 && layerElement.children[0]) {\n                                    layerElement.insertBefore(maps.navigationLineModule.renderNavigation(this_1.currentLayer, this_1.isPinchZooming ? this_1.pinchZoomScale : maps.tileZoomLevel, this_1.index), layerElement.children[1]);\n                                }\n                                else {\n                                    layerElement.appendChild(maps.navigationLineModule.renderNavigation(this_1.currentLayer, this_1.isPinchZooming ? this_1.pinchZoomScale : maps.tileZoomLevel, this_1.index));\n                                }\n                            }\n                            else if (maps.isTileMap && (currentEle.id.indexOf('_Polygons_Group') > -1)) {\n                                if (this_1.currentLayer.polygonSettings.polygons.length > 0) {\n                                    this_1.currentLayer.polygonSettings.polygons.map(function (polygonSettings, polygonIndex) {\n                                        var markerData = polygonSettings.points;\n                                        var path = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.calculatePolygonPath)(maps, _this.isPinchZooming ? _this.pinchZoomScale : maps.tileZoomLevel, _this.currentLayer, markerData);\n                                        var element = document.getElementById(maps.element.id + '_LayerIndex_' + _this.index + '_PolygonIndex_' + polygonIndex);\n                                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(element)) {\n                                            element.setAttribute('d', path);\n                                        }\n                                    });\n                                    document.getElementById(maps.element.id + '_LayerIndex_' + this_1.index + '_Polygons_Group').style.visibility = '';\n                                }\n                            }\n                            else if (currentEle.id.indexOf('Legend') === -1) {\n                                (0,_index__WEBPACK_IMPORTED_MODULE_2__.changeBorderWidth)(currentEle, this_1.index, scale, maps);\n                                maps.zoomTranslatePoint = maps.translatePoint;\n                                this_1.animateTransform(currentEle, animate, x, y, scale);\n                            }\n                        }\n                        else if (currentEle.id.indexOf('_Markers_Group') > -1) {\n                            if ((!this_1.isPanModeEnabled || !isPanning) && (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(currentEle.childNodes[0]) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(templateElement.childNodes[0]))) {\n                                var processElement = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(currentEle.childNodes[0]) ? currentEle.childNodes[0] : templateElement.childNodes[0]);\n                                this_1.markerTranslates(processElement, factor_1, x, y, scale, 'Marker', layerElement);\n                            }\n                            currentEle = layerElement.childNodes[j];\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(currentEle) && currentEle.id.indexOf('Markers') !== -1) {\n                                Array.prototype.forEach.call(currentEle.childNodes, function (childNode, k) {\n                                    _this.markerTranslate(childNode, factor_1, x, y, scale, 'Marker', animate);\n                                    var dataIndex = parseInt(childNode['id'].split('_dataIndex_')[1].split('_')[0], 10);\n                                    var markerIndex = parseInt(childNode['id'].split('_MarkerIndex_')[1].split('_')[0], 10);\n                                    if (_this.currentLayer.markerSettings[markerIndex].initialMarkerSelection.length > 0) {\n                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                        var markerSelectionValues = _this.currentLayer.markerSettings[markerIndex].dataSource[dataIndex];\n                                        for (var x_1 = 0; x_1 < _this.currentLayer.markerSettings[markerIndex].initialMarkerSelection.length; x_1++) {\n                                            if (_this.currentLayer.markerSettings[markerIndex].initialMarkerSelection[x_1]['latitude'] ===\n                                                markerSelectionValues['latitude'] ||\n                                                _this.currentLayer.markerSettings[markerIndex].initialMarkerSelection[x_1]['longitude'] ===\n                                                    markerSelectionValues['longitude']) {\n                                                maps.markerSelection(_this.currentLayer.markerSettings[markerIndex].selectionSettings, maps, currentEle.children[k], _this.currentLayer.markerSettings[markerIndex].dataSource[dataIndex]);\n                                            }\n                                        }\n                                    }\n                                    if (((_this.currentLayer.animationDuration > 0 || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable') || ((maps.layersCollection[0].animationDuration > 0 || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable') && _this.currentLayer.type === 'SubLayer')) && !_this.isPanModeEnabled) {\n                                        if (!maps.isTileMap) {\n                                            markerStyle = isMouseWheel ? markerStyle : 'visibility:hidden';\n                                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerStyle)) {\n                                                currentEle.style.cssText = markerStyle;\n                                            }\n                                        }\n                                    }\n                                });\n                                if (this_1.isPanModeEnabled && maps.markerModule.sameMarkerData.length > 0) {\n                                    (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.clusterSeparate)(maps.markerModule.sameMarkerData, maps, currentEle, true);\n                                }\n                                else if (maps.markerModule.sameMarkerData.length > 0) {\n                                    maps.markerModule.sameMarkerData = [];\n                                    if (document.getElementById(maps.element.id + '_mapsTooltip')) {\n                                        (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.removeElement)(maps.element.id + '_mapsTooltip');\n                                    }\n                                }\n                                if (document.getElementById(maps.element.id + '_mapsTooltip') && maps.mapsTooltipModule.tooltipTargetID.indexOf('_MarkerIndex_')\n                                    && !this_1.isPanModeEnabled) {\n                                    var mapsTooltip = maps.mapsTooltipModule;\n                                    var tooltipElement = currentEle.querySelector('#' + mapsTooltip.tooltipTargetID);\n                                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(tooltipElement)) {\n                                        if (tooltipElement['style']['visibility'] === 'hidden') {\n                                            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.removeElement)(maps.element.id + '_mapsTooltip');\n                                        }\n                                        else {\n                                            var x_2 = parseFloat(tooltipElement.getAttribute('transform').split('(')[1].split(')')[0].split(' ')[1]);\n                                            var y_1 = parseFloat(tooltipElement.getAttribute('transform').split('(')[1].split(')')[0].split(' ')[2]);\n                                            if (maps.isTileMap) {\n                                                x_2 += +(0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(maps.element.id + '_tile_parent')['style']['left'].split('px')[0];\n                                                y_1 += +(0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(maps.element.id + '_tile_parent')['style']['top'].split('px')[0];\n                                            }\n                                            mapsTooltip.svgTooltip.location.x = x_2;\n                                            mapsTooltip.svgTooltip.location.y = y_1;\n                                            mapsTooltip.svgTooltip.enableAnimation = false;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        else if (currentEle.id.indexOf('_bubble_Group') > -1) {\n                            var childElement = void 0;\n                            for (var k = 0; k < currentEle.childElementCount; k++) {\n                                childElement = currentEle.childNodes[k];\n                                layerIndex = parseFloat(childElement.id.split('_LayerIndex_')[1].split('_')[0]);\n                                var bubleIndex = parseFloat(childElement.id.split('_BubbleIndex_')[1].split('_')[0]);\n                                var dataIndex = parseFloat(childElement.id.split('_BubbleIndex_')[1].split('_')[2]);\n                                for (var l = 0; l < maps.bubbleModule.bubbleCollection.length; l++) {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    var bubbleCollection = maps.bubbleModule.bubbleCollection[l];\n                                    if (bubbleCollection['LayerIndex'] === layerIndex && bubbleCollection['BubbleIndex'] === bubleIndex &&\n                                        bubbleCollection['DataIndex'] === dataIndex) {\n                                        var centerX = bubbleCollection['center']['x'];\n                                        var centerY = bubbleCollection['center']['y'];\n                                        var currentX = ((centerX + x) * scale);\n                                        var currentY = ((centerY + y) * scale);\n                                        var duration = this_1.currentLayer.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable' ? 1000 : this_1.currentLayer.animationDuration;\n                                        if (!animate || duration === 0) {\n                                            childElement.setAttribute('transform', 'translate( ' + currentX + ' ' + currentY + ' )');\n                                        }\n                                        else {\n                                            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.smoothTranslate)(childElement, 0, duration, new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.MapLocation(currentX, currentY));\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        else if (currentEle.id.indexOf('_dataLableIndex_Group') > -1 && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(maps.layers[this_1.index])) {\n                            maps.zoomLabelPositions = [];\n                            maps.zoomLabelPositions = maps.dataLabelModule.dataLabelCollections;\n                            var labelAnimate_1 = !maps.isTileMap && animate;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            var intersect_1 = [];\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            Array.prototype.forEach.call(currentEle.childNodes, function (childNode, k) {\n                                if (currentEle.childNodes[k]['id'].indexOf('_LabelIndex_') > -1) {\n                                    var labelIndex = parseFloat(currentEle.childNodes[k]['id'].split('_LabelIndex_')[1].split('_')[0]);\n                                    var zoomShapeWidth = currentEle.childNodes[k].id;\n                                    maps.zoomShapeCollection.push(zoomShapeWidth);\n                                    _this.dataLabelTranslate(currentEle.childNodes[k], factor_1, x, y, scale, 'DataLabel', labelAnimate_1, currentLabelIndex, isPanning, intersect_1);\n                                    currentLabelIndex++;\n                                    var dataLabel = maps.layers[_this.index].dataLabelSettings;\n                                    var border = dataLabel.border;\n                                    if (k > 0 && border['width'] > 1) {\n                                        if (currentEle.childNodes[k - 1]['id'].indexOf('_rectIndex_') > -1 && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(maps.zoomLabelPositions[labelIndex])) {\n                                            var labelX = ((maps.zoomLabelPositions[labelIndex]['location']['x'] + x) * scale);\n                                            var labelY = ((maps.zoomLabelPositions[labelIndex]['location']['y'] + y) * scale);\n                                            var zoomtext = currentEle.childNodes[k]['textContent'];\n                                            var style = maps.layers[_this.index].dataLabelSettings.textStyle;\n                                            var zoomtextSize = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.measureText)(zoomtext, style);\n                                            var padding = 5;\n                                            var rectElement = currentEle.childNodes[k - 1];\n                                            var rectX = labelX - zoomtextSize['width'] / 2;\n                                            var rectY = labelY - zoomtextSize['height'] / 2 - padding;\n                                            rectElement['setAttribute']('x', rectX);\n                                            rectElement['setAttribute']('y', rectY);\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                    };\n                    for (var j = 0; j < elementCount; j++) {\n                        _loop_2(j);\n                    }\n                }\n                maps.arrangeTemplate();\n            };\n            var this_1 = this;\n            for (var i = 0; i < this.layerCollectionEle.childElementCount; i++) {\n                _loop_1(i);\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.currentLayer)) {\n                if (!animate || this.currentLayer.animationDuration === 0 || maps.isTileMap) {\n                    this.processTemplate(x, y, scale, maps);\n                }\n            }\n        }\n    };\n    Zoom.prototype.markerTranslates = function (element, factor, x, y, scale, type, layerElement) {\n        var _this = this;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var templateFn;\n        var nullCount = 0;\n        var markerCounts = 0;\n        var markerTemplateCounts = 0;\n        var layerIndex = parseInt((element ? element : layerElement).id.split('_LayerIndex_')[1].split('_')[0], 10);\n        var markerSVGObject = this.maps.renderer.createGroup({\n            id: this.maps.element.id + '_Markers_Group',\n            class: 'GroupElement'\n        });\n        markerSVGObject.style.pointerEvents = 'auto';\n        if (document.getElementById(markerSVGObject.id)) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.removeElement)(markerSVGObject.id);\n        }\n        var mapsAreaRect = this.maps.mapAreaRect;\n        var markerTemplateElements = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', {\n            id: this.maps.element.id + '_LayerIndex_' + layerIndex + '_Markers_Template_Group',\n            className: 'template'\n        });\n        markerTemplateElements.style.cssText = 'overflow: hidden; position: absolute;pointer-events: none;' +\n            'top:' + mapsAreaRect.y + 'px;' +\n            'left:' + mapsAreaRect.x + 'px;' +\n            'height:' + mapsAreaRect.height + 'px;' +\n            'width:' + mapsAreaRect.width + 'px;';\n        if (document.getElementById(markerTemplateElements.id)) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.removeElement)(markerTemplateElements.id);\n        }\n        var currentLayers = this.maps.layersCollection[layerIndex];\n        var allowInnerClusterSetting = this.maps.markerModule.allowInnerClusterSetting(currentLayers);\n        Array.prototype.forEach.call(currentLayers.markerSettings, function (markerSettings, markerIndex) {\n            markerTemplateCounts = 0;\n            markerCounts = 0;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var markerDatas = markerSettings.dataSource;\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerDatas)) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                Array.prototype.forEach.call(markerDatas, function (data, dataIndex) {\n                    _this.maps.markerNullCount = markerIndex >= 0 && dataIndex === 0 ? 0 : _this.maps.markerNullCount;\n                    var eventArgs = {\n                        template: markerSettings.template, data: data, maps: _this.maps, marker: markerSettings,\n                        cancel: false, name: _index__WEBPACK_IMPORTED_MODULE_2__.markerRendering, fill: markerSettings.fill, colorValuePath: markerSettings.colorValuePath,\n                        shapeValuePath: markerSettings.shapeValuePath,\n                        height: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerSettings.heightValuePath) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data[markerSettings.heightValuePath])\n                            ? data[markerSettings.heightValuePath] : markerSettings.height,\n                        width: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerSettings.widthValuePath) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data[markerSettings.widthValuePath])\n                            ? data[markerSettings.widthValuePath] : markerSettings.width,\n                        imageUrl: markerSettings.imageUrl, imageUrlValuePath: markerSettings.imageUrlValuePath, shape: markerSettings.shape,\n                        border: markerSettings.border\n                    };\n                    eventArgs = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerShapeChoose)(eventArgs, data);\n                    eventArgs = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerColorChoose)(eventArgs, data);\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    _this.maps.trigger('markerRendering', eventArgs, function (MarkerArgs) {\n                        if (markerSettings.shapeValuePath !== eventArgs.shapeValuePath) {\n                            eventArgs = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerShapeChoose)(eventArgs, data);\n                        }\n                        if (markerSettings.colorValuePath !== eventArgs.colorValuePath) {\n                            eventArgs = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerColorChoose)(eventArgs, data);\n                        }\n                        var lati = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerSettings.latitudeValuePath)) ?\n                            Number((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getValueFromObject)(data, markerSettings.latitudeValuePath)) : !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data['latitude']) ?\n                            parseFloat(data['latitude']) : !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data['Latitude']) ? data['Latitude'] : null;\n                        var long = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerSettings.longitudeValuePath)) ?\n                            Number((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getValueFromObject)(data, markerSettings.longitudeValuePath)) : !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data['longitude']) ?\n                            parseFloat(data['longitude']) : !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data['Longitude']) ? data['Longitude'] : null;\n                        var offset = markerSettings.offset;\n                        if (!eventArgs.cancel && markerSettings.visible && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(long) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(lati)) {\n                            var markerID = _this.maps.element.id + '_LayerIndex_' + layerIndex + '_MarkerIndex_'\n                                + markerIndex + '_dataIndex_' + dataIndex;\n                            var location_1 = (_this.maps.isTileMap) ? (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.convertTileLatLongToPoint)(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.MapLocation(long, lati), _this.isPinchZooming ? _this.pinchZoomScale : _this.maps.tileZoomLevel, _this.maps.tileTranslatePoint, true) : (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.convertGeoToPoint)(lati, long, factor, currentLayers, _this.maps);\n                            var transPoint = { x: x, y: y };\n                            if (eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {\n                                markerTemplateCounts++;\n                                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.markerTemplate)(eventArgs, templateFn, markerID, data, markerIndex, markerTemplateElements, location_1, transPoint, scale, offset, _this.maps);\n                            }\n                            else if (!eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {\n                                markerCounts++;\n                                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.marker)(eventArgs, markerSettings, markerDatas, dataIndex, location_1, transPoint, markerID, offset, scale, _this.maps, markerSVGObject);\n                            }\n                        }\n                        nullCount += (!isNaN(lati) && !isNaN(long)) ? 0 : 1;\n                        markerTemplateCounts += (eventArgs.cancel) ? 1 : 0;\n                        markerCounts += (eventArgs.cancel) ? 1 : 0;\n                        _this.maps.markerNullCount = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(lati) || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(long))\n                            ? _this.maps.markerNullCount + 1 : _this.maps.markerNullCount;\n                        var markerDataLength = markerDatas.length - _this.maps.markerNullCount;\n                        var isMarkersClustered = false;\n                        var markerGroup = (markerSettings.clusterSettings.allowClustering\n                            || (currentLayers.markerClusterSettings.allowClustering && currentLayers.markerSettings.length > 1))\n                            ? markerSVGObject.querySelectorAll(\"[id*='LayerIndex_\" + layerIndex + \"_MarkerIndex_\" + markerIndex + \"']:not([id*='_Group'])\")\n                            : markerSVGObject.childNodes;\n                        if (markerGroup.length === (markerDataLength - markerTemplateCounts - nullCount) && (type !== 'Template')) {\n                            if (_this.maps.isTileMap) {\n                                var polygonsElement = document.getElementById(_this.maps.element.id + '_LayerIndex_' + layerIndex + '_Polygons_Group');\n                                var polygonElement = document.getElementById(_this.maps.element.id + '_LayerIndex_' + layerIndex + '_Polygon_Group');\n                                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(polygonsElement)) {\n                                    polygonsElement.insertAdjacentElement('afterend', markerSVGObject);\n                                }\n                                else {\n                                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(polygonElement)) {\n                                        polygonElement.insertAdjacentElement('afterend', markerSVGObject);\n                                    }\n                                    else {\n                                        layerElement.insertBefore(markerSVGObject, layerElement.firstElementChild);\n                                    }\n                                }\n                            }\n                            else {\n                                layerElement.appendChild(markerSVGObject);\n                            }\n                            if (currentLayers.markerSettings[markerIndex].clusterSettings.allowClustering ||\n                                !allowInnerClusterSetting && currentLayers.markerClusterSettings.allowClustering) {\n                                _this.maps.svgObject.appendChild(markerSVGObject);\n                                _this.maps.element.appendChild(_this.maps.svgObject);\n                                isMarkersClustered = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.clusterTemplate)(currentLayers, markerSVGObject, _this.maps, layerIndex, markerIndex, markerSVGObject, layerElement, true, true, null, allowInnerClusterSetting);\n                            }\n                        }\n                        var markerTemplateGroup = (markerSettings.clusterSettings.allowClustering\n                            || (currentLayers.markerClusterSettings.allowClustering && currentLayers.markerSettings.length > 1))\n                            ? markerTemplateElements.querySelectorAll(\"[id*='LayerIndex_\" + layerIndex + \"_MarkerIndex_\" + markerIndex + \"']:not([id*='_Group'])\")\n                            : markerTemplateElements.childNodes;\n                        if (markerTemplateGroup.length === (markerDataLength - markerCounts - nullCount) && (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(_this.maps.element.id + '_Secondary_Element')) {\n                            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(_this.maps.element.id + '_Secondary_Element').appendChild(markerTemplateElements);\n                            if (scale >= 1) {\n                                if ((markerSettings.clusterSettings.allowClustering || !allowInnerClusterSetting &&\n                                    currentLayers.markerClusterSettings.allowClustering) && !isMarkersClustered) {\n                                    (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.clusterTemplate)(currentLayers, markerTemplateElements, _this.maps, layerIndex, markerIndex, markerSVGObject, layerElement, false, true, null, allowInnerClusterSetting);\n                                }\n                            }\n                        }\n                    });\n                });\n            }\n        });\n    };\n    /**\n     * To translate the layer template elements.\n     *\n     * @param {number} x - Specifies the x value\n     * @param {number} y - Specifies the y value\n     * @param {number} scale - Specifies the scale value\n     * @param {Maps} maps - Specifies the maps value\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.processTemplate = function (x, y, scale, maps) {\n        var currentLabelIndex = 0;\n        for (var i = 0; i < this.templateCount; i++) {\n            var factor = maps.mapLayerPanel.calculateFactor(this.currentLayer);\n            var markerTemplateElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(maps.element.id + '_LayerIndex_' +\n                i + '_Markers_Template_Group');\n            var datalabelTemplateElemement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(maps.element.id + '_LayerIndex_'\n                + i + '_Label_Template_Group');\n            var polygonElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(maps.element.id + '_LayerIndex_'\n                + i + '_Polygons_Group');\n            if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerTemplateElement)) && markerTemplateElement.childElementCount > 0) {\n                markerTemplateElement.style.visibility = 'visible';\n                for (var k = 0; k < markerTemplateElement.childElementCount; k++) {\n                    this.markerTranslate(markerTemplateElement.childNodes[k], factor, x, y, scale, 'Template');\n                }\n            }\n            if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(datalabelTemplateElemement)) && datalabelTemplateElemement.childElementCount > 0) {\n                for (var k = 0; k < datalabelTemplateElemement.childElementCount; k++) {\n                    this.dataLabelTranslate(datalabelTemplateElemement.childNodes[k], factor, x, y, scale, 'Template', false, currentLabelIndex);\n                    currentLabelIndex++;\n                }\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(polygonElement)) {\n                for (var k = 0; k < polygonElement.childElementCount; k++) {\n                    var width = maps.layersCollection[i].polygonSettings.polygons[k].borderWidth;\n                    polygonElement.childNodes[k].childNodes[0].setAttribute('stroke-width', (width / scale).toString());\n                }\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Zoom.prototype.dataLabelTranslate = function (element, factor, x, y, scale, type, animate, currentLabelIndex, isPanning, intersect) {\n        if (animate === void 0) { animate = false; }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var labelCollection = this.maps.dataLabelModule.dataLabelCollections;\n        var text;\n        var trimmedLable;\n        var style = this.maps.layers[this.index].dataLabelSettings.textStyle;\n        var zoomtext;\n        var zoomtextSize;\n        var zoomtrimLabel;\n        var layerIndex = parseFloat(element.id.split('_LayerIndex_')[1].split('_')[0]);\n        var shapeIndex = parseFloat(element.id.split('_shapeIndex_')[1].split('_')[0]);\n        var labelIndex;\n        if (element.id.indexOf('_LabelIndex_') > -1) {\n            labelIndex = parseFloat(element.id.split('_LabelIndex_')[1].split('_')[0]);\n        }\n        var duration = this.currentLayer.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable' ? 1000 : this.currentLayer.animationDuration;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var label = labelCollection[currentLabelIndex];\n        var index = currentLabelIndex;\n        if (label['layerIndex'] === layerIndex && label['shapeIndex'] === shapeIndex\n            && label['labelIndex'] === labelIndex) {\n            var labelX = label['location']['x'];\n            var labelY = label['location']['y'];\n            if (type === 'Template') {\n                var locationX = 0;\n                var locationY = 0;\n                if (this.maps.isTileMap) {\n                    zoomtext = label['dataLabelText'];\n                    zoomtextSize = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.measureText)(zoomtext, style);\n                    locationX = ((labelX + x) * scale) - (zoomtextSize['width'] / 2);\n                    locationY = ((labelY + y) * scale) - (zoomtextSize['height']);\n                }\n                else {\n                    var layerEle = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Layer_Collections');\n                    labelX = ((Math.abs(this.maps.baseMapRectBounds['min']['x'] - labelX)) * scale);\n                    labelY = ((Math.abs(this.maps.baseMapRectBounds['min']['y'] - labelY)) * scale);\n                    var layerOffset = layerEle.getBoundingClientRect();\n                    var elementOffset = element.parentElement.getBoundingClientRect();\n                    locationX = ((labelX) + (layerOffset.left - elementOffset.left));\n                    locationY = ((labelY) + (layerOffset.top - elementOffset.top));\n                }\n                element.style.left = locationX + 'px';\n                element.style.top = locationY + 'px';\n            }\n            else {\n                labelX = ((labelX + x) * scale);\n                labelY = ((labelY + y) * scale);\n                zoomtext = label['dataLabelText'];\n                if (!animate || duration === 0) {\n                    element.setAttribute('transform', 'translate( ' + labelX + ' ' + labelY + ' )');\n                }\n                if (((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(isPanning) || !isPanning) && (this.maps.layers[this.index].dataLabelSettings.smartLabelMode !== 'None' ||\n                    this.maps.layers[this.index].dataLabelSettings.intersectionAction !== 'None')) {\n                    zoomtextSize = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.measureTextElement)(zoomtext, style);\n                    var start = labelY - zoomtextSize['height'] / 2;\n                    var end = labelY + zoomtextSize['height'] / 2;\n                    var xpositionEnds = labelX + zoomtextSize['width'] / 2;\n                    var xpositionStart = labelX - zoomtextSize['width'] / 2;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    var textLocations = { rightWidth: xpositionEnds, leftWidth: xpositionStart, heightTop: start, heightBottom: end };\n                    if (this.maps.layers[this.index].dataLabelSettings.smartLabelMode === 'Hide') {\n                        if (scale > 1) {\n                            text = ((this.maps.dataLabelShape[index] * scale) >= zoomtextSize['width']) ? zoomtext : '';\n                            element.textContent = text;\n                        }\n                        else {\n                            text = (this.maps.dataLabelShape[index] >= zoomtextSize['width']) ? zoomtext : '';\n                            element.textContent = text;\n                        }\n                    }\n                    var widthList = [];\n                    if (this.maps.layers[this.index].dataLabelSettings.smartLabelMode === 'Trim') {\n                        if (scale > 1) {\n                            zoomtrimLabel = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textTrim)((this.maps.dataLabelShape[index] * scale), zoomtext, style, zoomtextSize.width, true, widthList);\n                            text = zoomtrimLabel;\n                            element.textContent = text;\n                        }\n                        else {\n                            zoomtrimLabel = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textTrim)(this.maps.dataLabelShape[index], zoomtext, style, zoomtextSize.width, true, widthList);\n                            text = zoomtrimLabel;\n                            element.textContent = text;\n                        }\n                    }\n                    if (this.maps.layers[this.index].dataLabelSettings.intersectionAction === 'Hide') {\n                        for (var m = 0; m < intersect.length; m++) {\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(intersect[m])) {\n                                if (textLocations['leftWidth'] > intersect[m]['rightWidth']\n                                    || textLocations['rightWidth'] < intersect[m]['leftWidth']\n                                    || textLocations['heightTop'] > intersect[m]['heightBottom']\n                                    || textLocations['heightBottom'] < intersect[m]['heightTop']) {\n                                    text = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(text) ? text : zoomtext;\n                                    element.textContent = text;\n                                }\n                                else {\n                                    text = '';\n                                    element.textContent = text;\n                                    break;\n                                }\n                            }\n                        }\n                        intersect.push(textLocations);\n                    }\n                    if (this.maps.layers[this.index].dataLabelSettings.intersectionAction === 'Trim') {\n                        for (var j = 0; j < intersect.length; j++) {\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(intersect[j])) {\n                                if (textLocations['rightWidth'] < intersect[j]['leftWidth']\n                                    || textLocations['leftWidth'] > intersect[j]['rightWidth']\n                                    || textLocations['heightBottom'] < intersect[j]['heightTop']\n                                    || textLocations['heightTop'] > intersect[j]['heightBottom']) {\n                                    trimmedLable = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(text) ? text : zoomtext;\n                                    if (scale > 1) {\n                                        var trimmedWidth = widthList.length > 0 ? widthList[0] : zoomtextSize.width;\n                                        trimmedLable = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textTrim)((this.maps.dataLabelShape[index] * scale), trimmedLable, style, trimmedWidth, true);\n                                    }\n                                    element.textContent = trimmedLable;\n                                }\n                                else {\n                                    if (textLocations['leftWidth'] > intersect[j]['leftWidth']) {\n                                        var width = intersect[j]['rightWidth'] - textLocations['leftWidth'];\n                                        var difference = width - (textLocations['rightWidth'] - textLocations['leftWidth']);\n                                        text = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(text) ? text : zoomtext;\n                                        var trimmedWidth = widthList.length > 0 ? widthList[0] : zoomtextSize.width;\n                                        trimmedLable = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textTrim)(difference, text, style, trimmedWidth, true);\n                                        element.textContent = trimmedLable;\n                                        break;\n                                    }\n                                    if (textLocations['leftWidth'] < intersect[j]['leftWidth']) {\n                                        var width = textLocations['rightWidth'] - intersect[j]['leftWidth'];\n                                        var difference = Math.abs(width - (textLocations['rightWidth'] - textLocations['leftWidth']));\n                                        text = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(text) ? text : zoomtext;\n                                        var trimmedWidth = widthList.length > 0 ? widthList[0] : zoomtextSize.width;\n                                        trimmedLable = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textTrim)(difference, text, style, trimmedWidth, true);\n                                        element.textContent = trimmedLable;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        intersect.push(textLocations);\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(trimmedLable)) {\n                            trimmedLable = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textTrim)((this.maps.dataLabelShape[index] * scale), zoomtext, style, zoomtextSize.width, true);\n                            element.textContent = trimmedLable;\n                        }\n                    }\n                }\n                if (animate || duration > 0) {\n                    (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.smoothTranslate)(element, 0, duration, new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.MapLocation(labelX, labelY));\n                }\n            }\n        }\n    };\n    /**\n     *\n     * @param {Element | HTMLElement} element - Specifies the marker element.\n     * @param {number} factor - Specifies scale factor.\n     * @param {number} x - Specifies the x location of the marker element.\n     * @param {number} y - Specifies the y location of the marker element.\n     * @param {number} scale - Specifies scale factor.\n     * @param {number} type - Specifies the type of the marker processing.\n     * @param {number} animate - Specifies whether the animation is enabled or not.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.markerTranslate = function (element, factor, x, y, scale, type, animate) {\n        if (animate === void 0) { animate = false; }\n        var layerIndex = parseInt(element.id.split('_LayerIndex_')[1].split('_')[0], 10);\n        var markerIndex = parseInt(element.id.split('_MarkerIndex_')[1].split('_')[0], 10);\n        var dataIndex = parseInt(element.id.split('_dataIndex_')[1].split('_')[0], 10);\n        var layer = this.maps.layersCollection[layerIndex];\n        var marker = layer.markerSettings[markerIndex];\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.dataSource) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.dataSource[dataIndex])) {\n            var lng = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.longitudeValuePath)) ?\n                Number((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getValueFromObject)(marker.dataSource[dataIndex], marker.longitudeValuePath)) :\n                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.dataSource[dataIndex]['longitude']) ? parseFloat(marker.dataSource[dataIndex]['longitude']) :\n                    !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.dataSource[dataIndex]['Longitude']) ? parseFloat(marker.dataSource[dataIndex]['Longitude']) : 0;\n            var lat = (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.latitudeValuePath)) ?\n                Number((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getValueFromObject)(marker.dataSource[dataIndex], marker.latitudeValuePath)) :\n                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.dataSource[dataIndex]['latitude']) ? parseFloat(marker.dataSource[dataIndex]['latitude']) :\n                    !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(marker.dataSource[dataIndex]['Latitude']) ? parseFloat(marker.dataSource[dataIndex]['Latitude']) : 0;\n            var duration = this.currentLayer.animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable' ? 1000 : this.currentLayer.animationDuration;\n            var location_2 = (this.maps.isTileMap) ? (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.convertTileLatLongToPoint)(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(lng, lat), this.isPinchZooming ? this.pinchZoomScale : this.maps.tileZoomLevel, this.maps.tileTranslatePoint, true) : (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.convertGeoToPoint)(lat, lng, factor, layer, this.maps);\n            if (this.maps.isTileMap) {\n                if (type === 'Template') {\n                    element.style.left = (location_2.x + marker.offset.x) + 'px';\n                    element.style.top = (location_2.y + marker.offset.y) + 'px';\n                }\n                else {\n                    location_2.x += marker.offset.x;\n                    location_2.y += marker.offset.y;\n                    element.setAttribute('transform', 'translate( ' + location_2.x + ' ' + location_2.y + ' )');\n                }\n            }\n            else {\n                if (type === 'Template') {\n                    if (duration > 0) {\n                        location_2.x = ((Math.abs(this.maps.baseMapRectBounds['min']['x'] - location_2.x)) * scale);\n                        location_2.y = ((Math.abs(this.maps.baseMapRectBounds['min']['y'] - location_2.y)) * scale);\n                        var layerOffset = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Layer_Collections').getBoundingClientRect();\n                        var elementOffset = element.parentElement.getBoundingClientRect();\n                        element.style.left = (((location_2.x) + (layerOffset.left - elementOffset.left)) + marker.offset.x) + 'px';\n                        element.style.top = (((location_2.y) + (layerOffset.top - elementOffset.top)) + marker.offset.y) + 'px';\n                        element.style.transform = 'translate(-50%, -50%)';\n                    }\n                    else {\n                        element.style.left = ((location_2.x + x) * scale) + marker.offset.x - this.maps.mapAreaRect.x + 'px';\n                        element.style.top = ((location_2.y + y) * scale) + marker.offset.y - this.maps.mapAreaRect.y + 'px';\n                    }\n                }\n                else {\n                    location_2.x = (((location_2.x + x) * scale) + marker.offset.x);\n                    location_2.y = (((location_2.y + y) * scale) + marker.offset.y);\n                    if (!animate || duration === 0) {\n                        element.setAttribute('transform', 'translate( ' + location_2.x + ' ' + location_2.y + ' )');\n                    }\n                    else {\n                        (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.smoothTranslate)(element, 0, duration, location_2);\n                    }\n                }\n            }\n        }\n    };\n    Zoom.prototype.markerLineAnimation = function (map) {\n        if (map.isTileMap) {\n            for (var i = 0; i < map.layersCollection.length; i++) {\n                var markerTemplateElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_LayerIndex_' + i + '_Markers_Template_Group');\n                var lineElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_LayerIndex_' + i + '_line_Group');\n                var polygonElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_LayerIndex_' + i + '_Polygons_Group');\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markerTemplateElement)) {\n                    markerTemplateElement.style.visibility = 'hidden';\n                }\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(lineElement)) {\n                    lineElement.style.visibility = 'hidden';\n                }\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(polygonElement)) {\n                    polygonElement.style.visibility = 'hidden';\n                }\n            }\n        }\n    };\n    /**\n     * @param {PanDirection} direction - Specifies the direction of the panning.\n     * @param {number} xDifference - Specifies the distance moved in the horizontal direction.\n     * @param {number} yDifference - Specifies the distance moved in the vertical direction.\n     * @param {PointerEvent | TouchEvent | KeyboardEvent} event - Specifies the pointer event argument.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.panning = function (direction, xDifference, yDifference, event) {\n        var map = this.maps;\n        var panArgs;\n        var down = this.mouseDownPoints;\n        var move = this.mouseMovePoints;\n        var scale = map.scale;\n        map.markerZoomedState = false;\n        map.zoomPersistence = map.enablePersistence;\n        map.defaultState = false;\n        map.initialCheck = false;\n        var translatePoint = map.translatePoint;\n        var prevTilePoint = map.tileTranslatePoint;\n        var x;\n        var y;\n        xDifference = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(xDifference) ? xDifference : (down.x - move.x);\n        yDifference = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(yDifference) ? yDifference : (down.y - move.y);\n        var layerX = event.type.indexOf('mouse') > -1 || event.type.indexOf('key') > -1 ? event['layerX'] : event.touches[0].pageX;\n        var layerY = event.type.indexOf('mouse') > -1 || event.type.indexOf('key') > -1 ? event['layerY'] : event.touches[0].pageY;\n        this.maps.mergeCluster();\n        if (!map.isTileMap) {\n            var marginTop = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getProcessedMarginValue)(map.margin.top);\n            var legendElement = document.getElementById(map.element.id + '_Legend_Group');\n            var legendHeight = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(legendElement) ? legendElement.getClientRects()[0].height : 0;\n            x = translatePoint.x - xDifference / scale;\n            y = translatePoint.y - yDifference / scale;\n            var layerRect = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_Layer_Collections').getBoundingClientRect();\n            var elementRect = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_svg').getBoundingClientRect();\n            var panningXDirection = ((xDifference < 0 ? layerRect.left <= (elementRect.left + map.mapAreaRect.x) :\n                ((layerRect.left + layerRect.width + map.mapAreaRect.x) >= (elementRect.width))));\n            var panningYDirection = ((yDifference < 0 ? layerRect.top <= (elementRect.top + map.mapAreaRect.y) :\n                ((layerRect.top + layerRect.height + legendHeight + marginTop) >= (elementRect.top + elementRect.height))));\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var location_3 = this.maps.getGeoLocation(this.maps.layersCollection.length - 1, layerX, layerY);\n            var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();\n            panArgs = {\n                cancel: false, name: _model_constants__WEBPACK_IMPORTED_MODULE_3__.pan, maps: map,\n                tileTranslatePoint: {}, translatePoint: { previous: translatePoint, current: new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(x, y) },\n                scale: map.scale, tileZoomLevel: map.tileZoomLevel, latitude: location_3['latitude'], longitude: location_3['longitude'],\n                minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n            };\n            map.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_3__.pan, panArgs);\n            if (!panArgs.cancel) {\n                if (panningXDirection && panningYDirection) {\n                    map.translatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);\n                    this.applyTransform(map, false, false, true);\n                }\n                else if (panningXDirection) {\n                    map.translatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(x, map.translatePoint.y);\n                    this.applyTransform(map, false, false, true);\n                }\n                else if (panningYDirection) {\n                    map.translatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(map.translatePoint.x, y);\n                    this.applyTransform(map, false, false, true);\n                }\n            }\n            this.maps.zoomNotApplied = false;\n        }\n        else if (this.maps.tileZoomLevel > 1) {\n            x = map.tileTranslatePoint.x - xDifference;\n            y = map.tileTranslatePoint.y - yDifference;\n            map.tileTranslatePoint.x = x;\n            map.tileTranslatePoint.y = y;\n            if ((map.tileTranslatePoint.y > -10 && yDifference < 0) || ((map.tileTranslatePoint.y < -((Math.pow(2, this.maps.tileZoomLevel) - 2) * 256) && yDifference > 0))) {\n                map.tileTranslatePoint.x = x + xDifference;\n                map.tileTranslatePoint.y = y + yDifference;\n            }\n            map.translatePoint.x = (map.tileTranslatePoint.x) / map.scale;\n            map.translatePoint.y = (map.tileTranslatePoint.y) / map.scale;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var location_4 = this.maps.getTileGeoLocation(layerX, layerY);\n            var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();\n            panArgs = {\n                cancel: false, name: _model_constants__WEBPACK_IMPORTED_MODULE_3__.pan, maps: map,\n                tileTranslatePoint: { previous: prevTilePoint, current: map.tileTranslatePoint },\n                translatePoint: { previous: translatePoint, current: map.translatePoint }, scale: map.scale,\n                tileZoomLevel: map.tileZoomLevel, latitude: location_4['latitude'], longitude: location_4['longitude'],\n                minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n            };\n            map.trigger(_model_constants__WEBPACK_IMPORTED_MODULE_3__.pan, panArgs);\n            map.mapLayerPanel.generateTiles(map.tileZoomLevel, map.tileTranslatePoint, 'Pan');\n            this.applyTransform(map, false, false, true);\n            map.translatePoint.x = (map.tileTranslatePoint.x - xDifference) / map.scale;\n            map.translatePoint.y = (map.tileTranslatePoint.y - yDifference) / map.scale;\n        }\n        map.zoomTranslatePoint = map.translatePoint;\n        this.mouseDownPoints = this.mouseMovePoints;\n        this.isSingleClick = false;\n    };\n    /**\n     * @param {number} zoomFactor - Specifies the factor for zooming\n     * @param {string} type - Specifies the type\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.toolBarZooming = function (zoomFactor, type) {\n        var _this = this;\n        var map = this.maps;\n        map.initialCheck = map.isMarkerZoomCompleted = false;\n        map.defaultState = ((type === 'Reset' && zoomFactor === 1 && !(map.zoomSettings.resetToInitial && map.applyZoomReset))\n            || (type === 'ZoomOut' && zoomFactor === 1));\n        var prevLevel = map.tileZoomLevel;\n        var scale = map.previousScale = map.scale;\n        map.markerZoomedState = false;\n        map.zoomPersistence = map.enablePersistence;\n        map.mapScaleValue = zoomFactor;\n        var maxZoom = map.zoomSettings.maxZoom;\n        var minZoom = map.zoomSettings.minZoom;\n        var size = map.mapAreaRect;\n        var translatePoint = map.previousPoint = map.translatePoint;\n        var prevTilePoint = map.tileTranslatePoint;\n        this.maps.mergeCluster();\n        map.previousProjection = type === 'Reset' ? undefined : map.projectionType;\n        zoomFactor = (type === 'ZoomOut') ? (Math.round(zoomFactor) === 1 ? 1 : zoomFactor) : zoomFactor;\n        zoomFactor = (type === 'Reset') ? minZoom : (Math.round(zoomFactor) === 0) ? 1 : zoomFactor;\n        zoomFactor = (minZoom > zoomFactor && type === 'ZoomIn') ? minZoom + 1 : zoomFactor;\n        if ((!map.isTileMap) && (type === 'ZoomIn' ? zoomFactor >= minZoom && Math.round(zoomFactor) <= maxZoom : zoomFactor >= minZoom\n            || map.isReset)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var min = map.baseMapRectBounds['min'];\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var max = map.baseMapRectBounds['max'];\n            var mapWidth = Math.abs(max['x'] - min['x']);\n            var mapHeight = Math.abs(min['y'] - max['y']);\n            var translatePointX = void 0;\n            var translatePointY = void 0;\n            if (zoomFactor < 1.2 && map.projectionType !== 'Eckert5') {\n                if (mapHeight === 0 || mapWidth === 0 || mapHeight === mapWidth) {\n                    mapWidth = size.width / 2;\n                    mapHeight = size.height;\n                }\n                zoomFactor = parseFloat(Math.min(size.width / mapWidth, size.height / mapHeight).toFixed(2));\n                zoomFactor = zoomFactor > 1.05 ? 1 : zoomFactor;\n                map.translatePoint = this.calculateInitalZoomTranslatePoint(zoomFactor, mapWidth, mapHeight, size, min, map);\n            }\n            else {\n                translatePointX = translatePoint.x - (((size.width / scale) - (size.width / zoomFactor)) / 2);\n                translatePointY = translatePoint.y - (((size.height / scale) - (size.height / zoomFactor)) / 2);\n                var currentHeight = Math.abs(map.baseMapRectBounds['max']['y'] - map.baseMapRectBounds['min']['y']) * zoomFactor;\n                translatePointX = (currentHeight < map.mapAreaRect.height) ? (size.x + ((-(min['x'])) + ((size.width / 2) - (mapWidth / 2))))\n                    : translatePointX;\n                translatePointY = (currentHeight < map.mapAreaRect.height) ? (size.y + ((-(min['y'])) + ((size.height / 2) - (mapHeight / 2))))\n                    : translatePointY;\n                map.translatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(translatePointX, translatePointY);\n            }\n            map.zoomTranslatePoint = map.translatePoint;\n            map.scale = zoomFactor;\n            if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {\n                map.translatePoint = map.zoomTranslatePoint = map.previousPoint;\n                map.scale = map.previousScale;\n            }\n            else {\n                this.applyTransform(map, false, true);\n            }\n        }\n        else if ((map.isTileMap) && ((zoomFactor >= minZoom && zoomFactor <= maxZoom) || map.isReset)) {\n            var tileZoomFactor = prevLevel < minZoom && !map.isReset ? minZoom : zoomFactor;\n            map.scale = Math.pow(2, tileZoomFactor - 1);\n            map.tileZoomLevel = tileZoomFactor;\n            if (map.previousScale !== map.scale || map.isReset) {\n                map.zoomSettings.zoomFactor = zoomFactor;\n                var position = { x: map.availableSize.width / 2, y: map.availableSize.height / 2 };\n                this.getTileTranslatePosition(prevLevel, tileZoomFactor, position, type);\n                if (map.zoomSettings.resetToInitial && map.applyZoomReset && type === 'Reset' || (type === 'ZoomOut' && map.zoomSettings.resetToInitial && map.applyZoomReset && tileZoomFactor <= map.initialZoomLevel)) {\n                    map.initialCheck = true;\n                    map.zoomPersistence = false;\n                    map.tileTranslatePoint.x = map.initialTileTranslate.x;\n                    map.tileTranslatePoint.y = map.initialTileTranslate.y;\n                    tileZoomFactor = map.tileZoomLevel = map.mapScaleValue = map.initialZoomLevel;\n                }\n                if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {\n                    map.translatePoint = map.tileTranslatePoint = new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);\n                    map.scale = map.previousScale;\n                    map.tileZoomLevel = prevLevel;\n                    map.zoomSettings.zoomFactor = map.previousScale;\n                }\n                else {\n                    map.translatePoint.y = (map.tileTranslatePoint.y - (0.01 * map.mapScaleValue)) / map.scale;\n                    map.translatePoint.x = (map.tileTranslatePoint.x - (0.01 * map.mapScaleValue)) / map.scale;\n                    if (document.getElementById(this.maps.element.id + '_LayerIndex_1')) {\n                        document.getElementById(this.maps.element.id + '_LayerIndex_1').style.display = 'none';\n                    }\n                    if (document.querySelector('.GroupElement')) {\n                        document.querySelector('.GroupElement').style.display = 'none';\n                    }\n                    this.markerLineAnimation(map);\n                    map.mapLayerPanel.generateTiles(tileZoomFactor, map.tileTranslatePoint, type);\n                    var animationDuration = this.maps.layersCollection[0].animationDuration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.animationMode === 'Enable' ? 1000 : this.maps.layersCollection[0].animationDuration;\n                    setTimeout(function () {\n                        if (type === 'ZoomOut' || type === 'Reset') {\n                            // element1.removeChild(element1.children[element1.childElementCount - 1]);\n                            // element1.childElementCount ? element1.removeChild(element1.children[element1.childElementCount - 1]) : element1;\n                        }\n                        _this.applyTransform(_this.maps, false, true);\n                        if (document.getElementById(_this.maps.element.id + '_LayerIndex_1')) {\n                            document.getElementById(_this.maps.element.id + '_LayerIndex_1').style.display = 'block';\n                        }\n                        _this.maps.isAddLayer = false;\n                    }, animationDuration);\n                }\n            }\n            this.maps.zoomNotApplied = false;\n        }\n        this.triggerZoomComplete(map, prevLevel, type);\n    };\n    /**\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.createZoomingToolbars = function () {\n        var map = this.maps;\n        this.toolBarGroup = map.renderer.createGroup({\n            id: map.element.id + '_Zooming_KitCollection',\n            opacity: map.theme.toLowerCase() === 'fluentdark' ? 0.6 : 0.3\n        });\n        var xSpacing = 15;\n        var ySpacing = 15;\n        var toolbar = map.zoomSettings.toolbarSettings;\n        var button = map.zoomSettings.toolbarSettings.buttonSettings;\n        this.maps.toolbarProperties = {\n            toolBarOrientation: toolbar.orientation,\n            highlightColor: button.highlightColor,\n            selectionColor: button.selectionColor,\n            horizontalAlignment: toolbar.horizontalAlignment,\n            verticalAlignment: toolbar.verticalAlignment,\n            color: button.color,\n            shapeOpacity: button.opacity,\n            borderOpacity: button.borderOpacity\n        };\n        var buttonRadius = button.radius || map.themeStyle.zoomButtonRadius;\n        var cx = buttonRadius / 4;\n        var cy = buttonRadius / 4;\n        var radius = buttonRadius / 2;\n        var padding = button.padding;\n        var orientation = this.maps.toolbarProperties.toolBarOrientation;\n        var toolbarCollection = map.zoomSettings.toolbarSettings.buttonSettings.toolbarItems.map(function (value) { return value; });\n        xSpacing = (buttonRadius / 4) + (button.borderWidth / 2) + padding;\n        ySpacing = (buttonRadius / 4) + (button.borderWidth / 2) + padding;\n        var shadowElement = '<filter id=\"chart_shadow\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"5\"/>';\n        shadowElement += '<feOffset dx=\"-3\" dy=\"4\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"1\"/>';\n        shadowElement += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n        var toolBarLength = toolbarCollection.length;\n        var toolWidth = (orientation === 'Horizontal') ? ((toolBarLength * buttonRadius) + (toolBarLength * padding) + padding + (toolBarLength * button.borderWidth)) : (buttonRadius + button.borderWidth + (2 * padding));\n        var toolHeight = (orientation === 'Horizontal') ? (buttonRadius + button.borderWidth + (2 * padding)) : ((toolBarLength * buttonRadius) + (toolBarLength * padding) + padding + (toolBarLength * button.borderWidth));\n        var defElement = map.renderer.createDefs();\n        defElement.innerHTML = shadowElement;\n        this.toolBarGroup.appendChild(defElement);\n        var outerElement = map.renderer.drawRectangle(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.RectOption(map.element.id + '_Zooming_Rect', toolbar.backgroundColor, { color: toolbar.borderColor, width: toolbar.borderWidth, opacity: toolbar.borderOpacity }, toolbar.borderOpacity, new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Rect((toolbar.borderWidth / 2), (toolbar.borderWidth / 2), (toolWidth - toolbar.borderWidth), (toolHeight - toolbar.borderWidth)), 0, 0));\n        this.toolBarGroup.appendChild(outerElement);\n        var scaleX = (buttonRadius - (button.borderWidth / 2)) / 30;\n        for (var i = 0; i < toolbarCollection.length; i++) {\n            if (i !== 0) {\n                xSpacing = (map.toolbarProperties.toolBarOrientation === 'Horizontal') ? (xSpacing + (buttonRadius + padding) + button.borderWidth) : xSpacing;\n                ySpacing = (map.toolbarProperties.toolBarOrientation === 'Horizontal') ? ySpacing : (ySpacing + (buttonRadius + padding) + button.borderWidth);\n            }\n            var toolbar_1 = toolbarCollection[i];\n            var pathStroke = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.maps.toolbarProperties.color) ? this.maps.toolbarProperties.color : this.maps.themeStyle.zoomFillColor;\n            var borderColor = button.borderColor || (this.maps.themeStyle.zoomBorderColor || this.maps.themeStyle.zoomFillColor);\n            this.currentToolbarEle = map.renderer.createGroup({\n                id: map.element.id + '_Zooming_ToolBar_' + toolbar_1 + '_Group',\n                transform: 'translate( ' + xSpacing + ' ' + ySpacing + ' ) '\n            });\n            this.currentToolbarEle.setAttribute('class', 'e-maps-toolbar');\n            this.currentToolbarEle.appendChild(map.renderer.drawCircle(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.CircleOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1 + '_Rect', button.fill, { color: borderColor, width: button.borderWidth, opacity: button.borderOpacity }, button.opacity, cx, cy, radius, '')));\n            var opacity = 1;\n            var direction = '';\n            var fill = button.fill;\n            this.selectionColor = this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor;\n            switch (toolbar_1.toLowerCase()) {\n                case 'zoom': {\n                    var fillColor = void 0;\n                    var strokeColor = void 0;\n                    direction = 'M0.001,14.629L1.372,16l4.571-4.571v-0.685l0.228-0.274c1.051,0.868,2.423,1.417,3.885,1.417c3.291,0,';\n                    direction += '5.943-2.651,5.943-5.943S13.395,0,10.103,0S4.16,2.651,4.16,5.943c0,1.508,0.503,2.834,1.417,3.885l-0.274,0.228H4.571';\n                    direction = direction + 'L0.001,14.629L0.001,14.629z M5.943,5.943c0-2.285,1.828-4.114,4.114-4.114s4.114,1.828,4.114,';\n                    this.currentToolbarEle.setAttribute('class', (this.maps.zoomSettings.enableSelectionZooming ? 'e-maps-toolbar' : ''));\n                    if (this.maps.zoomSettings.enablePanning && !this.maps.zoomSettings.enableSelectionZooming) {\n                        fillColor = fill;\n                        strokeColor = pathStroke;\n                    }\n                    else if (this.maps.zoomSettings.enablePanning && this.maps.zoomSettings.enableSelectionZooming) {\n                        fillColor = fill;\n                        strokeColor = pathStroke;\n                    }\n                    else if (!this.maps.zoomSettings.enablePanning && !this.maps.zoomSettings.enableSelectionZooming) {\n                        fillColor = fill;\n                        strokeColor = pathStroke;\n                    }\n                    else if (!this.maps.zoomSettings.enablePanning && this.maps.zoomSettings.enableSelectionZooming) {\n                        fillColor = this.maps.themeStyle.zoomFillColor;\n                        strokeColor = pathStroke;\n                    }\n                    else {\n                        fillColor = this.selectionColor;\n                        strokeColor = this.selectionColor;\n                    }\n                    var zoomPath = map.renderer.drawPath(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, fillColor, 1, strokeColor, opacity, opacity, null, direction + '4.114s-1.828,4.114-4.114,4.114S5.943,8.229,5.943,5.943z'));\n                    zoomPath.setAttribute('transform', 'scale( ' + scaleX + ',' + scaleX + ' )');\n                    this.currentToolbarEle.appendChild(zoomPath);\n                    this.zoomElements = this.currentToolbarEle;\n                    this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n                    break;\n                }\n                case 'zoomin':\n                    direction = 'M 8, 0 L 8, 16 M 0, 8 L 16, 8';\n                    /* eslint-disable no-case-declarations */\n                    var zoomInPath = map.renderer.drawPath(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1 + '_Path', fill, 3, pathStroke, 1, 1, null, direction));\n                    /* eslint-enable no-case-declarations */\n                    zoomInPath.setAttribute('transform', 'scale( ' + scaleX + ',' + scaleX + ' )');\n                    this.currentToolbarEle.appendChild(zoomInPath);\n                    this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n                    break;\n                case 'zoomout':\n                    direction = 'M 0, 8 L 16, 8';\n                    /* eslint-disable no-case-declarations */\n                    var zoomOutPath = map.renderer.drawPath(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, fill, 3, pathStroke, 1, 1, null, direction));\n                    /* eslint-enable no-case-declarations */\n                    zoomOutPath.setAttribute('transform', 'scale( ' + scaleX + ',' + scaleX + ' )');\n                    this.currentToolbarEle.appendChild(zoomOutPath);\n                    this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n                    break;\n                case 'pan': {\n                    var color = void 0;\n                    direction = 'M5,3h2.3L7.275,5.875h1.4L8.65,3H11L8,0L5,3z M3,11V8.7l2.875,0.025v-1.4L3,7.35V5L0,8L3,';\n                    direction += '11z M11,13H8.7l0.025-2.875h-1.4L7.35,13H5l3,3L11,13z M13,5v2.3l-2.875-0.025v1.4L13,8.65V11l3-3L13,5z';\n                    this.currentToolbarEle.setAttribute('class', (this.maps.zoomSettings.enablePanning ? 'e-maps-toolbar' : ''));\n                    if (this.maps.zoomSettings.enablePanning && this.maps.zoomModule.isDragZoom) {\n                        color = this.selectionColor || this.maps.themeStyle.zoomFillColor;\n                    }\n                    else if (!this.maps.zoomSettings.enablePanning) {\n                        color = this.selectionColor || this.maps.themeStyle.zoomFillColor;\n                        this.currentToolbarEle.setAttribute('class', '');\n                    }\n                    else {\n                        color = fill || this.maps.themeStyle.zoomFillColor;\n                    }\n                    var panPath = map.renderer.drawPath(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, color, 1, pathStroke, opacity, opacity, null, direction));\n                    panPath.setAttribute('transform', 'scale( ' + scaleX + ',' + scaleX + ' )');\n                    this.currentToolbarEle.appendChild(panPath);\n                    this.panColor = color;\n                    this.panElements = this.currentToolbarEle;\n                    this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n                    break;\n                }\n                case 'reset':\n                    direction = 'M12.364,8h-2.182l2.909,3.25L16,8h-2.182c0-3.575-2.618-6.5-5.818-6.5c-1.128,0-2.218,0.366-3.091,';\n                    direction += '1.016l1.055,1.178C6.581,3.328,7.272,3.125,8,3.125C10.4,3.125,12.363,5.319,12.364,8L12.364,8z M11.091,';\n                    direction += '13.484l-1.055-1.178C9.419,12.672,8.728,12.875,8,12.875c-2.4,0-4.364-2.194-4.364-4.875h2.182L2.909,4.75L0,8h2.182c0,';\n                    /* eslint-disable no-case-declarations */\n                    var resetPath = map.renderer.drawPath(new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(map.element.id + '_Zooming_ToolBar_' + toolbar_1, fill, null, pathStroke, 1, 1, null, direction + '3.575,2.618,6.5,5.818,6.5C9.128,14.5,10.219,14.134,11.091,13.484L11.091,13.484z'));\n                    /* eslint-enable no-case-declarations */\n                    resetPath.setAttribute('transform', 'scale( ' + scaleX + ',' + scaleX + ' )');\n                    this.currentToolbarEle.appendChild(resetPath);\n                    this.wireEvents(this.currentToolbarEle, this.performToolBarAction);\n                    break;\n            }\n            this.toolBarGroup.appendChild(this.currentToolbarEle);\n        }\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the event in the map\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.performToolBarAction = function (e) {\n        var target = e.target;\n        e.stopImmediatePropagation();\n        var isTouch = e.pointerType === 'touch' || e.pointerType === '2' || (e.type.indexOf('touch') > -1);\n        var toolbar = target.id.split('_Zooming_ToolBar_')[1].split('_')[0];\n        var isToolbarPerform = true;\n        switch (toolbar.toLowerCase()) {\n            case 'zoomin':\n                isToolbarPerform = (this.maps.isTileMap ? this.maps.tileZoomLevel : this.maps.scale) + 1 <= this.maps.zoomSettings.maxZoom;\n                break;\n            case 'zoomout':\n                /* eslint-disable no-case-declarations */\n                var scaleValue = this.maps.isTileMap ? this.maps.tileZoomLevel : this.maps.scale;\n                /* eslint-enable no-case-declarations */\n                isToolbarPerform = (this.maps.projectionType === 'Miller' || this.maps.projectionType === 'Winkel3' ||\n                    this.maps.projectionType === 'AitOff') ? Math.round(scaleValue) - 1 >= this.maps.zoomSettings.minZoom :\n                    (scaleValue) - 1 >= this.maps.zoomSettings.minZoom;\n                break;\n            case 'reset':\n                isToolbarPerform = Math.round(this.maps.isTileMap ? this.maps.tileZoomLevel : this.maps.scale) !== this.maps.zoomSettings.minZoom;\n                break;\n        }\n        if (isTouch && isToolbarPerform) {\n            this.handled = true;\n            this.performZoomingByToolBar(toolbar);\n        }\n        else if ((e.type === 'mousedown' || e.type === 'pointerdown') && !this.handled && isToolbarPerform) {\n            this.handled = false;\n            this.performZoomingByToolBar(toolbar);\n        }\n        else {\n            this.handled = false;\n        }\n    };\n    /**\n     * @param {string} type - Specifies the type.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.performZoomingByToolBar = function (type) {\n        var map = this.maps;\n        map.isReset = false;\n        var scale = 0;\n        var stateColor = this.fillColor || this.maps.themeStyle.zoomFillColor;\n        switch (type.toLowerCase()) {\n            case 'zoom':\n                this.panColor = stateColor;\n                this.zoomColor = this.maps.zoomSettings.enableSelectionZooming ? this.selectionColor : stateColor;\n                this.applySelection(this.zoomElements, this.zoomColor);\n                this.applySelection(this.panElements, this.panColor);\n                this.isPan = false;\n                this.isZoomSelection = this.maps.zoomSettings.enableSelectionZooming;\n                break;\n            case 'pan':\n                this.panColor = this.maps.zoomSettings.enablePanning ? this.selectionColor : stateColor;\n                this.zoomColor = stateColor;\n                if (!this.maps.zoomSettings.enablePanning) {\n                    this.applySelection(this.zoomElements, this.selectionColor);\n                    this.applySelection(this.panElements, this.panColor);\n                }\n                else {\n                    this.applySelection(this.zoomElements, (this.fillColor || stateColor));\n                    this.applySelection(this.panElements, this.panColor);\n                }\n                this.isPan = this.maps.zoomSettings.enablePanning;\n                this.isZoomSelection = false;\n                break;\n            case 'zoomin':\n                map.staticMapZoom = map.tileZoomLevel;\n                if (map.staticMapZoom > 0 && map.staticMapZoom < map.zoomSettings.maxZoom) {\n                    map.staticMapZoom += 1;\n                }\n                if (map.isTileMap && map.tileZoomLevel >= map.zoomSettings.minZoom && map.tileZoomLevel < map.zoomSettings.maxZoom) {\n                    this.toolBarZooming(map.tileZoomLevel + 1, 'ZoomIn');\n                }\n                else if (!map.isTileMap) {\n                    this.toolBarZooming(map.scale + 1, 'ZoomIn');\n                }\n                scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);\n                if (!this.isZoomSelection) {\n                    if (scale === map.zoomSettings.maxZoom || scale > 1 || (scale === 1 && this.maps.isTileMap)) {\n                        this.applySelection(this.zoomElements, stateColor);\n                        this.applySelection(this.panElements, map.zoomSettings.enablePanning ? this.selectionColor : stateColor);\n                    }\n                    else if (scale === 1 && !this.maps.isTileMap) {\n                        this.applySelection(this.zoomElements, stateColor);\n                        this.applySelection(this.panElements, stateColor);\n                    }\n                }\n                break;\n            case 'zoomout':\n                map.staticMapZoom = map.tileZoomLevel;\n                map.markerCenterLatitude = null;\n                map.markerCenterLongitude = null;\n                this.toolBarZooming((map.isTileMap ? map.tileZoomLevel : map.scale) - 1, 'ZoomOut');\n                scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);\n                if (!this.isPan && this.isZoomSelection) {\n                    this.panColor = stateColor;\n                    this.zoomColor = this.selectionColor;\n                    this.applySelection(this.zoomElements, this.selectionColor);\n                    this.applySelection(this.panElements, this.panColor);\n                }\n                else {\n                    if (scale <= 1 && !map.isTileMap) {\n                        this.applySelection(this.panElements, stateColor);\n                    }\n                    else {\n                        this.applySelection(this.panElements, map.zoomSettings.enablePanning ? this.selectionColor : stateColor);\n                    }\n                }\n                break;\n            case 'reset':\n                map.staticMapZoom = map.zoomSettings.enable ? map.zoomSettings.zoomFactor : 0;\n                map.markerCenterLatitude = null;\n                map.markerCenterLongitude = null;\n                this.isZoomSelection = false;\n                this.isPan = map.zoomSettings.enablePanning;\n                this.toolBarZooming(map.zoomSettings.minZoom, 'Reset');\n                if ((this.isPan && !this.isZoomSelection) || (!this.isPan && this.isZoomSelection)) {\n                    if (!this.maps.zoomSettings.enablePanning) {\n                        this.applySelection(this.zoomElements, this.selectionColor);\n                        this.applySelection(this.panElements, stateColor);\n                    }\n                    else {\n                        this.applySelection(this.zoomElements, stateColor);\n                        this.applySelection(this.panElements, this.selectionColor);\n                    }\n                }\n                else if (!this.isPan && !this.isZoomSelection) {\n                    this.applySelection(this.zoomElements, stateColor);\n                    this.applySelection(this.panElements, stateColor);\n                }\n        }\n        this.panningStyle(type.toLowerCase());\n    };\n    Zoom.prototype.panningStyle = function (toolbar) {\n        var svg = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_svg');\n        if (toolbar === 'pan' || (this.isPanModeEnabled && toolbar !== 'reset')) {\n            svg.setAttribute('class', 'e-maps-panning');\n        }\n        else {\n            svg.setAttribute('class', '');\n        }\n    };\n    Zoom.prototype.applySelection = function (elements, color) {\n        if (!elements) {\n            return;\n        }\n        var childElement;\n        for (var i = 0; i < elements.childElementCount; i++) {\n            childElement = elements.childNodes[i];\n            if (childElement.tagName !== 'circle') {\n                childElement.setAttribute('fill', (elements.id.indexOf('Pan') > -1 ? color : 'transparent'));\n                childElement.setAttribute('stroke', color);\n            }\n        }\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the event in the map\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.showTooltip = function (e) {\n        var text = e.target.id.split('_Zooming_ToolBar_')[1].split('_')[0];\n        var tooltip = this.maps.zoomSettings.toolbarSettings.tooltipSettings;\n        var tooltipSettings = {\n            visible: tooltip.visible,\n            fill: tooltip.fill,\n            borderOpacity: tooltip.borderOpacity,\n            borderWidth: tooltip.borderWidth,\n            borderColor: tooltip.borderColor,\n            fontColor: tooltip.fontColor,\n            fontFamily: tooltip.fontFamily,\n            fontStyle: tooltip.fontStyle,\n            fontWeight: tooltip.fontWeight,\n            fontSize: tooltip.fontSize || '10px',\n            fontOpacity: tooltip.fontOpacity\n        };\n        tooltipSettings.fontFamily = this.maps.themeStyle.fontFamily;\n        if (!this.isTouch) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.createTooltip)('EJ2_Map_Toolbar_Tip', this.maps.getLocalizedLabel(text), (e.pageY + 10), (e.pageX + 10), tooltipSettings);\n            if (this.maps.isDevice) {\n                clearTimeout(this.clearTimeout);\n                this.clearTimeout = setTimeout(this.removeTooltip.bind(this), 2000);\n            }\n        }\n    };\n    /**\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.removeTooltip = function () {\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)('EJ2_Map_Toolbar_Tip')) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.remove)((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)('EJ2_Map_Toolbar_Tip'));\n        }\n    };\n    /**\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.alignToolBar = function () {\n        var map = this.maps;\n        var padding = 10;\n        var element = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: map.element.id + '_ToolBar' });\n        element.style.cssText = 'position:absolute;z-index:2';\n        var rectSVGObject = map.renderer.createSvg({\n            id: map.element.id + '_Zooming_ToolBar', width: 10, height: 10\n        });\n        rectSVGObject.appendChild(this.toolBarGroup);\n        element.appendChild(rectSVGObject);\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_Secondary_Element')) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_Secondary_Element').appendChild(element);\n        }\n        var toolBarSize = this.toolBarGroup.getBoundingClientRect();\n        rectSVGObject.setAttribute('height', (toolBarSize.height + map.zoomSettings.toolbarSettings.borderWidth).toString());\n        rectSVGObject.setAttribute('width', (toolBarSize.width + map.zoomSettings.toolbarSettings.borderWidth).toString());\n        var size = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(map.totalRect) ? map.totalRect : map.mapAreaRect;\n        var x = 0;\n        var y = 0;\n        switch (map.toolbarProperties.verticalAlignment) {\n            case 'Near':\n                y = size.y;\n                break;\n            case 'Center':\n                y = (size.height / 2) - (toolBarSize.height / 2);\n                break;\n            case 'Far':\n                y = (size.height - toolBarSize.height) - padding;\n                break;\n        }\n        switch (map.toolbarProperties.horizontalAlignment) {\n            case 'Near':\n                x = size.x;\n                break;\n            case 'Center':\n                x = (size.width / 2) - (toolBarSize.width / 2);\n                break;\n            case 'Far':\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(map.legendModule) && map.legendSettings.position === 'Left') {\n                    x = size.width + size.x - toolBarSize.width - padding;\n                }\n                else {\n                    x = (size.width - toolBarSize.width) - padding;\n                }\n                break;\n        }\n        element.style.left = x + 'px';\n        element.style.top = y + 'px';\n        var color = this.maps.toolbarProperties.highlightColor || this.maps.themeStyle.zoomSelectionColor;\n        var css = ' .e-maps-toolbar:hover > circle { stroke:' + color + '; } .e-maps-toolbar:hover > path { fill: ' + color + ' ;  stroke: ' + color + '; }' +\n            '.e-maps-toolbar:hover { cursor: pointer; } .e-maps-cursor-disable:hover { cursor: not-allowed; } .e-maps-panning:hover { cursor: pointer; } ' +\n            '.e-maps-popup-close { display: block; opacity: 0; }';\n        var style = document.createElement('style');\n        style.appendChild(document.createTextNode(css));\n        element.appendChild(style);\n    };\n    /**\n     * @param {number} factor - Specifies the factor for toolbar\n     * @param {string} id - Specifies the id\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.removeToolbarOpacity = function (factor, id) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.maps) && this.maps.zoomModule && this.maps.zoomSettings.enable) {\n            if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_KitCollection') && id.indexOf(this.maps.element.id + '_Zooming_') > -1) {\n                if (this.maps.isDevice) {\n                    (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_KitCollection').setAttribute('opacity', '1');\n                    this.removeToolbarClass('', '', '', '', '');\n                }\n                else {\n                    this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', 'e-maps-toolbar', this.maps.zoomSettings.enablePanning ? 'e-maps-toolbar' : '', 'e-maps-toolbar');\n                }\n                var toolbarShapeOpacity = this.maps.toolbarProperties.shapeOpacity;\n                var toolbarButtonOpacity = this.maps.toolbarProperties.borderOpacity;\n                if (this.maps.isTileMap && (factor <= 1.1 || this.maps.zoomSettings.minZoom === factor)) {\n                    if (!this.maps.isDevice) {\n                        this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', '', this.maps.zoomSettings.enablePanning ? 'e-maps-toolbar' : '', '');\n                    }\n                    if (this.maps.zoomSettings.enablePanning) {\n                        this.removePanColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);\n                    }\n                    if (this.isZoomSelection && this.maps.zoomSettings.enableSelectionZooming && !this.maps.isReset) {\n                        this.removeZoomColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);\n                        this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                    }\n                    this.removeZoomOpacity((this.maps.zoomSettings.enableSelectionZooming ? toolbarShapeOpacity : 0.3), (this.maps.zoomSettings.enableSelectionZooming ? toolbarButtonOpacity : 0.3), toolbarShapeOpacity, toolbarButtonOpacity, 0.3, 0.3, (this.maps.zoomSettings.enablePanning ? toolbarShapeOpacity : 0.3), (this.maps.zoomSettings.enablePanning ? toolbarButtonOpacity : 0.3), 0.3, 0.3);\n                }\n                else if ((factor <= 1.1 || this.maps.zoomSettings.minZoom === factor)) {\n                    if (!this.maps.isDevice) {\n                        this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', '', '', '');\n                    }\n                    if (!this.isZoomSelection && this.maps.zoomSettings.enablePanning) {\n                        this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                    }\n                    if (this.isZoomSelection && this.maps.zoomSettings.enableSelectionZooming && !this.maps.isReset) {\n                        this.removeZoomColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);\n                        this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                    }\n                    this.removeZoomOpacity((this.maps.zoomSettings.enableSelectionZooming ? toolbarShapeOpacity : 0.3), (this.maps.zoomSettings.enableSelectionZooming ? toolbarButtonOpacity : 0.3), toolbarShapeOpacity, toolbarButtonOpacity, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3);\n                }\n                else if (factor < this.maps.zoomSettings.maxZoom) {\n                    if (!this.maps.isDevice) {\n                        this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? 'e-maps-toolbar' : '', 'e-maps-toolbar', 'e-maps-toolbar', this.maps.zoomSettings.enablePanning ? 'e-maps-toolbar' : '', 'e-maps-toolbar');\n                    }\n                    if (!this.maps.zoomModule.isZoomFinal) {\n                        this.removeZoomOpacity((this.maps.zoomSettings.enableSelectionZooming ? toolbarShapeOpacity : 0.3), (this.maps.zoomSettings.enableSelectionZooming ? toolbarButtonOpacity : 0.3), toolbarShapeOpacity, toolbarButtonOpacity, toolbarShapeOpacity, toolbarButtonOpacity, (this.maps.zoomSettings.enablePanning ? toolbarShapeOpacity : 0.3), (this.maps.zoomSettings.enablePanning ? toolbarButtonOpacity : 0.3), toolbarShapeOpacity, toolbarButtonOpacity);\n                    }\n                    else {\n                        this.maps.zoomModule.isZoomFinal = false;\n                    }\n                    if (this.isZoomSelection && this.maps.zoomSettings.enableSelectionZooming) {\n                        this.removeZoomColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);\n                        if (this.maps.zoomModule.isPan && this.maps.zoomSettings.enablePanning) {\n                            this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                        }\n                    }\n                    else if (!this.isZoomSelection && this.maps.zoomSettings.enablePanning) {\n                        this.removePanColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);\n                        if (this.maps.zoomSettings.enableSelectionZooming) {\n                            this.removeZoomColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                        }\n                    }\n                }\n                else {\n                    if (!this.maps.isDevice) {\n                        this.removeToolbarClass('', '', 'e-maps-toolbar', this.maps.zoomSettings.enablePanning ? 'e-maps-toolbar' : '', 'e-maps-toolbar');\n                    }\n                    this.removeZoomOpacity(0.3, 0.3, 0.3, 0.3, toolbarShapeOpacity, toolbarButtonOpacity, (this.maps.zoomSettings.enablePanning ? toolbarShapeOpacity : 0.3), (this.maps.zoomSettings.enablePanning ? toolbarButtonOpacity : 0.3), toolbarShapeOpacity, toolbarButtonOpacity);\n                    if (this.maps.zoomSettings.enableSelectionZooming) {\n                        this.removeZoomColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                    }\n                    if (!this.isZoomSelection && this.maps.zoomSettings.enablePanning) {\n                        this.removePanColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);\n                    }\n                }\n            }\n            else {\n                if (!this.maps.isDevice) {\n                    this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                    this.removeZoomColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);\n                    this.removeZoomOpacity(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                }\n            }\n        }\n    };\n    Zoom.prototype.setOpacity = function (circleId, pathId, circleOpacity, pathOpacity) {\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + circleId)) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + circleId).setAttribute('stroke-opacity', circleOpacity.toString());\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + circleId).setAttribute('fill-opacity', circleOpacity.toString());\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + pathId).setAttribute('stroke-opacity', pathOpacity.toString());\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + pathId).setAttribute('fill-opacity', pathOpacity.toString());\n        }\n    };\n    Zoom.prototype.removeZoomOpacity = function (zoomOpacity, zoomStrokeOpacity, zoomInOpacity, zoomInStrokeOpacity, zoomOutOpacity, zoomOutStrokeOpacity, panOpacity, panStrokeOpacity, resetOpacity, resetStrokeOpacity) {\n        this.setOpacity('_Zooming_ToolBar_Zoom_Rect', '_Zooming_ToolBar_Zoom', zoomStrokeOpacity, zoomOpacity);\n        this.setOpacity('_Zooming_ToolBar_ZoomIn_Rect', '_Zooming_ToolBar_ZoomIn_Path', zoomInStrokeOpacity, zoomInOpacity);\n        this.setOpacity('_Zooming_ToolBar_ZoomOut_Rect', '_Zooming_ToolBar_ZoomOut', zoomOutStrokeOpacity, zoomOutOpacity);\n        this.setOpacity('_Zooming_ToolBar_Pan_Rect', '_Zooming_ToolBar_Pan', panStrokeOpacity, panOpacity);\n        this.setOpacity('_Zooming_ToolBar_Reset_Rect', '_Zooming_ToolBar_Reset', resetStrokeOpacity, resetOpacity);\n    };\n    /**\n     * @param {string} zoomClassStyle - Specifies the style for zoom class.\n     * @param {string} zoomInClassStyle - Specifies the style for zoom in.\n     * @param {string} zoomOutClassStyle - Specifies the style for zoom out.\n     * @param {string} panClassStyle -  Specifies the style for pan.\n     * @param {string} resetClassStyle - Specifies the style for reset.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.removeToolbarClass = function (zoomClassStyle, zoomInClassStyle, zoomOutClassStyle, panClassStyle, resetClassStyle) {\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_KitCollection')) {\n            if (document.getElementById(this.maps.element.id + '_Zooming_ToolBar_ZoomIn_Group')) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_ZoomIn_Group').setAttribute('class', zoomInClassStyle);\n            }\n            if (document.getElementById(this.maps.element.id + '_Zooming_ToolBar_ZoomOut_Group')) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_ZoomOut_Group').setAttribute('class', zoomOutClassStyle);\n            }\n            if (document.getElementById(this.maps.element.id + '_Zooming_ToolBar_Reset_Group')) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Reset_Group').setAttribute('class', resetClassStyle);\n            }\n            if (document.getElementById(this.maps.element.id + '_Zooming_ToolBar_Zoom_Group') && this.maps.zoomSettings.enableSelectionZooming) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Zoom_Group').setAttribute('class', zoomClassStyle);\n            }\n            if (document.getElementById(this.maps.element.id + '_Zooming_ToolBar_Pan_Group') && this.maps.zoomSettings.enablePanning) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Pan_Group').setAttribute('class', panClassStyle);\n            }\n        }\n    };\n    Zoom.prototype.removePanColor = function (selectionColor) {\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Pan_Rect') && this.maps.zoomSettings.enablePanning) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Pan').setAttribute('fill', selectionColor);\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Pan').setAttribute('stroke', selectionColor);\n        }\n    };\n    Zoom.prototype.removeZoomColor = function (selectionColor) {\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Zoom_Rect') && this.maps.zoomSettings.enableSelectionZooming) {\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Zoom').setAttribute('fill', 'transparent');\n            (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Zooming_ToolBar_Zoom').setAttribute('stroke', selectionColor);\n        }\n    };\n    /**\n     * To bind events.\n     *\n     * @param {Element} element - Specifies the element.\n     * @param {Function} process - Specifies the process.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.wireEvents = function (element, process) {\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(element, _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchStartEvent, process, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(element, 'mouseover', this.showTooltip, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(element, 'mouseout', this.removeTooltip, this);\n    };\n    /**\n     * @param {WheelEvent} e - Specifies the wheel event in the map for zooming\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mapMouseWheel = function (e) {\n        if (this.maps.zoomSettings.enable && this.maps.zoomSettings.mouseWheelZoom) {\n            var map = this.maps;\n            map.markerZoomedState = false;\n            map.zoomPersistence = map.enablePersistence;\n            var position = this.getMousePosition(e.pageX, e.pageY);\n            var prevLevel = map.tileZoomLevel;\n            var prevScale = map.scale;\n            var delta = 1;\n            var staticMaxZoomLevel = map.zoomSettings.maxZoom;\n            var value = (map.isTileMap) ? prevLevel : prevScale;\n            this.maps.mergeCluster();\n            if (((position.x > map.mapAreaRect.x) && (position.x < (map.mapAreaRect.x + map.mapAreaRect.width))) &&\n                (position.y > map.mapAreaRect.y) && position.y < (map.mapAreaRect.y + map.mapAreaRect.height)) {\n                e.preventDefault();\n                var direction = (this.browserName === 'mozilla' && !this.isPointer) ?\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    -(e.detail) / 3 > 0 ? 'ZoomIn' : 'ZoomOut' : (e.wheelDelta / 120) > 0 ? 'ZoomIn' : 'ZoomOut';\n                if (direction === 'ZoomIn') {\n                    map.mapScaleValue = value + delta;\n                    if (map.isTileMap) {\n                        map.staticMapZoom = map.tileZoomLevel;\n                        if (map.staticMapZoom > 0 && map.staticMapZoom < staticMaxZoomLevel) {\n                            map.staticMapZoom += 1;\n                            this.performZooming(position, (value + delta), direction, true);\n                        }\n                    }\n                    else {\n                        this.performZooming(position, (value + delta), direction, true);\n                    }\n                }\n                else {\n                    map.mapScaleValue = value - delta;\n                    map.isReset = (map.mapScaleValue < 1) ? true : false;\n                    map.staticMapZoom = map.tileZoomLevel;\n                    if (map.mapScaleValue === 1) {\n                        map.markerCenterLatitude = null;\n                        map.markerCenterLongitude = null;\n                    }\n                    if (map.staticMapZoom > 1 && map.staticMapZoom < staticMaxZoomLevel) {\n                        map.staticMapZoom -= 1;\n                    }\n                    this.performZooming(position, (value - delta), direction, true);\n                }\n            }\n            this.removeToolbarOpacity(map.mapScaleValue, (!this.maps.isDevice ? (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(e.target) ? e.target['id'] :\n                this.maps.element.id) : this.maps.element.id + '_Zooming_'));\n        }\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the event in the map\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.doubleClick = function (e) {\n        var pageX = e.pageX;\n        var pageY = e.pageY;\n        var tooltipElement = e.target.closest('#' + this.maps.element.id + '_mapsTooltipparent_template');\n        if (this.maps.zoomSettings.enable && this.maps.zoomSettings.doubleClickZoom\n            && !(e.target['id'].indexOf('_Zooming_') > -1) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(tooltipElement)) {\n            var position = this.getMousePosition(pageX, pageY);\n            var map = this.maps;\n            var prevLevel = map.tileZoomLevel;\n            var prevScale = map.scale;\n            map.mapScaleValue = map.mapScaleValue + 1;\n            var value = (map.isTileMap) ? prevLevel : prevScale;\n            if (((position.x > map.mapAreaRect.x) && (position.x < (map.mapAreaRect.x + map.mapAreaRect.width))) &&\n                (position.y > map.mapAreaRect.y) && position.y < (map.mapAreaRect.y + map.mapAreaRect.height)) {\n                this.performZooming(position, (value + 1), 'ZoomIn');\n            }\n        }\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the event in the map\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mouseDownHandler = function (e) {\n        var pageX;\n        var pageY;\n        var target;\n        var touches = null;\n        this.isPinchZooming = false;\n        //eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var element = e.target;\n        if (e.type === 'touchstart') {\n            this.isTouch = true;\n            touches = e.touches;\n            target = e.target;\n            pageX = touches[0].pageX;\n            pageY = touches[0].pageY;\n        }\n        else {\n            pageX = e.pageX;\n            pageY = e.pageY;\n            //eslint-disable-next-line @typescript-eslint/no-unused-vars\n            target = e.target;\n        }\n        if (!this.isTouch) {\n            e.preventDefault();\n        }\n        if (!this.maps.zoomSettings.enablePanning) {\n            this.isPan = this.isPanModeEnabled = this.panColor !== this.selectionColor ? this.maps.zoomSettings.enablePanning\n                : this.zoomColor === this.selectionColor;\n        }\n        else {\n            this.isPan = this.isPanModeEnabled = !this.isZoomSelection;\n        }\n        this.mouseDownLatLong = { x: pageX, y: pageY };\n        var scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);\n        this.rectZoomingStart = ((this.isZoomSelection && scale < this.maps.zoomSettings.maxZoom) && this.maps.zoomSettings.enable);\n        this.mouseDownPoints = this.getMousePosition(pageX, pageY);\n        if (this.isTouch && touches !== null) {\n            this.firstMove = true;\n            this.pinchFactor = this.maps.scale;\n            this.fingers = touches.length;\n        }\n        if (this.maps.isTileMap && this.isTouch && e['touches'].length > 1) {\n            var startTouch = this.getMousePosition(e['touches'][0].pageX, e['touches'][0].pageY);\n            var endTouch = this.getMousePosition(e['touches'][1].pageX, e['touches'][1].pageY);\n            this.startDistance = Math.sqrt(Math.pow((startTouch.x - endTouch.x), 2) + Math.pow((startTouch.y - endTouch.y), 2));\n            this.touchCenter = { x: (startTouch.x + endTouch.x) / 2, y: (startTouch.y + endTouch.y) / 2 };\n            this.pinchStartLatLong = this.maps.pointToLatLong((startTouch.x + endTouch.x) / 2, (startTouch.y + endTouch.y) / 2);\n            this.isCancellation = false;\n            this.pinchTileZoomScale = this.maps.tileZoomLevel;\n            this.pinchDistance = null;\n        }\n        this.isSingleClick = true;\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the event in the map\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mouseMoveHandler = function (e) {\n        var pageX;\n        var pageY;\n        var map = this.maps;\n        //eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var touchArg;\n        var target;\n        var touches = null;\n        var zoom = this.maps.zoomSettings;\n        if (e.type === 'touchmove') {\n            this.isTouch = true;\n            target = e.target;\n            touches = e.touches;\n            pageX = touches[0].pageX;\n            pageY = touches[0].pageY;\n        }\n        else {\n            pageX = e.pageX;\n            pageY = e.pageY;\n            target = e.target;\n        }\n        if ((0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_Zooming_KitCollection')) {\n            if (target.id.indexOf('_Zooming_') > -1) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_Zooming_KitCollection').setAttribute('opacity', '1');\n            }\n            else if (!map.isDevice) {\n                (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(map.element.id + '_Zooming_KitCollection').setAttribute('opacity', map.theme.toLowerCase() === 'fluentdark' ? '0.6' : '0.3');\n            }\n        }\n        if (this.isTouch) {\n            if (this.maps.zoomSettings.enable && this.maps.zoomSettings.pinchZooming && touches !== null) {\n                if (this.firstMove && touches.length === 2) {\n                    this.rectZoomingStart = false;\n                    this.updateInteraction();\n                    this.touchStartList = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.targetTouches)(e);\n                }\n                else if (touches.length === 2 && this.touchStartList.length === 2) {\n                    this.touchMoveList = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.targetTouches)(e);\n                    if (e.cancelable) {\n                        e.preventDefault();\n                    }\n                    this.rectZoomingStart = false;\n                    this.performPinchZooming(e);\n                }\n                this.firstMove = false;\n            }\n        }\n        this.mouseMovePoints = this.getMousePosition(pageX, pageY);\n        if (!this.isPinchZooming && (zoom.enable && this.isPanModeEnabled && this.maps.markerDragId.indexOf('_MarkerIndex_') === -1 && ((_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && touches.length >= 1) || !_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice))) {\n            e.preventDefault();\n            this.maps.element.style.cursor = 'pointer';\n            this.mouseMoveLatLong = { x: pageX, y: pageY };\n            if ((this.mouseDownLatLong['x'] !== this.mouseMoveLatLong['x']) && (this.mouseDownLatLong['y'] !== this.mouseMoveLatLong['y'])) {\n                if (this.maps.zoomSettings.enablePanning) {\n                    this.panning('None', null, null, e);\n                }\n                this.mouseDownLatLong['x'] = pageX;\n                this.mouseDownLatLong['y'] = pageY;\n            }\n        }\n        if (!this.isPinchZooming && (this.isTouch ? (touches !== null && touches.length === 1 && this.rectZoomingStart) : this.rectZoomingStart)) {\n            e.preventDefault();\n            var scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);\n            if (this.maps.zoomSettings.enableSelectionZooming && scale < this.maps.zoomSettings.maxZoom) {\n                this.drawZoomRectangle();\n            }\n            else {\n                this.rectZoomingStart = false;\n                this.isPan = true;\n            }\n        }\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the event in the map\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mouseUpHandler = function (e) {\n        this.rectZoomingStart = false;\n        this.isSingleClick = this.isSingleClick ? true : false;\n        this.isTouch = false;\n        this.touchStartList = [];\n        this.touchMoveList = [];\n        this.lastScale = 1;\n        this.isCancellation = false;\n        this.maps.element.style.cursor = 'auto';\n        if (this.isPinchZooming && this.maps.isTileMap) {\n            this.isPinchZooming = false;\n            var tilesParent = document.getElementById(this.maps.element.id + '_tile_parent');\n            var svgElement = document.getElementById(this.maps.element.id + '_Tile_SVG_Parent');\n            tilesParent.style.transformOrigin = '';\n            tilesParent.style.transform = '';\n            svgElement.style.transformOrigin = '';\n            svgElement.style.transform = '';\n            this.maps.tileZoomLevel = this.maps.mapScaleValue = this.maps.zoomSettings.zoomFactor = this.pinchZoomScale;\n            this.maps.scale = Math.pow(2, this.pinchZoomScale - 1);\n            this.tileZoomLevel = Math.round(this.pinchZoomScale);\n            this.getTileTranslate(this.tileZoomLevel);\n            this.maps.mapLayerPanel.generateTiles(this.tileZoomLevel, this.maps.tileTranslatePoint);\n            this.applyTransform(this.maps);\n            if (document.getElementById(this.maps.element.id + '_animates_tiles')) {\n                document.getElementById(this.maps.element.id + '_animates_tiles').remove();\n            }\n        }\n        if (this.isPanModeEnabled && this.maps.zoomSettings.enablePanning && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.maps.previousPoint) &&\n            (!this.maps.isTileMap ? (this.maps.translatePoint.x !== this.maps.previousPoint.x && this.maps.translatePoint.y !== this.maps.previousPoint.y)\n                : this.isPanningInProgress)) {\n            var pageX = void 0;\n            var pageY = void 0;\n            var layerX = 0;\n            var layerY = 0;\n            var target = void 0;\n            var element = e.target;\n            if (e.type.indexOf('touch') !== -1) {\n                var touchArg = e;\n                layerX = pageX = touchArg.changedTouches[0].pageX;\n                pageY = touchArg.changedTouches[0].pageY;\n                layerY = pageY - (this.maps.isTileMap ? 10 : 0);\n                target = touchArg.target;\n                this.maps.mouseClickEvent = { x: pageX, y: pageY };\n            }\n            else {\n                pageX = e.pageX;\n                pageY = e.pageY;\n                layerX = e['layerX'];\n                layerY = e['layerY'] - (this.maps.isTileMap ? 10 : 0);\n                //eslint-disable-next-line @typescript-eslint/no-unused-vars\n                target = e.target;\n            }\n            var panCompleteEventArgs = void 0;\n            var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();\n            if (!this.maps.isTileMap) {\n                this.maps.mouseClickEvent['x'] = this.maps.mouseDownEvent['x'];\n                this.maps.mouseClickEvent['y'] = this.maps.mouseDownEvent['y'];\n                var location_5 = this.maps.getClickLocation(element.id, pageX, pageY, element, pageX, pageY);\n                panCompleteEventArgs = {\n                    cancel: false, name: 'panComplete', maps: this.maps,\n                    tileTranslatePoint: {}, translatePoint: { previous: this.maps.previousPoint, current: this.maps.translatePoint },\n                    scale: this.maps.scale, tileZoomLevel: this.maps.tileZoomLevel, latitude: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(location_5) ?\n                        location_5.latitude : 0, longitude: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(location_5) ? location_5.longitude : 0,\n                    minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                    minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n                };\n            }\n            else {\n                var location_6 = this.maps.getTileGeoLocation(layerX, layerY);\n                panCompleteEventArgs = {\n                    cancel: false, name: 'panComplete', maps: this.maps,\n                    tileTranslatePoint: { previous: this.maps.tileTranslatePoint, current: this.maps.tileTranslatePoint },\n                    translatePoint: { previous: this.maps.previousPoint, current: this.maps.translatePoint }, scale: this.maps.scale,\n                    tileZoomLevel: this.maps.tileZoomLevel, latitude: location_6.latitude, longitude: location_6.longitude,\n                    minLatitude: minMaxLatitudeLongitude.minLatitude, maxLatitude: minMaxLatitudeLongitude.maxLatitude,\n                    minLongitude: minMaxLatitudeLongitude.minLongitude, maxLongitude: minMaxLatitudeLongitude.maxLongitude\n                };\n            }\n            this.maps.trigger('panComplete', panCompleteEventArgs);\n        }\n        this.isPanModeEnabled = false;\n        this.isPanningInProgress = false;\n        var zoomRectElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Selection_Rect_Zooming');\n        if (zoomRectElement && this.maps.zoomSettings.enable && this.maps.zoomSettings.enableSelectionZooming) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.remove)(zoomRectElement);\n            this.performRectZooming();\n        }\n        this.mouseMoveLatLong = { x: 0, y: 0 };\n        this.mouseDownLatLong = { x: 0, y: 0 };\n        this.pinchDistance = null;\n    };\n    /**\n     * @param {PointerEvent} e - Specifies the event in the map\n     * @returns {void}\n     * @private\n     */\n    //eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Zoom.prototype.mouseCancelHandler = function (e) {\n        this.isPanModeEnabled = false;\n        this.isTouch = false;\n        this.rectZoomingStart = false;\n        var zoomRectElement = (0,_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElementByID)(this.maps.element.id + '_Selection_Rect_Zooming');\n        if (zoomRectElement && this.maps.zoomSettings.enable) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.remove)(zoomRectElement);\n            this.performRectZooming();\n        }\n    };\n    /**\n     * To handle the click event for maps.\n     *\n     * @param {PointerEvent} e - Specifies the pointer event.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.click = function (e) {\n        var map = this.maps;\n        var tooltipElement = e.target.closest('#' + this.maps.element.id + '_mapsTooltipparent_template');\n        if ((map.markerModule && map.markerModule.sameMarkerData.length > 0) ||\n            (e.target['id'].indexOf('MarkerIndex') > -1 && e.target['id'].indexOf('cluster') === -1) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(tooltipElement)) {\n            return null;\n        }\n        if (this.isSingleClick && map.zoomSettings.zoomOnClick && !(e.target['id'].indexOf('_Zooming_') > -1) && !map.zoomSettings.doubleClickZoom\n            && (this.zoomColor !== this.selectionColor)) {\n            var pageX = e.pageX;\n            var pageY = e.pageY;\n            var position = this.getMousePosition(pageX, pageY);\n            var prevLevel = map.tileZoomLevel;\n            var prevScale = map.scale;\n            map.mapScaleValue = map.mapScaleValue + 1;\n            var value = (map.isTileMap) ? prevLevel : prevScale;\n            if (((position.x > map.mapAreaRect.x) && (position.x < (map.mapAreaRect.x + map.mapAreaRect.width))) &&\n                (position.y > map.mapAreaRect.y) && position.y < (map.mapAreaRect.y + map.mapAreaRect.height)) {\n                this.performZooming(position, (value + 1), 'ZoomIn');\n            }\n        }\n    };\n    /**\n     * Gets the Mouse Position.\n     *\n     * @param {number} pageX - Specifies the Page x in map\n     * @param {number} pageY - Specifies the Page y in map\n     * @returns {Point} - returns the mouse point position\n     * @private\n     */\n    Zoom.prototype.getMousePosition = function (pageX, pageY) {\n        var map = this.maps;\n        var elementRect = map.element.getBoundingClientRect();\n        var pageXOffset = map.element.ownerDocument.defaultView.pageXOffset;\n        var pageYOffset = map.element.ownerDocument.defaultView.pageYOffset;\n        var clientTop = map.element.ownerDocument.documentElement.clientTop;\n        var clientLeft = map.element.ownerDocument.documentElement.clientLeft;\n        var positionX = elementRect.left + pageXOffset - clientLeft;\n        var positionY = elementRect.top + pageYOffset - clientTop;\n        return new _utils_helper__WEBPACK_IMPORTED_MODULE_0__.Point(Math.abs(pageX - positionX), Math.abs(pageY - positionY));\n    };\n    /**\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.addEventListener = function () {\n        if (this.maps.isDestroyed) {\n            return;\n        }\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(this.maps.element, this.wheelEvent, this.mapMouseWheel, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(this.maps.element, 'click', this.click, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(this.maps.element, 'dblclick', this.doubleClick, this);\n        this.maps.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchMoveEvent, this.mouseMoveHandler, this);\n        this.maps.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchStartEvent, this.mouseDownHandler, this);\n        this.maps.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchEndEvent, this.mouseUpHandler, this);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(this.maps.element, this.cancelEvent, this.mouseCancelHandler, this);\n    };\n    /**\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.removeEventListener = function () {\n        if (this.maps.isDestroyed) {\n            return;\n        }\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.remove(this.maps.element, this.wheelEvent, this.mapMouseWheel);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.remove(this.maps.element, 'click', this.click);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.remove(this.maps.element, 'dblclick', this.doubleClick);\n        this.maps.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchMoveEvent, this.mouseMoveHandler);\n        this.maps.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchStartEvent, this.mouseDownHandler);\n        this.maps.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchEndEvent, this.mouseUpHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.remove(this.maps.element, this.cancelEvent, this.mouseCancelHandler);\n        var toolbarElement = document.getElementById(this.maps.element.id + '_Zooming_KitCollection');\n        if (toolbarElement) {\n            for (var i = 0; i < toolbarElement.childNodes.length; i++) {\n                if (toolbarElement.childNodes[i].tagName === 'g') {\n                    _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(toolbarElement.childNodes[i], _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.touchStartEvent, this.performToolBarAction);\n                    _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(toolbarElement.childNodes[i], 'mouseover', this.showTooltip);\n                    _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.EventHandler.add(toolbarElement.childNodes[i], 'mouseout', this.removeTooltip);\n                }\n            }\n        }\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    Zoom.prototype.getModuleName = function () {\n        return 'Zoom';\n    };\n    /**\n     * To destroy the zoom.\n     *\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.destroy = function () {\n        this.toolBarGroup = null;\n        this.currentToolbarEle = null;\n        this.zoomingRect = null;\n        this.zoomElements = null;\n        this.panElements = null;\n        this.baseTranslatePoint = null;\n        this.touchStartList = null;\n        this.touchMoveList = null;\n        this.previousTouchMoveList = null;\n        this.mouseDownPoints = null;\n        this.mouseMovePoints = null;\n        this.startTouches = [];\n        this.mouseDownLatLong = null;\n        this.mouseMoveLatLong = null;\n        this.layerCollectionEle = null;\n        this.currentLayer = null;\n        this.pinchDistance = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (!this.maps.refreshing) {\n            this.maps = null;\n        }\n    };\n    return Zoom;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/zoom.js?");

/***/ })

}]);