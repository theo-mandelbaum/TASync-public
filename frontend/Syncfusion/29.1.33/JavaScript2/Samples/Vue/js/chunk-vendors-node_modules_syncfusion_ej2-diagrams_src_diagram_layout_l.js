"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_layout_l"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/layout-base.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/layout-base.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlowchartLayoutSettings: () => (/* binding */ FlowchartLayoutSettings),\n/* harmony export */   Layout: () => (/* binding */ Layout)\n/* harmony export */ });\n/* harmony import */ var _core_appearance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/appearance */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/appearance.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/**\n * Defines the configuration settings for flowchart automatic layout\n */\nvar FlowchartLayoutSettings = /** @class */ (function (_super) {\n    __extends(FlowchartLayoutSettings, _super);\n    function FlowchartLayoutSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('LeftInFlow')\n    ], FlowchartLayoutSettings.prototype, \"yesBranchDirection\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('RightInFlow')\n    ], FlowchartLayoutSettings.prototype, \"noBranchDirection\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(['Yes', 'True'])\n    ], FlowchartLayoutSettings.prototype, \"yesBranchValues\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(['No', 'False'])\n    ], FlowchartLayoutSettings.prototype, \"noBranchValues\", void 0);\n    return FlowchartLayoutSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.ChildProperty));\n\n/**\n * Defines the behavior of the automatic layouts\n */\nvar Layout = /** @class */ (function (_super) {\n    __extends(Layout, _super);\n    function Layout() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('')\n    ], Layout.prototype, \"fixedNode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(30)\n    ], Layout.prototype, \"horizontalSpacing\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('SamePoint')\n    ], Layout.prototype, \"connectionPointOrigin\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('Nonlinear')\n    ], Layout.prototype, \"arrangement\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(30)\n    ], Layout.prototype, \"verticalSpacing\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(30)\n    ], Layout.prototype, \"maxIteration\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(40)\n    ], Layout.prototype, \"springFactor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(50)\n    ], Layout.prototype, \"springLength\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Complex)({ left: 50, top: 50, right: 0, bottom: 0 }, _core_appearance__WEBPACK_IMPORTED_MODULE_0__.Margin)\n    ], Layout.prototype, \"margin\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('Auto')\n    ], Layout.prototype, \"horizontalAlignment\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('Auto')\n    ], Layout.prototype, \"verticalAlignment\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('TopToBottom')\n    ], Layout.prototype, \"orientation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('Auto')\n    ], Layout.prototype, \"connectionDirection\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('Default')\n    ], Layout.prototype, \"connectorSegments\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('None')\n    ], Layout.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)()\n    ], Layout.prototype, \"getLayoutInfo\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)()\n    ], Layout.prototype, \"layoutInfo\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)()\n    ], Layout.prototype, \"getBranch\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)()\n    ], Layout.prototype, \"bounds\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(true)\n    ], Layout.prototype, \"enableAnimation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)(false)\n    ], Layout.prototype, \"enableRouting\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Property)('')\n    ], Layout.prototype, \"root\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Complex)({}, FlowchartLayoutSettings)\n    ], Layout.prototype, \"flowchartLayoutSettings\", void 0);\n    return Layout;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.ChildProperty));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/layout-base.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/mind-map.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/mind-map.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MindMap: () => (/* binding */ MindMap)\n/* harmony export */ });\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _hierarchical_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hierarchical-tree */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/hierarchical-tree.js\");\n\n\n\n/**\n * Layout for mind-map tree\n */\nvar MindMap = /** @class */ (function () {\n    /**\n     * Constructor for the organizational chart module.\n     *\n     * @private\n     */\n    function MindMap() {\n        /**\n         * Defines the layout animation\n         *\n         */\n        this.isAnimation = false;\n        //constructs the layout module\n    }\n    /**\n     * To destroy the organizational chart\n     *\n     * @returns {void}\n     * @private\n     */\n    MindMap.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    /**\n     * Get module name.\n     */\n    MindMap.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the layout\n         */\n        return 'MindMapChart';\n    };\n    /**\n     * @param nodes\n     * @param nameTable\n     * @param layoutProp\n     * @param viewPort\n     * @param uniqueId\n     * @param root\n     * @private\n     */\n    MindMap.prototype.updateLayout = function (nodes, nameTable, layoutProp, viewPort, uniqueId, root) {\n        var isRoot = this.checkRoot(nodes, layoutProp, uniqueId, root, nameTable);\n        if (isRoot) {\n            layoutProp.fixedNode = isRoot;\n        }\n        else {\n            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                var node = nodes_1[_i];\n                if (!node.excludeFromLayout) {\n                    if (!node.inEdges || !node.inEdges.length) {\n                        layoutProp.fixedNode = node.id;\n                        break;\n                    }\n                }\n            }\n        }\n        var rootNode = nameTable[layoutProp.fixedNode];\n        var fistLevelNodes = this.findFirstLevelNodes(rootNode, layoutProp, nameTable);\n        var leftNodes = [];\n        var rightNodes = [];\n        var getMindmapBranch = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_1__.getFunction)(layoutProp.getBranch);\n        getMindmapBranch = getMindmapBranch || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_1__.getFunction)(this.getBranch);\n        for (var _a = 0, fistLevelNodes_1 = fistLevelNodes; _a < fistLevelNodes_1.length; _a++) {\n            var node = fistLevelNodes_1[_a];\n            var align = getMindmapBranch(node, fistLevelNodes);\n            align = node && node.branch ? node.branch : align;\n            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n            (align === 'Left') ? leftNodes.push(node) : rightNodes.push(node);\n        }\n        var viewPortBounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, viewPort.x, viewPort.y);\n        nameTable[layoutProp.fixedNode].offsetX = viewPortBounds.x + viewPortBounds.width / 2;\n        nameTable[layoutProp.fixedNode].offsetY = viewPortBounds.y + viewPortBounds.height / 2;\n        if (leftNodes.length) {\n            this.updateMindMapBranch(nodes, rightNodes, nameTable, layoutProp, viewPort, uniqueId, 'Left');\n        }\n        if (rightNodes.length) {\n            this.updateMindMapBranch(nodes, leftNodes, nameTable, layoutProp, viewPort, uniqueId, 'Right');\n        }\n    };\n    MindMap.prototype.checkRoot = function (nodes, layoutProp, uniqueId, root, nameTable) {\n        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n            var node = nodes_2[_i];\n            if (!node.excludeFromLayout) {\n                if (node.data && (node.data[\"\" + uniqueId].toString() === root || node.data[\"\" + uniqueId].toString()\n                    === layoutProp.root)) {\n                    return node.id;\n                }\n                else if (!node.data && node.id === layoutProp.root) {\n                    return node.id;\n                }\n            }\n        }\n        return '';\n    };\n    MindMap.prototype.updateMindMapBranch = function (nodes, excludeNodes, nameTable, layoutProp, viewPort, uniqueId, side) {\n        var layout = {\n            type: 'HierarchicalTree',\n            horizontalSpacing: layoutProp.verticalSpacing, verticalSpacing: layoutProp.horizontalSpacing,\n            verticalAlignment: layoutProp.verticalAlignment, horizontalAlignment: layoutProp.horizontalAlignment,\n            fixedNode: layoutProp.fixedNode, getLayoutInfo: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_1__.getFunction)(layoutProp.getLayoutInfo),\n            layoutInfo: layoutProp.layoutInfo, margin: layoutProp.margin,\n            orientation: layoutProp.orientation,\n            root: layoutProp.fixedNode\n        };\n        //(EJ2-277624)-Vertical orientation is not working in mindmap\n        if (layout.orientation === 'Vertical') {\n            layout.orientation = (side === 'Left') ? 'TopToBottom' : 'BottomToTop';\n        }\n        else {\n            layout.orientation = (side === 'Left') ? 'LeftToRight' : 'RightToLeft';\n        }\n        this.excludeFromLayout(excludeNodes, nameTable, true);\n        var mapLayout = new _hierarchical_tree__WEBPACK_IMPORTED_MODULE_2__.HierarchicalTree();\n        mapLayout.updateLayout(nodes, nameTable, layout, viewPort, uniqueId);\n        this.excludeFromLayout(excludeNodes, nameTable, false);\n    };\n    MindMap.prototype.getBranch = function (obj, firstLevelNodes) {\n        var side;\n        var i = firstLevelNodes.indexOf(obj);\n        if (i % 2 === 0) {\n            side = 'Left';\n        }\n        else {\n            side = 'Right';\n        }\n        return side;\n    };\n    MindMap.prototype.excludeFromLayout = function (newCollection, nameTable, exclude) {\n        for (var _i = 0, newCollection_1 = newCollection; _i < newCollection_1.length; _i++) {\n            var newcol = newCollection_1[_i];\n            var node = nameTable[newcol.id];\n            node.excludeFromLayout = exclude;\n        }\n    };\n    MindMap.prototype.findFirstLevelNodes = function (node, layout, nameTable) {\n        var parentNode;\n        var fistLevelNodes = [];\n        if (node && node.outEdges.length) {\n            for (var _i = 0, _a = node.outEdges; _i < _a.length; _i++) {\n                var outEdge = _a[_i];\n                fistLevelNodes.push(nameTable[nameTable[\"\" + outEdge].targetID]);\n            }\n        }\n        return fistLevelNodes;\n    };\n    return MindMap;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/mind-map.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/radial-tree.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/radial-tree.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RadialTree: () => (/* binding */ RadialTree)\n/* harmony export */ });\n/**\n * Radial Tree\n */\nvar RadialTree = /** @class */ (function () {\n    /**\n     * Constructor for the organizational chart module.\n     *\n     * @private\n     */\n    function RadialTree() {\n        //constructs the layout module\n    }\n    /**\n     * To destroy the organizational chart\n     *\n     * @returns {void}\n     * @private\n     */\n    RadialTree.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    /**\n     * Get module name.\n     */\n    RadialTree.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the layout\n         */\n        return 'RadialTree';\n    };\n    /**\n     * @param nodes\n     * @param nameTable\n     * @param layoutProp\n     * @param viewport\n     * @private\n     */\n    RadialTree.prototype.updateLayout = function (nodes, nameTable, layoutProp, viewport) {\n        var layout = {\n            type: layoutProp.type,\n            nameTable: nameTable, anchorX: 0, anchorY: 0,\n            firstLevelNodes: [], centerNode: null, levels: [], maxLevel: 0, graphNodes: {}, layoutNodes: [],\n            orientation: layoutProp.orientation,\n            horizontalSpacing: layoutProp.horizontalSpacing, verticalSpacing: layoutProp.verticalSpacing,\n            verticalAlignment: layoutProp.verticalAlignment, horizontalAlignment: layoutProp.horizontalAlignment,\n            fixedNode: layoutProp.fixedNode, margin: layoutProp.margin,\n            bounds: layoutProp.bounds, objects: [], root: layoutProp.root\n        };\n        this.doLayout(layout, nodes, nameTable, viewport);\n    };\n    RadialTree.prototype.doLayout = function (layout, nodes, nameTable, viewport) {\n        var node;\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[parseInt(i.toString(), 10)];\n            if (!node.excludeFromLayout) {\n                layout.graphNodes[node.id] = this.setUpLayoutInfo(layout, node);\n                if (!node.inEdges || !node.inEdges.length) {\n                    layout.firstLevelNodes.push(node);\n                }\n            }\n        }\n        if (layout.root && nameTable[layout.root]) {\n            layout.centerNode = nameTable[layout.root];\n        }\n        else if (layout.firstLevelNodes.length) {\n            layout.centerNode = layout.firstLevelNodes[0];\n            layout.root = layout.centerNode.id;\n        }\n        if (layout.centerNode) {\n            this.updateEdges(layout, layout.centerNode, 0, nameTable);\n            this.depthFirstAllignment(layout, layout.centerNode, 0, 0);\n            this.populateLevels(layout);\n            this.transformToCircleLayout(layout);\n            this.updateAnchor(layout, viewport);\n            this.updateNodes(layout, layout.centerNode, nameTable);\n        }\n    };\n    RadialTree.prototype.updateEdges = function (layout, node, depth, nameTable) {\n        var nodeInfo = layout.graphNodes[node.id];\n        layout.layoutNodes.push(nodeInfo);\n        nodeInfo.level = depth;\n        nodeInfo.visited = true;\n        layout.maxLevel = Math.max(layout.maxLevel, depth);\n        for (var j = 0; j < node.outEdges.length; j++) {\n            var edge = nameTable[nameTable[node.outEdges[parseInt(j.toString(), 10)]].targetID];\n            if (!edge.excludeFromLayout && !edge.visited) {\n                nodeInfo.children.push(edge);\n                this.updateEdges(layout, edge, depth + 1, nameTable);\n            }\n        }\n    };\n    RadialTree.prototype.depthFirstAllignment = function (layout, node, x, y) {\n        var newValue;\n        var nodeInfo = layout.graphNodes[node.id];\n        if (nodeInfo.children.length) {\n            y += 300;\n            for (var i = 0; i < nodeInfo.children.length; i++) {\n                newValue = this.depthFirstAllignment(layout, nodeInfo.children[parseInt(i.toString(), 10)], x, y);\n                x = newValue.x;\n                y = newValue.y;\n            }\n            nodeInfo.children = nodeInfo.children.sort(function (obj1, obj2) {\n                return layout.graphNodes[obj1.id].x - layout.graphNodes[obj2.id].x;\n            });\n            var min = layout.graphNodes[nodeInfo.children[0].id].min;\n            var max = layout.graphNodes[nodeInfo.children[nodeInfo.children.length - 1].id].max;\n            nodeInfo.x = min + (max - min) / 2;\n            x = max + layout.horizontalSpacing;\n            nodeInfo.segmentOffset = max + layout.horizontalSpacing;\n            nodeInfo.x -= nodeInfo.width / 2;\n            nodeInfo.y -= nodeInfo.height / 2;\n            nodeInfo.min = min;\n            nodeInfo.max = max;\n            if (nodeInfo.x < min && nodeInfo.visited) {\n                nodeInfo.x = min;\n                x = nodeInfo.x + nodeInfo.width / 2 - (max - min) / 2;\n                nodeInfo.visited = false;\n                for (var i = 0; i < nodeInfo.children.length; i++) {\n                    newValue = this.depthFirstAllignment(layout, nodeInfo.children[parseInt(i.toString(), 10)], x, y);\n                }\n                nodeInfo.visited = true;\n                x = nodeInfo.x + nodeInfo.width + layout.horizontalSpacing;\n            }\n            max = layout.graphNodes[nodeInfo.children[nodeInfo.children.length - 1].id].segmentOffset;\n            x = x < max ? max : x;\n            y -= 300;\n            nodeInfo.y = y;\n        }\n        else {\n            nodeInfo.x = x;\n            nodeInfo.y = y;\n            nodeInfo.min = x;\n            nodeInfo.max = x + nodeInfo.width;\n            x += nodeInfo.width + layout.horizontalSpacing;\n        }\n        return { x: x, y: y };\n    };\n    RadialTree.prototype.populateLevels = function (layout) {\n        var stages = [];\n        // eslint-disable-next-line prefer-spread\n        var min = Math.min.apply(Math, layout.layoutNodes.map(function (nodeInfo) { return nodeInfo.x; }));\n        // eslint-disable-next-line prefer-spread\n        var max = Math.max.apply(Math, layout.layoutNodes.map(function (nodeInfo) {\n            return nodeInfo.x + nodeInfo.width + layout.horizontalSpacing;\n        }));\n        var full = max - min;\n        layout.levels = [];\n        var _loop_1 = function (i) {\n            stages = layout.layoutNodes.filter(function (nodeInfo) {\n                if (nodeInfo.level === i) {\n                    return nodeInfo;\n                }\n                else {\n                    return null;\n                }\n            });\n            var newlevel = {};\n            stages = stages.sort(function (nodeInfo1, nodeInfo2) { return nodeInfo1.x - nodeInfo2.x; });\n            newlevel.min = stages[0].x;\n            newlevel.max = stages[stages.length - 1].x + stages[stages.length - 1].width + layout.horizontalSpacing;\n            newlevel.actualCircumference = 0;\n            newlevel.height = 0;\n            for (var k = 0; k < stages.length; k++) {\n                if (stages[parseInt(k.toString(), 10)].height > newlevel.height) {\n                    newlevel.height = stages[parseInt(k.toString(), 10)].height;\n                }\n                newlevel.actualCircumference += Math.max(stages[parseInt(k.toString(), 10)].width, stages[parseInt(k.toString(), 10)].height);\n                if (k !== stages.length - 1) {\n                    newlevel.actualCircumference += layout.horizontalSpacing;\n                }\n            }\n            newlevel.circumference = newlevel.max - newlevel.min;\n            if (newlevel.actualCircumference < newlevel.circumference) {\n                newlevel.circumference = (newlevel.circumference + newlevel.actualCircumference) / 2;\n            }\n            newlevel.radius = newlevel.circumference / (2 * Math.PI) + newlevel.height;\n            newlevel.nodes = [];\n            if (i > 1) {\n                if (layout.levels[i - 1].radius + layout.levels[i - 1].height >= newlevel.radius) {\n                    newlevel.radius = layout.levels[i - 1].radius + layout.levels[i - 1].height;\n                }\n            }\n            for (var j = 0; j < stages.length; j++) {\n                stages[parseInt(j.toString(), 10)].ratio = Math.abs(stages[parseInt(j.toString(), 10)].x\n                    + stages[parseInt(j.toString(), 10)].width / 2 - min) / full;\n                newlevel.nodes.push(stages[parseInt(j.toString(), 10)]);\n            }\n            layout.levels.push(newlevel);\n        };\n        for (var i = 0; i <= layout.maxLevel; i++) {\n            _loop_1(i);\n        }\n    };\n    RadialTree.prototype.transformToCircleLayout = function (layout) {\n        var root = layout.graphNodes[layout.centerNode.id];\n        root.x = 0;\n        root.y = 0;\n        for (var i = 1; i < layout.levels.length; i++) {\n            for (var j = 0; j < layout.levels[parseInt(i.toString(), 10)].nodes.length; j++) {\n                var nodeInfo = layout.levels[parseInt(i.toString(), 10)].nodes[parseInt(j.toString(), 10)];\n                nodeInfo.x = Math.cos(nodeInfo.ratio * 360 * Math.PI / 180)\n                    * (layout.levels[parseInt(i.toString(), 10)].radius + layout.verticalSpacing * i);\n                nodeInfo.y = Math.sin(nodeInfo.ratio * 360 * Math.PI / 180)\n                    * (layout.levels[parseInt(i.toString(), 10)].radius + layout.verticalSpacing * i);\n                layout.anchorX = Math.min(layout.anchorX, nodeInfo.x);\n                layout.anchorY = Math.min(layout.anchorY, nodeInfo.y);\n            }\n        }\n    };\n    RadialTree.prototype.updateAnchor = function (layout, viewPort) {\n        layout.anchorX = layout.centerNode.offsetX || viewPort.x / 2;\n        layout.anchorY = layout.centerNode.offsetY || viewPort.y / 2;\n    };\n    RadialTree.prototype.updateNodes = function (layout, node, nameTable) {\n        var nodeInfo = layout.graphNodes[node.id];\n        var offsetX = nodeInfo.x + layout.anchorX;\n        var offsetY = nodeInfo.y + layout.anchorY;\n        node.offsetX = offsetX;\n        node.offsetY = offsetY;\n        for (var i = 0; i < nodeInfo.children.length; i++) {\n            var childInfo = nodeInfo.children[parseInt(i.toString(), 10)];\n            this.updateNodes(layout, nameTable[childInfo.id], nameTable);\n        }\n    };\n    RadialTree.prototype.setUpLayoutInfo = function (layout, item) {\n        var info = {};\n        info.name = item.id;\n        info.x = 0;\n        info.y = 0;\n        info.min = 0;\n        info.max = 0;\n        info.width = item.actualSize.width;\n        info.height = item.actualSize.height;\n        info.children = [];\n        info.level = 0;\n        info.ratio = 0;\n        info.visited = false;\n        return info;\n    };\n    return RadialTree;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/radial-tree.js?");

/***/ })

}]);