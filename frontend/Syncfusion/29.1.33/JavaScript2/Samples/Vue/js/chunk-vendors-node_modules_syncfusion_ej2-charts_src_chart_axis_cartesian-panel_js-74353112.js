"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_axis_cartesian-panel_js-74353112"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/axis/cartesian-panel.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/axis/cartesian-panel.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CartesianAxisLayoutPanel: () => (/* binding */ CartesianAxisLayoutPanel)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n\n\n\n\n\n\n\n/**\n * Specifies the Cartesian Axis Layout.\n */\nvar axisPadding = 10;\nvar CartesianAxisLayoutPanel = /** @class */ (function () {\n    /** @private */\n    /**\n     * Constructor for creating the chart.\n     *\n     * @param {Chart} chartModule - Specifies the Chart model.\n     * @private */\n    function CartesianAxisLayoutPanel(chartModule) {\n        this.chart = chartModule;\n        this.padding = 5;\n    }\n    /**\n     * Measure the axis size.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n        var chart = this.chart;\n        var chartAreaWidth = chart.chartArea.width ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.stringToNumber)(chart.chartArea.width, chart.availableSize.width) : null;\n        this.crossAt(chart);\n        this.seriesClipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(rect.x, rect.y, rect.width, rect.height);\n        this.initialClipRect = rect;\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        //Measure Axis size with initial Rect\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.initialClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subtractThickness)(this.initialClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.initialClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subtractThickness)(this.initialClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.Thickness(0, 0, this.topSize, this.bottomSize));\n        if (!this.chart.delayRedraw) {\n            this.calculateAxisSize(this.initialClipRect);\n        }\n        this.leftSize = 0;\n        this.rightSize = 0;\n        this.topSize = 0;\n        this.bottomSize = 0;\n        //Measure Axis size with series Rect\n        this.measureRowAxis(chart, this.initialClipRect);\n        this.seriesClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subtractThickness)(this.seriesClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.Thickness(this.leftSize, this.rightSize, 0, 0));\n        this.measureColumnAxis(chart, this.initialClipRect);\n        this.seriesClipRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subtractThickness)(this.seriesClipRect, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.Thickness(0, 0, this.topSize, this.bottomSize));\n        if (chartAreaWidth) {\n            this.calculateFixedChartArea(chart, chartAreaWidth);\n        }\n        if (!this.chart.delayRedraw) {\n            chart.refreshAxis();\n            this.calculateAxisSize(this.seriesClipRect);\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {\n        this.seriesClipRect.width = chartAreaWidth;\n        this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth -\n            (chart.legendSettings.position === 'Right' ? chart.legendModule.legendBounds.width : 0);\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n            var item = _a[_i];\n            this.seriesClipRect.x -= (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(item.farSizes);\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n        var row;\n        this.calculateRowSize(rect);\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n            var item = _a[_i];\n            row = item;\n            row.nearSizes = [];\n            row.farSizes = [];\n            row.insideNearSizes = [];\n            row.insideFarSizes = [];\n            this.arrangeAxis(row);\n            this.measureDefinition(row, chart, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Size(chart.availableSize.width, row.computedHeight));\n            if (this.leftSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(row.nearSizes)) {\n                this.leftSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(row.nearSizes);\n            }\n            if (this.rightSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(row.farSizes)) {\n                this.rightSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(row.farSizes);\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n        var column;\n        this.calculateColumnSize(rect);\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var item = _a[_i];\n            column = item;\n            column.farSizes = [];\n            column.nearSizes = [];\n            column.insideNearSizes = [];\n            column.insideFarSizes = [];\n            this.arrangeAxis(column);\n            this.measureDefinition(column, chart, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Size(column.computedWidth, chart.availableSize.height));\n            if (this.bottomSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(column.nearSizes)) {\n                this.bottomSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(column.nearSizes);\n            }\n            if (this.topSize < (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(column.farSizes)) {\n                this.topSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)(column.farSizes);\n            }\n        }\n    };\n    /**\n     * Measure the column and row in chart.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\n        var ele;\n        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            ele = axis.scrollbarSettings.height;\n            axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar &&\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\n            axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar &&\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)\n                || axis.scrollbarSettings.enable) ? ele : 0;\n            axis.getModule(chart);\n            axis.baseModule.calculateRangeAndInterval(size, axis);\n            definition.computeSize(axis, axis.scrollBarHeight, definition, chart);\n        }\n        if (definition.farSizes.length > 0) {\n            definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n        }\n        if (definition.nearSizes.length > 0) {\n            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @param {Rect} rect - The rect for measuring the axis.\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var axis;\n        var nearCount = 0;\n        var farCount = 0;\n        var size = 0;\n        var x;\n        var y;\n        var axisOffset;\n        this.calculateRowSize(rect);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n                axis = row.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.height === 0) {\n                    axis.rect.height = row.computedHeight;\n                    size = 0;\n                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n                        definition = chart.rows[k];\n                        size += definition.computedHeight;\n                    }\n                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\n                    axis.rect.height = (axis.rect.height + size) -\n                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));\n                    axis.rect.width = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {\n                        if (farCount > 0) {\n                            x = rect.x + rect.width + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(row.farSizes, farCount))\n                                + axis.maxLabelSize.width + axis.multiLevelLabelHeight + (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) + axis.labelPadding;\n                        }\n                        else {\n                            x = rect.x + rect.width - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(row.insideFarSizes, farCount));\n                        }\n                    }\n                    else {\n                        x = rect.x + rect.width + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(row.farSizes, farCount));\n                    }\n                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n                    farCount++;\n                }\n                else {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Vertical') {\n                        if (nearCount > 0) {\n                            x = rect.x - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(row.nearSizes, nearCount)) - axis.maxLabelSize.width -\n                                axis.multiLevelLabelHeight - (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) - axis.labelPadding;\n                        }\n                        else {\n                            x = rect.x + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(row.insideNearSizes, nearCount));\n                        }\n                    }\n                    else {\n                        x = rect.x - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(row.nearSizes, nearCount));\n                    }\n                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n                    nearCount++;\n                }\n            }\n        }\n        this.calculateColumnSize(rect);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            nearCount = 0;\n            farCount = 0;\n            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n                axis = column.axes[j];\n                axisOffset = axis.plotOffset;\n                if (axis.rect.width === 0) {\n                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {\n                        definition = chart.columns[k];\n                        axis.rect.width += definition.computedWidth;\n                    }\n                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\n                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));\n                    axis.rect.height = 0;\n                }\n                if (axis.isAxisOpposedPosition) {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {\n                        if (farCount > 0) {\n                            y = rect.y - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(column.farSizes, farCount)) - axis.maxLabelSize.height\n                                - axis.multiLevelLabelHeight - (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) - axis.labelPadding;\n                        }\n                        else {\n                            y = rect.y + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(column.insideFarSizes, farCount));\n                        }\n                    }\n                    else {\n                        y = rect.y - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(column.farSizes, farCount));\n                    }\n                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n                    farCount++;\n                }\n                else {\n                    if (axis.labelPosition === 'Inside' && axis.orientation === 'Horizontal') {\n                        if (nearCount > 0) {\n                            y = rect.y + rect.height + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(column.nearSizes, nearCount)) + axis.maxLabelSize.height\n                                + axis.multiLevelLabelHeight + (axis.tickPosition === 'Inside' ? axis.majorTickLines.height : 0) + axis.labelPadding;\n                        }\n                        else {\n                            y = rect.y + rect.height - (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(column.insideNearSizes, nearCount));\n                        }\n                    }\n                    else {\n                        y = rect.y + rect.height + (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.sum)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.subArray)(column.nearSizes, nearCount));\n                    }\n                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n                    nearCount++;\n                }\n            }\n        }\n    };\n    /**\n     * Measure the axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.measure = function () {\n        var chart = this.chart;\n        var row;\n        var column;\n        var definition;\n        var actualIndex;\n        var span;\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            //definition.Axes = axis;\n            if (axis.orientation === 'Vertical') {\n                chart.verticalAxes.push(axis);\n                actualIndex = this.getActualRow(axis);\n                row = chart.rows[actualIndex];\n                this.pushAxis(row, axis);\n                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.rows[j];\n                    definition.axes[row.axes.length - 1] = axis;\n                    chart.rows[j] = definition;\n                }\n                chart.rows[actualIndex] = row;\n            }\n            else {\n                chart.horizontalAxes.push(axis);\n                actualIndex = this.getActualColumn(axis);\n                column = chart.columns[actualIndex];\n                this.pushAxis(column, axis);\n                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));\n                for (var j = actualIndex + 1; j < span; j++) {\n                    definition = chart.columns[j];\n                    definition.axes[column.axes.length - 1] = axis;\n                    chart.columns[j] = definition;\n                }\n                chart.columns[actualIndex] = column;\n            }\n            axis.isRTLEnabled = chart.enableRtl;\n            axis.setIsInversedAndOpposedPosition();\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\n        var rangeOffset = position1 ? (position1 + (position2 ? position2 :\n            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);\n        return rangeOffset;\n    };\n    CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            if (axis.crossesAt === null) {\n                continue;\n            }\n            if (!axis.crossesInAxis) {\n                if (chart.requireInvertedAxis) {\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryXAxis : chart.primaryYAxis;\n                }\n                else {\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryYAxis : chart.primaryXAxis;\n                }\n                axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n                continue;\n            }\n            else {\n                for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\n                    if (axis.crossesInAxis === chart.axisCollections[i].name) {\n                        axis.crossInAxis = chart.axisCollections[i];\n                        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n                        continue;\n                    }\n                }\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\n        switch (axis.valueType) {\n            case 'DateTime': {\n                var option = {\n                    skeleton: 'full',\n                    type: 'dateTime'\n                };\n                var dateParser = this.chart.intl.getDateParser(option);\n                var dateFormatter = this.chart.intl.getDateFormat(option);\n                return Date.parse(dateParser(dateFormatter(new Date(_syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_1__.DataUtil.parse.parseJson({ val: crossAt }).val))));\n            }\n            case 'Category':\n                return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\n            case 'Logarithmic':\n                return (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.logBase)(crossAt, axis.logBase);\n            default:\n                return crossAt;\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (!definition.axes[i]) {\n                definition.axes[i] = axis;\n                break;\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n        var axisCollection = [];\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\n            if (definition.axes[i]) {\n                axisCollection.push(definition.axes[i]);\n            }\n        }\n        definition.axes = axisCollection;\n    };\n    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n        var actualLength = this.chart.columns.length;\n        var pos = axis.columnIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n        var actualLength = this.chart.rows.length;\n        var pos = axis.rowIndex;\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\n        return result;\n    };\n    /**\n     * Measure the row size.\n     *\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n        /** Calculate row size */\n        var chart = this.chart;\n        var row;\n        var rowTop = rect.y + rect.height;\n        var height = 0;\n        var remainingHeight = Math.max(0, rect.height);\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\n            row = chart.rows[i];\n            if (row.height.indexOf('%') !== -1) {\n                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));\n            }\n            else {\n                height = Math.min(remainingHeight, parseInt(row.height, 10));\n            }\n            height = (i !== (len - 1)) ? height : remainingHeight;\n            row.computedHeight = height;\n            rowTop -= height;\n            row.computedTop = rowTop;\n            remainingHeight -= height;\n        }\n    };\n    /**\n     * Measure the row size.\n     *\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n        /** Calculate column size */\n        var chart = this.chart;\n        var column;\n        var columnLeft = rect.x;\n        var width = 0;\n        var remainingWidth = Math.max(0, rect.width);\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\n            column = chart.columns[i];\n            if (column.width.indexOf('%') !== -1) {\n                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));\n            }\n            else {\n                width = Math.min(remainingWidth, parseInt(column.width, 10));\n            }\n            width = (i !== (len - 1)) ? width : remainingWidth;\n            column.computedWidth = width;\n            column.computedLeft = columnLeft;\n            columnLeft += width;\n            remainingWidth -= width;\n        }\n    };\n    /**\n     * To render the axis element.\n     *\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.renderAxes = function () {\n        var chart = this.chart;\n        var axis;\n        var axisElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisInsideCollection' });\n        var axisLineElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisOutsideCollection' });\n        if (axisLineElement) {\n            axisLineElement.setAttribute('aria-hidden', 'true');\n        }\n        var outsideElement;\n        var isInside;\n        if (chart.scrollBarModule) {\n            chart.scrollBarModule.topScrollBarCount = 0;\n            chart.scrollBarModule.bottomScrollBarCount = 0;\n            chart.scrollBarModule.leftScrollBarCount = 0;\n            chart.scrollBarModule.rightScrollBarCount = 0;\n        }\n        for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n            var axisVisibility = true;\n            axis = chart.axisCollections[i];\n            this.element = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Inside' });\n            if (this.element) {\n                this.element.setAttribute('aria-hidden', 'true');\n            }\n            outsideElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Outside' });\n            if (outsideElement) {\n                outsideElement.setAttribute('aria-hidden', 'true');\n            }\n            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (axis.name === series.yAxisName || axis.name === series.xAxisName) {\n                    axisVisibility = series.visible;\n                    if (series.category === 'Pareto' && !series.paretoOptions.showAxis && series.type === 'Line') {\n                        axisVisibility = false;\n                    }\n                    if (!axisVisibility) {\n                        continue;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            if (!axisVisibility) {\n                if (axis.zoomingScrollBar) {\n                    axis.zoomingScrollBar.removeScrollSvg();\n                }\n                continue;\n            }\n            isInside = this.findAxisPosition(axis);\n            this.drawAxis(axis, i, isInside, outsideElement, axisElement, axisLineElement);\n        }\n        this.drawPaneLines(chart, axisElement);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n        return axisLineElement;\n    };\n    /**\n     * To render the axis scrollbar\n     *\n     * @param {Chart} chart chart\n     * @param {Axis} axis axis\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\n        var isZoomed = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\n        if (!axis.zoomingScrollBar) {\n            chart.scrollBarModule.injectTo(axis, chart);\n        }\n        if (((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) || (axis.scrollbarSettings.enable &&\n            (axis.zoomFactor <= 1 || axis.zoomPosition >= 0))) &&\n            (!axis.zoomingScrollBar.isScrollUI)) {\n            if (!chart.scrollElement) {\n                chart.scrollElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.redrawElement)(chart.redraw, chart.element.id + '_scrollElement') || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', { id: chart.element.id + '_scrollElement' });\n            }\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\n        }\n        else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\n            axis.zoomingScrollBar.destroy();\n        }\n        else if (axis.zoomingScrollBar.svgObject) {\n            var topOffset = (axis.isAxisOpposedPosition && axis.orientation === 'Horizontal' ? -16 : 0)\n                + axis.rect.y + Math.max(0.5, axis.lineStyle.width / 2);\n            var leftOffset = (axis.isAxisOpposedPosition && axis.orientation !== 'Horizontal' ? 16 : 0)\n                + axis.rect.x - (axis.orientation === 'Vertical' ? axis.scrollbarSettings.height : 0);\n            if (axis.orientation !== 'Horizontal' && (axis.scrollbarSettings.position === 'Left' || axis.scrollbarSettings.position === 'Right')) {\n                leftOffset = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.calculateScrollbarOffset)(axis.zoomingScrollBar, false);\n            }\n            else if (axis.orientation === 'Horizontal' && (axis.scrollbarSettings.position === 'Top' || axis.scrollbarSettings.position === 'Bottom')) {\n                topOffset = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.calculateScrollbarOffset)(axis.zoomingScrollBar, true);\n            }\n            axis.zoomingScrollBar.svgObject.style.top = topOffset + 'px';\n            axis.zoomingScrollBar.svgObject.style.left = leftOffset + 'px';\n        }\n        if (axis.zoomingScrollBar.isScrollUI) {\n            axis.zoomingScrollBar.isScrollUI = false;\n        }\n    };\n    /**\n     * Draws pane lines for the specified chart.\n     *\n     * @param {Chart} chart -The chart for which pane lines are to be drawn.\n     * @param {Element} [axisElement] -Optional. The axis element to which the pane lines are associated.\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawPaneLines = function (chart, axisElement) {\n        this.element = chart.renderer.createGroup({ id: chart.element.id + 'DefinitionLine' });\n        for (var j = 0, len = chart.rows.length; j < len; j++) {\n            var row = chart.rows[j];\n            if (row.border.color) {\n                this.drawBottomLine(row, j, true);\n            }\n        }\n        for (var j = 0, len = chart.columns.length; j < len; j++) {\n            var column = chart.columns[j];\n            if (column.border.color) {\n                this.drawBottomLine(column, j, false);\n            }\n        }\n        axisElement = axisElement ? axisElement : (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(chart.element.id + 'AxisInsideCollection');\n        if (!this.chart.enableCanvas) {\n            axisElement.appendChild(this.element);\n        }\n    };\n    /**\n     * Draws an axis for the specified axis configuration.\n     *\n     * @private\n     * @param {Axis} axis -The axis configuration to be drawn.\n     * @param {number} index -The index of the axis.\n     * @param {boolean} isInside -Indicates whether the axis is inside or outside the plot area.\n     * @param {Element} outsideElement -The element where the axis should be drawn if it's outside the plot area.\n     * @param {Element} axisElement -The element representing the axis.\n     * @param {Element} axisLineElement -The element representing the axis line.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxis = function (axis, index, isInside, outsideElement, axisElement, axisLineElement) {\n        axis.updateCrossValue();\n        var axisName = '';\n        if (axis.orientation === 'Horizontal') {\n            if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n                this.drawAxisLine(axis, index, axis.plotOffset, 0, 0, 0, axis.plotOffsetLeft, axis.plotOffsetRight, isInside ? outsideElement : this.element, axis.updatedRect);\n            }\n            axisName = 'X';\n        }\n        else {\n            if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n                this.drawAxisLine(axis, index, 0, axis.plotOffset, axis.plotOffsetBottom, axis.plotOffsetTop, 0, 0, isInside ? outsideElement : this.element, axis.updatedRect);\n            }\n            axisName = 'Y';\n        }\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0 || axis.minorTickLines.width > 0 ||\n            axis.minorGridLines.width > 0) {\n            this['draw' + axisName + 'AxisGridLine'](axis, index, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);\n        }\n        if (axis.visible && axis.internalVisibility) {\n            this['draw' + axisName + 'AxisLabels'](axis, index, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n            this['draw' + axisName + 'AxisBorder'](axis, index, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n            this['draw' + axisName + 'AxisTitle'](axis, index, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n        }\n        if (!this.chart.enableCanvas) {\n            axisElement.appendChild(this.element);\n            if (outsideElement && outsideElement.childNodes.length > 0) {\n                axisLineElement.appendChild(outsideElement);\n            }\n        }\n        if (this.chart.scrollBarModule && ((this.chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming) ||\n            axis.scrollbarSettings.enable)) {\n            this.renderScrollbar(this.chart, axis);\n        }\n        else {\n            if (axis.zoomingScrollBar) {\n                axis.zoomingScrollBar.destroy();\n            }\n        }\n    };\n    /**\n     * To find the axis position\n     *\n     * @param {Axis} axis axis\n     * @returns {boolean} axis position\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\n        return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\n    };\n    /**\n     * To render the bootom line of the columns and rows\n     *\n     * @param {Row | Column} definition definition\n     * @param {number} index index\n     * @param {boolean} isRow isRow\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\n        var chart = this.chart;\n        var optionsLine = {};\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var definitionName;\n        if (isRow) {\n            definition = definition;\n            y1 = y2 = definition.computedTop + definition.computedHeight;\n            x1 = this.seriesClipRect.x;\n            x2 = x1 + this.seriesClipRect.width;\n            definitionName = 'Row';\n        }\n        else {\n            definition = definition;\n            x1 = x2 = definition.computedLeft;\n            y1 = this.seriesClipRect.y;\n            y2 = y1 + this.seriesClipRect.height;\n            definitionName = 'Column';\n        }\n        optionsLine = {\n            'id': chart.element.id + '_AxisBottom_' + definitionName + index,\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            'stroke-width': definition.border.width,\n            'stroke': definition.border.color\n        };\n        this.htmlObject = chart.renderer.drawLine(optionsLine);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(chart.enableCanvas, this.element, this.htmlObject);\n    };\n    /**\n     * To render the axis line\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {number} plotX plotX\n     * @param {number} plotY plotY\n     * @param {number} plotBottom plotBottom\n     * @param {number} plotTop plotTop\n     * @param {number} plotLeft plotLeft\n     * @param {number} plotRight plotRight\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, plotBottom, plotTop, plotLeft, plotRight, parent, rect) {\n        var chart = this.chart;\n        var optionsLine = {};\n        var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(chart.element.id + 'AxisLine_' + index);\n        var direction = element ? element.getAttribute('d') : '';\n        element = null;\n        optionsLine = {\n            'id': chart.element.id + 'AxisLine_' + index,\n            'd': 'M ' + (rect.x - plotX - plotLeft) + ' ' + (rect.y - plotY - plotTop) +\n                ' L ' + (rect.x + rect.width + plotX + plotRight) + ' ' + (rect.y + rect.height + plotY + plotBottom),\n            'stroke-dasharray': axis.lineStyle.dashArray,\n            'stroke-width': axis.lineStyle.width,\n            'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n        };\n        this.htmlObject = chart.renderer.drawPath(optionsLine);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, null, null, null, chart.duration);\n    };\n    /**\n     * To render the yAxis grid line\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\n        var isLogAxis = axis.valueType === 'Logarithmic';\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n        var tempInterval;\n        var pointY = 0;\n        var majorGrid = '';\n        var majorTick = '';\n        var minorGridDirection;\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;\n        var axisLineSize = (isOpposed) ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\n        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ?\n            0.5 : 0;\n        var scrollBarHeight = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt) && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left') ? isOpposed ? axis.scrollBarHeight :\n            -axis.scrollBarHeight : 0;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var ticks = isTickInside ? (rect.x - tickSize - axisLineSize) : (rect.x + tickSize + axisLineSize + scrollBarHeight);\n        var length = axis.visibleLabels.length;\n        var chartThemeStyle = this.chart.themeStyle;\n        var count = 1;\n        if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0 && !this.chart.stockChart) {\n            length += 1;\n        }\n        var minorGridLines = axis.minorGridLines;\n        var minorTickLines = axis.minorTickLines;\n        //Gridlines\n        for (var i = 0; i < length; i++) {\n            tempInterval = !axis.visibleLabels[i] ? (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel\n                : axis.visibleLabels[i].value - ticksbwtLabel;\n            pointY = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(tempInterval, axis) * rect.height;\n            pointY = (pointY * -1) + (rect.y + rect.height);\n            if (pointY >= rect.y && (rect.y + rect.height) >= pointY) {\n                if (this.chart.redraw && !this.chart.enableCanvas && this.chart.zoomRedraw && axis.visible && axis.majorGridLines.width && i !== 0 && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.chart.element.id + '_MajorGridLine_' + index + '_' + i)) {\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count))) +\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count)));\n                    this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, false);\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                }\n                if (((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.inside)(tempInterval, axis.visibleRange)) || this.isBorder(axis, i, pointY)) {\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (pointY) +\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n                }\n                if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && i !== 0 && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.chart.element.id + '_MajorTickLine_' + index + '_' + i) && !this.chart.enableCanvas && axis.visible) {\n                    majorTick = 'M ' + this.seriesClipRect.x + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count))) +\n                        ' L ' + ticks + ' ' + (this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height / (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count)));\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, false);\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                    count += 1;\n                }\n                majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY +\n                    ' L ' + (ticks) + ' ' + pointY;\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n                if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\n                    if (i === 0 && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isZoomSet)(axis) && !isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n                    }\n                    minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n                    this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\n                    this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n                    if (i === length - 1 && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isZoomSet)(axis) && isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\n                    }\n                }\n            }\n        }\n        if (length && this.previousYLabel > length && !this.chart.enableCanvas && axis.visible &&\n            this.chart.zoomRedraw && this.chart.redraw) {\n            for (var i = length; i < this.previousYLabel; i++) {\n                var pointYValue = this.seriesClipRect.y + (axis.isInversed ? ((this.seriesClipRect.height / length) *\n                    ((i - length) + 1)) + this.seriesClipRect.height : -((this.seriesClipRect.height / length) * ((i - length) + 1)));\n                if (axis.majorGridLines.width) {\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + +pointYValue +\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointYValue;\n                    this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, true);\n                }\n                if (axis.majorTickLines.width) {\n                    majorTick = 'M ' + this.seriesClipRect.x + ' ' + pointYValue +\n                        ' L ' + ticks + ' ' + pointYValue;\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, true);\n                }\n            }\n        }\n    };\n    /**\n     * To check the border of the axis\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {number} value value\n     * @returns {boolean} check the border of the axis\n     */\n    CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\n        var border = this.chart.chartArea.border;\n        var rect = this.seriesClipRect;\n        var orientation = axis.orientation;\n        var start = (orientation === 'Horizontal') ? rect.x : rect.y;\n        var size = (orientation === 'Horizontal') ? rect.width : rect.height;\n        var startIndex = (orientation === 'Horizontal') ? 0 : axis.visibleLabels.length - 1;\n        var endIndex = (orientation === 'Horizontal') ? axis.visibleLabels.length - 1 : 0;\n        if (axis.plotOffset > 0) {\n            return true;\n        }\n        else if ((value === start || value === (start + size)) && (border.width <= 0 || border.color === 'transparent')) {\n            return true;\n        }\n        else if ((value !== start && index === startIndex) || (value !== (start + size) && index === endIndex)) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * To render the yAxis label\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\n        var chart = this.chart;\n        var label;\n        var pointX = 0;\n        var pointY = 0;\n        var elementSize;\n        var labelSpace = axis.labelPadding;\n        var options;\n        var isAxisBreakLabel;\n        var isLabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        var RotatedWidth;\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n        var angle = axis.angle % 360;\n        var isVerticalAngle = (angle === -90 || angle === 90 || angle === 270 || angle === -270);\n        padding += (isVerticalAngle) ? (isLabelInside ? 5 : -5) : 0;\n        padding = (isOpposed) ? padding : -padding;\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\n        var scrollBarHeight = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt) && axis.scrollbarSettings.position !== 'Left' && axis.scrollbarSettings.position !== 'Right') ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\n        var textHeight;\n        var textPadding;\n        var maxLineWidth;\n        var pixel = 10;\n        var isInverse = axis.isAxisInverse;\n        var count = 1;\n        var previousEnd = isInverse ? rect.y : (rect.y + rect.height);\n        var labelPadding;\n        var intervalLength;\n        var labelHeight;\n        var yAxisLabelX;\n        var isLabelOnAxisLineLeft = ((!isOpposed && !isLabelInside) || (isOpposed && isLabelInside));\n        if (isLabelInside) {\n            labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;\n        }\n        else {\n            labelPadding = !isLabelOnAxisLineLeft ? -padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight) :\n                padding + (chart.enableRtl ? -scrollBarHeight : scrollBarHeight);\n        }\n        var sizeWidth = [];\n        var breakLabelSizeWidth = [];\n        axis.visibleLabels.map(function (item) {\n            sizeWidth.push(item.size['width']);\n            breakLabelSizeWidth.push(item.breakLabelSize['width']);\n        });\n        var LabelMaxWidth = Math.max.apply(Math, sizeWidth);\n        var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);\n        RotatedWidth = LabelMaxWidth;\n        if (angle >= -45 && angle <= 45 && angle !== 0) {\n            RotatedWidth = LabelMaxWidth * Math.cos(angle * Math.PI / 180);\n            if (RotatedWidth < 0) {\n                RotatedWidth = -RotatedWidth;\n            }\n        }\n        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n            label = axis.visibleLabels[i];\n            isAxisBreakLabel = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isBreakLabel)(axis.visibleLabels[i].originalText);\n            elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\n            pointY = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value, axis) * rect.height) + (chart.stockChart ? 7 : 0);\n            pointY = Math.floor((pointY * -1) + (rect.y + rect.height));\n            textHeight = ((elementSize.height / 8) * axis.visibleLabels[i].text.length / 2);\n            textPadding = (chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : ((elementSize.height / 4) * 3) + 3;\n            intervalLength = rect.height / axis.visibleLabels.length;\n            labelHeight = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 &&\n                elementSize.width > intervalLength) ? intervalLength : elementSize.width;\n            pointY = (isAxisBreakLabel ? (axis.labelPosition === 'Inside' ? (pointY - (elementSize.height / 2) - textHeight + textPadding)\n                : (pointY - textHeight)) : (axis.labelPosition === 'Inside' ? pointY + textPadding : pointY));\n            if (axis.labelPosition === 'Inside' && ((i === 0 && !axis.isInversed) || (i === len - 1 && axis.isInversed))) {\n                if (chart.stockChart) {\n                    pointY -= (textPadding);\n                }\n                else {\n                    pointY -= (textPadding - ((chart.requireInvertedAxis && axis.labelPosition === 'Inside') ? 0 : (axis.opposedPosition ? -padding : padding)));\n                }\n            }\n            if (axis.majorGridLines.width > axis.majorTickLines.width) {\n                maxLineWidth = axis.majorGridLines.width;\n            }\n            else {\n                maxLineWidth = axis.majorTickLines.width;\n            }\n            if (axis.labelStyle.textAlignment === 'Far') {\n                pointY = pointY - maxLineWidth - pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Near') {\n                pointY = pointY + maxLineWidth + pixel;\n            }\n            // label X value adjustment (Start)\n            if (isLabelInside) {\n                yAxisLabelX = labelPadding + ((angle === 0 ? elementSize.width :\n                    (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);\n            }\n            else {\n                yAxisLabelX = labelPadding - ((angle === 0 ? elementSize.width :\n                    (isAxisBreakLabel ? breakLabelMaxWidth : RotatedWidth)) / 2);\n            }\n            if (axis.enableWrap && chart.requireInvertedAxis && angle && ((!axis.opposedPosition && axis.labelPosition === 'Inside') || (axis.opposedPosition && axis.labelPosition === 'Outside'))) {\n                yAxisLabelX = axis.opposedPosition ? yAxisLabelX - LabelMaxWidth / 2 : yAxisLabelX + LabelMaxWidth / 2;\n            }\n            pointX = isOpposed ? (axis.scrollBarHeight !== 0 && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left') ? ((rect.x + axis.scrollBarHeight + padding) - yAxisLabelX) :\n                (rect.x - yAxisLabelX) : (rect.x + yAxisLabelX);\n            if (isVerticalAngle) {\n                pointX += (isOpposed) ? 5 : -5;\n            }\n            yAxisLabelX = labelPadding;\n            options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle', angle);\n            switch (axis.edgeLabelPlacement) {\n                case 'None':\n                    break;\n                case 'Hide':\n                    if (((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) ||\n                        (((i === len - 1) || (isInverse && i === 0)) && options.y - elementSize.height * 0.5 < rect.y)) {\n                        options.text = '';\n                    }\n                    break;\n                case 'Shift':\n                    if ((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y + rect.height) {\n                        options.y = pointY = rect.y + rect.height;\n                    }\n                    else if (((i === len - 1) || (isInverse && i === 0)) &&\n                        (options.y <= 0)) {\n                        options.y = pointY = rect.y + elementSize.height * 0.5;\n                    }\n                    break;\n            }\n            // ------- Hide Calculation (Start) -------------\n            var previousYValue = options.y;\n            var currentYValue = options.y - labelHeight;\n            if (isAxisBreakLabel) {\n                previousYValue = (options.y - (labelHeight / 2));\n                currentYValue = options.y + (labelHeight / 2);\n            }\n            if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 &&\n                (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {\n                continue;\n            }\n            previousEnd = isInverse ? previousYValue : currentYValue;\n            // ------- Hide Calculation (End) -------------\n            options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n            if (this.chart.redraw && this.chart.zoomRedraw && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(options.id) && !this.chart.enableCanvas && axis.visible) {\n                var optionsY = options.y;\n                options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height + ((this.seriesClipRect.height /\n                    (i ? i : 1)) * count) : -((this.seriesClipRect.height / (i ? i : 1)) * count));\n                this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, false, options, label);\n                options.y = optionsY;\n                count += 1;\n            }\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, false, chart.redraw, true, true, chart.duration, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(pointX, pointY));\n        }\n        if (this.previousYLabel && axis.visibleLabels.length && this.previousYLabel > axis.visibleLabels.length\n            && !this.chart.enableCanvas && axis.visible && this.chart.zoomRedraw && chart.redraw && options.text) {\n            for (var i = axis.visibleLabels.length; i < this.previousYLabel; i++) {\n                options.y = this.seriesClipRect.y + (axis.isInversed ? this.seriesClipRect.height +\n                    ((this.seriesClipRect.height / axis.visibleLabels.length) * ((i - axis.visibleLabels.length) + 1)) :\n                    -((this.seriesClipRect.height / axis.visibleLabels.length) * ((i - axis.visibleLabels.length) + 1)));\n                options.id = chart.element.id + index + '_AxisLabel_' + i;\n                this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, true, options, label);\n            }\n        }\n        else {\n            this.previousYLabel = axis.visibleLabels.length;\n        }\n        if (!this.chart.enableCanvas) {\n            if (!chart.delayRedraw) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(chart.enableCanvas, parent, labelElement, chart.redraw);\n            }\n            else if (axis.visible && axis.internalVisibility) {\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n            }\n        }\n    };\n    /**\n     * Animates the template element.\n     *\n     * @param {Axis} axis axis\n     * @param {Element} element - The element to animate.\n     * @param {number} duration - The duration of the animation.\n     * @param {boolean} label - Label.\n     * @param {Rect} bounds - The bounding rectangle.\n     * @param {boolean} isRemove isRemoved\n     * @param {number} i index of the element\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.rangeAnimate = function (axis, element, duration, label, bounds, isRemove, i) {\n        var _this = this;\n        if (element) {\n            new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Animation({}).animate(element, {\n                duration: duration,\n                progress: function () {\n                    var animateElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(element.id);\n                    animateElement.style.animation = '';\n                    if (label) {\n                        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.withInBounds)(parseFloat(animateElement.getAttribute('x')), parseFloat(animateElement.getAttribute('y')), bounds)) {\n                            animateElement.style.visibility = 'visible';\n                        }\n                        else {\n                            animateElement.style.visibility = 'hidden';\n                        }\n                    }\n                    else {\n                        var direction = animateElement.getAttribute('d').split(' ');\n                        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.withInBounds)(parseFloat(direction[1]), parseFloat(direction[2]), bounds)) {\n                            animateElement.style.visibility = 'visible';\n                        }\n                        else {\n                            animateElement.style.visibility = 'hidden';\n                        }\n                    }\n                },\n                end: function () {\n                    var animateElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(element.id);\n                    animateElement.style.visibility = '';\n                    if (isRemove && i >= axis.visibleLabels.length) {\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.removeElement)(animateElement);\n                        if (label) {\n                            if (axis.orientation === 'Vertical') {\n                                _this.previousYLabel = axis.visibleLabels.length;\n                            }\n                            else {\n                                _this.previousXLabel = axis.visibleLabels.length;\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * To get X value based on lineBreakAlignment for Y axis line break labels only.\n     *\n     * @param {number} x text x position\n     * @param {Axis} axis y axis values\n     * @param {number} textWidth axis label width\n     * @returns {number} returns suitable axis label x position\n     */\n    CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {\n        var anchor = axis.lineBreakAlignment;\n        var isLabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        if ((isOpposed && isLabelInside) || (!isOpposed && !isLabelInside)) {\n            return (anchor === 'Right' ? x : (anchor === 'Center' ? (x - textWidth / 2) : (x - textWidth)));\n        }\n        else {\n            return (anchor === 'Left' ? x : (anchor === 'Center' ? (x + textWidth / 2) : (x + textWidth)));\n        }\n    };\n    /**\n     * To render the yAxis label border.\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\n        if (axis.border.width > 0) {\n            var startY = void 0;\n            var pointY = void 0;\n            var scrollBarHeight = (axis.labelPosition === 'Outside' && axis.scrollbarSettings.position !== 'Right' && axis.scrollbarSettings.position !== 'Left') ? axis.scrollBarHeight : 0;\n            var isOpposed = axis.isAxisOpposedPosition;\n            scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;\n            var gap = (rect.height / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\n                : axis.visibleRange.interval);\n            var endY = void 0;\n            var length_1 = axis.maxLabelSize.width + 10 + ((axis.tickPosition === axis.labelPosition) ?\n                axis.majorTickLines.height : 0);\n            var labelBorder = '';\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\n            var endX = ((isOpposed && axis.labelPosition === 'Inside') || (!isOpposed\n                && axis.labelPosition === 'Outside')) ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n                pointY = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n                pointY = (axis.isAxisInverse ? (1 - pointY) : pointY) * rect.height;\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n                    startY = (pointY * -1) + (rect.y + rect.height);\n                    endY = (pointY * -1) - (gap) + (rect.y + rect.height);\n                }\n                else {\n                    startY = (pointY * -1) + gap / 2 + (rect.y + rect.height);\n                    endY = (pointY * -1) - gap / 2 + (rect.y + rect.height);\n                }\n                switch (axis.border.type) {\n                    case 'Rectangle':\n                    case 'WithoutTopBorder':\n                        if (startY > (rect.y + rect.height)) {\n                            labelBorder += ('M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                        }\n                        else if (Math.floor(rect.y) > (endY)) {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX\n                                + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + (rect.y) + ' ');\n                        }\n                        else {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\n                                ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                            if (i === axis.visibleLabels.length - 1) {\n                                labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' +\n                                    endX + ' ' + endY + ' ');\n                            }\n                        }\n                        break;\n                    case 'WithoutTopandBottomBorder':\n                        if (!(startY > rect.y + rect.height) && !((endY) < Math.floor(rect.y))) {\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\n                                ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' +\n                                'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY);\n                        }\n                        break;\n                }\n            }\n            labelBorder += (axis.border.type === 'Rectangle') ? ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' +\n                (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ') : '';\n            if (labelBorder !== '') {\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\n            }\n        }\n        for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n            if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule && this.chart.visibleSeries[i].visible) {\n                this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\n                break;\n            }\n        }\n    };\n    /**\n     * To render the yAxis title\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\n        if (axis.title) {\n            var chart = this.chart;\n            var isRotated = false;\n            var isOpposed = axis.isAxisOpposedPosition;\n            var labelRotation = (axis.titleRotation == null ? (isOpposed ? 90 : -90) : axis.titleRotation) % 360;\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\n                (axis.labelPosition === 'Inside' ? 0 :\n                    (axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding));\n            padding = (axis.tickPosition !== 'Outside' && (axis.tickPosition === 'Inside' || axis.labelPosition === 'Inside'))\n                ? (axis.titlePadding === 5 ? padding : padding + axis.titlePadding)\n                : padding;\n            padding = isOpposed ? padding + (axis.scrollbarSettings.position === 'Right' || axis.scrollbarSettings.position === 'Left' ? 0 : axis.scrollBarHeight) : -padding - (axis.scrollbarSettings.position === 'Right' || axis.scrollbarSettings.position === 'Left' ? 0 : axis.scrollBarHeight);\n            if ((labelRotation !== -90 && !isOpposed) || (labelRotation !== 90 && isOpposed)) {\n                padding += axis.isAxisOpposedPosition ? axis.titleSize.width / 2 + (axis.labelPosition === 'Inside' ? (axis.labelPadding !== 5 ? 0 : axis.labelPadding) : axis.labelPadding) :\n                    -axis.titleSize.width / 2 - (axis.labelPosition === 'Inside' ? (axis.labelPadding !== 5 ? 0 : axis.labelPadding) : axis.labelPadding);\n                isRotated = true;\n            }\n            var x = rect.x + padding;\n            var y = void 0;\n            var anchor = void 0;\n            if (axis.titleStyle.textAlignment === 'Center') {\n                anchor = 'middle';\n                y = rect.y + rect.height * 0.5;\n            }\n            else if (axis.titleStyle.textAlignment === 'Near') {\n                anchor = axis.opposedPosition ? 'end' : 'start';\n                y = rect.height + rect.y;\n            }\n            else {\n                anchor = axis.opposedPosition ? 'start' : 'end';\n                y = rect.y;\n            }\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\n            var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.TextOption(chart.element.id + '_AxisTitle_' + index, x, y + (isRotated ? -titleSize : -(axis.labelPosition === 'Inside' ? (axis.labelPadding !== 5 ? 0 : axis.labelPadding) : axis.labelPadding) - titleSize), anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);\n            var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(x, y));\n            element.setAttribute('aria-hidden', 'true');\n        }\n    };\n    /**\n     * xAxis grid line calculation performed here\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\n        var isLogAxis = axis.valueType === 'Logarithmic';\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n        var tempInterval;\n        var pointX = 0;\n        var majorGrid = '';\n        var majorTick = '';\n        var minorDirection;\n        var count = 1;\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSize = (isOpposed) ? -axis.majorTickLines.height : axis.majorTickLines.height;\n        var axisLineSize = (isOpposed) ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\n        var scrollBarHeight = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt) && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom') ? isOpposed ? -axis.scrollBarHeight :\n            axis.scrollBarHeight : 0;\n        var ticksbwtLabel = (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) ?\n            0.5 : 0;\n        var length = axis.visibleLabels.length;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var ticks = isTickInside ? (rect.y - tickSize - axisLineSize) : (rect.y + tickSize + axisLineSize + scrollBarHeight);\n        var chartThemeStyle = this.chart.themeStyle;\n        if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks' && !this.chart.stockChart) {\n            length += 1;\n        }\n        var numericIDs = this.calculateGridLineId(parent, length);\n        for (var i = 0; i < length; i++) {\n            if (axis.valueType !== 'DateTimeCategory') {\n                tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel\n                    : (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;\n            }\n            else {\n                tempInterval = axis.visibleLabels[i] ?\n                    axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\n            }\n            pointX = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(tempInterval, axis) * rect.width) + rect.x;\n            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.inside)(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\n                    if (this.chart.redraw && ((this.chart.pointsAdded && !this.chart.pointsRemoved) || this.chart.zoomRedraw) &&\n                        axis.majorGridLines.width && i !== 0 && axis.visible &&\n                        !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.chart.element.id + '_MajorGridLine_' + index + '_' + i) && !this.chart.enableCanvas) {\n                        var pointXValue = this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ?\n                            -((this.seriesClipRect.width / length) * count) : this.seriesClipRect.width +\n                            ((this.seriesClipRect.width / (i ? i : 1)) * count));\n                        majorGrid = 'M ' + pointXValue + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\n                            ' L ' + pointXValue + ' ' + this.seriesClipRect.y;\n                        this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, (numericIDs['MajorGridLine'] && numericIDs['MajorGridLine'].ids ? numericIDs['MajorGridLine'].ids[i] : null), numericIDs['MajorGridLine'] ? numericIDs['MajorGridLine'].isPointRemoved : false);\n                        this.rangeAnimate(axis, this.element.childNodes[this.element.childNodes.length - 1], this.chart.duration, false, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x +\n                            this.seriesClipRect.width, this.chart.availableSize.height), false, i);\n                        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(parent.id)) {\n                            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                        }\n                    }\n                    majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\n                        ' L ' + pointX + ' ' + this.seriesClipRect.y;\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray, (numericIDs['MajorGridLine'] && numericIDs['MajorGridLine'].ids ? numericIDs['MajorGridLine'].ids[i] : null), numericIDs['MajorGridLine'] ? numericIDs['MajorGridLine'].isPointRemoved : false);\n                }\n                if (this.chart.redraw && this.chart.zoomRedraw && axis.majorTickLines.width && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.chart.element.id + '_MajorTickLine_' + index + '_' + i) && !this.chart.enableCanvas && axis.visible) {\n                    majorTick = 'M ' + (this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / length) * count) : this.seriesClipRect.width + ((this.seriesClipRect.width / (i ? i : 1)) * count))) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\n                        + ' L ' + (this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / length) * count) : this.seriesClipRect.width + ((this.seriesClipRect.width / (i ? i : 1)) * count))) + ' ' + ticks;\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, false);\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(parent.id).appendChild(this.element.childNodes[this.element.childNodes.length - 1]);\n                    count += 1;\n                }\n                majorTick = 'M ' + (pointX) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\n                    + ' L ' + (pointX) + ' ' + ticks;\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine, null, (numericIDs['MajorTickLine'] && numericIDs['MajorTickLine'].ids ? numericIDs['MajorTickLine'].ids[i] : null), numericIDs['MajorTickLine'] ? numericIDs['MajorTickLine'].isPointRemoved : false);\n                if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\n                    if (i === 0 && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isZoomSet)(axis) && !isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n                    }\n                    minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n                    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray, (numericIDs['MinorGridLine'] && numericIDs['MinorGridLine'].ids ? numericIDs['MinorGridLine'].ids[i] : null), numericIDs['MinorGridLine'] ? numericIDs['MinorGridLine'].isPointRemoved : false);\n                    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine, null, (numericIDs['MinorTickLine'] && numericIDs['MinorTickLine'].ids ? numericIDs['MinorTickLine'].ids[i] : null), numericIDs['MinorTickLine'] ? numericIDs['MinorTickLine'].isPointRemoved : false);\n                    if (i === length - 1 && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isZoomSet)(axis) && isLogAxis && !isCategoryAxis) {\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\n                    }\n                }\n            }\n        }\n        if (length && this.previousXLabel > length && !this.chart.enableCanvas && axis.visible &&\n            this.chart.zoomRedraw && this.chart.redraw) {\n            for (var i = length; i < this.previousXLabel; i++) {\n                var pointXValue = this.seriesClipRect.x + ((this.chart.enableRtl !== axis.isInversed) ?\n                    -((this.seriesClipRect.width / length) * ((i - length) + 1)) :\n                    this.seriesClipRect.width + ((this.seriesClipRect.width / length) * ((i - length) + 1)));\n                if (axis.majorGridLines.width) {\n                    majorGrid = 'M ' + pointXValue + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\n                        ' L ' + pointXValue + ' ' + this.seriesClipRect.y;\n                    this.updateAxisElement(axis, index, majorGrid, i, '_MajorGridLine_', this.element, true);\n                }\n                if (axis.majorTickLines.width) {\n                    majorTick = 'M ' + (pointXValue) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\n                        + ' L ' + (pointXValue) + ' ' + ticks;\n                    this.updateAxisElement(axis, index, majorTick, i, '_MajorTickLine_', parent, true);\n                }\n            }\n        }\n    };\n    CartesianAxisLayoutPanel.prototype.calculateGridLineId = function (parent, length) {\n        var _this = this;\n        var numericIDs = {};\n        if (this.chart.pointsRemoved) {\n            var elementTypes = ['MajorGridLine', 'MajorTickLine', 'MinorGridLine', 'MinorTickLine'];\n            elementTypes.forEach(function (type) {\n                var parentElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(parent.id);\n                var elements = parentElement.querySelectorAll('[id*=\"_' + type + '_\"]');\n                var elementArray = [];\n                for (var i = 0; i < elements.length; i++) {\n                    elementArray.push(elements[i]);\n                }\n                var len = type === 'MajorGridLine' && _this.chart.chartArea.border.width ? length - 2 : length;\n                len = type === 'MinorGridLine' || type === 'MinorTickLine' ? length - 1 : len;\n                if (elementArray.length > 0 && elementArray.length > len) {\n                    var elementsLength = elementArray.length;\n                    for (var k = 0; k < elementsLength - len; k++) {\n                        if (elementArray[k]) {\n                            parentElement.removeChild(elementArray[k]);\n                        }\n                        elementArray.shift();\n                    }\n                    var numericIds = elementArray.map(function (element) {\n                        var parts = element.id.split('_');\n                        return parseInt(parts[parts.length - 1], 10);\n                    });\n                    numericIDs[type] = {\n                        ids: numericIds,\n                        isPointRemoved: true\n                    };\n                }\n            });\n        }\n        return numericIDs;\n    };\n    /**\n     * To render missing minor grid lines while zooming\n     *\n     * @param {Axis} axis axis\n     * @param {number} tempInterval tempInterval\n     * @param {Rect} rect rect\n     * @param {number} i i\n     * @param {number} index index\n     * @param {IThemeStyle} chartThemeStyle chartThemeStyle\n     * @param {Element} parent parent\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {\n        var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);\n        this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n        this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);\n    };\n    /**\n     * To calcualte the axis minor line\n     *\n     * @param {Axis} axis axis\n     * @param {number} tempInterval tempInterval\n     * @param {Rect} rect rect\n     * @param {number} labelIndex labelIndex\n     * @param {boolean} isFirstLabel isFirstLabel\n     * @returns {string[]} axis minor line path\n     */\n    CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {\n        var value = tempInterval;\n        var coor = 0;\n        var position = 0;\n        var range = axis.visibleRange;\n        var isTickInside = axis.tickPosition === 'Inside';\n        var direction = [];\n        var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\n        var logStart;\n        var logEnd;\n        var logInterval = 1;\n        var logPosition = 1;\n        var ticksX = isTickInside ? (rect.y - tickSize) : (rect.y + tickSize);\n        var ticksY = isTickInside ? (rect.x + tickSize) : (rect.x - tickSize);\n        var minorGird = '';\n        var minorTick = '';\n        var isInverse = axis.isAxisInverse;\n        if (axis.valueType === 'Logarithmic') {\n            logStart = Math.pow(axis.logBase, value - range.interval);\n            logEnd = Math.pow(axis.logBase, value);\n            logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\n            logPosition = logStart + logInterval;\n        }\n        if (axis.orientation === 'Horizontal') {\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n                logPosition += logInterval;\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.inside)(value, range)) {\n                    position = ((value - range.min) / (range.max - range.min));\n                    position = Math.ceil((isInverse ? (1 - position) : position) * rect.width);\n                    coor = (Math.floor(position + rect.x));\n                    if (this.chart.enableCanvas) {\n                        if (minorGird === '') {\n                            minorGird = 'M ' + coor + ' ' + this.seriesClipRect.y +\n                                ' L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height);\n                        }\n                        else {\n                            minorGird = minorGird + ' M ' + coor + ' ' + this.seriesClipRect.y +\n                                ' L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height);\n                        }\n                        coor = (Math.floor(position + rect.x));\n                        if (minorTick === '') {\n                            minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)\n                                + ' L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n                        }\n                        else {\n                            minorTick = minorTick.concat(' M' + ' ' + coor + ' ' + (rect.y)\n                                + ' L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n                        }\n                    }\n                    else {\n                        minorGird = minorGird.concat('M' + ' ' + coor + ' ' + (this.seriesClipRect.y)\n                            + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\n                        coor = (Math.floor(position + rect.x));\n                        minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)\n                            + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n                    }\n                }\n            }\n        }\n        else {\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n                if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.inside)(value, range)) {\n                    position = ((value - range.min) / (range.max - range.min));\n                    position = Math.ceil(((isInverse ? (1 - position) : position)) * rect.height) * -1; // For inversed axis\n                    coor = (Math.floor(position + rect.y + rect.height));\n                    if (this.chart.enableCanvas) {\n                        if (minorGird === '') {\n                            minorGird = 'M ' + this.seriesClipRect.x + ' ' + coor +\n                                ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor;\n                        }\n                        else {\n                            minorGird = minorGird + ' M ' + this.seriesClipRect.x + ' ' + coor +\n                                ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor;\n                        }\n                        coor = (Math.floor(position + rect.y + rect.height));\n                        if (minorTick === '') {\n                            minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + ' L ' + (ticksY - axis.scrollBarHeight) +\n                                ' ' + coor + ' ');\n                        }\n                        else {\n                            minorTick = minorTick.concat(' M' + ' ' + rect.x + ' ' + coor + ' L ' + (ticksY - axis.scrollBarHeight) +\n                                ' ' + coor + ' ');\n                        }\n                    }\n                    else {\n                        minorGird = minorGird.concat('M' + ' ' + (this.seriesClipRect.x) + ' ' + coor\n                            + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\n                        coor = (Math.floor(position + rect.y + rect.height));\n                        minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) +\n                            ' ' + coor + ' ');\n                    }\n                }\n                logPosition += logInterval;\n            }\n        }\n        direction.push(minorGird);\n        direction.push(minorTick);\n        return direction;\n    };\n    /**\n     * To find the numeric value of the log\n     *\n     * @param {Axis} axis axis\n     * @param {number} logPosition logPosition\n     * @param {number} value value\n     * @param {number} labelIndex labelIndex\n     * @param {boolean} isFirstLabel isFirstLabel\n     * @returns {number} value\n     */\n    CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {\n        var range = axis.visibleRange;\n        var tempValue;\n        if (axis.valueType === 'Logarithmic') {\n            value = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.logBase)(logPosition, axis.logBase);\n        }\n        else if (axis.valueType === 'DateTime') {\n            tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\n        }\n        else if (axis.valueType === 'DateTimeCategory') {\n            var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n            value += ((axis.visibleLabels[labelIndex + 1] ?\n                axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) -\n                (axis.visibleLabels[labelIndex] ?\n                    axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) /\n                (axis.minorTicksPerInterval + 1);\n        }\n        else {\n            tempValue = range.interval / (axis.minorTicksPerInterval + 1);\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\n        }\n        return value;\n    };\n    /**\n     * To render the xAxis Labels\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     * @private\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\n        var chart = this.chart;\n        var pointX = 0;\n        var pointY = 0;\n        var previousLabel = 0;\n        var labelSpace = axis.labelPadding;\n        var labelHeight;\n        var elementSize;\n        var labelPadding;\n        var anchor;\n        var pixel = 10;\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\n        var islabelInside = axis.labelPosition === 'Inside';\n        var isOpposed = axis.isAxisOpposedPosition;\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n        var angle = axis.angle % 360;\n        var isHorizontalAngle = (angle === 0 || angle === -180 || angle === 180);\n        var options;\n        var labelWidth;\n        var isInverse = axis.isAxisInverse;\n        var isLeft;\n        var count = 1;\n        var previousEnd = isInverse ? (rect.x + rect.width) : rect.x;\n        var width = 0;\n        var length = axis.visibleLabels.length;\n        var intervalLength;\n        var label;\n        var isAxisBreakLabel;\n        var scrollBarHeight = axis.scrollbarSettings.enable || (!islabelInside && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt)\n            && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) ? axis.scrollbarSettings.position === 'Top' || axis.scrollbarSettings.position === 'Bottom' ? 0 : axis.scrollBarHeight : 0;\n        var newPoints = [];\n        var isRotatedLabelIntersect = false;\n        var textPoints = [];\n        var rotatedLabelSize = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Size(0, 0);\n        padding += (angle === 90 || angle === 270 || angle === -90 || angle === -270) ? (islabelInside ? 5 : -5) : 0;\n        var isLabelUnderAxisLine = ((!isOpposed && !islabelInside) || (isOpposed && islabelInside));\n        var axislabelElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(chart.element.id + 'AxisLabels' + index);\n        var pointsRemoved = this.removeAxisLabelElements(axis, axislabelElement);\n        var legendWidth = (chart.legendModule && chart.legendSettings.position === 'Right' && chart.legendModule.legendBounds.height + chart.legendModule.legendBounds.y >= axis.rect.y) ? chart.legendModule.legendBounds.width : 0;\n        var isEndAnchor = isLabelUnderAxisLine ?\n            ((360 >= angle && angle >= 180) || (-1 >= angle && angle >= -180)) :\n            ((1 <= angle && angle <= 180) || (-181 >= angle && angle >= -360));\n        for (var i = 0, len = length; i < len; i++) {\n            label = axis.visibleLabels[i];\n            isAxisBreakLabel = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isBreakLabel)(label.originalText) || (axis.labelIntersectAction === 'Wrap' && label.text.length > 1);\n            pointX = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(label.value, axis) * rect.width) + rect.x;\n            elementSize = label.size;\n            if (axis.enableWrap) {\n                elementSize.height = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(label.text, axis.labelStyle, chart.themeStyle.axisLabelFont).height;\n            }\n            intervalLength = rect.width / length;\n            labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\n            width = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 &&\n                labelWidth > intervalLength) ? intervalLength : labelWidth;\n            labelHeight = elementSize.height / 4;\n            pointX -= (isAxisBreakLabel || angle !== 0) ? 0 : (width / 2);\n            // label X value adjustment for label rotation (Start)\n            if (angle !== 0) {\n                if (isAxisBreakLabel) {\n                    pointX -= axis.lineBreakAlignment === 'Left' ? (label.breakLabelSize.width / 2) : axis.lineBreakAlignment === 'Right' ?\n                        -(label.breakLabelSize.width / 2) : 0;\n                }\n                else {\n                    pointX -= (angle === -90 || angle === 270 ? -labelHeight : (angle === 90 || angle === -270) ? labelHeight : 0);\n                }\n            }\n            // label X value adjustment for label rotation (End)\n            if (axis.labelStyle.textAlignment === 'Far') {\n                pointX = pointX + width - pixel;\n            }\n            else if (axis.labelStyle.textAlignment === 'Near') {\n                pointX = pointX - width + pixel;\n            }\n            // For line break label alignment like left, right & center in angle 0\n            if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {\n                pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : (width / 2);\n            }\n            var paddingForBreakLabel = isAxisBreakLabel ?\n                (isHorizontalAngle ? (axis.opposedPosition || islabelInside ? 0 : elementSize.height) :\n                    (label.breakLabelSize.width / 2)) : 0;\n            padding = isAxisBreakLabel ? (tickSpace + labelSpace + axis.lineStyle.width * 0.5) : padding;\n            // label Y value adjustment (Start)\n            if (islabelInside && angle) {\n                if (isAxisBreakLabel) {\n                    pointY = isOpposed ? (rect.y + padding + (paddingForBreakLabel)) : (rect.y - padding - (paddingForBreakLabel));\n                }\n                else {\n                    pointY = isOpposed ? (rect.y + padding + labelHeight) : (rect.y - padding - labelHeight);\n                }\n            }\n            else {\n                if (isAxisBreakLabel) {\n                    labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (paddingForBreakLabel)) :\n                        padding + scrollBarHeight + (angle ? paddingForBreakLabel : (3 * labelHeight));\n                }\n                else {\n                    labelPadding = !isLabelUnderAxisLine ?\n                        -(padding + scrollBarHeight + (angle ? labelHeight : (label.index > 1 ? (2 * labelHeight) : 0))) :\n                        padding + scrollBarHeight + ((angle ? 1 : 3) * labelHeight);\n                }\n                pointY = (rect.y + (labelPadding * label.index));\n            }\n            // label Y value adjustment (End)\n            if (isAxisBreakLabel) {\n                anchor = this.getAnchor(axis); // for break label self alignment\n            }\n            else {\n                anchor = (chart.enableRtl) ? ((isEndAnchor) ? '' : 'end') : (chart.isRtlEnabled || isEndAnchor) ? 'end' : '';\n            }\n            options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);\n            options.id = pointsRemoved && axislabelElement &&\n                axislabelElement.children[i] ? axislabelElement.children[i].id : options.id;\n            if (angle !== 0) {\n                rotatedLabelSize = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.rotateTextSize)(label.labelStyle, label.originalText, angle, chart, chart.themeStyle.axisLabelFont);\n                isLeft = ((angle < 0 && angle > -90) || (angle < -180 && angle > -270) ||\n                    (angle > 90 && angle < 180) || (angle > 270 && angle < 360));\n            }\n            if (axis.edgeLabelPlacement) {\n                switch (axis.edgeLabelPlacement) {\n                    case 'None':\n                        break;\n                    case 'Hide':\n                        if (((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) ||\n                            ((i === len - 1 || (isInverse && i === 0)) &&\n                                (options.x + (angle === 0 ? width : rotatedLabelSize.width) > rect.x + rect.width))) {\n                            continue;\n                        }\n                        break;\n                    case 'Shift':\n                        if (i === len - 2 && axis.labelIntersectAction !== 'MultipleRows') {\n                            if (anchor === 'start' || anchor === '') {\n                                previousLabel = options.x + width; // For start anchor\n                            }\n                            else if (anchor === 'middle') {\n                                previousLabel = options.x + (width / 2); // For middle anchor\n                            }\n                            else {\n                                previousLabel = options.x; // For end anchor\n                            }\n                        }\n                        if ((i === 0 || (isInverse && i === len - 1)) && (options.x < rect.x || (angle !== 0 && isLeft && options.x < rect.x) || (axis.lineBreakAlignment === 'Center' && options.x - (label.size.width / label.text.length) / 2 < rect.x && angle === 0))) {\n                            intervalLength -= (rect.x - options.x);\n                            if (anchor === '') {\n                                if (options.x <= 0) {\n                                    pointX = options.x = 0;\n                                }\n                                else {\n                                    pointX = options.x;\n                                }\n                                intervalLength = rect.width / length;\n                            }\n                            else if (isLeft && angle !== 0) {\n                                intervalLength = rect.width / length;\n                                if (rect.x + intervalLength > options.x + rotatedLabelSize.width) {\n                                    options.x = pointX = rect.x + padding;\n                                }\n                                else {\n                                    options.x = pointX = rect.x + intervalLength - padding;\n                                }\n                            }\n                            else if (isAxisBreakLabel && axis.lineBreakAlignment === 'Center' && axis.labelPlacement === 'OnTicks' && angle === 0) {\n                                var maxWidth = 0;\n                                for (var i_1 = 0; i_1 < label.text.length; i_1++) {\n                                    var breakLabelWidth = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(label.text[i_1], axis.labelStyle, chart.themeStyle.axisLabelFont).width;\n                                    if (breakLabelWidth > maxWidth) {\n                                        maxWidth = breakLabelWidth;\n                                    }\n                                }\n                                options.x = pointX = rect.x + maxWidth / 2;\n                            }\n                            else if (!(anchor === 'start' && options.x > 0)) {\n                                options.x = pointX = !isHorizontalAngle ? rect.x + padding : rect.x;\n                            }\n                        }\n                        else if ((i === len - 1 || (isInverse && i === 0)) &&\n                            (((options.x + width) > chart.availableSize.width - chart.border.width - legendWidth && (anchor === 'start' || anchor === '') && angle === 0) ||\n                                ((anchor === 'start') && angle !== 0 && !isLeft && (options.x + rotatedLabelSize.width) > chart.availableSize.width - chart.border.width - legendWidth) ||\n                                (anchor === 'middle' && angle !== 0 && !isLeft && (options.x + rotatedLabelSize.width / 2) > chart.availableSize.width - chart.border.width - legendWidth) ||\n                                (anchor === 'end' && angle !== 0 && !isLeft && options.x > chart.availableSize.width - chart.border.width - legendWidth) ||\n                                (anchor === 'end' && options.x > chart.availableSize.width - chart.border.width - legendWidth && angle === 0) ||\n                                (anchor === 'middle' && (options.x + width / 2) > chart.availableSize.width - chart.border.width - legendWidth && angle === 0))) {\n                            var axisLabelWidth = angle !== 0 ? rotatedLabelSize.width : width;\n                            var shiftedXValue = void 0;\n                            //Apply a default 5px padding between the edge label and the chart container\n                            var padding_1 = 5;\n                            if (anchor === 'start' || anchor === '') {\n                                shiftedXValue = options.x - ((options.x + axisLabelWidth) -\n                                    chart.availableSize.width + chart.border.width + padding_1 + legendWidth);\n                            }\n                            else if (anchor === 'middle') {\n                                shiftedXValue = options.x - ((options.x + axisLabelWidth / 2) -\n                                    chart.availableSize.width + chart.border.width + padding_1 + legendWidth);\n                            }\n                            else {\n                                shiftedXValue = options.x - (options.x - (chart.availableSize.width + chart.border.width + padding_1\n                                    + legendWidth));\n                            }\n                            // Check for overlap with previous label\n                            if (previousLabel !== 0 && shiftedXValue < previousLabel) {\n                                var maxAvailableWidth = chart.availableSize.width - previousLabel;\n                                label.text = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(maxAvailableWidth, label.originalText, axis.labelStyle, chart.isRtlEnabled, chart.themeStyle.axisLabelFont);\n                            }\n                            else {\n                                options.x = pointX = shiftedXValue;\n                            }\n                        }\n                        break;\n                }\n            }\n            options.text = this.getLabelText(label, axis, intervalLength);\n            options.labelRotation = angle;\n            // ------- Hide Calculation (Start) -------------\n            // Currect label actual start value (Start)\n            var xValue = void 0;\n            var xValue2 = void 0;\n            if (isAxisBreakLabel && angle === 0) {\n                if (axis.lineBreakAlignment === 'Right') {\n                    xValue = (options.x - width);\n                    xValue2 = options.x;\n                }\n                else if (axis.lineBreakAlignment === 'Center') {\n                    xValue = (options.x - (width / 2));\n                    xValue2 = options.x + (width / 2);\n                }\n                else {\n                    xValue = options.x;\n                    xValue2 = options.x + width;\n                }\n            }\n            else {\n                xValue = options.x;\n                xValue2 = options.x + width;\n            }\n            // Currect label actual start value (End)\n            if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 &&\n                (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {\n                continue;\n            }\n            // Previous label actual end value (Start)\n            if (isAxisBreakLabel) {\n                if (axis.lineBreakAlignment === 'Right') {\n                    previousEnd = isInverse ? (options.x - width) : options.x;\n                }\n                else if (axis.lineBreakAlignment === 'Center') {\n                    previousEnd = isInverse ? (options.x - (width / 2)) : options.x + (width / 2);\n                }\n                else {\n                    previousEnd = isInverse ? options.x : options.x + width;\n                }\n            }\n            else {\n                previousEnd = isInverse ? options.x : options.x + width;\n            }\n            // Previous label actual end value (End)\n            // ------- Hide Calculation (End) -------------\n            // label Rotataion calculation (Start)\n            if (angle !== 0) {\n                var height = void 0;\n                var rect_1 = void 0;\n                if (isAxisBreakLabel) {\n                    var xAdjustment = 0;\n                    var yAdjustment = 0;\n                    height = (label.breakLabelSize.height);\n                    yAdjustment = (label.breakLabelSize.height) - 4; // 4 for label bound correction\n                    // xAdjustment (Start)\n                    if (axis.lineBreakAlignment === 'Center') {\n                        xAdjustment = -(label.breakLabelSize.width / 2);\n                    }\n                    else if (axis.lineBreakAlignment === 'Right') {\n                        xAdjustment = -label.breakLabelSize.width;\n                    }\n                    // xAdjustment (End)\n                    if (isLabelUnderAxisLine) {\n                        yAdjustment = (label.breakLabelSize.height) / (options.text.length + 1);\n                    }\n                    rect_1 = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(options.x + xAdjustment, options.y - (yAdjustment), label.breakLabelSize.width, height);\n                }\n                else {\n                    height = (pointY) - (options.y - ((label.size.height / 2)));\n                    rect_1 = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(options.x, options.y - ((label.size.height / 2) - 5), label.size.width, height);\n                }\n                var rectCoordinates = this.getRectanglePoints(rect_1);\n                var rectCenterX = isAxisBreakLabel ? rect_1.x + (rect_1.width / 2) : pointX;\n                var rectCenterY = isAxisBreakLabel ? rect_1.y + (rect_1.height / 2) : (pointY - (height / 2));\n                if (isAxisBreakLabel) {\n                    options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';\n                }\n                else {\n                    options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n                }\n                newPoints.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getRotatedRectangleCoordinates)(rectCoordinates, rectCenterX, rectCenterY, angle));\n                isRotatedLabelIntersect = false;\n                if (axis.labelIntersectAction !== 'None') {\n                    for (var index_1 = i; index_1 > 0; index_1--) {\n                        if (newPoints[i] && newPoints[index_1 - 1] &&\n                            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isRotatedRectIntersect)(newPoints[i], newPoints[index_1 - 1])) {\n                            isRotatedLabelIntersect = true;\n                            newPoints[i] = null;\n                            break;\n                        }\n                    }\n                }\n                var rotateAngle = ((angle > 0 && angle < 90) || (angle > 180 && angle < 270) ||\n                    (angle < -90 && angle > -180) || (angle < -270 && angle > -360));\n                var textRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(options.x, options.y - (elementSize.height / 2 + padding / 2), label.size.width, height);\n                var textRectCoordinates = this.getRectanglePoints(textRect);\n                var rectPoints = [];\n                rectPoints.push(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(rotateAngle ? this.chart.availableSize.width : this.padding, axis.rect.y));\n                rectPoints.push(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(rotateAngle ? this.chart.availableSize.width :\n                    this.padding, axis.rect.y + axis.maxLabelSize.height));\n                textPoints.push((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getRotatedRectangleCoordinates)(textRectCoordinates, rectCenterX, rectCenterY, angle));\n                var newRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(0, axis.rect.y, this.chart.availableSize.width, axis.maxLabelSize.height * 2);\n                for (var k = 0; k < textPoints[i].length; k++) {\n                    if (!axis.opposedPosition && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.withInBounds)(textPoints[i][k].x, textPoints[i][k].y, newRect) && typeof options.text === 'string') {\n                        var interSectPoint = this.calculateIntersection(textPoints[i][0], textPoints[i][1], rectPoints[0], rectPoints[1]);\n                        var rectPoint1 = rotateAngle ? this.chart.availableSize.width - pointX : pointX;\n                        var rectPoint2 = interSectPoint.y - axis.rect.y;\n                        var trimValue = Math.sqrt((rectPoint1 * rectPoint1) + (rectPoint2 * rectPoint2));\n                        options.text = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(trimValue, label.text, label.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont);\n                    }\n                }\n            }\n            if (this.chart.redraw && ((chart.pointsAdded && !chart.pointsRemoved) || this.chart.zoomRedraw) &&\n                !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(options.id) && i !== 0 && !this.chart.enableCanvas && axis.visible) {\n                var optionsX = options.x;\n                options.x = this.seriesClipRect.x + ((chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / (i ? i : 1))\n                    * count) : this.seriesClipRect.width + (this.seriesClipRect.width / (i ? i : 1)) * count);\n                var transform = options.transform;\n                options.transform = angle ? 'rotate(' + angle + ',' + options.x + ',' + parseFloat(options.transform.split(',')[2]) + ')' : '';\n                var element_1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont);\n                this.rangeAnimate(axis, element_1, this.chart.duration, true, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect(this.seriesClipRect.x, axis.rect.y, this.seriesClipRect.x + this.seriesClipRect.width, this.chart.availableSize.height), false, i);\n                options.x = optionsX;\n                options.transform = transform;\n                count += 1;\n            }\n            // label Rotataion calculation (End)\n            var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabelFont.color, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, chart.duration, null, label.size, isRotatedLabelIntersect, chart.enableCanvas, null, chart.themeStyle.axisLabelFont, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(parseFloat(options.transform.split(',')[1]), parseFloat(options.transform.split(',')[2])));\n            if (pointsRemoved) {\n                element.id = chart.element.id + index + '_AxisLabel_' + i;\n            }\n        }\n        if (this.previousXLabel && length && this.previousXLabel > length && !this.chart.enableCanvas &&\n            axis.visible && this.chart.zoomRedraw && this.chart.redraw && options.text) {\n            for (var i = length; i < this.previousXLabel; i++) {\n                options.x = this.seriesClipRect.x + ((chart.enableRtl !== axis.isInversed) ? -((this.seriesClipRect.width / length) *\n                    (i - length + 1)) : this.seriesClipRect.width + ((this.seriesClipRect.width / length) * (i - length + 1)));\n                options.id = chart.element.id + index + '_AxisLabel_' + i;\n                options.transform = angle ? 'rotate(' + angle + ',' + options.x + ',' + parseFloat(options.transform.split(',')[2]) + ')' : '';\n                this.updateAxisElement(axis, index, '', i, '_AxisLabel_', labelElement, true, options, label);\n            }\n        }\n        else {\n            this.previousXLabel = length;\n        }\n        if (!this.chart.enableCanvas) {\n            if (!chart.delayRedraw) {\n                parent.appendChild(labelElement);\n            }\n            else if (axis.visible && axis.internalVisibility) {\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n            }\n        }\n    };\n    /**\n     * To render the axis grid, tick lines and label\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} gridDirection gridDirection\n     * @param {number} i index of the element\n     * @param {string} elementId elementId\n     * @param {Element} parentElement parent\n     * @param {boolean} isRemove isRemoved\n     * @param {TextOption} option - The options for the text element.\n     * @param {VisibleLabels} label - Label.\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.updateAxisElement = function (axis, index, gridDirection, i, elementId, parentElement, isRemove, option, label) {\n        var element;\n        var isGrid = elementId.indexOf('Grid') > -1;\n        var isLabel = elementId.indexOf('Label') > -1;\n        if (isLabel) {\n            element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(this.chart.renderer, option, label.labelStyle, label.labelStyle.color || this.chart.themeStyle.axisLabelFont.color, parentElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), this.chart.redraw, true, null, this.chart.duration, null, null, null, this.chart.enableCanvas, null, this.chart.themeStyle.axisLabelFont);\n        }\n        else {\n            this.renderGridLine(axis, index, gridDirection, isGrid ? axis.majorGridLines : axis.majorTickLines, elementId, i, this.element, isGrid ? this.chart.themeStyle.majorGridLine : this.chart.themeStyle.majorTickLine, isGrid ? axis.majorGridLines.dashArray : null);\n            if (this.element && parentElement.childNodes) {\n                element = this.element.childNodes[parentElement.childNodes.length - 1];\n            }\n        }\n        this.rangeAnimate(axis, element, this.chart.duration, isLabel, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.Rect((axis.orientation === 'Vertical') ? 0 : this.seriesClipRect.x, (axis.orientation === 'Vertical') ? this.seriesClipRect.y : axis.rect.y, this.seriesClipRect.width, this.seriesClipRect.height), isRemove, i);\n    };\n    CartesianAxisLayoutPanel.prototype.removeAxisLabelElements = function (axis, axislabelElement) {\n        if (this.chart.pointsRemoved && axislabelElement && axislabelElement.childNodes.length) {\n            var pointsRemoved = false;\n            if (axis.valueType.indexOf('Category') > -1) {\n                var visibleLabelTexts_1 = [];\n                axis.visibleLabels.map(function (label) {\n                    if (typeof label.text !== 'string') {\n                        visibleLabelTexts_1.push(label.text.join(''));\n                    }\n                    else {\n                        visibleLabelTexts_1.push(label.text);\n                    }\n                });\n                for (var i = axislabelElement.childNodes.length - 1; i >= 0; i--) {\n                    var childNode = axislabelElement.childNodes[i];\n                    if (visibleLabelTexts_1.indexOf(childNode.textContent.trim()) === -1) {\n                        axislabelElement.removeChild(childNode);\n                        pointsRemoved = true;\n                    }\n                }\n            }\n            else if (axislabelElement.childNodes.length > axis.visibleLabels.length) {\n                for (var j = 0; j < axislabelElement.childNodes.length - axis.visibleLabels.length; j++) {\n                    axislabelElement.removeChild(axislabelElement.childNodes[j]);\n                    pointsRemoved = true;\n                }\n            }\n            return pointsRemoved;\n        }\n        return false;\n    };\n    CartesianAxisLayoutPanel.prototype.calculateIntersection = function (p1, p2, p3, p4) {\n        var c2x = p3.x - p4.x;\n        var c3x = p1.x - p2.x;\n        var c2y = p3.y - p4.y;\n        var c3y = p1.y - p2.y;\n        var d = c3x * c2y - c3y * c2x;\n        var u1 = p1.x * p2.y - p1.y * p2.x;\n        var u4 = p3.x * p4.y - p3.y * p4.x;\n        var px = (u1 * c2x - c3x * u4) / d;\n        var py = (u1 * c2y - c3y * u4) / d;\n        var p = { x: px, y: py };\n        return p;\n    };\n    /**\n     * To get text anchor value for line break labels.\n     *\n     * @param {Axis} axis axis model\n     * @returns {string} returns text anchor\n     */\n    CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {\n        return (axis.lineBreakAlignment === 'Center' ? 'middle' : (this.chart.enableRtl) ? (axis.lineBreakAlignment === 'Left' ? 'end' : 'start') : (axis.lineBreakAlignment === 'Left' ? 'start' : 'end'));\n    };\n    /**\n     * Get rect coordinates\n     *\n     * @param {Rect} rect rect\n     * @returns {ChartLocation[]} rectangle points\n     */\n    CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {\n        var point1 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(rect.x, rect.y);\n        var point2 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(rect.x + rect.width, rect.y);\n        var point3 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(rect.x + rect.width, rect.y + rect.height);\n        var point4 = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(rect.x, rect.y + rect.height);\n        return [point1, point2, point3, point4];\n    };\n    /**\n     * To get axis label text\n     *\n     * @param {VisibleLabels} label label\n     * @param {Axis} axis axis\n     * @param {number} intervalLength intervalLength\n     * @returns {string | string[]} label or label collection\n     */\n    CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\n        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.isBreakLabel)(label.originalText)) {\n            var result = [];\n            var str = void 0;\n            for (var index = 0; index < label.text.length; index++) {\n                str = this.findAxisLabel(axis, label.text[index], intervalLength);\n                result.push(str);\n            }\n            return result;\n        }\n        else {\n            return this.findAxisLabel(axis, label.text, intervalLength);\n        }\n    };\n    /**\n     * To render the x-axis label border.\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} axisRect axisRect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\n        if (axis.border.width > 0) {\n            var scrollBarHeight = (axis.labelPosition === 'Outside' && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom') ? axis.scrollBarHeight : 0;\n            var isOpposed = axis.isAxisOpposedPosition;\n            var startX = void 0;\n            var startY = axisRect.y + ((isOpposed ? -1 : 1) * scrollBarHeight);\n            var padding = 10;\n            var pointX = void 0;\n            var gap = (axisRect.width / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\n                : axis.visibleRange.interval);\n            var endX = void 0;\n            var length_2 = axis.maxLabelSize.height +\n                ((axis.tickPosition === axis.labelPosition) ? axis.majorTickLines.height : 0);\n            var labelBorder = '';\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\n            var endY = ((isOpposed && axis.labelPosition === 'Inside') ||\n                (!isOpposed && axis.labelPosition === 'Outside')) ?\n                (axisRect.y + length_2 + padding + scrollBarHeight) : (axisRect.y - length_2 - padding - scrollBarHeight);\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n                pointX = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.valueToCoefficient)(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n                pointX = (axis.isAxisInverse ? (1 - pointX) : pointX) * axisRect.width;\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n                    startX = pointX + axisRect.x;\n                    endX = pointX + (gap) + axisRect.x;\n                }\n                else {\n                    startX = pointX - gap * 0.5 + axisRect.x;\n                    endX = pointX + gap * 0.5 + axisRect.x;\n                }\n                switch (axis.border.type) {\n                    case 'Rectangle':\n                    case 'WithoutTopBorder':\n                        if (startX < axisRect.x && axis.labelPlacement !== 'OnTicks') {\n                            labelBorder += ('M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                        }\n                        else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1) &&\n                            !(i === axis.visibleLabels.length - 1)) {\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ');\n                        }\n                        else {\n                            startX = (i === 0 && axis.labelPlacement === 'OnTicks') ? axisRect.x : startX;\n                            endX = ((i === axis.visibleLabels.length - 1) && axis.labelPlacement === 'OnTicks') ? endX - gap * 0.5 : endX;\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' +\n                                endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\n                            if (i === 0) {\n                                labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                    'M ' + startX + ' ' + endY + ' L ' + (axisRect.x) + ' ' + endY);\n                            }\n                            if (i === axis.visibleLabels.length - 1) {\n                                labelBorder += ('M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' +\n                                    'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY);\n                            }\n                        }\n                        break;\n                    case 'WithoutTopandBottomBorder':\n                        if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\n                                'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY);\n                        }\n                        break;\n                }\n            }\n            labelBorder += (axis.border.type === 'Rectangle' ? ('M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' +\n                (axisRect.x + axisRect.width) + ' ' + startY) : '');\n            if (labelBorder !== '') {\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\n            }\n        }\n        for (var i = 0; i < this.chart.visibleSeries.length; i++) {\n            if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0 && this.chart.visibleSeries[i].visible) {\n                this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\n                break;\n            }\n        }\n    };\n    /**\n     * To create border element of the axis\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} labelBorder labelBorder\n     * @param {Element} parent parent\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\n        var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(this.chart.element.id + '_BorderLine_' + index);\n        var direction = element ? element.getAttribute('d') : '';\n        var borderElement = this.chart.renderer.drawPath(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\n        borderElement.style.pointerEvents = 'none';\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, false, 'x', 'y', null, direction, true, null, null, this.chart.duration);\n    };\n    /**\n     * To find the axis label of the intersect action\n     *\n     * @param {Axis} axis axis\n     * @param {string} label label\n     * @param {number} width width\n     * @returns {string} label\n     */\n    CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\n        return (axis.labelIntersectAction === 'Trim' ?\n            ((axis.angle % 360 === 0 && !axis.enableTrim) ? (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textTrim)(width, label, axis.labelStyle, this.chart.enableRtl, this.chart.themeStyle.axisLabelFont) : label) : label);\n    };\n    /**\n     * X-Axis Title function performed\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Element} parent parent\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\n        if (axis.title) {\n            var chart = this.chart;\n            var elementSize = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.measureText)(axis.title, axis.titleStyle, this.chart.themeStyle.axisTitleFont);\n            var scrollBarHeight = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(axis.crossesAt) && axis.scrollbarSettings.position !== 'Top' && axis.scrollbarSettings.position !== 'Bottom') ? axis.scrollBarHeight : 0;\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\n                (axis.labelPosition === 'Inside' ? 0 :\n                    axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);\n            padding = (axis.tickPosition !== 'Outside' && (axis.tickPosition === 'Inside' || axis.labelPosition === 'Inside'))\n                ? (axis.titlePadding === 5 ? padding : padding + axis.titlePadding)\n                : padding;\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\n            padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : (padding + (3 *\n                elementSize.height / 4) + scrollBarHeight);\n            var labelRotation = axis.titleRotation ? axis.titleRotation : 0;\n            var x = void 0;\n            var y = rect.y + padding;\n            var anchor = void 0;\n            if (axis.titleStyle.textAlignment === 'Center') {\n                anchor = 'middle';\n                x = rect.x + rect.width * 0.5;\n            }\n            else if (axis.titleStyle.textAlignment === 'Near') {\n                anchor = 'start';\n                x = rect.x;\n            }\n            else {\n                anchor = 'end';\n                x = rect.x + rect.width;\n            }\n            if (labelRotation !== 0) {\n                y += axis.opposedPosition ? -(axis.titleSize.height / 2 + elementSize.height / 4) :\n                    axis.titleSize.height / 2 - elementSize.height / 4;\n            }\n            var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.TextOption(chart.element.id + '_AxisTitle_' + index, x, y, anchor, axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);\n            var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.textElement)(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitleFont.color, parent, null, chart.redraw, chart.redraw, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.axisTitleFont, new _common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.ChartLocation(x, y));\n            element.setAttribute('aria-hidden', 'true');\n        }\n    };\n    /**\n     * To render the axis grid and tick lines(Both Major and Minor)\n     *\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {string} gridDirection gridDirection\n     * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel\n     * @param {string} gridId gridId\n     * @param {number} gridIndex gridIndex\n     * @param {Element} parent parent\n     * @param {string} themeColor themeColor\n     * @param {string} dashArray dashArray\n     * @param {number} removeIndex removeIndex\n     * @param {boolean} isRemoved isRemoved\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray, removeIndex, isRemoved) {\n        if (dashArray === void 0) { dashArray = null; }\n        if (removeIndex === void 0) { removeIndex = null; }\n        if (isRemoved === void 0) { isRemoved = false; }\n        var chart = this.chart;\n        var direction;\n        var element;\n        if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {\n            element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(chart.element.id + gridId + index + '_' + (isRemoved ? removeIndex : gridIndex));\n            direction = element ? element.getAttribute('d') : null;\n            element = null;\n            this.htmlObject = chart.renderer.drawPath(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_3__.PathOption(chart.element.id + gridId + index + '_' + (isRemoved ? removeIndex : gridIndex), 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.appendChildElement)(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true, null, null, chart.duration);\n            if (isRemoved) {\n                this.htmlObject.id = chart.element.id + gridId + index + '_' + gridIndex;\n            }\n        }\n    };\n    /**\n     * To Find the parent node of the axis\n     *\n     * @param {string} elementId elementId\n     * @param {Element} label label\n     * @param {number} index index\n     * @returns {Element} parent node of the axis\n     */\n    CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {\n        if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n        }\n        else {\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\n        }\n    };\n    /**\n     * Create Zooming Labels Function Called here\n     *\n     * @param {Chart} chart chart\n     * @param {Element} labelElement labelElement\n     * @param {Axis} axis axis\n     * @param {number} index index\n     * @param {Rect} rect rect\n     * @returns {void}\n     */\n    CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\n        var parentNode = this.findParentNode(chart.element.id, labelElement, index);\n        labelElement.setAttribute('opacity', '0.3');\n        var zoomElement = chart.renderer.createGroup({\n            id: chart.element.id + 'AxisLabels_Zoom' + index\n        });\n        zoomElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.createZoomingLabels)(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\n        parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\n        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_2__.getElement)(chart.element.id + 'AxisLabels_Zoom' + index)) {\n            parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\n        }\n        else {\n            parentNode.appendChild(zoomElement);\n        }\n    };\n    return CartesianAxisLayoutPanel;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/axis/cartesian-panel.js?");

/***/ })

}]);