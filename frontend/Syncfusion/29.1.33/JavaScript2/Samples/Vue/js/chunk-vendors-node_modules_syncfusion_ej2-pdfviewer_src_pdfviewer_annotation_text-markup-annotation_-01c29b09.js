"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_annotation_text-markup-annotation_-01c29b09"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/text-markup-annotation.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/text-markup-annotation.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextMarkupAnnotation: () => (/* binding */ TextMarkupAnnotation)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n/**\n * The `TextMarkupAnnotation` module is used to handle text markup annotation actions of PDF viewer.\n *\n * @hidden\n * @param {Event} event - It describes about the event\n * @returns {void}\n */\nvar TextMarkupAnnotation = /** @class */ (function () {\n    /**\n     * @param {PdfViewer} pdfViewer - It describes about the pdfViewer\n     * @param {PdfViewerBase} viewerBase - It describes about the viewerBase\n     * @private\n     * @returns {void}\n     */\n    function TextMarkupAnnotation(pdfViewer, viewerBase) {\n        var _this = this;\n        /**\n         * @private\n         */\n        this.currentTextMarkupAddMode = '';\n        /**\n         * @private\n         */\n        this.selectTextMarkupCurrentPage = null;\n        /**\n         * @private\n         */\n        this.currentTextMarkupAnnotation = null;\n        /**\n         * @private\n         */\n        this.isAddAnnotationProgramatically = false;\n        this.currentAnnotationIndex = null;\n        this.isAnnotationSelect = false;\n        /**\n         * @private\n         */\n        this.isDropletClicked = false;\n        /**\n         * @private\n         */\n        this.isRightDropletClicked = false;\n        /**\n         * @private\n         */\n        this.isLeftDropletClicked = false;\n        /**\n         * @private\n         */\n        this.isSelectionMaintained = false;\n        this.isExtended = false;\n        this.isNewAnnotation = false;\n        this.selectedTextMarkup = null;\n        this.multiPageCollection = [];\n        this.triggerAddEvent = false;\n        /**\n         * @private\n         */\n        this.isSelectedAnnotation = false;\n        this.dropletHeight = 20;\n        // To update the height value of strikethrough and underline annotations for Chinese language (Task ID: 861029).\n        this.strikeoutDifference = -3;\n        this.underlineDifference = 2;\n        /**\n         * @private\n         */\n        this.annotationClickPosition = {};\n        this.maintainSelection = function () {\n            _this.isDropletClicked = true;\n            _this.pdfViewer.textSelectionModule.initiateSelectionByTouch();\n            _this.isExtended = true;\n            _this.pdfViewer.textSelectionModule.selectionRangeArray = [];\n        };\n        this.selectionEnd = function () {\n            if (_this.isDropletClicked) {\n                _this.isDropletClicked = false;\n            }\n        };\n        this.annotationLeftMove = function () {\n            if (_this.isDropletClicked) {\n                _this.isLeftDropletClicked = true;\n            }\n        };\n        this.annotationRightMove = function () {\n            if (_this.isDropletClicked) {\n                _this.isRightDropletClicked = true;\n            }\n        };\n        this.pdfViewer = pdfViewer;\n        this.pdfViewerBase = viewerBase;\n    }\n    /**\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.createAnnotationSelectElement = function () {\n        this.dropDivAnnotationLeft = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_droplet_left', className: 'e-pv-drop' });\n        this.dropDivAnnotationLeft.style.borderRight = '2px solid';\n        this.dropDivAnnotationRight = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_droplet_right', className: 'e-pv-drop' });\n        this.dropDivAnnotationRight.style.borderLeft = '2px solid';\n        this.dropElementLeft = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-droplet', id: this.pdfViewer.element.id + '_dropletspan_left' });\n        this.dropElementLeft.style.transform = 'rotate(0deg)';\n        this.dropDivAnnotationLeft.appendChild(this.dropElementLeft);\n        this.dropElementRight = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-droplet', id: this.pdfViewer.element.id + '_dropletspan_right' });\n        this.dropElementRight.style.transform = 'rotate(-90deg)';\n        this.dropDivAnnotationRight.appendChild(this.dropElementRight);\n        this.pdfViewerBase.pageContainer.appendChild(this.dropDivAnnotationLeft);\n        this.pdfViewerBase.pageContainer.appendChild(this.dropDivAnnotationRight);\n        this.dropElementLeft.style.top = '20px';\n        this.dropElementRight.style.top = '20px';\n        this.dropElementRight.style.left = '-8px';\n        this.dropElementLeft.style.left = '-8px';\n        this.dropDivAnnotationLeft.style.display = 'none';\n        this.dropDivAnnotationRight.style.display = 'none';\n        this.dropDivAnnotationLeft.addEventListener('mousedown', this.maintainSelection);\n        this.dropDivAnnotationLeft.addEventListener('mousemove', this.annotationLeftMove);\n        this.dropDivAnnotationLeft.addEventListener('mouseup', this.selectionEnd);\n        this.dropDivAnnotationRight.addEventListener('mousedown', this.maintainSelection);\n        this.dropDivAnnotationRight.addEventListener('mousemove', this.annotationRightMove);\n        this.dropDivAnnotationRight.addEventListener('mouseup', this.selectionEnd);\n    };\n    /**\n     * @param {any} target - It describes about the target\n     * @param {any} x - It describes about the X\n     * @param {any} y - It describes about the Y\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.textSelect = function (target, x, y) {\n        if (this.isLeftDropletClicked) {\n            var leftElement = this.dropDivAnnotationRight.getBoundingClientRect();\n            var rightElement = this.dropDivAnnotationLeft.getBoundingClientRect();\n            var clientX = x;\n            var clientY = y;\n            if (target.classList.contains('e-pv-text')) {\n                if ((rightElement.top - 25) > leftElement.top) {\n                    this.pdfViewer.textSelectionModule.textSelectionOnDrag(target, clientX, clientY, true);\n                }\n                else {\n                    this.pdfViewer.textSelectionModule.textSelectionOnDrag(target, clientX, clientY, false);\n                }\n                this.updateLeftposition(clientX, clientY);\n            }\n        }\n        else if (this.isRightDropletClicked) {\n            var leftElement = this.dropDivAnnotationLeft.getBoundingClientRect();\n            var clientX = x;\n            var clientY = y;\n            if (target.classList.contains('e-pv-text')) {\n                if ((clientY) >= leftElement.top) {\n                    this.pdfViewer.textSelectionModule.textSelectionOnDrag(target, clientX, clientY, true);\n                }\n                else {\n                    this.pdfViewer.textSelectionModule.textSelectionOnDrag(target, clientX, clientY, false);\n                }\n                this.updatePosition(clientX, clientY);\n            }\n        }\n    };\n    /**\n     * @param {boolean} hide - It describes about the hide\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.showHideDropletDiv = function (hide) {\n        var type = this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAddMode;\n        var isEnableResizer = this.isEnableTextMarkupResizer(type);\n        if (isEnableResizer && this.dropDivAnnotationLeft && this.dropDivAnnotationRight) {\n            if (hide) {\n                this.dropDivAnnotationLeft.style.display = 'none';\n                this.dropDivAnnotationRight.style.display = 'none';\n            }\n            else {\n                this.dropDivAnnotationLeft.style.display = '';\n                this.dropDivAnnotationRight.style.display = '';\n                this.updateDropletStyles(type);\n            }\n        }\n    };\n    /**\n     * @param {string} type - It describes about the type\n     * @private\n     * @returns {boolean} - boolean\n     */\n    TextMarkupAnnotation.prototype.isEnableTextMarkupResizer = function (type) {\n        var isEnableResizer = false;\n        if (type) {\n            if (type === 'Highlight' && this.pdfViewer.highlightSettings.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n            else if (type === 'Underline' && this.pdfViewer.underlineSettings.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n            else if (type === 'Strikethrough' && this.pdfViewer.strikethroughSettings.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n            else if (this.pdfViewer.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n        }\n        else {\n            if (this.pdfViewer.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n            else if (this.pdfViewer.highlightSettings.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n            else if (this.pdfViewer.underlineSettings.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n            else if (this.pdfViewer.strikethroughSettings.enableTextMarkupResizer) {\n                isEnableResizer = true;\n            }\n        }\n        return isEnableResizer;\n    };\n    TextMarkupAnnotation.prototype.updateDropletStyles = function (type) {\n        if (this.isEnableTextMarkupResizer(type) && this.dropDivAnnotationLeft && this.dropDivAnnotationLeft.offsetWidth > 0) {\n            this.dropDivAnnotationLeft.style.width = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropDivAnnotationRight.style.width = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropElementLeft.style.width = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropElementRight.style.width = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropDivAnnotationLeft.style.height = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropDivAnnotationRight.style.height = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropElementLeft.style.height = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropElementRight.style.height = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropElementLeft.style.top = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n            this.dropElementRight.style.top = this.dropletHeight * this.pdfViewerBase.getZoomFactor() + 'px';\n        }\n    };\n    TextMarkupAnnotation.prototype.updateAnnotationBounds = function () {\n        this.isSelectionMaintained = false;\n        var annotation = this.currentTextMarkupAnnotation;\n        if (annotation && annotation.isMultiSelect) {\n            this.showHideDropletDiv(true);\n            this.updateMultiAnnotBounds(annotation);\n        }\n        else if (annotation && annotation.bounds) {\n            this.retreieveSelection(annotation, null);\n            this.pdfViewer.textSelectionModule.maintainSelection(this.selectTextMarkupCurrentPage, false);\n            this.isSelectionMaintained = true;\n            window.getSelection().removeAllRanges();\n        }\n    };\n    TextMarkupAnnotation.prototype.updateMultiAnnotBounds = function (annotation) {\n        if (!annotation.annotpageNumbers) {\n            var annotationList = this.getAnnotations(annotation.pageNumber, null);\n            if (annotationList) {\n                for (var z = 0; z < annotationList.length; z++) {\n                    if (annotationList[parseInt(z.toString(), 10)].annotName === annotation.annotName) {\n                        annotation = annotationList[parseInt(z.toString(), 10)];\n                        break;\n                    }\n                }\n            }\n        }\n        var lowestNumber = annotation.annotpageNumbers[0];\n        var highestNumber = annotation.annotpageNumbers[0];\n        for (var p = 0; p < annotation.annotpageNumbers.length; p++) {\n            var currentPage = annotation.annotpageNumbers[parseInt(p.toString(), 10)];\n            if (currentPage >= highestNumber) {\n                highestNumber = currentPage;\n            }\n            if (currentPage <= lowestNumber) {\n                lowestNumber = currentPage;\n            }\n        }\n        for (var k = lowestNumber; k <= highestNumber; k++) {\n            var annotationList = this.getAnnotations(k, null);\n            if (annotationList) {\n                for (var j = 0; j < annotation.annotNameCollection.length; j++) {\n                    var currentAnnot = annotation.annotNameCollection[parseInt(j.toString(), 10)];\n                    for (var z = 0; z < annotationList.length; z++) {\n                        if (annotationList[parseInt(z.toString(), 10)].annotName === currentAnnot) {\n                            var newAnnotation = annotationList[parseInt(z.toString(), 10)];\n                            this.retreieveSelection(newAnnotation, null);\n                            this.pdfViewer.textSelectionModule.maintainSelection(newAnnotation.pageNumber, false);\n                        }\n                    }\n                }\n            }\n        }\n        this.isSelectionMaintained = true;\n        window.getSelection().removeAllRanges();\n    };\n    TextMarkupAnnotation.prototype.retreieveSelection = function (annotation, element) {\n        for (var k = 0; k < annotation.bounds.length; k++) {\n            var bound = annotation.bounds[parseInt(k.toString(), 10)];\n            var x = (bound.left ? bound.left : bound.Left) * this.pdfViewerBase.getZoomFactor();\n            var y = (bound.top ? bound.top : bound.Top) * this.pdfViewerBase.getZoomFactor();\n            var width = (bound.width ? bound.width : bound.Width) * this.pdfViewerBase.getZoomFactor();\n            var textLayer = this.pdfViewerBase.getElement('_textLayer_' + annotation.pageNumber);\n            if (textLayer) {\n                var textDivs = textLayer.childNodes;\n                for (var n = 0; n < textDivs.length; n++) {\n                    if (textDivs[parseInt(n.toString(), 10)]) {\n                        var rangebounds = textDivs[parseInt(n.toString(), 10)].getBoundingClientRect();\n                        var top_1 = this.getClientValueTop(rangebounds.top, annotation.pageNumber);\n                        var currentLeft = rangebounds.left - this.pdfViewerBase.getElement('_pageDiv_' + annotation.pageNumber).getBoundingClientRect().left;\n                        var totalLeft = currentLeft + rangebounds.width;\n                        var textDiVLeft = parseInt(textDivs[parseInt(n.toString(), 10)].style.left, 10);\n                        var currentTop = parseInt(textDivs[parseInt(n.toString(), 10)].style.top, 10);\n                        var isLeftBounds = this.pdfViewer.textSelectionModule.\n                            checkLeftBounds(currentLeft, textDiVLeft, totalLeft, x);\n                        var isTopBounds = this.pdfViewer.textSelectionModule.checkTopBounds(top_1, currentTop, y);\n                        if (isLeftBounds && isTopBounds) {\n                            element = textDivs[parseInt(n.toString(), 10)];\n                            break;\n                        }\n                    }\n                }\n                if (element != null) {\n                    var boundingRect = this.pdfViewerBase.getElement('_textLayer_' + annotation.pageNumber).getBoundingClientRect();\n                    this.pdfViewer.textSelectionModule.textSelectionOnMouseMove(element, x + boundingRect.left, y + boundingRect.top, false);\n                    if ((annotation.bounds.length - 1) === k) {\n                        this.pdfViewer.textSelectionModule.textSelectionOnMouseMove(element, x + boundingRect.left + width, y + boundingRect.top, false);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {number} x - It describes about the X\n     * @param {number} y - It describes about the Y\n     * @param {boolean} isSelected - It describes about the isSelected\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.updatePosition = function (x, y, isSelected) {\n        this.showHideDropletDiv(false);\n        var pageTopValue = this.pdfViewerBase.pageSize[this.pdfViewerBase.currentPageNumber - 1].top;\n        var topClientValue = this.getClientValueTop(y, this.pdfViewerBase.currentPageNumber - 1);\n        var rightDivElement = document.getElementById(this.pdfViewer.element.id + '_droplet_right');\n        if (isSelected) {\n            rightDivElement.style.top = topClientValue * this.pdfViewerBase.getZoomFactor() + pageTopValue * this.pdfViewerBase.getZoomFactor() + 'px';\n        }\n        else {\n            rightDivElement.style.top = topClientValue + pageTopValue * this.pdfViewerBase.getZoomFactor() + 'px';\n        }\n        rightDivElement.style.left = x + this.pdfViewerBase.viewerContainer.scrollLeft - this.pdfViewerBase.viewerContainer.getBoundingClientRect().left + 'px';\n    };\n    /**\n     * @param {number} x - It describes about the X\n     * @param {number} y - It describes about the Y\n     * @param {boolean} isSelected - It describes about the isSelected\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.updateLeftposition = function (x, y, isSelected) {\n        this.showHideDropletDiv(false);\n        var pageTopValue = this.pdfViewerBase.pageSize[this.pdfViewerBase.currentPageNumber - 1].top;\n        var topClientValue = this.getClientValueTop(y, this.pdfViewerBase.currentPageNumber - 1);\n        var leftDivElement = document.getElementById(this.pdfViewer.element.id + '_droplet_left');\n        leftDivElement.style.display = '';\n        if (isSelected) {\n            leftDivElement.style.top = topClientValue * this.pdfViewerBase.getZoomFactor() + pageTopValue * this.pdfViewerBase.getZoomFactor() + 'px';\n        }\n        else {\n            leftDivElement.style.top = topClientValue + pageTopValue * this.pdfViewerBase.getZoomFactor() + 'px';\n        }\n        leftDivElement.style.left = x + this.pdfViewerBase.viewerContainer.scrollLeft - this.pdfViewerBase.viewerContainer.getBoundingClientRect().left - (this.dropletHeight * this.pdfViewerBase.getZoomFactor()) + 'px';\n    };\n    TextMarkupAnnotation.prototype.getClientValueTop = function (clientValue, pageNumber) {\n        if (this.pdfViewerBase.getElement('_pageDiv_' + pageNumber)) {\n            return clientValue - this.pdfViewerBase.getElement('_pageDiv_' + pageNumber).getBoundingClientRect().top;\n        }\n        else {\n            return clientValue;\n        }\n    };\n    /**\n     * @param {any} textMarkupAnnotations - It describes about the text markup annotations\n     * @param {number} pageNumber - It describes about the page number\n     * @param {boolean} isImportTextMarkup - It describes about the isImportTextMarkup\n     * @param {boolean} isAnnotOrderAction - It describes about the isAnnotOrderAction\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.renderTextMarkupAnnotationsInPage = function (textMarkupAnnotations, pageNumber, isImportTextMarkup, isAnnotOrderAction) {\n        var canvasId = textMarkupAnnotations && textMarkupAnnotations.textMarkupAnnotationType === 'Highlight' ? '_blendAnnotationsIntoCanvas_' : '_annotationCanvas_';\n        var canvas = (canvasId === '_blendAnnotationsIntoCanvas_') ? this.pdfViewerBase.getElement(canvasId + pageNumber) :\n            this.pdfViewerBase.getAnnotationCanvas(canvasId, pageNumber);\n        if (isImportTextMarkup) {\n            this.renderTextMarkupAnnotations(null, pageNumber, canvas, this.pdfViewerBase.getZoomFactor());\n            this.renderTextMarkupAnnotations(textMarkupAnnotations, pageNumber, canvas, this.pdfViewerBase.getZoomFactor(), true);\n        }\n        else {\n            this.renderTextMarkupAnnotations(textMarkupAnnotations, pageNumber, canvas, this.pdfViewerBase.getZoomFactor(), null, isAnnotOrderAction);\n        }\n    };\n    TextMarkupAnnotation.prototype.renderTextMarkupAnnotations = function (textMarkupAnnotations, pageNumber, canvas, factor, isImportAction, isAnnotOrderAction) {\n        var highlightCanvasContext = null;\n        if (canvas) {\n            var context = canvas.getContext('2d');\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            context.setLineDash([]);\n            var annotations_1;\n            if (!isImportAction && !isAnnotOrderAction) {\n                annotations_1 = this.getAnnotations(pageNumber, textMarkupAnnotations);\n            }\n            else {\n                annotations_1 = textMarkupAnnotations;\n            }\n            if (textMarkupAnnotations) {\n                textMarkupAnnotations.forEach(function (textMarkupAnnotation) {\n                    var exists = annotations_1.some(function (existingAnnotation) {\n                        return existingAnnotation.annotName === textMarkupAnnotation.AnnotName;\n                    });\n                    if (!exists) {\n                        annotations_1.push(textMarkupAnnotation);\n                    }\n                });\n            }\n            if (annotations_1) {\n                var distinctAnnotations = [];\n                for (var i = 0; i < annotations_1.length; i++) {\n                    var duplicateFound = false;\n                    for (var j = 0; j < distinctAnnotations.length; j++) {\n                        if (annotations_1[parseInt(i.toString(), 10)].AnnotName ===\n                            distinctAnnotations[parseInt(j.toString(), 10)].AnnotName &&\n                            annotations_1[parseInt(i.toString(), 10)].annotName === distinctAnnotations[parseInt(j.toString(), 10)].annotName) {\n                            duplicateFound = true;\n                            break;\n                        }\n                    }\n                    if (!duplicateFound) {\n                        distinctAnnotations.push(annotations_1[parseInt(i.toString(), 10)]);\n                    }\n                }\n                annotations_1 = distinctAnnotations;\n            }\n            if (annotations_1) {\n                for (var i = 0; i < annotations_1.length; i++) {\n                    var annotation = annotations_1[parseInt(i.toString(), 10)];\n                    var annotationObject = null;\n                    var isAnnotationRotated = void 0;\n                    if (annotation.TextMarkupAnnotationType) {\n                        if (isImportAction) {\n                            if (this.pdfViewerBase.isJsonImported) {\n                                var newArray = [];\n                                for (var i_1 = 0; i_1 < annotation.Bounds.length; i_1++) {\n                                    annotation.Bounds[parseInt(i_1.toString(), 10)] = this.pdfViewerBase.\n                                        importJsonForRotatedDocuments(annotation.Rotate, pageNumber, annotation.Bounds[parseInt(i_1.toString(), 10)], annotation.AnnotationRotation);\n                                    annotation.Bounds[parseInt(i_1.toString(), 10)].left = annotation.Bounds[parseInt(i_1.toString(), 10)].X;\n                                    annotation.Bounds[parseInt(i_1.toString(), 10)].top = annotation.Bounds[parseInt(i_1.toString(), 10)].Y;\n                                    newArray.push(annotation.Bounds[parseInt(i_1.toString(), 10)]);\n                                }\n                                annotation.Bounds = newArray;\n                                isAnnotationRotated = this.pdfViewerBase.isPageRotated;\n                            }\n                        }\n                        annotation.annotationAddMode = this.pdfViewer.annotationModule.\n                            findAnnotationMode(annotation, pageNumber, annotation.AnnotType);\n                        annotation.allowedInteractions = annotation.AllowedInteractions ? annotation.AllowedInteractions :\n                            this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n                        annotation.AnnotationSettings = annotation.AnnotationSettings ? annotation.AnnotationSettings :\n                            this.pdfViewer.annotationModule.updateAnnotationSettings(annotation);\n                        if (annotation.IsLocked) {\n                            annotation.AnnotationSettings.isLock = annotation.IsLocked;\n                        }\n                        annotationObject = {\n                            textMarkupAnnotationType: annotation.TextMarkupAnnotationType, color: annotation.Color,\n                            allowedInteractions: annotation.allowedInteractions, opacity: annotation.Opacity,\n                            bounds: annotation.Bounds, author: annotation.Author, subject: annotation.Subject,\n                            modifiedDate: annotation.ModifiedDate, note: annotation.Note, rect: annotation.Rect,\n                            annotName: annotation.AnnotName, comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author), review: { state: annotation.State, stateModel: annotation.StateModel, modifiedDate: annotation.ModifiedDate, author: annotation.Author }, shapeAnnotationType: 'textMarkup', pageNumber: pageNumber,\n                            textMarkupContent: annotation.TextMarkupContent, textMarkupStartIndex: 0, textMarkupEndIndex: 0,\n                            annotationSelectorSettings: this.getSettings(annotation),\n                            customData: this.pdfViewer.annotation.getCustomData(annotation), annotationAddMode: annotation.annotationAddMode, annotationSettings: annotation.AnnotationSettings,\n                            isLocked: annotation.IsLocked, isPrint: annotation.IsPrint, isCommentLock: annotation.IsCommentLock,\n                            isAnnotationRotated: isAnnotationRotated, annotationRotation: annotation.AnnotationRotation\n                        };\n                        if (annotation.IsMultiSelect) {\n                            annotationObject.annotNameCollection = annotation.AnnotNameCollection;\n                            annotationObject.annotpageNumbers = annotation.AnnotpageNumbers;\n                            annotationObject.isMultiSelect = annotation.IsMultiSelect;\n                        }\n                        if (annotation.textMarkupContent && annotation.textMarkupContent !== '') {\n                            annotationObject.textMarkupContent = annotation.textMarkupContent;\n                            annotationObject.textMarkupStartIndex = annotation.textMarkupStartIndex;\n                            annotationObject.textMarkupEndIndex = annotation.textMarkupEndIndex;\n                        }\n                        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.TextMarkupContent) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.textMarkupContent)) {\n                            var markedBounds = annotation.Bounds;\n                            var storedData = this.pdfViewerBase.getStoredData(pageNumber, true);\n                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(storedData)) {\n                                this.pdfViewerBase.requestForTextExtraction(pageNumber, annotationObject);\n                            }\n                            else {\n                                var pageCharText = storedData.pageText.split('');\n                                var characterBounds = this.pdfViewerBase.textLayer.\n                                    characterBound[parseInt(pageNumber.toString(), 10)];\n                                var textMarkupContent = this.pdfViewerBase.\n                                    textMarkUpContent(markedBounds, pageCharText, characterBounds);\n                                annotationObject.textMarkupContent = textMarkupContent;\n                            }\n                        }\n                        this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotationObject, '_annotations_textMarkup');\n                        if (this.isAddAnnotationProgramatically) {\n                            var settings = {\n                                opacity: annotationObject.opacity, author: annotation.author, subject: annotation.subject,\n                                modifiedDate: annotation.modifiedDate,\n                                width: annotationObject.bounds.width, height: annotationObject.bounds.height\n                            };\n                            this.pdfViewer.fireAnnotationAdd(annotationObject.pageNumber, annotationObject.annotName, annotation.TextMarkupAnnotationType, annotationObject.bounds, settings);\n                        }\n                    }\n                    var type = annotation.TextMarkupAnnotationType ? annotation.TextMarkupAnnotationType :\n                        annotation.textMarkupAnnotationType;\n                    var annotBounds = annotation.Bounds ? annotation.Bounds : annotation.bounds;\n                    var opacity = annotation.Opacity ? annotation.Opacity : annotation.opacity;\n                    var color = annotation.Color ? annotation.Color : annotation.color;\n                    var annotationRotation = annotation.AnnotationRotation ? annotation.AnnotationRotation :\n                        annotation.annotationRotation;\n                    var isPrint = true;\n                    if (annotation.TextMarkupAnnotationType) {\n                        isPrint = annotation.IsPrint;\n                    }\n                    if (annotation.textMarkupAnnotationType) {\n                        isPrint = annotation.isPrint;\n                    }\n                    if (type === 'Highlight' && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(highlightCanvasContext)) {\n                        highlightCanvasContext = this.getHighlightCanvasContext(this.isPrintCanvas(canvas), pageNumber);\n                    }\n                    switch (type) {\n                        case 'Highlight':\n                            this.renderHighlightAnnotation(annotBounds, opacity, color, highlightCanvasContext.context, factor, isPrint, pageNumber);\n                            break;\n                        case 'Strikethrough':\n                            this.renderStrikeoutAnnotation(annotBounds, opacity, color, context, factor, pageNumber, isPrint, annotationRotation, annotation.textMarkupContent);\n                            break;\n                        case 'Underline':\n                            this.renderUnderlineAnnotation(annotBounds, opacity, color, context, factor, pageNumber, isPrint, annotationRotation);\n                            break;\n                    }\n                }\n            }\n            var isMaintainedSelector = false;\n            if (this.currentTextMarkupAnnotation && this.currentTextMarkupAnnotation.annotpageNumbers) {\n                for (var m = 0; m < this.currentTextMarkupAnnotation.annotpageNumbers.length; m++) {\n                    if (pageNumber === this.currentTextMarkupAnnotation.annotpageNumbers[parseInt(m.toString(), 10)]) {\n                        isMaintainedSelector = true;\n                        this.isAnnotationSelect = false;\n                        break;\n                    }\n                }\n            }\n            if ((pageNumber === this.selectTextMarkupCurrentPage) || isMaintainedSelector) {\n                if (!this.isAnnotationSelect) {\n                    this.maintainAnnotationSelection();\n                }\n                else {\n                    this.isAnnotationSelect = false;\n                }\n            }\n            var annotImg = canvas.toDataURL();\n            var highlightImg = void 0;\n            if (highlightCanvasContext) {\n                highlightImg = highlightCanvasContext.canvas.toDataURL();\n            }\n            return { annotImg: annotImg, highlightImg: highlightImg };\n        }\n    };\n    TextMarkupAnnotation.prototype.getHighlightCanvasContext = function (isPrintCanvas, pageNumber) {\n        var canvas;\n        if (!isPrintCanvas) {\n            canvas = this.pdfViewerBase.getElement('_blendAnnotationsIntoCanvas_' + pageNumber);\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(canvas)) {\n                var pageDiv = document.getElementById(this.pdfViewer.element.id + '_pageDiv_' + pageNumber);\n                canvas = this.pdfViewer.annotationModule.createBlendAnnotationsIntoCanvas(pageDiv, parseFloat(pageDiv.style.width), parseFloat(pageDiv.style.height), pageNumber);\n            }\n        }\n        else {\n            canvas = this.pdfViewerBase.getElement(this.pdfViewer.element.id + '_print_blendAnnotations_canvas_' + pageNumber);\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(canvas)) {\n                canvas = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('canvas', { id: this.pdfViewer.element.id + '_print_blendAnnotations_canvas_' + pageNumber });\n                canvas.style.width = 816 + 'px';\n                canvas.style.height = 1056 + 'px';\n                var pageWidth = this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].width;\n                var pageHeight = this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].height;\n                var zoom = void 0;\n                if (isPrintCanvas) {\n                    zoom = 1;\n                }\n                else {\n                    zoom = this.pdfViewerBase.getZoomFactor();\n                }\n                var zoomRatio = this.pdfViewerBase.getZoomRatio(zoom);\n                canvas.height = pageHeight * zoomRatio;\n                canvas.width = pageWidth * zoomRatio;\n            }\n        }\n        var context = canvas.getContext('2d');\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.setLineDash([]);\n        return { context: context, canvas: canvas };\n    };\n    TextMarkupAnnotation.prototype.isPrintCanvas = function (canvas) {\n        return canvas && canvas.id.indexOf('_print_annotation_layer_') !== -1 ? true : false;\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @private\n     * @returns {any} - any\n     */\n    TextMarkupAnnotation.prototype.getSettings = function (annotation) {\n        var selector;\n        if (annotation.AnnotationSelectorSettings) {\n            selector = typeof (annotation.AnnotationSelectorSettings) === 'string' ? JSON.parse(annotation.AnnotationSelectorSettings) : annotation.AnnotationSelectorSettings;\n        }\n        else {\n            selector = this.getSelector(annotation.TextMarkupAnnotationType);\n        }\n        return selector;\n    };\n    /**\n     * @param {string} type - It describes about the type\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.drawTextMarkupAnnotations = function (type) {\n        var isDrawn = false;\n        this.isTextMarkupAnnotationMode = true;\n        this.pdfViewer.annotationModule.isFormFieldShape = false;\n        this.currentTextMarkupAddMode = type;\n        var isCleared = true;\n        this.multiPageCollection = [];\n        var selectionObject = this.pdfViewer.textSelectionModule ?\n            this.pdfViewer.textSelectionModule.selectionRangeArray : [];\n        if (selectionObject.length > 0 && !this.isSelectionMaintained) {\n            isDrawn = true;\n            this.convertSelectionToTextMarkup(type, selectionObject, this.pdfViewerBase.getZoomFactor());\n        }\n        var selection = window.getSelection();\n        var targetElement;\n        if (selection && selection.anchorNode) {\n            targetElement = selection.anchorNode.parentElement;\n        }\n        if (this.isEnableTextMarkupResizer(type) && this.isExtended && window.getSelection().toString()) {\n            var pageBounds = this.getDrawnBounds();\n            if (pageBounds[0] && pageBounds[0].bounds) {\n                var currentAnnot = this.currentTextMarkupAnnotation;\n                for (var k = 0; k < pageBounds.length; k++) {\n                    if (currentAnnot && currentAnnot.pageNumber === pageBounds[parseInt(k.toString(), 10)].pageIndex) {\n                        this.currentTextMarkupAnnotation = currentAnnot;\n                        this.selectTextMarkupCurrentPage = pageBounds[parseInt(k.toString(), 10)].pageIndex;\n                        this.updateTextMarkupAnnotationBounds(pageBounds, k);\n                    }\n                    else {\n                        if (currentAnnot) {\n                            if (type === '') {\n                                type = currentAnnot.textMarkupAnnotationType;\n                            }\n                        }\n                        if (!currentAnnot.isMultiSelect) {\n                            var isMultiSelect = false;\n                            if (this.isMultiAnnotation(type)) {\n                                this.multiPageCollection.push(currentAnnot);\n                                isMultiSelect = true;\n                            }\n                            this.drawTextMarkups(type, pageBounds[parseInt(k.toString(), 10)].bounds, pageBounds[parseInt(k.toString(), 10)].pageIndex, pageBounds[parseInt(k.toString(), 10)].rect, this.pdfViewerBase.getZoomFactor(), pageBounds[parseInt(k.toString(), 10)].textContent, pageBounds[parseInt(k.toString(), 10)].startIndex, pageBounds[parseInt(k.toString(), 10)].endIndex, isMultiSelect, targetElement);\n                        }\n                        else {\n                            if (currentAnnot.isMultiSelect && currentAnnot.annotNameCollection) {\n                                this.modifyCurrentAnnotation(currentAnnot, pageBounds, k);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else if (window.getSelection().toString() && !isDrawn) {\n            var pageBounds = this.getDrawnBounds();\n            var isMultiSelect = this.isMultiPageAnnotations(pageBounds, type);\n            if (pageBounds.length > 0) {\n                for (var i = 0; i < pageBounds.length; i++) {\n                    if (type === '') {\n                        isCleared = false;\n                    }\n                    this.drawTextMarkups(type, pageBounds[parseInt(i.toString(), 10)].bounds, pageBounds[parseInt(i.toString(), 10)].pageIndex, pageBounds[parseInt(i.toString(), 10)].rect, this.pdfViewerBase.getZoomFactor(), pageBounds[parseInt(i.toString(), 10)].textContent, pageBounds[parseInt(i.toString(), 10)].startIndex, pageBounds[parseInt(i.toString(), 10)].endIndex, isMultiSelect, targetElement);\n                }\n            }\n        }\n        if (this.multiPageCollection) {\n            for (var j = 0; j < this.multiPageCollection.length; j++) {\n                this.updateAnnotationNames(this.multiPageCollection[parseInt(j.toString(), 10)], this.multiPageCollection[parseInt(j.toString(), 10)].pageNumber);\n            }\n        }\n        this.isExtended = false;\n        this.isSelectionMaintained = false;\n        // this.pdfViewerBase.annotationHelper.redoCollection = [];\n        if (isCleared && this.pdfViewer.textSelectionModule) {\n            this.pdfViewer.textSelectionModule.clearTextSelection();\n        }\n        if (this.isEnableTextMarkupResizer(type)) {\n            this.updateAnnotationBounds();\n        }\n    };\n    TextMarkupAnnotation.prototype.isMultiPageAnnotations = function (pageBounds, type) {\n        var isMultiSelect = false;\n        for (var n = 0; n < pageBounds.length; n++) {\n            if (pageBounds[parseInt(n.toString(), 10)].pageIndex !== pageBounds[0].pageIndex && this.isMultiAnnotation(type)) {\n                isMultiSelect = true;\n                break;\n            }\n        }\n        return isMultiSelect;\n    };\n    TextMarkupAnnotation.prototype.isMultiAnnotation = function (type) {\n        var isSelection = false;\n        if (type === 'Highlight' && this.pdfViewer.highlightSettings.enableMultiPageAnnotation) {\n            isSelection = true;\n        }\n        else if (type === 'Underline' && this.pdfViewer.underlineSettings.enableMultiPageAnnotation) {\n            isSelection = true;\n        }\n        else if (type === 'Strikethrough' && this.pdfViewer.strikethroughSettings.enableMultiPageAnnotation) {\n            isSelection = true;\n        }\n        else if (this.pdfViewer.enableMultiPageAnnotation) {\n            isSelection = true;\n        }\n        return isSelection;\n    };\n    TextMarkupAnnotation.prototype.modifyCurrentAnnotation = function (currentAnnot, pageBounds, index) {\n        for (var c = 0; c < currentAnnot.annotNameCollection.length; c++) {\n            var currentAnnots = currentAnnot.annotNameCollection[parseInt(c.toString(), 10)];\n            var annotationList = this.getAnnotations(pageBounds[parseInt(index.toString(), 10)].pageIndex, null);\n            if (annotationList) {\n                for (var z = 0; z < annotationList.length; z++) {\n                    if (annotationList[parseInt(z.toString(), 10)].annotName === currentAnnots) {\n                        this.currentTextMarkupAnnotation = annotationList[parseInt(z.toString(), 10)];\n                        this.selectTextMarkupCurrentPage = pageBounds[parseInt(index.toString(), 10)].pageIndex;\n                        this.updateTextMarkupAnnotationBounds(pageBounds, index);\n                        break;\n                    }\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.drawAnnotationSelector = function (newAnnotation, annotation, newcanvas) {\n        var newBounds = [];\n        var x = 0;\n        var y = 0;\n        var width = 0;\n        var height = 0;\n        var currentTop = 0;\n        var nextTop = 0;\n        var currentLeft = 0;\n        var nextLeft = 0;\n        var currentRotation = 0;\n        var nextRotation = 0;\n        for (var i = 0; i < newAnnotation.bounds.length; i++) {\n            currentTop = newAnnotation.bounds[parseInt(i.toString(), 10)].top ?\n                newAnnotation.bounds[parseInt(i.toString(), 10)].top : newAnnotation.bounds[parseInt(i.toString(), 10)].Top;\n            nextTop = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(newAnnotation.bounds[i + 1]) ? newAnnotation.bounds[i + 1].top ?\n                newAnnotation.bounds[i + 1].top : newAnnotation.bounds[i + 1].Top : 0;\n            var rotation180Exists = void 0;\n            if (this.pdfViewerBase.clientSideRendering) {\n                currentLeft = newAnnotation.bounds[parseInt(i.toString(), 10)].left ?\n                    newAnnotation.bounds[parseInt(i.toString(), 10)].left : newAnnotation.bounds[parseInt(i.toString(), 10)].Left;\n                nextLeft = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(newAnnotation.bounds[i + 1]) ? newAnnotation.bounds[i + 1].left ?\n                    newAnnotation.bounds[i + 1].left : newAnnotation.bounds[i + 1].Left : 0;\n                currentRotation = newAnnotation.bounds[parseInt(i.toString(), 10)].rotation;\n                nextRotation = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(newAnnotation.bounds[i + 1]) ? newAnnotation.bounds[i + 1].rotation : 0;\n                rotation180Exists = (currentRotation === 0) || (currentRotation === 180);\n            }\n            if (newAnnotation.bounds.length > 1 && i < newAnnotation.bounds.length - 1 && currentTop === nextTop) {\n                newBounds.push(newAnnotation.bounds[parseInt(i.toString(), 10)]);\n            }\n            else {\n                if (i === newAnnotation.bounds.length - 1 || newAnnotation.bounds.length >= 1) {\n                    newBounds.push(newAnnotation.bounds[parseInt(i.toString(), 10)]);\n                }\n                if (newBounds.length >= 1) {\n                    x = newBounds[0].left ? newBounds[0].left : newBounds[0].Left;\n                    y = newBounds[0].top ? newBounds[0].top : newBounds[0].Top;\n                    height = newBounds[0].height ? newBounds[0].height : newBounds[0].Height;\n                    for (var j = 0; j < newBounds.length; j++) {\n                        if ((!isNaN(newBounds[parseInt(j.toString(), 10)].width) &&\n                            newBounds[parseInt(j.toString(), 10)].width > 0) || (!isNaN(newBounds[parseInt(j.toString(), 10)].Width) &&\n                            newBounds[parseInt(j.toString(), 10)].Width > 0)) {\n                            width += newBounds[parseInt(j.toString(), 10)].width ?\n                                newBounds[parseInt(j.toString(), 10)].width : newBounds[parseInt(j.toString(), 10)].Width;\n                        }\n                    }\n                    if (!newcanvas) {\n                        var canvasId = newAnnotation.textMarkupAnnotationType === 'Highlight' ? '_blendAnnotationsIntoCanvas_' : '_annotationCanvas_';\n                        newcanvas = (canvasId === '_blendAnnotationsIntoCanvas_') ? this.pdfViewerBase.getElement(canvasId + newAnnotation.pageNumber) :\n                            this.pdfViewerBase.getAnnotationCanvas(canvasId, newAnnotation.pageNumber);\n                    }\n                    this.drawAnnotationSelectRect(newcanvas, this.getMagnifiedValue(x - 0.5, this.pdfViewerBase.getZoomFactor()), this.getMagnifiedValue(y - 0.5, this.pdfViewerBase.getZoomFactor()), this.getMagnifiedValue(width + 0.5, this.pdfViewerBase.getZoomFactor()), this.getMagnifiedValue(height + 0.5, this.pdfViewerBase.getZoomFactor()), annotation);\n                    newBounds = [];\n                    width = 0;\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.selectMultiPageAnnotations = function (annotation) {\n        for (var k = 0; k < annotation.annotNameCollection.length; k++) {\n            var currentAnnot = annotation.annotNameCollection[parseInt(k.toString(), 10)];\n            if (currentAnnot !== annotation.annotName) {\n                for (var p = 0; p < annotation.annotpageNumbers.length; p++) {\n                    var currentPage = annotation.annotpageNumbers[parseInt(p.toString(), 10)];\n                    var annotationList = this.getAnnotations(currentPage, null);\n                    if (annotationList) {\n                        for (var z = 0; z < annotationList.length; z++) {\n                            if (annotationList[parseInt(z.toString(), 10)].annotName === currentAnnot) {\n                                var newAnnotation = annotationList[parseInt(z.toString(), 10)];\n                                this.drawAnnotationSelector(newAnnotation, annotation);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.deletMultiPageAnnotation = function (annotation) {\n        for (var k = 0; k < annotation.annotNameCollection.length; k++) {\n            var currentAnnot = annotation.annotNameCollection[parseInt(k.toString(), 10)];\n            if (currentAnnot !== annotation.annotName) {\n                for (var p = 0; p < annotation.annotpageNumbers.length; p++) {\n                    var currentPage = annotation.annotpageNumbers[parseInt(p.toString(), 10)];\n                    var annotationList = this.getAnnotations(currentPage, null);\n                    if (annotationList) {\n                        for (var z = 0; z < annotationList.length; z++) {\n                            if (annotationList[parseInt(z.toString(), 10)].annotName === currentAnnot) {\n                                var newAnnotation = annotationList[parseInt(z.toString(), 10)];\n                                var deletedAnnotation = null;\n                                deletedAnnotation = annotationList.splice(z, 1)[0];\n                                this.pdfViewer.annotationModule.addAction(currentPage, z, deletedAnnotation, 'Text Markup Deleted', null);\n                                this.currentAnnotationIndex = z;\n                                this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(deletedAnnotation, 'textMarkup');\n                                var removeDiv = document.getElementById(deletedAnnotation.annotName);\n                                if (removeDiv) {\n                                    if (removeDiv.parentElement.childElementCount === 1) {\n                                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.updateAccordionContainer(removeDiv);\n                                    }\n                                    else {\n                                        removeDiv.remove();\n                                    }\n                                }\n                                this.pdfViewer.annotationModule.updateAnnotationCollection(newAnnotation);\n                                this.manageAnnotations(annotationList, currentPage);\n                                this.pdfViewer.annotationModule.updateImportAnnotationCollection(newAnnotation, newAnnotation.pageNumber, 'textMarkupAnnotation');\n                                this.pdfViewer.annotationModule.renderAnnotations(currentPage, null, null, null);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.modifyMultiPageAnnotations = function (annotation, property, value) {\n        for (var k = 0; k < annotation.annotNameCollection.length; k++) {\n            var currentAnnot = annotation.annotNameCollection[parseInt(k.toString(), 10)];\n            if (currentAnnot !== annotation.annotName) {\n                for (var p = 0; p < annotation.annotpageNumbers.length; p++) {\n                    var currentPage = annotation.annotpageNumbers[parseInt(p.toString(), 10)];\n                    var annotationList = this.getAnnotations(currentPage, null);\n                    if (annotationList) {\n                        for (var z = 0; z < annotationList.length; z++) {\n                            if (annotationList[parseInt(z.toString(), 10)].annotName === currentAnnot) {\n                                if (property === 'Color') {\n                                    annotationList[parseInt(z.toString(), 10)].color = value;\n                                }\n                                else {\n                                    annotationList[parseInt(z.toString(), 10)].opacity = value;\n                                }\n                                annotationList[parseInt(z.toString(), 10)].modifiedDate =\n                                    this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                                this.currentAnnotationIndex = z;\n                                if (status === null || status === 'changed') {\n                                    this.pdfViewer.annotationModule.addAction(annotationList[parseInt(z.toString(), 10)].pageNumber, z, annotationList[parseInt(z.toString(), 10)], 'Text Markup Property modified', property);\n                                }\n                                this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                                    updateAnnotationModifiedDate(annotationList[parseInt(z.toString(), 10)]);\n                                this.manageAnnotations(annotationList, currentPage);\n                                this.pdfViewer.annotationModule.renderAnnotations(currentPage, null, null, null);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.convertSelectionToTextMarkup = function (type, selectionObject, factor) {\n        var isMultiSelect = false;\n        this.triggerAddEvent = false;\n        this.multiPageCollection = [];\n        for (var i = 0; i < selectionObject.length; i++) {\n            var textValue = selectionObject[parseInt(i.toString(), 10)].textContent;\n            var indexes = void 0;\n            if (selectionObject[parseInt(i.toString(), 10)].startNode === selectionObject[parseInt(i.toString(), 10)].endNode) {\n                var parentText = document.getElementById(selectionObject[parseInt(i.toString(), 10)].startNode).textContent;\n                indexes = this.getIndexNumbers(selectionObject[parseInt(i.toString(), 10)].pageNumber, textValue, parentText);\n            }\n            else {\n                indexes = this.getIndexNumbers(selectionObject[parseInt(i.toString(), 10)].pageNumber, textValue);\n            }\n            if (!isMultiSelect) {\n                for (var n = 1; n < selectionObject.length; n++) {\n                    if (selectionObject[parseInt(n.toString(), 10)].pageNumber !== selectionObject[0].pageNumber &&\n                        this.isMultiAnnotation(type)) {\n                        isMultiSelect = true;\n                        break;\n                    }\n                }\n            }\n            if (this.isMultiAnnotation(type) && (selectionObject.length - 1) === i) {\n                this.triggerAddEvent = true;\n            }\n            this.drawTextMarkups(type, selectionObject[parseInt(i.toString(), 10)].rectangleBounds, selectionObject[parseInt(i.toString(), 10)].pageNumber, selectionObject[parseInt(i.toString(), 10)].bound, factor, textValue, indexes.startIndex, indexes.endIndex, isMultiSelect, document.getElementById(selectionObject[parseInt(i.toString(), 10)].startNode));\n        }\n    };\n    TextMarkupAnnotation.prototype.updateTextMarkupAnnotationBounds = function (pageBounds, currentIndex) {\n        if (this.currentTextMarkupAnnotation) {\n            var pageAnnotations = this.getAnnotations(pageBounds[parseInt(currentIndex.toString(), 10)].pageIndex, null);\n            var annotation = null;\n            if (pageAnnotations) {\n                for (var i = 0; i < pageAnnotations.length; i++) {\n                    if (JSON.stringify(this.currentTextMarkupAnnotation) === JSON.stringify(pageAnnotations[parseInt(i.toString(), 10)])) {\n                        pageAnnotations[parseInt(i.toString(), 10)].bounds = pageBounds[parseInt(currentIndex.toString(), 10)].bounds;\n                        pageAnnotations[parseInt(i.toString(), 10)].textMarkupContent =\n                            pageBounds[parseInt(currentIndex.toString(), 10)].textContent;\n                        pageAnnotations[parseInt(i.toString(), 10)].textMarkupStartIndex =\n                            pageBounds[parseInt(currentIndex.toString(), 10)].startIndex;\n                        pageAnnotations[parseInt(i.toString(), 10)].textMarkupEndIndex =\n                            pageBounds[parseInt(currentIndex.toString(), 10)].endIndex;\n                        pageAnnotations[parseInt(i.toString(), 10)].modifiedDate =\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                        annotation = pageAnnotations[parseInt(i.toString(), 10)];\n                    }\n                }\n                this.manageAnnotations(pageAnnotations, pageBounds[parseInt(currentIndex.toString(), 10)].pageIndex);\n                this.currentTextMarkupAnnotation = null;\n                this.pdfViewer.annotationModule.renderAnnotations(pageBounds[parseInt(currentIndex.toString(), 10)].pageIndex, null, null, null);\n                this.pdfViewerBase.updateDocumentEditedProperty(true);\n                if (annotation) {\n                    var settings = { opacity: annotation.opacity, color: annotation.color, author: annotation.author,\n                        subject: annotation.subject, modifiedDate: annotation.modifiedDate };\n                    var multiPageCollection = this.multiPageCollectionList(annotation);\n                    if (multiPageCollection.length > 0) {\n                        if ((pageBounds.length - 1) === currentIndex) {\n                            this.pdfViewer.fireAnnotationResize(pageBounds[parseInt(currentIndex.toString(), 10)].pageIndex, annotation.annotName, annotation.textMarkupAnnotationType, annotation.bounds, settings, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex, null, multiPageCollection);\n                        }\n                    }\n                    else {\n                        this.pdfViewer.fireAnnotationResize(pageBounds[parseInt(currentIndex.toString(), 10)].pageIndex, annotation.annotName, annotation.textMarkupAnnotationType, annotation.bounds, settings, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex, null);\n                    }\n                }\n                this.currentAnnotationIndex = null;\n                this.selectTextMarkupCurrentPage = null;\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @private\n     * @returns {any} - any\n     */\n    TextMarkupAnnotation.prototype.multiPageCollectionList = function (annotation) {\n        var multiPageCollectionList = [];\n        if (annotation.isMultiSelect && annotation.annotNameCollection) {\n            multiPageCollectionList.push(annotation);\n            for (var k = 0; k < annotation.annotNameCollection.length; k++) {\n                var currentAnnot = annotation.annotNameCollection[parseInt(k.toString(), 10)];\n                if (currentAnnot !== annotation.annotName) {\n                    for (var p = 0; p < annotation.annotpageNumbers.length; p++) {\n                        var currentPage = annotation.annotpageNumbers[parseInt(p.toString(), 10)];\n                        var annotationList = this.getAnnotations(currentPage, null);\n                        if (annotationList) {\n                            for (var z = 0; z < annotationList.length; z++) {\n                                if (annotationList[parseInt(z.toString(), 10)].annotName === currentAnnot) {\n                                    multiPageCollectionList.push(annotationList[parseInt(z.toString(), 10)]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return multiPageCollectionList;\n    };\n    TextMarkupAnnotation.prototype.updateAnnotationNames = function (annotations, pageNumber) {\n        if (annotations) {\n            var pageAnnotations = this.getAnnotations(pageNumber, null);\n            var annotation = null;\n            if (pageAnnotations) {\n                for (var i = 0; i < pageAnnotations.length; i++) {\n                    if (annotations.annotName === pageAnnotations[parseInt(i.toString(), 10)].annotName) {\n                        var annotNamesCollections = [];\n                        var annotpageNumbers = [];\n                        for (var p = 0; p < this.multiPageCollection.length; p++) {\n                            annotNamesCollections.push(this.multiPageCollection[parseInt(p.toString(), 10)].annotName);\n                            annotpageNumbers.push(this.multiPageCollection[parseInt(p.toString(), 10)].pageNumber);\n                        }\n                        pageAnnotations[parseInt(i.toString(), 10)].isMultiSelect = true;\n                        pageAnnotations[parseInt(i.toString(), 10)].annotNameCollection = annotNamesCollections;\n                        pageAnnotations[parseInt(i.toString(), 10)].annotpageNumbers = annotpageNumbers;\n                        annotation = pageAnnotations[parseInt(i.toString(), 10)];\n                    }\n                }\n                this.manageAnnotations(pageAnnotations, pageNumber);\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.updateAnnotationContent = function (annotation, pageBound) {\n        if (annotation) {\n            var pageAnnotations = this.getAnnotations(this.selectTextMarkupCurrentPage, null);\n            var annotation_1 = null;\n            if (pageAnnotations) {\n                for (var i = 0; i < pageAnnotations.length; i++) {\n                    if (JSON.stringify(this.currentTextMarkupAnnotation) === JSON.stringify(pageAnnotations[parseInt(i.toString(), 10)])) {\n                        pageAnnotations[parseInt(i.toString(), 10)].textMarkupContent = pageBound.textContent;\n                        pageAnnotations[parseInt(i.toString(), 10)].textMarkupStartIndex = pageBound.startIndex;\n                        pageAnnotations[parseInt(i.toString(), 10)].textMarkupEndIndex = pageBound.endIndex;\n                        annotation_1 = pageAnnotations[parseInt(i.toString(), 10)];\n                    }\n                    this.pdfViewer.annotationModule.storeAnnotationCollections(pageAnnotations[parseInt(i.toString(), 10)], this.selectTextMarkupCurrentPage);\n                }\n                this.manageAnnotations(pageAnnotations, this.selectTextMarkupCurrentPage);\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.drawTextMarkups = function (type, bounds, pageNumber, rect, factor, textContent, startIndex, endIndex, isMultiSelect, targetElement) {\n        var annotation = null;\n        this.isNewAnnotation = false;\n        var author = 'Guest';\n        var subject;\n        var context = (type === 'Highlight') ? this.getPageContext(pageNumber, '_blendAnnotationsIntoCanvas_') : this.getPageContext(pageNumber, '_annotationCanvas_');\n        var modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n        this.highlightColor = this.highlightColor ? this.highlightColor : this.pdfViewer.highlightSettings.color ? this.pdfViewer.highlightSettings.color : '#FFDF56';\n        this.underlineColor = this.underlineColor ? this.underlineColor : this.pdfViewer.underlineSettings.color ? this.pdfViewer.underlineSettings.color : '#00ff00';\n        this.strikethroughColor = this.strikethroughColor ? this.strikethroughColor : this.pdfViewer.strikethroughSettings.color ? this.pdfViewer.strikethroughSettings.color : '#ff0000';\n        this.highlightOpacity = this.highlightOpacity ? this.highlightOpacity : this.pdfViewer.highlightSettings.opacity;\n        this.underlineOpacity = this.underlineOpacity ? this.underlineOpacity : this.pdfViewer.underlineSettings.opacity;\n        this.strikethroughOpacity = this.strikethroughOpacity ? this.strikethroughOpacity : this.pdfViewer.strikethroughSettings.opacity;\n        this.annotationAddMode = 'UI Drawn Annotation';\n        var allowedInteractions;\n        var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)];\n        var annotationRotate = 0;\n        var pageRotation = this.pdfViewerBase.getAngle(pageDetails.rotation);\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(context)) {\n            var pageDiv = document.getElementById(this.pdfViewer.element.id + '_pageDiv_' + pageNumber);\n            // If the 'blendAnnotationsIntoCanvas' is not implemented, it should be created to highlight annotations.\n            var canvas = this.pdfViewer.annotationModule.createBlendAnnotationsIntoCanvas(pageDiv, parseFloat(pageDiv.style.width), parseFloat(pageDiv.style.height), pageNumber);\n            context = canvas.getContext('2d');\n        }\n        if (context) {\n            context.setLineDash([]);\n            switch (type) {\n                case 'Highlight':\n                    this.isNewAnnotation = true;\n                    subject = (this.pdfViewer.highlightSettings.subject !== '' && this.pdfViewer.highlightSettings.subject) ? this.pdfViewer.highlightSettings.subject : this.pdfViewer.annotationSettings.subject ? this.pdfViewer.annotationSettings.subject : 'Highlight';\n                    author = (this.pdfViewer.highlightSettings.author !== 'Guest' && this.pdfViewer.highlightSettings.author) ? this.pdfViewer.highlightSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                    allowedInteractions = this.pdfViewer.highlightSettings.allowedInteractions ? this.pdfViewer.highlightSettings.allowedInteractions : ['None'];\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.highlightOpacity)) {\n                        this.highlightOpacity = 1;\n                    }\n                    annotation = this.getAddedAnnotation(type, this.highlightColor, this.highlightOpacity, bounds, author, subject, modifiedDate, '', false, rect, pageNumber, textContent, startIndex, endIndex, isMultiSelect, allowedInteractions, annotationRotate);\n                    if (annotation) {\n                        this.renderHighlightAnnotation(annotation.bounds, annotation.opacity, annotation.color, context, factor, annotation.isPrint, pageNumber);\n                    }\n                    break;\n                case 'Strikethrough':\n                    this.isNewAnnotation = true;\n                    subject = (this.pdfViewer.strikethroughSettings.subject !== '' && this.pdfViewer.strikethroughSettings.subject) ? this.pdfViewer.strikethroughSettings.subject : this.pdfViewer.annotationSettings.subject ? this.pdfViewer.annotationSettings.subject : 'Strikethrough';\n                    author = (this.pdfViewer.strikethroughSettings.author !== 'Guest' && this.pdfViewer.strikethroughSettings.author) ? this.pdfViewer.strikethroughSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                    allowedInteractions = this.pdfViewer.strikethroughSettings.allowedInteractions ? this.pdfViewer.strikethroughSettings.allowedInteractions : ['None'];\n                    if (targetElement && targetElement.style.transform !== '') {\n                        if (targetElement.style.transform.startsWith('rotate(90deg)')) {\n                            annotationRotate = Math.abs(pageRotation - 90);\n                        }\n                        else if (targetElement.style.transform.startsWith('rotate(180deg)')) {\n                            annotationRotate = Math.abs(pageRotation - 180);\n                        }\n                        else if (targetElement.style.transform.startsWith('rotate(-90deg)')) {\n                            annotationRotate = Math.abs(pageRotation - 270);\n                        }\n                        else {\n                            annotationRotate = pageRotation;\n                        }\n                    }\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.strikethroughOpacity)) {\n                        this.strikethroughOpacity = 1;\n                    }\n                    annotation = this.getAddedAnnotation(type, this.strikethroughColor, this.strikethroughOpacity, bounds, author, subject, modifiedDate, '', false, rect, pageNumber, textContent, startIndex, endIndex, isMultiSelect, allowedInteractions, annotationRotate);\n                    if (annotation) {\n                        this.renderStrikeoutAnnotation(annotation.bounds, annotation.opacity, annotation.color, context, factor, pageNumber, annotation.isPrint, annotation.annotationRotation, annotation.textMarkupContent);\n                    }\n                    break;\n                case 'Underline':\n                    this.isNewAnnotation = true;\n                    subject = (this.pdfViewer.underlineSettings.subject !== '' && this.pdfViewer.underlineSettings.subject) ? this.pdfViewer.underlineSettings.subject : this.pdfViewer.annotationSettings.subject ? this.pdfViewer.annotationSettings.subject : 'Underline';\n                    author = (this.pdfViewer.underlineSettings.author !== 'Guest' && this.pdfViewer.underlineSettings.author) ? this.pdfViewer.underlineSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                    allowedInteractions = this.pdfViewer.underlineSettings.allowedInteractions ? this.pdfViewer.underlineSettings.allowedInteractions : ['None'];\n                    if (targetElement && targetElement.style.transform !== '') {\n                        if (targetElement.style.transform.startsWith('rotate(90deg)')) {\n                            annotationRotate = Math.abs(pageRotation - 90);\n                        }\n                        else if (targetElement.style.transform.startsWith('rotate(180deg)')) {\n                            annotationRotate = Math.abs(pageRotation - 180);\n                        }\n                        else if (targetElement.style.transform.startsWith('rotate(-90deg)')) {\n                            annotationRotate = Math.abs(pageRotation - 270);\n                        }\n                        else {\n                            annotationRotate = pageRotation;\n                        }\n                    }\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.underlineOpacity)) {\n                        this.underlineOpacity = 1;\n                    }\n                    annotation = this.getAddedAnnotation(type, this.underlineColor, this.underlineOpacity, bounds, author, subject, modifiedDate, '', false, rect, pageNumber, textContent, startIndex, endIndex, isMultiSelect, allowedInteractions, annotationRotate);\n                    if (annotation) {\n                        this.renderUnderlineAnnotation(annotation.bounds, annotation.opacity, annotation.color, context, factor, pageNumber, annotation.isPrint, annotation.annotationRotation);\n                    }\n                    break;\n            }\n            this.isNewAnnotation = false;\n            if (annotation) {\n                this.pdfViewerBase.updateDocumentEditedProperty(true);\n                var settings = { opacity: annotation.opacity, color: annotation.color, author: annotation.author,\n                    subject: annotation.subject, modifiedDate: annotation.modifiedDate };\n                if (this.isMultiAnnotation(type)) {\n                    if (this.triggerAddEvent) {\n                        this.pdfViewer.fireAnnotationAdd(pageNumber, annotation.annotName, type, annotation.bounds, settings, textContent, startIndex, endIndex, null, this.multiPageCollection);\n                    }\n                }\n                else {\n                    this.pdfViewer.fireAnnotationAdd(pageNumber, annotation.annotName, type, annotation.bounds, settings, textContent, startIndex, endIndex);\n                }\n            }\n            if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode && this.pdfViewer.enableToolbar &&\n                this.pdfViewer.enableAnnotationToolbar) {\n                this.pdfViewer.toolbarModule.annotationToolbarModule.createPropertyTools(type);\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.retreiveTextIndex = function (annotation) {\n        if (annotation.textMarkupContent === '') {\n            this.retreieveSelection(annotation, null);\n            var pageBounds = this.getDrawnBounds();\n            window.getSelection().removeAllRanges();\n            if (pageBounds[0] && pageBounds[0].bounds) {\n                this.updateAnnotationContent(annotation, pageBounds[0]);\n                annotation.textMarkupContent = pageBounds[0].textContent;\n                annotation.textMarkupStartIndex = pageBounds[0].startIndex;\n                annotation.textMarkupEndIndex = pageBounds[0].endIndex;\n            }\n        }\n        return annotation;\n    };\n    TextMarkupAnnotation.prototype.renderHighlightAnnotation = function (bounds, opacity, color, context, factor, isPrint, pageIndex) {\n        var zoomRatio = this.pdfViewerBase.getZoomRatio(factor);\n        for (var i = 0; i < bounds.length; i++) {\n            var bound = bounds[parseInt(i.toString(), 10)];\n            context.beginPath();\n            var x = bound.X ? bound.X : bound.left;\n            var y = bound.Y ? bound.Y : bound.top;\n            var width = bound.Width ? bound.Width : bound.width;\n            var height = bound.Height ? bound.Height : bound.height;\n            var rotation = bound.Rotation ? bound.Rotation : bound.rotation;\n            x = x ? x : bound.x;\n            y = y ? y : bound.y;\n            // The highlighted position is slightly increased. So Subtract -1 from the height.\n            if (this.pdfViewerBase.clientSideRendering) {\n                if (rotation >= 0) {\n                    rotation = Math.abs(rotation) / 90;\n                }\n                if (rotation === 0 || rotation === 2) {\n                    height = height - 1;\n                }\n                else if (rotation === 1 || rotation === 3) {\n                    width = width - 1;\n                }\n            }\n            else {\n                height = height - 1;\n            }\n            if (context.canvas.id === this.pdfViewer.element.id + '_print_annotation_layer_' + pageIndex ||\n                context.canvas.id === this.pdfViewer.element.id + '_print_blendAnnotations_canvas_' + pageIndex) {\n                if (isPrint) {\n                    context.rect((x * zoomRatio), (y * zoomRatio), (width * zoomRatio), (height * zoomRatio));\n                    context.globalAlpha = opacity;\n                    context.closePath();\n                    context.fillStyle = color;\n                    context.msFillRule = 'nonzero';\n                    context.fill();\n                }\n            }\n            else {\n                context.rect((x * zoomRatio), (y * zoomRatio), (width * zoomRatio), (height * zoomRatio));\n                context.globalAlpha = opacity;\n                context.closePath();\n                context.fillStyle = color;\n                context.msFillRule = 'nonzero';\n                context.fill();\n            }\n        }\n        context.save();\n    };\n    TextMarkupAnnotation.prototype.renderStrikeoutAnnotation = function (bounds, opacity, color, context, factor, pageNumber, isPrint, annotationRotation, textContent) {\n        for (var i = 0; i < bounds.length; i++) {\n            var bound = this.getProperBounds(bounds[parseInt(i.toString(), 10)]);\n            var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)];\n            var factorRatio = this.pdfViewerBase.getZoomRatio(factor);\n            var rotation = pageDetails.rotation;\n            if (annotationRotation || (this.pdfViewerBase.clientSideRendering && bounds[parseInt(i.toString(), 10)].rotation)) {\n                var pageRotation = this.pdfViewerBase.getAngle(rotation);\n                rotation = this.pdfViewerBase.clientSideRendering ? Math.abs(bounds[parseInt(i.toString(), 10)].rotation) / 90 :\n                    Math.abs(annotationRotation - pageRotation) / 90;\n            }\n            if (context.canvas.id === this.pdfViewer.element.id + '_print_annotation_layer_' + pageNumber) {\n                if (isPrint) {\n                    if (rotation === 1) {\n                        this.drawLine(opacity, (bound.x + (bound.width / 2)), bound.y, bound.width, bound.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ?\n                            bounds[parseInt(i.toString(), 10)].rotation : annotationRotation, textContent);\n                    }\n                    else if (rotation === 2) {\n                        this.drawLine(opacity, bound.x, (bound.y + (bound.height / 2)), bound.width, bound.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ?\n                            bounds[parseInt(i.toString(), 10)].rotation : annotationRotation, textContent);\n                    }\n                    else if (rotation === 3) {\n                        this.drawLine(opacity, bound.x, bound.y, (bound.width / 2), bound.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ? bounds[parseInt(i.toString(), 10)].rotation :\n                            annotationRotation, textContent);\n                    }\n                    else {\n                        this.drawLine(opacity, bound.x, bound.y, bound.width, (bound.height / 2), color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ? bounds[parseInt(i.toString(), 10)].rotation :\n                            annotationRotation, textContent);\n                    }\n                }\n            }\n            else {\n                if (rotation === 1) {\n                    this.drawLine(opacity, (bound.x + (bound.width / 2)), bound.y, bound.width, bound.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ?\n                        bounds[parseInt(i.toString(), 10)].rotation :\n                        annotationRotation, textContent);\n                }\n                else if (rotation === 2) {\n                    this.drawLine(opacity, bound.x, (bound.y + (bound.height / 2)), bound.width, bound.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ?\n                        bounds[parseInt(i.toString(), 10)].rotation :\n                        annotationRotation, textContent);\n                }\n                else if (rotation === 3) {\n                    this.drawLine(opacity, bound.x, bound.y, (bound.width / 2), bound.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ? bounds[parseInt(i.toString(), 10)].rotation :\n                        annotationRotation, textContent);\n                }\n                else {\n                    this.drawLine(opacity, bound.x, bound.y, bound.width, (bound.height / 2), color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ? bounds[parseInt(i.toString(), 10)].rotation :\n                        annotationRotation, textContent);\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.renderUnderlineAnnotation = function (bounds, opacity, color, context, factor, pageNumber, isPrint, annotationRotation) {\n        for (var i = 0; i < bounds.length; i++) {\n            var boundValues = this.getProperBounds(bounds[parseInt(i.toString(), 10)]);\n            var factorRatio = this.pdfViewerBase.getZoomRatio(factor);\n            if (context.canvas.id === this.pdfViewer.element.id + '_print_annotation_layer_' + pageNumber) {\n                if (isPrint) {\n                    this.drawLine(opacity, boundValues.x, boundValues.y, boundValues.width, boundValues.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ? bounds[parseInt(i.toString(), 10)].rotation\n                        : annotationRotation);\n                }\n            }\n            else {\n                this.drawLine(opacity, boundValues.x, boundValues.y, boundValues.width, boundValues.height, color, factorRatio, context, pageNumber, this.pdfViewerBase.clientSideRendering ? bounds[parseInt(i.toString(), 10)].rotation :\n                    annotationRotation);\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.getProperBounds = function (bound) {\n        var x = bound.X ? bound.X : bound.left;\n        var y = bound.Y ? bound.Y : bound.top;\n        var width = bound.Width ? bound.Width : bound.width;\n        var height = bound.Height ? bound.Height : bound.height;\n        x = x ? x : bound.x;\n        y = y ? y : bound.y;\n        return { x: x, y: y, width: width, height: height };\n    };\n    TextMarkupAnnotation.prototype.isChineseLanguage = function (textContent) {\n        var chineseRegex = /[\\u4e00-\\u9fff]/;\n        // Check if the text contains Chinese characters\n        var isChinese = chineseRegex.test(textContent);\n        if (isChinese) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    TextMarkupAnnotation.prototype.drawLine = function (opacity, x, y, width, height, color, factor, context, pageNumber, annotationRotation, textContent) {\n        context.globalAlpha = opacity;\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n            y = y - 1;\n        }\n        if (this.isChineseLanguage(textContent)) {\n            height = height - 1.5;\n        }\n        if (!this.pdfViewerBase.clientSideRendering && !this.isChineseLanguage(textContent)) {\n            height = height - 1;\n        }\n        context.beginPath();\n        var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)];\n        var rotation = pageDetails.rotation;\n        if (annotationRotation || (this.pdfViewerBase.clientSideRendering && annotationRotation >= 0)) {\n            var pageRotation = this.pdfViewerBase.getAngle(rotation);\n            rotation = this.pdfViewerBase.clientSideRendering ? Math.abs(annotationRotation) / 90 :\n                Math.abs(annotationRotation - pageRotation) / 90;\n        }\n        if (this.pdfViewerBase.clientSideRendering) {\n            if (rotation === 0 || rotation === 2) {\n                height = height - 1;\n            }\n            else if (rotation === 1 || rotation === 3) {\n                width = width - 1;\n            }\n        }\n        if (rotation === 1) {\n            context.moveTo((x * factor), (y * factor));\n            context.lineTo((x * factor), (y + height) * factor);\n        }\n        else if (rotation === 2) {\n            context.moveTo((x * factor), (y * factor));\n            context.lineTo((width + x) * factor, (y * factor));\n        }\n        else if (rotation === 3) {\n            context.moveTo((width + x) * factor, (y * factor));\n            context.lineTo((width + x) * factor, (y + height) * factor);\n        }\n        else {\n            context.moveTo((x * factor), (y + height) * factor);\n            context.lineTo((width + x) * factor, (y + height) * factor);\n        }\n        context.lineWidth = 1;\n        context.strokeStyle = color;\n        context.closePath();\n        context.msFillRule = 'nonzero';\n        context.stroke();\n    };\n    /**\n     * @param {any} textMarkupAnnotations - It describes about the text markup annotations\n     * @param {number} pageIndex - It describes about the page number\n     * @param {any} stampData - It describes about the stamp data\n     * @param {any} shapeData - It describes about the shape data\n     * @param {any} measureShapeData - It describes about the measure shape data\n     * @param {any} stickyData - It describes about the sticky data\n     * @param {any} freeTextData - It describes about the free text data\n     * @param {any} inkData - It describes about the ink data\n     * @private\n     * @returns {string} - string\n     */\n    TextMarkupAnnotation.prototype.printAnnotationsInCanvas = function (textMarkupAnnotations, pageIndex, stampData, shapeData, measureShapeData, stickyData, freeTextData, inkData) {\n        var canvas = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('canvas', { id: this.pdfViewer.element.id + '_print_annotation_layer_' + pageIndex });\n        canvas.style.width = 816 + 'px';\n        canvas.style.height = 1056 + 'px';\n        var pageWidth = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)].width;\n        var pageHeight = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)].height;\n        var zoom = 1;\n        var zoomRatio = this.pdfViewerBase.getZoomRatio(zoom);\n        canvas.height = pageHeight * zoomRatio;\n        canvas.width = pageWidth * zoomRatio;\n        var shapeAnnotation = this.getAnnotations(pageIndex, null, '_annotations_shape');\n        var measureShapeAnnotation = this.getAnnotations(pageIndex, null, '_annotations_shape_measure');\n        var stampAnnotation = this.getAnnotations(pageIndex, null, '_annotations_stamp');\n        var stickyNoteAnnotation = this.getAnnotations(pageIndex, null, '_annotations_sticky');\n        var inkAnnotation = this.getAnnotations(pageIndex, null, '_annotations_ink');\n        if (inkAnnotation || stampAnnotation || shapeAnnotation || stickyNoteAnnotation || measureShapeAnnotation) {\n            this.pdfViewer.renderDrawing(canvas, pageIndex);\n            this.pdfViewer.annotation.renderAnnotations(pageIndex, null, null, null, canvas, null, null, freeTextData, inkData);\n        }\n        else {\n            this.pdfViewer.annotation.renderAnnotations(pageIndex, shapeData, measureShapeData, null, canvas, null, null, freeTextData, inkData);\n            this.pdfViewer.annotation.stampAnnotationModule.renderStampAnnotations(stampData, pageIndex, canvas);\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.renderStickyNotesAnnotations(stickyData, pageIndex, canvas);\n        }\n        return this.renderTextMarkupAnnotations(null, pageIndex, canvas, zoom);\n    };\n    /**\n     * @private\n     * @returns {string} - string\n     */\n    TextMarkupAnnotation.prototype.saveTextMarkupAnnotations = function () {\n        var storeTextMarkupObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeTextMarkupObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_textMarkup'];\n        }\n        var textMarkupAnnotations = [];\n        for (var j = 0; j < this.pdfViewerBase.pageCount; j++) {\n            textMarkupAnnotations[parseInt(j.toString(), 10)] = [];\n        }\n        if (storeTextMarkupObject && !this.pdfViewer.annotationSettings.skipDownload) {\n            var textMarkupAnnotationCollection = JSON.parse(storeTextMarkupObject);\n            for (var i = 0; i < textMarkupAnnotationCollection.length; i++) {\n                var newArray = [];\n                var pageAnnotationObject = textMarkupAnnotationCollection[parseInt(i.toString(), 10)];\n                if (pageAnnotationObject) {\n                    var _loop_1 = function (z) {\n                        this_1.pdfViewer.annotationModule.updateModifiedDate(pageAnnotationObject.annotations[parseInt(z.toString(), 10)]);\n                        if (this_1.pdfViewerBase.isJsonExported) {\n                            if (pageAnnotationObject.annotations[parseInt(z.toString(), 10)].isAnnotationRotated) {\n                                pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds =\n                                    this_1.getBoundsForSave(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds, i);\n                            }\n                            else {\n                                var pageDetails = this_1.pdfViewerBase.pageSize[pageAnnotationObject.pageIndex];\n                                if (pageDetails) {\n                                    pageAnnotationObject.annotations[parseInt(z.toString(), 10)].annotationRotation = pageDetails.rotation;\n                                }\n                            }\n                        }\n                        if (this_1.isChineseLanguage(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].textMarkupContent)) {\n                            if (pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds.length > 0) {\n                                var heightDifference_1 = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].textMarkupAnnotationType === 'Strikethrough' ? this_1.strikeoutDifference : pageAnnotationObject.annotations[parseInt(z.toString(), 10)].textMarkupAnnotationType === 'Underline' ? this_1.underlineDifference : 0;\n                                pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds.forEach(function (bound) {\n                                    bound.height = bound.height ? bound.height : bound.Height;\n                                    if (bound.height > 0) {\n                                        // Update height value\n                                        bound.height += heightDifference_1;\n                                    }\n                                });\n                            }\n                        }\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds =\n                            JSON.stringify(this_1.getBoundsForSave(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds, pageAnnotationObject.annotations[parseInt(z.toString(), 10)].pageNumber));\n                        var colorString = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].color;\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].color = JSON.stringify(this_1.getRgbCode(colorString));\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].rect =\n                            JSON.stringify(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].rect);\n                    };\n                    var this_1 = this;\n                    for (var z = 0; pageAnnotationObject.annotations.length > z; z++) {\n                        _loop_1(z);\n                    }\n                    newArray = pageAnnotationObject.annotations;\n                }\n                textMarkupAnnotations[pageAnnotationObject.pageIndex] = newArray;\n            }\n        }\n        return JSON.stringify(textMarkupAnnotations);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.deleteTextMarkupAnnotation = function () {\n        if (this.currentTextMarkupAnnotation) {\n            var isLock = false;\n            if (this.currentTextMarkupAnnotation.annotationSettings) {\n                isLock = this.currentTextMarkupAnnotation.annotationSettings.isLock;\n                if (this.pdfViewer.annotationModule.checkAllowedInteractions('Delete', this.currentTextMarkupAnnotation)) {\n                    isLock = false;\n                }\n            }\n            if (!isLock) {\n                var deletedAnnotation = null;\n                this.showHideDropletDiv(true);\n                var annotation = this.currentTextMarkupAnnotation;\n                if (this.currentTextMarkupAnnotation.isMultiSelect && annotation.annotNameCollection) {\n                    this.deletMultiPageAnnotation(annotation);\n                }\n                var pageAnnotations = this.getAnnotations(this.selectTextMarkupCurrentPage, null);\n                if (pageAnnotations) {\n                    for (var i = 0; i < pageAnnotations.length; i++) {\n                        if (this.currentTextMarkupAnnotation.annotName === pageAnnotations[parseInt(i.toString(), 10)].annotName) {\n                            deletedAnnotation = pageAnnotations.splice(i, 1)[0];\n                            this.pdfViewer.annotationModule.addAction(this.selectTextMarkupCurrentPage, i, deletedAnnotation, 'Text Markup Deleted', null);\n                            this.currentAnnotationIndex = i;\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(deletedAnnotation, 'textMarkup');\n                            var removeDiv = document.getElementById(deletedAnnotation.annotName);\n                            if (removeDiv) {\n                                if (removeDiv.parentElement.childElementCount === 1) {\n                                    this.pdfViewer.annotationModule.stickyNotesAnnotationModule.updateAccordionContainer(removeDiv);\n                                }\n                                else {\n                                    removeDiv.remove();\n                                }\n                            }\n                        }\n                    }\n                    this.pdfViewer.annotationModule.updateAnnotationCollection(this.currentTextMarkupAnnotation);\n                    this.manageAnnotations(pageAnnotations, this.selectTextMarkupCurrentPage);\n                    this.pdfViewer.annotationModule.updateImportAnnotationCollection(this.currentTextMarkupAnnotation, this.currentTextMarkupAnnotation.pageNumber, 'textMarkupAnnotation');\n                    var annotationId = this.currentTextMarkupAnnotation.annotName;\n                    var annotationBounds = this.currentTextMarkupAnnotation.bounds;\n                    this.currentTextMarkupAnnotation = null;\n                    this.pdfViewer.annotationModule.renderAnnotations(this.selectTextMarkupCurrentPage, null, null, null);\n                    this.pdfViewerBase.updateDocumentEditedProperty(true);\n                    var multiPageCollection = this.multiPageCollectionList(annotation);\n                    if (multiPageCollection.length > 0) {\n                        multiPageCollection.push(deletedAnnotation);\n                        this.pdfViewer.fireAnnotationRemove(this.selectTextMarkupCurrentPage, annotationId, deletedAnnotation.textMarkupAnnotationType, annotationBounds, deletedAnnotation.textMarkupContent, deletedAnnotation.textMarkupStartIndex, deletedAnnotation.textMarkupEndIndex, multiPageCollection);\n                    }\n                    else if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(deletedAnnotation)) {\n                        this.pdfViewer.fireAnnotationRemove(this.selectTextMarkupCurrentPage, annotationId, deletedAnnotation.textMarkupAnnotationType, annotationBounds, deletedAnnotation.textMarkupContent, deletedAnnotation.textMarkupStartIndex, deletedAnnotation.textMarkupEndIndex);\n                    }\n                    this.currentAnnotationIndex = null;\n                    this.selectTextMarkupCurrentPage = null;\n                    if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode) {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.hideMobileAnnotationToolbar();\n                        this.pdfViewer.toolbarModule.showToolbar(true);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} bounds - bounds\n     * @returns {void}\n     * @private\n     */\n    TextMarkupAnnotation.prototype.modifyBoundsProperty = function (bounds) {\n        if (this.currentTextMarkupAnnotation) {\n            var pageAnnotations = this.modifyAnnotationProperty('Bounds', bounds, null);\n            this.manageAnnotations(pageAnnotations, this.selectTextMarkupCurrentPage);\n            this.pdfViewer.annotationModule.renderAnnotations(this.selectTextMarkupCurrentPage, null, null, null);\n            this.pdfViewerBase.updateDocumentEditedProperty(true);\n            var annotation = this.currentTextMarkupAnnotation;\n            var multiPageCollection = this.multiPageCollectionList(annotation);\n            if (multiPageCollection.length > 0) {\n                this.pdfViewer.fireAnnotationPropertiesChange(this.selectTextMarkupCurrentPage, annotation.annotName, annotation.textMarkupAnnotationType, false, false, false, false, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex, multiPageCollection);\n                this.currentAnnotationIndex = null;\n            }\n            else {\n                this.pdfViewer.fireAnnotationPropertiesChange(this.selectTextMarkupCurrentPage, annotation.annotName, annotation.textMarkupAnnotationType, false, false, false, false, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex);\n                this.currentAnnotationIndex = null;\n            }\n        }\n    };\n    /**\n     * @param {string} color - It describes about the color\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.modifyColorProperty = function (color) {\n        if (this.currentTextMarkupAnnotation) {\n            var pageAnnotations = this.modifyAnnotationProperty('Color', color, null);\n            this.manageAnnotations(pageAnnotations, this.selectTextMarkupCurrentPage);\n            this.pdfViewer.annotationModule.renderAnnotations(this.selectTextMarkupCurrentPage, null, null, null);\n            this.pdfViewerBase.updateDocumentEditedProperty(true);\n            var annotation = this.currentTextMarkupAnnotation;\n            var multiPageCollection = this.multiPageCollectionList(annotation);\n            if (multiPageCollection.length > 0) {\n                this.pdfViewer.fireAnnotationPropertiesChange(this.selectTextMarkupCurrentPage, annotation.annotName, annotation.textMarkupAnnotationType, true, false, false, false, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex, multiPageCollection);\n                this.currentAnnotationIndex = null;\n            }\n            else {\n                this.pdfViewer.fireAnnotationPropertiesChange(this.selectTextMarkupCurrentPage, annotation.annotName, annotation.textMarkupAnnotationType, true, false, false, false, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex);\n                this.currentAnnotationIndex = null;\n            }\n        }\n    };\n    /**\n     * @param {ChangeEventArgs} args - It describes about the args\n     * @param {number} isOpacity - It describes about the isOpacity\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.modifyOpacityProperty = function (args, isOpacity) {\n        if (this.currentTextMarkupAnnotation) {\n            var pageAnnotations = void 0;\n            if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(isOpacity))) {\n                pageAnnotations = this.modifyAnnotationProperty('Opacity', isOpacity, 'changed');\n            }\n            else {\n                pageAnnotations = this.modifyAnnotationProperty('Opacity', args.value / 100, args.name);\n            }\n            if (pageAnnotations) {\n                this.manageAnnotations(pageAnnotations, this.selectTextMarkupCurrentPage);\n                this.pdfViewer.annotationModule.renderAnnotations(this.selectTextMarkupCurrentPage, null, null, null);\n                if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(isOpacity)) || args.name === 'changed') {\n                    this.pdfViewerBase.updateDocumentEditedProperty(true);\n                    var annotation = this.currentTextMarkupAnnotation;\n                    var multiPageCollection = this.multiPageCollectionList(annotation);\n                    if (multiPageCollection.length > 0) {\n                        this.pdfViewer.fireAnnotationPropertiesChange(this.selectTextMarkupCurrentPage, annotation.annotName, annotation.textMarkupAnnotationType, false, true, false, false, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex, multiPageCollection);\n                        this.currentAnnotationIndex = null;\n                    }\n                    else {\n                        this.pdfViewer.fireAnnotationPropertiesChange(this.selectTextMarkupCurrentPage, annotation.annotName, annotation.textMarkupAnnotationType, false, true, false, false, annotation.textMarkupContent, annotation.textMarkupStartIndex, annotation.textMarkupEndIndex);\n                        this.currentAnnotationIndex = null;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {string} property -It describes about the property\n     * @param {any} value - It describes about the value\n     * @param {string} status - It describes about the status\n     * @param {string} annotName - It describes about the annotation name\n     * @private\n     * @returns {ITextMarkupAnnotation} - ITextMarkuoAnnotation\n     */\n    TextMarkupAnnotation.prototype.modifyAnnotationProperty = function (property, value, status, annotName) {\n        var annotation = this.currentTextMarkupAnnotation;\n        this.pdfViewer.annotationModule.isFormFieldShape = false;\n        if (annotation.isMultiSelect && annotation.annotNameCollection) {\n            this.modifyMultiPageAnnotations(annotation, property, value);\n        }\n        var pageAnnotations = this.getAnnotations(this.selectTextMarkupCurrentPage, null);\n        if (pageAnnotations) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (JSON.stringify(this.currentTextMarkupAnnotation) === JSON.stringify(pageAnnotations[parseInt(i.toString(), 10)])) {\n                    if (property === 'Color') {\n                        pageAnnotations[parseInt(i.toString(), 10)].color = value;\n                    }\n                    else if (property === 'Opacity') {\n                        pageAnnotations[parseInt(i.toString(), 10)].opacity = value;\n                    }\n                    else if (property === 'AnnotationSettings') {\n                        pageAnnotations[parseInt(i.toString(), 10)].annotationSettings = { isLock: value };\n                    }\n                    else if (property === 'Bounds') {\n                        pageAnnotations[parseInt(i.toString(), 10)].bounds = value;\n                    }\n                    else if (property === 'AnnotationSelectorSettings') {\n                        pageAnnotations[parseInt(i.toString(), 10)].annotationSelectorSettings = value;\n                    }\n                    pageAnnotations[parseInt(i.toString(), 10)].modifiedDate =\n                        this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                    this.currentAnnotationIndex = i;\n                    if (status === null || status === 'changed') {\n                        this.pdfViewer.annotationModule.addAction(this.selectTextMarkupCurrentPage, i, this.currentTextMarkupAnnotation, 'Text Markup Property modified', property);\n                    }\n                    this.currentTextMarkupAnnotation = pageAnnotations[parseInt(i.toString(), 10)];\n                    this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        updateAnnotationModifiedDate(pageAnnotations[parseInt(i.toString(), 10)]);\n                    this.pdfViewer.annotationModule.storeAnnotationCollections(pageAnnotations[parseInt(i.toString(), 10)], this.selectTextMarkupCurrentPage);\n                }\n            }\n        }\n        return pageAnnotations;\n    };\n    /**\n     * @param {ITextMarkupAnnotation} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @param {number} index - It describes about the index\n     * @param {string} action - It describes about the action\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.undoTextMarkupAction = function (annotation, pageNumber, index, action) {\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations) {\n            if (action === 'Text Markup Added') {\n                this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(pageAnnotations[parseInt(index.toString(), 10)], 'textMarkup', null, true);\n                var removeDiv = document.getElementById(pageAnnotations[parseInt(index.toString(), 10)].annotName);\n                if (removeDiv) {\n                    if (removeDiv.parentElement.childElementCount === 1) {\n                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.updateAccordionContainer(removeDiv);\n                    }\n                    else {\n                        removeDiv.parentElement.removeChild(removeDiv);\n                    }\n                }\n                pageAnnotations.splice(index, 1);\n                this.pdfViewer.annotationCollection.splice(index, 1);\n            }\n            else if (action === 'Text Markup Deleted') {\n                this.pdfViewer.annotationModule.stickyNotesAnnotationModule.addAnnotationComments(pageNumber, annotation.shapeAnnotationType, true);\n                pageAnnotations.splice(index, 0, annotation);\n            }\n        }\n        this.clearCurrentAnnotation();\n        this.pdfViewerBase.updateDocumentEditedProperty(true);\n        this.manageAnnotations(pageAnnotations, pageNumber);\n        this.pdfViewer.annotationModule.renderAnnotations(pageNumber, null, null, null);\n    };\n    /**\n     * @param {ITextMarkupAnnotation} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @param {number} index - It describes about the index\n     * @param {string} property - It describes about the proeperty\n     * @param {boolean} isUndoAction - It describes about the isUndoAction\n     * @private\n     * @returns {ITextMarkupAnnotation} - Itextmarkupannotation\n     */\n    TextMarkupAnnotation.prototype.undoRedoPropertyChange = function (annotation, pageNumber, index, property, isUndoAction) {\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations) {\n            if (property === 'Color') {\n                var tempColor = pageAnnotations[parseInt(index.toString(), 10)].color;\n                pageAnnotations[parseInt(index.toString(), 10)].color = annotation.color;\n                annotation.color = tempColor;\n            }\n            else {\n                var tempOpacity = pageAnnotations[parseInt(index.toString(), 10)].opacity;\n                pageAnnotations[parseInt(index.toString(), 10)].opacity = annotation.opacity;\n                annotation.opacity = tempOpacity;\n            }\n            this.pdfViewer.annotationModule.stickyNotesAnnotationModule.updateAnnotationModifiedDate(annotation, null, true);\n            if (isUndoAction) {\n                annotation.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n            }\n        }\n        this.clearCurrentAnnotation();\n        this.pdfViewerBase.updateDocumentEditedProperty(true);\n        this.manageAnnotations(pageAnnotations, pageNumber);\n        this.pdfViewer.annotationModule.renderAnnotations(pageNumber, null, null, null);\n        return annotation;\n    };\n    /**\n     * @param {ITextMarkupAnnotation} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @param {number} index - It describes about the index\n     * @param {string} action - It describes about the action\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.redoTextMarkupAction = function (annotation, pageNumber, index, action) {\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations) {\n            if (action === 'Text Markup Added') {\n                this.pdfViewer.annotationModule.stickyNotesAnnotationModule.addAnnotationComments(pageNumber, annotation.shapeAnnotationType, false);\n                pageAnnotations.push(annotation);\n            }\n            else if (action === 'Text Markup Deleted') {\n                this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(pageAnnotations[parseInt(index.toString(), 10)], 'textMarkup');\n                var removeDiv = document.getElementById(pageAnnotations[parseInt(index.toString(), 10)].annotName);\n                if (removeDiv) {\n                    if (removeDiv.parentElement.childElementCount === 1) {\n                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.updateAccordionContainer(removeDiv);\n                    }\n                    else {\n                        removeDiv.remove();\n                    }\n                }\n                pageAnnotations.splice(index, 1);\n            }\n        }\n        this.clearCurrentAnnotation();\n        this.pdfViewerBase.updateDocumentEditedProperty(true);\n        this.manageAnnotations(pageAnnotations, pageNumber);\n        this.pdfViewer.annotationModule.renderAnnotations(pageNumber, null, null, null);\n    };\n    /**\n     * @param {number} pageNumber - It describes about the page number\n     * @param {string} note -  It describes about the note\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.saveNoteContent = function (pageNumber, note) {\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (JSON.stringify(this.currentTextMarkupAnnotation) === JSON.stringify(pageAnnotations[parseInt(i.toString(), 10)])) {\n                    pageAnnotations[parseInt(i.toString(), 10)].note = note;\n                }\n            }\n        }\n        this.manageAnnotations(pageAnnotations, pageNumber);\n        this.pdfViewerBase.updateDocumentEditedProperty(true);\n    };\n    TextMarkupAnnotation.prototype.clearCurrentAnnotation = function () {\n        if (!this.isExtended) {\n            if (!(this.pdfViewer.isMaintainSelection && !this.pdfViewer.textSelectionModule.isTextSelection)) {\n                this.selectTextMarkupCurrentPage = null;\n                this.currentTextMarkupAnnotation = null;\n            }\n            var isSkip = false;\n            if (this.pdfViewer.annotation.freeTextAnnotationModule &&\n                this.pdfViewer.annotation.freeTextAnnotationModule.isInuptBoxInFocus) {\n                isSkip = true;\n            }\n            if (!isSkip) {\n                this.enableAnnotationPropertiesTool(false);\n            }\n        }\n    };\n    /**\n     * @param {number} pageNumber - It describes about the pageNumber\n     * @param {boolean} isSelect - It describes about the isSelect\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.clearCurrentAnnotationSelection = function (pageNumber, isSelect) {\n        if (isSelect) {\n            this.isAnnotationSelect = true;\n        }\n        else {\n            this.isAnnotationSelect = false;\n        }\n        var lowerPageIndex = (pageNumber - 2) >= 0 ? (pageNumber - 2) : 0;\n        var higherPageIndex = (pageNumber + 2) < this.pdfViewerBase.pageCount ? (pageNumber + 2) :\n            this.pdfViewerBase.pageCount - 1;\n        for (var k = lowerPageIndex; k <= higherPageIndex; k++) {\n            this.clearAnnotationSelection(k);\n        }\n    };\n    TextMarkupAnnotation.prototype.getBoundsForSave = function (bounds, pageIndex) {\n        var newArray = [];\n        for (var i = 0; i < bounds.length; i++) {\n            var bound = this.getAnnotationBounds(bounds[parseInt(i.toString(), 10)], pageIndex);\n            newArray.push(bound);\n        }\n        return newArray;\n    };\n    TextMarkupAnnotation.prototype.getAnnotationBounds = function (bounds, pageIndex) {\n        var left = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bounds.left) ? bounds.left : bounds.Left;\n        var top = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bounds.top) ? bounds.top : bounds.Top;\n        var height = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bounds.height) ? bounds.height : bounds.Height;\n        var width = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(bounds.width) ? bounds.width : bounds.Width;\n        var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)];\n        left = left ? left : bounds.x;\n        top = top ? top : bounds.y;\n        if (pageDetails) {\n            if (pageDetails.rotation === 1) {\n                return { left: top, top: pageDetails.width - (left + width), width: height, height: width };\n            }\n            else if (pageDetails.rotation === 2) {\n                return { left: pageDetails.width - left - width, top: pageDetails.height - top - height, width: width, height: height };\n            }\n            else if (pageDetails.rotation === 3) {\n                return { left: pageDetails.height - top - height, top: left, width: height, height: width };\n            }\n            else {\n                return { left: left, top: top, width: width, height: height };\n            }\n        }\n        else {\n            return { left: left, top: top, width: width, height: height };\n        }\n    };\n    TextMarkupAnnotation.prototype.getRgbCode = function (colorString) {\n        // eslint-disable-next-line\n        if (!colorString.match(/#([a-z0-9]+)/gi) && !colorString.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/)) {\n            colorString = this.pdfViewer.annotationModule.nameToHash(colorString);\n        }\n        var markupStringArray = colorString.split(',');\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(markupStringArray[1])) {\n            colorString = this.pdfViewer.annotationModule.getValue(colorString, 'rgba');\n            markupStringArray = colorString.split(',');\n        }\n        var textMarkupR = parseInt(markupStringArray[0].split('(')[1], 10);\n        var textMarkupG = parseInt(markupStringArray[1], 10);\n        var textMarkupB = parseInt(markupStringArray[2], 10);\n        var textMarkupA = parseInt(markupStringArray[3], 10);\n        return { a: textMarkupA, r: textMarkupR, g: textMarkupG, b: textMarkupB };\n    };\n    TextMarkupAnnotation.prototype.getDrawnBounds = function () {\n        var pageBounds = [];\n        var selection = window.getSelection();\n        if (selection.anchorNode !== null) {\n            var range = document.createRange();\n            var isBackWardSelection = this.pdfViewerBase.textLayer.isBackWardSelection(selection);\n            if (selection.anchorNode === selection.focusNode) {\n                var pageId = this.pdfViewerBase.textLayer.getPageIndex(selection.anchorNode);\n                var startIndex = 0;\n                var endIndex = 0;\n                if (!isNaN(pageId)) {\n                    var pageRect = this.pdfViewerBase.getElement('_pageDiv_' + pageId).getBoundingClientRect();\n                    if (this.pdfViewerBase.isMixedSizeDocument) {\n                        pageRect = this.pdfViewerBase.getElement('_textLayer_' + pageId).getBoundingClientRect();\n                    }\n                    if (isBackWardSelection) {\n                        range.setStart(selection.focusNode, selection.focusOffset);\n                        range.setEnd(selection.anchorNode, selection.anchorOffset);\n                    }\n                    else {\n                        if (selection.anchorOffset < selection.focusOffset) {\n                            startIndex = selection.anchorOffset;\n                            endIndex = selection.focusOffset;\n                            range.setStart(selection.anchorNode, selection.anchorOffset);\n                            range.setEnd(selection.focusNode, selection.focusOffset);\n                        }\n                        else {\n                            startIndex = selection.focusOffset;\n                            endIndex = selection.anchorOffset;\n                            range.setStart(selection.focusNode, selection.focusOffset);\n                            range.setEnd(selection.anchorNode, selection.anchorOffset);\n                        }\n                    }\n                    var boundingRect = range.getBoundingClientRect();\n                    var annotationRotate = 0;\n                    if (this.pdfViewerBase.clientSideRendering) {\n                        var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageId.toString(), 10)];\n                        var pageRotation = this.pdfViewerBase.getAngle(pageDetails.rotation);\n                        var textElement = void 0;\n                        if (range.startContainer.parentElement) {\n                            textElement = range.startContainer.parentElement;\n                        }\n                        else {\n                            textElement = range.startContainer.parentNode;\n                        }\n                        if (textElement && textElement.style.transform !== '') {\n                            if (textElement.style.transform.startsWith('rotate(90deg)')) {\n                                annotationRotate = 90;\n                            }\n                            else if (textElement.style.transform.startsWith('rotate(180deg)')) {\n                                annotationRotate = 180;\n                            }\n                            else if (textElement.style.transform.startsWith('rotate(-90deg)') || textElement.style.transform.startsWith('rotate(270deg)')) {\n                                annotationRotate = 270;\n                            }\n                            else {\n                                annotationRotate = 0;\n                            }\n                        }\n                    }\n                    var indexes = this.getIndexNumbers(pageId, range.toString(), range.commonAncestorContainer.textContent.toString());\n                    var rectangle = { left: this.getDefaultValue(boundingRect.left - pageRect.left),\n                        top: this.getDefaultValue(boundingRect.top - pageRect.top), width: this.getDefaultValue(boundingRect.width),\n                        height: this.getDefaultValue(boundingRect.height), right: this.getDefaultValue(boundingRect.right - pageRect.left),\n                        bottom: this.getDefaultValue(boundingRect.bottom - pageRect.top), rotation: annotationRotate };\n                    var rectangleArray = [];\n                    rectangleArray.push(rectangle);\n                    var rect = { left: rectangle.left, top: rectangle.top, right: rectangle.right,\n                        bottom: rectangle.bottom, rotation: annotationRotate };\n                    pageBounds.push({ pageIndex: pageId, bounds: rectangleArray, rect: rect, startIndex: indexes.startIndex,\n                        endIndex: indexes.endIndex, textContent: range.toString() });\n                }\n            }\n            else {\n                var startNode = void 0;\n                var endNode = void 0;\n                var selectionStartOffset = void 0;\n                var selectionEndOffset = void 0;\n                if (isBackWardSelection) {\n                    startNode = selection.focusNode;\n                    selectionStartOffset = selection.focusOffset;\n                    endNode = selection.anchorNode;\n                    selectionEndOffset = selection.anchorOffset;\n                }\n                else {\n                    startNode = selection.anchorNode;\n                    selectionStartOffset = selection.anchorOffset;\n                    endNode = selection.focusNode;\n                    selectionEndOffset = selection.focusOffset;\n                }\n                var anchorPageId = this.pdfViewerBase.textLayer.getPageIndex(startNode);\n                var anchorTextId = this.pdfViewerBase.textLayer.getTextIndex(startNode, anchorPageId);\n                var focusPageId = this.pdfViewerBase.textLayer.getPageIndex(endNode);\n                var focusTextId = this.pdfViewerBase.textLayer.getTextIndex(endNode, focusPageId);\n                var startOffset = 0;\n                var endOffset = 0;\n                var currentId = 0;\n                for (var i = anchorPageId; i <= focusPageId; i++) {\n                    var selectionRects = [];\n                    var pageStartId = void 0;\n                    var pageEndId = void 0;\n                    var pageStartOffset = void 0;\n                    var pageEndOffset = void 0;\n                    var textDivs = this.pdfViewerBase.getElement('_textLayer_' + i).childNodes;\n                    var pageRect = this.pdfViewerBase.getElement('_pageDiv_' + i).getBoundingClientRect();\n                    if (this.pdfViewerBase.isMixedSizeDocument) {\n                        pageRect = this.pdfViewerBase.getElement('_textLayer_' + i).getBoundingClientRect();\n                    }\n                    if (i === anchorPageId) {\n                        currentId = anchorTextId;\n                    }\n                    else {\n                        currentId = 0;\n                    }\n                    for (var j = currentId; j < textDivs.length; j++) {\n                        var textElement = textDivs[parseInt(j.toString(), 10)];\n                        if (j === currentId) {\n                            pageStartId = currentId;\n                            pageStartOffset = (i === anchorPageId) ? selectionStartOffset : 0;\n                        }\n                        else {\n                            pageEndId = j;\n                            pageEndOffset = (i === focusPageId) ? selectionEndOffset : textElement.textContent.length;\n                        }\n                        if (j === anchorTextId && i === anchorPageId) {\n                            startOffset = selectionStartOffset;\n                        }\n                        else {\n                            startOffset = 0;\n                        }\n                        if (j === focusTextId && i === focusPageId) {\n                            endOffset = selectionEndOffset;\n                        }\n                        else {\n                            endOffset = textElement.textContent.length;\n                        }\n                        for (var k = 0; k < textElement.childNodes.length; k++) {\n                            var node = textElement.childNodes[parseInt(k.toString(), 10)];\n                            range.setStart(node, startOffset);\n                            range.setEnd(node, endOffset);\n                        }\n                        var boundingRect = range.getBoundingClientRect();\n                        var annotationRotate = 0;\n                        if (this.pdfViewerBase.clientSideRendering) {\n                            var pageDetails = this.pdfViewerBase.pageSize[parseInt(i.toString(), 10)];\n                            var pageRotation = this.pdfViewerBase.getAngle(pageDetails.rotation);\n                            if (textElement && textElement.style.transform !== '') {\n                                if (textElement.style.transform.startsWith('rotate(90deg)')) {\n                                    annotationRotate = 90;\n                                }\n                                else if (textElement.style.transform.startsWith('rotate(180deg)')) {\n                                    annotationRotate = 180;\n                                }\n                                else if (textElement.style.transform.startsWith('rotate(-90deg)') || textElement.style.transform.startsWith('rotate(270deg)')) {\n                                    annotationRotate = 270;\n                                }\n                                else {\n                                    annotationRotate = 0;\n                                }\n                            }\n                        }\n                        var rectangle = { left: this.getDefaultValue(boundingRect.left - pageRect.left),\n                            top: this.getDefaultValue(boundingRect.top - pageRect.top),\n                            width: this.getDefaultValue(boundingRect.width), height: this.getDefaultValue(boundingRect.height),\n                            right: this.getDefaultValue(boundingRect.right - pageRect.left),\n                            bottom: this.getDefaultValue(boundingRect.bottom - pageRect.top), rotation: annotationRotate };\n                        selectionRects.push(rectangle);\n                        range.detach();\n                        if (i === focusPageId && j === focusTextId) {\n                            break;\n                        }\n                    }\n                    if (!pageEndId) {\n                        pageEndId = pageStartId;\n                    }\n                    if (!pageEndOffset) {\n                        pageEndOffset = endOffset;\n                    }\n                    var startElementNode = this.pdfViewerBase.getElement('_text_' + i + '_' + pageStartId).childNodes[0];\n                    var endElementNode = this.pdfViewerBase.getElement('_text_' + i + '_' + pageEndId).childNodes[0];\n                    var pageRange = document.createRange();\n                    pageRange.setStart(startElementNode, pageStartOffset);\n                    pageRange.setEnd(endElementNode, pageEndOffset);\n                    var pageRectBounds = pageRange.getBoundingClientRect();\n                    var textValue = pageRange.toString();\n                    var indexes = this.getIndexNumbers(i, textValue);\n                    var pageRectangle = { left: this.getDefaultValue(pageRectBounds.left - pageRect.left),\n                        top: this.getDefaultValue(pageRectBounds.top - pageRect.top),\n                        width: this.getDefaultValue(pageRectBounds.width), height: this.getDefaultValue(pageRectBounds.height),\n                        right: this.getDefaultValue(pageRectBounds.right - pageRect.left),\n                        bottom: this.getDefaultValue(pageRectBounds.bottom - pageRect.top) };\n                    var rect = { left: pageRectangle.left, top: pageRectangle.top, right: pageRectangle.right,\n                        bottom: pageRectangle.bottom };\n                    pageBounds.push({ pageIndex: i, bounds: selectionRects, rect: rect, startIndex: indexes.startIndex,\n                        endIndex: indexes.endIndex, textContent: textValue });\n                }\n            }\n        }\n        selection.removeAllRanges();\n        return pageBounds;\n    };\n    TextMarkupAnnotation.prototype.getIndexNumbers = function (pageNumber, content, parentText) {\n        var storedData = this.pdfViewerBase.clientSideRendering ?\n            this.pdfViewerBase.getLinkInformation(pageNumber) : this.pdfViewerBase.getStoredData(pageNumber);\n        var startIndex;\n        var endIndex;\n        if (storedData) {\n            var previousIndex = 0;\n            var pageText = storedData.pageText;\n            for (var p = 0; p < pageNumber; p++) {\n                if (this.pdfViewer.isExtractText) {\n                    var documentIndex = this.pdfViewer.textSearchModule.\n                        documentTextCollection[parseInt(p.toString(), 10)][parseInt(p.toString(), 10)];\n                    var pageTextData = documentIndex.pageText ? documentIndex.pageText : documentIndex.PageText;\n                    if (this.pdfViewer.textSearchModule && this.pdfViewer.\n                        textSearchModule.documentTextCollection && this.pdfViewer.textSearchModule.isTextRetrieved) {\n                        if (this.pdfViewer.textSearchModule.documentTextCollection[parseInt(p.toString(), 10)]) {\n                            previousIndex = previousIndex + pageTextData.length;\n                        }\n                    }\n                    else {\n                        if (this.pdfViewer.textSearchModule && this.pdfViewer.textSearchModule.documentTextCollection) {\n                            if (pageNumber <= this.pdfViewer.textSearchModule.documentTextCollection.length) {\n                                if (this.pdfViewer.textSearchModule.documentTextCollection[parseInt(p.toString(), 10)]) {\n                                    previousIndex = previousIndex + pageTextData.length;\n                                }\n                            }\n                            else {\n                                previousIndex = 0;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(parentText)) {\n                var parentIndex = pageText.indexOf(parentText);\n                var initialIndex = parentText.indexOf(content);\n                startIndex = (parentIndex + initialIndex) + previousIndex;\n            }\n            else {\n                startIndex = (pageText.indexOf(content)) + previousIndex;\n            }\n            endIndex = startIndex + (content.length - 1);\n        }\n        return { startIndex: startIndex, endIndex: endIndex };\n    };\n    /**\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.rerenderAnnotationsPinch = function (pageNumber) {\n        var _this = this;\n        // Need to be check both canvases. The 'blendAnnotationsIntoCanvas' is used for highlight annotations.\n        ['_annotationCanvas_', '_blendAnnotationsIntoCanvas_'].forEach(function (id) {\n            var annotCanvas = _this.pdfViewerBase.getElement(id + pageNumber);\n            if (annotCanvas) {\n                var oldAnnotCanvas = _this.pdfViewerBase.getElement('_old_annotationCanvas_' + pageNumber);\n                if (oldAnnotCanvas) {\n                    if (annotCanvas) {\n                        oldAnnotCanvas.id = annotCanvas.id;\n                        annotCanvas.parentElement.removeChild(annotCanvas);\n                    }\n                    else {\n                        oldAnnotCanvas.id = _this.pdfViewer.element.id + '_annotationCanvas_' + pageNumber;\n                    }\n                    annotCanvas = oldAnnotCanvas;\n                }\n                annotCanvas.style.width = '';\n                annotCanvas.style.height = '';\n                if (_this.pdfViewer.restrictZoomRequest) {\n                    annotCanvas.style.width = _this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].width * _this.pdfViewerBase.getZoomFactor() + 'px';\n                    annotCanvas.style.height = _this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].height * _this.pdfViewerBase.getZoomFactor() + 'px';\n                }\n                else {\n                    annotCanvas.width =\n                        _this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].width * _this.pdfViewerBase.getZoomFactor();\n                    annotCanvas.height =\n                        _this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].height * _this.pdfViewerBase.getZoomFactor();\n                }\n                _this.renderTextMarkupAnnotations(null, pageNumber, annotCanvas, _this.pdfViewerBase.getZoomFactor());\n            }\n        });\n    };\n    /**\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.rerenderAnnotations = function (pageNumber) {\n        var _this = this;\n        var oldCanvasCollection = document.querySelectorAll('#' + this.pdfViewer.element.id + '_old_annotationCanvas_' + pageNumber);\n        for (var i = 0; i < oldCanvasCollection.length; i++) {\n            if (oldCanvasCollection[parseInt(i.toString(), 10)]) {\n                oldCanvasCollection[parseInt(i.toString(), 10)].parentElement.removeChild(oldCanvasCollection[parseInt(i.toString(), 10)]);\n            }\n        }\n        // Styles need to be applied to both canvases. The 'blendAnnotationsIntoCanvas' is used for highlight annotations.\n        var canvasIds = [\n            '_annotationCanvas_' + pageNumber,\n            '_blendAnnotationsIntoCanvas_' + pageNumber\n        ];\n        canvasIds.forEach(function (id) {\n            var canvas = _this.pdfViewerBase.getElement(id);\n            if (canvas) {\n                canvas.style.display = 'block';\n            }\n        });\n    };\n    /**\n     * @param {MouseEvent} event - It describes about the event\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.onTextMarkupAnnotationMouseUp = function (event) {\n        var pageNumber = this.pdfViewer.annotationModule.getEventPageNumber(event);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(pageNumber) && !isNaN(pageNumber)) {\n            var canvas = this.pdfViewerBase.getElement('_annotationCanvas_' + pageNumber);\n            var highlighCanvas = this.pdfViewerBase.getElement('_blendAnnotationsIntoCanvas_' + pageNumber);\n            if (this.currentTextMarkupAnnotation) {\n                this.selectedTextMarkup = this.currentTextMarkupAnnotation;\n            }\n            else {\n                this.selectedTextMarkup = null;\n            }\n            this.clearCurrentSelectedAnnotation();\n            var currentAnnot = this.getCurrentMarkupAnnotation(event.clientX, event.clientY, pageNumber, canvas);\n            var currentHighlightAnnot = this.getCurrentMarkupAnnotation(event.clientX, event.clientY, pageNumber, highlighCanvas);\n            if (currentAnnot && !window.getSelection().toString()) {\n                this.onTextMarkupMouseUp(currentAnnot, event, canvas, pageNumber);\n            }\n            else if (currentHighlightAnnot && !window.getSelection().toString()) {\n                this.onTextMarkupMouseUp(currentHighlightAnnot, event, highlighCanvas, pageNumber);\n            }\n            else {\n                this.clearCurrentAnnotation();\n            }\n            if (this.pdfViewer.isMaintainSelection && !this.pdfViewer.textSelectionModule.isTextSelection) {\n                if (currentAnnot || currentHighlightAnnot) {\n                    this.clearCurrentAnnotationSelection(pageNumber);\n                }\n            }\n            else {\n                this.clearCurrentAnnotationSelection(pageNumber);\n            }\n        }\n        else {\n            if (!this.pdfViewerBase.isClickedOnScrollBar(event, true)) {\n                this.clearCurrentAnnotation();\n                this.clearCurrentAnnotationSelection(pageNumber);\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.onTextMarkupMouseUp = function (currentAnnot, event, canvas, pageNumber) {\n        var isLock = false;\n        var isSelection = false;\n        if (currentAnnot.annotationSettings && currentAnnot.annotationSettings.isLock) {\n            isLock = currentAnnot.annotationSettings.isLock;\n            if (isLock && this.pdfViewer.annotationModule.checkAllowedInteractions('Select', currentAnnot)) {\n                isLock = false;\n                if (this.pdfViewer.annotationModule.checkAllowedInteractions('PropertyChange', currentAnnot)) {\n                    isSelection = false;\n                }\n                else {\n                    isSelection = true;\n                }\n            }\n        }\n        if (!isLock) {\n            var canvasParentPosition = canvas.parentElement.getBoundingClientRect();\n            var leftClickPosition = event.clientX - canvasParentPosition.left;\n            var topClickPosition = event.clientY - canvasParentPosition.top;\n            this.annotationClickPosition = { x: leftClickPosition, y: topClickPosition };\n            this.selectAnnotation(currentAnnot, canvas, pageNumber, event);\n            if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode && this.pdfViewer.enableToolbar &&\n                this.pdfViewer.enableAnnotationToolbar) {\n                this.pdfViewer.toolbarModule.annotationToolbarModule.\n                    createPropertyTools(this.currentTextMarkupAnnotation.textMarkupAnnotationType);\n            }\n            this.currentTextMarkupAnnotation = currentAnnot;\n            this.selectTextMarkupCurrentPage = pageNumber;\n            if (!isSelection) {\n                this.enableAnnotationPropertiesTool(true);\n            }\n            var commentPanelDiv = document.getElementById(this.pdfViewer.element.id + '_commantPanel');\n            if (commentPanelDiv && commentPanelDiv.style.display === 'block') {\n                var accordionExpand = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + (pageNumber + 1));\n                if (accordionExpand) {\n                    accordionExpand.ej2_instances[0].expandItem(true);\n                }\n                var comments = document.getElementById(currentAnnot.annotName);\n                if (comments) {\n                    comments.firstChild.click();\n                }\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                if (this.pdfViewer.toolbarModule && this.pdfViewer.enableAnnotationToolbar) {\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.isToolbarHidden = true;\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.\n                        showAnnotationToolbar(this.pdfViewer.toolbarModule.annotationItem);\n                }\n            }\n        }\n    };\n    /**\n     * @param {TouchEvent} event - It describes about the event\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.onTextMarkupAnnotationTouchEnd = function (event) {\n        var pageNumber = this.pdfViewer.annotationModule.getEventPageNumber(event);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(pageNumber) && !isNaN(pageNumber)) {\n            if (this.currentTextMarkupAnnotation) {\n                this.selectedTextMarkup = this.currentTextMarkupAnnotation;\n            }\n            else {\n                this.selectedTextMarkup = null;\n            }\n            this.clearCurrentAnnotationSelection(pageNumber);\n            var touchCanvas = this.pdfViewerBase.getElement('_annotationCanvas_' + pageNumber);\n            var highlightTouchCanvas = this.pdfViewerBase.getElement('_blendAnnotationsIntoCanvas_' + pageNumber);\n            this.clearCurrentSelectedAnnotation();\n            var currentAnnot = this.getCurrentMarkupAnnotation(event.touches[0].clientX, event.touches[0].clientY, pageNumber, touchCanvas);\n            var currentHighlightAnnot = this.getCurrentMarkupAnnotation(event.touches[0].clientX, event.touches[0].clientY, pageNumber, highlightTouchCanvas);\n            if (currentAnnot) {\n                this.onTextMarkupTouchEnd(currentAnnot, touchCanvas, event, pageNumber);\n            }\n            else if (currentHighlightAnnot) {\n                this.onTextMarkupTouchEnd(currentHighlightAnnot, highlightTouchCanvas, event, pageNumber);\n            }\n            else {\n                this.clearCurrentAnnotation();\n            }\n            this.clearCurrentAnnotationSelection(pageNumber);\n        }\n        else if (this.selectTextMarkupCurrentPage != null && (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode)) {\n            var number = this.selectTextMarkupCurrentPage;\n            this.selectTextMarkupCurrentPage = null;\n            this.clearAnnotationSelection(number);\n        }\n        else {\n            this.clearCurrentAnnotation();\n            this.clearCurrentAnnotationSelection(pageNumber);\n        }\n    };\n    TextMarkupAnnotation.prototype.onTextMarkupTouchEnd = function (currentAnnot, touchCanvas, event, pageNumber) {\n        var isLock = false;\n        if (currentAnnot.annotationSettings && currentAnnot.annotationSettings.isLock) {\n            isLock = currentAnnot.annotationSettings.isLock;\n        }\n        if (!isLock) {\n            var canvasParentPosition = touchCanvas.parentElement.getBoundingClientRect();\n            var leftClickPosition = event.touches[0].clientX - canvasParentPosition.left;\n            var topClickPosition = event.touches[0].clientY - canvasParentPosition.top;\n            this.annotationClickPosition = { x: leftClickPosition, y: topClickPosition };\n            this.selectAnnotation(currentAnnot, touchCanvas, pageNumber, event);\n            if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode && this.pdfViewer.enableToolbar &&\n                this.pdfViewer.enableAnnotationToolbar) {\n                this.pdfViewer.toolbarModule.annotationToolbarModule.\n                    createPropertyTools(this.currentTextMarkupAnnotation.textMarkupAnnotationType);\n            }\n            this.currentTextMarkupAnnotation = currentAnnot;\n            this.selectTextMarkupCurrentPage = pageNumber;\n            this.enableAnnotationPropertiesTool(true);\n            var accordionExpand = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + (pageNumber + 1));\n            if (accordionExpand) {\n                accordionExpand.ej2_instances[0].expandItem(true);\n            }\n            var comments = document.getElementById(currentAnnot.annotName);\n            if (comments) {\n                if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice) {\n                    comments.firstChild.click();\n                }\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.clearCurrentSelectedAnnotation = function () {\n        if (this.currentTextMarkupAnnotation) {\n            this.clearAnnotationSelection(this.selectTextMarkupCurrentPage);\n            var currentAnnot = this.currentTextMarkupAnnotation;\n            this.pdfViewer.fireAnnotationUnSelect(currentAnnot.annotName, currentAnnot.pageNumber, currentAnnot);\n            this.currentTextMarkupAnnotation = null;\n            this.clearCurrentAnnotation();\n        }\n    };\n    /**\n     * @param {MouseEvent} event - It describes about the event\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.onTextMarkupAnnotationMouseMove = function (event) {\n        var _this = this;\n        var eventTarget = event.target;\n        var pageIndex = parseInt(eventTarget.id.split('_text_')[1], 10) || parseInt(eventTarget.id.split('_textLayer_')[1], 10) || parseInt(eventTarget.id.split('_annotationCanvas_')[1], 10);\n        if (event.target && (eventTarget.id.indexOf('_text') > -1 || eventTarget.id.indexOf('_annotationCanvas') > -1 || eventTarget.classList.contains('e-pv-hyperlink')) && this.pdfViewer.annotation) {\n            pageIndex = this.pdfViewer.annotation.getEventPageNumber(event);\n            // Need to be check both canvases. The 'blendAnnotationsIntoCanvas' is used for highlight annotations.\n            ['_annotationCanvas_', '_blendAnnotationsIntoCanvas_'].forEach(function (id) {\n                var canvas = _this.pdfViewerBase.getElement(id + pageIndex);\n                var currentAnnot = _this.getCurrentMarkupAnnotation(event.clientX, event.clientY, pageIndex, canvas);\n                if (currentAnnot) {\n                    var eventTarget_1 = event.target;\n                    eventTarget_1.style.cursor = 'pointer';\n                    var currentPosition = _this.pdfViewerBase.getMousePosition(event);\n                    var relativePosition = _this.pdfViewerBase.relativePosition(event);\n                    var viewerPositions = { left: relativePosition.x, top: relativePosition.y };\n                    var mousePositions = { left: currentPosition.x, top: currentPosition.y };\n                    var annotationSettings = { opacity: currentAnnot.opacity, color: currentAnnot.color,\n                        author: currentAnnot.author, subject: currentAnnot.subject, modifiedDate: currentAnnot.modifiedDate };\n                    _this.pdfViewerBase.isMousedOver = true;\n                    _this.pdfViewer.fireAnnotationMouseover(currentAnnot.annotName, currentAnnot.pageNumber, currentAnnot.textMarkupAnnotationType, currentAnnot.bounds, annotationSettings, mousePositions, viewerPositions);\n                    // this.showPopupNote(event, currentAnnot);\n                }\n                else {\n                    _this.pdfViewer.annotationModule.hidePopupNote();\n                    if (_this.pdfViewerBase.isPanMode && !_this.pdfViewerBase.getAnnotationToolStatus()) {\n                        eventTarget.style.cursor = 'grab';\n                    }\n                    if (_this.pdfViewerBase.isMousedOver && !_this.pdfViewerBase.isFormFieldMousedOver) {\n                        _this.pdfViewer.fireAnnotationMouseLeave(pageIndex);\n                        _this.pdfViewerBase.isMousedOver = false;\n                    }\n                }\n            });\n        }\n    };\n    TextMarkupAnnotation.prototype.showPopupNote = function (event, annotation) {\n        if (annotation.note) {\n            this.pdfViewer.annotationModule.showPopupNote(event, annotation.color, annotation.author, annotation.note, annotation.textMarkupAnnotationType);\n        }\n    };\n    TextMarkupAnnotation.prototype.getCurrentMarkupAnnotation = function (clientX, clientY, pageNumber, canvas) {\n        var currentTextMarkupAnnotations = [];\n        if (canvas) {\n            var canvasParentPosition = canvas.parentElement.getBoundingClientRect();\n            if (canvas.clientWidth !== canvas.parentElement.clientWidth) {\n                canvasParentPosition = canvas.getBoundingClientRect();\n            }\n            var leftClickPosition = clientX - canvasParentPosition.left;\n            var topClickPosition = clientY - canvasParentPosition.top;\n            var annotationList = this.getAnnotations(pageNumber, null);\n            var isAnnotationGot = false;\n            if (annotationList) {\n                for (var i = 0; i < annotationList.length; i++) {\n                    var annotation = annotationList[parseInt(i.toString(), 10)];\n                    for (var j = 0; j < annotation.bounds.length; j++) {\n                        var bound = annotation.bounds[parseInt(j.toString(), 10)];\n                        var left = bound.left ? bound.left : bound.Left;\n                        var top_2 = bound.top ? bound.top : bound.Top;\n                        var width = bound.width ? bound.width : bound.Width;\n                        var height = bound.height ? bound.height : bound.Height;\n                        if (leftClickPosition >= this.getMagnifiedValue(left, this.pdfViewerBase.getZoomFactor()) &&\n                            leftClickPosition <= this.getMagnifiedValue(left + width, this.pdfViewerBase.getZoomFactor()) &&\n                            topClickPosition >= this.getMagnifiedValue(top_2, this.pdfViewerBase.getZoomFactor()) &&\n                            topClickPosition <= this.getMagnifiedValue(top_2 + height, this.pdfViewerBase.getZoomFactor())) {\n                            currentTextMarkupAnnotations.push(annotation);\n                            isAnnotationGot = true;\n                        }\n                        else {\n                            if (isAnnotationGot) {\n                                isAnnotationGot = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            var currentAnnot = null;\n            if (currentTextMarkupAnnotations.length > 1) {\n                currentAnnot = this.compareCurrentAnnotations(currentTextMarkupAnnotations);\n            }\n            else if (currentTextMarkupAnnotations.length === 1) {\n                currentAnnot = currentTextMarkupAnnotations[0];\n            }\n            return currentAnnot;\n        }\n        else {\n            return null;\n        }\n    };\n    TextMarkupAnnotation.prototype.compareCurrentAnnotations = function (annotations) {\n        var previousX;\n        var currentAnnotation = null;\n        for (var i = 0; i < annotations.length; i++) {\n            if (i === annotations.length - 1) {\n                break;\n            }\n            var firstAnnotBounds = annotations[parseInt(i.toString(), 10)].bounds;\n            var firstXposition = firstAnnotBounds[0].left ? firstAnnotBounds[0].left : firstAnnotBounds[0].Left;\n            var firstYposition = firstAnnotBounds[0].top ? firstAnnotBounds[0].top : firstAnnotBounds[0].Top;\n            var secondAnnotBounds = annotations[i + 1].bounds;\n            var secondXposition = secondAnnotBounds[0].left ? secondAnnotBounds[0].left : secondAnnotBounds[0].Left;\n            var secondYposition = secondAnnotBounds[0].top ? secondAnnotBounds[0].top : secondAnnotBounds[0].Top;\n            if ((firstXposition < secondXposition) || (firstYposition < secondYposition)) {\n                previousX = secondXposition;\n                currentAnnotation = annotations[i + 1];\n            }\n            else {\n                previousX = firstXposition;\n                currentAnnotation = annotations[parseInt(i.toString(), 10)];\n            }\n            if (previousX && (i === (annotations.length - 2))) {\n                if ((previousX === firstXposition) && (previousX === secondXposition)) {\n                    previousX = secondXposition;\n                    currentAnnotation = annotations[i + 1];\n                }\n            }\n        }\n        return currentAnnotation;\n    };\n    /**\n     * @param {number} pageNumber - It describes about the pageNumber\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.clearAnnotationSelection = function (pageNumber) {\n        var _this = this;\n        // Styles need to be applied to both canvases. The 'blendAnnotationsIntoCanvas' is used for highlight annotations.\n        var canvasIds = [\n            '_annotationCanvas_' + pageNumber,\n            '_blendAnnotationsIntoCanvas_' + pageNumber\n        ];\n        canvasIds.forEach(function (id) {\n            var canvas = _this.pdfViewerBase.getElement(id);\n            if (canvas) {\n                var context = canvas.getContext('2d');\n                context.setLineDash([]);\n                _this.pdfViewer.annotationModule.renderAnnotations(pageNumber, null, null, null);\n            }\n        });\n    };\n    /**\n     * @param {ITextMarkupAnnotation} annotation - It describes about the annotation\n     * @param {HTMLElement} canvas - It describes about the canvas\n     * @param {number} pageNumber - It describes about the page number\n     * @param {MouseEvent} event - It describes about the event\n     * @param {boolean} isProgrammaticSelection - It describes about the programmactic selection\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.selectAnnotation = function (annotation, canvas, pageNumber, event, isProgrammaticSelection) {\n        if (this.pdfViewer.selectedItems.annotations[0]) {\n            this.pdfViewer.clearSelection(this.pdfViewer.selectedItems.annotations[0].pageIndex);\n            this.pdfViewer.clearSelection(this.selectTextMarkupCurrentPage);\n        }\n        var isLock = false;\n        if (annotation.annotationSettings && annotation.annotationSettings.isLock) {\n            isLock = annotation.annotationSettings.isLock;\n            if (isLock && this.pdfViewer.annotationModule.checkAllowedInteractions('Select', annotation)) {\n                isLock = false;\n            }\n        }\n        if (!isLock) {\n            var isCurrentTextMarkup = false;\n            if (!this.currentTextMarkupAnnotation) {\n                isCurrentTextMarkup = true;\n            }\n            if (this.selectedTextMarkup && annotation && !isProgrammaticSelection) {\n                if (this.selectedTextMarkup.annotName === annotation.annotName) {\n                    isCurrentTextMarkup = false;\n                }\n                else {\n                    isCurrentTextMarkup = true;\n                }\n            }\n            if (!isNaN(pageNumber)) {\n                this.selectTextMarkupCurrentPage = pageNumber;\n                this.currentTextMarkupAnnotation = annotation;\n                annotation = this.retreiveTextIndex(annotation);\n                this.currentTextMarkupAnnotation = annotation;\n            }\n            if (this.isSelectedAnnotation && this.pdfViewer.textSelectionModule) {\n                this.pdfViewerBase.isSelection = true;\n                this.updateAnnotationBounds();\n            }\n            var currentEvent = event;\n            if (this.isEnableTextMarkupResizer(annotation.textMarkupAnnotationType) && annotation && currentEvent &&\n                !currentEvent.touches) {\n                this.updateCurrentResizerPosition(annotation);\n            }\n            this.drawAnnotationSelector(annotation, this.currentTextMarkupAnnotation, canvas);\n            if (annotation.isMultiSelect && annotation.annotNameCollection) {\n                this.selectMultiPageAnnotations(annotation);\n            }\n            if (annotation.annotName !== '' && !this.isNewAnnotation) {\n                if (isCurrentTextMarkup) {\n                    var isSelected = false;\n                    if (!currentEvent) {\n                        isSelected = true;\n                    }\n                    this.pdfViewer.annotationModule.annotationSelect(annotation.annotName, this.selectTextMarkupCurrentPage, annotation, null, false, isSelected);\n                    this.selectedTextMarkup = null;\n                }\n            }\n            if (annotation && this.isEnableTextMarkupResizer(annotation.textMarkupAnnotationType)) {\n                this.isTextMarkupAnnotationMode = true;\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.updateCurrentResizerPosition = function (annotation) {\n        if (!annotation) {\n            annotation = this.currentTextMarkupAnnotation;\n        }\n        if (annotation) {\n            if (this.isEnableTextMarkupResizer(annotation.textMarkupAnnotationType) && annotation) {\n                var textElement = this.pdfViewerBase.getElement('_textLayer_' + this.selectTextMarkupCurrentPage);\n                if (textElement) {\n                    var boundingRect = textElement.getBoundingClientRect();\n                    var left = annotation.bounds[0].left ? annotation.bounds[0].left : annotation.bounds[0].Left;\n                    var top_3 = annotation.bounds[0].top ? annotation.bounds[0].top : annotation.bounds[0].Top;\n                    this.updateLeftposition(left * this.pdfViewerBase.getZoomFactor() + boundingRect.left, (boundingRect.top + top_3), true);\n                    var endPosition = annotation.bounds[annotation.bounds.length - 1];\n                    var endLeft = endPosition.left ? endPosition.left : endPosition.Left;\n                    var endTop = endPosition.top ? endPosition.top : endPosition.Top;\n                    var endWidth = endPosition.width ? endPosition.width : endPosition.Width;\n                    this.updatePosition((endLeft + endWidth) * this.pdfViewerBase.getZoomFactor() + boundingRect.left, (endTop + boundingRect.top), true);\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.drawAnnotationSelectRect = function (canvas, x, y, width, height, annotation) {\n        var ratio = this.pdfViewerBase.getZoomRatio();\n        if (canvas) {\n            var context = canvas.getContext('2d');\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            context.beginPath();\n            if (typeof (annotation).annotationSelectorSettings === 'string') {\n                var lineDash = JSON.parse(annotation.annotationSelectorSettings).selectorLineDashArray.length === 0 ?\n                    [4] : JSON.parse(annotation.annotationSelectorSettings).selectorLineDashArray;\n                if (lineDash.length > 2) {\n                    lineDash = [lineDash[0], lineDash[1]];\n                }\n                context.setLineDash(lineDash);\n                context.globalAlpha = 1;\n                context.rect(x * ratio, y * ratio, width * ratio, height * ratio);\n                context.closePath();\n                var borderColor = JSON.parse(annotation.annotationSelectorSettings).selectionBorderColor === '' ? '#0000ff' : JSON.parse(annotation.annotationSelectorSettings).selectionBorderColor;\n                context.strokeStyle = borderColor;\n                context.lineWidth = JSON.parse(annotation.annotationSelectorSettings).selectionBorderThickness === 1 ?\n                    1 : (annotation.annotationSelectorSettings).selectionBorderThickness;\n                context.stroke();\n                context.save();\n            }\n            else {\n                var lineDash = (annotation.annotationSelectorSettings).selectorLineDashArray.length === 0 ? [4] :\n                    (annotation.annotationSelectorSettings).selectorLineDashArray;\n                if (lineDash.length > 2) {\n                    lineDash = [lineDash[0], lineDash[1]];\n                }\n                context.setLineDash(lineDash);\n                context.globalAlpha = 1;\n                context.rect(x * ratio, y * ratio, width * ratio, height * ratio);\n                context.closePath();\n                var borderColor = (annotation.annotationSelectorSettings).selectionBorderColor === '' ? '#0000ff' : (annotation.annotationSelectorSettings).selectionBorderColor;\n                context.strokeStyle = borderColor;\n                context.lineWidth = (annotation.annotationSelectorSettings).selectionBorderThickness ? 1 :\n                    (annotation.annotationSelectorSettings).selectionBorderThickness;\n                context.stroke();\n                context.save();\n            }\n        }\n    };\n    /**\n     * @param {boolean} isEnable - It describes about the isEnable\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.enableAnnotationPropertiesTool = function (isEnable) {\n        if (this.pdfViewer.toolbarModule && this.pdfViewer.toolbarModule.annotationToolbarModule) {\n            this.pdfViewer.toolbarModule.annotationToolbarModule.colorDropDownElementInBlazor = this.pdfViewer.element.querySelector('.e-pv-annotation-color-container');\n        }\n        if (this.pdfViewer.toolbarModule && this.pdfViewer.toolbarModule.annotationToolbarModule) {\n            if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice) {\n                this.pdfViewer.toolbarModule.annotationToolbarModule.createMobileAnnotationToolbar(isEnable);\n            }\n        }\n        if (this.pdfViewer.toolbarModule && this.pdfViewer.toolbarModule.annotationToolbarModule &&\n            this.pdfViewer.toolbarModule.annotationToolbarModule.isMobileAnnotEnabled &&\n            this.pdfViewer.selectedItems.annotations.length === 0) {\n            if (this.pdfViewer.toolbarModule.annotationToolbarModule) {\n                this.pdfViewer.toolbarModule.annotationToolbarModule.selectAnnotationDeleteItem(isEnable);\n                var enable = isEnable;\n                if (this.isTextMarkupAnnotationMode) {\n                    enable = true;\n                }\n                this.pdfViewer.toolbarModule.annotationToolbarModule.enableTextMarkupAnnotationPropertiesTools(enable);\n                if (this.currentTextMarkupAnnotation) {\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.\n                            updateColorInIcon(this.pdfViewer.toolbarModule.annotationToolbarModule.colorDropDownElement, this.currentTextMarkupAnnotation.color);\n                    }\n                    else {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.\n                            updateColorInIcon(this.pdfViewer.toolbarModule.annotationToolbarModule.colorDropDownElementInBlazor, this.currentTextMarkupAnnotation.color);\n                    }\n                }\n                else {\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.isTextMarkupAnnotationMode) && !this.isTextMarkupAnnotationMode) {\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.updateColorInIcon(this.pdfViewer.toolbarModule.annotationToolbarModule.colorDropDownElement, '#000000');\n                        }\n                        else {\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.updateColorInIcon(this.pdfViewer.toolbarModule.annotationToolbarModule.colorDropDownElementInBlazor, '#000000');\n                        }\n                    }\n                    else {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.setCurrentColorInPicker();\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.maintainAnnotationSelection = function () {\n        if (this.currentTextMarkupAnnotation) {\n            var canvasId = this.currentTextMarkupAnnotation.textMarkupAnnotationType === 'Highlight' ? '_blendAnnotationsIntoCanvas_' : '_annotationCanvas_';\n            var canvas = (canvasId === '_blendAnnotationsIntoCanvas_') ? this.pdfViewerBase.getElement(canvasId + this.selectTextMarkupCurrentPage) :\n                this.pdfViewerBase.getAnnotationCanvas(canvasId, this.selectTextMarkupCurrentPage);\n            if (canvas) {\n                this.selectAnnotation(this.currentTextMarkupAnnotation, canvas, this.selectTextMarkupCurrentPage);\n            }\n        }\n    };\n    // private storeAnnotations(pageNumber: number, annotation: ITextMarkupAnnotation): number {\n    //     let storeObject: any = PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n    //     let index: number = 0;\n    //     if (!storeObject) {\n    //         let markupAnnotation: IPageAnnotations = { pageIndex: pageNumber, annotations: [] };\n    //         markupAnnotation.annotations.push(annotation);\n    //         index = markupAnnotation.annotations.indexOf(annotation);\n    //         let annotationCollection: IPageAnnotations[] = [];\n    //         annotationCollection.push(markupAnnotation);\n    //         let annotationStringified: string = JSON.stringify(annotationCollection);\n    //         PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_textMarkup', annotationStringified);\n    //     } else {\n    //         let annotObject: IPageAnnotations[] = JSON.parse(storeObject);\n    //         PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n    //         let pageIndex: number = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageNumber);\n    //         if (annotObject[pageIndex]) {\n    //             (annotObject[pageIndex] as IPageAnnotations).annotations.push(annotation);\n    //             index = (annotObject[pageIndex] as IPageAnnotations).annotations.indexOf(annotation);\n    //         } else {\n    //             let markupAnnotation: IPageAnnotations = { pageIndex: pageNumber, annotations: [] };\n    //             markupAnnotation.annotations.push(annotation);\n    //             index = markupAnnotation.annotations.indexOf(annotation);\n    //             annotObject.push(markupAnnotation);\n    //         }\n    //         let annotationStringified: string = JSON.stringify(annotObject);\n    //         PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_textMarkup', annotationStringified);\n    //     }\n    //     return index;\n    // }\n    /**\n     * @param {ITextMarkupAnnotation} pageAnnotations - It describes about the page annotations\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.manageAnnotations = function (pageAnnotations, pageNumber) {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_textMarkup'];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            if (!this.pdfViewerBase.isStorageExceed) {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n            }\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageNumber);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotObject[parseInt(index.toString(), 10)].annotations = pageAnnotations;\n            }\n            var annotationStringified = JSON.stringify(annotObject);\n            if (this.pdfViewerBase.isStorageExceed) {\n                this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_textMarkup'] = annotationStringified;\n            }\n            else {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_textMarkup', annotationStringified);\n            }\n        }\n    };\n    /**\n     * @param {number} pageIndex - It describes about the pageIndex\n     * @param {any} textMarkupAnnotations - It describes about the text markup annotations\n     * @param {string} id -It describes about the id\n     * @private\n     * @returns {any} - any\n     */\n    TextMarkupAnnotation.prototype.getAnnotations = function (pageIndex, textMarkupAnnotations, id) {\n        var annotationCollection;\n        if (id == null || id === undefined) {\n            id = '_annotations_textMarkup';\n        }\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + id);\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + id];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageIndex);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotationCollection = annotObject[parseInt(index.toString(), 10)].annotations;\n            }\n            else {\n                annotationCollection = textMarkupAnnotations;\n            }\n        }\n        else {\n            annotationCollection = textMarkupAnnotations;\n        }\n        return annotationCollection;\n    };\n    TextMarkupAnnotation.prototype.getAddedAnnotation = function (type, color, opacity, bounds, author, subject, predefinedDate, note, isCommentLock, rect, pageNumber, textContent, startIndex, endIndex, isMultiSelect, allowedInteractions, annotationRotate) {\n        var modifiedDate = predefinedDate ? predefinedDate : this.pdfViewer.annotation.\n            stickyNotesAnnotationModule.getDateAndTime();\n        var annotationName = this.pdfViewer.annotation.createGUID();\n        var commentsDivid = this.pdfViewer.annotation.stickyNotesAnnotationModule.addComments('textMarkup', pageNumber + 1, type);\n        if (commentsDivid) {\n            document.getElementById(commentsDivid).id = annotationName;\n        }\n        var annotationSettings = this.pdfViewer.annotationSettings;\n        var isPrint = this.getIsPrintValue(type);\n        var annotation = {\n            textMarkupAnnotationType: type, color: color, opacity: opacity, bounds: bounds, author: author,\n            allowedInteractions: allowedInteractions, subject: subject, modifiedDate: modifiedDate, note: note, rect: rect,\n            annotName: annotationName, comments: [], review: { state: '', stateModel: '', author: author, modifiedDate: modifiedDate }, shapeAnnotationType: 'textMarkup', pageNumber: pageNumber,\n            textMarkupContent: textContent, textMarkupStartIndex: startIndex, textMarkupEndIndex: endIndex,\n            isMultiSelect: isMultiSelect, annotationSelectorSettings: this.getSelector(type),\n            customData: this.pdfViewer.annotation.getTextMarkupData(subject), annotationAddMode: this.annotationAddMode,\n            annotationSettings: annotationSettings, isPrint: isPrint, isCommentLock: isCommentLock, isAnnotationRotated: false,\n            annotationRotation: annotationRotate,\n            isLocked: false\n        };\n        annotation.annotationSettings = this.pdfViewer.annotationModule.updateAnnotationSettings(annotation);\n        if (isMultiSelect) {\n            this.multiPageCollection.push(annotation);\n        }\n        var isSkip = false;\n        if (isMultiSelect && this.isExtended) {\n            isSkip = true;\n        }\n        if (document.getElementById(annotationName) && !isSkip) {\n            document.getElementById(annotationName).addEventListener('mouseup', this.annotationDivSelect(annotation, pageNumber));\n        }\n        var storedIndex = this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotation, '_annotations_textMarkup');\n        this.pdfViewer.annotationModule.addAction(pageNumber, storedIndex, annotation, 'Text Markup Added', null);\n        return annotation;\n    };\n    TextMarkupAnnotation.prototype.getSelector = function (type) {\n        var selector = this.pdfViewer.annotationSelectorSettings;\n        if (type === 'Highlight' && this.pdfViewer.highlightSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.highlightSettings.annotationSelectorSettings;\n        }\n        else if (type === 'Underline' && this.pdfViewer.underlineSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.underlineSettings.annotationSelectorSettings;\n        }\n        else if (type === 'Strikethrough' && this.pdfViewer.strikethroughSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.strikethroughSettings.annotationSelectorSettings;\n        }\n        return selector;\n    };\n    TextMarkupAnnotation.prototype.getIsPrintValue = function (type) {\n        var isPrint = true;\n        if (type === 'Highlight') {\n            isPrint = this.pdfViewer.highlightSettings.isPrint;\n        }\n        if (type === 'Underline') {\n            isPrint = this.pdfViewer.underlineSettings.isPrint;\n        }\n        if (type === 'Strikethrough') {\n            isPrint = this.pdfViewer.strikethroughSettings.isPrint;\n        }\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(isPrint)) {\n            isPrint = true;\n        }\n        return isPrint;\n    };\n    TextMarkupAnnotation.prototype.annotationDivSelect = function (annotation, pageNumber) {\n        var canvasId = annotation.textMarkupAnnotationType === 'Highlight' ? '_blendAnnotationsIntoCanvas_' : '_annotationCanvas_';\n        var canvas = (canvasId === '_blendAnnotationsIntoCanvas_') ? this.pdfViewerBase.getElement(canvasId + pageNumber) :\n            this.pdfViewerBase.getAnnotationCanvas(canvasId, pageNumber);\n        this.selectAnnotation(annotation, canvas, pageNumber);\n        if (this.pdfViewer.toolbarModule) {\n            if (this.pdfViewer.toolbarModule.annotationToolbarModule && this.pdfViewer.enableAnnotationToolbar) {\n                this.pdfViewer.toolbarModule.annotationToolbarModule.clearShapeMode();\n                this.pdfViewer.toolbarModule.annotationToolbarModule.clearMeasureMode();\n                var isLock = false;\n                if (annotation.annotationSettings && annotation.annotationSettings.isLock) {\n                    isLock = annotation.annotationSettings.isLock;\n                }\n                if (isLock) {\n                    if (this.pdfViewer.annotationModule.checkAllowedInteractions('PropertyChange', annotation)) {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.enableTextMarkupAnnotationPropertiesTools(true);\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.setCurrentColorInPicker();\n                    }\n                    if (this.pdfViewer.annotationModule.checkAllowedInteractions('Delete', annotation)) {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.selectAnnotationDeleteItem(true);\n                    }\n                }\n                else {\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.enableTextMarkupAnnotationPropertiesTools(true);\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.selectAnnotationDeleteItem(true);\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.setCurrentColorInPicker();\n                }\n                this.pdfViewer.toolbarModule.annotationToolbarModule.isToolbarHidden = true;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.showAnnotationToolbar(this.pdfViewer.toolbarModule.annotationItem);\n                }\n            }\n        }\n    };\n    TextMarkupAnnotation.prototype.getPageContext = function (pageNumber, canvasId) {\n        var canvas;\n        if (canvasId === '_annotationCanvas_') {\n            canvas = this.pdfViewerBase.getAnnotationCanvas(canvasId, pageNumber);\n        }\n        else {\n            canvas = this.pdfViewerBase.getElement(canvasId + pageNumber);\n        }\n        var context = null;\n        if (canvas) {\n            context = canvas.getContext('2d');\n        }\n        return context;\n    };\n    TextMarkupAnnotation.prototype.getDefaultValue = function (value) {\n        return value / this.pdfViewerBase.getZoomFactor();\n    };\n    TextMarkupAnnotation.prototype.getMagnifiedValue = function (value, factor) {\n        return value * factor;\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.saveImportedTextMarkupAnnotations = function (annotation, pageNumber) {\n        var annotationObject = null;\n        annotation.Author = this.pdfViewer.annotationModule.updateAnnotationAuthor('textMarkup', annotation.Subject);\n        annotation.allowedInteractions = this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n        annotation.AnnotationSettings = annotation.AnnotationSettings ?\n            annotation.AnnotationSettings : this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.customStampSettings);\n        annotationObject = {\n            textMarkupAnnotationType: annotation.TextMarkupAnnotationType, color: annotation.Color, opacity: annotation.Opacity,\n            allowedInteractions: annotation.allowedInteractions, bounds: annotation.Bounds, author: annotation.Author,\n            subject: annotation.Subject, modifiedDate: annotation.ModifiedDate, note: annotation.Note, rect: annotation.Rect,\n            annotName: annotation.AnnotName, isLocked: annotation.IsLocked,\n            comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author), review: { state: annotation.State,\n                stateModel: annotation.StateModel,\n                modifiedDate: annotation.ModifiedDate, author: annotation.Author },\n            shapeAnnotationType: 'textMarkup',\n            pageNumber: pageNumber, textMarkupContent: '', textMarkupStartIndex: 0,\n            textMarkupEndIndex: 0, annotationSelectorSettings: this.getSettings(annotation),\n            customData: this.pdfViewer.annotation.getCustomData(annotation),\n            isMultiSelect: annotation.IsMultiSelect, annotNameCollection: annotation.AnnotNameCollection,\n            annotpageNumbers: annotation.AnnotpageNumbers,\n            annotationAddMode: this.annotationAddMode, annotationSettings: annotation.AnnotationSettings,\n            isPrint: annotation.IsPrint, isCommentLock: annotation.IsCommentLock, isAnnotationRotated: false\n        };\n        this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotationObject, '_annotations_textMarkup');\n    };\n    /**\n     * @param {any} annotation - It describes about the annotation\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {any} - any\n     */\n    TextMarkupAnnotation.prototype.updateTextMarkupAnnotationCollections = function (annotation, pageNumber) {\n        var annotationObject = null;\n        annotation.allowedInteractions = annotation.AllowedInteractions ?\n            annotation.AllowedInteractions : this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n        annotation.AnnotationSettings = annotation.AnnotationSettings ?\n            annotation.AnnotationSettings : this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.customStampSettings);\n        if (annotation.IsLocked) {\n            annotation.AnnotationSettings.isLock = annotation.IsLocked;\n        }\n        annotationObject = {\n            textMarkupAnnotationType: annotation.TextMarkupAnnotationType, allowedInteractions: annotation.allowedInteractions,\n            color: annotation.Color, opacity: annotation.Opacity, bounds: annotation.Bounds, author: annotation.Author,\n            subject: annotation.Subject, modifiedDate: annotation.ModifiedDate, note: annotation.Note, rect: annotation.Rect,\n            annotationId: annotation.AnnotName, comments: this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author), review: { state: annotation.State, stateModel: annotation.StateModel, modifiedDate: annotation.ModifiedDate, author: annotation.Author }, shapeAnnotationType: 'textMarkup', pageNumber: pageNumber, isMultiSelect: annotation.IsMultiSelect, annotNameCollection: annotation.AnnotNameCollection, annotpageNumbers: annotation.AnnotpageNumbers, customData: this.pdfViewer.annotation.getCustomData(annotation),\n            annotationSettings: annotation.AnnotationSettings, isLocked: annotation.IsLocked, isPrint: annotation.IsPrint,\n            isCommentLock: annotation.IsCommentLock\n        };\n        return annotationObject;\n    };\n    /**\n     * @param {string} textMarkUpSettings - It describes about the textmarkup settings\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.updateTextMarkupSettings = function (textMarkUpSettings) {\n        if (textMarkUpSettings === 'highlightSettings') {\n            this.highlightColor = this.pdfViewer.highlightSettings.color ? this.pdfViewer.highlightSettings.color : this.highlightColor;\n            this.highlightOpacity = this.pdfViewer.highlightSettings.opacity ?\n                this.pdfViewer.highlightSettings.opacity : this.highlightOpacity;\n        }\n        if (textMarkUpSettings === 'underlineSettings') {\n            this.underlineColor = this.pdfViewer.underlineSettings.color ? this.pdfViewer.underlineSettings.color : this.underlineColor;\n            this.underlineOpacity = this.pdfViewer.underlineSettings.opacity ?\n                this.pdfViewer.underlineSettings.opacity : this.underlineOpacity;\n        }\n        if (textMarkUpSettings === 'strikethroughSettings') {\n            this.strikethroughColor = this.pdfViewer.strikethroughSettings.color ?\n                this.pdfViewer.strikethroughSettings.color : this.strikethroughColor;\n            this.strikethroughOpacity = this.pdfViewer.strikethroughSettings.opacity ?\n                this.pdfViewer.strikethroughSettings.opacity : this.strikethroughOpacity;\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    TextMarkupAnnotation.prototype.clear = function () {\n        this.selectTextMarkupCurrentPage = null;\n        this.currentTextMarkupAnnotation = null;\n        this.annotationClickPosition = null;\n        _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n    };\n    /**\n     * Get vertex points properties\n     *\n     * @param {any} points - It describes about the points\n     * @private\n     * @returns {any} - any\n     */\n    TextMarkupAnnotation.prototype.getOffsetPoints = function (points) {\n        var offsetPoints = [];\n        //Converting points model into vertex property\n        for (var j = 0; j < points.length; j++) {\n            offsetPoints[parseInt(j.toString(), 10)] = { X: points[parseInt(j.toString(), 10)].x,\n                Y: points[parseInt(j.toString(), 10)].y, Width: points[parseInt(j.toString(), 10)].width,\n                Height: points[parseInt(j.toString(), 10)].height, Left: points[parseInt(j.toString(), 10)].x,\n                Top: points[parseInt(j.toString(), 10)].y };\n        }\n        return offsetPoints;\n    };\n    /**\n     * This method used to add annotations with using program.\n     *\n     * @param {AnnotationType} annotationType - It describes the annotation type\n     * @param {any} annotationObject - It describes type of annotation object\n     * @returns {object} - object\n     * @private\n     */\n    TextMarkupAnnotation.prototype.updateAddAnnotationDetails = function (annotationType, annotationObject) {\n        //Creating new object if annotationObject is null\n        if (!annotationObject) {\n            annotationObject = { pageNumber: 0 };\n        }\n        //Initialize the annotation settings\n        var annotSelectorSettings = null;\n        var annotallowedInteractions = null;\n        var textMarkupAnnotationType = '';\n        var annotSettings = null;\n        var color = '';\n        var bounds = [];\n        //Creating the CurrentDate and Annotation name\n        var currentDateString = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n        var annotationName = this.pdfViewer.annotation.createGUID();\n        if (annotationType === 'Highlight') {\n            //Creating annotation settings\n            annotSelectorSettings = this.pdfViewer.highlightSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotSelectorSettings);\n            annotSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.highlightSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('textMarkup', annotationType);\n            annotallowedInteractions = this.pdfViewer.highlightSettings.allowedInteractions ?\n                this.pdfViewer.highlightSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            textMarkupAnnotationType = 'Highlight';\n            color = annotationObject.color ? annotationObject.color : '#FFDF56';\n        }\n        else if (annotationType === 'Underline') {\n            //Creating annotation settings\n            annotSelectorSettings = this.pdfViewer.underlineSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotSelectorSettings);\n            annotSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.underlineSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('textMarkup', annotationType);\n            annotallowedInteractions = this.pdfViewer.underlineSettings.allowedInteractions ?\n                this.pdfViewer.underlineSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            textMarkupAnnotationType = 'Underline';\n            color = annotationObject.color ? annotationObject.color : '#00ff00';\n        }\n        else if (annotationType === 'Strikethrough') {\n            //Creating annotation settings\n            annotSelectorSettings = this.pdfViewer.strikethroughSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(annotSelectorSettings);\n            annotSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.strikethroughSettings);\n            annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('textMarkup', annotationType);\n            annotallowedInteractions = this.pdfViewer.strikethroughSettings.allowedInteractions ?\n                this.pdfViewer.strikethroughSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            textMarkupAnnotationType = 'Strikethrough';\n            color = annotationObject.color ? annotationObject.color : '#ff0000';\n        }\n        annotSettings.isLock = annotationObject.isLock ? annotationObject.isLock : annotSettings.isLock;\n        //Creating the offset points\n        if (annotationObject.bounds) {\n            bounds = this.getOffsetPoints(annotationObject.bounds);\n        }\n        else {\n            bounds = [{ X: 1, Y: 1, Width: 100, Height: 14, Left: 1, Top: 1, Location: { X: 1, Y: 1 },\n                    Size: { Height: 14, IsEmpty: false, Width: 100 } }];\n        }\n        //Creating Annotation objects with it's proper properties\n        var textMarkupAnnotation = [];\n        var textmarkup = {\n            AllowedInteractions: annotationObject.allowedInteractions ? annotationObject.allowedInteractions : annotallowedInteractions,\n            AnnotName: annotationName,\n            AnnotNameCollection: null,\n            AnnotType: 'textMarkup',\n            AnnotationSelectorSettings: annotationObject.annotationSelectorSettings ?\n                annotationObject.annotationSelectorSettings : annotSelectorSettings,\n            AnnotationSettings: annotSettings,\n            Author: annotationObject.author ? annotationObject.author : 'Guest',\n            Bounds: bounds,\n            Color: annotationObject.color ? annotationObject.color : color,\n            Comments: null,\n            CreatedDate: currentDateString,\n            CustomData: annotationObject.customData ? annotationObject.customData : null,\n            ExistingCustomData: null,\n            EnableMultiPageAnnotation: annotationObject.enableMultiPageAnnotation ? annotationObject.enableMultiPageAnnotation : false,\n            EnableTextMarkupResizer: annotationObject.enableTextMarkupResizer ? annotationObject.enableTextMarkupResizer : false,\n            IsCommentLock: false,\n            IsMultiSelect: false,\n            IsLocked: annotationObject.isLock ? annotationObject.isLock : false,\n            IsLock: annotationObject.isLock ? annotationObject.isLock : false,\n            IsPrint: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotationObject.isPrint) ? annotationObject.isPrint : true,\n            ModifiedDate: '',\n            Note: '',\n            Opacity: annotationObject.opacity ? annotationObject.opacity : 1,\n            Rect: {},\n            State: '',\n            StateModel: '',\n            Subject: annotationObject.subject ? annotationObject.subject : textMarkupAnnotationType,\n            TextMarkupAnnotationType: textMarkupAnnotationType\n        };\n        //Adding the annotation object to an array and return it\n        textMarkupAnnotation[0] = textmarkup;\n        return { textMarkupAnnotation: textMarkupAnnotation };\n    };\n    return TextMarkupAnnotation;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/text-markup-annotation.js?");

/***/ })

}]);