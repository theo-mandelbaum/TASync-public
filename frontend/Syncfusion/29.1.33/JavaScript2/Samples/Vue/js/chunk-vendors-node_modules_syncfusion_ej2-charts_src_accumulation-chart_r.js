"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_accumulation-chart_r"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pyramid-series.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pyramid-series.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PyramidSeries: () => (/* binding */ PyramidSeries)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _triangular_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./triangular-base */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/triangular-base.js\");\n/**\n * Defines the behavior of a pyramid series\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `PyramidSeries` module is used to render the `Pyramid` series.\n */\nvar PyramidSeries = /** @class */ (function (_super) {\n    __extends(PyramidSeries, _super);\n    function PyramidSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Defines the path of a pyramid segment.\n     *\n     * @param {AccPoints} point - The points to initialize the segment size.\n     * @param {AccumulationSeries} series - The series for which to define the path.\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @returns {string} - The path of the pyramid segment.\n     */\n    PyramidSeries.prototype.getSegmentData = function (point, series, chart) {\n        var area = series.triangleSize;\n        //top of th series\n        var seriesTop = chart.initialClipRect.y + (chart.initialClipRect.height - area.height) / 2;\n        //consider, if the point is exploded\n        var offset = 0;\n        var extraSpace = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n        var emptySpaceAtLeft = extraSpace + chart.initialClipRect.x;\n        //top and bottom\n        var top = point.yRatio;\n        var bottom = point.yRatio + point.heightRatio;\n        //width of the top and bottom edge\n        var topRadius = 0.5 * (1 - point.yRatio);\n        var bottomRadius = 0.5 * (1 - bottom);\n        top += seriesTop / area.height;\n        bottom += seriesTop / area.height;\n        var line1 = {\n            x: emptySpaceAtLeft + offset + topRadius * area.width,\n            y: top * area.height\n        };\n        var line2 = {\n            x: emptySpaceAtLeft + offset + (1 - topRadius) * area.width,\n            y: top * area.height\n        };\n        var line3 = {\n            x: emptySpaceAtLeft + offset + (1 - bottomRadius) * area.width,\n            y: bottom * area.height\n        };\n        var line4 = {\n            x: emptySpaceAtLeft + offset + bottomRadius * area.width,\n            y: bottom * area.height\n        };\n        var polygon = [line1, line2, line3, line4];\n        this.setLabelLocation(series, point, polygon);\n        var direction = this.findPath(polygon, point, series);\n        return direction;\n    };\n    /**\n     * Initializes the size of the pyramid segments.\n     *\n     * @private\n     * @param {AccPoints[]} points - The points to initialize the segment size.\n     * @param {AccumulationSeries} series - The series for which to initialize properties.\n     * @returns {void}\n     */\n    PyramidSeries.prototype.initializeSizeRatio = function (points, series) {\n        if (series.pyramidMode === 'Linear') {\n            _super.prototype.initializeSizeRatio.call(this, points, series, true);\n        }\n        else {\n            this.calculateSurfaceSegments(series);\n        }\n    };\n    /**\n     * Defines the size of the pyramid segments, the surface of that will reflect the values.\n     *\n     * @param {AccumulationSeries} series - The series for which to initialize properties.\n     * @returns {void}\n     */\n    PyramidSeries.prototype.calculateSurfaceSegments = function (series) {\n        var count = series.points.length;\n        var sumOfValues = series.sumOfPoints;\n        var y = [];\n        var height = [];\n        var gapRatio = Math.min(0, Math.max(series.gapRatio, 1));\n        var gapHeight = series.points.length > 1 ? gapRatio / (count - 1) : 0;\n        var preSum = this.getSurfaceHeight(0, sumOfValues);\n        var currY = 0;\n        for (var i = 0; i < count; i++) {\n            if (series.points[i].visible) {\n                y[i] = currY;\n                height[i] = this.getSurfaceHeight(currY, Math.abs(series.points[i].y));\n                currY += height[i] + gapHeight * preSum;\n            }\n        }\n        var coef = 1 / (currY - gapHeight * preSum);\n        for (var i = 0; i < count; i++) {\n            if (series.points[i].visible) {\n                series.points[i].yRatio = coef * y[i];\n                series.points[i].heightRatio = coef * height[i];\n            }\n        }\n    };\n    /**\n     * Finds the height of pyramid segment.\n     *\n     * @param {number} y - The y-coordinate of the segment's point.\n     * @param {number} surface - The surface area of the segment that reflects the values.\n     * @returns {number} - The height of the pyramid segment.\n     */\n    PyramidSeries.prototype.getSurfaceHeight = function (y, surface) {\n        var result = this.solveQuadraticEquation(1, 2 * y, -surface);\n        return result;\n    };\n    /**\n     * Solves quadratic equation.\n     *\n     * @param {number} a - Coefficient.\n     * @param {number} b - Coefficient.\n     * @param {number} c - Coefficient.\n     * @returns {number} - The height of the pyramid segment.\n     */\n    PyramidSeries.prototype.solveQuadraticEquation = function (a, b, c) {\n        var root1;\n        var root2;\n        var d = b * b - 4 * a * c;\n        if (d >= 0) {\n            var sd = Math.sqrt(d);\n            root1 = (-b - sd) / (2 * a);\n            root2 = (-b + sd) / (2 * a);\n            return Math.max(root1, root2);\n        }\n        return 0;\n    };\n    /**\n     * Renders a pyramid segment.\n     *\n     * @param {AccPoints} point - The point data.\n     * @param {AccumulationSeries} series - The series of the chart.\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @param {PathOption} options - The rendering options for the segment.\n     * @param {Element} seriesGroup - The group element to contain the segment.\n     * @param {boolean} redraw - Specifies whether to redraw the segment.\n     * @param {string} previousRadius - Specifies the previous radius of the pie when animating the individual series point.\n     * @param {Object[]} previousCenter - Specifies the previous center of the pie when animating the individual series point.\n     * @param {boolean} pointAnimation - Specifies whether the point based animation is enabled.\n     * @returns {void}\n     */\n    PyramidSeries.prototype.renderPoint = function (point, series, chart, options, seriesGroup, redraw, previousRadius, previousCenter, pointAnimation) {\n        if (!point.visible) {\n            (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.removeElement)(options.id);\n            return null;\n        }\n        var previousDirection;\n        options.d = this.getSegmentData(point, series, chart);\n        if (pointAnimation && document.getElementById(options.id)) {\n            previousDirection = document.getElementById(options.id).getAttribute('d');\n        }\n        point.midAngle = 0;\n        var element = chart.renderer.drawPath(options);\n        element.setAttribute('role', series.accessibility.accessibilityRole ? series.accessibility.accessibilityRole : 'img');\n        element.setAttribute('tabindex', (point.index === 0 && series.accessibility.focusable) ? String(series.accessibility.tabIndex) : '-1');\n        element.setAttribute('aria-label', series.accessibility.accessibilityDescription ? series.accessibility.accessibilityDescription : (point.x + ': ' + point.y + '%. ' + series.name));\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(false, seriesGroup, element, redraw, pointAnimation ? pointAnimation : undefined, pointAnimation ? 'x' : undefined, pointAnimation ? 'y' : undefined, undefined, pointAnimation ? previousDirection : undefined, undefined, undefined, undefined, pointAnimation ? chart.duration : undefined);\n        if (point.isExplode) {\n            chart.accBaseModule.explodePoints(point.index, chart, true);\n        }\n    };\n    /**\n     * To get the module name of the Pyramid series.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    PyramidSeries.prototype.getModuleName = function () {\n        return 'PyramidSeries';\n    };\n    /**\n     * To destroy the pyramid series.\n     *\n     * @returns {void}\n     * @private\n     */\n    PyramidSeries.prototype.destroy = function () {\n        /**\n         * Destroys the pyramid series.\n         */\n    };\n    return PyramidSeries;\n}(_triangular_base__WEBPACK_IMPORTED_MODULE_2__.TriangularBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/pyramid-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/triangular-base.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/triangular-base.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TriangularBase: () => (/* binding */ TriangularBase)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _accumulation_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./accumulation-base */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/accumulation-base.js\");\n/**\n * Defines the common behavior of funnel and pyramid series\n */\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `TriangularBase` module is used to calculate base functions for funnel and pyramid series.\n *\n * @private\n */\nvar TriangularBase = /** @class */ (function (_super) {\n    __extends(TriangularBase, _super);\n    function TriangularBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Initializes the properties of funnel/pyramid series.\n     *\n     * @private\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @param {AccumulationSeries} series - The series for which to initialize properties.\n     * @returns {void}\n     */\n    TriangularBase.prototype.initProperties = function (chart, series) {\n        var actualChartArea = chart.initialClipRect;\n        series.triangleSize = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.Size((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.width, actualChartArea.width), (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.height, actualChartArea.height));\n        series.neckSize = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.Size((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.neckWidth, actualChartArea.width), (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.neckHeight, actualChartArea.height));\n        this.defaultLabelBound(series, series.dataLabel.visible, series.dataLabel.position, chart);\n        if (series.explodeOffset === '30%') {\n            series.explodeOffset = '25px';\n        }\n        chart.explodeDistance = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.stringToNumber)(series.explodeOffset, actualChartArea.width);\n        var points = series.points;\n        this.initializeSizeRatio(points, series);\n    };\n    /**\n     * Initializes the size of the pyramid/funnel segments.\n     *\n     * @private\n     * @param {AccPoints[]} points - The points to initialize the segment size.\n     * @param {AccumulationSeries} series - The series for which to initialize properties.\n     * @param {boolean} reverse - Indicates whether the pyramid/funnel segments should be reversed.\n     * @returns {void}\n     */\n    TriangularBase.prototype.initializeSizeRatio = function (points, series, reverse) {\n        if (reverse === void 0) { reverse = false; }\n        var sumOfPoints = series.sumOfPoints;\n        //Limiting the ratio within the range of 0 to 1\n        var gapRatio = Math.min(Math.max(series.gapRatio, 0), 1);\n        //% equivalence of a value 1\n        var coEff = (sumOfPoints !== 0) ? 1 / (sumOfPoints * (1 + gapRatio / (1 - gapRatio))) : 0;\n        var spacing = gapRatio / (points.length - 1);\n        var y = 0;\n        //starting from bottom\n        for (var i = points.length - 1; i >= 0; i--) {\n            var index = reverse ? points.length - 1 - i : i;\n            if (points[index].visible) {\n                var height = coEff * points[index].y;\n                points[index].yRatio = y;\n                points[index].heightRatio = height;\n                y += height + spacing;\n            }\n        }\n    };\n    /**\n     * Marks the label location from the set of points that forms a pyramid/funnel segment.\n     *\n     * @private\n     * @param {AccumulationSeries} series - The series for which to mark label locations.\n     * @param {AccPoints} point - The point to mark the label location.\n     * @param {ChartLocation[]} points - The set of points that forms a pyramid/funnel segment.\n     * @returns {void}\n     */\n    TriangularBase.prototype.setLabelLocation = function (series, point, points) {\n        var last = points.length - 1;\n        var bottom = series.type === 'Funnel' ? points.length - 2 : points.length - 1;\n        var x = (points[0].x + points[bottom].x) / 2;\n        var right = (points[1].x + points[bottom - 1].x) / 2;\n        point.region = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.Rect(x, points[0].y, right - x, points[bottom].y - points[0].y);\n        point.symbolLocation = {\n            x: point.region.x + point.region.width / 2,\n            y: point.region.y + point.region.height / 2\n        };\n        point.labelOffset = {\n            x: point.symbolLocation.x - (points[0].x + points[last].x) / 2,\n            y: point.symbolLocation.y - (points[0].y + points[last].y) / 2\n        };\n    };\n    /**\n     * Finds the path to connect the list of points.\n     *\n     * @param {ChartLocation[]} locations - An array of ChartLocation objects representing the points to connect.\n     * @param {AccPoints} point - The current AccPoints object containing the data point information.\n     * @param {string} path - The initial path string to be modified.\n     * @param {number} firstIndex - The index of the first point in the path.\n     * @param {number} lastIndex - The index of the last point in the path.\n     * @param {AccumulationSeries} series - The series object of the Accumulation.\n     * @returns {string} - This string represent the path value of the D attribute.\n     * @Private\n     */\n    TriangularBase.prototype.getPath = function (locations, point, path, firstIndex, lastIndex, series) {\n        var length = series.points.length;\n        var borderRadius = series.borderRadius;\n        var min = Math.min(point.region.width, point.region.height);\n        var funnelMinimum = Math.min(series.neckSize.height, series.neckSize.width);\n        if (funnelMinimum === 0) {\n            funnelMinimum = series.neckSize.height === 0 && series.neckSize.width === 0 ?\n                point.region.height : (series.neckSize.width === 0 ? series.neckSize.height : series.neckSize.width);\n        }\n        borderRadius = borderRadius > min / 2 ? min / 2 : borderRadius;\n        if (series.type === 'Funnel') {\n            borderRadius = (borderRadius > funnelMinimum / 2) ? funnelMinimum / 2 : borderRadius;\n        }\n        var angle = Math.atan2(locations[1].x - locations[2].x, locations[1].y - locations[2].y);\n        var temp = borderRadius;\n        if (series.type === 'Pyramid') {\n            borderRadius = (point.index === lastIndex && length !== 1 && firstIndex !== lastIndex) ? 0 : borderRadius;\n            path += (locations[0].x - (temp * Math.sin(-angle))) + ' ' + (locations[0].y + (-temp * Math.cos(angle))) + ' Q' + locations[0].x + ' ' + locations[0].y + ' '\n                + (locations[0].x + (borderRadius * Math.sin(-angle))) + ' ' + (locations[0].y + (-borderRadius * Math.cos(-angle)));\n            path += ' L' + (locations[1].x + (borderRadius * Math.sin(-angle))) + ' ' + (locations[1].y + (-borderRadius * Math.cos(angle)));\n            borderRadius = point.index === lastIndex ? temp : 0;\n            path += ' L' + (locations[2].x - (temp * Math.sin(-angle))) + ' ' + (locations[2].y - (-temp * Math.cos(angle))) + ' Q' + locations[2].x + ' ' + locations[2].y\n                + ' ' + (locations[2].x - borderRadius) + ' ' + locations[2].y;\n            path += ' L' + (locations[3].x + borderRadius) + ' ' + locations[3].y + ' Q' + locations[3].x + ' ' + locations[3].y + ' '\n                + (locations[3].x + (temp * Math.sin(-angle))) + ' ' + (locations[3].y - (-temp * Math.cos(angle)));\n        }\n        if (series.type === 'Funnel') {\n            borderRadius = (point.index === firstIndex && length !== 1 && firstIndex !== lastIndex) ? 0 : borderRadius;\n            path += locations[0].x + (-(borderRadius * Math.sin(-angle))) + ' ' + (locations[0].y + (-borderRadius * Math.cos(angle))) + ' Q' + locations[0].x\n                + ' ' + locations[0].y + ' ' + (locations[0].x + borderRadius) + ' ' + locations[0].y;\n            path += ' L' + (locations[1].x - borderRadius) + ' ' + locations[1].y + ' Q' + locations[1].x + ' '\n                + locations[1].y + ' ' + (locations[1].x - ((borderRadius * Math.sin(angle)))) + ' ' + (locations[1].y + (-borderRadius * Math.cos(angle)));\n            borderRadius = point.index === firstIndex ? temp : 0;\n            if (series.neckWidth === '0%') {\n                var middle = (locations[5].x + (locations[3].x - locations[5].x) / 2);\n                path += ' L' + (locations[2].x + (-borderRadius * Math.sin(-angle))) + ' ' + (locations[2].y - (-borderRadius * Math.cos(angle)))\n                    + ' Q' + middle + ' ' + locations[2].y + ' ' + (locations[5].x - (-borderRadius * Math.sin(-angle))) + ' ' + (locations[2].y - (-borderRadius * Math.cos(angle)));\n            }\n            else {\n                path = series.neckHeight !== '0%' && locations[2].y !== locations[3].y ? path += ' L' + locations[2].x + ' ' + (locations[2].y) : path;\n                var tempX = series.neckHeight === '0%' ? ((borderRadius * Math.sin(-angle))) : 0;\n                var tempY = series.neckHeight === '0%' ? (-borderRadius * Math.cos(angle)) : borderRadius;\n                path += ' L' + (locations[3].x - (tempX)) + ' ' + (locations[3].y - (tempY)) + ' Q' + locations[3].x + ' ' + locations[3].y + ' '\n                    + (locations[3].x - tempY) + ' ' + locations[3].y;\n                path += ' L' + (locations[4].x + tempY) + ' ' + locations[4].y + ' Q' + locations[4].x + ' ' + locations[4].y + ' '\n                    + (locations[4 + 1].x + tempX) + ' ' + (locations[4].y - tempY);\n                path = series.neckHeight !== '0%' && locations[4].y !== locations[5].y ? path += ' L' + locations[5].x + ' ' + (locations[5].y) : path;\n            }\n        }\n        return path;\n    };\n    /**\n     * Creates a path to connect a list of points.\n     *\n     * @param {ChartLocation[]} locations - An array of ChartLocation objects representing the points to connect.\n     * @param {AccPoints} point - The current AccPoints object containing the data point information.\n     * @param {AccumulationSeries} series - The series object of the Accumulation.\n     * @returns {string} - This string represent the path value of the D attribute.\n     * @Private\n     */\n    TriangularBase.prototype.findPath = function (locations, point, series) {\n        var path = 'M ';\n        var firstIndex = -1;\n        var lastIndex = -1;\n        for (var index = 0; index < series.points.length; index++) {\n            if (series.points[index].visible) {\n                if (firstIndex === -1) {\n                    firstIndex = index;\n                }\n                lastIndex = index;\n            }\n        }\n        if (series.borderRadius && (point.index === lastIndex || point.index === firstIndex)) {\n            path = this.getPath(locations, point, path, firstIndex, lastIndex, series);\n        }\n        else {\n            for (var i = 0; i < locations.length; i++) {\n                path += locations[i].x + ' ' + locations[i].y;\n                if (i !== locations.length - 1) {\n                    path += ' L ';\n                }\n            }\n        }\n        return path + ' Z ';\n    };\n    /**\n     * To calculate data-label bounds.\n     *\n     * @private\n     * @param {AccumulationSeries} series - The series for which to calculate data-label bounds.\n     * @param {boolean} visible - Specifies whether the data-labels are visible.\n     * @param {AccumulationLabelPosition} position - The position of the data-labels.\n     * @param {AccumulationChart} chart - The accumulation chart control.\n     * @returns {void}\n     */\n    TriangularBase.prototype.defaultLabelBound = function (series, visible, position, chart) {\n        var x = (chart.initialClipRect.width - series.triangleSize.width) / 2;\n        var y = (chart.initialClipRect.height - series.triangleSize.height) / 2;\n        var accumulationBound = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.Rect(x, y, series.triangleSize.width, series.triangleSize.height);\n        series.labelBound = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.Rect(accumulationBound.x, accumulationBound.y, accumulationBound.width + accumulationBound.x, accumulationBound.height + accumulationBound.y);\n        series.accumulationBound = accumulationBound;\n        if (visible && position === 'Outside') {\n            series.labelBound = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_0__.Rect(Infinity, Infinity, -Infinity, -Infinity);\n        }\n    };\n    return TriangularBase;\n}(_accumulation_base__WEBPACK_IMPORTED_MODULE_2__.AccumulationBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/triangular-base.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/high-light.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/high-light.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccumulationHighlight: () => (/* binding */ AccumulationHighlight)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection */ \"./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/selection.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * AccumulationChart highlight source file\n */\n\n\n\n/**\n * The `AccumulationHighlight` module handles highlighting for the accumulation chart.\n *\n * @private\n */\nvar AccumulationHighlight = /** @class */ (function (_super) {\n    __extends(AccumulationHighlight, _super);\n    /**\n     * Constructor for selection module.\n     *\n     * @private.\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     */\n    function AccumulationHighlight(accumulation) {\n        var _this = _super.call(this, accumulation) || this;\n        _this.accumulation = accumulation;\n        _this.renderer = accumulation.renderer;\n        _this.wireEvents();\n        return _this;\n    }\n    /**\n     * Binding events for selection module.\n     *\n     * @returns {void}\n     */\n    AccumulationHighlight.prototype.wireEvents = function () {\n        if (this.accumulation.isDestroyed) {\n            return;\n        }\n        this.accumulation.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove, this);\n    };\n    /**\n     * UnBinding events for selection module.\n     *\n     * @returns {void}\n     */\n    AccumulationHighlight.prototype.unWireEvents = function () {\n        if (this.accumulation.isDestroyed) {\n            return;\n        }\n        this.accumulation.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMove);\n    };\n    /**\n     * To find private variable values.\n     *\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @returns {void}\n     */\n    AccumulationHighlight.prototype.declarePrivateVariables = function (accumulation) {\n        this.styleId = accumulation.element.id + '_ej2_chart_highlight';\n        this.unselected = accumulation.element.id + '_ej2_deselected';\n        this.selectedDataIndexes = [];\n        this.highlightDataIndexes = [];\n    };\n    /**\n     * Method to select the point and series.\n     *\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\n     * @returns {void}\n     */\n    AccumulationHighlight.prototype.invokeHighlight = function (accumulation) {\n        this.declarePrivateVariables(accumulation);\n        this.series = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)({}, accumulation.visibleSeries, null, true);\n        this.seriesStyles();\n        this.currentMode = accumulation.highlightMode;\n    };\n    /**\n     * Get module name.\n     *\n     * @private\n     * @returns {string} - Returns the module name.\n     */\n    AccumulationHighlight.prototype.getModuleName = function () {\n        return 'AccumulationHighlight';\n    };\n    /**\n     * To destroy the highlight.\n     *\n     * @returns {void}\n     * @private\n     */\n    AccumulationHighlight.prototype.destroy = function () {\n        this.unWireEvents();\n        //Destroy method performed here\n    };\n    return AccumulationHighlight;\n}(_selection__WEBPACK_IMPORTED_MODULE_1__.AccumulationSelection));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/high-light.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/tooltip.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/tooltip.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccumulationTooltip: () => (/* binding */ AccumulationTooltip)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _common_user_interaction_tooltip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/user-interaction/tooltip */ \"./node_modules/@syncfusion/ej2-charts/src/common/user-interaction/tooltip.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * AccumulationChart Tooltip file.\n */\n\n\n\n//import { Rect } from '@syncfusion/ej2-svg-base';\n\n\n/**\n * The `AccumulationTooltip` module is used to render tooltips for the accumulation chart.\n */\nvar AccumulationTooltip = /** @class */ (function (_super) {\n    __extends(AccumulationTooltip, _super);\n    function AccumulationTooltip(accumulation) {\n        var _this = _super.call(this, accumulation) || this;\n        _this.accumulation = accumulation;\n        _this.addEventListener();\n        _this.template = _this.accumulation.tooltip.template;\n        return _this;\n    }\n    /**\n     * Adds an event listener.\n     *\n     * @hidden\n     * @returns {void}\n     */\n    AccumulationTooltip.prototype.addEventListener = function () {\n        if (this.accumulation.isDestroyed) {\n            return;\n        }\n        this.accumulation.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer ? 'pointerleave' : 'mouseleave', this.mouseLeaveHandler, this);\n        this.accumulation.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMoveHandler, this);\n        this.accumulation.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseUpHandler, this);\n    };\n    AccumulationTooltip.prototype.mouseLeaveHandler = function () {\n        this.removeTooltip(this.accumulation.tooltip.fadeOutDuration);\n    };\n    AccumulationTooltip.prototype.mouseUpHandler = function (e) {\n        var control = this.accumulation;\n        if (control.tooltip.enable && control.isTouch && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(control.mouseX, control.mouseY, control.initialClipRect)) {\n            this.tooltip(e);\n            this.removeTooltip(2000);\n        }\n    };\n    AccumulationTooltip.prototype.mouseMoveHandler = function (e) {\n        var control = this.accumulation;\n        // Tooltip for chart series.\n        if (control.tooltip.enable && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(control.mouseX, control.mouseY, control.initialClipRect)) {\n            this.tooltip(e);\n        }\n    };\n    /**\n     * Renders the tooltip.\n     *\n     * @param {PointerEvent | TouchEvent} event - The mouse move event or touch event.\n     * @returns {void}\n     * @private\n     */\n    AccumulationTooltip.prototype.tooltip = function (event) {\n        this.renderSeriesTooltip(this.accumulation, this.getPieData(event, this.accumulation));\n    };\n    /**\n     * @private\n     */\n    AccumulationTooltip.prototype.renderSeriesTooltip = function (chart, data) {\n        var svgElement = this.getElement(this.element.id + '_tooltip_svg');\n        var isTooltip = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0;\n        var tooltipDiv = this.getTooltipElement(isTooltip);\n        var isFirst = !isTooltip;\n        this.currentPoints = [];\n        if (data.point && (!this.previousPoints[0] || (this.previousPoints[0].point !== data.point))) {\n            if (this.previousPoints[0] && data.point.index === this.previousPoints[0].point.index\n                && data.series.index === this.previousPoints[0].series.index) {\n                return null;\n            }\n            if (this.pushData(data, isFirst, tooltipDiv, false)) {\n                this.triggerTooltipRender(data, isFirst, this.getTooltipText(data, chart.tooltip), this.findHeader(data));\n            }\n        }\n        else {\n            if (!data.point && this.isRemove) {\n                this.removeTooltip(this.accumulation.tooltip.fadeOutDuration);\n                this.isRemove = false;\n            }\n        }\n    };\n    AccumulationTooltip.prototype.triggerTooltipRender = function (point, isFirst, textCollection, headerText) {\n        var _this = this;\n        //let template: string;\n        var tooltip = this.chart.tooltip;\n        var argsData = {\n            cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_3__.tooltipRender, text: textCollection, point: point.point, textStyle: this.textStyle,\n            series: this.accumulation.isBlazor ? {} : point.series, headerText: headerText,\n            data: {\n                pointX: point.point.x, pointY: point.point.y, seriesIndex: point.series.index,\n                pointIndex: point.point.index, pointText: point.point.text, seriesName: point.series.name\n            }\n        };\n        var tooltipSuccess = function (argsData) {\n            if (!argsData.cancel) {\n                _this.formattedText = _this.formattedText.concat(argsData.text);\n                _this.text = _this.formattedText;\n                _this.headerText = argsData.headerText;\n                _this.createTooltip(_this.chart, isFirst, { x: (tooltip.location.x !== null) ? tooltip.location.x :\n                        point.point.symbolLocation.x, y: (tooltip.location.y !== null) ? tooltip.location.y : point.point.symbolLocation.y }, point.series.clipRect, point.point, !tooltip.enableMarker ? [] : ['Circle'], 0, _this.chart.initialClipRect, false, null, point.point, _this.template ? _this.accumulation.enableHtmlSanitizer ? _this.accumulation.sanitize(_this.template) : argsData.template : '');\n            }\n            else {\n                _this.removeHighlight();\n                (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(_this.getElement(_this.element.id + '_tooltip'));\n            }\n            _this.isRemove = true;\n        };\n        tooltipSuccess.bind(this, point);\n        this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_3__.tooltipRender, argsData, tooltipSuccess);\n    };\n    AccumulationTooltip.prototype.getPieData = function (e, chart) {\n        var target = e.target;\n        var id = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.indexFinder)(target.id, true);\n        if (!isNaN(id.series)) {\n            var seriesIndex = id.series;\n            var pointIndex = id.point;\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(seriesIndex) && !isNaN(seriesIndex) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(pointIndex) && !isNaN(pointIndex)) {\n                var series = this.getSeriesFromIndex(seriesIndex, chart.visibleSeries);\n                if (series.enableTooltip) {\n                    return new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.AccPointData(series.points[pointIndex], series);\n                }\n            }\n        }\n        return new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.AccPointData(null, null);\n    };\n    /**\n     * To get series from index.\n     *\n     * @param {number} index - The index of the series to retrieve.\n     * @param {AccumulationSeries[]} visibleSeries - The array of visible series in the accumulation chart.\n     * @returns {AccumulationSeries} - The series retrieved from the specified index.\n     */\n    AccumulationTooltip.prototype.getSeriesFromIndex = function (index, visibleSeries) {\n        return visibleSeries[0];\n    };\n    AccumulationTooltip.prototype.getTooltipText = function (data, tooltip) {\n        var series = data.series;\n        var format = tooltip.format ? tooltip.format : this.accumulation.theme.indexOf('Tailwind3') > -1 ? '${point.x} : ${point.y}' : '${point.x} : <b>${point.y}</b>';\n        format = this.accumulation.useGroupingSeparator ? format.replace('${point.y}', '${point.separatorY}') : format;\n        return this.parseTemplate(data.point, series, format);\n    };\n    AccumulationTooltip.prototype.findHeader = function (data) {\n        if (this.header === '') {\n            return '';\n        }\n        this.header = this.parseTemplate(data.point, data.series, this.header);\n        if (this.header.replace(/<b>/g, '').replace(/<\\/b>/g, '').trim() !== '') {\n            return this.header;\n        }\n        return '';\n    };\n    AccumulationTooltip.prototype.parseTemplate = function (point, series, format) {\n        var value;\n        var textValue;\n        var regExp = RegExp;\n        for (var _i = 0, _a = Object.keys(point); _i < _a.length; _i++) {\n            var dataValue = _a[_i];\n            value = new regExp('${point' + '.' + dataValue + '}', 'gm');\n            var pointValue = (dataValue === 'x' && this.accumulation.useGroupingSeparator && typeof point[dataValue] === 'number') ?\n                this.accumulation.intl.formatNumber(point.x, { useGrouping: true }) : point[dataValue];\n            format = format.replace(value.source, pointValue);\n        }\n        for (var _b = 0, _c = Object.keys(Object.getPrototypeOf(series)); _b < _c.length; _b++) {\n            var dataValue = _c[_b];\n            value = new regExp('${series' + '.' + dataValue + '}', 'gm');\n            textValue = series[dataValue];\n            format = format.replace(value.source, textValue);\n        }\n        return format;\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    AccumulationTooltip.prototype.getModuleName = function () {\n        return 'AccumulationTooltip';\n    };\n    /**\n     * To destroy the Tooltip.\n     *\n     * @returns {void}\n     * @private\n     */\n    AccumulationTooltip.prototype.destroy = function () {\n        /**\n         * Destroy method calling here\n         */\n    };\n    return AccumulationTooltip;\n}(_common_user_interaction_tooltip__WEBPACK_IMPORTED_MODULE_2__.BaseTooltip));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/accumulation-chart/user-interaction/tooltip.js?");

/***/ })

}]);