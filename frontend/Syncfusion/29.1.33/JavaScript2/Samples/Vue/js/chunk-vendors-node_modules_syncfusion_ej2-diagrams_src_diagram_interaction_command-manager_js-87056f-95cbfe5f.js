"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_command-manager_js-87056f-95cbfe5f"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/command-manager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/command-manager.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandHandler: () => (/* binding */ CommandHandler)\n/* harmony export */ });\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _diagram_diagram__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../diagram/diagram */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js\");\n/* harmony import */ var _primitives_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./../primitives/matrix */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./actions */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/actions.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./../utility/constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n/* harmony import */ var _utility_dom_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utility/dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _diagram_layer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../diagram/layer */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/layer.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _utility_connector__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./../utility/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js\");\n/* harmony import */ var _objects_annotation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../objects/annotation */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/annotation.js\");\n/* harmony import */ var _objects_port__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../objects/port */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/port.js\");\n/* harmony import */ var _container_interaction__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./container-interaction */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js\");\n/* harmony import */ var _utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../utility/swim-lane-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js\");\n/* harmony import */ var _core_elements_html_element__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../core/elements/html-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/html-element.js\");\n/* harmony import */ var _overview_overview__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../overview/overview */ \"./node_modules/@syncfusion/ej2-diagrams/src/overview/overview.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Defines the behavior of commands\n */\nvar CommandHandler = /** @class */ (function () {\n    function CommandHandler(diagram) {\n        /**   @private  */\n        this.clipboardData = {};\n        // private newNodeObject: Object[] = [];\n        // private newConnectorObject: Object[] = [];\n        /**   @private  */\n        this.diagramObject = {};\n        /**   @private  */\n        this.newSelectedObjects = {};\n        /**   @private  */\n        this.oldSelectedObjects = {};\n        /**   @private  */\n        this.changedNodeZIndexes = {};\n        /**   @private  */\n        this.connectorsTable = [];\n        /** @private */\n        this.PreventConnectorSplit = false;\n        /**   @private  */\n        this.processTable = {};\n        /** @private */\n        this.isContainer = false;\n        /** @private */\n        this.canUpdateTemplate = false;\n        /** @private */\n        this.cloningInProgress = false;\n        this.childTable = {};\n        this.objectStore = [];\n        this.parentTable = {};\n        this.blazor = 'Blazor';\n        this.blazorInterop = 'sfBlazor';\n        this.cloneGroupChildCollection = [];\n        this.diagram = diagram;\n    }\n    Object.defineProperty(CommandHandler.prototype, \"snappingModule\", {\n        /**   @private  */\n        get: function () {\n            return this.diagram.snappingModule;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandHandler.prototype, \"layoutAnimateModule\", {\n        /**   @private  */\n        get: function () {\n            return this.diagram.layoutAnimateModule;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * startTransaction method\\\n     *\n     * @returns {  void }    startTransaction method .\\\n     * @param {boolean} protectChange - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.startTransaction = function (protectChange) {\n        this.state = { element: this.diagram.selectedItems, backup: null };\n        if (protectChange) {\n            this.diagram.protectPropertyChange(true);\n        }\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getAdornerLayer)(this.diagram.element.id).style.pointerEvents = 'none';\n    };\n    /**\n     * endTransaction method\\\n     *\n     * @returns {  void }    endTransaction method .\\\n     * @param {boolean} protectChange - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.endTransaction = function (protectChange) {\n        this.state = null;\n        if (protectChange) {\n            this.diagram.protectPropertyChange(false);\n        }\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getAdornerLayer)(this.diagram.element.id).style.pointerEvents = 'all';\n    };\n    /**\n     * setFocus method\\\n     *\n     * @returns {  void }    setFocus method .\\\n     * @private\n     */\n    CommandHandler.prototype.setFocus = function () {\n        document.getElementById(this.diagram.element.id).focus();\n    };\n    /**\n     * showTooltip method\\\n     *\n     * @returns {  void }    showTooltip method .\\\n     * @param {IElement} node - provide the options value.\n     * @param {PointModel} position - provide the position value.\n     * @param {string | HTMLElement} content - provide the content value.\n     * @param {string} toolName - provide the toolName value.\n     * @param {boolean} isTooltipVisible - provide the isTooltipVisible value.\n     * @private\n     */\n    CommandHandler.prototype.showTooltip = function (node, position, content, toolName, isTooltipVisible) {\n        var _this = this;\n        var targetId;\n        var targetEle;\n        var isNative = false;\n        if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n            if ((node.nodes.length === 1) && node.connectors.length === 0) {\n                targetId = node.nodes[0].id;\n                if (node.nodes[0].shape && node.nodes[0].shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Native) {\n                    isNative = true;\n                }\n            }\n            else if ((node.nodes.length === 0) && node.connectors.length === 1) {\n                targetId = node.connectors[0].id;\n            }\n            else {\n                targetEle = document.getElementById(this.diagram.element.id + '_SelectorElement');\n            }\n        }\n        else if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            targetId = node.id;\n            if (node.shape && (node.shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Native)) {\n                isNative = true;\n            }\n        }\n        else {\n            targetId = node.id;\n        }\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isNullOrUndefined)(targetEle) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isNullOrUndefined)(targetId)) {\n            var idName = isNative ? '_content_native_element' : '_groupElement';\n            targetEle = document.getElementById(targetId + idName);\n        }\n        if (isTooltipVisible) {\n            this.diagram.tooltipObject.position = 'BottomCenter';\n            this.diagram.tooltipObject.animation = { open: { delay: 0, duration: 0 } };\n            this.diagram.tooltipObject.openDelay = 0;\n            this.diagram.tooltipObject.closeDelay = 0;\n        }\n        if (this.diagram.selectedItems.setTooltipTemplate) {\n            var template = void 0;\n            var setTooltipTemplate = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getFunction)(this.diagram.selectedItems.setTooltipTemplate);\n            if (setTooltipTemplate) {\n                template = setTooltipTemplate(node, this.diagram);\n            }\n            if (template instanceof HTMLElement) {\n                content = template.cloneNode(true);\n            }\n            else {\n                content = template ? template : content;\n            }\n        }\n        //840454- support to provide isSticky property for tooltip in diagram control\n        this.diagram.tooltipObject.isSticky = false;\n        if (node.tooltip) {\n            this.diagram.tooltipObject.openOn = node.tooltip.openOn;\n        }\n        // Task 834121: Content-Security-Policy support for diagram\n        if (typeof content === 'string') {\n            this.diagram.tooltipObject.content = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.initializeCSPTemplate)(function () {\n                return content;\n            });\n        }\n        else {\n            this.diagram.tooltipObject.content = content;\n        }\n        this.diagram.tooltipObject.offsetX = 0;\n        this.diagram.tooltipObject.offsetY = 0;\n        this.diagram.tooltipObject.refresh(targetEle);\n        if (isTooltipVisible) {\n            setTimeout(function () {\n                _this.diagram.tooltipObject.open(targetEle);\n            }, 1);\n        }\n    };\n    /**\n     * Split the connector, when the node is dropped onto it and establish connection with that dropped node.\n     *\n     * @returns {  void }   connectorSplit  method .\\\n     * @param {NodeModel}  droppedObject - Provide the dropped node id\n     * @param {ConnectorModel} targetConnector - Provide the connector id\n     * @private\n     */\n    CommandHandler.prototype.connectorSplit = function (droppedObject, targetConnector) {\n        var droppedNodeId = droppedObject.id;\n        var existingConnector = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(targetConnector);\n        var connectorIndex = this.diagram.connectors.indexOf(targetConnector);\n        var nodeIndex = this.diagram.nodes.indexOf(droppedObject);\n        var droppedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(droppedObject);\n        var connectorOldChanges = {};\n        var nodeOldChanges = {};\n        var nodeOldProperty = {\n            offsetX: droppedNode.offsetX,\n            offsetY: droppedNode.offsetY\n        };\n        var connectorOldProperty = {\n            sourceID: existingConnector.sourceID,\n            sourcePoint: existingConnector.sourcePoint,\n            sourcePortID: existingConnector.sourcePortID,\n            targetID: existingConnector.targetID,\n            targetPoint: existingConnector.targetPoint,\n            targetPortID: existingConnector.targetPortID\n        };\n        connectorOldChanges[parseInt(connectorIndex.toString(), 10)] = connectorOldProperty;\n        nodeOldChanges[parseInt(nodeIndex.toString(), 10)] = nodeOldProperty;\n        var connectorNewChanges = {};\n        var nodeNewChanges = {};\n        var nodeNewProperty = {};\n        var connectorNewProperty = {};\n        //Split the connector based on the dropped node\n        if (existingConnector.sourceID !== '' && existingConnector.targetID !== '') {\n            connectorNewProperty.targetID = this.ConnectorTargetChange(targetConnector, droppedNodeId);\n        }\n        else if (existingConnector.sourceID !== '' && existingConnector.targetID === '') {\n            this.nodeOffsetChange(nodeNewProperty, droppedNode, targetConnector.targetPoint);\n            connectorNewProperty.targetID = this.ConnectorTargetChange(targetConnector, droppedNodeId);\n        }\n        else if ((existingConnector.sourceID === '' && existingConnector.targetID === '') || (existingConnector.sourceID === '' && existingConnector.targetID !== '')) {\n            this.nodeOffsetChange(nodeNewProperty, droppedNode, targetConnector.sourcePoint);\n            connectorNewProperty.sourceID = this.ConnectorSourceChange(targetConnector, droppedNodeId);\n        }\n        connectorNewChanges[parseInt(connectorIndex.toString(), 10)] = connectorNewProperty;\n        nodeNewChanges[parseInt(nodeIndex.toString(), 10)] = nodeNewProperty;\n        this.diagram.nodePropertyChange(droppedObject, nodeOldProperty, nodeNewProperty);\n        this.diagram.updateSelector();\n        this.diagram.connectorPropertyChange(targetConnector, connectorOldProperty, connectorNewProperty);\n        //Check Whether the connector connects with the node\n        if (existingConnector.sourceID !== '' && existingConnector.targetID !== '') {\n            var newConnector = {\n                id: 'connector ' + droppedNodeId,\n                constraints: _enum_enum__WEBPACK_IMPORTED_MODULE_10__.ConnectorConstraints.Default | _enum_enum__WEBPACK_IMPORTED_MODULE_10__.ConnectorConstraints.AllowDrop,\n                sourceID: droppedNodeId\n            };\n            // 28029: Update new connectors source and target end type and styles\n            newConnector.type = existingConnector.type;\n            newConnector.style = existingConnector.style;\n            newConnector.sourceDecorator = existingConnector.sourceDecorator;\n            newConnector.targetDecorator = existingConnector.targetDecorator;\n            newConnector.targetID = existingConnector.targetID;\n            //Check whether the connector connects with the ports\n            if (existingConnector.targetPortID !== '') {\n                newConnector.targetPortID = existingConnector.targetPortID;\n            }\n            this.diagram.add(newConnector);\n        }\n        var entry = {\n            type: 'PropertyChanged', redoObject: { nodes: nodeNewChanges }, undoObject: { nodes: nodeOldChanges },\n            category: 'Internal'\n        };\n        this.diagram.addHistoryEntry(entry);\n        var entry1 = {\n            type: 'PropertyChanged', redoObject: { connectors: connectorNewChanges }, undoObject: { connectors: connectorOldChanges },\n            category: 'Internal'\n        };\n        this.diagram.addHistoryEntry(entry1);\n    };\n    CommandHandler.prototype.nodeOffsetChange = function (propertyChangeArg, node, nodeNewOffset) {\n        propertyChangeArg.offsetX = node.offsetX = nodeNewOffset.x;\n        propertyChangeArg.offsetY = node.offsetY = nodeNewOffset.y;\n    };\n    CommandHandler.prototype.ConnectorTargetChange = function (connector, newTarget) {\n        connector.targetID = newTarget;\n        return newTarget;\n    };\n    CommandHandler.prototype.ConnectorSourceChange = function (connector, newTarget) {\n        connector.sourceID = newTarget;\n        return newTarget;\n    };\n    /**\n     * closeTooltip method\\\n     *\n     * @returns {  void }    closeTooltip method .\\\n     * @private\n     */\n    CommandHandler.prototype.closeTooltip = function () {\n        this.diagram.tooltipObject.close();\n    };\n    /**\n     * canEnableDefaultTooltip method\\\n     *\n     * @returns {  boolean }    canEnableDefaultTooltip method .\\\n     * @private\n     */\n    CommandHandler.prototype.canEnableDefaultTooltip = function () {\n        if (this.diagram.selectedItems.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.SelectorConstraints.ToolTip) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * updateSelector method\\\n     *\n     * @returns {  void }    updateSelector method .\\\n     * @private\n     */\n    CommandHandler.prototype.updateSelector = function () {\n        this.diagram.updateSelector();\n    };\n    // /**\n    //  * updateConnectorValue method\\\n    //  *\n    //  * @returns {  void }    updateConnectorValue method .\\\n    //  * @param {IBlazorConnectionChangeEventArgs} args - provide the options value.\n    //  * @private\n    //  */\n    // public updateConnectorValue(args: IBlazorConnectionChangeEventArgs): void {\n    //     //remove Blazor code\n    // }\n    /**\n     * triggerEvent method\\\n     *\n     * @returns {  Promise<void | object | IBlazorConnectionChangeEventArgs> }    triggerEvent method .\\\n     * @param {DiagramEvent} event - provide the options value.\n     * @param {Object} args - provide the args value.\n     * @private\n     */\n    CommandHandler.prototype.triggerEvent = function (event, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var temparg;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(event === _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.drop || event === _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.positionChange ||\n                            event === _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.connectionChange)) return [3 /*break*/, 3];\n                        if (this.diagram.currentSymbol) {\n                            return [2 /*return*/];\n                        }\n                        if (event === _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.drop) {\n                            args.source = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(this.diagram);\n                        }\n                        if (!(this.diagram.currentDrawingObject instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && event !== _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.positionChange)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.diagram.triggerEvent(event, args)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        if (this.diagram.currentDrawingObject && event !== _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.positionChange) {\n                            return [2 /*return*/];\n                        }\n                        _a.label = 3;\n                    case 3: return [4 /*yield*/, this.diagram.triggerEvent(event, args)];\n                    case 4:\n                        temparg = _a.sent();\n                        return [2 /*return*/, temparg];\n                }\n            });\n        });\n    };\n    /**\n     * dragOverElement method\\\n     *\n     * @returns { void }    dragOverElement method .\\\n     * @param {MouseEventArgs} args - provide the options value.\n     * @param {PointModel} currentPosition - provide the args value.\n     * @private\n     */\n    CommandHandler.prototype.dragOverElement = function (args, currentPosition) {\n        if (this.diagram.currentSymbol) {\n            var dragOverArg = {\n                element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(args.source), target: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(args.target),\n                mousePosition: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(currentPosition), diagram: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(this.diagram)\n            };\n            this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.dragOver, dragOverArg);\n        }\n    };\n    /**\n     * disConnect method\\\n     *\n     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    disConnect method .\\\n     * @param {IElement} obj - provide the obj value.\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {boolean} canCancel - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.disConnect = function (obj, endPoint, canCancel) {\n        var oldChanges = {};\n        var newChanges = {};\n        var returnargs;\n        var selectorModel;\n        var connector;\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n            selectorModel = obj;\n            connector = selectorModel.connectors[0];\n        }\n        else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && this.diagram.currentDrawingObject) {\n            connector = this.diagram.currentDrawingObject;\n        }\n        if (obj && connector && ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSingleConnection)(this.diagram) || this.diagram.currentDrawingObject)) {\n            if (endPoint && (endPoint === 'ConnectorSourceEnd' || endPoint === 'ConnectorTargetEnd')) {\n                var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n                var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n                if (connector[\"\" + nodeEndId]) { //connector.sourceID || connector.targetID\n                    oldChanges[\"\" + nodeEndId] = connector[\"\" + nodeEndId];\n                    connector[\"\" + nodeEndId] = '';\n                    newChanges[\"\" + nodeEndId] = connector[\"\" + nodeEndId];\n                    if (connector.sourcePortID || connector.targetPortID) {\n                        oldChanges[\"\" + portEndId] = connector[\"\" + portEndId];\n                        connector[\"\" + portEndId] = '';\n                        newChanges[\"\" + portEndId] = connector[\"\" + portEndId];\n                    }\n                    returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n                }\n            }\n            else if ((endPoint !== 'OrthoThumb' && endPoint !== 'SegmentEnd') && (connector.sourceID || connector.targetID)) {\n                oldChanges = {\n                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,\n                    targetID: connector.targetID, targetPortID: connector.targetPortID\n                };\n                connector.sourceID = '';\n                connector.sourcePortID = '';\n                connector.targetID = '';\n                connector.targetPortID = '';\n                newChanges = {\n                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,\n                    targetID: connector.targetID, targetPortID: connector.targetPortID\n                };\n                var arg = {\n                    connector: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(connector), oldValue: oldChanges,\n                    newValue: newChanges, cancel: false, state: 'Changing', connectorEnd: endPoint\n                };\n                this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.connectionChange, arg);\n                if (arg.cancel) {\n                    connector.sourceID = oldChanges.sourceID;\n                    connector.sourcePortID = oldChanges.sourcePortID;\n                    connector.targetID = oldChanges.targetID;\n                    connector.targetPortID = oldChanges.targetPortID;\n                }\n                else {\n                    this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n                    this.diagram.updateDiagramObject(connector);\n                    arg = {\n                        connector: connector, oldValue: oldChanges,\n                        newValue: newChanges, cancel: false, state: 'Changed', connectorEnd: endPoint\n                    };\n                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.connectionChange, arg);\n                }\n            }\n        }\n        return returnargs;\n    };\n    CommandHandler.prototype.connectionEventChange = function (connector, oldChanges, newChanges, endPoint, canCancel) {\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        var connectedNode;\n        if (this.enableCloneObject) {\n            connectedNode = this.diagram.nameTable[newChanges[\"\" + nodeEndId]];\n            var nodeObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(connectedNode);\n            this.diagram.insertValue(nodeObject, true);\n        }\n        var returnargs;\n        var arg = {\n            cancel: false, state: 'Changing', connectorEnd: endPoint,\n            connector: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(connector), oldValue: { nodeId: oldChanges[\"\" + nodeEndId], portId: oldChanges[\"\" + portEndId] },\n            newValue: { nodeId: newChanges[\"\" + nodeEndId], portId: newChanges[\"\" + portEndId] }\n        };\n        this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.connectionChange, arg);\n        if (arg.cancel) {\n            connector[\"\" + nodeEndId] = oldChanges[\"\" + nodeEndId];\n            connector[\"\" + portEndId] = oldChanges[\"\" + portEndId];\n            newChanges = oldChanges;\n        }\n        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n        this.diagram.updateDiagramObject(connector);\n        arg = {\n            connector: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(connector), oldValue: { nodeId: oldChanges[\"\" + nodeEndId], portId: oldChanges[\"\" + portEndId] },\n            newValue: {\n                nodeId: newChanges[\"\" + nodeEndId],\n                portId: newChanges[\"\" + portEndId]\n            },\n            cancel: false, state: 'Changing', connectorEnd: endPoint\n        };\n        if (this.enableCloneObject) {\n            if (connectedNode === undefined) {\n                connectedNode = this.diagram.nameTable[oldChanges[\"\" + nodeEndId]];\n                var nodeObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(connectedNode);\n                this.diagram.insertValue(nodeObject, true);\n            }\n        }\n        if (this.diagram.bpmnModule) {\n            if (connector.isBpmnAnnotationConnector) {\n                var textAnnotationNode = this.diagram.nameTable[connector.targetID];\n                textAnnotationNode.shape.textAnnotation.textAnnotationTarget = connector.sourceID;\n            }\n        }\n        return returnargs;\n    };\n    // /**\n    //  * insertBlazorObject method\\\n    //  *\n    //  * @returns { void }    insertBlazorObject method .\\\n    //  * @param {IElement} object - provide the object value.\n    //  * @param {boolean} isNode - provide the isNode value.\n    //  * @private\n    //  */\n    // public insertBlazorObject(object: SelectorModel | Node | Connector, isNode?: boolean): void {\n    // }\n    // /**\n    //  * updatePropertiesToBlazor method\\\n    //  *\n    //  * @returns { void }    updatePropertiesToBlazor method .\\\n    //  * @param {MouseEventArgs} args - provide the args value.\n    //  * @param {PointModel} labelDrag - provide the labelDrag value.\n    //  * @private\n    //  */\n    // public updatePropertiesToBlazor(args: MouseEventArgs, labelDrag: boolean): void {\n    //     this.enableCloneObject(false);\n    //     this.ismouseEvents(false);\n    //     // this.getBlazorOldValues(args, labelDrag);\n    //     // this.updateBlazorSelector();\n    // }\n    // /**\n    //  * insertSelectedObjects method\\\n    //  *\n    //  * @returns { void }    insertSelectedObjects method .\\\n    //  * @private\n    //  */\n    // public insertSelectedObjects(): void {\n    //     // this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n    // }\n    /**\n     * findTarget method\\\n     *\n     * @returns { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel }    findTarget method .\\\n     * @param {DiagramElement} element - provide the element value.\n     * @param {IElement} argsTarget - provide the argsTarget value.\n     * @param {boolean} source - provide the source value.\n     * @param {boolean} connection - provide the connection value.\n     * @private\n     */\n    CommandHandler.prototype.findTarget = function (element, argsTarget, source, connection) {\n        var target;\n        if (argsTarget instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            if (element && element.id === argsTarget.id + '_content') {\n                return argsTarget;\n            }\n            if (source && argsTarget.shape.type === 'Bpmn' && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)() && argsTarget.shape.shape === 'Activity'))) {\n                if (argsTarget.shape.activity.subProcess.type === 'Transaction') {\n                    var transaction = argsTarget.shape.activity.subProcess.transaction;\n                    if (transaction.success.visible && element.id.indexOf(argsTarget.id + '_success') === 0) {\n                        return transaction.success;\n                    }\n                    if (transaction.cancel.visible && element.id.indexOf(argsTarget.id + '_cancel') === 0) {\n                        return transaction.cancel;\n                    }\n                    if (transaction.failure.visible && element.id.indexOf(argsTarget.id + '_failure') === 0) {\n                        return transaction.failure;\n                    }\n                }\n            }\n            if (element instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_2__.PathElement || element instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_22__.DiagramHtmlElement) {\n                var nodePort = this.findMatch(argsTarget.ports, argsTarget.id, element.id);\n                if (nodePort) {\n                    return nodePort;\n                }\n                var nodeFixedUserHandle = this.findMatch(argsTarget.fixedUserHandles, argsTarget.id, element.id);\n                if (nodeFixedUserHandle) {\n                    return nodeFixedUserHandle;\n                }\n            }\n        }\n        // Feature 826644: Support to add ports to the connector.\n        // Added below condition to find the target connector port.\n        if (argsTarget instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n            if (element && element.id === argsTarget.id + '_path') {\n                return argsTarget;\n            }\n            if (element instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_2__.PathElement || element instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_22__.DiagramHtmlElement) {\n                var connectorPort = this.findMatch(argsTarget.ports, argsTarget.id, element.id);\n                if (connectorPort) {\n                    return connectorPort;\n                }\n                var connectorFixedUserHandle = this.findMatch(argsTarget.fixedUserHandles, argsTarget.id, element.id);\n                if (connectorFixedUserHandle) {\n                    return connectorFixedUserHandle;\n                }\n            }\n        }\n        if (!connection) {\n            var annotation = void 0;\n            for (var i = 0; i < argsTarget.annotations.length; i++) {\n                annotation = argsTarget.annotations[parseInt(i.toString(), 10)];\n                if (element.id === argsTarget.id + '_' + annotation.id) {\n                    return annotation;\n                }\n            }\n        }\n        return argsTarget;\n    };\n    CommandHandler.prototype.findMatch = function (items, targetID, elementID) {\n        for (var i = 0; i < items.length; i++) {\n            var item = items[parseInt(i.toString(), 10)];\n            if (elementID === targetID + '_' + item.id || elementID === targetID + '_' + item.id + '_shape') {\n                return item;\n            }\n        }\n    };\n    /**\n     * canDisconnect method\\\n     *\n     * @returns { boolean }    canDisconnect method .\\\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {string} targetPortId - provide the targetPortId value.\n     * @param {string} targetNodeId - provide the targetNodeId value.\n     * @private\n     */\n    CommandHandler.prototype.canDisconnect = function (endPoint, args, targetPortId, targetNodeId) {\n        var selector;\n        var connect;\n        if (args.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n            selector = args.source;\n            connect = selector.connectors[0];\n        }\n        else if (args.source instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && this.diagram.currentDrawingObject) {\n            connect = this.diagram.currentDrawingObject;\n        }\n        var targetObject = this.findTarget(args.targetWrapper, args.target, endPoint === 'ConnectorSourceEnd', true);\n        var nodeEnd = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEnd = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        if (connect[\"\" + nodeEnd] !== targetNodeId || connect[\"\" + portEnd] !== targetPortId) {\n            return true;\n        }\n        return false;\n    };\n    /* tslint:disable */\n    /**\n     * connect method\\\n     *\n     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    connect method .\\\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {boolean} canCancel - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.connect = function (endPoint, args, canCancel) {\n        var checkBlazor;\n        var newChanges = {};\n        var oldChanges = {};\n        var oldNodeId;\n        var oldPortId;\n        var selectorModel;\n        var connector;\n        var returnargs;\n        if (args.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n            selectorModel = args.source;\n            connector = selectorModel.connectors[0];\n        }\n        else if (args.source instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && this.diagram.currentDrawingObject) {\n            connector = this.diagram.currentDrawingObject;\n        }\n        var target = this.findTarget((args.targetWrapper || args.sourceWrapper), (args.target || args.actualObject), endPoint === 'ConnectorSourceEnd', true);\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        if (target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            oldChanges[\"\" + nodeEndId] = connector[\"\" + nodeEndId];\n            connector[\"\" + nodeEndId] = target.id;\n            newChanges[\"\" + nodeEndId] = connector[\"\" + nodeEndId];\n            oldChanges[\"\" + portEndId] = connector[\"\" + portEndId];\n            returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n        }\n        else if (target instanceof _objects_port__WEBPACK_IMPORTED_MODULE_19__.Port || target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.BpmnSubEvent) {\n            oldNodeId = connector[\"\" + nodeEndId];\n            oldPortId = connector[\"\" + portEndId];\n            connector[\"\" + portEndId] = target.id;\n            connector[\"\" + nodeEndId] = (args.target && args.target.id || args.actualObject.id);\n            newChanges[\"\" + nodeEndId] = connector[\"\" + nodeEndId];\n            newChanges[\"\" + portEndId] = connector[\"\" + portEndId];\n            var arg = {\n                connector: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },\n                newValue: { nodeId: newChanges[\"\" + nodeEndId], portId: newChanges[\"\" + portEndId] },\n                cancel: false, state: 'Changing', connectorEnd: endPoint\n            };\n            if (!checkBlazor) {\n                this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.connectionChange, arg);\n            }\n            if (arg.cancel) {\n                connector[\"\" + nodeEndId] = oldNodeId;\n                connector[\"\" + portEndId] = oldPortId;\n                newChanges[\"\" + nodeEndId] = oldNodeId;\n                newChanges[\"\" + portEndId] = oldPortId;\n            }\n            else {\n                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n                this.diagram.updateDiagramObject(connector);\n                arg = {\n                    connector: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },\n                    newValue: { nodeId: newChanges[\"\" + nodeEndId], portId: newChanges[\"\" + portEndId] }, cancel: false,\n                    state: 'Changing', connectorEnd: endPoint\n                };\n            }\n        }\n        this.renderHighlighter(args, undefined, endPoint === 'ConnectorSourceEnd');\n        return returnargs;\n    };\n    /* tslint:enable */\n    /** @private */\n    /**\n     * cut method\\\n     *\n     * @returns { void }    cut method .\\\n     * @private\n     */\n    CommandHandler.prototype.cut = function () {\n        var index;\n        this.clipboardData.pasteIndex = 0;\n        if (this.diagram.undoRedoModule) {\n            this.diagram.historyManager.startGroupAction();\n        }\n        this.clipboardData.clipObject = this.copyObjects();\n        if (this.diagram.undoRedoModule) {\n            this.diagram.historyManager.endGroupAction();\n        }\n        if (this.diagram.mode !== 'SVG') {\n            this.diagram.refreshDiagramLayer();\n        }\n    };\n    // private UpdateBlazorDiagramModelLayers(layer: Layer, isRemove: boolean): void {\n    // comment blazor code\n    // }\n    /**\n     * addLayer method\\\n     *\n     * @returns { void }    addLayer method .\\\n     * @param {LayerModel} layer - provide the endPoint value.\n     * @param {Object[]} objects - provide the args value.\n     * @param {boolean} isServerUpdate - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.addLayer = function (layer, objects, isServerUpdate) {\n        if (isServerUpdate === void 0) { isServerUpdate = true; }\n        layer.id = layer.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)();\n        layer.zIndex = this.diagram.layers.length;\n        var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n        this.diagram.enableServerDataBinding(false);\n        layer = new _diagram_layer__WEBPACK_IMPORTED_MODULE_15__.Layer(this.diagram, 'layers', layer, true);\n        this.diagram.enableServerDataBinding(isEnableServerDatabind);\n        layer.objectZIndex = -1;\n        layer.zIndexTable = {};\n        this.diagram.layers.push(layer);\n        // if (isServerUpdate) {\n        //     this.UpdateBlazorDiagramModelLayers(layer as Layer, false);\n        // }\n        this.diagram.layerZIndexTable[layer.zIndex] = layer.id;\n        this.diagram.activeLayer = layer;\n        var layers = layer.objects;\n        if (objects) {\n            for (var i = 0; i < objects.length; i++) {\n                this.diagram.add(objects[parseInt(i.toString(), 10)]);\n            }\n        }\n    };\n    /**\n     * getObjectLayer method\\\n     *\n     * @returns { LayerModel }    getObjectLayer method .\\\n     * @param {string} objectName - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.getObjectLayer = function (objectName) {\n        var layers = this.diagram.layers;\n        if (layers.length > 1) {\n            for (var i = 0; i < layers.length; i++) {\n                var objIndex = layers[parseInt(i.toString(), 10)].objects.indexOf(objectName);\n                if (objIndex > -1) {\n                    return layers[parseInt(i.toString(), 10)];\n                }\n            }\n        }\n        return this.diagram.activeLayer;\n    };\n    /**\n     * getLayer method\\\n     *\n     * @returns { LayerModel }    getLayer method .\\\n     * @param {string} layerName - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.getLayer = function (layerName) {\n        var layers = this.diagram.layers;\n        for (var i = 0; i < layers.length; i++) {\n            if (layers[parseInt(i.toString(), 10)].id === layerName) {\n                return layers[parseInt(i.toString(), 10)];\n            }\n        }\n        return undefined;\n    };\n    /**\n     * removeLayer method\\\n     *\n     * @returns { void }    removeLayer method .\\\n     * @param {string} layerId - provide the endPoint value.\n     * @param {boolean} isServerUpdate - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.removeLayer = function (layerId, isServerUpdate) {\n        if (isServerUpdate === void 0) { isServerUpdate = true; }\n        var layers = this.getLayer(layerId);\n        if (layers) {\n            var index = this.diagram.layers.indexOf(layers);\n            var layerObject = layers.objects;\n            for (var i = layerObject.length - 1; i >= 0; i--) {\n                this.diagram.unSelect(this.diagram.nameTable[layerObject[parseInt(i.toString(), 10)]]);\n                this.diagram.remove(this.diagram.nameTable[layerObject[parseInt(i.toString(), 10)]]);\n                if (layers.id !== 'default_layer') {\n                    if (this.diagram.activeLayer.id === layerId) {\n                        this.diagram.activeLayer = this.diagram.layers[this.diagram.layers.length - 1];\n                    }\n                }\n            }\n            // if (isServerUpdate) {\n            //     this.UpdateBlazorDiagramModelLayers(this.diagram.layers[parseInt(index.toString(), 10)] as Layer, true);\n            // }\n            delete this.diagram.layerZIndexTable[layers.zIndex];\n            this.diagram.layers.splice(index, 1);\n            if (this.diagram.mode !== 'SVG') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * moveObjects method\\\n     *\n     * @returns { void }    moveObjects method .\\\n     * @param {string[]]} objects - provide the objects value.\n     * @param {string} targetLayer - provide the targetLayer value.\n     * @private\n     */\n    CommandHandler.prototype.moveObjects = function (objects, targetLayer) {\n        this.diagram.startGroupAction();\n        var connectorObjectsDetails = {};\n        var childNodes = [];\n        for (var i = 0; i < objects.length; i++) {\n            var obj = this.diagram.nameTable[objects[parseInt(i.toString(), 10)]];\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                var detail = { inEdges: obj.inEdges, outEdges: obj.outEdges };\n                connectorObjectsDetails[\"\" + obj.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(detail);\n            }\n            else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n                var detail = {\n                    sourceID: obj.sourceID, targetID: obj.targetID,\n                    sourcePortID: obj.sourcePortID, targetPortID: obj.targetPortID\n                };\n                connectorObjectsDetails[\"\" + obj.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(detail);\n            }\n        }\n        var layer = this.getLayer(targetLayer) || this.diagram.activeLayer;\n        this.diagram.setActiveLayer(layer.id);\n        var targerNodes;\n        for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {\n            var i = objects_1[_i];\n            var layer_1 = this.getObjectLayer(i);\n            var index = layer_1.objects.indexOf(i);\n            if (index > -1) {\n                targerNodes = this.diagram.nameTable[\"\" + i];\n                childNodes = [];\n                if (targerNodes.children) {\n                    for (var _a = 0, _b = targerNodes.children; _a < _b.length; _a++) {\n                        var node = _b[_a];\n                        childNodes.push(this.diagram.nameTable[\"\" + node]);\n                    }\n                }\n                this.diagram.unSelect(targerNodes);\n                //875087 - Restrict removing dependent connectors when moveing between layers\n                this.diagram.deleteDependentConnector = false;\n                this.diagram.remove(this.diagram.nameTable[\"\" + i]);\n                this.diagram.deleteDependentConnector = true;\n                if (childNodes.length > 0) {\n                    var addedObj = void 0;\n                    for (var _c = 0, childNodes_1 = childNodes; _c < childNodes_1.length; _c++) {\n                        var node = childNodes_1[_c];\n                        addedObj = this.diagram.add(node);\n                        this.setConnectorDetails(addedObj || node, connectorObjectsDetails);\n                        targerNodes.children.push(addedObj.id);\n                    }\n                    addedObj = this.diagram.add(targerNodes);\n                    this.setConnectorDetails(addedObj || targerNodes, connectorObjectsDetails);\n                }\n                else {\n                    var addedObj = this.diagram.add(targerNodes);\n                    this.setConnectorDetails(addedObj || targerNodes, connectorObjectsDetails);\n                }\n                if (targerNodes.parentId) {\n                    var parentId = targerNodes.parentId;\n                    var group = this.diagram.nameTable[\"\" + parentId];\n                    this.diagram.addChildToGroup(group, targerNodes.id);\n                }\n            }\n        }\n        this.diagram.endGroupAction();\n    };\n    CommandHandler.prototype.setConnectorDetails = function (obj, connectorObjectsDetails) {\n        var details = connectorObjectsDetails[obj.id];\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            if (details) {\n                if (details.inEdges && details.inEdges.length > 0) {\n                    for (var i = 0; i < details.inEdges.length; i++) {\n                        var con = this.diagram.nameTable[details.inEdges[parseInt(i.toString(), 10)]];\n                        con.targetID = obj.id;\n                    }\n                }\n                if (details.outEdges && details.outEdges.length > 0) {\n                    for (var i = 0; i < details.outEdges.length; i++) {\n                        var con = this.diagram.nameTable[details.outEdges[parseInt(i.toString(), 10)]];\n                        con.sourceID = obj.id;\n                    }\n                }\n            }\n        }\n        else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n            if (details) {\n                obj.sourceID = details.sourceID;\n                obj.targetID = details.targetID;\n                obj.sourcePortID = details.sourcePortID;\n                obj.targetPortID = details.targetPortID;\n            }\n        }\n    };\n    /**\n     * cloneLayer method\\\n     *\n     * @returns { void }    cloneLayer method .\\\n     * @param {string[]} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.cloneLayer = function (layerName) {\n        var layers = this.diagram.layers;\n        var layer = this.getLayer(layerName);\n        if (layer) {\n            var cloneObject_1 = [];\n            var newlayer = {\n                id: layerName + '_' + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)(), objects: [], visible: true, lock: false\n            };\n            this.addLayer(newlayer, null, true);\n            newlayer.zIndex = this.diagram.layers.length - 1;\n            var multiSelect = cloneObject_1.length !== 1;\n            for (var _i = 0, _a = layer.objects; _i < _a.length; _i++) {\n                var obj = _a[_i];\n                cloneObject_1.push(this.diagram.nameTable[\"\" + obj]);\n            }\n            this.paste(cloneObject_1);\n        }\n    };\n    /**\n     * copy method\\\n     *\n     * @returns { void }    copy method .\\\n     * @private\n     */\n    CommandHandler.prototype.copy = function () {\n        this.clipboardData.pasteIndex = 1;\n        this.clipboardData.clipObject = this.copyObjects();\n        return this.clipboardData.clipObject;\n    };\n    /**\n     * copyObjects method\\\n     *\n     * @returns { Object[] }    copyObjects method .\\\n     * @private\n     */\n    CommandHandler.prototype.copyObjects = function () {\n        var selectedItems = [];\n        var obj = [];\n        this.clipboardData.childTable = {};\n        if (this.diagram.selectedItems.connectors.length > 0) {\n            //908602 - Issue in Cut connectors\n            selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);\n            for (var j = 0; j < selectedItems.length; j++) {\n                var element = void 0;\n                //To copy text annotation node while copying the text annotation connector.\n                if (this.diagram.bpmnModule &&\n                    selectedItems[parseInt(j.toString(), 10)].isBpmnAnnotationConnector) {\n                    element = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)((this.diagram.nameTable[selectedItems[parseInt(j.toString(), 10)].targetID]));\n                }\n                else {\n                    element = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)((selectedItems[parseInt(j.toString(), 10)]));\n                }\n                obj.push(element);\n            }\n        }\n        if (this.diagram.selectedItems.nodes.length > 0) {\n            selectedItems = selectedItems.concat(this.diagram.selectedItems.nodes);\n            for (var j = 0; j < this.diagram.selectedItems.nodes.length; j++) {\n                if (!this.diagram.selectedItems.nodes[parseInt(j.toString(), 10)].isPhase) {\n                    var node = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems.nodes[parseInt(j.toString(), 10)]);\n                    // Bug-913795: Pasting lane selected through rubber band selection results in multiple swimlane to be pasted\n                    // Filter lane nodes-in the collection kept for clipboard data.\n                    var laneNodes = obj.filter(function (node) { return node.isLane; });\n                    // Flag-to check if same lane representing node already pushed in collection\n                    var isCopiedLane = false;\n                    // Check if same lane representing node is already pushed in collection\n                    if (node.isLane) {\n                        for (var _i = 0, laneNodes_1 = laneNodes; _i < laneNodes_1.length; _i++) {\n                            var laneNode = laneNodes_1[_i];\n                            if ((0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.checkSameLaneNodes)(laneNode, node, this.diagram)) {\n                                isCopiedLane = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!((node.isLane || node.isHeader) && this.checkSwimlaneInSelection(node, obj))) {\n                        // Restricting-child node push if parent lane node pushed & same lane nodes push\n                        if (!((0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.isParentNodeSelected)(node, this.diagram) || isCopiedLane)) {\n                            if (node.wrapper && (node.offsetX !== node.wrapper.offsetX)) {\n                                node.offsetX = node.wrapper.offsetX;\n                            }\n                            if (node.wrapper && (node.offsetY !== node.wrapper.offsetY)) {\n                                node.offsetY = node.wrapper.offsetY;\n                            }\n                            var processTable = {};\n                            this.copyProcesses(node);\n                            obj.push((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(node));\n                            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n                            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, -node.rotateAngle, node.offsetX, node.offsetY);\n                            if (node.children) {\n                                var childTable = this.clipboardData.childTable;\n                                var tempNode = void 0;\n                                var elements = [];\n                                var nodes = this.getAllDescendants(node, elements, true);\n                                for (var i = 0; i < nodes.length; i++) {\n                                    tempNode = this.diagram.nameTable[nodes[parseInt(i.toString(), 10)].id];\n                                    var clonedObject = childTable[tempNode.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(tempNode);\n                                    var newOffset = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, { x: clonedObject.wrapper.offsetX, y: clonedObject.wrapper.offsetY });\n                                    if (tempNode instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                                        clonedObject.offsetX = newOffset.x;\n                                        clonedObject.offsetY = newOffset.y;\n                                        clonedObject.rotateAngle -= node.rotateAngle;\n                                    }\n                                }\n                                this.clipboardData.childTable = childTable;\n                            }\n                            // Adding the clonned connectors of swim lane in child table\n                            if (node.shape.type === 'SwimLane') {\n                                var swimlane = this.diagram.getObject(this.diagram.selectedItems.nodes[parseInt(j.toString(), 10)].id);\n                                var childTable = this.clipboardData.childTable;\n                                var connectorsList = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.getConnectors)(this.diagram, swimlane.wrapper.children[0], 0, true);\n                                for (var i = 0; i < connectorsList.length; i++) {\n                                    var connector = this.diagram.getObject(connectorsList[parseInt(i.toString(), 10)]);\n                                    childTable[connector.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(connector);\n                                    childTable[connector.id].parentSwimlaneId = node.id;\n                                }\n                            }\n                            // Adding the clonned LANE of swim lane in child table\n                            if (node && node.isLane) {\n                                var childTable = this.clipboardData.childTable;\n                                var swimlane = this.diagram.getObject(node.parentId);\n                                var lane = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.findLane)(node, this.diagram);\n                                childTable[node.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(lane);\n                                childTable[node.id].width = swimlane.wrapper.actualSize.width;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.sortByZIndex(obj, 'zIndex');\n        //892957: Remove duplicate elements while copy, paste the swimlane\n        if (this.diagram.selectedItems.nodes.some(function (node) {\n            return node.shape.type === 'SwimLane';\n        })) {\n            obj = this.removeDuplicateObjects(obj);\n        }\n        if (this.clipboardData.pasteIndex === 0) {\n            this.startGroupAction();\n            for (var _a = 0, selectedItems_1 = selectedItems; _a < selectedItems_1.length; _a++) {\n                var item = selectedItems_1[_a];\n                if (this.diagram.nameTable[item.id]) {\n                    this.diagram.remove(item);\n                }\n            }\n            this.endGroupAction();\n        }\n        return obj;\n    };\n    /**\n     * findProcesses method\\\n     *\n     * @returns { string[] } findProcesses method .\\\n     * @param {Node} node - provide the laneNode  value.\n     * @private\n     */\n    CommandHandler.prototype.findProcesses = function (node) {\n        var processes = [];\n        var lanes = node.shape.lanes;\n        lanes.forEach(function (lane) {\n            lane.children.forEach(function (child) {\n                var activity = child.shape.activity;\n                if (activity && activity.subProcess.processes) {\n                    activity.subProcess.processes.forEach(function (process) {\n                        processes.push(process);\n                    });\n                }\n            });\n        });\n        return processes;\n    };\n    //892957: To remove duplicate objects\n    CommandHandler.prototype.removeDuplicateObjects = function (objects) {\n        var uniqueObjects = {};\n        for (var i = 0; i < objects.length; i++) {\n            uniqueObjects[objects[parseInt(i.toString(), 10)].id] = objects[parseInt(i.toString(), 10)];\n        }\n        var result = [];\n        //To remove objects with same id\n        for (var key in uniqueObjects) {\n            if (Object.prototype.hasOwnProperty.call(uniqueObjects, key)) {\n                result.push(uniqueObjects[\"\" + key]);\n            }\n        }\n        var _loop_1 = function (i) {\n            if (result[parseInt(i.toString(), 10)].parentId) {\n                var lane_1 = this_1.diagram.getObject(result[parseInt(i.toString(), 10)].parentId);\n                if (lane_1 && lane_1.isLane && lane_1.parentId &&\n                    result.some(function (obj) { return obj.id === lane_1.parentId; })) {\n                    result.splice(i, 1);\n                    i--;\n                }\n            }\n            out_i_1 = i;\n        };\n        var this_1 = this, out_i_1;\n        //To remove the nodes which is child node of copied swimlane\n        for (var i = 0; i < result.length; i++) {\n            _loop_1(i);\n            i = out_i_1;\n        }\n        // Get the keys from childTable\n        var childTableKeys = Object.keys(this.clipboardData.childTable);\n        // Filter the array to remove objects with ids matching the keys in childTable except lane\n        var filteredArray = result.filter(function (item) {\n            return (childTableKeys.indexOf(item.id) === -1 || item.isLane);\n        });\n        return filteredArray;\n    };\n    //To check if the swimlane is selected along with its child lane\n    CommandHandler.prototype.checkSwimlaneInSelection = function (node, obj) {\n        return this.diagram.selectedItems.nodes.some(function (item) { return item.id === node.parentId; });\n    };\n    CommandHandler.prototype.copyProcesses = function (node) {\n        if (node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes &&\n            node.shape.activity.subProcess.processes.length > 0) {\n            var processes = node.shape.activity.subProcess.processes;\n            for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {\n                var i = processes_1[_i];\n                this.processTable[\"\" + i] = ((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.nameTable[\"\" + i]));\n                if (this.processTable[\"\" + i].shape.activity.subProcess.processes &&\n                    this.processTable[\"\" + i].shape.activity.subProcess.processes.length > 0) {\n                    this.copyProcesses(this.processTable[\"\" + i]);\n                }\n            }\n            this.clipboardData.processTable = this.processTable;\n        }\n    };\n    /**\n     * group method\\\n     *\n     * @returns { void }    group method .\\\n     * @private\n     */\n    CommandHandler.prototype.group = function () {\n        var _this = this;\n        this.oldSelectedObjects = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneSelectedObjects)(this.diagram);\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[\"\" + propName];\n        this.diagram.protectPropertyChange(true);\n        this.diagram.diagramActions = this.diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.Group;\n        var selectedItems = [];\n        var obj = {};\n        //let group: Node | Connector;\n        obj.id = 'group' + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)();\n        obj = new _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node(this.diagram, 'nodes', obj, true);\n        obj.children = [];\n        selectedItems = this.diagram.selectedItems.nodes;\n        selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);\n        var connectors = this.diagram.connectors;\n        connectors.forEach(function (connector) {\n            var sourceNode = _this.diagram.nameTable[connector.sourceID];\n            var targetNode = _this.diagram.nameTable[connector.targetID];\n            var isSourceNode = (sourceNode && sourceNode.processId &&\n                (0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(_this.diagram, _this.diagram.nameTable[sourceNode.processId]));\n            var isTargetNode = (targetNode && targetNode.processId &&\n                (0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(_this.diagram, _this.diagram.nameTable[targetNode.processId]));\n            var isAlreadySelected = selectedItems.some(function (item) { return item.id === connector.id; });\n            if (!isAlreadySelected && (isSourceNode || isTargetNode)) {\n                selectedItems.push(connector);\n            }\n        });\n        var order = selectedItems.sort(function (a, b) {\n            return a.zIndex - b.zIndex;\n        });\n        for (var i = 0; i < order.length; i++) {\n            if (!order[parseInt(i.toString(), 10)].parentId) {\n                obj.children.push(order[parseInt(i.toString(), 10)].id);\n            }\n        }\n        //867606 - Exception throws while grouping the existing group nodes.\n        if (obj.children.length > 0) {\n            var group = this.diagram.add(obj);\n            if (group) {\n                this.select(group);\n            }\n            // 939249: Duplicate Ports Added to Group After Grouping and Undoing.\n            obj.annotations = group.annotations;\n            obj.ports = group.ports;\n            obj.style = group.style;\n            var entry = { type: 'Group', undoObject: obj, redoObject: obj, category: 'Internal' };\n            this.addHistoryEntry(entry);\n            this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.Group;\n            this.diagram.protectPropertyChange(protectedChange);\n            // this.updateBlazorSelector();\n        }\n    };\n    /**\n     * unGroup method\\\n     *\n     * @returns {  void }    unGroup method .\\\n     * @param {NodeModel} obj - provide the angle value.\n     * @private\n     */\n    CommandHandler.prototype.unGroup = function (obj) {\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[\"\" + propName];\n        this.diagram.protectPropertyChange(true);\n        this.diagram.diagramActions = this.diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.Group;\n        var selectedItems = [];\n        if (obj) {\n            selectedItems.push(obj);\n        }\n        else {\n            selectedItems = this.diagram.selectedItems.nodes;\n        }\n        this.diagram.startGroupAction();\n        for (var i = 0; i < selectedItems.length; i++) {\n            var node = selectedItems[parseInt(i.toString(), 10)];\n            var undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(node);\n            var childCollection = [];\n            for (var k = 0; k < node.children.length; k++) {\n                childCollection.push(node.children[parseInt(k.toString(), 10)]);\n            }\n            if (node.children) {\n                if (node.ports && node.ports.length > 0) {\n                    this.diagram.removePorts(node, node.ports);\n                }\n                if (node.annotations && node.annotations.length > 0 && (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)())) {\n                    this.diagram.removeLabels(node, node.annotations);\n                }\n                var parentNode = this.diagram.nameTable[node.parentId];\n                for (var j = node.children.length - 1; j >= 0; j--) {\n                    (this.diagram.nameTable[node.children[parseInt(j.toString(), 10)]]).parentId = '';\n                    var childNode = node.children[parseInt(j.toString(), 10)];\n                    this.diagram.deleteChild(this.diagram.nameTable[node.children[parseInt(j.toString(), 10)]], node);\n                    if (node.parentId && childNode) {\n                        this.diagram.addChild(parentNode, childNode);\n                    }\n                }\n                this.resetDependentConnectors(node.inEdges, true);\n                this.resetDependentConnectors(node.outEdges, false);\n                var entry = {\n                    type: 'UnGroup', undoObject: undoObject,\n                    redoObject: undoObject, category: 'Internal'\n                };\n                if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(entry);\n                }\n                if (node.parentId) {\n                    this.diagram.deleteChild(node, parentNode);\n                }\n            }\n            this.diagram.removeNode(node, childCollection);\n            this.clearSelection();\n        }\n        this.diagram.endGroupAction();\n        this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.Group;\n        this.diagram.protectPropertyChange(protectedChange);\n    };\n    CommandHandler.prototype.resetDependentConnectors = function (edges, isInEdges) {\n        for (var i = 0; i < edges.length; i++) {\n            var newConnector = this.diagram.nameTable[edges[parseInt(i.toString(), 10)]];\n            var undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(newConnector);\n            var newProp = void 0;\n            if (isInEdges) {\n                newConnector.targetID = '';\n                newConnector.targetPortID = '';\n                newProp = { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID };\n            }\n            else {\n                newConnector.sourceID = '';\n                newConnector.sourcePortID = '';\n                newProp = { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID };\n            }\n            this.diagram.connectorPropertyChange(newConnector, {}, newProp);\n            var entry = {\n                type: 'ConnectionChanged', undoObject: { connectors: [undoObject], nodes: [] },\n                redoObject: { connectors: [(0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(newConnector)], nodes: [] }, category: 'Internal'\n            };\n            if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n    };\n    /**\n     * paste method\\\n     *\n     * @returns { void }    paste method .\\\n     * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.paste = function (obj) {\n        if (obj || this.clipboardData.clipObject) {\n            this.diagram.protectPropertyChange(true);\n            var copiedItems = obj ? this.getNewObject(obj) :\n                this.clipboardData.clipObject;\n            if (copiedItems) {\n                var multiSelect = copiedItems.length !== 1;\n                var groupAction = false;\n                var objectTable = {};\n                var keyTable = {};\n                if (this.clipboardData.pasteIndex !== 0) {\n                    this.clearSelection();\n                }\n                if (this.diagram.undoRedoModule) {\n                    groupAction = true;\n                    this.diagram.historyManager.startGroupAction();\n                }\n                for (var _i = 0, copiedItems_1 = copiedItems; _i < copiedItems_1.length; _i++) {\n                    var copy = copiedItems_1[_i];\n                    objectTable[copy.id] = copy;\n                }\n                var copiedObject = [];\n                if (multiSelect) {\n                    // This bool is also consider to prevent selection change event is triggered after every object clone\n                    this.diagram.isServerUpdate = true;\n                }\n                for (var j = 0; j < copiedItems.length; j++) {\n                    var copy = copiedItems[parseInt(j.toString(), 10)];\n                    //EJ2-841227-Copy paste of child node from group node\n                    if (copy.parentId) {\n                        var parentObj = this.diagram.getObject(copy.parentId);\n                        if (parentObj.shape.type !== 'SwimLane' && copy.parentId) {\n                            copy.parentId = '';\n                        }\n                    }\n                    if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(copy) === _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n                        var clonedObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(copy);\n                        var nodeId = clonedObj.sourceID;\n                        clonedObj.sourceID = '';\n                        if (objectTable[\"\" + nodeId] && keyTable[\"\" + nodeId]) {\n                            clonedObj.sourceID = keyTable[\"\" + nodeId];\n                        }\n                        nodeId = clonedObj.targetID;\n                        clonedObj.targetID = '';\n                        if (objectTable[\"\" + nodeId] && keyTable[\"\" + nodeId]) {\n                            clonedObj.targetID = keyTable[\"\" + nodeId];\n                        }\n                        //To check if the connector is cloned already for text annotation node.\n                        var allowClone = true;\n                        if (clonedObj.targetID) {\n                            var targetNode = this.diagram.nameTable[clonedObj.targetID];\n                            if (targetNode.shape.shape === 'TextAnnotation' && targetNode.inEdges && targetNode.inEdges.length > 0) {\n                                allowClone = false;\n                            }\n                        }\n                        if (allowClone) {\n                            var newObj = this.cloneConnector(clonedObj, multiSelect);\n                            copiedObject.push(newObj);\n                            keyTable[copy.id] = newObj.id;\n                        }\n                    }\n                    else {\n                        // Ej2-909148-BPMN -- BPMN Subprocess Issues with Node Misplacement During Copy/Paste and Undo/Redo\n                        if (copy.shape && copy.shape.type === 'Bpmn') {\n                            copy.processId = '';\n                        }\n                        //To indicate the node cloning which helps to avoid alignment of child nodes with flip.\n                        this.cloningInProgress = true;\n                        var newNode = this.cloneNode(copy, multiSelect);\n                        this.cloningInProgress = false;\n                        copiedObject.push(newNode);\n                        //bpmn text annotations will not be pasted\n                        if (newNode) {\n                            keyTable[copy.id] = newNode.id;\n                            var edges = copy.inEdges;\n                            if (edges) {\n                                for (var _a = 0, edges_1 = edges; _a < edges_1.length; _a++) {\n                                    var edge = edges_1[_a];\n                                    if (objectTable[\"\" + edge] && keyTable[\"\" + edge]) {\n                                        var newConnector = this.diagram.nameTable[keyTable[\"\" + edge]];\n                                        newConnector.targetID = keyTable[copy.id];\n                                        this.diagram.connectorPropertyChange(newConnector, { targetID: '', targetPortID: '' }, { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID });\n                                    }\n                                }\n                            }\n                            edges = copy.outEdges;\n                            if (edges) {\n                                for (var _b = 0, edges_2 = edges; _b < edges_2.length; _b++) {\n                                    var edge = edges_2[_b];\n                                    if (objectTable[\"\" + edge] && keyTable[\"\" + edge]) {\n                                        var newConnector = this.diagram.nameTable[keyTable[\"\" + edge]];\n                                        newConnector.sourceID = keyTable[copy.id];\n                                        this.diagram.connectorPropertyChange(newConnector, { sourceID: '', sourcePortID: '' }, { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (multiSelect) {\n                    this.diagram.isServerUpdate = false;\n                    // this.diagram.UpdateBlazorDiagramModelCollection(copiedItems[0] as Node, copiedObject);\n                    // this.getBlazorOldValues();\n                    this.diagram.select(copiedObject, true);\n                }\n                if (groupAction === true) {\n                    this.diagram.historyManager.endGroupAction();\n                    groupAction = false;\n                }\n                if (this.diagram.mode !== 'SVG') {\n                    this.diagram.refreshDiagramLayer();\n                }\n                this.clipboardData.pasteIndex++;\n                this.diagram.protectPropertyChange(false);\n            }\n        }\n    };\n    CommandHandler.prototype.getNewObject = function (obj) {\n        var newObj;\n        var newobjs = [];\n        this.clipboardData.pasteIndex = 1;\n        for (var i = 0; i < obj.length; i++) {\n            newObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj[parseInt(i.toString(), 10)]);\n            newobjs.push(newObj);\n        }\n        return newobjs;\n    };\n    CommandHandler.prototype.cloneConnector = function (connector, multiSelect) {\n        //let newConnector: Node | Connector;\n        var cloneObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(connector);\n        this.translateObject(cloneObject);\n        cloneObject.zIndex = Number.MIN_VALUE;\n        var newConnector = this.diagram.add(cloneObject);\n        if (!this.diagram.isServerUpdate) {\n            this.selectObjects([newConnector], multiSelect);\n        }\n        return newConnector;\n    };\n    CommandHandler.prototype.cloneNode = function (node, multiSelect, children, groupnodeID) {\n        var newNode;\n        var connectorsTable = {};\n        var cloneObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(node);\n        var process;\n        var temp = this.diagram.nameTable[node.parentId];\n        if (node.shape && node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes\n            && node.shape.activity.subProcess.processes.length) {\n            process = cloneObject.shape.activity.subProcess.processes;\n            cloneObject.zIndex = Number.MIN_VALUE;\n            cloneObject.shape.activity.subProcess.processes = undefined;\n        }\n        if (node.shape && node.shape.type === 'SwimLane') {\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.pasteSwimLane)(node, this.diagram, this.clipboardData);\n        }\n        else if (temp && temp.shape.type === 'SwimLane') {\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.pasteSwimLane)((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(temp), this.diagram, this.clipboardData, node, true);\n        }\n        else if (node.children && node.children.length && (!children || !children.length)) {\n            newNode = this.cloneGroup(node, multiSelect);\n        }\n        else {\n            this.translateObject(cloneObject, groupnodeID);\n            cloneObject.zIndex = Number.MIN_VALUE;\n            if (children) {\n                cloneObject.children = children;\n            }\n            if (cloneObject.shape && cloneObject.shape.shape === 'TextAnnotation') {\n                cloneObject.isTextAnnotationCopied = true;\n            }\n            newNode = this.diagram.add(cloneObject);\n        }\n        for (var _i = 0, _a = Object.keys(connectorsTable); _i < _a.length; _i++) {\n            var i = _a[_i];\n            this.diagram.add(connectorsTable[\"\" + i]);\n        }\n        if (process && process.length) {\n            newNode.shape.activity.subProcess.processes = process;\n            this.cloneSubProcesses(newNode);\n        }\n        if (newNode && !this.diagram.isServerUpdate) {\n            this.selectObjects([newNode], multiSelect);\n        }\n        return newNode;\n    };\n    CommandHandler.prototype.cloneSubProcesses = function (node) {\n        var connector = [];\n        var temp = {};\n        if (node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes\n            && node.shape.activity.subProcess.processes.length) {\n            var process = node.shape.activity.subProcess.processes;\n            for (var g = 0; g < process.length; g++) {\n                var child = this.diagram.nameTable[process[parseInt(g.toString(), 10)]]\n                    || this.clipboardData.processTable[process[parseInt(g.toString(), 10)]];\n                for (var _i = 0, _a = child.outEdges; _i < _a.length; _i++) {\n                    var j = _a[_i];\n                    if (connector.indexOf(j) < 0) {\n                        connector.push(j);\n                    }\n                }\n                for (var _b = 0, _c = child.inEdges; _b < _c.length; _b++) {\n                    var j = _c[_b];\n                    if (connector.indexOf(j) < 0) {\n                        connector.push(j);\n                    }\n                }\n                var innerChild = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.clipboardData.processTable[process[parseInt(g.toString(), 10)]]);\n                innerChild.processId = node.id;\n                var newNode = this.cloneNode(innerChild, false);\n                temp[process[parseInt(g.toString(), 10)]] = newNode.id;\n                process[parseInt(g.toString(), 10)] = newNode.id;\n                this.diagram.addProcess(newNode, node.id);\n                for (var _d = 0, connector_1 = connector; _d < connector_1.length; _d++) {\n                    var i = connector_1[_d];\n                    var node_1 = this.diagram.nameTable[\"\" + i] || this.diagram.connectorTable[\"\" + i];\n                    var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(node_1);\n                    if (temp[clonedNode.sourceID] && temp[clonedNode.targetID]) {\n                        clonedNode.zIndex = -1;\n                        clonedNode.id += (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)();\n                        clonedNode.sourceID = temp[clonedNode.sourceID];\n                        clonedNode.targetID = temp[clonedNode.targetID];\n                        connector.splice(connector.indexOf(i), 1);\n                        //937235: Copy paste subprocess with connector, the connector disappears.\n                        clonedNode.zIndex = Number.MIN_VALUE;\n                        this.diagram.add(clonedNode);\n                    }\n                }\n            }\n        }\n    };\n    CommandHandler.prototype.cloneGroup = function (obj, multiSelect) {\n        var value;\n        var sourceId;\n        var targetId;\n        var newChildren = [];\n        var children = [];\n        var connectorObj = [];\n        var newObj;\n        var oldID = [];\n        children = children.concat(obj.children);\n        var id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)();\n        var objectCollection = [];\n        this.diagram.blazorActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_10__.BlazorAction.GroupClipboardInProcess;\n        if (this.clipboardData.childTable || obj.children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n                var childObj = void 0;\n                if (this.clipboardData.childTable) {\n                    childObj = this.clipboardData.childTable[children[parseInt(i.toString(), 10)]];\n                    // EJ2-905181 - Added to consider copy paste and clone the new group node.\n                    if (!childObj) {\n                        childObj = this.diagram.nameTable[children[parseInt(i.toString(), 10)]];\n                    }\n                }\n                else {\n                    childObj = this.diagram.nameTable[children[parseInt(i.toString(), 10)]];\n                }\n                childObj.parentId = '';\n                if (childObj) {\n                    if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(childObj) === _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n                        connectorObj.push(childObj);\n                    }\n                    else {\n                        newObj = this.cloneNode(childObj, multiSelect, undefined, id);\n                        oldID.push(childObj.id);\n                        newChildren.push(newObj.id);\n                        objectCollection.push(newObj);\n                    }\n                }\n            }\n        }\n        for (var k = 0; k < connectorObj.length; k++) {\n            if (connectorObj[parseInt(k.toString(), 10)].sourceID || connectorObj[parseInt(k.toString(), 10)].targetID) {\n                for (var j = 0; j < oldID.length; j++) {\n                    if (connectorObj[parseInt(k.toString(), 10)].sourceID === (oldID[parseInt(j.toString(), 10)])) {\n                        sourceId = connectorObj[parseInt(k.toString(), 10)].sourceID;\n                        connectorObj[parseInt(k.toString(), 10)].sourceID += id;\n                    }\n                    if (connectorObj[parseInt(k.toString(), 10)].targetID === (oldID[parseInt(j.toString(), 10)])) {\n                        targetId = connectorObj[parseInt(k.toString(), 10)].targetID;\n                        connectorObj[parseInt(k.toString(), 10)].targetID += id;\n                    }\n                }\n            }\n            newObj = this.cloneConnector(connectorObj[parseInt(k.toString(), 10)], multiSelect);\n            //EJ2-839982 - When we copy paste the group node multiple times, the connector is not rendered properly\n            connectorObj[parseInt(k.toString(), 10)].sourceID = sourceId;\n            connectorObj[parseInt(k.toString(), 10)].targetID = targetId;\n            newChildren.push(newObj.id);\n            objectCollection.push(newObj);\n        }\n        var parentObj = this.cloneNode(obj, multiSelect, newChildren);\n        objectCollection.push(parentObj);\n        if (parentObj && parentObj.container && parentObj.shape && parentObj.shape.type === 'UmlClassifier') {\n            this.diagram.updateDiagramObject(parentObj);\n            parentObj.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_14__.Size());\n        }\n        this.diagram.blazorActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.BlazorAction.GroupClipboardInProcess;\n        if (!this.diagram.isServerUpdate) {\n            this.diagram.UpdateBlazorDiagramModelCollection(undefined, objectCollection, undefined, true);\n        }\n        else {\n            this.cloneGroupChildCollection = objectCollection;\n        }\n        return parentObj;\n    };\n    /**\n     * translateObject method\\\n     *\n     * @returns { Object[] }    translateObject method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @param {string} groupnodeID - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.translateObject = function (obj, groupnodeID) {\n        obj.id += groupnodeID || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)();\n        var diff = this.clipboardData.pasteIndex * 10;\n        if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(obj) === _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n            obj.sourcePoint = {\n                x: obj.sourcePoint.x + diff, y: obj.sourcePoint.y + diff\n            };\n            obj.targetPoint = {\n                x: obj.targetPoint.x + diff, y: obj.targetPoint.y + diff\n            };\n            if (obj.type === 'Bezier') {\n                var segments = obj.segments;\n                for (var i = 0; i < segments.length; i++) {\n                    if (!_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.isEmptyPoint(segments[parseInt(i.toString(), 10)].point1)) {\n                        segments[parseInt(i.toString(), 10)].point1 = {\n                            x: segments[parseInt(i.toString(), 10)].point1.x + diff, y: segments[parseInt(i.toString(), 10)].point1.y + diff\n                        };\n                    }\n                    if (!_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.isEmptyPoint(segments[parseInt(i.toString(), 10)].point2)) {\n                        segments[parseInt(i.toString(), 10)].point2 = {\n                            x: segments[parseInt(i.toString(), 10)].point2.x + diff, y: segments[parseInt(i.toString(), 10)].point2.y + diff\n                        };\n                    }\n                }\n            }\n            if (obj.type === 'Straight' || obj.type === 'Bezier') {\n                if (obj.segments && obj.segments.length > 0) {\n                    var segments = obj.segments;\n                    for (var i = 0; i < segments.length - 1; i++) {\n                        segments[parseInt(i.toString(), 10)].point.x += diff;\n                        segments[parseInt(i.toString(), 10)].point.y += diff;\n                    }\n                }\n            }\n        }\n        else {\n            obj.offsetX += diff;\n            obj.offsetY += diff;\n        }\n    };\n    /**\n     * drawObject method\\\n     *\n     * @returns { Node | Connector }    drawObject method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.drawObject = function (obj) {\n        var newObj;\n        //let cloneObject: Node | Connector;\n        if (obj && obj.shape) {\n            if (obj.shape.type === 'Text') {\n                obj.width = this.diagram.drawingObject.width ? this.diagram.drawingObject.width : 50;\n                obj.height = this.diagram.drawingObject.height ? this.diagram.drawingObject.height : 20;\n            }\n        }\n        var cloneObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.drawingObject);\n        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n            var prop = _a[_i];\n            cloneObject[\"\" + prop] = obj[\"\" + prop];\n        }\n        if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(this.diagram.drawingObject) === _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node || ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(this.diagram.drawingObject) === _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && this.diagram.drawingObject.type === 'Freehand' && obj.type !== 'Bezier')) {\n            newObj = new _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node(this.diagram, 'nodes', cloneObject, true);\n            newObj.id = (this.diagram.drawingObject.id || 'node') + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)();\n        }\n        else {\n            newObj = new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector(this.diagram, 'connectors', cloneObject, true);\n            newObj.id = (this.diagram.drawingObject ? (this.diagram.drawingObject.id ? this.diagram.drawingObject.id : 'connector')\n                : 'connector') + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.randomId)();\n        }\n        this.diagram.initObject(newObj);\n        this.diagram.updateDiagramObject(newObj);\n        this.diagram.currentDrawingObject = newObj;\n        return newObj;\n    };\n    /**\n     * addObjectToDiagram method\\\n     *\n     * @returns { void }    addObjectToDiagram method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.addObjectToDiagram = function (obj) {\n        //let newObj: Node | Connector;\n        this.diagram.removeFromAQuad(obj);\n        this.diagram.removeObjectsFromLayer(this.diagram.nameTable[obj.id]);\n        delete this.diagram.nameTable[obj.id];\n        //EJ2-62652 - Added below code to empty the segment collection if connector type is bezier\n        if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && obj.type === 'Bezier' && obj.segments.length > 0\n            && (this.diagram.drawingObject && this.diagram.drawingObject.type === 'Bezier')) {\n            obj.segments = [];\n        }\n        var newObj = this.diagram.add(obj);\n        if (this.diagram.mode !== 'SVG') {\n            this.diagram.refreshDiagramLayer();\n        }\n        this.selectObjects([newObj]);\n        if (obj && (!((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canContinuousDraw)(this.diagram)))) {\n            this.diagram.tool &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramTools.DrawOnce;\n            this.diagram.currentDrawingObject = undefined;\n        }\n    };\n    /**\n     * addObjectToDiagram method\\\n     *\n     * @returns { void }    addObjectToDiagram method .\\\n     * @param {boolean} enable - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.enableServerDataBinding = function (enable) {\n        this.diagram.enableServerDataBinding(enable);\n    };\n    /**\n     * addText method\\\n     *\n     * @returns { void }    addText method .\\\n     * @param {boolean} obj - provide the objects value.\n     * @param {PointModel} currentPosition - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.addText = function (obj, currentPosition) {\n        var annotation = this.diagram.findElementUnderMouse(obj, currentPosition, this.diagram);\n        this.diagram.startTextEdit(obj, annotation instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_3__.TextElement ? (annotation.id).split('_')[1] : undefined);\n    };\n    /**\n     * isUserHandle method\\\n     *\n     * @returns { boolean }    isUserHandle method .\\\n     * @param {PointModel} position - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.isUserHandle = function (position) {\n        var handle = this.diagram.selectedItems;\n        if (handle.wrapper && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.canShowCorner)(handle.constraints, 'UserHandle')) {\n            for (var _i = 0, _a = handle.userHandles; _i < _a.length; _i++) {\n                var obj = _a[_i];\n                if (obj.visible) {\n                    var paddedBounds = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getUserHandlePosition)(handle, obj, this.diagram.scroller.transform);\n                    if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.contains)(position, paddedBounds, obj.size / (2 * this.diagram.scroller.transform.scale))) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * selectObjects method\\\n     *\n     * @returns { Promise<void> }    selectObjects method .\\\n     * @param {(NodeModel | ConnectorModel | AnnotationModel)[]} obj - provide the objects value.\n     * @param {boolean} multipleSelection - provide the objects value.\n     * @param {(NodeModel | ConnectorModel| AnnotationModel)[]} oldValue - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.selectObjects = function (obj, multipleSelection, oldValue) {\n        return __awaiter(this, void 0, void 0, function () {\n            var arg, swimlaneNode, laneId, j, i, parentId, select, oldSelectedItems, canDoMultipleSelection, canDoSingleSelection, i, newObj, i_1, parentNode;\n            return __generator(this, function (_a) {\n                arg = {\n                    oldValue: oldValue ? oldValue : this.getSelectedObject(),\n                    newValue: obj, cause: this.diagram.diagramActions,\n                    state: 'Changing', type: 'Addition', cancel: false\n                };\n                // EJ2-57157 - Added to consider the lane header at selection change when selecting a lane.\n                if (obj.length > 0 && (obj[0] && obj[0].isLane)) {\n                    swimlaneNode = this.diagram.getObject(obj[0].parentId);\n                    obj[0].shape.header = [];\n                    laneId = '';\n                    for (j = 0; j < obj.length; j++) {\n                        for (i = 0; i < swimlaneNode.shape.lanes.length; i++) {\n                            parentId = obj[0].id.split(obj[0].parentId);\n                            laneId = parentId[1].slice(0, -1);\n                            if (laneId === swimlaneNode.shape.lanes[parseInt(i.toString(), 10)].id) {\n                                obj[0].shape.header.push(swimlaneNode.shape.lanes[parseInt(i.toString(), 10)].header);\n                            }\n                        }\n                    }\n                }\n                this.diagram.enableServerDataBinding(false);\n                select = true;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)()) {\n                    this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, arg);\n                }\n                else {\n                    this.oldSelectedObjects = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneSelectedObjects)(this.diagram);\n                }\n                oldSelectedItems = this.diagram.selectedItems.annotation ?\n                    [this.diagram.selectedItems.annotation] :\n                    (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));\n                canDoMultipleSelection = (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canMultiSelect)(this.diagram);\n                canDoSingleSelection = (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canSingleSelect)(this.diagram);\n                if (canDoSingleSelection || canDoMultipleSelection) {\n                    if (!canDoMultipleSelection && ((obj.length > 1) || (multipleSelection && obj.length === 1))) {\n                        if (obj.length === 1) {\n                            this.clearSelection();\n                        }\n                        else {\n                            return [2 /*return*/];\n                        }\n                    }\n                    if (!(canDoSingleSelection || canDoMultipleSelection) && obj.length === 1\n                        && (!multipleSelection || !(0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram))) {\n                        this.clearSelection();\n                        return [2 /*return*/];\n                    }\n                }\n                if (!arg.cancel) {\n                    for (i = 0; i < obj.length; i++) {\n                        newObj = obj[parseInt(i.toString(), 10)];\n                        if (newObj) {\n                            select = true;\n                            if (!(0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram)) {\n                                this.select(newObj, i > 0 || multipleSelection, true);\n                            }\n                            else {\n                                if ((i > 0 || multipleSelection) && newObj.children && !newObj.parentId) {\n                                    for (i_1 = 0; i_1 < this.diagram.selectedItems.nodes.length; i_1++) {\n                                        parentNode = this.diagram.nameTable[this.diagram.selectedItems.nodes[parseInt(i_1.toString(), 10)].parentId];\n                                        if (parentNode) {\n                                            parentNode = this.findParent(parentNode);\n                                            if (parentNode) {\n                                                if (newObj.id === parentNode.id) {\n                                                    this.selectGroup(newObj);\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                this.selectProcesses(newObj);\n                                select = this.selectBpmnSubProcesses(newObj);\n                                if (select) {\n                                    this.select(newObj, i > 0 || multipleSelection, true);\n                                }\n                            }\n                        }\n                    }\n                    if (oldValue === undefined) {\n                        oldValue = oldSelectedItems;\n                    }\n                    arg = {\n                        oldValue: oldValue ? oldValue : [],\n                        newValue: this.getSelectedObject(),\n                        cause: this.diagram.diagramActions, state: 'Changed', type: 'Addition', cancel: false\n                    };\n                    this.diagram.renderSelector(multipleSelection || (obj && obj.length > 1));\n                    // this.updateBlazorSelectorModel(oldValue);\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)()) {\n                        this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, arg);\n                    }\n                    this.diagram.enableServerDataBinding(true);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    // /**\n    //  * updateBlazorSelector method\\\n    //  *\n    //  * @returns { void }    updateBlazorSelector method .\\\n    //  * @private\n    //  */\n    // public updateBlazorSelector(): void {\n    //     //remove blazor code\n    // }\n    /**\n     * findParent method\\\n     *\n     * @returns { Node }    findParent method .\\\n     * @param {Node} node - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.findParent = function (node) {\n        if (node.parentId) {\n            node = this.diagram.nameTable[node.parentId];\n            this.findParent(node);\n        }\n        return node;\n    };\n    CommandHandler.prototype.selectProcesses = function (newObj) {\n        if (this.hasProcesses(newObj)) {\n            var processes = (newObj).shape.activity.subProcess.processes;\n            for (var i = 0; i < processes.length; i++) {\n                var innerChild = this.diagram.nameTable[processes[parseInt(i.toString(), 10)]];\n                if (this.hasProcesses(innerChild)) {\n                    this.selectObjects([innerChild], true);\n                }\n                this.unSelect(innerChild);\n            }\n        }\n    };\n    CommandHandler.prototype.selectGroup = function (newObj) {\n        for (var j = 0; j < newObj.children.length; j++) {\n            var innerChild = this.diagram.nameTable[newObj.children[parseInt(j.toString(), 10)]];\n            if (innerChild.children) {\n                this.selectGroup(innerChild);\n            }\n            this.unSelect(this.diagram.nameTable[newObj.children[parseInt(j.toString(), 10)]]);\n        }\n    };\n    CommandHandler.prototype.selectBpmnSubProcesses = function (node) {\n        var select = true;\n        var parent;\n        if (node.processId) {\n            if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(this.diagram, this.diagram.nameTable[node.processId])) {\n                select = false;\n            }\n            else {\n                select = this.selectBpmnSubProcesses(this.diagram.nameTable[node.processId]);\n            }\n        }\n        else if (node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n            if (node.sourceID && this.diagram.nameTable[node.sourceID] &&\n                this.diagram.nameTable[node.sourceID].processId) {\n                parent = this.diagram.nameTable[node.sourceID].processId;\n            }\n            if (node.targetID && this.diagram.nameTable[node.targetID] &&\n                this.diagram.nameTable[node.targetID].processId) {\n                parent = this.diagram.nameTable[node.targetID].processId;\n            }\n            if (parent) {\n                if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(this.diagram, this.diagram.nameTable[\"\" + parent])) {\n                    return false;\n                }\n                else {\n                    select = this.selectBpmnSubProcesses(this.diagram.nameTable[\"\" + parent]);\n                }\n            }\n        }\n        else if (node.parentId && this.diagram.nameTable[node.parentId] &&\n            this.diagram.nameTable[node.parentId].shape.type === 'UmlClassifier') {\n            if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(this.diagram, this.diagram.nameTable[node.parentId])) {\n                select = false;\n            }\n        }\n        return select;\n    };\n    CommandHandler.prototype.hasProcesses = function (node) {\n        if (node) {\n            if ((node.shape.type === 'Bpmn') && node.shape.activity &&\n                node.shape.activity.subProcess.processes &&\n                node.shape.activity.subProcess.processes.length > 0) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * select method\\\n     *\n     * @returns { void }    select method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @param {boolean} multipleSelection - provide the objects value.\n     * @param {boolean} preventUpdate - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.select = function (obj, multipleSelection, preventUpdate) {\n        var hasLayer = this.getObjectLayer(obj.id);\n        if (((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canSelect)(obj) && !(obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) && !(0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(this.diagram, obj))\n            && (hasLayer && !hasLayer.lock && hasLayer.visible) && obj.wrapper.visible) {\n            multipleSelection = (0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram) ? multipleSelection : false;\n            if (!multipleSelection) {\n                this.clearSelection();\n            }\n            this.diagram.enableServerDataBinding(false);\n            var selectorModel = this.diagram.selectedItems;\n            var convert = obj;\n            if (convert instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                if (obj.isHeader) {\n                    var node = this.diagram.nameTable[obj.parentId];\n                    selectorModel.nodes.push(node);\n                }\n                else {\n                    selectorModel.nodes.push(obj);\n                }\n            }\n            else {\n                selectorModel.connectors.push(obj);\n            }\n            // EJ2-56919 - Push the newly selected objects in selectedObjects collection\n            selectorModel.selectedObjects.push(obj);\n            if (!multipleSelection) {\n                selectorModel.init(this.diagram);\n                if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n                    var wrapper = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.gridSelection)(this.diagram, selectorModel);\n                    if (wrapper) {\n                        selectorModel.wrapper.children[0] = wrapper;\n                    }\n                    selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n                    selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n                    selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n                }\n            }\n            else {\n                selectorModel.wrapper.rotateAngle = selectorModel.rotateAngle = 0;\n                selectorModel.wrapper.children.push(obj.wrapper);\n            }\n            if (!preventUpdate) {\n                this.diagram.renderSelector(multipleSelection);\n            }\n            this.diagram.enableServerDataBinding(true);\n        }\n    };\n    // private getObjectCollectionId(isNode: boolean, clearSelection?: boolean): string[] {\n    //     const id: string[] = [];\n    //     let i: number = 0;\n    //     const selectedObject: (NodeModel | ConnectorModel)[] = isNode ? this.diagram.selectedItems.nodes\n    //         : this.diagram.selectedItems.connectors;\n    //     while (!clearSelection && i < selectedObject.length) {\n    //         id[parseInt(i.toString(), 10)] = selectedObject[parseInt(i.toString(), 10)].id;\n    //         i++;\n    //     }\n    //     return id;\n    // }\n    // private updateBlazorSelectorModel(oldItemsCollection: (NodeModel | ConnectorModel)[], clearSelection?: boolean): void {\n    // remove blazor code\n    // }\n    /**\n     * labelSelect method\\\n     *\n     * @returns { void }    labelSelect method .\\\n     * @param {NodeModel | ConnectorModel | AnnotationModel} obj - provide the objects value.\n     * @param {DiagramElement} textWrapper - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.labelSelect = function (obj, textWrapper, oldValue) {\n        this.oldSelectedObjects = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneSelectedObjects)(this.diagram);\n        var annotation = this.findTarget(textWrapper, obj);\n        // Prepare the event arguments\n        var eventArgs = {\n            oldValue: oldValue ? oldValue : this.getSelectedObject(),\n            newValue: [annotation],\n            cause: this.diagram.diagramActions,\n            state: 'Changing', type: 'Addition', cancel: false\n        };\n        // Trigger the selectionChange event with the updated newValue\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)()) {\n            this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, eventArgs);\n        }\n        else {\n            this.oldSelectedObjects = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneSelectedObjects)(this.diagram);\n        }\n        if (!eventArgs.cancel) {\n            var selectorModel = (this.diagram.selectedItems);\n            var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n            this.diagram.allowServerDataBinding = false;\n            selectorModel.nodes = selectorModel.connectors = [];\n            this.diagram.allowServerDataBinding = isEnableServerDatabind;\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                selectorModel.nodes[0] = obj;\n            }\n            else {\n                selectorModel.connectors[0] = obj;\n            }\n            selectorModel.annotation = annotation;\n            selectorModel.init(this.diagram);\n            this.diagram.renderSelector(false);\n            eventArgs = {\n                oldValue: oldValue ? oldValue : [],\n                newValue: [selectorModel.annotation],\n                cause: this.diagram.diagramActions, state: 'Changed', type: 'Addition', cancel: false\n            };\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)()) {\n                this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, eventArgs);\n            }\n        }\n    };\n    /**\n     * unSelect method\\\n     *\n     * @returns { void }    unSelect method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.unSelect = function (obj) {\n        var objArray = [];\n        objArray.push(obj);\n        var items = (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));\n        var selectedObjects = items.filter(function (items) {\n            return items.id !== obj.id;\n        });\n        var arg = {\n            oldValue: items, newValue: selectedObjects, cause: this.diagram.diagramActions,\n            state: 'Changing', type: 'Removal', cancel: false\n        };\n        if (!this.diagram.currentSymbol) {\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)()) {\n                this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, arg);\n            }\n        }\n        if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(this.diagram, obj)) {\n            var selectormodel = this.diagram.selectedItems;\n            var index = void 0;\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                index = selectormodel.nodes.indexOf(obj, 0);\n                selectormodel.nodes.splice(index, 1);\n            }\n            else {\n                index = selectormodel.connectors.indexOf(obj, 0);\n                selectormodel.connectors.splice(index, 1);\n            }\n            index = selectormodel.selectedObjects.indexOf(obj, 0);\n            selectormodel.selectedObjects.splice(index, 1);\n            arg = {\n                oldValue: items, newValue: selectedObjects, cause: this.diagram.diagramActions,\n                state: 'Changed', type: 'Removal', cancel: false\n            };\n            // this.updateBlazorSelectorModel(objArray);\n            arg = {\n                oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(items), newValue: selectedObjects, cause: this.diagram.diagramActions,\n                state: 'Changed', type: 'Removal', cancel: arg.cancel\n            };\n            if (!arg.cancel) {\n                index = selectormodel.wrapper.children.indexOf(obj.wrapper, 0);\n                selectormodel.wrapper.children.splice(index, 1);\n                this.diagram.updateSelector();\n                if (!this.diagram.currentSymbol) {\n                    this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, arg);\n                }\n            }\n        }\n    };\n    /**\n     * getChildElements method\\\n     *\n     * @returns { string[] }    getChildElements method .\\\n     * @param {DiagramElement[]} child - provide the objects value.\n     * @private\n     */\n    // public getChildElements(child: DiagramElement[]): string[] {\n    //     const children: string[] = [];\n    //     for (let i: number = 0; i < child.length; i++) {\n    //         const childNode: DiagramElement = child[parseInt(i.toString(), 10)];\n    //         if ((childNode as Container).children && (childNode as Container).children.length > 0) {\n    //             // children.concat(this.getChildElements((childNode as Container).children));\n    //         } else {\n    //             children.push(childNode.id);\n    //             if (childNode instanceof TextElement) {\n    //                 children.push(childNode.id + '_text');\n    //             }\n    //         }\n    //     }\n    //     return children;\n    // }\n    /**\n     * moveSvgNode method\\\n     *\n     * @returns { void }    moveSvgNode method .\\\n     * @param {string} nodeId - provide the objects value.\n     * @param {string} targetID - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.moveSvgNode = function (nodeId, targetID) {\n        //Bug 921994: Z-index order changes are not reflected at the UI level with Undo Redo commands.\n        var node = this.diagram.nameTable[\"\" + targetID];\n        if (node.shape.type === 'Native' || node.shape.type === 'HTML') {\n            this.updateNativeNodeIndex(nodeId, targetID);\n        }\n        else {\n            var diagramDiv = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(targetID + '_groupElement', this.diagram.element.id);\n            var backNode = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(nodeId + '_groupElement', this.diagram.element.id);\n            diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n        }\n    };\n    CommandHandler.prototype.moveAfterSvgNode = function (nodeId, targetID) {\n        //Bug 921994: Z-index order changes are not reflected at the UI level with Undo Redo commands.\n        var node = this.diagram.nameTable[\"\" + targetID];\n        if (node && (node.shape.type === 'HTML' || node.shape.type === 'Native')) {\n            for (var i = 0; i < this.diagram.views.length; i++) {\n                var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';\n                var backNode = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(nodeId + id, this.diagram.views[parseInt(i.toString(), 10)]);\n                var diagramDiv = targetID ? (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(targetID + id, this.diagram.views[parseInt(i.toString(), 10)])\n                    : backNode.parentElement.firstChild;\n                if (backNode && diagramDiv) {\n                    if (backNode.parentNode.id === diagramDiv.parentNode.id) {\n                        diagramDiv.insertAdjacentElement('afterend', backNode);\n                    }\n                }\n            }\n        }\n        else {\n            var diagramDiv = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(targetID + '_groupElement', this.diagram.element.id);\n            var backNode = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(nodeId + '_groupElement', this.diagram.element.id);\n            diagramDiv.insertAdjacentElement('afterend', backNode);\n        }\n    };\n    /**\n     * sendLayerBackward method\\\n     *\n     * @returns { void }    sendLayerBackward method .\\\n     * @param {string} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.sendLayerBackward = function (layerName) {\n        var layer = this.getLayer(layerName);\n        if (layer && layer.zIndex !== 0) {\n            var index = layer.zIndex;\n            if (this.diagram.mode === 'SVG') {\n                var currentLayerObject = layer.objects;\n                var targetObject = this.getLayer(this.diagram.layerZIndexTable[index - 1]).objects[0];\n                if (targetObject) {\n                    for (var _i = 0, currentLayerObject_1 = currentLayerObject; _i < currentLayerObject_1.length; _i++) {\n                        var obj = currentLayerObject_1[_i];\n                        this.moveSvgNode(obj, targetObject);\n                    }\n                }\n            }\n            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index - 1]);\n            targetLayer.zIndex = targetLayer.zIndex + 1;\n            layer.zIndex = layer.zIndex - 1;\n            var temp = this.diagram.layerZIndexTable[parseInt(index.toString(), 10)];\n            this.diagram.layerZIndexTable[parseInt(index.toString(), 10)] = this.diagram.layerZIndexTable[index - 1];\n            this.diagram.layerZIndexTable[index - 1] = temp;\n            if (this.diagram.mode === 'Canvas') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * bringLayerForward method\\\n     *\n     * @returns { void }    bringLayerForward method .\\\n     * @param {string} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.bringLayerForward = function (layerName) {\n        var layer = this.getLayer(layerName);\n        if (layer && layer.zIndex < this.diagram.layers.length - 1) {\n            var index = layer.zIndex;\n            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index + 1]);\n            if (this.diagram.mode === 'SVG') {\n                var currentLayerObject = layer.objects[0];\n                var targetLayerObjects = targetLayer.objects;\n                for (var _i = 0, targetLayerObjects_1 = targetLayerObjects; _i < targetLayerObjects_1.length; _i++) {\n                    var obj = targetLayerObjects_1[_i];\n                    if (obj) {\n                        this.moveSvgNode(obj, currentLayerObject);\n                    }\n                }\n            }\n            targetLayer.zIndex = targetLayer.zIndex - 1;\n            layer.zIndex = layer.zIndex + 1;\n            var temp = this.diagram.layerZIndexTable[parseInt(index.toString(), 10)];\n            this.diagram.layerZIndexTable[parseInt(index.toString(), 10)] = this.diagram.layerZIndexTable[index + 1];\n            this.diagram.layerZIndexTable[index + 1] = temp;\n            if (this.diagram.mode === 'Canvas') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * sendToBack method\\\n     *\n     * @returns { void }    sendToBack method .\\\n     * @param {NodeModel | ConnectorModel} object - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.sendToBack = function (object) {\n        this.diagram.protectPropertyChange(true);\n        if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram) || object) {\n            // EJ2-57772 - Added the below code to iterate all the selected nodes / connectors in the diagram and\n            // perform send to back operation\n            var selectedItems = this.diagram.selectedItems;\n            var objects = [];\n            if (object && object.id) {\n                objects.push(object);\n            }\n            else {\n                objects = objects.concat(selectedItems.nodes);\n                objects = objects.concat(selectedItems.connectors);\n            }\n            var objectId = (object && object.id);\n            var undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            objects = objects.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });\n            for (var i = objects.length - 1; i >= 0; i--) {\n                var clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(objects[parseInt(i.toString(), 10)]);\n                objectId = objects[parseInt(i.toString(), 10)].id;\n                var index = this.diagram.nameTable[\"\" + objectId].zIndex;\n                var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n                this.updateLayerZindexTable(layerNum);\n                var zIndexTable = this.diagram.layers[parseInt(layerNum.toString(), 10)].zIndexTable;\n                var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;\n                var minZindex = null;\n                var targetId = '';\n                for (var i_2 = 0; i_2 < layerObjects.length; i_2++) {\n                    var obj = this.diagram.nameTable[layerObjects[parseInt(i_2.toString(), 10)]];\n                    if (minZindex === null || obj.zIndex < minZindex) {\n                        minZindex = obj.zIndex;\n                        targetId = obj.id;\n                    }\n                }\n                var tempTable = JSON.parse(JSON.stringify(zIndexTable));\n                var tempIndex = 0;\n                //Checks whether the selected node is the only node in the node array.\n                //Checks whether it is not a group and the nodes behind it are not its children.\n                if (this.diagram.nodes.length !== 1 && (this.diagram.nameTable[\"\" + objectId].children === undefined ||\n                    this.checkObjectBehind(objectId, zIndexTable, index))) {\n                    var obj = this.diagram.nameTable[\"\" + objectId];\n                    if (obj.zIndex > minZindex && obj.shape.type !== 'SwimLane') {\n                        var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj);\n                        var childMaxZindex = null;\n                        var childCount = null;\n                        if (obj.children) {\n                            childMaxZindex = this.findMaxZIndex(obj);\n                            childCount = childMaxZindex - obj.zIndex;\n                            obj.zIndex = minZindex - 1 - childCount;\n                            this.updateGroupZindex(obj, 'SendToBack', minZindex);\n                        }\n                        else {\n                            obj.zIndex = minZindex - 1;\n                        }\n                        this.triggerOrderCommand(clonedNode, obj, obj);\n                    }\n                    else if (obj.shape.type === 'SwimLane') {\n                        tempIndex = this.swapZIndexObjects(index, zIndexTable, objectId, tempTable);\n                    }\n                    // for (let i: number = index; i > 0; i--) {\n                    //     if (zIndexTable[parseInt(i.toString(), 10)]) {\n                    //         //When there are empty records in the zindex table\n                    //         if (!zIndexTable[i - 1]) {\n                    //             zIndexTable[i - 1] = zIndexTable[parseInt(i.toString(), 10)];\n                    //             this.diagram.nameTable[zIndexTable[i - 1]].zIndex = i;\n                    //             delete zIndexTable[parseInt(i.toString(), 10)];\n                    //         } else {\n                    //             //bringing the objects forward\n                    //             let clonedNode = cloneObject( this.diagram.nameTable[zIndexTable[parseInt((i-1).toString(), 10)]]);\n                    //             zIndexTable[parseInt(i.toString(), 10)] = zIndexTable[i - 1];\n                    //             this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;\n                    //             this.triggerOrderCommand(clonedNode, this.diagram.nameTable[zIndexTable[parseInt((i-1).toString(), 10)]], this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]]);\n                    //         }\n                    //     }\n                    // }\n                    // for (let i: number = index; i > 0; i--) {\n                    //     if (zIndexTable[parseInt(i.toString(), 10)]) {\n                    //         this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;\n                    //     }\n                    // }\n                    // if (obj.shape.type !== 'SwimLane') {\n                    //     zIndexTable[0] = this.diagram.nameTable[`${objectId}`].id;\n                    //     this.diagram.nameTable[`${objectId}`].zIndex = 0;\n                    //     this.triggerOrderCommand(clonedObject, objects[parseInt(i.toString(), 10)], objects[parseInt(i.toString(), 10)]);\n                    // } else {\n                    //     tempIndex = this.swapZIndexObjects(index, zIndexTable, objectId, tempTable);\n                    // }\n                    if (this.diagram.mode === 'SVG') {\n                        var obj_1 = this.diagram.nameTable[\"\" + objectId];\n                        var i_3 = obj_1.shape.type !== 'SwimLane' ? minZindex : tempIndex;\n                        // if (i !== tempIndex) {\n                        //     i = (obj.children && obj.children.length > 0) ? index : 1;\n                        // }\n                        var target = zIndexTable[parseInt(i_3.toString(), 10)];\n                        // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.\n                        while (!target && i_3 < index) {\n                            target = zIndexTable[++i_3];\n                        }\n                        // EJ2-46656 - CR issue fix\n                        target = this.resetTargetNode(objectId, target, i_3, zIndexTable);\n                        //EJ2-69654 - Send to back command not working when there is single node in layer\n                        if (target) {\n                            target = this.diagram.nameTable[\"\" + target].parentId ? this.checkParentExist(target) : target;\n                            this.moveSvgNode(objectId, target);\n                        }\n                        this.updateNativeNodeIndex(objectId);\n                        this.updateLayerZindexTable(layerNum);\n                    }\n                    else {\n                        this.diagram.refreshCanvasLayers();\n                        this.updateLayerZindexTable(layerNum);\n                    }\n                }\n            }\n            var redoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            var entry = { type: 'SendToBack', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n            if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    CommandHandler.prototype.findMaxZIndex = function (parent) {\n        var _this = this;\n        var childMaxZindex = null;\n        // Recursive function to find the maximum zIndex among all children\n        var findMax = function (parent) {\n            for (var m = 0; m < parent.children.length; m++) {\n                var child = _this.diagram.nameTable[parent.children[parseInt(m.toString(), 10)]];\n                // Update the maximum zIndex found\n                if (childMaxZindex === null || child.zIndex > childMaxZindex) {\n                    childMaxZindex = child.zIndex;\n                }\n                // Recurse if the child has its own children\n                if (child.children) {\n                    findMax(child);\n                }\n            }\n        };\n        findMax(parent);\n        return childMaxZindex; // Return the maximum zIndex found\n    };\n    CommandHandler.prototype.updateGroupZindex = function (parent, command, index) {\n        var _this = this;\n        var newIndex;\n        if (newIndex === undefined) {\n            newIndex = parent.zIndex + 1; // Assign index if it is undefined\n        }\n        // Recursive function to update zIndex\n        var updateGroupindex = function (parent) {\n            for (var n = 0; n < parent.children.length; n++) {\n                var child = _this.diagram.nameTable[parent.children[parseInt(n.toString(), 10)]]; // Use the correct index without parsing to int\n                if (child.children) {\n                    child.zIndex = newIndex++; // Update zIndex for children with children (group)\n                    updateGroupindex(child); // Recursively update child group\n                }\n                else {\n                    child.zIndex = newIndex++; // Update zIndex for individual children\n                }\n            }\n        };\n        updateGroupindex(parent); // Start the update process from the parent\n    };\n    CommandHandler.prototype.updateLayerZindexTable = function (layerIndex) {\n        var layer = this.diagram.layers[parseInt(layerIndex.toString(), 10)];\n        layer.zIndexTable = {};\n        for (var i = 0; i < layer.objects.length; i++) {\n            var obj = this.diagram.nameTable[layer.objects[parseInt(i.toString(), 10)]];\n            layer.zIndexTable[obj.zIndex] = obj.id;\n        }\n    };\n    CommandHandler.prototype.swapZIndexObjects = function (index, zIndexTable, objectId, tempTable) {\n        var tempIndex = 0;\n        var childCount = 0;\n        var childIndex = -1;\n        var j = 1;\n        // Get the swimlane's Children count\n        for (var i = 0; i <= index; i++) {\n            if (zIndexTable[parseInt(i.toString(), 10)]\n                && this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].parentId === objectId) {\n                // Get the swimlane's first children position from z index table\n                if (childIndex === -1) {\n                    childIndex = i;\n                }\n                childCount++;\n            }\n        }\n        // Swap the swimlane children to the top of the z index table\n        for (var i = 0; i <= index; i++) {\n            if (zIndexTable[parseInt(i.toString(), 10)] && j <= childCount) {\n                while (!zIndexTable[parseInt(childIndex.toString(), 10)]) {\n                    childIndex++;\n                }\n                zIndexTable[parseInt(i.toString(), 10)] = zIndexTable[parseInt(childIndex.toString(), 10)];\n                this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;\n                childIndex++;\n                j++;\n            }\n        }\n        var k = 0;\n        // Get the Z index from ZindexTable in the child's count position. In that position we want to put the swimlane\n        for (var i = 0; i < childCount; i++) {\n            while (!zIndexTable[parseInt(k.toString(), 10)]) {\n                k++;\n            }\n            tempIndex = this.diagram.nameTable[zIndexTable[parseInt(k.toString(), 10)]].zIndex;\n            k++;\n        }\n        tempIndex = tempIndex + 1;\n        // Check if there is a object in the z index table or not\n        while (!zIndexTable[parseInt(tempIndex.toString(), 10)]) {\n            ++tempIndex;\n        }\n        k = 0;\n        // Place the swimlane at the next position of the swimlane's last children.\n        zIndexTable[parseInt(tempIndex.toString(), 10)] = this.diagram.nameTable[\"\" + objectId].id;\n        this.diagram.nameTable[\"\" + objectId].zIndex = tempIndex;\n        tempIndex = tempIndex + 1;\n        // Now swap the intersect nodes at next position of the swimlane.\n        for (var i = tempIndex; i <= index; i++) {\n            if (zIndexTable[parseInt(i.toString(), 10)]) {\n                while (!tempTable[parseInt(k.toString(), 10)]) {\n                    k++;\n                }\n                zIndexTable[parseInt(i.toString(), 10)] = tempTable[parseInt(k.toString(), 10)];\n                this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;\n                k++;\n            }\n        }\n        return tempIndex;\n    };\n    CommandHandler.prototype.resetTargetNode = function (objectId, target, i, zIndexTable) {\n        if (this.diagram.nameTable[\"\" + objectId].shape.type === 'SwimLane'\n            && this.diagram.nameTable[\"\" + target].parentId !== undefined && this.diagram.nameTable[\"\" + target].parentId !== '' && this.diagram.nameTable[this.diagram.nameTable[\"\" + target].parentId].isLane) {\n            i = i + 1;\n            if (zIndexTable[parseInt(i.toString(), 10)]) {\n                target = zIndexTable[parseInt(i.toString(), 10)];\n                return target = this.resetTargetNode(objectId, target, i, zIndexTable);\n            }\n            else {\n                return target;\n            }\n        }\n        else {\n            return target;\n        }\n    };\n    // private getZIndexObjects(): void {\n    //     // const element: (NodeModel | ConnectorModel)[] = [];\n    //     // let i: number; let j: number;\n    //     // for (i = 0; i < this.diagram.nodes.length; i++) {\n    //     //     element.push(this.diagram.nodes[parseInt(i.toString(), 10)]);\n    //     // }\n    //     // for (j = 0; j < this.diagram.connectors.length; j++) {\n    //     //     element.push(this.diagram.connectors[parseInt(j.toString(), 10)]);\n    //     // }\n    //     // this.updateBlazorZIndex(element);\n    // }\n    // private updateBlazorZIndex(element: (NodeModel | ConnectorModel)[]): void {\n    //     // const blazorInterop: string = 'sfBlazor';\n    //     // const blazor: string = 'Blazor';\n    //     // let diagramobject: object = {};\n    //     // const nodeObject: NodeModel[] = [];\n    //     // const connectorObject: ConnectorModel[] = [];\n    //     // let k: number;\n    //     // if (element && element.length > 0) {\n    //     //     for (k = 0; k < element.length; k++) {\n    //     //         const elementObject: (NodeModel | ConnectorModel) = element[parseInt(k.toString(), 10)];\n    //     //         if (elementObject instanceof Node) {\n    //     //             nodeObject.push(this.getBlazorObject(elementObject));\n    //     //         } else if (elementObject instanceof Connector) {\n    //     //             connectorObject.push(this.getBlazorObject(elementObject));\n    //     //         }\n    //     //     }\n    //     // }\n    //     // diagramobject = {\n    //     //     nodes: nodeObject,\n    //     //     connectors: connectorObject\n    //     // };\n    //     // if (window && window[`${blazor}`]) {\n    //     //     const obj: object = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': diagramobject };\n    //     //     window[`${blazorInterop}`].updateBlazorProperties(obj, this.diagram);\n    //     // }\n    // }\n    // private getBlazorObject(objectName: (NodeModel | ConnectorModel)): any {\n    //     // const object: object = {\n    //     //     sfIndex: getIndex(this.diagram, objectName.id),\n    //     //     zIndex: objectName.zIndex\n    //     // };\n    //     // return object;\n    // }\n    //Checks whether the target is a child node.\n    CommandHandler.prototype.checkParentExist = function (target) {\n        var objBehind = target;\n        while (this.diagram.nameTable[\"\" + objBehind].parentId) {\n            objBehind = this.diagram.nameTable[\"\" + objBehind].parentId;\n        }\n        return objBehind;\n    };\n    //Checks whether the selected node is not a parent of another node.\n    CommandHandler.prototype.checkObjectBehind = function (objectId, zIndexTable, index) {\n        // for (let i: number = 0; i < index; i++) {\n        //     const z: string = zIndexTable[parseInt(i.toString(), 10)];\n        //     if (this.diagram.nameTable[`${z}`] && objectId !== this.diagram.nameTable[`${z}`].parentId) {\n        //         return true;\n        //     }\n        // }\n        return true;\n    };\n    /**\n     * bringToFront method\\\n     *\n     * @returns {  void  }    bringToFront method .\\\n     *  @param {NodeModel | ConnectorModel } obj - Provide the nodeArray element .\n     * @private\n     */\n    CommandHandler.prototype.bringToFront = function (obj) {\n        this.diagram.protectPropertyChange(true);\n        if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram) || obj) {\n            // EJ2-57772 - Added the below code to iterate all the selected nodes / connectors in the diagram and\n            // perform bring to front operation\n            var objectName = (obj && obj.id);\n            var selectedItems = this.diagram.selectedItems;\n            var objects = [];\n            if (obj && obj.id) {\n                objects.push(obj);\n            }\n            else {\n                objects = objects.concat(selectedItems.nodes);\n                objects = objects.concat(selectedItems.connectors);\n            }\n            var undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            objects = objects.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });\n            for (var i = 0; i < objects.length; i++) {\n                var clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(objects[parseInt(i.toString(), 10)]);\n                objectName = objects[parseInt(i.toString(), 10)].id;\n                var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectName));\n                this.updateLayerZindexTable(layerNum);\n                var zIndexTable = this.diagram.layers[parseInt(layerNum.toString(), 10)].zIndexTable;\n                var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;\n                var maxZindex = null;\n                for (var i_4 = 0; i_4 < layerObjects.length; i_4++) {\n                    var obj_2 = this.diagram.nameTable[layerObjects[parseInt(i_4.toString(), 10)]];\n                    if (maxZindex === null || obj_2.zIndex > maxZindex) {\n                        maxZindex = obj_2.zIndex;\n                    }\n                }\n                var tempTable = JSON.parse(JSON.stringify(zIndexTable));\n                var tempIndex = 0;\n                //find the maximum zIndex of the tabel\n                var tabelLength = Number(Object.keys(zIndexTable).sort(function (a, b) { return Number(a) - Number(b); }).reverse()[0]);\n                var index = this.diagram.nameTable[\"\" + objectName].zIndex;\n                var oldzIndexTable = [];\n                var length_1 = 0;\n                for (var i_5 = 0; i_5 <= tabelLength; i_5++) {\n                    oldzIndexTable.push(zIndexTable[parseInt(i_5.toString(), 10)]);\n                }\n                var object = this.diagram.nameTable[\"\" + objectName];\n                if (object.shape.type === 'SwimLane') {\n                    for (var i_6 = tabelLength; i_6 >= index; i_6--) {\n                        if (zIndexTable[parseInt(i_6.toString(), 10)]\n                            && !(this.diagram.nameTable[zIndexTable[parseInt(i_6.toString(), 10)]].parentId === objectName)) {\n                            length_1 = i_6;\n                            tabelLength = length_1;\n                            break;\n                        }\n                    }\n                }\n                var obj_3 = this.diagram.nameTable[\"\" + objectName];\n                if (obj_3.zIndex < maxZindex && obj_3.shape.type !== 'SwimLane') {\n                    var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj_3);\n                    var childMaxZindex = null;\n                    if (obj_3.children) {\n                        childMaxZindex = this.findMaxZIndex(obj_3);\n                        if (childMaxZindex < maxZindex) {\n                            obj_3.zIndex = maxZindex + 1;\n                            this.updateGroupZindex(obj_3, 'BringToFront', maxZindex);\n                        }\n                    }\n                    else {\n                        obj_3.zIndex = maxZindex + 1;\n                    }\n                    this.triggerOrderCommand(clonedNode, obj_3, obj_3);\n                }\n                // for (let i: number = index; i < tabelLength; i++) {\n                //     //When there are empty records in the zindex table\n                //     if (zIndexTable[parseInt(i.toString(), 10)]) {\n                //         if (!zIndexTable[i + 1]) {\n                //             zIndexTable[i + 1] = zIndexTable[parseInt(i.toString(), 10)];\n                //             this.diagram.nameTable[zIndexTable[i + 1]].zIndex = i;\n                //             delete zIndexTable[parseInt(i.toString(), 10)];\n                //         } else {\n                //             //bringing the objects backward\n                //             let clonedNode = cloneObject(this.diagram.nameTable[zIndexTable[parseInt((i+1).toString(), 10)]]);\n                //             zIndexTable[parseInt(i.toString(), 10)] = zIndexTable[i + 1];\n                //             this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;\n                //             this.triggerOrderCommand(clonedNode, this.diagram.nameTable[zIndexTable[parseInt((i+1).toString(), 10)]], this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]]);\n                //         }\n                //     }\n                // }\n                // for (let i: number = index; i < tabelLength; i++) {\n                //     if (zIndexTable[parseInt(i.toString(), 10)]) {\n                //         this.diagram.nameTable[zIndexTable[parseInt(i.toString(), 10)]].zIndex = i;\n                //     }\n                // }\n                // if (object.shape.type !== 'SwimLane') {\n                //     zIndexTable[parseInt(tabelLength.toString(), 10)] = this.diagram.nameTable[`${objectName}`].id;\n                //     this.diagram.nameTable[`${objectName}`].zIndex = tabelLength;\n                //     this.triggerOrderCommand(clonedObject, objects[parseInt(i.toString(), 10)], objects[parseInt(i.toString(), 10)]);\n                // }\n                else if (obj_3.shape.type === 'SwimLane') {\n                    var childCount = 0;\n                    var childIndex = -1;\n                    var tempIndex_1 = 0;\n                    var laneIndex = 0;\n                    var cloneTable = JSON.parse(JSON.stringify(zIndexTable));\n                    for (var i_7 = 0; i_7 <= index; i_7++) {\n                        if (zIndexTable[parseInt(i_7.toString(), 10)]\n                            && this.diagram.nameTable[zIndexTable[parseInt(i_7.toString(), 10)]].parentId === objectName) {\n                            if (childIndex === -1) {\n                                childIndex = i_7;\n                                tempIndex_1 = i_7;\n                                break;\n                            }\n                        }\n                    }\n                    for (var i_8 = 0; i_8 <= tabelLength; i_8++) {\n                        if (tempTable[parseInt(i_8.toString(), 10)] && tempTable[parseInt(i_8.toString(), 10)] !== objectName\n                            && this.diagram.nameTable[tempTable[parseInt(i_8.toString(), 10)]].parentId !== objectName) {\n                            var node = this.diagram.nameTable[tempTable[parseInt(i_8.toString(), 10)]];\n                            var swimlaneObject = this.diagram.nameTable[\"\" + objectName];\n                            if (node.zIndex >= swimlaneObject.zIndex) {\n                                childCount++;\n                            }\n                        }\n                    }\n                    var k = childIndex;\n                    for (var i_9 = 0; i_9 <= childCount; i_9++) {\n                        while (!zIndexTable[parseInt(k.toString(), 10)]) {\n                            k++;\n                        }\n                        laneIndex = this.diagram.nameTable[zIndexTable[parseInt(k.toString(), 10)]].zIndex;\n                        k++;\n                    }\n                    for (var i_10 = laneIndex; i_10 <= tabelLength; i_10++) {\n                        while (!cloneTable[parseInt(childIndex.toString(), 10)]) {\n                            childIndex++;\n                        }\n                        while (!zIndexTable[parseInt(i_10.toString(), 10)]) {\n                            i_10++;\n                        }\n                        zIndexTable[parseInt(i_10.toString(), 10)] = cloneTable[parseInt(childIndex.toString(), 10)];\n                        this.diagram.nameTable[zIndexTable[parseInt(i_10.toString(), 10)]].zIndex = i_10;\n                        childIndex++;\n                    }\n                    zIndexTable[parseInt(tabelLength.toString(), 10)] = this.diagram.nameTable[\"\" + objectName].id;\n                    this.diagram.nameTable[\"\" + objectName].zIndex = tabelLength;\n                    k = index + 1;\n                    var j = tempIndex_1;\n                    for (var i_11 = 0; i_11 < childCount; i_11++) {\n                        while (!tempTable[parseInt(k.toString(), 10)]) {\n                            k++;\n                        }\n                        while (this.diagram.nameTable[tempTable[parseInt(k.toString(), 10)]].parentId === objectName) {\n                            k++;\n                        }\n                        while (!zIndexTable[parseInt(j.toString(), 10)]) {\n                            j++;\n                        }\n                        zIndexTable[parseInt(j.toString(), 10)] = tempTable[parseInt(k.toString(), 10)];\n                        this.diagram.nameTable[zIndexTable[parseInt(j.toString(), 10)]].zIndex = j;\n                        k++;\n                        j++;\n                    }\n                }\n                if (this.diagram.mode === 'SVG') {\n                    // const diagramLayer: SVGGElement = this.diagram.diagramLayer as SVGGElement;\n                    // //const child: string[] = this.getChildElements(this.diagram.nameTable[objectName].wrapper.children);\n                    // //const targerNodes: Object = [];\n                    // let element: HTMLElement = getDiagramElement(objectName + '_groupElement', this.diagram.element.id);\n                    // const nodes: NodeModel[] = this.diagram.selectedItems.nodes;\n                    // if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {\n                    //     element.parentNode.removeChild(element);\n                    //     for (let j: number = 0; j < this.diagram.views.length; j++) {\n                    //         element = getDiagramElement(\n                    //             objectName + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'),\n                    //             this.diagram.views[parseInt(j.toString(), 10)]);\n                    //         const lastChildNode: HTMLElement = element.parentNode.lastChild as HTMLElement;\n                    //         lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);\n                    //     }\n                    //     const htmlLayer: HTMLElement = getHTMLLayer(this.diagram.element.id);\n                    //     this.diagram.diagramRenderer.renderElement(this.diagram.nameTable[`${objectName}`].wrapper, diagramLayer, htmlLayer);\n                    // } else {\n                    //     Object.keys(zIndexTable).forEach((key: string) => {\n                    //         const zIndexValue: string = zIndexTable[`${key}`];\n                    //         if ((zIndexValue !== objectName) && (this.diagram.nameTable[`${zIndexValue}`].parentId) !== objectName) {\n                    //             //EJ2-42101 - SendToBack and BringToFront not working for connector with group node\n                    //             //Added @Dheepshiva to restrict the objects with lower zIndex\n                    //             if (zIndexValue !== undefined &&\n                    //                 (oldzIndexTable.indexOf(objectName) < oldzIndexTable.indexOf(zIndexValue))) {\n                    //                 const objectNode: Node | Connector = this.diagram.nameTable[`${objectName}`];\n                    //                 const zIndexNode: Node | Connector = this.diagram.nameTable[`${zIndexValue}`];\n                    //                 if (objectNode.parentId === '' && zIndexNode.parentId === '' && zIndexNode.parentId === undefined\n                    //                     && objectNode.parentId !== zIndexNode.id) {\n                    //                     this.moveSvgNode(zIndexValue, objectName);\n                    //                     this.updateNativeNodeIndex(objectName);\n                    //                 } else {\n                    //                     if (this.checkGroupNode(objectName, zIndexValue, this.diagram.nameTable)) {\n                    //                         this.moveSvgNode(zIndexValue, objectName);\n                    //                         this.updateNativeNodeIndex(objectName);\n                    //                     }\n                    //                 }\n                    //             }\n                    //         }\n                    //     });\n                    //     this.updateLayerZindexTable(layerNum);\n                    // }\n                    var obj_4 = this.diagram.nameTable[\"\" + objectName];\n                    var i_12 = obj_4.shape.type !== 'SwimLane' ? maxZindex : tempIndex;\n                    // if (i !== tempIndex) {\n                    //     i = (obj.children && obj.children.length > 0) ? index : 1;\n                    // }\n                    var target = zIndexTable[parseInt(i_12.toString(), 10)];\n                    // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.\n                    // while (!target && i > index) {\n                    //     target = zIndexTable[++i];\n                    // }\n                    // EJ2-46656 - CR issue fix\n                    target = this.resetTargetNode(objectName, target, i_12, zIndexTable);\n                    //EJ2-69654 - Send to back command not working when there is single node in layer\n                    if (target) {\n                        target = this.diagram.nameTable[\"\" + target].parentId ? this.checkParentExist(target) : target;\n                        this.moveAfterSvgNode(objectName, target);\n                    }\n                    var diagramLayer = this.diagram.diagramLayer;\n                    var element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(objectName + '_groupElement', this.diagram.element.id);\n                    var nodes = this.diagram.selectedItems.nodes;\n                    if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {\n                        element.parentNode.removeChild(element);\n                        for (var j = 0; j < this.diagram.views.length; j++) {\n                            element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(objectName + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'), this.diagram.views[parseInt(j.toString(), 10)]);\n                            var lastChildNode = element.parentNode.lastChild;\n                            lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);\n                        }\n                        var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getHTMLLayer)(this.diagram.element.id);\n                        this.diagram.diagramRenderer.renderElement(this.diagram.nameTable[\"\" + objectName].wrapper, diagramLayer, htmlLayer);\n                    }\n                    this.updateLayerZindexTable(layerNum);\n                }\n                else {\n                    this.diagram.refreshCanvasLayers();\n                    this.updateLayerZindexTable(layerNum);\n                }\n            }\n            var redoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            var entry = { type: 'BringToFront', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n            if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    // private findGreatestZIndex (parent: Node, layerObjects: string[]): number {\n    //     const layerObj: NodeModel[] = this.diagram.nodes.filter((node: any) => layerObjects.indexOf(node.id) !== -1);\n    //     // Get zIndex values of nodes excluding children of the parent\n    //     const zIndexes: number[] = layerObj.filter((node: any) => node.parentId === '' && node.id !== parent.id).map((node: NodeModel) => (node as Node).zIndex);\n    //     // Sort zIndexes in descending order\n    //     zIndexes.sort((a: number, b: number) => b - a);\n    //     // Find the greatest zIndex excluding children\n    //     if (zIndexes.length > 0){\n    //         return zIndexes[0];\n    //     }\n    //     return null;\n    // }\n    // private findLowestZIndex (parent: Node, layerObjects: string[]): number {\n    //     const layerObj: NodeModel[] = this.diagram.nodes.filter((node: any) => layerObjects.indexOf(node.id) !== -1);\n    //     // Get zIndex values of nodes excluding children of the parent\n    //     const zIndexes: number[] = layerObj.filter((node: any) => node.parentId === '' && node.id !== parent.id).map((node: NodeModel) => (node as Node).zIndex);\n    //     // Sort zIndexes in ascending order\n    //     zIndexes.sort((a: number, b: number) => a - b);\n    //     // Find the lowest zIndex excluding children\n    //     if (zIndexes.length > 0){\n    //         return zIndexes[0];\n    //     }\n    //     return null;\n    // }\n    CommandHandler.prototype.triggerOrderCommand = function (oldObj, newObj, obj) {\n        var clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(oldObj);\n        // EJ2-61653 - Added below code to get only changed values (zIndex) and passed as an argument to property change event\n        var oldValue = {\n            zIndex: clonedObject.zIndex\n        };\n        var newValue = {\n            zIndex: newObj.zIndex\n        };\n        var arg = {\n            element: obj, cause: this.diagram.diagramActions, diagramAction: this.diagram.getDiagramAction(this.diagram.diagramActions),\n            oldValue: oldValue, newValue: newValue\n        };\n        this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.propertyChange, arg);\n    };\n    CommandHandler.prototype.checkGroupNode = function (selectedNodeName, layerObject, nameTable) {\n        return nameTable[\"\" + layerObject].parentId === nameTable[\"\" + selectedNodeName].parentId;\n    };\n    /**\n     * sortByZIndex method\\\n     *\n     * @returns {  Object[] }    sortByZIndex method .\\\n     *  @param { Object[] } nodeArray - Provide the nodeArray element .\n     *  @param { string } sortID - Provide the sortID element .\n     * @private\n     */\n    CommandHandler.prototype.sortByZIndex = function (nodeArray, sortID, command) {\n        if (command === 'BringForward') {\n            var id_1 = sortID ? sortID : 'zIndex';\n            nodeArray = nodeArray.sort(function (a, b) {\n                return b[\"\" + id_1] - a[\"\" + id_1];\n            });\n        }\n        else {\n            var id_2 = sortID ? sortID : 'zIndex';\n            nodeArray = nodeArray.sort(function (a, b) {\n                return a[\"\" + id_2] - b[\"\" + id_2];\n            });\n        }\n        return nodeArray;\n    };\n    /**\n     * orderCommands method\\\n     *\n     * @returns {  void }    orderCommands method .\\\n     *  @param { boolean } isRedo - Provide the previousObject element .\n     *  @param { Selector } selector - Provide the previousObject element .\n     *  @param { EntryType } action - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.orderCommands = function (isRedo, selector, action) {\n        var _this = this;\n        var selectedObject = selector.nodes;\n        selectedObject = selectedObject.concat(selector.connectors);\n        if (isRedo) {\n            var selectedItems = selector.selectedObjects;\n            // sort the selected items by zIndex\n            selectedItems = selectedItems.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });\n            if (action === 'SendBackward') {\n                for (var i = 0; i < selectedItems.length; i++) {\n                    this.sendBackward(selectedItems[parseInt(i.toString(), 10)]);\n                }\n            }\n            else if (action === 'SendForward') {\n                for (var i = selectedItems.length - 1; i >= 0; i--) {\n                    this.sendForward(selectedItems[parseInt(i.toString(), 10)]);\n                }\n            }\n            else if (action === 'BringToFront') {\n                for (var i = 0; i < selectedItems.length; i++) {\n                    this.bringToFront(selectedItems[parseInt(i.toString(), 10)]);\n                }\n            }\n            else if (action === 'SendToBack') {\n                for (var i = selectedItems.length - 1; i >= 0; i--) {\n                    this.sendToBack(selectedItems[parseInt(i.toString(), 10)]);\n                }\n            }\n        }\n        else {\n            // Get the first selected object's layer and zIndex information\n            var firstObject = selectedObject[0];\n            var layer = this.getObjectLayer(firstObject.id);\n            var layerIndex = layer.zIndex;\n            var zIndexTable = layer.zIndexTable;\n            var objectId = void 0;\n            // Handle actions for sendBackward or sendToBack\n            if (action === 'SendBackward' || action === 'SendToBack') {\n                // Sort objects by their zIndex\n                selectedObject = selectedObject.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });\n                for (var i = 0; i < selectedObject.length; i++) {\n                    var undoObject = selectedObject[parseInt(i.toString(), 10)];\n                    var node = this.diagram.nameTable[selectedObject[parseInt(i.toString(), 10)].id];\n                    node.zIndex = undoObject.zIndex; // Update each object's zIndex in selectedObject\n                    this.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable[undoObject.zIndex] = undoObject.id;\n                    objectId = undoObject.id;\n                    if (action === 'SendToBack') {\n                        if (selectedObject[0].shape.type === 'SwimLane') {\n                            this.bringToFront(selectedObject[0]);\n                        }\n                        if (node.children) {\n                            this.updateGroupZindex(node, '', null);\n                        }\n                        this.updateLayerZindexTable(layer.zIndex);\n                    }\n                    if (this.diagram.mode === 'SVG') {\n                        // Get the selected object's layer and zIndex information\n                        var object = this.diagram.nameTable[\"\" + objectId];\n                        var objectIndex = object.zIndex;\n                        var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n                        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;\n                        var previousZindex = null;\n                        var _loop_2 = function (m) {\n                            var obj_5 = this_2.diagram.nameTable[layerObjects[parseInt(m.toString(), 10)]];\n                            // Check if the current object is not a child of the selected object.\n                            var isChildOfSelectedObject = true;\n                            selector.selectedObjects.forEach(function (seletedObject) {\n                                isChildOfSelectedObject = _this.notChildOfSelectedNode(obj_5, seletedObject);\n                            });\n                            // Find the previous zIndex\n                            if (isChildOfSelectedObject && obj_5.zIndex < objectIndex &&\n                                (previousZindex === null || obj_5.zIndex > previousZindex)) {\n                                previousZindex = obj_5.zIndex;\n                            }\n                        };\n                        var this_2 = this;\n                        for (var m = 0; m < layerObjects.length; m++) {\n                            _loop_2(m);\n                        }\n                        var tempIndex = 0;\n                        var obj = this.diagram.nameTable[\"\" + objectId];\n                        // Determine the target index for the movement\n                        var targetIndex = obj.shape.type !== 'SwimLane' ? previousZindex : tempIndex;\n                        var target = void 0;\n                        // Find the target using target index\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isNullOrUndefined)(targetIndex)) {\n                            target = zIndexTable[parseInt(targetIndex.toString(), 10)];\n                        }\n                        if (target) {\n                            target = this.diagram.nameTable[\"\" + target].parentId ? this.checkParentExist(target) : target;\n                            if (action === 'SendBackward') {\n                                // eslint-disable-next-line max-len\n                                if ((object.parentId && this.notChildOfSelectedNode(object, this.diagram.nameTable[\"\" + target])) || object.parentId === '') {\n                                    this.moveAfterSvgNode(objectId, target);\n                                }\n                            }\n                            else if (action === 'SendToBack') {\n                                if (selectedObject[0].shape.type !== 'SwimLane') {\n                                    this.moveAfterSvgNode(objectId, target);\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        this.diagram.refreshCanvasLayers();\n                    }\n                }\n            }\n            // Handle actions for SendForward or BringToFront\n            else if (action === 'SendForward' || action === 'BringToFront') {\n                // Sort objects by their zIndex\n                selectedObject = selectedObject.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });\n                for (var i = 0; i < selectedObject.length; i++) {\n                    var undoObject = selectedObject[parseInt(i.toString(), 10)];\n                    var node = this.diagram.nameTable[selectedObject[parseInt(i.toString(), 10)].id];\n                    node.zIndex = undoObject.zIndex;\n                    this.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable[undoObject.zIndex] = undoObject.id;\n                    objectId = undoObject.id;\n                    if (action === 'BringToFront') {\n                        if (selectedObject[0].shape.type === 'SwimLane') {\n                            this.sendToBack(selectedObject[0]);\n                        }\n                        if (node.children) {\n                            this.updateGroupZindex(node, '', null);\n                        }\n                        this.updateLayerZindexTable(layer.zIndex);\n                    }\n                    if (this.diagram.mode === 'SVG') {\n                        // Get the selected object's layer and zIndex information\n                        var object = this.diagram.nameTable[\"\" + objectId];\n                        var objectIndex = object.zIndex;\n                        var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n                        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;\n                        var nextZindex = null;\n                        var _loop_3 = function (n) {\n                            var obj_6 = this_3.diagram.nameTable[layerObjects[parseInt(n.toString(), 10)]];\n                            // Check if the current object is not a child of the selected object.\n                            var isChildOfSelectedObject = true;\n                            selector.selectedObjects.forEach(function (seletedObject) {\n                                isChildOfSelectedObject = _this.notChildOfSelectedNode(obj_6, seletedObject);\n                            });\n                            var isSelectedObject = selector.selectedObjects.some(function (object) {\n                                return object.id === obj_6.id;\n                            });\n                            // Find the next zIndex\n                            if (!isSelectedObject && isChildOfSelectedObject && obj_6.zIndex > objectIndex &&\n                                (nextZindex === null || obj_6.zIndex < nextZindex)) {\n                                nextZindex = obj_6.zIndex;\n                            }\n                        };\n                        var this_3 = this;\n                        for (var n = layerObjects.length - 1; n >= 0; n--) {\n                            _loop_3(n);\n                        }\n                        var tempIndex = 0;\n                        var obj = this.diagram.nameTable[\"\" + objectId];\n                        // Determine the target index for the movement\n                        var targetIndex = obj.shape.type !== 'SwimLane' ? nextZindex : tempIndex;\n                        var target = void 0;\n                        // Find the target using target index\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isNullOrUndefined)(targetIndex)) {\n                            target = zIndexTable[parseInt(targetIndex.toString(), 10)];\n                        }\n                        if (target) {\n                            target = this.diagram.nameTable[\"\" + target].parentId ? this.checkParentExist(target) : target;\n                            if (action === 'SendForward') {\n                                if (object.parentId === '') {\n                                    this.moveSvgNode(objectId, target);\n                                }\n                            }\n                            else if (action === 'BringToFront') {\n                                if (selectedObject[0].shape.type !== 'SwimLane') {\n                                    this.moveSvgNode(objectId, target);\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        this.diagram.refreshCanvasLayers();\n                    }\n                }\n            }\n        }\n    };\n    // private moveSBObject: (targetId: string) => void = function (targetId: string): void {\n    //     if (targetId) {\n    //         this.moveBackUndoNode(targetId);\n    //     }\n    // };\n    // //The below method is for undo process for sendBackward command\n    // private moveBackUndoNode: (targetId: string) => void = function (targetId: string): void {\n    //     const originalZIndexTable: object = {};  // New variable to store original zIndex values\n    //     // Store original zIndex values\n    //     for (let i: number = 0; i < this.diagram.nodes.length; i++) {\n    //         const node1: NodeModel = this.diagram.nodes[parseInt(i.toString(), 10)];\n    //         originalZIndexTable[node1.id] = node1.zIndex;\n    //     }\n    //     for (let j: number = 0; j < this.diagram.connectors.length; j++) {\n    //         const connector: ConnectorModel = this.diagram.connectors[parseInt(j.toString(), 10)];\n    //         originalZIndexTable[connector.id] = connector.zIndex;\n    //     }\n    //     const sortedNodeIds: string[] = Object.keys(originalZIndexTable).sort((a: string, b: string) => originalZIndexTable[`${a}`] - originalZIndexTable[`${b}`]);\n    //     const currentIndex: number = sortedNodeIds.indexOf(targetId);\n    //     //This method moves the node/connector based on their zindex\n    //     if (currentIndex !== -1) {\n    //         if (currentIndex === sortedNodeIds.length - 1) {\n    //             const nextNodeId: string = sortedNodeIds[currentIndex - 1];\n    //             this.swapDomOrder(nextNodeId, targetId);\n    //         }\n    //         else {\n    //             const nextNodeId: string = sortedNodeIds[currentIndex + 1];\n    //             let backNode: HTMLElement;\n    //             if (nextNodeId) {\n    //                 const node: NodeModel = this.diagram.getObject(targetId);\n    //                 if (node.shape.type === 'Native' || node.shape.type === 'HTML') {\n    //                     this.updateNativeNodeIndex(targetId, nextNodeId);\n    //                 } else {\n    //                     const diagramDiv: HTMLElement = getDiagramElement(targetId + '_groupElement', this.diagram.element.id);\n    //                     backNode = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);\n    //                     const target: Node = this.diagram.getObject(targetId);\n    //                     const newnode: Node = this.diagram.getObject(nextNodeId);\n    //                     if (newnode.parentId && newnode.parentId !== target.parentId) {\n    //                         backNode = getDiagramElement(newnode.parentId + '_groupElement', this.diagram.element.id);\n    //                     }\n    //                     if (target.parentId !== newnode.id) {\n    //                         diagramDiv.parentNode.insertBefore(diagramDiv, backNode);\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     }\n    // };\n    // private moveFBObject: (targetId: string) => void = function (targetId: string): void {\n    //     if (targetId) {\n    //         this.moveForwardUndoNode(targetId);\n    //     }\n    // };\n    // //The below method is for undo process for moveForward command\n    // private moveForwardUndoNode: (targetID: string) => void = function (targetID: string): void {\n    //     const originalZIndexTable: object = {};  // New variable to store original zIndex values\n    //     // Store original zIndex values\n    //     for (let i: number = 0; i < this.diagram.nodes.length; i++) {\n    //         const node1: NodeModel = this.diagram.nodes[parseInt(i.toString(), 10)];\n    //         originalZIndexTable[node1.id] = node1.zIndex;\n    //     }\n    //     for (let j: number = 0; j < this.diagram.connectors.length; j++) {\n    //         const connector: ConnectorModel = this.diagram.connectors[parseInt(j.toString(), 10)];\n    //         originalZIndexTable[connector.id] = connector.zIndex;\n    //     }\n    //     const sortedNodeIds: string[] = Object.keys(originalZIndexTable).sort((a: string, b: string) => originalZIndexTable[`${a}`] - originalZIndexTable[`${b}`]);\n    //     const currentIndex: number = sortedNodeIds.indexOf(targetID);\n    //     //This method moves the node/connector based on their zindex\n    //     if (currentIndex !== -1) {\n    //         if (currentIndex === sortedNodeIds.length - 1) {\n    //             const nextNodeId: string = sortedNodeIds[currentIndex - 1];\n    //             this.swapDomOrder(nextNodeId, targetID);\n    //         }\n    //         else {\n    //             const nextNodeId: string = sortedNodeIds[currentIndex + 1];\n    //             if (nextNodeId) {\n    //                 const node: NodeModel = this.diagram.getObject(targetID);\n    //                 if (node.shape.type === 'Native' || node.shape.type === 'HTML') {\n    //                     this.updateNativeNodeIndex(targetID, nextNodeId);\n    //                 } else {\n    //                     const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n    //                     const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);\n    //                     diagramDiv.parentNode.insertBefore(diagramDiv, backNode);\n    //                 }\n    //             }\n    //         }\n    //     }\n    // };\n    // private swapDomOrder(nextNodeId: string, targetId: string): void {\n    //     if (nextNodeId) {\n    //         //Bug 921994: Z-index order changes are not reflected at the UI level with Undo Redo commands.\n    //         const node: NodeModel = this.diagram.getObject(targetId);\n    //         if (node.shape.type === 'Native' || node.shape.type === 'HTML') {\n    //             this.updateNativeNodeIndex(targetId, nextNodeId);\n    //             this.updateNativeNodeIndex(nextNodeId, targetId);\n    //         } else {\n    //             const diagramDiv: HTMLElement = getDiagramElement(targetId + '_groupElement', this.diagram.element.id);\n    //             const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);\n    //             diagramDiv.parentNode.insertBefore(diagramDiv, backNode);\n    //             diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n    //         }\n    //     }\n    // }\n    // private moveObject(sourceId: string, targetId: string): void {\n    //     if (targetId) {\n    //         this.moveSvgNode(sourceId, targetId);\n    //         this.updateNativeNodeIndex(sourceId, targetId);\n    //     }\n    // }\n    /**\n     * sendForward method\\\n     *\n     * @returns {  void }    sendForward method .\\\n     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.sendForward = function (obj) {\n        var _this = this;\n        this.diagram.protectPropertyChange(true);\n        if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram) || obj) {\n            var selectedItems = this.diagram.selectedItems;\n            var objects = [];\n            if (obj && obj.id) {\n                objects.push(obj);\n            }\n            else {\n                objects = objects.concat(selectedItems.nodes);\n                objects = objects.concat(selectedItems.connectors);\n            }\n            this.sortByZIndex(objects);\n            var nodeId = (obj && obj.id);\n            var undoObject_1 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            this.diagram.startGroupAction();\n            var changeNodeZIndexesArray_1 = [];\n            var _loop_4 = function (s) {\n                var clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(objects[parseInt(s.toString(), 10)]);\n                nodeId = objects[parseInt(s.toString(), 10)].id;\n                var layerIndex = this_4.diagram.layers.indexOf(this_4.getObjectLayer(nodeId));\n                var originalNameTable = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this_4.diagram.nameTable);\n                var zIndexTable = this_4.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable;\n                //const tabelLength: number = Object.keys(zIndexTable).length;\n                var index = this_4.diagram.nameTable[\"\" + nodeId];\n                var intersectArray = [];\n                var temp = this_4.diagram.spatialSearch.findObjects(index.wrapper.bounds);\n                if (temp.length > 2) {\n                    temp = this_4.sortByZIndex(temp, undefined, 'BringForward');\n                }\n                var _loop_5 = function (i) {\n                    if (index.id !== i.id) {\n                        var currentLayer = this_4.getObjectLayer(i.id).zIndex;\n                        var isSelectedObject = this_4.diagram.selectedItems.selectedObjects.some(function (object) {\n                            return object.id === i.id;\n                        });\n                        if ((this_4.diagram.selectedItems.selectedObjects.length === 1 || !isSelectedObject) && layerIndex === currentLayer &&\n                            (Number(this_4.diagram.nameTable[\"\" + nodeId].zIndex) < Number(i.zIndex)) &&\n                            i.parentId === '' && index.wrapper.bounds.intersects(i.wrapper.bounds)) {\n                            intersectArray.push(i);\n                        }\n                    }\n                };\n                for (var _i = 0, temp_1 = temp; _i < temp_1.length; _i++) {\n                    var i = temp_1[_i];\n                    _loop_5(i);\n                }\n                for (var i = intersectArray.length - 1; i >= 0; i--) {\n                    var child = this_4.diagram.nameTable[intersectArray[parseInt(i.toString(), 10)].id];\n                    if (child.parentId === nodeId) {\n                        intersectArray.splice(i, 1);\n                    }\n                }\n                if (intersectArray.length > 0) {\n                    var node = this_4.diagram.nameTable[intersectArray[intersectArray.length - 1].id];\n                    if (node.parentId) {\n                        var parentId = '';\n                        var parent_1 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findParentInSwimlane)(node, this_4.diagram, parentId);\n                        var obj_7 = this_4.diagram.nameTable[\"\" + parent_1];\n                        if (obj_7.id !== nodeId) {\n                            intersectArray[0] = obj_7;\n                        }\n                    }\n                    var originalZIndexTable = {}; // New variable to store original zIndex values\n                    // Store original zIndex values for nodes\n                    for (var i = 0; i < this_4.diagram.nodes.length; i++) {\n                        var node1 = this_4.diagram.nodes[parseInt(i.toString(), 10)];\n                        originalZIndexTable[node1.id] = node1.zIndex;\n                    }\n                    // Store original zIndex values for connectors\n                    for (var j = 0; j < this_4.diagram.connectors.length; j++) {\n                        var connector = this_4.diagram.connectors[parseInt(j.toString(), 10)];\n                        originalZIndexTable[connector.id] = connector.zIndex;\n                    }\n                    var overlapObject = intersectArray[0].zIndex;\n                    var temp_2 = zIndexTable[parseInt(overlapObject.toString(), 10)];\n                    //To store the zindex values as key value pair\n                    var zIndex_1 = {};\n                    intersectArray.forEach(function (item) {\n                        zIndex_1[item.id] = item.zIndex;\n                    });\n                    // To store the intersecting zindex value\n                    var greaterItems_1 = [];\n                    if (index) {\n                        var tempIndex_2 = index.zIndex;\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                        // @ts-nochec\n                        if (Object.keys(zIndex_1).length > 0) {\n                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                            // @ts-ignore\n                            Object.values(zIndex_1).forEach(function (val) {\n                                if (val >= tempIndex_2) {\n                                    greaterItems_1.push(val);\n                                }\n                            });\n                            if (greaterItems_1.length !== 0) {\n                                this_4.updateZIndexBySendForward(index, greaterItems_1, layerIndex);\n                            }\n                        }\n                    }\n                    var changedNodeZIndexesArray_1 = [];\n                    Object.keys(this_4.changedNodeZIndexes).forEach(function (nodeId) {\n                        var originalZIndex = originalNameTable[\"\" + nodeId] ? originalNameTable[\"\" + nodeId].zIndex : null;\n                        var changedZIndex = _this.changedNodeZIndexes[\"\" + nodeId];\n                        //By comparing with changedNodeZIndexes to store the changed elements in undo\n                        if (originalZIndex !== changedZIndex) {\n                            var node_2 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(originalNameTable[\"\" + nodeId]);\n                            changedNodeZIndexesArray_1.push(node_2);\n                        }\n                    });\n                    this_4.updateLayerZindexTable(layerIndex);\n                    changedNodeZIndexesArray_1.forEach(function (object) {\n                        if (!(undoObject_1.nodes.some(function (node) { return node.id === object.id; }))) {\n                            var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(object);\n                            undoObject_1.nodes.push(clonedNode);\n                        }\n                    });\n                    if (this_4.diagram.mode === 'SVG') {\n                        var nodeIdToUpdate = intersectArray[intersectArray.length - 1].id;\n                        var element = intersectArray[intersectArray.length - 1];\n                        // if (element && !(element.shape.type === 'HTML'\n                        //     || element.shape.type === 'Native')) {\n                        // this.moveForwardSvgNode(nodeId);\n                        this_4.moveAfterSvgNode(nodeId, nodeIdToUpdate);\n                        // }\n                        this_4.updateNativeNodeIndex(nodeIdToUpdate, nodeId);\n                    }\n                    else {\n                        this_4.diagram.refreshCanvasLayers();\n                    }\n                    Object.keys(this_4.changedNodeZIndexes).forEach(function (nodeId) {\n                        var originalZIndex = originalNameTable[\"\" + nodeId] ? originalNameTable[\"\" + nodeId].zIndex : null;\n                        var changedZIndex = _this.changedNodeZIndexes[\"\" + nodeId];\n                        //By comparing with changedNodeZIndexes to store the changed elements in redo\n                        if (originalZIndex !== changedZIndex) {\n                            var node_3 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(_this.diagram.nameTable[\"\" + nodeId]);\n                            changeNodeZIndexesArray_1.push(node_3);\n                        }\n                    });\n                }\n            };\n            var this_4 = this;\n            for (var s = objects.length - 1; s >= 0; s--) {\n                _loop_4(s);\n            }\n            var redoObject_1 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            changeNodeZIndexesArray_1.forEach(function (object) {\n                if (!(redoObject_1.nodes.some(function (node) { return node.id === object.id; }))) {\n                    var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(object);\n                    redoObject_1.nodes.push(clonedNode);\n                }\n            });\n            var historyEntry = {\n                type: 'SendForward', category: 'Internal',\n                undoObject: undoObject_1, redoObject: redoObject_1\n            };\n            if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(historyEntry);\n            }\n            this.diagram.endGroupAction();\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    //This method changes all the zindex values based on the selected node/connector\n    CommandHandler.prototype.updateZIndexBySendForward = function (selectedNode, greaterItems, layerNum) {\n        var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(selectedNode);\n        var nextHigherIndex = Math.min.apply(Math, greaterItems);\n        var objId = this.diagram.layers[parseInt(layerNum.toString(), 10)].\n            zIndexTable[parseInt(nextHigherIndex.toString(), 10)];\n        if (this.diagram.nameTable[\"\" + objId].children) {\n            nextHigherIndex = this.findGreatestChildZIndex(this.diagram.nameTable[\"\" + objId]);\n        }\n        var highIndex;\n        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;\n        var objects = this.diagram.nodes.filter(function (node) {\n            return layerObjects.indexOf(node.id) !== -1;\n        });\n        var connectors = this.diagram.connectors.filter(function (connector) {\n            return layerObjects.indexOf(connector.id) !== -1;\n        });\n        connectors.forEach(function (connector) {\n            objects.push(connector);\n        });\n        var frontNode = objects.filter(function (x) { return x.zIndex === nextHigherIndex && x.id !== selectedNode.id; });\n        if (selectedNode.children) {\n            selectedNode.zIndex = nextHigherIndex + 1;\n            this.updateGroupZindex(selectedNode, 'BringForward', selectedNode.zIndex);\n            highIndex = this.findGreatestChildZIndex(selectedNode);\n        }\n        else {\n            selectedNode.zIndex = nextHigherIndex + 1;\n            highIndex = selectedNode.zIndex;\n        }\n        this.triggerOrderCommand(clonedNode, selectedNode, selectedNode);\n        var sortedObjects = objects.slice().sort(function (a, b) { return a.zIndex - b.zIndex; });\n        var notChildOfSelectedNode = true;\n        for (var i = 0; i < sortedObjects.length; i++) {\n            var node = sortedObjects[parseInt(i.toString(), 10)];\n            if (selectedNode.children) {\n                notChildOfSelectedNode = this.notChildOfSelectedNode(node, selectedNode);\n            }\n            if (node.zIndex > nextHigherIndex && node !== selectedNode && node.parentId !== selectedNode.id &&\n                notChildOfSelectedNode && frontNode && frontNode.length > 0 && node.parentId !== frontNode[0].id) {\n                var clonedNode_1 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(node);\n                if (node.zIndex <= highIndex + 1) {\n                    node.zIndex = highIndex + 1;\n                    highIndex++;\n                    this.triggerOrderCommand(clonedNode_1, node, node);\n                }\n                else {\n                    break;\n                }\n            }\n            var originalZIndex = node.zIndex;\n            //changedNodeZIndexes store the zindex values with node id as key value pair\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.changedNodeZIndexes.hasOwnProperty(node.id)) {\n                this.changedNodeZIndexes[node.id] = originalZIndex;\n            }\n            else {\n                this.changedNodeZIndexes[node.id] = originalZIndex;\n            }\n        }\n    };\n    // private arrangeZIndexForLowerNodes(index: number, parent: Node, objects: NodeModel[]): void {\n    //     const lesserIndexNodes: NodeModel[] = objects.filter((x: NodeModel) => x.zIndex <= index && (x as Node).parentId !== parent.id);\n    //     lesserIndexNodes.sort((a: NodeModel, b: NodeModel) => b.zIndex - a.zIndex);\n    //     for (let i: number = 0; i < lesserIndexNodes.length; i++){\n    //         lesserIndexNodes[parseInt(i.toString(), 10)].zIndex = index - (i + 1);\n    //     }\n    // }\n    CommandHandler.prototype.findGreatestChildZIndex = function (parent) {\n        var _this = this;\n        var highestZIndex = parent.zIndex;\n        var findGreatestZIndex = function (parent) {\n            for (var i = 0; i < parent.children.length; i++) {\n                var child = _this.diagram.nameTable[parent.children[parseInt(i.toString(), 10)]];\n                if (child.children) {\n                    findGreatestZIndex(child);\n                }\n                else {\n                    if (child.zIndex > highestZIndex) {\n                        highestZIndex = child.zIndex; // Update zIndex for individual children\n                    }\n                }\n            }\n        };\n        findGreatestZIndex(parent);\n        return highestZIndex;\n    };\n    // check current node is not a children of selected node\n    CommandHandler.prototype.notChildOfSelectedNode = function (node, selectedNode) {\n        var _this = this;\n        var notChildOfSelectedNode = true;\n        var isNotChild = function (node, selectedNode) {\n            for (var i = 0; i < selectedNode.children.length; i++) {\n                var child = _this.diagram.nameTable[selectedNode.children[parseInt(i.toString(), 10)]];\n                if (child.id === node.id) {\n                    notChildOfSelectedNode = false;\n                    return notChildOfSelectedNode;\n                }\n                if (child.children) {\n                    isNotChild(node, child);\n                }\n            }\n            return notChildOfSelectedNode;\n        };\n        if (selectedNode.children) {\n            isNotChild(node, selectedNode);\n        }\n        return notChildOfSelectedNode;\n    };\n    // /**\n    //  * moveForwardSvgNode method\\\n    //  *\n    //  * @returns { void }    moveForwardSvgNode method .\\\n    //  * @param {string} targetID - provide the objects value.\n    //  * @private\n    //  */\n    // public moveForwardSvgNode(targetID: string): void {\n    //     const sortedNodeIds: string[] = Object.keys(this.changedNodeZIndexes).sort((a: string, b: string) => this.changedNodeZIndexes[`${a}`] - this.changedNodeZIndexes[`${b}`]);\n    //     const currentIndex: number = sortedNodeIds.indexOf(targetID);\n    //     if (currentIndex !== -1) {\n    //         //This logic moves the node/connector based on their zindex\n    //         if (currentIndex === sortedNodeIds.length - 1) {\n    //             const nextNodeId: string = sortedNodeIds[currentIndex - 1];\n    //             if (nextNodeId) {\n    //                 const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n    //                 const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);\n    //                 diagramDiv.parentNode.insertBefore(diagramDiv, backNode);\n    //                 diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n    //             }\n    //         }\n    //         else {\n    //             const nextNodeId: string = sortedNodeIds[currentIndex + 1];\n    //             if (nextNodeId) {\n    //                 const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n    //                 const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);\n    //                 diagramDiv.parentNode.insertBefore(diagramDiv, backNode);\n    //             }\n    //         }\n    //     }\n    // }\n    /**\n     * sendBackward method\\\n     *\n     * @returns {  void }    sendBackward method .\\\n     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.sendBackward = function (obj) {\n        var _this = this;\n        this.diagram.protectPropertyChange(true);\n        if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram) || obj) {\n            var selectedItems = this.diagram.selectedItems;\n            var objects = [];\n            if (obj && obj.id) {\n                objects.push(obj);\n            }\n            else {\n                objects = objects.concat(selectedItems.nodes);\n                objects = objects.concat(selectedItems.connectors);\n            }\n            this.sortByZIndex(objects);\n            var objectId = (obj && obj.id);\n            var undoObject_2 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            this.diagram.startGroupAction();\n            var changeNodeZIndexesArray_2 = [];\n            var _loop_6 = function (s) {\n                var clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(objects[parseInt(s.toString(), 10)]);\n                objectId = objects[parseInt(s.toString(), 10)].id;\n                var layerNum = this_5.diagram.layers.indexOf(this_5.getObjectLayer(objectId));\n                var originalNameTable = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this_5.diagram.nameTable);\n                var zIndexTable = this_5.diagram.layers[parseInt(layerNum.toString(), 10)].zIndexTable;\n                //const tabelLength: number = Object.keys(zIndexTable).length;\n                var node = this_5.diagram.nameTable[\"\" + objectId];\n                var intersectArray = [];\n                var temp = this_5.diagram.spatialSearch.findObjects(node.wrapper.bounds);\n                if (temp.length > 2) {\n                    temp = this_5.sortByZIndex(temp);\n                }\n                var _loop_7 = function (i) {\n                    if (node.id !== i.id) {\n                        var currentLayer = this_5.getObjectLayer(i.id).zIndex;\n                        var isSelectedObject = this_5.diagram.selectedItems.selectedObjects.some(function (object) {\n                            return object.id === i.id;\n                        });\n                        if ((this_5.diagram.selectedItems.selectedObjects.length === 1 || !isSelectedObject) && layerNum === currentLayer &&\n                            (Number(this_5.diagram.nameTable[\"\" + objectId].zIndex) > Number(i.zIndex)) &&\n                            i.parentId === '' && node.wrapper.bounds.intersects(i.wrapper.bounds)) {\n                            intersectArray.push(i);\n                        }\n                    }\n                };\n                for (var _i = 0, temp_3 = temp; _i < temp_3.length; _i++) {\n                    var i = temp_3[_i];\n                    _loop_7(i);\n                }\n                for (var i = intersectArray.length - 1; i >= 0; i--) {\n                    var child = this_5.diagram.nameTable[intersectArray[parseInt(i.toString(), 10)].id];\n                    if (child.parentId === objectId) {\n                        intersectArray.splice(i, 1);\n                    }\n                }\n                if (intersectArray.length > 0) {\n                    var child = this_5.diagram.nameTable[intersectArray[intersectArray.length - 1].id];\n                    if (child.parentId) {\n                        var parentId = '';\n                        var parent_2 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findParentInSwimlane)(child, this_5.diagram, parentId);\n                        var obj_8 = this_5.diagram.nameTable[\"\" + parent_2];\n                        if (objectId !== obj_8.id) {\n                            intersectArray[intersectArray.length - 1] = obj_8;\n                        }\n                    }\n                    var originalZIndexTable = {}; // New variable to store original zIndex values\n                    // Store original zIndex values for nodes\n                    for (var i = 0; i < this_5.diagram.nodes.length; i++) {\n                        var node1 = this_5.diagram.nodes[parseInt(i.toString(), 10)];\n                        originalZIndexTable[node1.id] = node1.zIndex;\n                    }\n                    // Store original zIndex values for connectors\n                    for (var j = 0; j < this_5.diagram.connectors.length; j++) {\n                        var connector = this_5.diagram.connectors[parseInt(j.toString(), 10)];\n                        originalZIndexTable[connector.id] = connector.zIndex;\n                    }\n                    var overlapObject = intersectArray[intersectArray.length - 1].zIndex;\n                    var temp_4 = zIndexTable[parseInt(overlapObject.toString(), 10)];\n                    var zIndex_2 = {};\n                    intersectArray.forEach(function (item) {\n                        zIndex_2[item.id] = item.zIndex;\n                    });\n                    var lesserItems_1 = [];\n                    if (node) {\n                        var tempIndex_3 = node.zIndex;\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                        // @ts-nochec\n                        if (Object.keys(zIndex_2).length > 0) {\n                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                            // @ts-ignore\n                            Object.values(zIndex_2).forEach(function (val) {\n                                if (val <= tempIndex_3) {\n                                    lesserItems_1.push(val);\n                                }\n                            });\n                            if (lesserItems_1.length !== 0) {\n                                this_5.updateZIndexBySendBackward(node, lesserItems_1, layerNum);\n                            }\n                        }\n                    }\n                    var changedNodeZIndexesArray_2 = [];\n                    Object.keys(this_5.changedNodeZIndexes).forEach(function (nodeId) {\n                        var originalZIndex = originalNameTable[\"\" + nodeId] ? originalNameTable[\"\" + nodeId].zIndex : null;\n                        var changedZIndex = _this.changedNodeZIndexes[\"\" + nodeId];\n                        //By comparing with changedNodeZIndexes to store the changed elements in undo\n                        if (originalZIndex !== changedZIndex) {\n                            var node_4 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(originalNameTable[\"\" + nodeId]);\n                            changedNodeZIndexesArray_2.push(node_4);\n                        }\n                    });\n                    this_5.updateLayerZindexTable(layerNum);\n                    changedNodeZIndexesArray_2.forEach(function (object) {\n                        if (!(undoObject_2.nodes.some(function (node) { return node.id === object.id; }))) {\n                            var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(object);\n                            undoObject_2.nodes.push(clonedNode);\n                        }\n                    });\n                    if (this_5.diagram.mode === 'SVG') {\n                        var nodeIdToUpdate = intersectArray[intersectArray.length - 1].id;\n                        var element = intersectArray[intersectArray.length - 1];\n                        if (element && !(element.shape.type === 'HTML'\n                            || element.shape.type === 'Native')) {\n                            // this.moveBackSvgNode(objectId);\n                            this_5.moveSvgNode(objectId, nodeIdToUpdate);\n                        }\n                        var node_5 = this_5.diagram.nameTable[\"\" + nodeIdToUpdate];\n                        if (node_5.children && node_5.children.length > 0) {\n                            this_5.updateNativeNodeIndex(objectId);\n                        }\n                        else {\n                            this_5.updateNativeNodeIndex(objectId, nodeIdToUpdate);\n                        }\n                    }\n                    else {\n                        this_5.diagram.refreshCanvasLayers();\n                    }\n                    Object.keys(this_5.changedNodeZIndexes).forEach(function (nodeId) {\n                        var originalZIndex = originalNameTable[\"\" + nodeId] ? originalNameTable[\"\" + nodeId].zIndex : null;\n                        var changedZIndex = _this.changedNodeZIndexes[\"\" + nodeId];\n                        //By comparing with changedNodeZIndexes to store the changed elements in redo\n                        if (originalZIndex !== changedZIndex) {\n                            var node_6 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(_this.diagram.nameTable[\"\" + nodeId]);\n                            changeNodeZIndexesArray_2.push(node_6);\n                        }\n                    });\n                }\n            };\n            var this_5 = this;\n            for (var s = 0; s < objects.length; s++) {\n                _loop_6(s);\n            }\n            var redoObject_2 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            changeNodeZIndexesArray_2.forEach(function (object) {\n                if (!(redoObject_2.nodes.some(function (node) { return node.id === object.id; }))) {\n                    var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(object);\n                    redoObject_2.nodes.push(clonedNode);\n                }\n            });\n            var entry = { type: 'SendBackward', category: 'Internal', undoObject: undoObject_2, redoObject: redoObject_2 };\n            if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n            this.diagram.endGroupAction();\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    //This method changes all the zindex values based on the selected node/connector\n    CommandHandler.prototype.updateZIndexBySendBackward = function (selectedNode, lesserItems, layerNum) {\n        var clonedNode = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(selectedNode);\n        var previousLowerIndex = Math.max.apply(Math, lesserItems);\n        var layerObjects = this.diagram.layers[parseInt(layerNum.toString(), 10)].objects;\n        var objects = this.diagram.nodes.filter(function (node) {\n            return layerObjects.indexOf(node.id) !== -1;\n        });\n        var connectors = this.diagram.connectors.filter(function (connector) {\n            return layerObjects.indexOf(connector.id) !== -1;\n        });\n        connectors.forEach(function (connector) {\n            objects.push(connector);\n        });\n        var backNode = objects.filter(function (x) { return x.zIndex === previousLowerIndex && x.id !== selectedNode.id; });\n        var childMaxZindex;\n        var childCount;\n        var lowIndex;\n        if (selectedNode.children) {\n            childMaxZindex = this.findMaxZIndex(selectedNode);\n            childCount = childMaxZindex - selectedNode.zIndex;\n            selectedNode.zIndex = previousLowerIndex - 1 - childCount;\n            this.updateGroupZindex(selectedNode, 'SendBackward', selectedNode.zIndex);\n            lowIndex = this.findLowestChildZIndex(selectedNode);\n        }\n        else {\n            selectedNode.zIndex = previousLowerIndex - 1;\n            lowIndex = selectedNode.zIndex;\n        }\n        this.triggerOrderCommand(clonedNode, selectedNode, selectedNode);\n        var sortedObjects = objects.slice().sort(function (a, b) { return b.zIndex - a.zIndex; });\n        var notChildOfSelectedNode = true;\n        for (var i = 0; i < sortedObjects.length; i++) {\n            var node = sortedObjects[parseInt(i.toString(), 10)];\n            if (selectedNode.children) {\n                notChildOfSelectedNode = this.notChildOfSelectedNode(node, selectedNode);\n            }\n            if (node.zIndex < previousLowerIndex && node !== selectedNode && node.parentId !== selectedNode.id &&\n                notChildOfSelectedNode && backNode && backNode.length > 0 && node.parentId !== backNode[0].id) {\n                var clonedNode_2 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(node);\n                if (node.zIndex >= lowIndex - 1) {\n                    node.zIndex = lowIndex - 1;\n                    lowIndex--;\n                    this.triggerOrderCommand(clonedNode_2, node, node);\n                }\n                else {\n                    break;\n                }\n            }\n            var originalZIndex = node.zIndex;\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.changedNodeZIndexes.hasOwnProperty(node.id)) {\n                this.changedNodeZIndexes[\"\" + node.id] = originalZIndex;\n            }\n            else {\n                this.changedNodeZIndexes[\"\" + node.id] = originalZIndex;\n            }\n        }\n    };\n    CommandHandler.prototype.findLowestChildZIndex = function (parent) {\n        var lowestZIndex = parent.zIndex;\n        for (var i = 0; i < parent.children.length; i++) {\n            var child = this.diagram.nameTable[parent.children[parseInt(i.toString(), 10)]];\n            if (child.zIndex < lowestZIndex) {\n                lowestZIndex = child.zIndex;\n            }\n        }\n        return lowestZIndex;\n    };\n    // /**\n    //  * moveBackSvgNode method\\\n    //  *\n    //  * @returns { void }    moveBackSvgNode method .\\\n    //  * @param {string} targetID - provide the objects value.\n    //  * @private\n    //  */\n    // public moveBackSvgNode(targetID: string): void {\n    //     const sortedNodeIds: string[] = Object.keys(this.changedNodeZIndexes).sort((a: string, b: string) => this.changedNodeZIndexes[`${a}`] - this.changedNodeZIndexes[`${b}`]);\n    //     const currentIndex: number = sortedNodeIds.indexOf(targetID);\n    //     //This logic moves the node/connector based on their zindex\n    //     if (currentIndex !== -1) {\n    //         const nextNodeId: string = sortedNodeIds[currentIndex + 1];\n    //         if (nextNodeId) {\n    //             const diagramDiv: HTMLElement = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n    //             const backNode: HTMLElement = getDiagramElement(nextNodeId + '_groupElement', this.diagram.element.id);\n    //             diagramDiv.parentNode.insertBefore(diagramDiv, backNode);\n    //         }\n    //     }\n    // }\n    /**\n     * updateNativeNodeIndex method\\\n     *\n     * @returns {  void }    updateNativeNodeIndex method .\\\n     *  @param { string } nodeId - Provide the previousObject element .\n     *  @param { string } targetID - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.updateNativeNodeIndex = function (nodeId, targetID) {\n        var node = this.diagram.selectedItems.nodes[0] || this.diagram.getObject(targetID);\n        for (var i = 0; i < this.diagram.views.length; i++) {\n            if (node && (node.shape.type === 'HTML'\n                || node.shape.type === 'Native')) {\n                var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';\n                var backNode = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(nodeId + id, this.diagram.views[parseInt(i.toString(), 10)]);\n                var diagramDiv = targetID ? (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getDiagramElement)(targetID + id, this.diagram.views[parseInt(i.toString(), 10)])\n                    : backNode.parentElement.firstChild;\n                if (backNode && diagramDiv) {\n                    if (backNode.parentNode.id === diagramDiv.parentNode.id) {\n                        diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * initSelectorWrapper method\\\n     *\n     * @returns {  void }    initSelectorWrapper method .\\\n     * @private\n     */\n    CommandHandler.prototype.initSelectorWrapper = function () {\n        var selectorModel = this.diagram.selectedItems;\n        selectorModel.init(this.diagram);\n        if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n            selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n            selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n            selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n        }\n    };\n    /**\n     * doRubberBandSelection method\\\n     *\n     * @returns {  void }    doRubberBandSelection method .\\\n     *  @param { Rect } region - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.doRubberBandSelection = function (region) {\n        this.clearSelectionRectangle();\n        var selArray = [];\n        var rubberArray = [];\n        selArray = this.diagram.getNodesConnectors(selArray);\n        if (this.diagram.selectedItems.rubberBandSelectionMode === 'CompleteIntersect') {\n            rubberArray = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.completeRegion)(region, selArray);\n        }\n        else {\n            rubberArray = this.diagram.spatialSearch.findObjects(region);\n        }\n        if (rubberArray.length) {\n            this.selectObjects(rubberArray, true);\n        }\n    };\n    CommandHandler.prototype.clearSelectionRectangle = function () {\n        var adornerSvg = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getAdornerLayerSvg)(this.diagram.element.id);\n        var element = adornerSvg.getElementById(this.diagram.element.id + '_diagramAdorner_selected_region');\n        if (element) {\n            (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.remove)(element);\n        }\n    };\n    /**\n     * dragConnectorEnds method\\\n     *\n     * @returns {  void }    dragConnectorEnds method .\\\n     *  @param { string } endPoint - Provide the previousObject element .\n     *  @param { IElement } obj - Provide the previousObject element .\n     *  @param { PointModel } point - Provide the point element .\n     *  @param { BezierSegmentModel } segment - Provide the segment element .\n     *  @param { IElement } target - Provide the target element .\n     *  @param { string } targetPortId - Provide the targetPortId element .\n     * @private\n     */\n    CommandHandler.prototype.dragConnectorEnds = function (endPoint, obj, point, segment, target, targetPortId) {\n        var selectorModel;\n        var connector; //let node: Node;\n        var tx; //let segmentPoint: PointModel;\n        var ty; //let index: number;\n        var checkBezierThumb = false;\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n            selectorModel = obj;\n            connector = selectorModel.connectors[0];\n        }\n        else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && this.diagram.currentDrawingObject) {\n            this.clearSelection();\n            connector = this.diagram.currentDrawingObject;\n        }\n        if (endPoint === 'BezierSourceThumb' || endPoint === 'BezierTargetThumb') {\n            checkBezierThumb = true;\n            connector.isBezierEditing = true;\n        }\n        if (endPoint === 'ConnectorSourceEnd' || endPoint === 'BezierSourceThumb') {\n            tx = point.x - (checkBezierThumb ? segment.bezierPoint1.x : connector.sourcePoint.x);\n            ty = point.y - (checkBezierThumb ? segment.bezierPoint1.y : connector.sourcePoint.y);\n            return this.dragSourceEnd(connector, tx, ty, null, point, endPoint, undefined, target, targetPortId, undefined, segment);\n        }\n        else {\n            tx = point.x - (checkBezierThumb ? segment.bezierPoint2.x : connector.targetPoint.x);\n            ty = point.y - (checkBezierThumb ? segment.bezierPoint2.y : connector.targetPoint.y);\n            return this.dragTargetEnd(connector, tx, ty, null, point, endPoint, undefined, segment);\n        }\n    };\n    /**\n     * getSelectedObject method\\\n     *\n     * @returns {  void }    getSelectedObject method .\\\n     * @private\n     */\n    CommandHandler.prototype.getSelectedObject = function () {\n        var selectormodel = this.diagram.selectedItems;\n        if (selectormodel.annotation) {\n            return [selectormodel.annotation];\n        }\n        else {\n            return (selectormodel.nodes).concat(selectormodel.connectors);\n        }\n    };\n    // /**\n    //  * updateBlazorProperties method\\\n    //  *\n    //  * @returns {  void }    updateBlazorProperties method .\\\n    //  *  @param { boolean } isObjectInteraction - Provide the previousObject element .\n    //  * @private\n    //  */\n    // public updateBlazorProperties(isObjectInteraction?: boolean): void {\n    // const blazorInterop: string = 'sfBlazor';\n    // const blazor: string = 'Blazor';\n    // if (!isObjectInteraction) {\n    //     if (window && window[`${blazor}`]) {\n    //         const obj: object = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.diagramObject };\n    //         // window[`${blazorInterop}`].updateBlazorProperties(obj, this.diagram);\n    //     }\n    // } else {\n    //     if (window && window[`${blazor}`] && JSON.stringify(this.deepDiffer.diagramObject) !== '{}') {\n    //         const obj: object = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.deepDiffer.diagramObject };\n    //         if (!this.diagram.isLoading) {\n    //             // window[`${blazorInterop}`].updateBlazorProperties(obj, this.diagram);\n    //         }\n    //     }\n    // }\n    // //this.diagram.enableServerDataBinding(true);\n    // this.deepDiffer.newNodeObject = [];\n    // this.deepDiffer.newConnectorObject = [];\n    // this.diagramObject = [];\n    // this.diagram.oldNodeObjects = [];\n    // this.diagram.oldConnectorObjects = [];\n    // }\n    // /**\n    //  * enableCloneObject method\\\n    //  *\n    //  * @returns {  void }    enableCloneObject method .\\\n    //  *  @param { boolean } value - Provide the previousObject element .\n    //  * @private\n    //  */\n    CommandHandler.prototype.enableCloneObject = function (value) {\n        // if ((!this.diagram.lineRoutingModule || !(this.diagram.constraints & DiagramConstraints.LineRouting))) {\n        //     this.diagram.canEnableBlazorObject = value;\n        // }\n    };\n    // /**\n    //  * ismouseEvents method\\\n    //  *\n    //  * @returns {  void }    ismouseEvents method .\\\n    //  *  @param { boolean } value - Provide the previousObject element .\n    //  * @private\n    //  */\n    // public ismouseEvents(value: boolean): void {\n    //     // if (value) {\n    //     //     this.diagram.blazorActions = this.diagram.addConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n    //     // } else {\n    //     //     this.diagram.blazorActions = this.diagram.removeConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n    //     // }\n    // }\n    // /**\n    //  * updateLayerObject method\\\n    //  *\n    //  * @returns {  void }    updateLayerObject method .\\\n    //  *  @param { object } oldDiagram - Provide the previousObject element .\n    //  *  @param { boolean } temp - Provide the temp element .\n    //  * @private\n    //  */\n    // public updateLayerObject(oldDiagram: object, temp?: boolean): void {\n    // comment blazor code\n    // }\n    // /* tslint:enable:no-string-literal */\n    // /**\n    //  * getDiagramOldValues method\\\n    //  *\n    //  * @returns {  void }    getDiagramOldValues method .\\\n    //  *  @param { object } oldDiagram - Provide the previousObject element .\n    //  *  @param { string[] } attribute - Provide the previousObject element .\n    //  * @private\n    //  */\n    // public getDiagramOldValues(oldDiagram: object, attribute: string[]): void {\n    //     const newDiagram: object = {};\n    //     for (let i: number = 0; i < attribute.length; i++) {\n    //         newDiagram[attribute[parseInt(i.toString(), 10)]] = cloneObject(this.diagram[attribute[parseInt(i.toString(), 10)]]);\n    //     }\n    //     const newObject: Object = cloneObject(newDiagram);\n    //     const result: object = this.deepDiffer.map(newObject, oldDiagram);\n    //     const diffValue: object = this.deepDiffer.frameObject({}, result);\n    //     let diff: object = this.deepDiffer.removeEmptyValues(diffValue);\n    //     diff = this.deepDiffer.changeSegments(diff, newObject);\n    //     this.diagramObject = diff;\n    //     if (!(this.diagram.blazorActions & BlazorAction.ClearObject)) {\n    //         // this.updateBlazorProperties();\n    //     }\n    // }\n    /* tslint:disable */\n    /**\n     * getBlazorOldValues method\\\n     *\n     * @returns {  void }    getBlazorOldValues method .\\\n     *  @param { MouseEventArgs } args - Provide the previousObject element .\n     *  @param { boolean } labelDrag - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.getBlazorOldValues = function (args, labelDrag) {\n        //comment blazor code\n    };\n    // /**\n    //  * getObjectChanges method\\\n    //  *\n    //  * @returns {  void }    getObjectChanges method .\\\n    //  *  @param { Object[] } previousObject - Provide the previousObject element .\n    //  *  @param { Object[] } currentObject - Provide the previousObject element .\n    //  *  @param { Object[] } previousObject - Provide the previousObject element .\n    //  * @private\n    //  */\n    // public getObjectChanges(previousObject: Object[], currentObject: Object[], changedNodes: Object[]): void {\n    // }\n    /**\n     * clearObjectSelection method\\\n     *\n     * @returns {  void }    clearObjectSelection method .\\\n     *  @param { (NodeModel | ConnectorModel) } mouseDownElement - Provide the triggerAction element .\n     * @private\n     */\n    // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node\n    CommandHandler.prototype.clearObjectSelection = function (mouseDownElement) {\n        var selectedItems = this.diagram.selectedItems;\n        var list = [];\n        list = list.concat(selectedItems.nodes, selectedItems.connectors);\n        if (list.indexOf(mouseDownElement) === -1) {\n            this.clearSelection((list.length > 0) ? true : false);\n            this.selectObjects([mouseDownElement], true);\n        }\n    };\n    /**\n     * clearSelection method\\\n     *\n     * @returns {  void }    clearSelection method .\\\n     *  @param { boolean } triggerAction - Provide the triggerAction element .\n     *  @param { boolean } isTriggered - Provide the isTriggered element .\n     * @private\n     */\n    CommandHandler.prototype.clearSelection = function (triggerAction, isTriggered) {\n        return __awaiter(this, void 0, void 0, function () {\n            var enableServerDataBinding, selectormodel, arrayNodes, arg;\n            return __generator(this, function (_a) {\n                enableServerDataBinding = this.diagram.allowServerDataBinding;\n                this.diagram.enableServerDataBinding(false);\n                if ((0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram)) {\n                    selectormodel = this.diagram.selectedItems;\n                    arrayNodes = this.getSelectedObject();\n                    if (this.diagram.currentSymbol) {\n                        this.diagram.previousSelectedObject = arrayNodes;\n                    }\n                    arg = {\n                        oldValue: arrayNodes, newValue: [], cause: this.diagram.diagramActions,\n                        state: 'Changing', type: 'Removal', cancel: false\n                    };\n                    // this.updateBlazorSelectorModel(arrayNodes, true);\n                    if (triggerAction) {\n                        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)()) {\n                            this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, arg);\n                        }\n                    }\n                    if (!arg.cancel) {\n                        selectormodel.offsetX = 0;\n                        selectormodel.offsetY = 0;\n                        selectormodel.width = 0;\n                        selectormodel.height = 0;\n                        selectormodel.rotateAngle = 0;\n                        selectormodel.nodes = [];\n                        selectormodel.connectors = [];\n                        selectormodel.wrapper = null;\n                        selectormodel.annotation = undefined;\n                        // EJ2-56919 - While clear selection empty the selectedObjects collection\n                        selectormodel.selectedObjects = [];\n                        this.diagram.clearSelectorLayer();\n                        if (triggerAction) {\n                            arg = {\n                                oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(arrayNodes), newValue: [], cause: this.diagram.diagramActions,\n                                state: 'Changed', type: 'Removal', cancel: false\n                            };\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)()) {\n                                this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.selectionChange, arg);\n                            }\n                        }\n                    }\n                    // this.updateBlazorSelector();\n                    this.diagram.enableServerDataBinding(enableServerDataBinding);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * clearSelectedItems method\\\n     *\n     * @returns {  void }    clearSelectedItems method .\\\n     * @private\n     */\n    CommandHandler.prototype.clearSelectedItems = function () {\n        var selectedNodes = this.diagram.selectedItems.nodes ? this.diagram.selectedItems.nodes.length : 0;\n        var selectedConnectors = this.diagram.selectedItems.connectors ? this.diagram.selectedItems.connectors.length : 0;\n        this.clearSelection((selectedNodes + selectedConnectors) > 0 ? true : false);\n    };\n    /**\n     * removeStackHighlighter method\\\n     *\n     * @returns {  void }    removeStackHighlighter method .\\\n     * @private\n     */\n    CommandHandler.prototype.removeStackHighlighter = function () {\n        var adornerSvg = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getAdornerLayerSvg)(this.diagram.element.id);\n        var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');\n        if (highlighter) {\n            highlighter.parentNode.removeChild(highlighter);\n        }\n    };\n    /**\n     * @param {End} args - provide the args  value.\n     * @param {IElement} target - provide the target  value.\n     * @private\n     */\n    CommandHandler.prototype.renderStackHighlighter = function (args, target) {\n        var source = this.diagram.selectedItems.nodes[0];\n        var symbolDrag;\n        var node;\n        var selectorModel;\n        if (!target) {\n            var objects = this.diagram.findObjectsUnderMouse(args.position);\n            target = this.diagram.findObjectUnderMouse(objects, 'Drag', true);\n            if (target && !(target.isLane || target.isPhase || target.isHeader)) {\n                for (var i = 0; i < objects.length; i++) {\n                    var laneNode = this.diagram.nameTable[objects[parseInt(i.toString(), 10)].id];\n                    if (!laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {\n                        target = laneNode;\n                        this.diagram.parentObject = target;\n                    }\n                }\n            }\n        }\n        if (source && target && target.isLane && source.shape && !source.shape.isPhase) {\n            node = this.diagram.nameTable[target.parentId];\n            if (this.diagram.currentSymbol && node.shape.type === 'SwimLane') {\n                symbolDrag = true;\n            }\n            if ((source && !source.parentId && source.shape.type !== 'SwimLane') ||\n                (source && source.parentId && this.diagram.nameTable[source.parentId] && this.diagram.nameTable[source.parentId].isLane &&\n                    (source.parentId !== target.parentId && source.parentId !== target.id))) {\n                selectorModel = this.diagram.selectedItems;\n                var canvas = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.gridSelection)(this.diagram, selectorModel, target.id, true);\n                //Bug 904547: Snapping of nodes inside the swimlane is not proper.\n                //Instead of assigning the canvas to the selectorModel children, pass them to render selector to highlight the swimlane.\n                this.diagram.renderSelector(false, true, canvas);\n                selectorModel.wrapper.children[0] = selectorModel.nodes[0].wrapper;\n            }\n        }\n        if (source && target && target.parentId && source.shape && source.shape.isPhase) {\n            var node_7 = this.diagram.nameTable[target.parentId];\n            if (node_7.shape.type === 'SwimLane') {\n                //Bug 904547: Snapping of nodes inside the swimlane is not proper.\n                //Instead of assigning the canvas to the selectorModel children, pass them to render selector to highlight the swimlane.\n                var canvas = this.diagram.nameTable[target.parentId].wrapper;\n                this.diagram.renderSelector(false, true, canvas);\n            }\n        }\n        if ((symbolDrag && this.diagram.currentSymbol.shape.isLane) || (source && target &&\n            source.parentId && target.parentId && !source.isPhase && (source.parentId === target.parentId)\n            && (source.id !== target.id) && node &&\n            (node.container && (node.container.type === 'Stack' || node.container.type === 'Grid')))) {\n            var canvas = void 0;\n            var value = node.container.orientation === 'Vertical';\n            var isVertical = node.container === 'Stack' ? value : !value;\n            if (node.container.type === 'Grid' && target.isLane &&\n                (((node.shape.orientation === 'Horizontal' && target.rowIndex !== source.rowIndex) ||\n                    (node.shape.orientation === 'Vertical' && target.columnIndex !== source.columnIndex))\n                    || (this.diagram.currentSymbol &&\n                        this.diagram.currentSymbol.shape.orientation === node.container.orientation))) {\n                selectorModel = this.diagram.selectedItems;\n                if ((source.isLane && (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.canLaneInterchange)(source, this.diagram)) || !source.isLane) {\n                    canvas = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.gridSelection)(this.diagram, selectorModel, target.id, symbolDrag);\n                }\n            }\n            var wrapper = node.container.type === 'Stack' ? target.wrapper : canvas;\n            if (wrapper) {\n                (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.renderStackHighlighter)(wrapper, isVertical, args.position, this.diagram, false, true);\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.insertBlazorConnector = function (obj) {\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n            for (var i = 0; i < obj.connectors.length; i++) {\n                this.diagram.insertBlazorConnector(obj.connectors[parseInt(i.toString(), 10)]);\n            }\n        }\n        else {\n            this.diagram.insertBlazorConnector(obj);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drag = function (obj, tx, ty) {\n        var tempNode;\n        var elements = [];\n        // EJ2-846953: The below code is added to set current action to drag when we drag objects dynamically using method.\n        // It is used to prevent the updateGroupSize method call for group node while dragging it.\n        if (!this.diagram.rotateUsingButton && obj.shape && obj.shape.type !== 'SwimLane') {\n            this.diagram.eventHandler.currentAction = 'Drag';\n        }\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canMove)(obj) && this.checkBoundaryConstraints(tx, ty, obj.wrapper.bounds) && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canPageEditable)(this.diagram)) {\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                var oldValues = { offsetX: obj.offsetX, offsetY: obj.offsetY };\n                obj.offsetX += tx;\n                obj.offsetY += ty;\n                if (obj.children && !(obj.container)) {\n                    if (!((0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, obj, true))) {\n                        this.diagram.diagramActions = this.diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.isGroupDragging;\n                    }\n                    var nodes = this.getAllDescendants(obj, elements);\n                    for (var i = 0; i < nodes.length; i++) {\n                        tempNode = (this.diagram.nameTable[nodes[parseInt(i.toString(), 10)].id]);\n                        this.drag(tempNode, tx, ty);\n                    }\n                    this.updateInnerParentProperties(obj);\n                    this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.isGroupDragging;\n                }\n                if ((0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, obj, true)) {\n                    (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkChildNodeInContainer)(this.diagram, obj);\n                }\n                else {\n                    if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n                        obj.wrapper.measureChildren = true;\n                    }\n                    this.diagram.nodePropertyChange(obj, oldValues, { offsetX: obj.offsetX, offsetY: obj.offsetY }, undefined, undefined, false);\n                    obj.wrapper.measureChildren = false;\n                }\n                if (obj.shape.type === 'SwimLane' && !this.diagram.currentSymbol) {\n                    var grid = obj.wrapper.children[0];\n                    var connectors = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.getConnectors)(this.diagram, grid, 0, true);\n                    (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.updateConnectorsProperties)(connectors, this.diagram);\n                }\n            }\n            else {\n                var connector = obj;\n                // 909588: Property change new & old value are same upon connector drag\n                var oldConnector = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj);\n                var oldValues = { sourcePoint: oldConnector.sourcePoint, targetPoint: oldConnector.targetPoint };\n                var update = connector.type === 'Bezier' ? true : false;\n                var hasEnds = false;\n                if (!connector.sourceWrapper) {\n                    this.dragSourceEnd(connector, tx, ty, true, null, '', update);\n                }\n                else {\n                    hasEnds = true;\n                }\n                if (!connector.targetWrapper) {\n                    this.dragTargetEnd(connector, tx, ty, true, null, '', update);\n                }\n                else {\n                    hasEnds = true;\n                }\n                var canDragPoints = false;\n                if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n                    canDragPoints = true;\n                }\n                if (!hasEnds || canDragPoints) {\n                    this.dragControlPoint(connector, tx, ty, true);\n                    var conn = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                    this.diagram.connectorPropertyChange(connector, oldValues, conn);\n                }\n            }\n        }\n        //886700: undo and redo changes not reflected properly in overview after rotate and resize\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            // eslint-disable-next-line security/detect-object-injection\n            var view = this.diagram.views[temp];\n            if (view instanceof _overview_overview__WEBPACK_IMPORTED_MODULE_23__.Overview) {\n                this.diagram.refreshCanvasDiagramLayer(view);\n            }\n        }\n    };\n    /**   @private  */\n    CommandHandler.prototype.connectorSegmentChange = function (actualObject, existingInnerBounds, isRotate) {\n        var tx;\n        var ty;\n        var segmentChange = true;\n        if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {\n            if (actualObject.outEdges.length > 0) {\n                for (var k = 0; k < actualObject.outEdges.length; k++) {\n                    var connector = this.diagram.nameTable[actualObject.outEdges[parseInt(k.toString(), 10)]];\n                    if (connector.targetID !== '') {\n                        segmentChange = this.isSelected(this.diagram.nameTable[connector.targetID]) ? false : true;\n                    }\n                    else {\n                        segmentChange = this.isSelected(this.diagram.nameTable[connector.id]) ? false : true;\n                    }\n                    if (connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 1) {\n                        if (!isRotate) {\n                            if (segmentChange) {\n                                switch (connector.segments[0].direction) {\n                                    case 'Bottom':\n                                        tx = actualObject.wrapper.bounds.bottomCenter.x - existingInnerBounds.bottomCenter.x;\n                                        ty = actualObject.wrapper.bounds.bottomCenter.y - existingInnerBounds.bottomCenter.y;\n                                        break;\n                                    case 'Top':\n                                        tx = actualObject.wrapper.bounds.topCenter.x - existingInnerBounds.topCenter.x;\n                                        ty = actualObject.wrapper.bounds.topCenter.y - existingInnerBounds.topCenter.y;\n                                        break;\n                                    case 'Left':\n                                        tx = actualObject.wrapper.bounds.middleLeft.x - existingInnerBounds.middleLeft.x;\n                                        ty = actualObject.wrapper.bounds.middleLeft.y - existingInnerBounds.middleLeft.y;\n                                        break;\n                                    case 'Right':\n                                        tx = actualObject.wrapper.bounds.middleRight.x - existingInnerBounds.middleRight.x;\n                                        ty = actualObject.wrapper.bounds.middleRight.y - existingInnerBounds.middleRight.y;\n                                        break;\n                                }\n                                this.dragSourceEnd(connector, tx, ty, true, null, 'ConnectorSourceEnd', undefined, undefined, undefined, (actualObject.parentId &&\n                                    (this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.isGroupDragging)) ? false : true);\n                            }\n                        }\n                        else {\n                            var firstSegment = connector.segments[0];\n                            var secondSegment = connector.segments[1];\n                            var cornerPoints = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.swapBounds)(actualObject.wrapper, actualObject.wrapper.corners, actualObject.wrapper.bounds);\n                            var sourcePoint = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findPoint)(cornerPoints, firstSegment.direction);\n                            sourcePoint = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.getIntersection)(connector, connector.sourceWrapper, sourcePoint, { x: connector.sourceWrapper.offsetX, y: connector.sourceWrapper.offsetY }, false);\n                            var source = {\n                                corners: undefined, point: sourcePoint, margin: undefined, direction: firstSegment.direction\n                            };\n                            var target = {\n                                corners: undefined, point: secondSegment.points[1], margin: undefined, direction: undefined\n                            };\n                            var intermediatePoints = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.orthoConnection2Segment)(source, target);\n                            firstSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(intermediatePoints[0], intermediatePoints[1]);\n                            if (secondSegment.direction && secondSegment.length) {\n                                secondSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(intermediatePoints[1], intermediatePoints[2]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.updateEndPoint = function (connector, oldChanges) {\n        var conn = {\n            sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint,\n            sourceID: connector.sourceID ? connector.sourceID : undefined,\n            targetID: connector.targetID ? connector.targetID : undefined,\n            sourcePortID: connector.sourcePortID ? connector.sourcePortID : undefined,\n            targetPortID: connector.targetPortID ? connector.targetPortID : undefined,\n            segments: connector.segments ? connector.segments : undefined\n        };\n        var newValue = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n        if (connector.sourceID) {\n            newValue.sourceID = connector.sourceID;\n        }\n        if (connector.targetID) {\n            newValue.targetID = connector.targetID;\n        }\n        if (connector.sourcePortID) {\n            newValue.sourcePortID = connector.sourcePortID;\n        }\n        if (connector.targetPortID) {\n            newValue.targetPortID = connector.targetPortID;\n        }\n        if (connector.segments) {\n            newValue.segments = connector.segments;\n        }\n        this.diagram.connectorPropertyChange(connector, oldChanges ? oldChanges : {}, newValue);\n        // this.diagram.refreshDiagramLayer();\n        this.diagram.updateSelector();\n    };\n    /**\n     * @param obj\n     * @param tx\n     * @param ty\n     * @param preventUpdate\n     * @param point\n     * @param endPoint\n     * @param update\n     * @param target\n     * @param targetPortId\n     * @param isDragSource\n     * @param segment\n     * @private\n     */\n    CommandHandler.prototype.dragSourceEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, target, targetPortId, isDragSource, segment) {\n        var connector = this.diagram.nameTable[obj.id];\n        var oldChanges = {};\n        var checkBoundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canDragSourceEnd)(connector) && checkBoundaryConstraints\n            && (endPoint !== 'BezierSourceThumb') && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canPageEditable)(this.diagram)) {\n            oldChanges = { sourcePoint: connector.sourcePoint };\n            oldChanges = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(oldChanges);\n            connector.sourcePoint.x += tx;\n            connector.sourcePoint.y += ty;\n            if (endPoint === 'ConnectorSourceEnd' && connector.type === 'Orthogonal') {\n                this.changeSegmentLength(connector, target, targetPortId, isDragSource);\n            }\n            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {\n                this.updatePathElementOffset(connector);\n            }\n        }\n        if (connector.type === 'Bezier') {\n            oldChanges = { sourcePoint: connector.sourcePoint };\n            if (segment) {\n                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, segment, point, !update);\n            }\n            else {\n                for (var i = 0; i < obj.segments.length; i++) {\n                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, obj.segments[parseInt(i.toString(), 10)], point, !update);\n                }\n            }\n        }\n        if (!preventUpdate) {\n            this.updateEndPoint(connector, oldChanges);\n        }\n        if (!(this.diagram.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.RealAction.AnimationClick)) {\n            this.diagram.refreshCanvasLayers();\n        }\n        return checkBoundaryConstraints;\n    };\n    /**\n     * Update Path Element offset\n     */\n    CommandHandler.prototype.updatePathElementOffset = function (connector) {\n        connector.wrapper.children.splice(3, 1);\n        var pathElement = new _core_elements_path_element__WEBPACK_IMPORTED_MODULE_2__.PathElement();\n        var anglePoints = connector.intermediatePoints;\n        pathElement = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updatePathElement)(anglePoints, connector);\n        connector.wrapper.children.splice(3, 0, pathElement);\n    };\n    /**\n     * Upadte the connector segments when change the source node\n     */\n    CommandHandler.prototype.changeSegmentLength = function (connector, target, targetPortId, isDragSource) {\n        // EJ2-65063 - Added below code to check condition if connector segment length can be changed or not.\n        // If inconnect and outconnect removed from node constraints\n        var canChangeSegment = target ? this.canConnect(connector, target) : true;\n        if (connector.segments && connector.segments[0].direction !== null\n            && ((!target && connector.sourceID === '') || isDragSource) && canChangeSegment) {\n            var first = connector.segments[0];\n            var second = connector.segments[1];\n            var node = this.diagram.nameTable[connector.sourceID];\n            var secPoint = void 0;\n            first.points[0] = connector.sourcePoint;\n            if (first.direction === 'Top' || first.direction === 'Bottom') {\n                first.points[first.points.length - 1].x = connector.sourcePoint.x;\n                second.points[0].y = first.points[first.points.length - 1].y;\n            }\n            else {\n                first.points[first.points.length - 1].y = connector.sourcePoint.y;\n                second.points[0].x = first.points[first.points.length - 1].x;\n            }\n            if (first.direction && (first.length || first.length === 0)) {\n                first.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n            }\n            if (second.direction && (second.length || second.length === 0)) {\n                second.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n                second.direction = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.direction(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n            }\n            if (connector.sourcePortID !== '' && first.length < 10) {\n                if (connector.segments.length > 2) {\n                    var next = connector.segments[2];\n                    var nextDirection = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.direction(next.points[0], next.points[1]);\n                    if (first.direction === (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.getOppositeDirection)(nextDirection)) {\n                        if (first.direction === 'Right') {\n                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleRight.x + 20;\n                        }\n                        else if (first.direction === 'Left') {\n                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleLeft.x - 20;\n                        }\n                        else if (first.direction === 'Top') {\n                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.topCenter.y - 20;\n                        }\n                        else {\n                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.bottomCenter.y + 20;\n                        }\n                        if (next.direction && next.length) {\n                            next.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                        }\n                        first.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n                    }\n                    else if (first.direction === nextDirection && next.direction && next.length) {\n                        if (first.direction === 'Top' || first.direction === 'Bottom') {\n                            next.points[0] = first.points[0];\n                            next.points[next.points.length - 1].x = next.points[0].x;\n                        }\n                        else {\n                            next.points[0] = first.points[0];\n                            next.points[next.points.length - 1].y = next.points[0].y;\n                        }\n                        next.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                        connector.segments.splice(0, 2);\n                    }\n                    else {\n                        first.length = 20;\n                    }\n                }\n                else {\n                    first.length = 20;\n                }\n            }\n            else if (first.length < 1) {\n                if (connector.sourceID !== '') {\n                    if (second.direction === 'Right') {\n                        secPoint = node.wrapper.corners.middleRight;\n                        second.points[second.points.length - 1].y = secPoint.y;\n                    }\n                    else if (second.direction === 'Left') {\n                        secPoint = node.wrapper.corners.middleLeft;\n                        second.points[second.points.length - 1].y = secPoint.y;\n                    }\n                    else if (second.direction === 'Top') {\n                        secPoint = node.wrapper.corners.topCenter;\n                        second.points[second.points.length - 1].x = secPoint.x;\n                    }\n                    else {\n                        secPoint = node.wrapper.corners.bottomCenter;\n                        second.points[second.points.length - 1].x = secPoint.x;\n                    }\n                    second.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(secPoint, second.points[second.points.length - 1]);\n                    if (connector.segments.length > 2) {\n                        var next = connector.segments[2];\n                        if (next.direction && next.length) {\n                            next.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(second.points[second.points.length - 1], next.points[next.points.length - 1]);\n                        }\n                    }\n                    connector.segments.splice(0, 1);\n                }\n                else {\n                    connector.segments.splice(0, 1);\n                }\n            }\n        }\n        else {\n            if (target && !targetPortId && connector.sourceID !== target.id &&\n                connector.segments && connector.segments[0].direction !== null\n                && target && target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node && canChangeSegment) {\n                this.changeSourceEndToNode(connector, target);\n            }\n            if (target && targetPortId && connector.sourcePortID !== targetPortId &&\n                connector.segments && connector.segments[0].direction !== null\n                && target && target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node && canChangeSegment) {\n                this.changeSourceEndToPort(connector, target, targetPortId);\n            }\n        }\n    };\n    // EJ2-65063 - Added below method to check if target has inConnect or outConnect. If it does not have inconnect and outconnect means then return false\n    CommandHandler.prototype.canConnect = function (connector, target) {\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canInConnect)(target) && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canOutConnect)(target)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Change the connector endPoint to port\n     */\n    CommandHandler.prototype.changeSourceEndToPort = function (connector, target, targetPortId) {\n        var port = this.diagram.getWrapper(target.wrapper, targetPortId);\n        var point = { x: port.offsetX, y: port.offsetY };\n        var direction = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.getPortDirection)(point, (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cornersPointsBeforeRotation)(target.wrapper), target.wrapper.bounds, false);\n        var firstSegment = connector.segments[0];\n        var secondSegment = connector.segments[1];\n        if (firstSegment.direction !== direction) {\n            var segments = [];\n            var segValues = {};\n            if (firstSegment.direction === (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.getOppositeDirection)(direction)) {\n                segValues = {};\n                var segValues1 = void 0;\n                if (direction === 'Top' || direction === 'Bottom') {\n                    segValues1 = (direction === 'Top') ? {\n                        type: 'Orthogonal', isTerminal: true, direction: direction,\n                        length: Math.abs(firstSegment.points[0].y - point.y)\n                    } :\n                        {\n                            type: 'Orthogonal', isTerminal: true, direction: direction,\n                            length: Math.abs(point.y - firstSegment.points[0].y)\n                        };\n                    segValues = (firstSegment.points[0].x > point.x) ?\n                        { type: 'Orthogonal', isTerminal: true, direction: 'Right', length: (firstSegment.points[0].x - point.x) } :\n                        { type: 'Orthogonal', isTerminal: true, direction: 'Left', length: (point.x - firstSegment.points[0].x) };\n                }\n                else {\n                    segValues1 = (direction === 'Right') ? {\n                        type: 'Orthogonal', isTerminal: true, direction: direction,\n                        length: Math.abs(firstSegment.points[0].x - point.x)\n                    } :\n                        {\n                            type: 'Orthogonal', isTerminal: true, direction: direction,\n                            length: Math.abs(point.x - firstSegment.points[0].x)\n                        };\n                    segValues = (firstSegment.points[0].y > point.y) ?\n                        { type: 'Orthogonal', direction: 'Top', isTerminal: true, length: (firstSegment.points[0].y - point.y) } :\n                        { type: 'Orthogonal', direction: 'Bottom', isTerminal: true, length: (point.y - firstSegment.points[0].y) };\n                }\n                segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(connector, 'segments', segValues1, true));\n                segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(connector, 'segments', segValues, true));\n            }\n            else {\n                segValues = { type: 'Orthogonal', direction: direction, length: 20, isTerminal: true };\n                segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(connector, 'segments', segValues, true));\n            }\n            if (firstSegment.direction !== (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.getOppositeDirection)(direction)) {\n                if (direction === 'Top' || direction === 'Bottom') {\n                    firstSegment.points[0].x = point.x;\n                    firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = (direction === 'Top') ?\n                        point.y - 20 : point.y + 20;\n                }\n                else {\n                    firstSegment.points[0].y = point.y;\n                    firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = (direction === 'Right') ?\n                        point.x + 20 : point.x - 20;\n                }\n                firstSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                secondSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n            }\n            connector.segments = segments.concat(connector.segments);\n        }\n        else {\n            firstSegment.points[0] = point;\n            if (direction === 'Top' || direction === 'Bottom') {\n                firstSegment.points[firstSegment.points.length - 1].x = point.x;\n            }\n            else {\n                firstSegment.points[firstSegment.points.length - 1].y = point.y;\n            }\n            firstSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n            secondSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n        }\n    };\n    /**\n     * @param connector\n     * @param changeTerminal\n     * @private\nRemove terinal segment in initial\n     */\n    CommandHandler.prototype.removeTerminalSegment = function (connector, changeTerminal) {\n        for (var i = 0; i < connector.segments.length - 2; i++) {\n            var segment = connector.segments[0];\n            if (segment.isTerminal) {\n                if (changeTerminal) {\n                    segment.isTerminal = false;\n                }\n                else {\n                    connector.segments.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    };\n    /**\n     * Change the connector endPoint from point to node\n     */\n    CommandHandler.prototype.changeSourceEndToNode = function (connector, target) {\n        this.removeTerminalSegment(connector);\n        var sourceWrapper = target.wrapper.children[0].corners;\n        var sourcePoint;\n        var sourcePoint2;\n        var firstSegment = connector.segments[0];\n        var nextSegment = connector.segments[1];\n        var segments = [];\n        if (firstSegment.direction === 'Right' || firstSegment.direction === 'Left') {\n            sourcePoint = (firstSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n            if (firstSegment.length > sourceWrapper.width || ((firstSegment.direction === 'Left' &&\n                sourcePoint.x >= firstSegment.points[0].x) || (firstSegment.direction === 'Right' &&\n                sourcePoint.x <= firstSegment.points[0].x))) {\n                firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = sourcePoint.y;\n                firstSegment.points[0].x = sourcePoint.x;\n                firstSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                nextSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n            }\n            else {\n                var direction = void 0;\n                if (nextSegment.direction) {\n                    direction = nextSegment.direction;\n                }\n                else {\n                    direction = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n                }\n                sourcePoint2 = (direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n                if (nextSegment.length && nextSegment.direction) {\n                    nextSegment.length =\n                        (direction === 'Top') ? firstSegment.points[firstSegment.points.length - 1].y - (sourcePoint2.y + 20) :\n                            (sourcePoint2.y + 20) - firstSegment.points[firstSegment.points.length - 1].y;\n                }\n                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].x - sourcePoint2.x;\n                firstSegment.direction = (firstSegment.length > 0) ? 'Right' : 'Left';\n                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };\n                segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(connector, 'segments', segValues, true));\n                connector.segments = segments.concat(connector.segments);\n            }\n        }\n        else {\n            sourcePoint = (firstSegment.direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n            if (firstSegment.length > sourceWrapper.height || ((firstSegment.direction === 'Top' &&\n                sourcePoint.y >= firstSegment.points[0].y) ||\n                (firstSegment.direction === 'Bottom' && sourcePoint.y <= firstSegment.points[0].y))) {\n                firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = sourcePoint.x;\n                firstSegment.points[0].y = sourcePoint.y;\n                firstSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                nextSegment.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n            }\n            else {\n                sourcePoint2 = (nextSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n                var direction = void 0;\n                if (nextSegment.direction) {\n                    direction = nextSegment.direction;\n                }\n                else {\n                    direction = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n                }\n                if (nextSegment.length && nextSegment.direction) {\n                    nextSegment.length =\n                        (direction === 'Left') ? firstSegment.points[firstSegment.points.length - 1].x - (sourcePoint2.x + 20) :\n                            (sourcePoint2.x + 20) - firstSegment.points[firstSegment.points.length - 1].x;\n                }\n                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].y - sourcePoint2.y;\n                firstSegment.direction = (firstSegment.length > 0) ? 'Bottom' : 'Top';\n                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };\n                segments.push(new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(connector, 'segments', segValues, true));\n                connector.segments = segments.concat(connector.segments);\n            }\n        }\n    };\n    //Translate the bezier points during the interaction\n    CommandHandler.prototype.translateBezierPoints = function (connector, value, tx, ty, seg, point, update) {\n        var index = (connector.segments.indexOf(seg));\n        var segment = connector.segments[parseInt(index.toString(), 10)];\n        var prevSegment = index > 0 ? connector.segments[index - 1] : null;\n        var startPoint = prevSegment !== null ? prevSegment.point : connector.sourcePoint;\n        var endPoint = index === connector.segments.length - 1 ? connector.targetPoint : segment.point;\n        if (segment) {\n            if (value === 'BezierSourceThumb' && (segment.vector1.angle || segment.vector1.distance)) {\n                var oldDistance = segment.vector1.distance;\n                var oldAngle = segment.vector1.angle;\n                segment.vector1 = {\n                    distance: connector.distance(startPoint, point),\n                    angle: _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findAngle(startPoint, point)\n                };\n                var deltaLength = segment.vector1.distance - oldDistance;\n                var deltaAngle = segment.vector1.angle - oldAngle;\n                this.translateSubsequentSegment(connector, seg, true, deltaLength, deltaAngle);\n            }\n            else if (value === 'BezierTargetThumb' && (segment.vector2.angle || segment.vector2.distance)) {\n                var oldDistance = segment.vector2.distance;\n                var oldAngle = segment.vector2.angle;\n                segment.vector2 = {\n                    distance: connector.distance(endPoint, point),\n                    angle: _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findAngle(endPoint, point)\n                };\n                var deltaLength = segment.vector2.distance - oldDistance;\n                var deltaAngle = segment.vector2.angle - oldAngle;\n                this.translateSubsequentSegment(connector, seg, false, deltaLength, deltaAngle);\n            }\n            else if ((value === 'ConnectorSourceEnd' && !connector.sourceID || value === 'ConnectorTargetEnd' && !connector.targetID)\n                && update && (0,_objects_connector__WEBPACK_IMPORTED_MODULE_0__.isEmptyVector)(segment.vector1) && (0,_objects_connector__WEBPACK_IMPORTED_MODULE_0__.isEmptyVector)(segment.vector2)) {\n                if (_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.isEmptyPoint(segment.point1)) {\n                    segment.bezierPoint1 = (0,_objects_connector__WEBPACK_IMPORTED_MODULE_0__.getBezierPoints)(connector.sourcePoint, connector.targetPoint);\n                }\n                if (_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.isEmptyPoint(segment.point2)) {\n                    segment.bezierPoint2 = (0,_objects_connector__WEBPACK_IMPORTED_MODULE_0__.getBezierPoints)(connector.targetPoint, connector.sourcePoint);\n                }\n            }\n            else if (value === 'BezierSourceThumb' || (value === 'ConnectorSourceEnd' && !update && (0,_objects_connector__WEBPACK_IMPORTED_MODULE_0__.isEmptyVector)(segment.vector1))) {\n                segment.bezierPoint1.x += tx;\n                segment.bezierPoint1.y += ty;\n                if ((!_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.isEmptyPoint(segment.point1)) || (update)) {\n                    segment.point1 = { x: segment.bezierPoint1.x, y: segment.bezierPoint1.y };\n                }\n                // 927005: Segment next to the target end of the connector always resets\n                if ((tx !== 0 || ty !== 0) && (seg.isInternalSegment === true)) {\n                    seg.isInternalSegment = false;\n                }\n            }\n            else if (value === 'BezierTargetThumb' || (value === 'ConnectorTargetEnd' && !update && (0,_objects_connector__WEBPACK_IMPORTED_MODULE_0__.isEmptyVector)(segment.vector2))) {\n                segment.bezierPoint2.x += tx;\n                segment.bezierPoint2.y += ty;\n                if ((!_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.isEmptyPoint(segment.point2)) || (update)) {\n                    segment.point2 = { x: segment.bezierPoint2.x, y: segment.bezierPoint2.y };\n                }\n                // 927005: Segment next to the target end of the connector always resets\n                if ((tx !== 0 || ty !== 0) && (seg.isInternalSegment === true)) {\n                    seg.isInternalSegment = false;\n                }\n            }\n        }\n    };\n    CommandHandler.prototype.translateSubsequentSegment = function (connector, seg, isSourceEnd, deltaLength, deltaAngle) {\n        var index = (connector.segments.indexOf(seg));\n        var segment = connector.segments[parseInt(index.toString(), 10)];\n        if (!(connector.bezierSettings.smoothness & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.BezierSmoothness.SymmetricAngle)) {\n            deltaAngle = null;\n        }\n        if (!(connector.bezierSettings.smoothness & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.BezierSmoothness.SymmetricDistance)) {\n            deltaLength = null;\n        }\n        if (deltaLength == null && deltaAngle == null) {\n            return;\n        }\n        if (isSourceEnd) {\n            if (index !== 0) {\n                this.updatePreviousBezierSegment(connector, index, deltaLength, deltaAngle);\n            }\n        }\n        else {\n            if (index !== connector.segments.length - 1) {\n                this.updateNextBezierSegment(connector, index, deltaLength, deltaAngle);\n            }\n        }\n    };\n    CommandHandler.prototype.updatePreviousBezierSegment = function (connector, index, deltaLength, deltaAngle) {\n        var segment = connector.segments[index - 1];\n        var newDistance = segment.vector2.distance + deltaLength;\n        var newAngle = (segment.vector2.angle + deltaAngle) % 360;\n        if (newAngle < 0) {\n            newAngle += 360;\n        }\n        segment.vector2 = { distance: newDistance, angle: newAngle };\n    };\n    CommandHandler.prototype.updateNextBezierSegment = function (connector, index, deltaLength, deltaAngle) {\n        var segment = connector.segments[index + 1];\n        var newDistance = segment.vector1.distance + deltaLength;\n        var newAngle = (segment.vector1.angle + deltaAngle) % 360;\n        if (newAngle < 0) {\n            newAngle += 360;\n        }\n        segment.vector1 = { distance: newDistance, angle: newAngle };\n    };\n    /**\n     * dragTargetEnd method \\\n     *\n     * @returns { void }     dragTargetEnd method .\\\n     * @param {ConnectorModel} obj - provide the obj value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the ty value.\n     * @param {boolean} preventUpdate - provide the preventUpdate value.\n     * @param {PointModel} point - provide the point value.\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {boolean} update - provide the update value.\n     * @param {OrthogonalSegmentModel | BezierSegmentModel | StraightSegmentModel} segment - provide the segment value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dragTargetEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, segment) {\n        var connector = this.diagram.nameTable[obj.id];\n        var oldChanges;\n        var boundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canDragTargetEnd)(connector) && endPoint !== 'BezierTargetThumb'\n            && boundaryConstraints && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canPageEditable)(this.diagram)) {\n            oldChanges = { targetPoint: connector.targetPoint };\n            oldChanges = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(oldChanges);\n            connector.targetPoint.x += tx;\n            connector.targetPoint.y += ty;\n            if (endPoint === 'ConnectorTargetEnd' && connector.type === 'Orthogonal' &&\n                connector.segments && connector.segments.length > 0) {\n                var prev = connector.segments[connector.segments.length - 2];\n                if (prev && connector.segments[connector.segments.length - 1].points.length === 2) {\n                    if (prev.direction === 'Left' || prev.direction === 'Right') {\n                        prev.points[prev.points.length - 1].x = connector.targetPoint.x;\n                    }\n                    else {\n                        prev.points[prev.points.length - 1].y = connector.targetPoint.y;\n                    }\n                    prev.length = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.distancePoints(prev.points[0], prev.points[prev.points.length - 1]);\n                    prev.direction = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.direction(prev.points[0], prev.points[prev.points.length - 1]);\n                }\n            }\n            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {\n                this.updatePathElementOffset(connector);\n            }\n        }\n        if (connector.type === 'Bezier') {\n            oldChanges = { targetPoint: connector.targetPoint };\n            if (segment) {\n                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, segment, point, !update);\n            }\n            else {\n                for (var i = 0; i < obj.segments.length; i++) {\n                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, obj.segments[parseInt(i.toString(), 10)], point, !update);\n                }\n            }\n        }\n        if (!preventUpdate) {\n            this.updateEndPoint(connector, oldChanges);\n        }\n        if (!(this.diagram.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.RealAction.AnimationClick)) {\n            this.diagram.refreshCanvasLayers();\n        }\n        return boundaryConstraints;\n    };\n    /**\n     * dragControlPoint method \\\n     *\n     * @returns { void }     dragControlPoint method .\\\n     * @param {ConnectorModel} obj - provide the obj value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the ty value.\n     * @param {boolean} preventUpdate - provide the preventUpdate value.\n     * @param {number} segmentNumber - provide the segmentNumber value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dragControlPoint = function (obj, tx, ty, preventUpdate, segmentNumber) {\n        var connector = this.diagram.nameTable[obj.id];\n        if ((connector.type === 'Straight' || connector.type === 'Bezier') && connector.segments.length > 0) {\n            if (segmentNumber !== undefined && connector.segments[parseInt(segmentNumber.toString(), 10)]) {\n                if (connector.type === 'Bezier') {\n                    var seg = connector.segments[parseInt(segmentNumber.toString(), 10)];\n                    var isInternalSegment = seg.isInternalSegment;\n                    if (!isInternalSegment || connector.bezierSettings === null || connector.bezierSettings.segmentEditOrientation === 'FreeForm') {\n                        seg.point.x += tx;\n                        seg.point.y += ty;\n                    }\n                    else {\n                        if (seg.orientation === 'Horizontal') {\n                            seg.point.x += tx;\n                        }\n                        else {\n                            seg.point.y += ty;\n                        }\n                        this.updateDirectionalBezierCurve(connector);\n                    }\n                    if (isInternalSegment) {\n                        connector.isBezierEditing = true;\n                    }\n                }\n                else {\n                    connector.segments[parseInt(segmentNumber.toString(), 10)].point.x += tx;\n                    connector.segments[parseInt(segmentNumber.toString(), 10)].point.y += ty;\n                }\n            }\n            else {\n                for (var i = 0; i < connector.segments.length - 1; i++) {\n                    connector.segments[parseInt(i.toString(), 10)].point.x += tx;\n                    connector.segments[parseInt(i.toString(), 10)].point.y += ty;\n                }\n            }\n            if (!preventUpdate) {\n                this.updateEndPoint(connector);\n            }\n        }\n        return true;\n    };\n    CommandHandler.prototype.updateDirectionalBezierCurve = function (connector) {\n        var pts = [];\n        pts.push(connector.sourcePoint);\n        for (var i = 0; i < connector.segments.length - 1; i++) {\n            var seg = connector.segments[parseInt(i.toString(), 10)];\n            if (seg.orientation === 'Horizontal') {\n                pts.push({ x: seg.point.x, y: pts[pts.length - 1].y });\n            }\n            else {\n                pts.push({ x: pts[pts.length - 1].x, y: seg.point.y });\n            }\n            if (i === connector.segments.length - 2) {\n                if (seg.orientation === 'Horizontal') {\n                    pts.push({ x: seg.point.x, y: connector.targetPoint.y });\n                }\n                else {\n                    pts.push({ x: connector.targetPoint.x, y: seg.point.y });\n                }\n            }\n        }\n        pts.push(connector.targetPoint);\n        var start = pts[0];\n        var end = pts[pts.length - 1];\n        if (connector.segments.length > 1) {\n            var mid1 = pts[1];\n            var mid2 = pts[2];\n            var center1 = { x: (mid1.x + mid2.x) * 0.5, y: (mid1.y + mid2.y) * 0.5 };\n            var segment1 = connector.segments[0];\n            segment1.vector1.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(start, mid1);\n            segment1.vector1.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(start, mid1) * 0.5;\n            segment1.vector2.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(center1, mid1);\n            segment1.vector2.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(center1, mid1) * 0.5;\n            segment1.point = center1;\n            var segment2 = connector.segments[1];\n            segment2.vector1.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(center1, mid2);\n            segment2.vector1.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(center1, mid2) * 0.5;\n            if (connector.segments.length > 2) {\n                var mid3 = pts[3];\n                var center2 = { x: (mid2.x + mid3.x) * 0.5, y: (mid2.y + mid3.y) * 0.5 };\n                segment2.vector2.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(center2, mid2);\n                segment2.vector2.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(center2, mid2) * 0.5;\n                segment2.point = center2;\n                var segment3 = connector.segments[2];\n                segment3.vector1.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(center2, mid3);\n                segment3.vector1.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(center2, mid3) * 0.5;\n                if (connector.segments.length > 3) {\n                    var mid4 = pts[4];\n                    var center3 = { x: (mid3.x + mid4.x) * 0.5, y: (mid3.y + mid4.y) * 0.5 };\n                    segment3.vector2.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(center3, mid3);\n                    segment3.vector2.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(center3, mid3) * 0.5;\n                    segment3.point = center3;\n                    var segment4 = connector.segments[3];\n                    segment4.vector1.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(center3, mid4);\n                    segment4.vector1.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(center3, mid4) * 0.5;\n                    segment4.vector2.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(end, mid4);\n                    segment4.vector2.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(end, mid4) * 0.5;\n                }\n                else {\n                    segment3.vector2.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(end, mid3);\n                    segment3.vector2.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(end, mid3) * 0.5;\n                }\n            }\n            else {\n                segment2.vector2.angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)(end, mid2);\n                segment2.vector2.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(end, mid2) * 0.5;\n            }\n        }\n    };\n    // /**\n    //  * rotatePropertyChnage method \\\n    //  *\n    //  * @returns { void }     rotatePropertyChnage method .\\\n    //  * @param {number} angle - provide the obj value.\n    //  *\n    //  * @private\n    //  */\n    // public rotatePropertyChnage(angle: number): void {\n    //     const selectedItems: SelectorModel = this.diagram.selectedItems;\n    //     let objects: (NodeModel | ConnectorModel)[] = [];\n    //     objects = objects.concat(selectedItems.nodes);\n    //     objects = objects.concat(selectedItems.connectors);\n    //     const pivotValue: PointModel = { x: selectedItems.offsetX, y: selectedItems.offsetY };\n    //     this.rotateObjects(selectedItems, objects, angle - selectedItems.rotateAngle, pivotValue);\n    //     selectedItems.wrapper.rotateAngle = selectedItems.rotateAngle = angle;\n    //     this.diagram.updateSelector();\n    // }\n    /**\n     * rotateObjects method \\\n     *\n     * @returns { void }     rotateObjects method .\\\n     * @param {NodeModel | SelectorModel} parent - provide the parent value.\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the objects value.\n     * @param {number} angle - provide the angle value.\n     * @param {PointModel} pivot - provide the pivot value.\n     * @param {boolean} includeParent - provide the includeParent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotateObjects = function (parent, objects, angle, pivot, includeParent) {\n        pivot = pivot || {};\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, angle, pivot.x, pivot.y);\n        var oldValues;\n        for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {\n            var obj = objects_2[_i];\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canRotate)(obj) && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canPageEditable)(this.diagram)) {\n                    if (includeParent !== false || parent !== obj) {\n                        //918299 - Flip and rotation of the group node now work properly by calculating the wrapper offset instead of the individual offset\n                        oldValues = { offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY, rotateAngle: obj.rotateAngle };\n                        //909137 - Undo Operation Improper After Rotating Node Counterclockwise. Remove the below line and add the angle to same line.\n                        obj.rotateAngle = ((obj.rotateAngle + angle) + 360) % 360;\n                        var newOffset = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY });\n                        obj.offsetX = newOffset.x;\n                        obj.offsetY = newOffset.y;\n                        //909355: When rotating a node, the old value in the property change event argument is undefined. pass the old valuse as parameter\n                        this.diagram.nodePropertyChange(obj, oldValues, { offsetX: obj.offsetX, offsetY: obj.offsetY, rotateAngle: obj.rotateAngle });\n                    }\n                    if (obj.processId) {\n                        var parent_3 = this.diagram.nameTable[obj.processId];\n                        var bound = this.diagram.bpmnModule.getChildrenBound(parent_3, obj.id, this.diagram);\n                        this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n                    }\n                    if (obj.children && obj.children.length && !obj.container) {\n                        this.getChildren(obj, objects);\n                    }\n                }\n            }\n            else {\n                this.rotatePoints(obj, angle, pivot || { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY });\n            }\n            this.diagram.updateDiagramObject(obj);\n        }\n        this.diagram.refreshCanvasLayers();\n        this.diagram.updateSelector();\n    };\n    /**\n     * snapConnectorEnd method \\\n     *\n     * @returns { PointModel }     snapConnectorEnd method .\\\n     * @param {PointModel} currentPosition - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.snapConnectorEnd = function (currentPosition) {\n        if ((this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.SnapConstraints.SnapToLines)\n            && this.snappingModule) {\n            this.diagram.snappingModule.snapConnectorEnd(currentPosition);\n        }\n        return currentPosition;\n    };\n    /**\n     * snapAngle method \\\n     *\n     * @returns { number }     snapAngle method .\\\n     * @param {number} angle - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.snapAngle = function (angle) {\n        if ((this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.SnapConstraints.SnapToLines)\n            && this.snappingModule) {\n            return this.snappingModule.snapAngle(this.diagram, angle);\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * rotatePoints method \\\n     *\n     * @returns { number }     rotatePoints method .\\\n     * @param {Connector} conn - provide the parent value.\n     * @param {number} angle - provide the parent value.\n     * @param {PointModel} pivot - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotatePoints = function (conn, angle, pivot) {\n        if (!conn.sourceWrapper || !conn.targetWrapper) {\n            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, angle, pivot.x, pivot.y);\n            conn.sourcePoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, conn.sourcePoint);\n            conn.targetPoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, conn.targetPoint);\n            if (conn.shape.type === 'Bpmn' && conn.shape.sequence === 'Default' && conn.shape.flow === 'Sequence') {\n                this.updatePathElementOffset(conn);\n            }\n            var newProp = { sourcePoint: conn.sourcePoint, targetPoint: conn.targetPoint };\n            this.diagram.connectorPropertyChange(conn, {}, newProp);\n            if (conn.segments && conn.segments.length > 0) {\n                this.diagram.protectPropertyChange(true);\n                var connector = conn;\n                connector.segments = [];\n                this.diagram.connectorPropertyChange(connector, {}, { segments: connector.segments });\n                this.diagram.protectPropertyChange(false);\n            }\n        }\n    };\n    CommandHandler.prototype.updateInnerParentProperties = function (tempNode) {\n        var elements = [];\n        var protect = 'isProtectedOnChange';\n        var protectChange = this.diagram[\"\" + protect];\n        this.diagram.protectPropertyChange(true);\n        var innerParents = this.getAllDescendants(tempNode, elements, false, true);\n        for (var i = 0; i < innerParents.length; i++) {\n            var obj = this.diagram.nameTable[innerParents[parseInt(i.toString(), 10)].id];\n            obj.offsetX = obj.wrapper.offsetX;\n            obj.offsetY = obj.wrapper.offsetY;\n            obj.width = obj.wrapper.width;\n            obj.height = obj.wrapper.height;\n        }\n        this.diagram.protectPropertyChange(protectChange);\n    };\n    /**\n     * scale method \\\n     *\n     * @returns { boolean }     scale method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the parent value.\n     * @param {number} sw - provide the parent value.\n     * @param {number} sh - provide the parent value.\n     * @param {number} pivot - provide the parent value.\n     * @param {number} refObject - provide the parent value.\n     * @param {boolean} isOutsideBoundary - provide the parent value.\n     *\n     * @private\n     */\n    // eslint-disable-next-line max-len\n    CommandHandler.prototype.scale = function (obj, sw, sh, pivot, refObject, isOutsideBoundary) {\n        var node = this.diagram.nameTable[obj.id];\n        var tempNode = node;\n        var elements = [];\n        var element = node.wrapper;\n        if (!refObject) {\n            refObject = obj;\n        }\n        var refWrapper = refObject.wrapper;\n        var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;\n        var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;\n        var refPoint = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getPoint)(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);\n        if (element.actualSize.width !== undefined && element.actualSize.height !== undefined && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canPageEditable)(this.diagram)) {\n            if (tempNode.children && !(tempNode.container)) {\n                var nodes = this.getAllDescendants(tempNode, elements);\n                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                    var temp = nodes_1[_i];\n                    this.scaleObject(sw, sh, refPoint, temp, element, refObject);\n                }\n                obj.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_14__.Size());\n                obj.wrapper.arrange(obj.wrapper.desiredSize);\n                this.diagram.updateGroupOffset(node);\n                this.updateInnerParentProperties(tempNode);\n            }\n            else {\n                this.scaleObject(sw, sh, refPoint, node, element, refObject);\n            }\n            var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(obj.wrapper);\n            var checkBoundaryConstraints = this.checkBoundaryConstraints(undefined, undefined, bounds);\n            if (!checkBoundaryConstraints && isOutsideBoundary) {\n                this.scale(obj, 1 / sw, 1 / sh, pivot, undefined, true);\n                return false;\n            }\n            this.diagram.updateDiagramObject(obj);\n        }\n        return true;\n    };\n    /** @private */\n    CommandHandler.prototype.getAllDescendants = function (node, nodes, includeParent, innerParent) {\n        var temp = node;\n        var parentNodes = [];\n        for (var i = 0; i < temp.children.length; i++) {\n            node = (this.diagram.nameTable[temp.children[parseInt(i.toString(), 10)]]);\n            if (node) {\n                if (!node.children) {\n                    nodes.push(node);\n                }\n                else {\n                    if (includeParent) {\n                        nodes.push(node);\n                    }\n                    if (innerParent) {\n                        parentNodes.push(node);\n                    }\n                    nodes = this.getAllDescendants(node, nodes);\n                }\n            }\n        }\n        return (innerParent) ? parentNodes : nodes;\n    };\n    /**\n     * getChildren method \\\n     *\n     * @returns { (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[] }     getChildren method .\\\n     * @param {NodeModel} node - provide the sw value.\n     * @param {(NodeModel | ConnectorModel)[]} nodes - provide the sw value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.getChildren = function (node, nodes) {\n        var temp = node;\n        if (node.children && node.children.length) {\n            for (var i = 0; i < temp.children.length; i++) {\n                node = (this.diagram.nameTable[temp.children[parseInt(i.toString(), 10)]]);\n                if (node) {\n                    nodes.push(node);\n                }\n            }\n        }\n        return nodes;\n    };\n    /**\n     * scaleObject method \\\n     *\n     * @returns { NodeModel }     scaleObject method .\\\n     * @param {string} id - provide the sw value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.cloneChild = function (id) {\n        var node = this.diagram.nameTable[\"\" + id];\n        return node;\n    };\n    /**\n     * scaleObject method \\\n     *\n     * @returns { void }     scaleObject method .\\\n     * @param {End} sw - provide the sw value.\n     * @param {End} sh - provide the sh value.\n     * @param {PointModel} pivot - provide the pivot value.\n     * @param {IElement} obj - provide the pivot value.\n     * @param {DiagramElement} element - provide the element value.\n     * @param {IElement} refObject - provide the refObject value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.scaleObject = function (sw, sh, pivot, obj, element, refObject, canUpdate) {\n        sw = sw < 0 ? 1 : sw;\n        sh = sh < 0 ? 1 : sh;\n        var oldValues = {};\n        if (sw !== 1 || sh !== 1) {\n            var width = void 0;\n            var height = void 0;\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                var node = obj;\n                var isResize = void 0;\n                var bound = void 0;\n                oldValues = {\n                    width: obj.wrapper.actualSize.width, height: obj.wrapper.actualSize.height,\n                    offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY,\n                    margin: { top: node.margin.top, left: node.margin.left }\n                };\n                if (node.shape.type === 'Bpmn' && node.shape.activity.subProcess.processes\n                    && node.shape.activity.subProcess.processes.length > 0) {\n                    bound = this.diagram.bpmnModule.getChildrenBound(node, node.id, this.diagram);\n                    isResize = node.wrapper.bounds.containsRect(bound);\n                }\n                width = node.wrapper.actualSize.width * sw;\n                height = node.wrapper.actualSize.height * sh;\n                var hasAspectRatio = (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.NodeConstraints.AspectRatio) === _enum_enum__WEBPACK_IMPORTED_MODULE_10__.NodeConstraints.AspectRatio;\n                var hasMinWidth = node.minWidth !== undefined && node.minWidth !== 0;\n                var hasMaxWidth = node.maxWidth !== undefined && node.maxWidth !== 0;\n                var hasMinHeight = node.minHeight !== undefined && node.minHeight !== 0;\n                var hasMaxHeight = node.maxHeight !== undefined && node.maxHeight !== 0;\n                if (hasAspectRatio) {\n                    var actualSize = node.wrapper.actualSize;\n                    if (hasMinWidth && hasMinHeight) {\n                        if ((height / node.minHeight) < (width / node.minWidth)) {\n                            if (height < node.minHeight) {\n                                height = node.minHeight;\n                                width = node.minHeight * (actualSize.width / actualSize.height);\n                            }\n                        }\n                        else {\n                            if (width < node.minWidth) {\n                                width = node.minWidth;\n                                height = node.minWidth * (actualSize.height / actualSize.width);\n                            }\n                        }\n                    }\n                    else if (hasMinWidth) {\n                        if (width < node.minWidth) {\n                            width = node.minWidth;\n                            height = node.minWidth * (actualSize.height / actualSize.width);\n                        }\n                    }\n                    else if (hasMinHeight) {\n                        if (height < node.minHeight) {\n                            height = node.minHeight;\n                            width = node.minHeight * (actualSize.width / actualSize.height);\n                        }\n                    }\n                    if (hasMaxWidth && hasMaxHeight) {\n                        if ((height / node.maxHeight) > (width / node.maxWidth)) {\n                            if (height > node.maxHeight) {\n                                height = node.maxHeight;\n                                width = node.maxHeight * (actualSize.width / actualSize.height);\n                            }\n                        }\n                        else {\n                            if (width > node.maxWidth) {\n                                width = node.maxWidth;\n                                height = node.maxWidth * (actualSize.height / actualSize.width);\n                            }\n                        }\n                    }\n                    else if (hasMaxWidth) {\n                        if (width > node.maxWidth) {\n                            width = node.maxWidth;\n                            height = node.maxWidth * (actualSize.height / actualSize.width);\n                        }\n                    }\n                    else if (hasMaxHeight) {\n                        if (height > node.maxHeight) {\n                            height = node.maxHeight;\n                            width = node.maxHeight * (actualSize.width / actualSize.height);\n                        }\n                    }\n                }\n                else {\n                    if (hasMaxWidth) {\n                        width = Math.min(node.maxWidth, width);\n                    }\n                    if (hasMinWidth) {\n                        width = Math.max(node.minWidth, width);\n                    }\n                    if (hasMinHeight) {\n                        height = Math.max(node.minHeight, height);\n                    }\n                    if (hasMaxHeight) {\n                        height = Math.min(node.maxHeight, height);\n                    }\n                }\n                if (isResize) {\n                    width = Math.max(width, (bound.right - node.wrapper.bounds.x));\n                    height = Math.max(height, (bound.bottom - node.wrapper.bounds.y));\n                }\n                sw = width / node.actualSize.width;\n                sh = height / node.actualSize.height;\n            }\n            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)(); // let refWrapper: DiagramElement;\n            if (!refObject) {\n                refObject = obj;\n            }\n            var refWrapper = refObject.wrapper;\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, -refWrapper.rotateAngle, pivot.x, pivot.y);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.scaleMatrix)(matrix, sw, sh, pivot.x, pivot.y);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, refWrapper.rotateAngle, pivot.x, pivot.y);\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                var node = obj; //let left: number; let top: number;\n                var newPosition = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, { x: node.wrapper.offsetX, y: node.wrapper.offsetY });\n                var oldleft = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n                var oldtop = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n                if (width > 0) {\n                    if (node.processId) {\n                        var parent_4 = this.diagram.nameTable[node.processId];\n                        if (!parent_4.maxWidth || ((node.margin.left + width) < parent_4.maxWidth)) {\n                            node.width = width;\n                            node.offsetX = newPosition.x;\n                        }\n                    }\n                    else {\n                        node.width = width;\n                        node.offsetX = newPosition.x;\n                    }\n                }\n                if (height > 0) {\n                    if (node.processId) {\n                        var parent_5 = this.diagram.nameTable[node.processId];\n                        if (!parent_5.maxHeight || ((node.margin.top + height) < parent_5.maxHeight)) {\n                            node.height = height;\n                            node.offsetY = newPosition.y;\n                        }\n                    }\n                    else {\n                        node.height = height;\n                        node.offsetY = newPosition.y;\n                    }\n                }\n                var left = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n                var top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n                var parent_6 = this.diagram.nameTable[node.processId];\n                // 931096: In subprocess, BPMN shape nodes positions changed after undo and redo\n                if (parent_6) {\n                    left = node.offsetX - node.width * node.pivot.x;\n                    top_1 = node.offsetY - node.height * node.pivot.y;\n                }\n                if (parent_6 && ((node.margin.top + (top_1 - oldtop)) <= 0 ||\n                    (node.margin.left + (left - oldleft) <= 0))) {\n                    if (this.diagram.eventHandler.currentAction !== 'Drag') {\n                        this.diagram.nodePropertyChange(obj, {}, {\n                            margin: { top: node.margin.top, left: node.margin.left }\n                        });\n                    }\n                    else {\n                        this.diagram.nodePropertyChange(obj, {}, {\n                            width: node.width, height: node.height, margin: { top: node.margin.top, left: node.margin.left }\n                        });\n                    }\n                }\n                else {\n                    if ((0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, obj, true)) {\n                        (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkChildNodeInContainer)(this.diagram, obj);\n                    }\n                    else {\n                        if (!canUpdate) {\n                            this.diagram.nodePropertyChange(obj, oldValues, {\n                                width: node.width, height: node.height, offsetX: node.offsetX, offsetY: node.offsetY,\n                                margin: { top: node.margin.top + (top_1 - oldtop), left: node.margin.left + (left - oldleft) }\n                            });\n                        }\n                    }\n                }\n            }\n            else {\n                var connector = obj;\n                var oldValues_1 = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                if (!connector.sourceWrapper || !connector.targetWrapper) {\n                    this.scaleConnector(connector, matrix, oldValues_1, sw, sh, pivot);\n                }\n            }\n            var parentNode = this.diagram.nameTable[obj.processId];\n            if (parentNode) {\n                var parent_7 = parentNode.wrapper.bounds;\n                var child = obj.wrapper.bounds;\n                var bound = this.diagram.bpmnModule.getChildrenBound(parentNode, obj.id, this.diagram);\n                this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n            }\n        }\n    };\n    CommandHandler.prototype.scaleConnector = function (connector, matrix, oldValues, sw, sh, pivot) {\n        connector.sourcePoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, connector.sourcePoint);\n        connector.targetPoint = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, connector.targetPoint);\n        if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {\n            this.updatePathElementOffset(connector);\n        }\n        var newProp = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n        this.diagram.connectorPropertyChange(connector, oldValues, newProp);\n        var selector = this.diagram.selectedItems;\n        if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.selectionHasConnector)(this.diagram, selector)) {\n            var clonedSelectedItems = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n            var nodeModel = {\n                offsetX: clonedSelectedItems.offsetX, offsetY: clonedSelectedItems.offsetY,\n                height: clonedSelectedItems.height, width: clonedSelectedItems.width,\n                rotateAngle: clonedSelectedItems.rotateAngle\n            };\n            var obj = new _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node(this.diagram, 'nodes', nodeModel, true);\n            obj.wrapper = clonedSelectedItems.wrapper;\n            obj.wrapper.rotateAngle = selector.rotateAngle;\n            this.scaleObject(sw, sh, pivot, obj, obj.wrapper, obj, true);\n            selector.wrapper.actualSize.width = obj.width;\n            selector.wrapper.actualSize.height = obj.height;\n            selector.wrapper.offsetX = obj.offsetX;\n            selector.wrapper.offsetY = obj.offsetY;\n            var child = this.diagram.selectedItems.connectors[0];\n            if (child.id !== connector.id) {\n                this.measureSelector(selector);\n            }\n        }\n    };\n    CommandHandler.prototype.measureSelector = function (selector) {\n        var desiredBounds = undefined;\n        //Measuring the children\n        var clonedSelectedItems = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.selectedItems);\n        var objects = [];\n        var bounds;\n        objects = clonedSelectedItems.connectors;\n        var pivot = { x: this.diagram.selectedItems.offsetX, y: this.diagram.selectedItems.offsetY };\n        for (var i = 0; i < objects.length; i++) {\n            var matrix_1 = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix_1, -selector.rotateAngle, pivot.x, pivot.y);\n            objects[parseInt(i.toString(), 10)].sourcePoint\n                = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix_1, objects[parseInt(i.toString(), 10)].sourcePoint);\n            objects[parseInt(i.toString(), 10)].targetPoint\n                = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix_1, objects[parseInt(i.toString(), 10)].targetPoint);\n            var p1 = {\n                x: objects[parseInt(i.toString(), 10)].sourcePoint.x,\n                y: objects[parseInt(i.toString(), 10)].sourcePoint.y\n            };\n            var p2 = {\n                x: objects[parseInt(i.toString(), 10)].targetPoint.x,\n                y: objects[parseInt(i.toString(), 10)].targetPoint.y\n            };\n            bounds = (this.calculateBounds(p1, p2));\n            if (desiredBounds === undefined) {\n                desiredBounds = bounds;\n            }\n            else {\n                desiredBounds.uniteRect(bounds);\n            }\n        }\n        var offsetPt = {};\n        if (desiredBounds !== undefined) {\n            offsetPt = {\n                x: desiredBounds.x + desiredBounds.width * selector.wrapper.pivot.x,\n                y: desiredBounds.y + desiredBounds.height * selector.wrapper.pivot.y\n            };\n        }\n        var nodeModel = {\n            offsetX: offsetPt.x, offsetY: offsetPt.y,\n            height: desiredBounds.height, width: desiredBounds.width, rotateAngle: 0\n        };\n        var obj = new _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node(this.diagram, 'nodes', nodeModel, true);\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n        (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, selector.rotateAngle, pivot.x, pivot.y);\n        obj.rotateAngle += selector.rotateAngle;\n        obj.rotateAngle = (obj.rotateAngle + 360) % 360;\n        var newOffset = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, { x: obj.offsetX, y: obj.offsetY });\n        obj.offsetX = newOffset.x;\n        obj.offsetY = newOffset.y;\n        selector.wrapper.actualSize.width = desiredBounds.width;\n        selector.wrapper.actualSize.height = desiredBounds.height;\n        selector.wrapper.offsetX = obj.offsetX;\n        selector.wrapper.offsetY = obj.offsetY;\n        var selectorEle = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getSelectorElement)(this.diagram.element.id);\n        // EJ2-69511 - Added handleSize parameter to avoid exception when we perform multiselect of connectors, rotate and resize it.\n        this.diagram.diagramRenderer.renderResizeHandle(selector.wrapper, selectorEle, selector.thumbsConstraints, this.diagram.scroller.currentZoom, selector.constraints, this.diagram.scroller.transform, false, (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canMove)(selector), null, null, selector.handleSize);\n    };\n    CommandHandler.prototype.calculateBounds = function (p1, p2) {\n        var left = Math.min(p1.x, p2.x);\n        var right = Math.max(p1.x, p2.x);\n        var top = Math.min(p1.y, p2.y);\n        var bottom = Math.max(p1.y, p2.y);\n        var width = right - left;\n        var height = bottom - top;\n        var rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_4__.Rect(left, top, width, height);\n        return rect;\n    };\n    /**\n     * portDrag method \\\n     *\n     * @returns { void }     portDrag method .\\\n     * @param { NodeModel | ConnectorModel} obj - provide the obj value.\n     * @param {DiagramElement} portElement - provide the portElement value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the tx value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.portDrag = function (obj, portElement, tx, ty) {\n        var oldValues;\n        var changedvalues;\n        var port = this.findTarget(portElement, obj);\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(obj.wrapper);\n        if (port && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canDrag)(port, this.diagram)) {\n            // Feature 826644: Support to add ports to the connector. Added below condition to check connector port.\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n                oldValues = this.getPortChanges(obj, port);\n                port.offset.x += (tx / bounds.width);\n                port.offset.y += (ty / bounds.height);\n                changedvalues = this.getPortChanges(obj, port);\n                this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n            }\n            else {\n                oldValues = this.getConnectorPortChanges(obj, port);\n                this.updatePortOffset(obj, port, tx, ty);\n                port.alignment = 'Center';\n                changedvalues = this.getConnectorPortChanges(obj, port);\n                this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);\n            }\n            this.diagram.updateDiagramObject(obj);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.labelDrag = function (obj, textElement, tx, ty) {\n        //let changedvalues: Object;\n        //let label: ShapeAnnotationModel | PathAnnotationModel;\n        // eslint-disable-next-line max-len\n        var label = this.findTarget(textElement, obj);\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cornersPointsBeforeRotation)(obj.wrapper);\n        var oldValues = this.getAnnotationChanges(obj, label);\n        var oldValue = this.getSelectedObject();\n        if (label instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_18__.ShapeAnnotation) {\n            label.offset.x += (tx / bounds.width);\n            label.offset.y += (ty / bounds.height);\n        }\n        else {\n            this.updatePathAnnotationOffset(obj, label, tx, ty);\n            if (label instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_18__.PathAnnotation) {\n                label.alignment = 'Center';\n            }\n        }\n        var changedvalues = this.getAnnotationChanges(obj, label);\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(obj);\n        if (!(0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(this.diagram, label, false, textElement)) {\n            this.labelSelect(obj, textElement, oldValue);\n        }\n        //909175: Label interaction not reflected properly in overview\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            // eslint-disable-next-line security/detect-object-injection\n            var view = this.diagram.views[temp];\n            if (!(view instanceof _diagram_diagram__WEBPACK_IMPORTED_MODULE_5__.Diagram)) {\n                this.diagram.refreshCanvasDiagramLayer(view);\n            }\n        }\n    };\n    CommandHandler.prototype.updatePathAnnotationOffset = function (object, label, tx, ty, newPosition, size) {\n        var textWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n        var offsetX = textWrapper.offsetX;\n        var offsetY = textWrapper.offsetY;\n        var offset;\n        var intermediatePoints = object.intermediatePoints;\n        var prev;\n        var pointLength = 0;\n        var totalLength = 0;\n        var intersectingOffset;\n        var currentPosition;\n        switch (label.verticalAlignment) {\n            case 'Center':\n                if (label.horizontalAlignment === 'Center') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + ty };\n                }\n                else if (label.horizontalAlignment === 'Right') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };\n                }\n                else if (label.horizontalAlignment === 'Left') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };\n                }\n                break;\n            case 'Top':\n                if (label.horizontalAlignment === 'Center') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (label.horizontalAlignment === 'Right') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (label.horizontalAlignment === 'Left') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };\n                }\n                break;\n            case 'Bottom':\n                if (label.horizontalAlignment === 'Center') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (label.horizontalAlignment === 'Right') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (label.horizontalAlignment === 'Left') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };\n                }\n                break;\n        }\n        var intersetingPts = this.getInterceptWithSegment(currentPosition, intermediatePoints);\n        var newOffset = intermediatePoints[intermediatePoints.length - 1];\n        totalLength = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.getLengthFromListOfPoints(intermediatePoints);\n        if (intersetingPts.length > 0) {\n            label.dragLimit = label.dragLimit ? label.dragLimit : {};\n            if (label.dragLimit.top || label.dragLimit.bottom || label.dragLimit.left || label.dragLimit.right) {\n                var minDistance = { minDistance: null };\n                newOffset = this.getRelativeOffset(currentPosition, intermediatePoints, minDistance);\n                var distance = { minDistance: null };\n                intersectingOffset = this.getRelativeOffset(currentPosition, intersetingPts, distance);\n                if (minDistance != null && distance.minDistance < minDistance.minDistance) {\n                    newOffset = intersectingOffset;\n                }\n                else {\n                    var connectorOffset = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getOffsetOfConnector)(object.intermediatePoints, label);\n                    newOffset = connectorOffset.point;\n                }\n            }\n            else {\n                intersectingOffset = intersetingPts[intersetingPts.length - 1];\n                newOffset = intersectingOffset;\n            }\n            if (newOffset) {\n                var p = void 0;\n                var bounds = void 0;\n                for (p = 0; p < intermediatePoints.length; p++) {\n                    if (prev != null) {\n                        bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_4__.Rect.toBounds([prev, intermediatePoints[parseInt(p.toString(), 10)]]);\n                        if (bounds.containsPoint(newOffset)) {\n                            pointLength += _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(prev, newOffset);\n                            break;\n                        }\n                        else {\n                            pointLength += _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(prev, intermediatePoints[parseInt(p.toString(), 10)]);\n                        }\n                    }\n                    prev = intermediatePoints[parseInt(p.toString(), 10)];\n                }\n                offset = { x: pointLength / totalLength, y: 0 };\n            }\n            this.updateLabelMargin(object, label, offset, currentPosition, size, tx, ty);\n        }\n        else {\n            this.updateLabelMargin(object, label, null, currentPosition, size, tx, ty);\n        }\n    };\n    // Feature 826644: Support to add ports to the connector.\n    // Added below method to update the port offset when we drag the port.\n    CommandHandler.prototype.updatePortOffset = function (object, port, tx, ty, newPosition, size) {\n        var textWrapper = this.diagram.getWrapper(object.wrapper, port.id);\n        var offsetX = textWrapper.offsetX;\n        var offsetY = textWrapper.offsetY;\n        var offset;\n        var intermediatePoints = object.intermediatePoints;\n        var prev;\n        var pointLength = 0;\n        var totalLength = 0;\n        var intersectingOffset;\n        var currentPosition;\n        switch (port.verticalAlignment) {\n            case 'Center':\n                if (port.horizontalAlignment === 'Center') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + ty };\n                }\n                else if (port.horizontalAlignment === 'Right') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };\n                }\n                else if (port.horizontalAlignment === 'Left') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + ty };\n                }\n                break;\n            case 'Top':\n                if (port.horizontalAlignment === 'Center') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (port.horizontalAlignment === 'Right') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (port.horizontalAlignment === 'Left') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY - (textWrapper.actualSize.height) / 2 + ty };\n                }\n                break;\n            case 'Bottom':\n                if (port.horizontalAlignment === 'Center') {\n                    currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (port.horizontalAlignment === 'Right') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX + (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };\n                }\n                else if (port.horizontalAlignment === 'Left') {\n                    currentPosition = (newPosition) ? newPosition :\n                        { x: offsetX - (textWrapper.actualSize.width) / 2 + tx, y: offsetY + (textWrapper.actualSize.height) / 2 + ty };\n                }\n                break;\n        }\n        var intersectingPoints = this.getInterceptWithSegment(currentPosition, intermediatePoints);\n        var newOffset = intermediatePoints[intermediatePoints.length - 1];\n        totalLength = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.getLengthFromListOfPoints(intermediatePoints);\n        if (intersectingPoints.length > 0) {\n            intersectingOffset = intersectingPoints[intersectingPoints.length - 1];\n            newOffset = intersectingOffset;\n            if (newOffset) {\n                var p = void 0;\n                var bounds = void 0;\n                for (p = 0; p < intermediatePoints.length; p++) {\n                    if (prev != null) {\n                        bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_4__.Rect.toBounds([prev, intermediatePoints[parseInt(p.toString(), 10)]]);\n                        if (bounds.containsPoint(newOffset)) {\n                            pointLength += _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(prev, newOffset);\n                            break;\n                        }\n                        else {\n                            pointLength += _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(prev, intermediatePoints[parseInt(p.toString(), 10)]);\n                        }\n                    }\n                    prev = intermediatePoints[parseInt(p.toString(), 10)];\n                }\n                offset = { x: pointLength / totalLength, y: 0 };\n            }\n            this.updateLabelMargin(object, port, offset, currentPosition, size, tx, ty);\n        }\n        else {\n            this.updateLabelMargin(object, port, null, currentPosition, size, tx, ty);\n        }\n    };\n    CommandHandler.prototype.getRelativeOffset = function (currentPosition, points, minDistance) {\n        var newOffset;\n        var distance;\n        var pt;\n        var i;\n        for (i = 0; i < points.length; i++) {\n            pt = points[parseInt(i.toString(), 10)];\n            distance = Math.round(Math.sqrt(Math.pow((currentPosition.x - pt.x), 2) +\n                Math.pow((currentPosition.y - pt.y), 2)));\n            if (minDistance.minDistance === null ||\n                Math.min(Math.abs(minDistance.minDistance), Math.abs(distance)) === Math.abs(distance)) {\n                newOffset = pt;\n                minDistance.minDistance = distance;\n            }\n        }\n        return newOffset;\n    };\n    CommandHandler.prototype.dragLimitValue = function (label, point, tempPt, contentDimension) {\n        var x = false;\n        var y = false;\n        if ((tempPt.x >= (point.x - label.dragLimit.left - (contentDimension.width / 2))) &&\n            (tempPt.x <= point.x + label.dragLimit.right + (contentDimension.width / 2))) {\n            x = true;\n        }\n        if ((tempPt.y >= (point.y - label.dragLimit.top - (contentDimension.height / 2))) &&\n            (tempPt.y <= point.y + label.dragLimit.bottom + (contentDimension.height / 2))) {\n            y = true;\n        }\n        return { x: x, y: y };\n    };\n    /* eslint-disable */\n    CommandHandler.prototype.updateLabelMargin = function (node, label, offset, tempPt, size, tx, ty) {\n        offset = offset ? offset : { x: label.offset, y: 0 };\n        if (label && offset && offset.x > 0 && offset.x < 1) {\n            //let point: PointModel;\n            var length_2 = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.getLengthFromListOfPoints(node.intermediatePoints);\n            var point = this.getPointAtLength(length_2 * offset.x, node.intermediatePoints, 0);\n            var curZoomfactor = this.diagram.scrollSettings.currentZoom;\n            var dragLimit = label.dragLimit ? label.dragLimit : { left: 0, right: 0, top: 0, bottom: 0 };\n            if (dragLimit.top || dragLimit.bottom || dragLimit.left || dragLimit.right) {\n                var labelBounds = this.diagram.getWrapper(node.wrapper, label.id);\n                var contentDimension = new _primitives_rect__WEBPACK_IMPORTED_MODULE_4__.Rect(0, 0, 0, 0);\n                var annotationWrtapper = this.diagram.getWrapper(node.wrapper, label.id);\n                contentDimension.x = ((annotationWrtapper).offsetX / curZoomfactor) + tx;\n                contentDimension.y = (annotationWrtapper.offsetY / curZoomfactor) + ty;\n                contentDimension.width = annotationWrtapper.bounds.width / curZoomfactor;\n                contentDimension.height = annotationWrtapper.bounds.height / curZoomfactor;\n                var draggableBounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_4__.Rect(point.x - (dragLimit.left || 0) - contentDimension.width / 2, point.y - (dragLimit.top || 0) - contentDimension.height / 2, (dragLimit.left || 0) + (dragLimit.right || 0) + contentDimension.width, (dragLimit.top || 0) + (dragLimit.bottom || 0) + contentDimension.height);\n                if (draggableBounds.containsPoint(tempPt)) {\n                    tempPt = tempPt;\n                }\n                else {\n                    var lineIntersects = void 0;\n                    var line1 = [point, tempPt];\n                    lineIntersects = this.boundsInterSects(line1, draggableBounds, false);\n                    for (var _i = 0, lineIntersects_1 = lineIntersects; _i < lineIntersects_1.length; _i++) {\n                        var i = lineIntersects_1[_i];\n                        var ptt = i;\n                        tempPt = ptt;\n                    }\n                }\n                var cursorLimit = this.dragLimitValue(label, point, tempPt, contentDimension);\n                label.margin = {\n                    left: cursorLimit.x ? tempPt.x - point.x : label.margin.left,\n                    top: cursorLimit.y ? tempPt.y - point.y : label.margin.top, right: 0, bottom: 0\n                };\n            }\n            else {\n                label.margin = { left: tempPt.x - point.x, top: tempPt.y - point.y, right: 0, bottom: 0 };\n            }\n            label.offset = offset.x;\n            if (size) {\n                label.width = size.width;\n                label.height = size.height;\n            }\n        }\n    };\n    CommandHandler.prototype.boundsInterSects = function (polyLine, bounds, self) {\n        var intersects;\n        if (bounds) {\n            var polyLine2 = [\n                { x: bounds.x, y: bounds.y },\n                { x: bounds.x + bounds.width, y: bounds.y },\n                { x: bounds.x + bounds.width, y: bounds.y + bounds.height },\n                { x: bounds.x, y: bounds.y + bounds.height },\n                { x: bounds.x, y: bounds.y }\n            ];\n            intersects = this.intersect(polyLine, polyLine2, self);\n        }\n        return intersects;\n    };\n    /** @private */\n    CommandHandler.prototype.intersect = function (polyLine1, polyLine2, self) {\n        var intersect = [];\n        for (var i = 0; i < polyLine1.length - 1; i++) {\n            for (var j = 0; j < polyLine2.length - 1; j++) {\n                var p = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.intersect2)(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);\n                if (p.x !== 0 && p.y !== 0) {\n                    intersect.push(p);\n                }\n            }\n        }\n        return intersect;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.getPointAtLength = function (length, points, angle) {\n        angle = 0;\n        var run = 0;\n        var pre;\n        var found = { x: 0, y: 0 };\n        var pt;\n        for (var i = 0; i < points.length; i++) {\n            pt = points[i];\n            if (!pre) {\n                pre = pt;\n                continue;\n            }\n            else {\n                var l = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength(pre, pt);\n                var r = void 0;\n                var deg = void 0;\n                var x = void 0;\n                var y = void 0;\n                if (run + l >= length) {\n                    r = length - run;\n                    deg = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findAngle(pre, pt);\n                    x = r * Math.cos(deg * Math.PI / 180);\n                    y = r * Math.sin(deg * Math.PI / 180);\n                    found = { x: pre.x + x, y: pre.y + y };\n                    angle = deg;\n                    break;\n                }\n                else {\n                    run += l;\n                }\n            }\n            pre = pt;\n        }\n        return found;\n    };\n    CommandHandler.prototype.getInterceptWithSegment = function (currentPosition, conPoints) {\n        var intercepts = [];\n        var imgLine = [];\n        var segemnt = [];\n        var tarAngle;\n        var srcAngle; //let maxLength: number;\n        var maxLength = _primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findLength({ x: 0, y: 0 }, { x: this.diagram.scroller.viewPortWidth, y: this.diagram.scroller.viewPortHeight });\n        for (var i = 1; i < conPoints.length; i++) {\n            segemnt = [conPoints[i - 1], conPoints[i]];\n            imgLine = [];\n            srcAngle = Math.round(_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findAngle(segemnt[0], segemnt[1]) % 360);\n            tarAngle = Math.round(_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.findAngle(segemnt[1], segemnt[0]) % 360);\n            var angleAdd = (srcAngle > 0 && srcAngle <= 90) || (srcAngle > 180 && srcAngle <= 270) ? 90 : -90;\n            imgLine.push(_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.transform(currentPosition, srcAngle + angleAdd, maxLength));\n            imgLine.push(_primitives_point__WEBPACK_IMPORTED_MODULE_13__.Point.transform(currentPosition, tarAngle + angleAdd, maxLength));\n            var lineUtil1 = { x1: segemnt[0].x, y1: segemnt[0].y, x2: segemnt[1].x, y2: segemnt[1].y };\n            var lineUtil2 = { x1: imgLine[0].x, y1: imgLine[0].y, x2: imgLine[1].x, y2: imgLine[1].y };\n            var line3 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.intersect3)(lineUtil1, lineUtil2);\n            if (line3.enabled) {\n                intercepts.push(line3.intersectPt);\n            }\n        }\n        return intercepts;\n    };\n    /** @private */\n    CommandHandler.prototype.getAnnotationChanges = function (object, label) {\n        var index = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findObjectIndex)(object, label.id, true);\n        var annotations = {};\n        annotations[index] = {\n            width: label.width, height: label.height, offset: (object instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) ? ({\n                x: label.offset.x,\n                y: label.offset.y\n            }) : label.offset,\n            rotateAngle: label.rotateAngle,\n            margin: { left: label.margin.left, right: label.margin.right, top: label.margin.top, bottom: label.margin.bottom },\n            horizontalAlignment: label.horizontalAlignment, verticalAlignment: label.verticalAlignment,\n            alignment: ((object instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) ? label.alignment : undefined)\n        };\n        return { annotations: annotations };\n    };\n    // Feature 826644: Support to add ports to the connector. Added below method to get port values before and after drag.\n    /** @private */\n    CommandHandler.prototype.getConnectorPortChanges = function (object, label) {\n        var index = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findPortIndex)(object, label.id, true);\n        var ports = {};\n        ports[index] = {\n            width: label.width, height: label.height, offset: label.offset,\n            margin: { left: label.margin.left, right: label.margin.right, top: label.margin.top, bottom: label.margin.bottom },\n            horizontalAlignment: label.horizontalAlignment, verticalAlignment: label.verticalAlignment,\n            alignment: ((object instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) ? label.alignment : undefined)\n        };\n        return { ports: ports };\n    };\n    /** @private */\n    CommandHandler.prototype.getPortChanges = function (object, port) {\n        var index = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findObjectIndex)(object, port.id, false);\n        var ports = {};\n        ports[index] = { offset: port.offset };\n        return { ports: ports };\n    };\n    /** @private */\n    CommandHandler.prototype.labelRotate = function (object, label, currentPosition, selector) {\n        var oldValues;\n        var changedvalues;\n        oldValues = this.getAnnotationChanges(object, label);\n        var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n        var rotateAngle = label.rotateAngle;\n        var labelWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n        var angle = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_17__.findAngle)({ x: labelWrapper.offsetX, y: labelWrapper.offsetY }, currentPosition) + 90;\n        var snapAngle = this.snapAngle(angle);\n        angle = snapAngle !== 0 ? snapAngle : angle;\n        if (label instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_18__.PathAnnotation && label.segmentAngle) {\n            var getPointloop = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getAnnotationPosition)(object.intermediatePoints, label, object.wrapper.bounds);\n            angle -= getPointloop.angle;\n        }\n        angle = (angle + 360) % 360;\n        label.rotateAngle += angle - (label.rotateAngle + labelWrapper.parentTransform);\n        if (label instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_18__.PathAnnotation) {\n            label.alignment = 'Center';\n        }\n        selector.wrapper.rotateAngle = selector.rotateAngle = label.rotateAngle;\n        changedvalues = this.getAnnotationChanges(object, label);\n        if (object instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            this.diagram.nodePropertyChange(object, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(object, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(object);\n        //909175: Label interaction not reflected properly in overview\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            var view = this.diagram.views[temp];\n            if (!(view instanceof _diagram_diagram__WEBPACK_IMPORTED_MODULE_5__.Diagram)) {\n                this.diagram.refreshCanvasDiagramLayer(view);\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.labelResize = function (node, label, deltaWidth, deltaHeight, pivot, selector) {\n        var oldValues;\n        var changedvalues;\n        var rotateAngle;\n        oldValues = this.getAnnotationChanges(node, label);\n        var textElement = selector.wrapper.children[0];\n        if ((deltaWidth && deltaWidth !== 1) || (deltaHeight && deltaHeight !== 1)) {\n            var newMat = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n            var matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.identityMatrix)();\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(newMat, -node.rotateAngle, node.offsetX, node.offsetY);\n            rotateAngle = ((textElement.rotateAngle + ((node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) ? node.rotateAngle : 0)) + 360) % 360;\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, -rotateAngle, pivot.x, pivot.y);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.scaleMatrix)(matrix, deltaWidth, deltaHeight, pivot.x, pivot.y);\n            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.rotateMatrix)(matrix, rotateAngle, pivot.x, pivot.y);\n            var newPosition = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(matrix, { x: textElement.offsetX, y: textElement.offsetY });\n            var height = textElement.actualSize.height * deltaHeight;\n            var width = textElement.actualSize.width * deltaWidth;\n            var shape = this.findTarget(textElement, node);\n            if (shape instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_18__.PathAnnotation) {\n                newPosition.y += (shape.verticalAlignment === 'Top') ? (-height / 2) : ((shape.verticalAlignment === 'Bottom') ? (height / 2) : 0);\n                newPosition.x += (shape.horizontalAlignment === 'Left') ? (-width / 2) : ((shape.horizontalAlignment === 'Right') ? (width / 2) : 0);\n            }\n            if (shape instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_18__.PathAnnotation) {\n                this.updatePathAnnotationOffset(node, label, 0, 0, newPosition, new _primitives_size__WEBPACK_IMPORTED_MODULE_14__.Size(width, height));\n            }\n            else {\n                var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cornersPointsBeforeRotation)(node.wrapper);\n                newPosition = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_6__.transformPointByMatrix)(newMat, newPosition);\n                newPosition.x = newPosition.x - textElement.margin.left + textElement.margin.right;\n                newPosition.y = newPosition.y - textElement.margin.top + textElement.margin.bottom;\n                newPosition.y += (shape.verticalAlignment === 'Top') ? (-height / 2) : ((shape.verticalAlignment === 'Bottom') ? (height / 2) : 0);\n                newPosition.x += (shape.horizontalAlignment === 'Left') ? (-width / 2) : ((shape.horizontalAlignment === 'Right') ? (width / 2) : 0);\n                var offsetx = bounds.width / (newPosition.x - bounds.x);\n                var offsety = bounds.height / (newPosition.y - bounds.y);\n                if (width > 1) {\n                    shape.width = width;\n                    shape.offset.x = 1 / offsetx;\n                }\n                if (height > 1) {\n                    shape.height = height;\n                    shape.offset.y = 1 / offsety;\n                }\n            }\n        }\n        if (label instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_18__.PathAnnotation) {\n            label.alignment = 'Center';\n        }\n        changedvalues = this.getAnnotationChanges(node, label);\n        if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            this.diagram.nodePropertyChange(node, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(node, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(node);\n        //909175: Label interaction not reflected properly in overview\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            var view = this.diagram.views[temp];\n            if (!(view instanceof _diagram_diagram__WEBPACK_IMPORTED_MODULE_5__.Diagram)) {\n                this.diagram.refreshCanvasDiagramLayer(view);\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.getSubProcess = function (source) {\n        var selector = { nodes: [], connectors: [] };\n        var process;\n        if (source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            process = source.processId;\n        }\n        else if (source && source.nodes && (source.nodes.length)\n            && source.nodes[0].processId) {\n            process = source.nodes[0].processId;\n        }\n        if (process) {\n            selector.nodes.push((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(this.diagram.nameTable[process]));\n            return selector;\n        }\n        return selector;\n    };\n    /**   @private  */\n    CommandHandler.prototype.checkBoundaryConstraints = function (tx, ty, nodeBounds, isInitialRendering) {\n        var pageSettings = this.diagram.pageSettings;\n        var boundaryConstraints = this.diagram.pageSettings.boundaryConstraints;\n        var scroller = this.diagram.scroller;\n        if (boundaryConstraints === 'Page' || boundaryConstraints === 'Diagram') {\n            var selectorBounds = !nodeBounds ? this.diagram.selectedItems.wrapper.bounds : undefined;\n            var width = boundaryConstraints === 'Page' ? pageSettings.width : scroller.viewPortWidth;\n            var height = boundaryConstraints === 'Page' ? pageSettings.height : scroller.viewPortHeight;\n            var bounds = nodeBounds;\n            var right = (nodeBounds ? bounds.right : selectorBounds.right) + (tx || 0);\n            var left = (nodeBounds ? bounds.left : selectorBounds.left) + (tx || 0);\n            var top_2 = (nodeBounds ? bounds.top : selectorBounds.top) + (ty || 0);\n            var bottom = (nodeBounds ? bounds.bottom : selectorBounds.bottom) + (ty || 0);\n            //Bug 906963: Layout is not rendered when boundaryConstraints set to \"Page/Diagram\"\n            if (right <= width && left >= 0\n                && bottom <= height && top_2 >= 0 || (this.diagram.layout.type !== 'None' && isInitialRendering)) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    };\n    //interfaces\n    /** @private */\n    CommandHandler.prototype.dragSelectedObjects = function (tx, ty) {\n        var _this = this;\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.offsetX = obj.offsetX;\n            this.state.backup.offsetY = obj.offsetY;\n        }\n        obj = (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.renderContainerHelper)(this.diagram, obj) || obj;\n        //Bug 905527: Multiselecting and dragging Swimlane updates incorrectly\n        //Added below condition to check if swimlane is selected and not the symbol symbol from the symbol palette\n        //Also check if the selected swimlane is not the only object selected\n        var swimLaneInSelection = this.diagram.selectedItems.nodes.filter(function (node) { return node.shape.type === 'SwimLane'; });\n        var conCollection = [];\n        if (swimLaneInSelection.length > 0 && !this.diagram.currentSymbol) {\n            if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 1) {\n                var filterObjects = this.diagram.selectedItems.nodes.filter(function (node) { return (node.parentId === '' || _this.diagram.nameTable[node.parentId].shape.type !== 'SwimLane'); });\n                if (filterObjects.length > 0) {\n                    for (var i = 0; i < filterObjects.length; i++) {\n                        if ((this.diagram.nameTable[filterObjects[parseInt(i.toString(), 10)].parentId] &&\n                            this.diagram.nameTable[filterObjects[parseInt(i.toString(), 10)].parentId].isLane)\n                            || filterObjects[parseInt(i.toString(), 10)].shape.type === 'SwimLane') {\n                            filterObjects.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    //\"obj\" -  The current object being processed in the array.\n                    //\"index\" - The index of the current object in the array.\n                    //\"self\" - The reference to the entire array being processed by the filter function.\n                    var uniqueSwimlane = swimLaneInSelection.filter(function (obj, index, self) {\n                        return index === self.findIndex(function (item) { return item.id === obj.id; });\n                    });\n                    //Bug 913796: Multiselect swimlane with outside node, drag, rotate is not proper\n                    //Added below code to get connectors connected inside swimlane and update the properties.\n                    for (var i = 0; i < uniqueSwimlane.length; i++) {\n                        conCollection = conCollection.concat((0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.getConnectors)(this.diagram, uniqueSwimlane[i].wrapper.children[0], 0, true));\n                    }\n                    if (filterObjects.length > 0 || uniqueSwimlane.length > 1 || this.diagram.selectedItems.connectors.length > 0) {\n                        filterObjects = filterObjects.concat(uniqueSwimlane);\n                        // Clear the nodes array without losing the reference\n                        this.diagram.selectedItems.nodes.splice(0, this.diagram.selectedItems.nodes.length);\n                        // Push objects from filterObjects into the nodes array\n                        filterObjects.forEach(function (node) {\n                            _this.diagram.selectedItems.nodes.push(node);\n                        });\n                        obj = this.diagram.selectedItems;\n                        this.diagram.selectedObject.helperObject = undefined;\n                    }\n                }\n            }\n        }\n        if (this.checkBoundaryConstraints(tx, ty)) {\n            this.diagram.diagramActions = this.diagram.diagramActions | (_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.PreventZIndexOnDragging | _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.DragUsingMouse);\n            var actualObject = this.diagram.selectedObject.actualObject;\n            if ((actualObject && actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node && actualObject.isLane &&\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.canLaneInterchange)(actualObject, this.diagram)) || (!actualObject || !actualObject.isLane)) {\n                this.diagram.drag(obj, tx, ty);\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.updateConnectorsProperties)(conCollection, this.diagram);\n            }\n            this.diagram.diagramActions = this.diagram.diagramActions & ~(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.PreventZIndexOnDragging | _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.DragUsingMouse);\n            this.diagram.refreshCanvasLayers();\n            //Bug 872140: Dragging HTML nodes in a diagram leaves shadows on the overview\n            this.checkHtmlObjectDrag(obj);\n            return true;\n        }\n        return false;\n    };\n    // Checks if any HTML object is being dragged and reset the canvas to clear the shadow of the HTML node border.\n    CommandHandler.prototype.checkHtmlObjectDrag = function (obj) {\n        var isHtmlObjDragged = false;\n        if (this.diagram.views && this.diagram.views.length > 1) {\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n                isHtmlObjDragged = obj.nodes.some(function (node) { return node.shape && node.shape.type === 'HTML'; });\n            }\n            else if (obj.shape && obj.shape.type === 'HTML') {\n                isHtmlObjDragged = true;\n            }\n            if (isHtmlObjDragged) {\n                this.resetOverviewCanvas();\n            }\n        }\n    };\n    //Resetting Overview canvas  \n    CommandHandler.prototype.resetOverviewCanvas = function () {\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            var view = this.diagram.views[temp];\n            if (!(view instanceof _diagram_diagram__WEBPACK_IMPORTED_MODULE_5__.Diagram)) {\n                var rect = document.getElementById(view.canvas.id + 'overviewrect');\n                var x = Number(rect.getAttribute('x'));\n                var y = Number(rect.getAttribute('y'));\n                var width = Number(rect.getAttribute('width'));\n                var height = Number(rect.getAttribute('height'));\n                var attr = { x: x, y: y, width: Math.max(1, width), height: Math.max(1, height) };\n                (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.setAttributeHtml)(rect, attr);\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.scaleSelectedItems = function (sx, sy, pivot) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.offsetX = obj.offsetX;\n            this.state.backup.offsetY = obj.offsetY;\n            this.state.backup.width = obj.width;\n            this.state.backup.height = obj.height;\n            this.state.backup.pivot = pivot;\n        }\n        obj = (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.renderContainerHelper)(this.diagram, obj) || obj;\n        return this.diagram.scale(obj, sx, sy, pivot);\n    };\n    /** @private */\n    CommandHandler.prototype.rotateSelectedItems = function (angle) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.angle = obj.rotateAngle;\n        }\n        obj = (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.renderContainerHelper)(this.diagram, obj) || obj;\n        return this.diagram.rotate(obj, angle, undefined, true);\n    };\n    /** @private */\n    CommandHandler.prototype.hasSelection = function () {\n        return (0,_actions__WEBPACK_IMPORTED_MODULE_9__.hasSelection)(this.diagram);\n    };\n    /** @private */\n    CommandHandler.prototype.isSelected = function (element) {\n        return (0,_actions__WEBPACK_IMPORTED_MODULE_9__.isSelected)(this.diagram, element);\n    };\n    /**\n     * initExpand is used for layout expand and collapse interaction\n     */\n    CommandHandler.prototype.initExpand = function (args) {\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[propName];\n        this.diagram.protectPropertyChange(true);\n        var node = (args.target || args.source);\n        var oldValues = { isExpanded: node.isExpanded };\n        node.isExpanded = !node.isExpanded;\n        this.diagram.preventNodesUpdate = true;\n        this.diagram.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.PreventIconsUpdate;\n        this.diagram.nodePropertyChange(node, oldValues, { isExpanded: node.isExpanded });\n        this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.PreventIconsUpdate;\n        this.diagram.preventNodesUpdate = false;\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            var view = this.diagram.views[temp];\n            if (!(view instanceof _diagram_diagram__WEBPACK_IMPORTED_MODULE_5__.Diagram)) {\n                this.diagram.refreshCanvasDiagramLayer(view);\n            }\n        }\n        this.diagram.protectPropertyChange(protectedChange);\n    };\n    /** @private */\n    CommandHandler.prototype.expandNode = function (node, diagram, canLayout) {\n        var animation;\n        //let objects: ILayout;\n        var preventNodesUpdate = this.diagram.preventNodesUpdate;\n        var expand = node.isExpanded;\n        this.diagram.preventNodesUpdate = true;\n        //Bug 883244: After expand and collapse the compex hierarchical layout, the connector are not rendered properly.\n        // Removed the preventConnectorsUpdate property to update the connector properly while performing expand and collapse.\n        // this.diagram.preventConnectorsUpdate = true;\n        this.expandCollapse(node, expand, this.diagram, undefined);\n        node.isExpanded = expand;\n        var fixedNode = this.diagram.layout.fixedNode;\n        this.diagram.layout.fixedNode = node.id;\n        if ((this.diagram.diagramActions != _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.Render) && this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && this.diagram.organizationalChartModule) {\n            this.diagram.organizationalChartModule.isAnimation = true;\n        }\n        this.diagram.blazorActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_10__.BlazorAction.expandNode;\n        var objects = {};\n        if (!canLayout) {\n            if (this.layoutAnimateModule && this.layoutAnimateModule.setIntervalObject.length > 0) {\n                this.layoutAnimateModule.stopCurrentAnimation(this.objectStore[0], diagram, node);\n                this.objectStore = [];\n            }\n            objects = this.diagram.doLayout();\n            this.objectStore.push(objects);\n        }\n        this.canUpdateTemplate = false;\n        this.diagram.blazorActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.BlazorAction.expandNode;\n        this.diagram.preventNodesUpdate = preventNodesUpdate;\n        // this.diagram.preventConnectorsUpdate = false;\n        if (this.diagram.layoutAnimateModule && this.diagram.organizationalChartModule && !canLayout) {\n            this.diagram.allowServerDataBinding = false;\n            this.layoutAnimateModule.expand(this.diagram.layout.enableAnimation, objects, node, this.diagram);\n        }\n        else {\n            var arg = {\n                element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(node)), state: (node.isExpanded) ? true : false\n            };\n            this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.expandStateChange, arg);\n            //Bug 873119: Diagram throws error when setting isExpanded property as false with LineRouting injected.\n            if (this.diagram.lineRoutingModule && this.diagram.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramConstraints.LineRouting && this.diagram.layout.type !== 'ComplexHierarchicalTree') {\n                this.diagram.resetSegments();\n            }\n        }\n        this.diagram.layout.fixedNode = fixedNode === '' ? '' : this.diagram.layout.fixedNode;\n        return objects;\n    };\n    CommandHandler.prototype.getparentexpand = function (target, diagram, visibility, connector) {\n        var boolean;\n        for (var i = 0; i < target.inEdges.length; i++) {\n            var newConnector = diagram.nameTable[target.inEdges[i]];\n            var previousNode = diagram.nameTable[newConnector.sourceID];\n            if (previousNode.isExpanded && !visibility && previousNode.id !== connector.sourceID && newConnector.visible) {\n                return false;\n            }\n            else {\n                boolean = true;\n            }\n        }\n        return boolean;\n    };\n    /**\n     * Setinterval and Clear interval for layout animation\n     */\n    /** @private */\n    CommandHandler.prototype.expandCollapse = function (source, visibility, diagram, visitedNodes) {\n        //937703 - Check if the node has already been visited\n        if (!visitedNodes || visitedNodes.length === 0) {\n            visitedNodes = [];\n        }\n        if (visitedNodes.some(function (node) { return node.id === source.id; })) {\n            return; // Avoid infinite loop by returning early\n        }\n        // Mark the current node as visited\n        visitedNodes.push(source);\n        for (var i = 0; i < source.outEdges.length; i++) {\n            var connector = diagram.nameTable[source.outEdges[i]];\n            var target = diagram.nameTable[connector.targetID];\n            var value = this.getparentexpand(target, diagram, visibility, connector);\n            connector.visible = visibility;\n            var oldValues = {\n                visible: target.visible,\n                style: { opacity: target.wrapper.style.opacity }\n            };\n            var newValues = {\n                visible: target.visible,\n                style: { opacity: target.wrapper.style.opacity }\n            };\n            if (value) {\n                if (target.isExpanded) {\n                    this.expandCollapse(target, visibility, diagram, visitedNodes);\n                }\n                target.visible = visibility;\n                target.style.opacity = (this.diagram.layoutAnimateModule &&\n                    this.diagram.layout.enableAnimation && visibility) ? 0.1 : target.style.opacity;\n                diagram.nodePropertyChange(target, oldValues, newValues);\n            }\n            diagram.connectorPropertyChange(connector, oldValues, newValues);\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateNodeDimension = function (obj, rect) {\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            obj.offsetX = rect.x + rect.width / 2;\n            obj.offsetY = rect.y + rect.height / 2;\n            obj.width = rect.width;\n            obj.height = rect.height;\n            obj.wrapper.children[0].canMeasurePath = true;\n            this.diagram.nodePropertyChange(obj, {}, {\n                width: rect.width, height: rect.height, offsetX: obj.offsetX,\n                offsetY: obj.offsetY\n            });\n            if (this.diagram.mode !== 'SVG') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateConnectorPoints = function (obj, rect) {\n        if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && obj.type !== 'Bezier') {\n            this.diagram.connectorPropertyChange(obj, {}, {\n                targetPoint: obj.targetPoint\n            });\n            this.diagram.updateDiagramObject(obj);\n        }\n        else {\n            this.diagram.connectorPropertyChange(obj, {}, { segments: obj.segments });\n            this.diagram.updateDiagramObject(obj);\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateSelectedNodeProperties = function (object) {\n        if (this.diagram.lineRoutingModule && (this.diagram.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramConstraints.LineRouting)) {\n            var previousNodeObject = [];\n            var previousConnectorObject = [];\n            var updateNodeObject = [];\n            var updateConnectorObject = [];\n            var changeNodes = [];\n            var changeConnectors = [];\n            this.diagram.protectPropertyChange(true);\n            var objects = [];\n            var connectors = [];\n            var actualObject = this.diagram.selectedObject.actualObject;\n            var helperObject = this.diagram.selectedObject.helperObject;\n            //EJ2-908138 - Redo not working after move and undo the multi nodes while  line routing enabled\n            var undoElement = actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector ? (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(actualObject) : undefined;\n            if (helperObject && actualObject) {\n                var offsetX = (helperObject.offsetX - actualObject.offsetX);\n                var offsetY = (helperObject.offsetY - actualObject.offsetY);\n                var width = (helperObject.width - actualObject.width);\n                var height = (helperObject.height - actualObject.height);\n                var rotateAngle = (helperObject.rotateAngle - actualObject.rotateAngle);\n                if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 0) {\n                    this.diagram.selectedItems.wrapper.rotateAngle = this.diagram.selectedItems.rotateAngle = helperObject.rotateAngle;\n                }\n                if (actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node &&\n                    actualObject.shape.type !== 'SwimLane' && !actualObject.isLane && !actualObject.isPhase && !actualObject.isHeader &&\n                    !(0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, actualObject)) {\n                    if (actualObject.offsetX !== actualObject.wrapper.offsetX || actualObject.offsetY !== actualObject.wrapper.offsetY ||\n                        actualObject.width !== actualObject.wrapper.width || actualObject.height !== actualObject.wrapper.height ||\n                        actualObject.rotateAngle !== actualObject.wrapper.rotateAngle) {\n                        actualObject.offsetX += offsetX;\n                        actualObject.offsetY += offsetY;\n                        actualObject.width += width;\n                        actualObject.height += height;\n                        actualObject.rotateAngle += rotateAngle;\n                        this.diagram.nodePropertyChange(actualObject, {}, {\n                            offsetX: actualObject.offsetX, offsetY: actualObject.offsetY,\n                            width: actualObject.width, height: actualObject.height, rotateAngle: actualObject.rotateAngle\n                        }, false, true);\n                    }\n                    objects = this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds);\n                }\n                else if (actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n                    //929543: To resize the multiselected nodes properly\n                    var scaleWidth = helperObject.width / actualObject.width;\n                    var scaleHeight = helperObject.height / actualObject.height;\n                    var pivot = this.diagram.eventHandler.tool.getPivot(this.diagram.eventHandler.tool.corner);\n                    if (this.diagram.eventHandler.tool.corner) {\n                        for (var i = 0; i < actualObject.nodes.length; i++) {\n                            var node = actualObject.nodes[parseInt(i.toString(), 10)];\n                            var element = node.wrapper;\n                            var refWrapper = actualObject.wrapper;\n                            var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;\n                            var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;\n                            var refPoint = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getPoint)(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);\n                            this.diagram.commandHandler.scaleObject(scaleWidth, scaleHeight, refPoint, node, element, actualObject);\n                        }\n                    }\n                    else {\n                        for (var i = 0; i < actualObject.nodes.length; i++) {\n                            var node = actualObject.nodes[i];\n                            if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node && node.shape.type !== 'SwimLane' &&\n                                !(0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, node) &&\n                                !node.isLane\n                                && !node.isPhase && !node.isHeader) {\n                                node.offsetX += offsetX;\n                                node.offsetY += offsetY;\n                                node.width += width;\n                                node.height += height;\n                                node.rotateAngle += rotateAngle;\n                                this.diagram.nodePropertyChange(node, {}, {\n                                    offsetX: node.offsetX, offsetY: node.offsetY,\n                                    width: node.width, height: node.height, rotateAngle: node.rotateAngle\n                                });\n                                objects = objects.concat(this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds));\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                if (object instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) {\n                    objects.push(object);\n                }\n                else if (object instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector && object.connectors.length) {\n                    objects = objects.concat(object.connectors);\n                }\n                //EJ2-909180 - Line routing does not take place when drag and drop from symbol Palatte\n                if (object instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n                    if (this.diagram.nodes.indexOf(object.nodes[0]) !== -1) {\n                        var node = actualObject || object.nodes[0];\n                        if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node && node.shape.type !== 'SwimLane' && !(0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, node)\n                            && !node.isLane && !node.isPhase && !node.isHeader) {\n                            objects = objects.concat(this.diagram.spatialSearch.findObjects(node.wrapper.outerBounds));\n                        }\n                    }\n                }\n            }\n            for (var i = 0; i < objects.length; i++) {\n                if (objects[i] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && connectors.indexOf(objects[i].id) === -1) {\n                    connectors.push(objects[i].id);\n                }\n            }\n            if (connectors.length > 0 || this.diagram.routedConnectors.length > 0) {\n                if (this.diagram.avoidLineOverlappingModule) {\n                    this.diagram.avoidLineOverlappingModule.removeConnectors(connectors);\n                    this.diagram.avoidLineOverlappingModule.removeConnectors(this.diagram.routedConnectors);\n                }\n                this.diagram.lineRoutingModule.renderVirtualRegion(this.diagram, true);\n            }\n            this.diagram.lineRoutingModule.skipObstacleCheck = true;\n            for (var i = 0; i < this.diagram.routedConnectors.length; i++) {\n                var connector = this.diagram.nameTable[this.diagram.routedConnectors[i]];\n                this.ReRouteConnector(connector);\n            }\n            this.diagram.lineRoutingModule.skipObstacleCheck = false;\n            for (var i = 0; i < connectors.length; i++) {\n                var connector = this.diagram.nameTable[connectors[i]];\n                if (this.diagram.routedConnectors.indexOf(connector.id) === -1) {\n                    this.ReRouteConnector(connector);\n                }\n            }\n            this.diagram.routedConnectors = [];\n            //EJ2-908138 - Redo not working after move and undo the multi nodes while  line routing enabled\n            //EJ2-925499 - Undo/Redo not working after move multiselected nodes inside swimlane while line routing enabled\n            if (helperObject && actualObject && undoElement && this.diagram.eventHandler.currentAction === 'Drag') {\n                var canAddHistory = false;\n                var nameTable = this.diagram.nameTable;\n                for (var i = 0; i < actualObject.nodes.length; i++) {\n                    if (!(nameTable[actualObject.nodes[i].parentId] && nameTable[actualObject.nodes[i].parentId].isLane)) {\n                        canAddHistory = true;\n                    }\n                }\n                if (canAddHistory) {\n                    var obj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(actualObject);\n                    this.diagram.startGroupAction();\n                    var entry = {\n                        type: 'PositionChanged',\n                        redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj), undoObject: undoElement, category: 'Internal'\n                    };\n                    this.diagram.addHistoryEntry(entry);\n                    this.diagram.endGroupAction();\n                }\n            }\n            this.updateSelector();\n            this.diagram.protectPropertyChange(false);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drawSelectionRectangle = function (x, y, width, height) {\n        this.diagram.drawSelectionRectangle(x, y, width, height);\n    };\n    /** @private */\n    CommandHandler.prototype.ReRouteConnector = function (connector) {\n        if (connector instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector && connector.type === 'Orthogonal') {\n            // EJ2-65876 - Exception occurs on line routing injection module\n            //Bug 850195: Exception occurs due to line routing constraints enabled\n            if (connector.sourceID && connector.targetID && connector.sourceID != connector.targetID && this.diagram.layout.type !== 'ComplexHierarchicalTree') {\n                //EJ2-69573 - Excecption occurs when calling doLayout method with the lineRouting module \n                var sourceNode = this.diagram.getObject(connector.sourceID);\n                var targetNode = this.diagram.getObject(connector.targetID);\n                var connectorLengthX = targetNode.offsetX > sourceNode.offsetX\n                    ? targetNode.wrapper.outerBounds.middleLeft.x - sourceNode.wrapper.outerBounds.middleRight.x\n                    : sourceNode.wrapper.outerBounds.middleLeft.x - targetNode.wrapper.outerBounds.middleRight.x;\n                var connectorLengthY = targetNode.offsetY > sourceNode.offsetY\n                    ? targetNode.wrapper.outerBounds.topCenter.y - sourceNode.wrapper.outerBounds.bottomCenter.y\n                    : sourceNode.wrapper.outerBounds.topCenter.y - targetNode.wrapper.outerBounds.bottomCenter.y;\n                if (connectorLengthX > 30 || connectorLengthY > 30) {\n                    this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, true);\n                }\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.startGroupAction = function () {\n        this.diagram.startGroupAction();\n    };\n    /** @private */\n    CommandHandler.prototype.endGroupAction = function () {\n        this.diagram.endGroupAction();\n    };\n    /** @private */\n    CommandHandler.prototype.removeChildFromBPmn = function (child, newTarget, oldTarget) {\n        var obj = this.diagram.nameTable[child.id] || child.nodes[0];\n        if (oldTarget) {\n            if ((obj) && obj.processId && obj.processId === oldTarget.wrapper.id) {\n                var node = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj);\n                node.processId = obj.processId;\n                // 908136: Node goes behind the subprocess and the connector connected to it is destroyed Issue Fix by commenting these lines\n                // let edges: string[] = [];\n                // edges = edges.concat((obj as Node).outEdges, (obj as Node).inEdges);\n                // for (let i: number = edges.length - 1; i >= 0; i--) {\n                //     const connector: ConnectorModel = this.diagram.nameTable[edges[i]];\n                //     if (connector) {\n                //         this.diagram.remove(connector);\n                //     }\n                // }\n                var nodeCollection = (this.diagram.nameTable[obj.processId].shape.activity.subProcess.processes) || [];\n                nodeCollection.splice(nodeCollection.indexOf((obj).id), 1);\n                this.diagram.bpmnModule.removeChildFromBPMN(this.diagram.nameTable[obj.processId].wrapper, (obj).id, this.diagram);\n                this.diagram.nameTable[(obj).id].processId = '';\n                obj.offsetX = obj.wrapper.offsetX;\n                obj.offsetY = obj.wrapper.offsetY;\n                //909153: Removed the history entries as we have positionchange entry in mouseup\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.isDroppable = function (source, targetNodes) {\n        var node = this.diagram.nameTable[source.id] || source.nodes[0];\n        if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)() && node.shape.shape === 'TextAnnotation')\n            // ||(isBlazor() && (node.shape as DiagramShape).bpmnShape === 'TextAnnotation')\n            ) {\n                return true;\n            }\n            //848061 - Enabling BPMN Group Nodes to Function Like Subprocess Nodes\n            if (targetNodes.shape.shape === 'Group') {\n                targetNodes.shape.activity.subProcess.collapsed = false;\n            }\n            if (node && node.shape.type === 'Bpmn') {\n                //905238 - Exception thrown while dropping BPMN shapes over a BPMN connector\n                if ((node.processId === targetNodes.id) || (node.id === targetNodes.processId) ||\n                    targetNodes.shape.type === 'Bpmn' && !(targetNodes instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector)\n                        && targetNodes.shape.activity && targetNodes.shape.activity.subProcess\n                        && targetNodes.shape.activity.subProcess.collapsed) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.renderHighlighter = function (args, connectHighlighter, source) {\n        var bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_4__.Rect();\n        if ((args.target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node || args.target instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector) || (connectHighlighter && (args.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node || args.source instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector))) {\n            var tgt = connectHighlighter ? args.source : args.target;\n            var tgtWrap = connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n            var target = this.findTarget(tgtWrap, tgt, source, true);\n            var element = void 0;\n            if (target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.BpmnSubEvent) {\n                var portId = target.id;\n                var node = args.target;\n                var parent_8 = node.wrapper.children[0].children[0].children[2];\n                for (var _i = 0, _a = parent_8.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    if (child.id === node.id + '_' + portId) {\n                        element = child.children[0];\n                        break;\n                    }\n                }\n            }\n            else {\n                element = (target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) ?\n                    target.wrapper : connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n            }\n            if (element && !(target instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector)) {\n                this.diagram.renderHighlighter(element);\n            }\n        }\n    };\n    //additional events\n    /** @private */\n    CommandHandler.prototype.mouseOver = function (source, target, position) {\n        //mouse over\n        //returns whether the source can move over the target or not\n        return true;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.snapPoint = function (startPoint, endPoint, tx, ty) {\n        var obj = this.diagram.selectedItems;\n        var point;\n        var towardsLeft = endPoint.x < startPoint.x;\n        var towardsTop = endPoint.y < startPoint.y;\n        point = { x: tx, y: ty };\n        var snappedPoint = point;\n        if (this.snappingModule && (((obj.nodes.length > 0) && (obj.nodes[0].constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.NodeConstraints.Drag)) || ((obj.connectors.length > 0) && (obj.connectors[0].constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.ConnectorConstraints.Drag)))) {\n            snappedPoint = this.diagram.snappingModule.snapPoint(this.diagram, obj, towardsLeft, towardsTop, point, startPoint, endPoint);\n        }\n        return snappedPoint;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.removeSnap = function () {\n        if ((this.diagram.snapSettings.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.SnapConstraints.SnapToObject) && this.snappingModule) {\n            this.snappingModule.removeGuidelines(this.diagram);\n        }\n    };\n    /** @private */\n    /**Bug(EJ2-62725): Exception occurs when drag and drop the connector inside the swimlane */\n    CommandHandler.prototype.dropAnnotation = function (source, target) {\n        if (source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node || source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Selector) {\n            var node = (source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) ? source : source.nodes[0];\n            if (this.diagram.bpmnModule && target.shape.type === 'Bpmn'\n                && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_16__.isBlazor)() && node.shape.shape === 'TextAnnotation')\n                //  ||(isBlazor() && (node.shape as DiagramShape).bpmnShape === 'TextAnnotation')\n                )) {\n                var hasTarget = 'hasTarget';\n                node[hasTarget] = target.id;\n                node.shape.annotation.nodeId = target.id;\n                if (!this.diagram.currentSymbol) {\n                    this.diagram.addTextAnnotation(node.shape.annotation, target);\n                    node.shape.annotation.nodeId = '';\n                    this.diagram.remove(node);\n                }\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drop = function (source, target, position) {\n        //drop\n        if (this.diagram.bpmnModule) {\n            var nodesToProcess = (source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) ? [source] : source.nodes;\n            for (var i = 0; i < nodesToProcess.length; i++) {\n                var node = nodesToProcess[i];\n                //905238 - Exception thrown while dropping BPMN shapes over a BPMN connector\n                if (node && node.shape.type === 'Bpmn' && target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node && target.shape.type === 'Bpmn'\n                    && !(target instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_0__.Connector)) {\n                    this.diagram.bpmnModule.dropBPMNchild(target, node, this.diagram);\n                }\n            }\n            this.diagram.refreshDiagramLayer();\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.addHistoryEntry = function (entry) {\n        this.diagram.addHistoryEntry(entry);\n    };\n    /** @private */\n    CommandHandler.prototype.align = function (objects, option, type) {\n        if (objects.length > 0) {\n            var i = 0;\n            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n            var bounds = (type === 'Object') ? (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(objects[0].wrapper) : this.diagram.selectedItems.wrapper.bounds;\n            var undoObj = { nodes: [], connectors: [] };\n            var redoObj = { nodes: [], connectors: [] };\n            for (i = ((type === 'Object') ? (i + 1) : i); i < objects.length; i++) {\n                var tx = 0;\n                var ty = 0;\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n                var objectBounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(objects[i].wrapper);\n                if (option === 'Left') {\n                    tx = bounds.left + objectBounds.width / 2 - objectBounds.center.x;\n                }\n                else if (option === 'Right') {\n                    tx = bounds.right - objectBounds.width / 2 - objectBounds.center.x;\n                }\n                else if (option === 'Top') {\n                    ty = bounds.top + objectBounds.height / 2 - objectBounds.center.y;\n                }\n                else if (option === 'Bottom') {\n                    ty = bounds.bottom - objectBounds.height / 2 - objectBounds.center.y;\n                }\n                else if (option === 'Center') {\n                    tx = bounds.center.x - objectBounds.center.x;\n                }\n                else if (option === 'Middle') {\n                    ty = bounds.center.y - objectBounds.center.y;\n                }\n                undoObj = this.storeObject(undoObj, objects[i]);\n                this.drag(objects[i], tx, ty);\n                this.diagram.updateSelector();\n                redoObj = this.storeObject(redoObj, objects[i]);\n            }\n            undoObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(undoObj);\n            redoObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(redoObj);\n            var entry = {\n                type: 'Align', category: 'Internal',\n                undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(undoObj), redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(redoObj)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    /**\n     * distribute method \\\n     *\n     * @returns { void }     distribute method .\\\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n     * @param {SizingOptions} option - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.distribute = function (objects, option) {\n        if (objects.length > 0) {\n            var i = 0;\n            //const j: number = 0;\n            //const rect: Rect = new Rect();\n            //const b: Rect[] = [];\n            //let temp: NodeModel | ConnectorModel;\n            var right = 0;\n            var left = 0;\n            var top_3 = 0;\n            var bottom = 0;\n            var center = 0;\n            var middle = 0;\n            var btt = 0;\n            var rtl = 0;\n            //const sum: number = 0;\n            var undoSelectorObj = { nodes: [], connectors: [] };\n            var redoSelectorObj = { nodes: [], connectors: [] };\n            for (i = 0; i < objects.length; i++) {\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n            }\n            objects = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.sort)(objects, option);\n            for (i = 1; i < objects.length; i++) {\n                right = right + objects[i].wrapper.bounds.topRight.x - objects[i - 1].wrapper.bounds.topRight.x;\n                left = left + objects[i].wrapper.bounds.topLeft.x - objects[i - 1].wrapper.bounds.topLeft.x;\n                top_3 = top_3 + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.topRight.y;\n                bottom = bottom + objects[i].wrapper.bounds.bottomRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n                center = center + objects[i].wrapper.bounds.center.x - objects[i - 1].wrapper.bounds.center.x;\n                middle = middle + objects[i].wrapper.bounds.center.y - objects[i - 1].wrapper.bounds.center.y;\n                btt = btt + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n                rtl = rtl + objects[i].wrapper.bounds.middleLeft.x - objects[i - 1].wrapper.bounds.middleRight.x;\n            }\n            for (i = 1; i < objects.length - 1; i++) {\n                var tx = 0;\n                var ty = 0;\n                var prev = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(objects[i - 1].wrapper);\n                var current = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(objects[i].wrapper);\n                if (option === 'Center') {\n                    tx = prev.center.x - current.center.x + (center / (objects.length - 1));\n                }\n                else if (option === 'RightToLeft') {\n                    // 926115: Distribute command RightToLeft option works incorrectly\n                    tx = prev.middleRight.x - current.middleLeft.x + (rtl / (objects.length - 1));\n                }\n                else if (option === 'Right') {\n                    tx = prev.topRight.x - current.topRight.x + (right / (objects.length - 1));\n                }\n                else if (option === 'Left') {\n                    tx = prev.topLeft.x - current.topLeft.x + (left / (objects.length - 1));\n                }\n                else if (option === 'Middle') {\n                    ty = prev.center.y - current.center.y + (middle / (objects.length - 1));\n                }\n                else if (option === 'Top') {\n                    ty = prev.topRight.y - current.topRight.y + (top_3 / (objects.length - 1));\n                }\n                else if (option === 'Bottom') {\n                    ty = prev.bottomRight.y - current.bottomRight.y + (bottom / (objects.length - 1));\n                }\n                else if (option === 'BottomToTop') {\n                    ty = prev.bottomRight.y - current.topRight.y + (btt / (objects.length - 1));\n                }\n                undoSelectorObj = this.storeObject(undoSelectorObj, objects[i]);\n                this.drag(objects[i], tx, ty);\n                this.diagram.updateSelector();\n                redoSelectorObj = this.storeObject(redoSelectorObj, objects[i]);\n            }\n            undoSelectorObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(undoSelectorObj);\n            redoSelectorObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(redoSelectorObj);\n            var entry = {\n                type: 'Distribute', category: 'Internal',\n                undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(undoSelectorObj), redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(redoSelectorObj)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    /* eslint-enable */\n    /**\n     * sameSize method \\\n     *\n     * @returns { void }     sameSize method .\\\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n     * @param {SizingOptions} option - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.sameSize = function (objects, option) {\n        if (objects.length > 0) {\n            var i = 0;\n            //let pivot: PointModel;\n            var pivot = { x: 0.5, y: 0.5 };\n            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n            var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(objects[0].wrapper);\n            var undoObject = { nodes: [], connectors: [] };\n            var redoObject = { nodes: [], connectors: [] };\n            for (i = 1; i < objects.length; i++) {\n                objects[parseInt(i.toString(), 10)] = this.diagram.nameTable[objects[parseInt(i.toString(), 10)].id] || objects[0];\n                var rect = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.getBounds)(objects[parseInt(i.toString(), 10)].wrapper);\n                var sw = 1;\n                var sh = 1;\n                if (option === 'Width') {\n                    sw = bounds.width / rect.width;\n                }\n                else if (option === 'Height') {\n                    sh = bounds.height / rect.height;\n                }\n                else if (option === 'Size') {\n                    sw = bounds.width / rect.width;\n                    sh = bounds.height / rect.height;\n                }\n                undoObject = this.storeObject(undoObject, objects[parseInt(i.toString(), 10)]);\n                this.scale(objects[parseInt(i.toString(), 10)], sw, sh, pivot);\n                redoObject = this.storeObject(redoObject, objects[parseInt(i.toString(), 10)]);\n            }\n            this.diagram.updateSelector();\n            undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(undoObject);\n            redoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(redoObject);\n            var entry = {\n                type: 'Sizing', category: 'Internal',\n                undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(undoObject), redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(redoObject)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    CommandHandler.prototype.storeObject = function (selectorObject, obj) {\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            selectorObject.nodes.push((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj));\n        }\n        else {\n            selectorObject.connectors.push((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_7__.cloneObject)(obj));\n        }\n        return selectorObject;\n    };\n    /**\n     * updatePanState method \\\n     *\n     * @returns { any }     updatePanState method .\\\n     * @param {number} eventCheck - provide the eventCheck value.\n     *\n     * @private\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    CommandHandler.prototype.updatePanState = function (eventCheck) {\n        if (eventCheck) {\n            this.diagram.realActions = this.diagram.realActions | _enum_enum__WEBPACK_IMPORTED_MODULE_10__.RealAction.PanInProgress;\n        }\n        else {\n            this.diagram.dataBind();\n            var diagramScrollSettings = this.diagram.scrollSettings;\n            this.diagram.realActions = this.diagram.realActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_10__.RealAction.PanInProgress;\n            var Values = {\n                VerticalOffset: diagramScrollSettings.verticalOffset, HorizontalOffset: diagramScrollSettings.horizontalOffset,\n                ViewportHeight: diagramScrollSettings.viewPortHeight, ViewportWidth: diagramScrollSettings.viewPortWidth,\n                CurrentZoom: diagramScrollSettings.currentZoom\n            };\n            var arg = {\n                oldValue: Values,\n                newValue: Values, source: this.diagram, panState: 'Completed'\n            };\n            this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramEvent.scrollChange, arg);\n        }\n    };\n    /**\n     * dataBinding method \\\n     *\n     * @returns { void }     dataBinding method .\\\n     *\n     * @private\n     */\n    CommandHandler.prototype.dataBinding = function () {\n        this.diagram.dataBind();\n    };\n    CommandHandler.prototype.setBlazorDiagramProps = function (arg) {\n        this.diagram.setBlazorDiagramProps(arg);\n    };\n    /**\n     * scroll method \\\n     *\n     * @returns { void }     scroll method .\\\n     * @param {number} scrollX - provide the source value.\n     * @param {number} scrollY - provide the target value.\n     * @param {PointModel} focusPoint - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.scroll = function (scrollX, scrollY, focusPoint) {\n        var panx = (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canPanX)(this.diagram);\n        var pany = (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_11__.canPanY)(this.diagram);\n        var canPan = true;\n        this.diagram.pan((scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint, canPan);\n    };\n    /**\n     * drawHighlighter method \\\n     *\n     * @returns { NodeModel | ConnectorModel }     drawHighlighter method .\\\n     * @param {IElement} element - provide the element value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.drawHighlighter = function (element) {\n        this.diagram.renderHighlighter(element.wrapper);\n    };\n    /**\n     * removeHighlighter method \\\n     *\n     * @returns { void }     removeHighlighter method .\\\n     *\n     * @private\n     */\n    CommandHandler.prototype.removeHighlighter = function () {\n        this.diagram.clearHighlighter();\n    };\n    /**\n     * renderContainerHelper method \\\n     *\n     * @returns { NodeModel | ConnectorModel }     renderContainerHelper method .\\\n     * @param {NodeModel | SelectorModel | ConnectorModel} node - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.renderContainerHelper = function (node) {\n        return (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.renderContainerHelper)(this.diagram, node);\n    };\n    /**\n     * isParentAsContainer method \\\n     *\n     * @returns { boolean }     isParentAsContainer method .\\\n     * @param {NodeModel} node - provide the parent value.\n     * @param {boolean} isChild - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.isParentAsContainer = function (node, isChild) {\n        return (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, node, isChild);\n    };\n    /**\n     * @returns { boolean } isParentAsContainer method .\\\n     * @param {NodeModel} node - provide the target Node value.\n     * @private\n     */\n    CommandHandler.prototype.isTargetSubProcess = function (node) {\n        if (node && node.shape && node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.activity === 'SubProcess') {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * dropChildToContainer method \\\n     *\n     * @returns { void }     dropChildToContainer method .\\\n     * @param {NodeModel} parent - provide the parent value.\n     * @param {NodeModel} node - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dropChildToContainer = function (parent, node) {\n        if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_10__.DiagramAction.PreventLaneContainerUpdate)) {\n            (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.addChildToContainer)(this.diagram, parent, node);\n            if (node.hasTextAnnotation) {\n                for (var i = 0; i < node.outEdges.length; i++) {\n                    var con = this.diagram.nameTable[node.outEdges[parseInt(i.toString(), 10)]];\n                    if (con.isBpmnAnnotationConnector) {\n                        var annotationNode = this.diagram.nameTable[con.targetID];\n                        (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.addChildToContainer)(this.diagram, parent, annotationNode);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @returns { void }     updateLaneChildrenZindex method .\\\n     * @param {NodeModel} node - provide the node value.\n     * @param {IElement} target - provide the target value.\n     * @private\n     */\n    CommandHandler.prototype.updateLaneChildrenZindex = function (node, target) {\n        var lowerIndexobject = this.findLeastIndexObject(node, target);\n        var swimlane = this.diagram.nameTable[target.parentId];\n        if (swimlane && swimlane.zIndex > lowerIndexobject.zIndex) {\n            var layerIndex = this.diagram.layers.indexOf(this.diagram.getActiveLayer());\n            var layerZIndexTable = this.diagram.layers[parseInt(layerIndex.toString(), 10)].zIndexTable;\n            var tempTable = JSON.parse(JSON.stringify(layerZIndexTable));\n            var startIndex = lowerIndexobject.zIndex;\n            var endIndex = swimlane.zIndex;\n            for (var i = endIndex; i >= startIndex; i--) {\n                if (startIndex !== i) {\n                    if (!layerZIndexTable[i - 1]) {\n                        layerZIndexTable[i - 1] = layerZIndexTable[parseInt(i.toString(), 10)];\n                        this.diagram.nameTable[layerZIndexTable[i - 1]].zIndex = i;\n                        delete layerZIndexTable[parseInt(i.toString(), 10)];\n                    }\n                    else {\n                        //bringing the objects forward\n                        layerZIndexTable[parseInt(i.toString(), 10)] = layerZIndexTable[i - 1];\n                        this.diagram.nameTable[layerZIndexTable[parseInt(i.toString(), 10)]].zIndex = i;\n                    }\n                }\n                else {\n                    var tempIndex = this.swapZIndexObjects(endIndex, layerZIndexTable, swimlane.id, tempTable);\n                }\n            }\n            if (this.diagram.mode === 'SVG') {\n                this.moveSvgNode(target.parentId, lowerIndexobject.id);\n                this.updateNativeNodeIndex(target.parentId, lowerIndexobject.id);\n            }\n            else {\n                this.diagram.refreshCanvasLayers();\n            }\n        }\n    };\n    CommandHandler.prototype.findLeastIndexConnector = function (edges, target, index) {\n        for (var i = 0; i < edges.length; i++) {\n            var connector = this.diagram.nameTable[edges[parseInt(i.toString(), 10)]];\n            if (index.zIndex > connector.zIndex) {\n                index = connector;\n            }\n        }\n        return index;\n    };\n    CommandHandler.prototype.findLeastIndexObject = function (node, target) {\n        var lowerIndexobject = node;\n        if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_1__.Node) {\n            lowerIndexobject = this.findLeastIndexConnector(node.inEdges, target, lowerIndexobject);\n            lowerIndexobject = this.findLeastIndexConnector(node.outEdges, target, lowerIndexobject);\n        }\n        return lowerIndexobject;\n    };\n    /**\n     * checkSelection method \\\n     *\n     * @returns { void }     checkSelection method .\\\n     * @param {SelectorModel} selector - provide the source value.\n     * @param {string} corner - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.checkSelection = function (selector, corner) {\n        var node; // let wrapper: GridPanel; let child: Container; let index: number; let shape: SwimLaneModel;\n        if (selector.nodes.length === 1 && selector.connectors.length === 0) {\n            if ((0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, selector.nodes[0], true)) {\n                node = (selector.nodes[0].shape === 'SwimLane') ? selector.nodes[0] :\n                    this.diagram.nameTable[selector.nodes[0].parentId];\n                var child = selector.nodes[0];\n                if (node.shape.type === 'SwimLane') {\n                    var orientation_1 = (node.shape.orientation === 'Horizontal') ? true : false;\n                    if ((child.isPhase && ((orientation_1 && corner === 'ResizeSouth') || (!orientation_1 && corner === 'ResizeEast'))) ||\n                        (child.isLane && ((orientation_1 && corner === 'ResizeEast') || (!orientation_1 && corner === 'ResizeSouth')))) {\n                        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.swimLaneSelection)(this.diagram, node, corner);\n                    }\n                }\n                else if (node.container.type === 'Grid') {\n                    if (((node.container.orientation === 'Horizontal' && child.rowIndex === 1) ||\n                        (node.container.orientation === 'Vertical' && child.rowIndex > 0 && child.columnIndex > 0))) {\n                        if (corner === 'ResizeSouth') {\n                            for (var i = 0; i < this.diagram.nodes.length; i++) {\n                                var obj = this.diagram.nodes[parseInt(i.toString(), 10)];\n                                if (obj.rowIndex === node.rows.length - 1 && obj.columnIndex === 0) {\n                                    this.select(obj);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        if (corner === 'ResizeEast') {\n                            for (var i = 0; i < this.diagram.nodes.length; i++) {\n                                var obj = this.diagram.nodes[parseInt(i.toString(), 10)];\n                                if (obj.rowIndex === 1 && obj.columnIndex === node.columns.length - 1) {\n                                    this.select(obj);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.swimLaneSelection)(this.diagram, selector.nodes[0], corner);\n            }\n        }\n    };\n    /**\n     * zoom method \\\n     *\n     * @returns { void }     zoom method .\\\n     * @param {number} scale - provide the source value.\n     * @param {number} scrollX - provide the target value.\n     * @param {number} scrollY - provide the layoutOrientation value.\n     * @param {PointModel} focusPoint - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.zoom = function (scale, scrollX, scrollY, focusPoint) {\n        this.diagram.scroller.zoom(scale, scrollX * this.diagram.scroller.currentZoom, scrollY * this.diagram.scroller.currentZoom, focusPoint);\n    };\n    return CommandHandler;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/command-manager.js?");

/***/ })

}]);