"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_e"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/error-bar.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/error-bar.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorBar: () => (/* binding */ ErrorBar)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\n\n/**\n * The `ErrorBar` module is used to render the error bar for series.\n */\nvar ErrorBar = /** @class */ (function () {\n    /**\n     * Constructor for the error bar module.\n     *\n     * @private\n     */\n    function ErrorBar(chart) {\n        this.chart = chart;\n    }\n    /**\n     * Render the error bar for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    ErrorBar.prototype.render = function (series) {\n        if (this.chart.chartAreaType === 'PolarRadar') {\n            return null;\n        }\n        this.createElement(series, this.chart);\n        this.renderErrorBar(series);\n    };\n    ErrorBar.prototype.renderErrorBar = function (series) {\n        var seriesIndex = series.index;\n        var symbolId;\n        var capId;\n        var errorbar = series.errorBar;\n        var errorBarCap = series.errorBar.errorBarCap;\n        var errorDirection = ['', ''];\n        var redraw = series.chart.redraw;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            if (point.visible && point.symbolLocations[0]) {\n                var errorX = 0;\n                var errorY = 0;\n                switch (errorbar.mode) {\n                    case 'Vertical':\n                        errorY = point.verticalError;\n                        break;\n                    case 'Horizontal':\n                        errorX = point.horizontalError;\n                        break;\n                    case 'Both':\n                        errorX = point.horizontalError;\n                        errorY = point.verticalError;\n                        break;\n                }\n                errorDirection = this['calculate' + errorbar.type + 'Value'](point, series, this.chart.requireInvertedAxis, errorX, errorY);\n                symbolId = this.chart.element.id + '_Series_' + '_ErrorBarGroup_' + seriesIndex + '_Point_' + point.index;\n                capId = this.chart.element.id + '_Series_' + '_ErrorBarCap_' + seriesIndex + '_Point_' + point.index;\n                var shapeOption = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(symbolId, '', errorbar.width, (errorbar.errorBarColorMapping ? point.errorBarColor : errorbar.color || this.chart.themeStyle.errorBar), null, '', errorDirection[0]);\n                var element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(shapeOption.id);\n                var previousDirection = element ? element.getAttribute('d') : null;\n                if (series.errorBarElement) {\n                    series.errorBarElement.appendChild(this.chart.renderer.drawPath(shapeOption));\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.pathAnimation)(element, errorDirection[0], redraw, previousDirection, this.chart.duration);\n                var capOption = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(capId, '', errorBarCap.width, (errorbar.errorBarCap.color ? errorBarCap.color : (errorbar.errorBarColorMapping ? point.errorBarColor : errorbar.color || this.chart.themeStyle.errorBar)), null, '', errorDirection[1]);\n                element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(capOption.id);\n                previousDirection = element ? element.getAttribute('d') : null;\n                if (series.errorBarElement) {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendChildElement)(this.chart.enableCanvas, series.errorBarElement, this.chart.renderer.drawPath(capOption), redraw);\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.pathAnimation)(element, errorDirection[1], redraw, previousDirection, this.chart.duration);\n            }\n        }\n    };\n    // path calculation for error bar\n    ErrorBar.prototype.findLocation = function (point, series, isInverted, x1, y1) {\n        var errorbar = series.errorBar;\n        var direction = errorbar.direction;\n        var location = [];\n        var yValue = series.type.indexOf('Stacking') > -1 ? series.stackedValues.endValues[point.index] :\n            (series.seriesType === 'HighLow' || series.seriesType === 'HighLowOpenClose') ? (series.points[point.index].high) :\n                point.yValue;\n        var startPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue + ((direction === 'Plus' || direction === 'Both') ? (errorbar.type === 'Custom' &&\n            (errorbar.mode === 'Horizontal' || errorbar.mode === 'Both')) ? x1 = point.horizontalPositiveError : x1 : 0), yValue + ((direction === 'Plus' || direction === 'Both') ? (errorbar.type === 'Custom' &&\n            (errorbar.mode === 'Vertical' || errorbar.mode === 'Both')) ? y1 = point.verticalPositiveError : y1 : 0), series.xAxis, series.yAxis, isInverted);\n        location.push(startPoint);\n        if (series.isRectSeries) {\n            var midPoint = point.symbolLocations[0];\n            location.push(midPoint);\n        }\n        else {\n            var midPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.yValue, series.xAxis, series.yAxis, isInverted);\n            location.push(midPoint);\n        }\n        var endPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue - ((direction === 'Minus' || direction === 'Both') ? (errorbar.type === 'Custom' &&\n            (errorbar.mode === 'Horizontal' || errorbar.mode === 'Both')) ? x1 = point.horizontalNegativeError : x1 : 0), yValue - ((direction === 'Minus' || direction === 'Both') ? (errorbar.type === 'Custom' &&\n            (errorbar.mode === 'Vertical' || errorbar.mode === 'Both')) ? y1 = point.verticalNegativeError : y1 : 0), series.xAxis, series.yAxis, isInverted);\n        location.push(endPoint);\n        // calculate error height for datalabel position alignment\n        point.error = (errorbar.mode === 'Vertical') ? errorbar.verticalError : errorbar.horizontalError;\n        this.negativeHeight = (errorbar.mode === 'Vertical' || errorbar.mode === 'Both') ? (isInverted ? (location[1].x - location[2].x) :\n            (location[2].y - location[1].y)) : 0;\n        this.positiveHeight = (errorbar.mode === 'Vertical' || errorbar.mode === 'Both') ? (isInverted ? (location[0].x - location[1].x) :\n            (location[1].y - location[0].y)) : 0;\n        return this.getErrorDirection(location[0], location[1], location[2], series, isInverted);\n    };\n    //calculations for eror bar types\n    ErrorBar.prototype.calculateFixedValue = function (point, series, isInverted, errorX, errorY) {\n        // const errorbar: ErrorBarSettingsModel = series.errorBar;\n        return this.findLocation(point, series, isInverted, errorX, errorY);\n    };\n    ErrorBar.prototype.calculatePercentageValue = function (point, series, isInverted, errorX, errorY) {\n        errorX = (errorX / 100) * point.xValue;\n        errorY = (errorY / 100) * point.yValue;\n        return this.findLocation(point, series, isInverted, errorX, errorY);\n    };\n    ErrorBar.prototype.calculateStandardDeviationValue = function (point, series, isInverted, errorX, errorY) {\n        var getMean = this.meanCalculation(series, series.errorBar.mode);\n        errorX = errorX * (getMean.horizontalSquareRoot + getMean.horizontalMean);\n        errorY = errorY * (getMean.verticalSquareRoot + getMean.verticalMean);\n        return this.findLocation(point, series, isInverted, errorX, errorY);\n    };\n    ErrorBar.prototype.calculateStandardErrorValue = function (point, series, isInverted, errorX, errorY) {\n        var length = series.points.length;\n        var getMean = this.meanCalculation(series, series.errorBar.mode);\n        errorX = ((errorX * getMean.horizontalSquareRoot) / Math.sqrt(length));\n        errorY = ((errorY * getMean.verticalSquareRoot) / Math.sqrt(length));\n        return this.findLocation(point, series, isInverted, errorX, errorY);\n    };\n    ErrorBar.prototype.calculateCustomValue = function (point, series, isInverted, errorX, errorY) {\n        // const errorbar: ErrorBarSettingsModel = series.errorBar;\n        return this.findLocation(point, series, isInverted, errorX, errorY);\n    };\n    ErrorBar.prototype.getHorizontalDirection = function (start, mid, end, direction, errorMode, capLength) {\n        var path = '';\n        var capDirection = '';\n        path += 'M ' + start.x + ' ' + mid.y + ' L ' + end.x + ' ' + mid.y;\n        capDirection += (direction === 'Plus' || direction === 'Both') ? 'M ' + (start.x) + ' ' + (mid.y - capLength) + ' L '\n            + (start.x) + ' ' + (mid.y + capLength) : '';\n        capDirection += (direction === 'Minus' || direction === 'Both') ? 'M ' + (end.x) + ' ' + (mid.y - capLength) + ' L '\n            + (end.x) + ' ' + (mid.y + capLength) : ' ';\n        return [path, capDirection];\n    };\n    ErrorBar.prototype.getVerticalDirection = function (start, mid, end, direction, errorMode, capLength) {\n        var path = '';\n        var capDirection = '';\n        path += 'M ' + mid.x + ' ' + start.y + ' L ' + mid.x + ' ' + end.y;\n        capDirection += (direction === 'Plus' || direction === 'Both') ? 'M ' + (mid.x - capLength) + ' ' + start.y + ' L '\n            + (mid.x + capLength) + ' ' + start.y : '';\n        capDirection += (direction === 'Minus' || direction === 'Both') ? 'M ' + (mid.x - capLength) + ' ' + end.y + ' L '\n            + (mid.x + capLength) + ' ' + end.y : '';\n        return [path, capDirection];\n    };\n    ErrorBar.prototype.getBothDirection = function (start, mid, end, direction, errorMode, capLength) {\n        var capDirection = '';\n        var path = '';\n        var pathH = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);\n        var pathV = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);\n        path = pathH[0].concat(pathV[0]);\n        capDirection = pathH[1].concat(pathV[1]);\n        return [path, capDirection];\n    };\n    ErrorBar.prototype.getErrorDirection = function (start, mid, end, series, isInverted) {\n        var direction = series.errorBar.direction;\n        var mode = series.errorBar.mode;\n        var capLength = series.errorBar.errorBarCap.length;\n        var paths;\n        var errorMode = mode;\n        switch (mode) {\n            case 'Both':\n                errorMode = mode;\n                break;\n            case 'Horizontal':\n                errorMode = (isInverted) ? 'Vertical' : mode;\n                break;\n            case 'Vertical':\n                errorMode = (isInverted) ? 'Horizontal' : mode;\n                break;\n        }\n        switch (errorMode) {\n            case 'Horizontal':\n                paths = this.getHorizontalDirection(start, mid, end, direction, errorMode, capLength);\n                break;\n            case 'Vertical':\n                paths = this.getVerticalDirection(start, mid, end, direction, errorMode, capLength);\n                break;\n            case 'Both':\n                paths = this.getBothDirection(start, mid, end, direction, errorMode, capLength);\n                break;\n        }\n        return [paths[0], paths[1]];\n    };\n    // mean calculation for standard deviation and standard error\n    ErrorBar.prototype.meanCalculation = function (series, mode) {\n        var sumOfX = 0;\n        var sumOfY = 0;\n        var verticalMean = 0;\n        var horizontalMean = 0;\n        var length = series.points.length;\n        switch (mode) {\n            case 'Vertical':\n                sumOfY = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(series.yData);\n                verticalMean = sumOfY / length;\n                break;\n            case 'Horizontal':\n                sumOfX = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(series.xData);\n                horizontalMean = sumOfX / length;\n                break;\n            case 'Both':\n                sumOfY = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(series.yData);\n                verticalMean = sumOfY / length;\n                sumOfX = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.sum)(series.xData);\n                horizontalMean = sumOfX / length;\n        }\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            if (mode === 'Vertical') {\n                sumOfY = sumOfY + Math.pow((point.yValue - verticalMean), 2);\n            }\n            else if (mode === 'Horizontal') {\n                sumOfX = sumOfX + Math.pow((point.xValue - horizontalMean), 2);\n            }\n            else {\n                sumOfY = sumOfY + Math.pow((point.yValue - verticalMean), 2);\n                sumOfX = sumOfX + Math.pow((point.xValue - horizontalMean), 2);\n            }\n        }\n        var verStandardMean = sumOfY / (length - 1);\n        var verSquareRoot = Math.sqrt(sumOfY / (length - 1));\n        var horStandardMean = sumOfX / (length - 1);\n        var horSquareRoot = Math.sqrt(sumOfX / (length - 1));\n        return new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.Mean(verStandardMean, verSquareRoot, horStandardMean, horSquareRoot, verticalMean, horizontalMean);\n    };\n    ErrorBar.prototype.createElement = function (series, chart) {\n        // const explodeValue: number = 5;\n        var transform = chart.chartAreaType === 'Cartesian' ?\n            'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';\n        var markerHeight = (series.marker.height) / 2;\n        var markerWidth = (series.marker.width) / 2;\n        if (chart.chartAreaType === 'Cartesian') {\n            var options = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.RectOption(chart.element.id + '_ChartErrorBarClipRect_' + series.index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                x: -markerWidth, y: -markerHeight,\n                width: series.clipRect.width + markerWidth * 2, height: series.clipRect.height + markerHeight * 2\n            });\n            series.errorBarElement = chart.renderer.createGroup({\n                'id': chart.element.id + 'ErrorBarGroup' + series.index,\n                'transform': transform,\n                'clip-path': 'url(#' + chart.element.id + '_ChartErrorBarClipRect_' + series.index + ')'\n            });\n            if (series.errorBarElement) {\n                series.errorBarElement.appendChild((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.appendClipElement)(chart.redraw, options, chart.renderer));\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    ErrorBar.prototype.doErrorBarAnimation = function (series) {\n        var errorBarElements = series.errorBarElement.childNodes;\n        if (!errorBarElements) {\n            return null;\n        }\n        var delay = series.animation.delay + ((series.animation.duration === 0 && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.animationMode === 'Enable') ? 1000 : series.animation.duration);\n        var j = 1;\n        while (j < errorBarElements.length) {\n            for (var i = 0; i < series.points.length; i++) {\n                if (!series.points[i].symbolLocations[0]) {\n                    continue;\n                }\n                errorBarElements[j].style.visibility = 'hidden';\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.templateAnimate)(errorBarElements[j], delay, 350, series.chart.requireInvertedAxis ? 'SlideLeftIn' : 'SlideBottomIn', false);\n            }\n            j++;\n        }\n    };\n    /**\n     * Get module name.\n     */\n    ErrorBar.prototype.getModuleName = function () {\n        // Returns the module name\n        return 'ErrorBar';\n    };\n    /**\n     * To destroy the errorBar for series.\n     *\n     * @returns {void}\n     * @private\n     */\n    ErrorBar.prototype.destroy = function () {\n        // Destroy method performed here\n    };\n    return ErrorBar;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/error-bar.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/hilo-open-close-series.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/hilo-open-close-series.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HiloOpenCloseSeries: () => (/* binding */ HiloOpenCloseSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `HiloOpenCloseSeries` module is used to render the hilo open close series.\n */\nvar HiloOpenCloseSeries = /** @class */ (function (_super) {\n    __extends(HiloOpenCloseSeries, _super);\n    function HiloOpenCloseSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sideBySideInfo = [];\n        return _this;\n    }\n    /**\n     * Render HiloOpenCloseSeries series.\n     *\n     * @returns {void}\n     * @private\n     */\n    HiloOpenCloseSeries.prototype.render = function (series) {\n        this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);\n        var borderWidth = Math.max(series.border.width, 2);\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            this.renderPoint(series, point, this.sideBySideInfo[series.index], borderWidth);\n        }\n    };\n    HiloOpenCloseSeries.prototype.renderPoint = function (series, point, sideBySideInfo, borderWidth) {\n        point.symbolLocations = [];\n        point.regions = [];\n        var highLowRect;\n        var index1;\n        var index2;\n        if (point.visible &&\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n            //highlow\n            highLowRect = this.getRectangle(point.xValue + sideBySideInfo.start, Math.max(point.high, point.low), point.xValue + sideBySideInfo.end, Math.min(point.high, point.low), series);\n            point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.median, Math.max(point.high, point.low), point.xValue + sideBySideInfo.median, Math.min(point.high, point.low), series));\n            this.updateTickRegion(!series.chart.requireInvertedAxis, point.regions[0], borderWidth);\n            //open\n            point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.start, Math.max(point.open, point.close), point.xValue + sideBySideInfo.median, Math.max(point.open, point.close), series));\n            //close\n            point.regions.push(this.getRectangle(point.xValue + sideBySideInfo.median, Math.min(point.open, point.close), point.xValue + sideBySideInfo.end, Math.min(point.open, point.close), series));\n            var argsData = this.triggerPointRenderEvent(series, point);\n            if (!argsData.cancel) {\n                this.updateSymbolLocation(point, point.regions[0], series);\n                index1 = point.open > point.close ? 1 : 2;\n                index2 = point.open > point.close ? 2 : 1;\n                var open_1 = { x: point.regions[index1].x, y: point.regions[index1].y };\n                var close_1 = { x: point.regions[index2].x, y: point.regions[index2].y };\n                this.drawHiloOpenClosePath(series, point, open_1, close_1, highLowRect, argsData);\n            }\n            this.updateTickRegion(series.chart.requireInvertedAxis, point.regions[1], borderWidth);\n            this.updateTickRegion(series.chart.requireInvertedAxis, point.regions[2], borderWidth);\n        }\n    };\n    HiloOpenCloseSeries.prototype.updateDirection = function (series, point) {\n        var borderWidth = Math.max(series.border.width, 2);\n        for (var i = 0; i < point.length; i++) {\n            this.renderPoint(series, series.points[point[i]], this.sideBySideInfo[series.index], borderWidth);\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * Updates the tick region based on the specified parameters.\n     *\n     * @param {boolean} horizontal - Specifies whether the tick region is horizontal.\n     * @param {Rect} region - The region to update.\n     * @param {number} borderWidth - The width of the border.\n     * @returns {void}\n     */\n    HiloOpenCloseSeries.prototype.updateTickRegion = function (horizontal, region, borderWidth) {\n        if (horizontal) {\n            region.x -= borderWidth / 2;\n            region.width = borderWidth;\n        }\n        else {\n            region.y -= borderWidth / 2;\n            region.height = borderWidth;\n        }\n    };\n    /**\n     * Triggers the point render event and returns the event arguments.\n     *\n     * @param {Series} series - The series associated with the point.\n     * @param {Points} point - The data point.\n     * @returns {IPointRenderEventArgs} The event arguments.\n     */\n    HiloOpenCloseSeries.prototype.triggerPointRenderEvent = function (series, point) {\n        var fill = (point.open <= point.close) ? series.bearFillColor || series.chart.themeStyle.bearFillColor :\n            series.bullFillColor || series.chart.themeStyle.bullFillColor;\n        var border = { color: series.border.color, width: Math.max(series.border.width, 1) };\n        return this.triggerEvent(series, point, fill, border);\n    };\n    /**\n     * Draws the path for high, low, open, and close values in the series.\n     *\n     * @param {Series} series - The series associated with the point.\n     * @param {Points} point - The data point.\n     * @param {ChartLocation} open - The location of the open value.\n     * @param {ChartLocation} close - The location of the close value.\n     * @param {Rect} rect - The rectangle bounds.\n     * @param {IPointRenderEventArgs} argsData - The event arguments.\n     * @returns {void}\n     */\n    HiloOpenCloseSeries.prototype.drawHiloOpenClosePath = function (series, point, open, close, rect, argsData) {\n        // region highlow\n        var direction;\n        if (series.chart.requireInvertedAxis) {\n            direction = ('M' + ' ' + (rect.x) + ' ' + (rect.y + rect.height / 2) + ' ' +\n                'L' + ' ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height / 2) + ' ');\n            direction += ('M' + ' ' + (open.x) + ' ' + (rect.y + rect.height / 2) + ' ' +\n                'L' + ' ' + (open.x) + ' ' + (rect.y + rect.height) + ' ');\n            direction += ('M' + ' ' + (close.x) + ' ' + (rect.y + rect.height / 2) + ' ' +\n                'L' + ' ' + (close.x) + ' ' + (rect.y) + ' ');\n        }\n        else {\n            direction = ('M' + ' ' + (rect.x + rect.width / 2) + ' ' + (rect.y + rect.height) + ' ' +\n                'L' + ' ' + (rect.x + rect.width / 2) + ' ' + (rect.y) + ' ');\n            //region opentick\n            direction += ('M' + ' ' + (rect.x) + ' ' + (open.y) + ' ' +\n                'L' + ' ' + (rect.x + rect.width / 2 + argsData.border.width / 2) + ' ' + (open.y) + ' ');\n            //region closetick\n            direction += ('M' + ' ' + (rect.x + rect.width / 2 - argsData.border.width / 2) + ' ' + (close.y) + ' ' +\n                'L' + ' ' + (rect.x + rect.width) + ' ' + (close.y) + ' ');\n        }\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + ((series.removedPointIndex !== null && series.removedPointIndex <= point.index) ? (point.index + 1) : point.index), argsData.fill, argsData.border.width, argsData.fill, series.opacity, series.dashArray, direction);\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.pathAnimation)((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getElement)(options.id), direction, series.chart.redraw, null, series.chart.duration);\n        var element = series.chart.renderer.drawPath(options, new Int32Array([series.clipRect.x, series.clipRect.y]));\n        if (series.removedPointIndex !== null && series.removedPointIndex <= point.index) {\n            element.id = series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index;\n        }\n        element.setAttribute('role', 'img');\n        element.setAttribute('aria-label', series.accessibility.accessibilityDescriptionFormat ? series.formatAccessibilityDescription(point, series) : (point.x.toString() + ':' + point.high.toString()\n            + ':' + point.low.toString() + ':' + point.close.toString() + ':' + point.open.toString()));\n        if (!series.chart.enableCanvas) {\n            series.seriesElement.appendChild(element);\n        }\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    HiloOpenCloseSeries.prototype.getModuleName = function () {\n        return 'HiloOpenCloseSeries';\n        /**\n         * return the module name.\n         */\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    HiloOpenCloseSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * To destroy the column series.\n     *\n     * @returns {void}\n     * @private\n     */\n    HiloOpenCloseSeries.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    return HiloOpenCloseSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_2__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/hilo-open-close-series.js?");

/***/ })

}]);