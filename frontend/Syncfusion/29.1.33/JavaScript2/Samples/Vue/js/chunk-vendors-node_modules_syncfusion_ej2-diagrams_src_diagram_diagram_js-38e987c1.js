"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_diagram_js-38e987c1"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Diagram: () => (/* binding */ Diagram)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _rendering_canvas_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rendering/canvas-renderer */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/canvas-renderer.js\");\n/* harmony import */ var _rendering_svg_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rendering/svg-renderer */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/svg-renderer.js\");\n/* harmony import */ var _rendering_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rendering/renderer */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/renderer.js\");\n/* harmony import */ var _diagram_page_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./diagram/page-settings */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/page-settings.js\");\n/* harmony import */ var _objects_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./objects/service */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/service.js\");\n/* harmony import */ var _core_containers_container__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/containers/container */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/container.js\");\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _diagram_grid_lines__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diagram/grid-lines */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/grid-lines.js\");\n/* harmony import */ var _diagram_ruler_settings__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./diagram/ruler-settings */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/ruler-settings.js\");\n/* harmony import */ var _ruler_ruler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ruler/ruler */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/ruler/ruler.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _core_elements_path_element__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./core/elements/path-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _objects_dictionary_common__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./objects/dictionary/common */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/dictionary/common.js\");\n/* harmony import */ var _objects_annotation__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./objects/annotation */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/annotation.js\");\n/* harmony import */ var _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./core/containers/canvas */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/canvas.js\");\n/* harmony import */ var _core_containers_grid__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./core/containers/grid */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/grid.js\");\n/* harmony import */ var _diagram_data_source__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./diagram/data-source */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/data-source.js\");\n/* harmony import */ var _layout_layout_base__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./layout/layout-base */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/layout-base.js\");\n/* harmony import */ var _interaction_event_handlers__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./interaction/event-handlers */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/event-handlers.js\");\n/* harmony import */ var _interaction_command_manager__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./interaction/command-manager */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/command-manager.js\");\n/* harmony import */ var _interaction_scroller__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./interaction/scroller */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/scroller.js\");\n/* harmony import */ var _interaction_actions__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./interaction/actions */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/actions.js\");\n/* harmony import */ var _interaction_spatial_search_spatial_search__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./interaction/spatial-search/spatial-search */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/spatial-search/spatial-search.js\");\n/* harmony import */ var _utility_dom_util__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./utility/dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _diagram_keyboard_commands__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./diagram/keyboard-commands */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/keyboard-commands.js\");\n/* harmony import */ var _utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./utility/constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _objects_tooltip__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./objects/tooltip */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/tooltip.js\");\n/* harmony import */ var _objects_port__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./objects/port */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/port.js\");\n/* harmony import */ var _diagram_layer__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./diagram/layer */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/layer.js\");\n/* harmony import */ var _core_elements_native_element__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./core/elements/native-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/native-element.js\");\n/* harmony import */ var _core_elements_html_element__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./core/elements/html-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/html-element.js\");\n/* harmony import */ var _interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./interaction/container-interaction */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js\");\n/* harmony import */ var _utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./utility/swim-lane-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js\");\n/* harmony import */ var _diagram_serialization_settings__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./diagram/serialization-settings */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/serialization-settings.js\");\n/* harmony import */ var _diagram_custom_cursor__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./diagram/custom-cursor */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram/custom-cursor.js\");\n/* harmony import */ var _interaction_line_routing__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./interaction/line-routing */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-routing.js\");\n/* harmony import */ var _diagram_diagram_settings__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ../diagram/diagram-settings */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram-settings.js\");\n/* harmony import */ var _core_containers_stack_panel__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./core/containers/stack-panel */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/stack-panel.js\");\n/* harmony import */ var _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./objects/fixed-user-handle */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/fixed-user-handle.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _utility_uml_util__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./utility/uml-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/uml-util.js\");\n/* harmony import */ var _utility_connector__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./utility/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable prefer-spread */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-returns */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Represents the Diagram control\n * ```html\n * <div id='diagram'/>\n * ```\n * ```typescript\n * let diagram: Diagram = new Diagram({\n * width:'1000px', height:'500px' });\n * diagram.appendTo('#diagram');\n * ```\n */\nvar Diagram = /** @class */ (function (_super) {\n    __extends(Diagram, _super);\n    /**\n     * Constructor for creating the widget\n     */\n    function Diagram(options, element) {\n        var _this = _super.call(this, options, element) || this;\n        /** @private */\n        _this.version = 17.1;\n        /** @private */\n        _this.checkMenu = false;\n        /** @private */\n        _this.isServerUpdate = false;\n        /** @private */\n        _this.oldNodeObjects = [];\n        /** @private */\n        _this.oldDiagramObject = {};\n        /** @private */\n        _this.oldConnectorObjects = [];\n        /** @private */\n        _this.canEnableBlazorObject = false;\n        /** @private */\n        _this.connectorTable = {};\n        /** @private */\n        _this.groupTable = {};\n        /** @private */\n        _this.scrollActions = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ScrollActions.None;\n        /** @private */\n        _this.blazorActions = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.Default;\n        /** @private */\n        _this.activeLabel = { id: '', parentId: '', isGroup: false, text: undefined };\n        /** @private */\n        _this.textEditing = false;\n        /** @private */\n        _this.isTriggerEvent = false;\n        /** @private */\n        _this.preventNodesUpdate = false;\n        /** @private */\n        _this.preventConnectorsUpdate = false;\n        /** @private */\n        _this.callBlazorModel = true;\n        /** @private */\n        _this.selectionConnectorsList = [];\n        /** @private */\n        _this.deleteVirtualObject = false;\n        _this.canLayout = true;\n        _this.cancelPositionChange = false;\n        _this.isRefreshed = false;\n        /** @private */\n        _this.swimlaneChildTable = {};\n        /** @private */\n        _this.swimlaneZIndexTable = {};\n        /** @private */\n        _this.canExpand = false;\n        _this.changedConnectorCollection = [];\n        _this.changedNodesCollection = [];\n        _this.previousNodeCollection = [];\n        _this.previousConnectorCollection = [];\n        _this.crudDeleteNodes = [];\n        _this.previousSelectedObjects = [];\n        // Group update to server when BlazorAction is isGroupAction;\n        _this.blazorAddorRemoveCollection = [];\n        _this.blazorRemoveIndexCollection = [];\n        _this.diagramid = 88123;\n        _this.portCenterPoint = [];\n        /** @private */\n        _this.selectedObject = { helperObject: undefined, actualObject: undefined };\n        /** @private */\n        _this.deleteDependentConnector = true;\n        /** @private */\n        _this.scaleValue = 1;\n        _this.routedConnectors = [];\n        /** @private */\n        _this.pathDataStorage = new Map();\n        // To check current action is undo or redo\n        _this.isUndo = false;\n        _this.mermaidNodeBaseCollection = [];\n        _this.bangShape = 'M0 0 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,-3.7200001525878905 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 25.78437614440918,3.7200001525878905 a15.470625686645507,15.470625686645507 1 0,0 15.470625686645507,12.276000503540038 a12.376500549316406,12.376500549316406 1 0,0 0,12.648000518798828 a15.470625686645507,15.470625686645507 1 0,0 -15.470625686645507,12.276000503540038 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,5.580000228881835 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,0 a15.470625686645507,15.470625686645507 1 0,0 -25.78437614440918,-5.580000228881835 a15.470625686645507,15.470625686645507 1 0,0 -10.313750457763673,-12.276000503540038 a12.376500549316406,12.376500549316406 1 0,0 0,-12.648000518798828 a15.470625686645507,15.470625686645507 1 0,0 10.313750457763673,-12.276000503540038 H0 V0 Z';\n        _this.cloudShape = 'M0 0 a16.18875045776367,16.18875045776367 0 0,1 26.981250762939453,-10.792500305175782 a37.77375106811523,37.77375106811523 1 0,1 43.17000122070313,-10.792500305175782 a26.981250762939453,26.981250762939453 1 0,1 37.77375106811523,21.585000610351564 a16.18875045776367,16.18875045776367 1 0,1 16.18875045776367,13.020000534057615 a21.585000610351564,21.585000610351564 1 0,1 -16.18875045776367,24.180000991821288 a26.981250762939453,16.18875045776367 1 0,1 -26.981250762939453,16.18875045776367 a37.77375106811523,37.77375106811523 1 0,1 -53.962501525878906,0 a16.18875045776367,16.18875045776367 1 0,1 -26.981250762939453,-16.18875045776367 a16.18875045776367,16.18875045776367 1 0,1 -10.792500305175782,-13.020000534057615 a21.585000610351564,21.585000610351564 1 0,1 10.792500305175782,-24.180000991821288 H0 V0 Z';\n        _this.renderTimer = null;\n        var child;\n        var node;\n        //Removed isBlazor code\n        _this.ignoreCollectionWatch = true;\n        for (var i = 0; options && options.nodes && i < options.nodes.length; i++) {\n            child = options.nodes[parseInt(i.toString(), 10)];\n            node = _this.nodes[parseInt(i.toString(), 10)];\n            if (child.children && child.children.length > 0) {\n                if (!child.style || !child.style.fill) {\n                    node.style.fill = 'transparent';\n                }\n                if (!child.style || !child.style.strokeColor) {\n                    node.style.strokeColor = 'transparent';\n                }\n            }\n            if (child.shape && child.shape.type === 'UmlActivity') {\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.setUMLActivityDefaults)(child, node);\n            }\n            if (child.shape && child.shape.type === 'SwimLane') {\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.setSwimLaneDefaults)(child, node);\n            }\n            // Removed isBlazor code\n            if (_this.nodeDefaults) {\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateDefaultValues)(node, child, _this.nodeDefaults);\n            }\n            _this.updateAnnotationText(node.annotations);\n        }\n        if (options && options.connectors) {\n            for (var i = 0; options && options.connectors && i < options.connectors.length; i++) {\n                child = options.connectors[parseInt(i.toString(), 10)];\n                node = _this.connectors[parseInt(i.toString(), 10)];\n                //Removed isBlazor code\n                if (_this.connectorDefaults) {\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateDefaultValues)(node, child, _this.connectorDefaults);\n                }\n                _this.updateAnnotationText(node.annotations);\n            }\n        }\n        for (var i = 0; options && options.connectors && i < options.connectors.length; i++) {\n            var defaultConnector = options.connectors[parseInt(i.toString(), 10)];\n            var connector = _this.connectors[parseInt(i.toString(), 10)];\n            if (defaultConnector.shape && defaultConnector.shape.type !== 'None') {\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.setConnectorDefaults)(defaultConnector, connector);\n            }\n            //Removed isBlazor code\n        }\n        return _this;\n    }\n    Diagram.prototype.updateAnnotationText = function (annotations) {\n        //Removed isBlazor code\n    };\n    Diagram.prototype.clearCollection = function (isConnector) {\n        var collection = [];\n        var obj;\n        for (var _i = 0, _a = Object.keys(this.nameTable); _i < _a.length; _i++) {\n            var key = _a[_i];\n            obj = this.nameTable[\"\" + key];\n            if (obj && ((isConnector && obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) || (!isConnector && obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node))) {\n                collection.push(obj);\n            }\n        }\n        this.clearObjects(collection);\n    };\n    /**\n     * Updates the diagram control when the objects are changed by comparing new and old property values.\n     *\n     * @param {DiagramModel} newProp - A object that lists the new values of the changed properties.\n     * @param {DiagramModel} oldProp - A object that lists the old values of the changed properties.\n     */\n    /* tslint:disable */\n    Diagram.prototype.onPropertyChanged = function (newProp, oldProp) {\n        var _this = this;\n        // Model Changed\n        // Bug 842506: After multiple group node rotations, the undo functionality is not working.\n        // Below condition is used to restrict onPropertyChange when we rotate group node using button at runtime.\n        if (!this.rotateUsingButton) {\n            var newValue = void 0;\n            var oldValue = void 0;\n            var isPropertyChanged = true;\n            var refreshLayout = false;\n            var refereshColelction = false;\n            var bpmnAnnotationConnector = void 0;\n            if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) {\n                for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    switch (prop) {\n                        case 'width':\n                        case 'height':\n                            this.element.style.width = this.getSizeValue(this.width);\n                            this.element.style.height = this.getSizeValue(this.height);\n                            this.eventHandler.updateViewPortSize(this.element);\n                            for (var _b = 0, _c = this.views; _b < _c.length; _b++) {\n                                var view = _c[_b];\n                                var temp = this.views[\"\" + view];\n                                if (!(temp instanceof Diagram)) {\n                                    temp.updateView(temp);\n                                }\n                            }\n                            break;\n                        case 'nodes':\n                            if (newProp.nodes.length > 0 && oldProp.nodes.length === 0) {\n                                this.clearCollection();\n                                refereshColelction = true;\n                            }\n                            else {\n                                for (var _d = 0, _e = Object.keys(newProp.nodes); _d < _e.length; _d++) {\n                                    var key = _e[_d];\n                                    var index = Number(key);\n                                    var actualObject = this.nodes[parseInt(index.toString(), 10)];\n                                    var changedProp = newProp.nodes[parseInt(index.toString(), 10)];\n                                    if (newProp.nodes[parseInt(index.toString(), 10)].style\n                                        && newProp.nodes[parseInt(index.toString(), 10)].style.gradient) {\n                                        this.updateGradient(newProp.nodes[parseInt(index.toString(), 10)], oldProp.nodes[parseInt(index.toString(), 10)], this.nodes[parseInt(index.toString(), 10)]);\n                                        this.nodes[parseInt(index.toString(), 10)].oldGradientValue\n                                            = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(newProp.nodes[parseInt(index.toString(), 10)].style.gradient);\n                                    }\n                                    refreshLayout = refreshLayout || changedProp.excludeFromLayout !== undefined;\n                                    /* eslint-disable */\n                                    if (newProp.nodes[index] && newProp.nodes[index].shape\n                                        && newProp.nodes[index].shape.textAnnotation\n                                        && newProp.nodes[index].shape.textAnnotation.textAnnotationTarget !== '') {\n                                        bpmnAnnotationConnector = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.nameTable[actualObject.inEdges[0]]);\n                                    }\n                                    /* eslint-enable */\n                                    this.nodePropertyChange(actualObject, oldProp.nodes[parseInt(index.toString(), 10)], changedProp, undefined, true, true);\n                                    var args = {\n                                        element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(actualObject), cause: this.diagramActions,\n                                        diagramAction: this.getDiagramAction(this.diagramActions),\n                                        oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(oldProp.nodes[parseInt(index.toString(), 10)]),\n                                        newValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(newProp.nodes[parseInt(index.toString(), 10)])\n                                    };\n                                    // Removed isBlazor code\n                                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.propertyChange, args);\n                                    if (isPropertyChanged) {\n                                        isPropertyChanged = false;\n                                    }\n                                }\n                                if (this.mode === 'Canvas') {\n                                    this.refreshDiagramLayer();\n                                }\n                            }\n                            break;\n                        case 'connectors':\n                            // eslint-disable-next-line no-case-declarations\n                            var oldObject = void 0;\n                            if (newProp.connectors.length > 0 && oldProp.connectors.length === 0) {\n                                this.clearCollection(true);\n                                refereshColelction = true;\n                            }\n                            else {\n                                for (var _f = 0, _g = Object.keys(newProp.connectors); _f < _g.length; _f++) {\n                                    var key = _g[_f];\n                                    var index = Number(key);\n                                    var actualObject = this.connectors[parseInt(index.toString(), 10)];\n                                    var changedProp = newProp.connectors[parseInt(index.toString(), 10)];\n                                    // 927220: Improper Connector State After Undo When Connecting via Button\n                                    var changedPoints = {\n                                        sourcePoint: { x: actualObject.sourcePoint.x, y: actualObject.sourcePoint.y },\n                                        targetPoint: { x: actualObject.targetPoint.x, y: actualObject.targetPoint.y }\n                                    };\n                                    if (changedProp && (changedProp.sourceDecorator || changedProp.targetDecorator)) {\n                                        this.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DecoratorPropertyChange;\n                                    }\n                                    this.connectorPropertyChange(actualObject, oldProp.connectors[parseInt(index.toString(), 10)], changedProp, true, true);\n                                    // 927220: Improper Connector State After Undo When Connecting via Button\n                                    if (newProp.connectors[parseInt(index.toString(), 10)].sourceID &&\n                                        !newProp.connectors[parseInt(index.toString(), 10)].sourcePoint) {\n                                        oldProp.connectors[parseInt(index.toString(), 10)].sourcePoint = {\n                                            x: changedPoints.sourcePoint.x,\n                                            y: changedPoints.sourcePoint.y\n                                        };\n                                        newProp.connectors[parseInt(index.toString(), 10)].sourcePoint = {\n                                            x: actualObject.sourcePoint.x,\n                                            y: actualObject.sourcePoint.y\n                                        };\n                                    }\n                                    if (newProp.connectors[parseInt(index.toString(), 10)].targetID &&\n                                        !newProp.connectors[parseInt(index.toString(), 10)].targetPoint) {\n                                        oldProp.connectors[parseInt(index.toString(), 10)].targetPoint = {\n                                            x: changedPoints.targetPoint.x,\n                                            y: changedPoints.targetPoint.y\n                                        };\n                                        newProp.connectors[parseInt(index.toString(), 10)].targetPoint = {\n                                            x: actualObject.targetPoint.x,\n                                            y: actualObject.targetPoint.y\n                                        };\n                                    }\n                                    if (changedProp && (changedProp.sourceDecorator || changedProp.targetDecorator)) {\n                                        this.diagramActions = this.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DecoratorPropertyChange;\n                                    }\n                                    var args = {\n                                        element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(actualObject), cause: this.diagramActions,\n                                        diagramAction: this.getDiagramAction(this.diagramActions),\n                                        oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(oldProp.connectors[parseInt(index.toString(), 10)]),\n                                        newValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(newProp.connectors[parseInt(index.toString(), 10)])\n                                    };\n                                    // Removed isBlazor code\n                                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.propertyChange, args);\n                                    if (actualObject && actualObject.parentId && this.nameTable[actualObject.parentId].shape.type === 'UmlClassifier') {\n                                        this.updateConnectorEdges(this.nameTable[actualObject.parentId] || actualObject);\n                                    }\n                                    if (isPropertyChanged) {\n                                        isPropertyChanged = false;\n                                    }\n                                }\n                                this.updateBridging();\n                                if (this.mode === 'Canvas') {\n                                    this.refreshDiagramLayer();\n                                }\n                            }\n                            break;\n                        case 'bridgeDirection':\n                            this.updateBridging();\n                            if (this.mode === 'Canvas') {\n                                this.refreshDiagramLayer();\n                            }\n                            break;\n                        case 'backgroundColor':\n                            this.intOffPageBackground();\n                            break;\n                        case 'pageSettings':\n                            this.validatePageSize();\n                            this.updatePage();\n                            break;\n                        case 'selectedItems':\n                            if (newProp.selectedItems.userHandles && this.selectedItems.wrapper && this.selectedItems.userHandles) {\n                                if (this.selectedItems.userHandles.length > 0) {\n                                    this.renderSelector(true);\n                                    break;\n                                }\n                            }\n                            if (newProp.selectedItems.constraints) {\n                                this.renderSelector(true);\n                                break;\n                            }\n                            break;\n                        case 'snapSettings':\n                            this.updateSnapSettings(newProp);\n                            break;\n                        case 'commandManager':\n                            this.initCommands();\n                            break;\n                        case 'layout':\n                            refreshLayout = true;\n                            break;\n                        case 'segmentThumbShape':\n                            this.updateSelector();\n                            break;\n                        case 'dataSourceSettings':\n                            this.clear();\n                            if (this.layout.type === 'None') {\n                                refereshColelction = true;\n                            }\n                            else {\n                                //EJ2-837322- Duplicate nodes and connectors are created after reset for layout type 'None'\n                                this.initObjects();\n                                refreshLayout = true;\n                            }\n                            break;\n                        case 'tooltip':\n                            (0,_objects_tooltip__WEBPACK_IMPORTED_MODULE_33__.initTooltip)(this);\n                            break;\n                        case 'rulerSettings':\n                            this.updateRulerSettings(newProp);\n                            break;\n                        case 'layers':\n                            this.updateLayer(newProp);\n                            break;\n                        case 'scrollSettings':\n                            this.scrollActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ScrollActions.PropertyChange;\n                            this.updateScrollSettings(newProp);\n                            this.scrollActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ScrollActions.PropertyChange;\n                            this.scrollSettings.horizontalOffset = -this.scroller.horizontalOffset || 0;\n                            this.scrollSettings.verticalOffset = -this.scroller.verticalOffset || 0;\n                            break;\n                        case 'locale':\n                            if (newProp.locale !== oldProp.locale) {\n                                // 927339: Diagram Layout Rendering correctly When Locale is Set by removing the line\n                                _super.prototype.refresh.call(this);\n                            }\n                            break;\n                        case 'contextMenuSettings':\n                            if (newProp.contextMenuSettings.showCustomMenuOnly !== undefined) {\n                                this.contextMenuSettings.showCustomMenuOnly = newProp.contextMenuSettings.showCustomMenuOnly;\n                            }\n                            if (newProp.contextMenuSettings.show !== undefined) {\n                                this.contextMenuSettings.show = newProp.contextMenuSettings.show;\n                            }\n                            if (newProp.contextMenuSettings.items) {\n                                var items = newProp.contextMenuSettings.items;\n                                for (var _h = 0, _j = Object.keys(items); _h < _j.length; _h++) {\n                                    var key = _j[_h];\n                                    var index = Number(key);\n                                    this.contextMenuSettings.items[parseInt(index.toString(), 10)] = items[parseInt(index.toString(), 10)];\n                                }\n                                if (this.contextMenuModule) {\n                                    this.contextMenuModule.refreshItems();\n                                }\n                                else {\n                                    console.warn('[WARNING] :: Module \"DiagramContextMenu\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n                                }\n                            }\n                            break;\n                        case 'serializationSettings':\n                            if (newProp.serializationSettings.preventDefaults !== undefined) {\n                                this.serializationSettings.preventDefaults = newProp.serializationSettings.preventDefaults;\n                            }\n                            break;\n                        case 'tool':\n                            // 912436: Mouse cursor flickers when entering the diagram canvas after the tool is changed at runtime\n                            this.eventHandler.updateTool();\n                            break;\n                    }\n                }\n                if (refreshLayout && !refereshColelction) {\n                    if (oldProp.layout && oldProp.layout.connectionPointOrigin === 'DifferentPoint' && newProp.layout.connectionPointOrigin === 'SamePoint'\n                        || (oldProp.layout && newProp.layout && !newProp.layout.enableRouting && oldProp.layout.enableRouting)) {\n                        for (var i = 0; i < this.nodes.length; i++) {\n                            var node = this.nodes[parseInt(i.toString(), 10)];\n                            if ((node.ports && node.ports.length > 0)) {\n                                var ports = [];\n                                for (var j = node.ports.length - 1; j >= 0; j--) {\n                                    if (node.ports[parseInt(j.toString(), 10)].id.split('_')[1] === 'LineDistribution') {\n                                        ports.push(node.ports[parseInt(j.toString(), 10)]);\n                                    }\n                                }\n                                this.removePorts(node, ports);\n                            }\n                        }\n                        for (var j = 0; j < this.connectors.length; j++) {\n                            var connector = this.connectors[parseInt(j.toString(), 10)];\n                            var sourcePortid = connector.sourcePortID;\n                            var targetPortId = connector.targetPortID;\n                            //const oldSegment: OrthogonalSegmentModel = (connector.segments as OrthogonalSegmentModel);\n                            connector.sourcePortID = '';\n                            connector.targetPortID = '';\n                            connector.sourcePortWrapper = undefined;\n                            connector.targetPortWrapper = undefined;\n                            connector.segments = [];\n                            this.connectorPropertyChange(connector, {\n                                sourcePortID: sourcePortid, targetPortID: targetPortId\n                            }, { sourcePortID: '', targetPortID: '' });\n                        }\n                    }\n                    this.doLayout();\n                    this.renderReactTemplates();\n                }\n                if (isPropertyChanged && this.propertyChange) {\n                    var args = {\n                        element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(this), cause: this.diagramActions,\n                        diagramAction: this.getDiagramAction(this.diagramActions),\n                        oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(oldProp), newValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(newProp)\n                    };\n                    // Removed isBlazor code\n                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.propertyChange, args);\n                }\n                /**Feature(EJ2-60228): Need to add Object ID in the history change event argument*/\n                if (!refereshColelction && (this.canLogChange()) && (this.modelChanged(newProp, oldProp))) {\n                    var propertyObjects = [];\n                    var nodeObjects = [];\n                    var connObjects = [];\n                    var nodeIndex = void 0;\n                    if (newProp.nodes && Object.keys(newProp.nodes).length > 0) {\n                        for (var _k = 0, _l = Object.keys(newProp.nodes); _k < _l.length; _k++) {\n                            var key = _l[_k];\n                            nodeIndex = parseInt(key, 10);\n                            nodeObjects.push(this.nodes[parseInt(nodeIndex.toString(), 10)].id);\n                        }\n                    }\n                    if (newProp.connectors && Object.keys(newProp.connectors).length > 0) {\n                        for (var _m = 0, _o = Object.keys(newProp.connectors); _m < _o.length; _m++) {\n                            var key = _o[_m];\n                            var connIndex = parseInt(key, 10);\n                            connObjects.push(this.connectors[parseInt(connIndex.toString(), 10)].id);\n                        }\n                    }\n                    propertyObjects = nodeObjects.concat(connObjects);\n                    //To prevent history entry for text annotation connector while dragging node.\n                    var textCon = connObjects.filter(function (id) { return _this.nameTable[\"\" + id].isBpmnAnnotationConnector; });\n                    /* eslint-disable */\n                    if (textCon.length === 0) {\n                        //historyEntry to store BPMNtextAnnotation connector positionchange.\n                        if (newProp.nodes && newProp.nodes[nodeIndex] && newProp.nodes[nodeIndex].shape\n                            && newProp.nodes[nodeIndex].shape.textAnnotation\n                            && newProp.nodes[nodeIndex].shape.textAnnotation.textAnnotationTarget !== '') {\n                            var obj = this.nameTable[this.nodes[parseInt(nodeIndex.toString(), 10)].inEdges[0]];\n                            this.startGroupAction();\n                            var connectorEntry = { type: 'ConnectionChanged', undoObject: bpmnAnnotationConnector, redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal' };\n                            var entry = { type: 'PropertyChanged', undoObject: oldProp, redoObject: newProp, category: 'Internal' };\n                            if (this.historyManager) {\n                                this.addHistoryEntry(connectorEntry);\n                                this.addHistoryEntry(entry, propertyObjects);\n                            }\n                            this.endGroupAction();\n                        }\n                        else {\n                            var entry = { type: 'PropertyChanged', undoObject: oldProp, redoObject: newProp, category: 'Internal' };\n                            if (this.historyManager) {\n                                this.addHistoryEntry(entry, propertyObjects);\n                            }\n                        }\n                    }\n                }\n                this.resetDiagramActions();\n                if (refereshColelction) {\n                    this.initObjects(true);\n                    this.refreshDiagramLayer();\n                    if (refreshLayout) {\n                        this.doLayout();\n                    }\n                }\n                var scrollAlone = ((Object.keys(newProp).length === 1) && newProp.scrollSettings !== undefined);\n                if (!refereshColelction) {\n                    for (var _p = 0, _q = this.views; _p < _q.length; _p++) {\n                        var temp = _q[_p];\n                        var view = this.views[\"\" + temp];\n                        if (!(view instanceof Diagram)) {\n                            if (newProp.scrollSettings && newProp.scrollSettings.currentZoom !== oldProp.scrollSettings.currentZoom) {\n                                //view.updateHtmlLayer(view);\n                            }\n                            if (!scrollAlone) {\n                                this.refreshCanvasDiagramLayer(view);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            this.rotateUsingButton = false;\n        }\n    };\n    /* tslint:enable */\n    Diagram.prototype.updateSnapSettings = function (newProp) {\n        if (newProp.snapSettings.constraints !== undefined || newProp.snapSettings.horizontalGridlines ||\n            newProp.snapSettings.verticalGridlines || newProp.snapSettings.gridType) {\n            this.diagramRenderer.updateGrid(this.snapSettings, (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getGridLayerSvg)(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);\n        }\n    };\n    // This private method has been specially provided to update only the node old gradient value in oldProperty.\n    // This issue belong to core team but we fixed in our end.\n    // https://syncfusion.atlassian.net/browse/EJ2-49232\n    Diagram.prototype.updateGradient = function (newProp, oldProp, nodeObj) {\n        if (nodeObj.oldGradientValue) {\n            var linearNode = nodeObj;\n            var radialNode = nodeObj;\n            var linearProp = oldProp.style.gradient;\n            var radialProp = oldProp.style.gradient;\n            for (var _i = 0, _a = Object.keys(newProp.style.gradient); _i < _a.length; _i++) {\n                var key = _a[_i];\n                switch (key) {\n                    case 'type':\n                        if (linearNode.type) {\n                            linearProp.type = linearNode.type;\n                        }\n                        break;\n                    case 'x1':\n                        if (linearNode.x1) {\n                            linearProp.x1 = linearNode.x1;\n                        }\n                        break;\n                    case 'x2':\n                        if (linearNode.x2) {\n                            linearProp.x2 = linearNode.x2;\n                        }\n                        break;\n                    case 'y1':\n                        if (linearNode.y1) {\n                            linearProp.y1 = linearNode.y1;\n                        }\n                        break;\n                    case 'y2':\n                        if (linearNode.y2) {\n                            linearProp.y2 = linearNode.y2;\n                        }\n                        break;\n                    case 'cx':\n                        if (radialNode.cx) {\n                            radialProp.cx = radialNode.cx;\n                        }\n                        break;\n                    case 'cy':\n                        if (radialNode.cy) {\n                            radialProp.cy = radialNode.cy;\n                        }\n                        break;\n                    case 'fx':\n                        if (radialNode.fx) {\n                            radialProp.fx = radialNode.fx;\n                        }\n                        break;\n                    case 'fy':\n                        if (radialNode.fy) {\n                            radialProp.fy = radialNode.fy;\n                        }\n                        break;\n                    case 'r':\n                        if (radialNode.r) {\n                            radialProp.r = radialNode.r;\n                        }\n                        break;\n                    case 'stops':\n                        if (nodeObj.oldGradientValue.stops) {\n                            var stops = (Object.values((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(nodeObj.oldGradientValue.stops)));\n                            stops.pop();\n                            oldProp.style.gradient.stops = stops;\n                        }\n                        break;\n                }\n            }\n        }\n    };\n    Diagram.prototype.updateRulerSettings = function (newProp) {\n        if (newProp.rulerSettings.dynamicGrid !== undefined) {\n            this.diagramRenderer.updateGrid(this.snapSettings, (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getGridLayerSvg)(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);\n        }\n        if (newProp.rulerSettings.showRulers !== undefined) {\n            this.intOffPageBackground();\n            this.scroller.setSize();\n            this.renderRulers();\n        }\n        else if (newProp.rulerSettings.horizontalRuler !== undefined ||\n            newProp.rulerSettings.verticalRuler !== undefined) {\n            if (newProp.rulerSettings.horizontalRuler.thickness !== undefined ||\n                newProp.rulerSettings.verticalRuler.thickness !== undefined) {\n                (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.removeRulerElements)(this);\n                this.intOffPageBackground();\n                this.scroller.setSize();\n                this.renderRulers();\n            }\n            else {\n                (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.updateRuler)(this);\n            }\n        }\n        this.diagramRenderer.updateGrid(this.snapSettings, (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getGridLayerSvg)(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);\n    };\n    /**\n     * Get the properties to be maintained in the persisted state.\n     *\n     * @returns {string}\n     */\n    Diagram.prototype.getPersistData = function () {\n        var keyEntity = ['loaded'];\n        return this.addOnPersist(keyEntity);\n    };\n    /**\n     * Initialize nodes, connectors and renderer\n     */\n    Diagram.prototype.preRender = function () {\n        this.initializePrivateVariables();\n        this.isProtectedOnChange = true;\n        this.serviceLocator = new _objects_service__WEBPACK_IMPORTED_MODULE_5__.ServiceLocator;\n        this.initializeServices();\n        this.setCulture();\n        var measureWindowElement = 'measureElement';\n        if (window[\"\" + measureWindowElement]) {\n            window[\"\" + measureWindowElement] = null;\n        }\n        this.initDiagram();\n        this.initViews();\n        this.unWireEvents();\n        this.wireEvents();\n        this.element.classList.add('e-diagram');\n    };\n    Diagram.prototype.initializePrivateVariables = function () {\n        if (this.element.id === '') {\n            var collection = document.getElementsByClassName('e-diagram').length;\n            this.element.id = 'diagram_' + this.diagramid + '_' + collection;\n        }\n        this.defaultLocale = {\n            Copy: 'Copy',\n            Cut: 'Cut',\n            Paste: 'Paste',\n            Undo: 'Undo',\n            Redo: 'Redo',\n            SelectAll: 'Select All',\n            Grouping: 'Grouping',\n            Group: 'Group',\n            UnGroup: 'Un Group',\n            Order: 'Order',\n            BringToFront: 'Bring To Front',\n            MoveForward: 'Move Forward',\n            SendToBack: 'Send To Back',\n            SendBackward: 'Send Backward'\n        };\n        this.layerZIndex = -1;\n        this.layerZIndexTable = {};\n        //878837 : initialize parameter for passing container as a parameter\n        if (this.swimlaneChildTable === undefined && this.swimlaneZIndexTable === undefined) {\n            this.swimlaneChildTable = {};\n            this.swimlaneZIndexTable = {};\n        }\n        this.nameTable = {};\n        this.pathTable = {};\n        this.groupTable = {};\n        this.commands = {};\n        if (!this.isLoading) {\n            this.views = [];\n        }\n        this.commandHandler = new _interaction_command_manager__WEBPACK_IMPORTED_MODULE_25__.CommandHandler(this);\n        this.eventHandler = new _interaction_event_handlers__WEBPACK_IMPORTED_MODULE_24__.DiagramEventHandler(this, this.commandHandler);\n        this.spatialSearch = new _interaction_spatial_search_spatial_search__WEBPACK_IMPORTED_MODULE_28__.SpatialSearch(this.nameTable);\n        this.scroller = new _interaction_scroller__WEBPACK_IMPORTED_MODULE_26__.DiagramScroller(this);\n    };\n    Diagram.prototype.initializeServices = function () {\n        this.serviceLocator.register('localization', this.localeObj = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.L10n(this.getModuleName(), this.defaultLocale, this.locale));\n    };\n    /**\n     * Method to set culture for chart\n     */\n    Diagram.prototype.setCulture = function () {\n        this.localeObj = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.L10n(this.getModuleName(), this.defaultLocale, this.locale);\n    };\n    /* tslint:disable */\n    /**\n     * Renders the diagram control with nodes and connectors\n     */\n    Diagram.prototype.render = function () {\n        if (this.refreshing && this.dataSourceSettings.dataSource && !this.isLoading) {\n            this.nodes = [];\n            this.connectors = [];\n        }\n        //830544-Support to add load event to notify before rendering of diagram\n        if (!this.refreshing) {\n            var loadEventData = {\n                diagram: this, name: 'load'\n            };\n            this.trigger('load', loadEventData);\n        }\n        // Bug 832897: Need to improve performance while rendering layout with large number of nodes.\n        this.isRefreshed = false;\n        this.ignoreCollectionWatch = true;\n        var domTable = 'domTable';\n        window[\"\" + domTable] = {};\n        var collapsedNode = [];\n        //Removed isBlazor code.\n        if (this.dataSourceSettings.crudAction.read) {\n            this.renderInitialCrud();\n        }\n        this.initHistory();\n        this.diagramRenderer = new _rendering_renderer__WEBPACK_IMPORTED_MODULE_3__.DiagramRenderer(this.element.id, new _rendering_svg_renderer__WEBPACK_IMPORTED_MODULE_2__.SvgRenderer(), this.mode === 'SVG');\n        this.initLayers();\n        this.initializeDiagramLayers();\n        this.diagramRenderer.setLayers();\n        this.initObjects(true);\n        var isLayout = false;\n        // Removed isBlazor code.\n        var nodes = this.nodes;\n        for (var i = 0; i < nodes.length; i++) {\n            if (!nodes[parseInt(i.toString(), 10)].isExpanded) {\n                collapsedNode.push(nodes[parseInt(i.toString(), 10)]);\n            }\n        }\n        if (collapsedNode.length) {\n            for (var i = collapsedNode.length - 1; i >= 0; i--) {\n                if (i === 0) {\n                    this.commandHandler.expandNode(collapsedNode[parseInt(i.toString(), 10)], this, false);\n                }\n                else {\n                    this.commandHandler.expandNode(collapsedNode[parseInt(i.toString(), 10)], this, true);\n                }\n            }\n        }\n        if (this.canLayout) {\n            this.doLayout();\n        }\n        if (isLayout) {\n            this.commandHandler.getBlazorOldValues();\n        }\n        if (this.lineRoutingModule) {\n            var previousConnectorObject = [];\n            var updateConnectorObject = [];\n            var changeConnectors = [];\n            //Removed isBlazor code.\n            // EJ2-65876 - Exception occurs on line routing injection module\n            //934719 - Line Routing is never executed during initial rendering\n            this.lineRoutingModule.lineRouting(this);\n            // Removed isBlazor code.\n        }\n        else if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting) {\n            console.warn('[WARNING] :: Module \"LineRouting\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n        this.validatePageSize();\n        this.renderPageBreaks();\n        this.diagramRenderer.renderSvgGridlines(this.snapSettings, (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getGridLayerSvg)(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);\n        this.commandHandler.initSelectorWrapper();\n        /**\n         * Used to render context menu\n         */\n        this.notify('initial-load', {});\n        /**\n         * Used to load context menu\n         */\n        this.trigger('load');\n        this.scroller.setSize();\n        this.scroller.updateScrollOffsets();\n        // Bug 832897: Need to improve performance while rendering layout with large number of nodes.\n        // If diagram not refreshed, then we will refresh the diagram.\n        if (!this.isRefreshed) {\n            this.refreshDiagramLayer();\n        }\n        //Bug 855677: After Serialization, Subprocess Node Dragging Faces Problems After Removing Child Node.\n        //Removed refreshDiagramLayer() method in this line as it causes the subprocess child node to be rendered twice in wrapper which causes the issue.\n        if (this.scrollSettings.verticalOffset > 0 || this.scrollSettings.horizontalOffset > 0) {\n            this.updateScrollOffset();\n        }\n        /**\n         * Used to end the context menu rendering\n         */\n        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice) {\n            this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.ZoomPan | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.SingleSelect;\n        }\n        this.notify('initial-end', {});\n        this.isProtectedOnChange = false;\n        this.tooltipObject = (0,_objects_tooltip__WEBPACK_IMPORTED_MODULE_33__.initTooltip)(this);\n        this.diagramActions = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render;\n        this.initCommands();\n        var hiddenUserHandleTemplate = document.getElementsByClassName(this.element.id + '_hiddenUserHandleTemplate');\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createUserHandleTemplates)(this.userHandleTemplate, hiddenUserHandleTemplate, this.selectedItems, this.element.id);\n        //Removed isBlazor code.\n        this.isLoading = false;\n        this.refreshRoutingConnectors();\n        this.renderComplete();\n        this.updateFitToPage();\n        if (this.refreshing) {\n            this.renderReactTemplates();\n        }\n    };\n    /* tslint:enable */\n    Diagram.prototype.updateFitToPage = function () {\n        if (this.pageSettings && this.pageSettings.fitOptions && this.pageSettings.fitOptions.canFit) {\n            this.fitToPage(this.pageSettings.fitOptions);\n        }\n    };\n    Diagram.prototype.updateTemplate = function () {\n        //Removed blazor code\n    };\n    //Call back function to the node template\n    // private measureNode(node: NodeModel): void {\n    //     if (node.shape.type === 'Native' && isBlazor()) {\n    //         node.wrapper.measure(new Size(node.width, node.height));\n    //         node.wrapper.arrange(node.wrapper.desiredSize);\n    //     }\n    // }\n    Diagram.prototype.renderInitialCrud = function () {\n        /* eslint-disable */\n        var tempObj = this;\n        /* eslint-enable */\n        if (tempObj.dataSourceSettings.crudAction.read) {\n            var callback = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Fetch(tempObj.dataSourceSettings.crudAction.read, 'GET');\n            callback.onSuccess = function (data) {\n                if (tempObj.dataSourceSettings.dataManager) {\n                    tempObj.dataSourceSettings.dataManager = JSON.parse(data);\n                }\n                else {\n                    tempObj.dataSourceSettings.dataSource = JSON.parse(data);\n                }\n                tempObj.dataBind();\n            };\n            callback.send().then();\n        }\n        if (tempObj.dataSourceSettings.connectionDataSource.crudAction.read) {\n            var callback = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Fetch(tempObj.dataSourceSettings.connectionDataSource.crudAction.read, 'GET');\n            callback.onSuccess = function (data) {\n                tempObj.dataSourceSettings.connectionDataSource.dataManager = JSON.parse(data);\n                tempObj.dataBind();\n            };\n            callback.send().then();\n        }\n    };\n    /**\n     * Retrieves the module name associated with the diagram.\n     *\n     * @returns {string}  Retrieves the module name associated with the diagram.\n     */\n    Diagram.prototype.getModuleName = function () {\n        return 'diagram';\n    };\n    /**\n     *\n     * Returns the name of class Diagram\n     * @returns {string}  Returns the module name of the diagram\n     * @private\n     */\n    Diagram.prototype.getClassName = function () {\n        return 'Diagram';\n    };\n    /* tslint:disable */\n    /**\n     * To provide the array of modules needed for control rendering\n     *\n     * @returns {ModuleDeclaration[]} To provide the array of modules needed for control rendering .\\\n     * @private\n     */\n    Diagram.prototype.requiredModules = function () {\n        var modules = [];\n        modules.push({\n            member: 'Bpmn',\n            args: []\n        });\n        modules.push({\n            member: 'Bridging',\n            args: []\n        });\n        modules.push({\n            member: 'ConnectorEditingTool',\n            args: []\n        });\n        //Removed isBlazor code\n        if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.UndoRedo) {\n            modules.push({\n                member: 'UndoRedo',\n                args: []\n            });\n        }\n        if (this.layout.type === 'OrganizationalChart' || this.layout.type === 'HierarchicalTree' ||\n            this.layout.enableAnimation) {\n            modules.push({\n                member: 'LayoutAnimate',\n                args: []\n            });\n        }\n        if (this.snapSettings.constraints) {\n            modules.push({\n                member: 'Snapping',\n                args: [this]\n            });\n        }\n        modules.push({\n            member: 'Ej1Serialization',\n            args: [this]\n        });\n        modules.push({\n            member: 'PrintandExport',\n            args: [this]\n        });\n        if (this.contextMenuSettings.show) {\n            modules.push({\n                member: 'contextMenu',\n                args: [this, this.serviceLocator]\n            });\n        }\n        if (this.layout.type === 'OrganizationalChart' || this.layout.type === 'HierarchicalTree') {\n            modules.push({\n                member: 'OrganizationalChart',\n                args: [this]\n            });\n        }\n        if (this.layout.type === 'ComplexHierarchicalTree') {\n            modules.push({\n                member: 'ComplexHierarchicalTree',\n                args: []\n            });\n        }\n        if (this.layout.type === 'MindMap') {\n            modules.push({\n                member: 'MindMapChart',\n                args: []\n            });\n        }\n        if (this.layout.type === 'RadialTree') {\n            modules.push({\n                member: 'RadialTree',\n                args: []\n            });\n        }\n        if (this.layout.type === 'SymmetricalLayout') {\n            modules.push({\n                member: 'SymmetricalLayout',\n                args: []\n            });\n        }\n        if (this.layout.type === 'Flowchart') {\n            modules.push({\n                member: 'FlowchartLayout',\n                args: []\n            });\n        }\n        if (this.dataSourceSettings.dataManager || this.dataSourceSettings.dataSource ||\n            this.dataSourceSettings.crudAction.read || this.dataSourceSettings.connectionDataSource.crudAction.read) {\n            modules.push({\n                member: 'DataBinding',\n                args: []\n            });\n        }\n        if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting) {\n            modules.push({\n                member: 'LineRouting',\n                args: []\n            });\n        }\n        if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.AvoidLineOverlapping) {\n            modules.push({\n                member: 'AvoidLineOverlapping',\n                args: [this]\n            });\n        }\n        if ((this.layout && (this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree')) || (this.layout.arrangement === 'Linear' || (this.layout.enableRouting))) {\n            modules.push({\n                member: 'LineDistribution',\n                args: []\n            });\n        }\n        return modules;\n    };\n    /* tslint:enable */\n    Diagram.prototype.removeUserHandlesTemplate = function () {\n        if (this.selectedItems.userHandles.length) {\n            for (var i = 0; i < this.selectedItems.userHandles.length; i++) {\n                for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n                    var elementId = _a[_i];\n                    (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(this.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_template_hiddenUserHandle', elementId);\n                }\n            }\n        }\n    };\n    /**\n     *Destroys the diagram, freeing up its resources.\n     *\n     * @returns {void} Destroys the diagram, freeing up its resources.\n     */\n    Diagram.prototype.destroy = function () {\n        clearInterval(this.renderTimer);\n        this.renderTimer = null;\n        if (this.hRuler && this.vRuler) {\n            this.hRuler.destroy();\n            this.vRuler.destroy();\n        }\n        this.tooltipObject.destroy();\n        this.droppable.destroy();\n        this.unWireEvents();\n        this.notify('destroy', {});\n        _super.prototype.destroy.call(this);\n        this.removeUserHandlesTemplate();\n        this.clearTemplate();\n        if (document.getElementById(this.element.id)) {\n            this.element.classList.remove('e-diagram');\n            var tooltipelement = document.getElementsByClassName('e-diagram-tooltip');\n            while (tooltipelement.length > 0) {\n                tooltipelement[0].parentNode.removeChild(tooltipelement[0]);\n            }\n            var content = document.getElementById(this.element.id + 'content');\n            if (content) {\n                this.element.removeChild(content);\n            }\n            var measureWindowElement = 'measureElement';\n            if (window[\"\" + measureWindowElement]) {\n                window[\"\" + measureWindowElement].usageCount -= 1;\n                var measureElementCount = 'measureElementCount';\n                window[\"\" + measureElementCount]--;\n                if (window[\"\" + measureElementCount] === 0) {\n                    window[\"\" + measureWindowElement].parentNode.removeChild(window[\"\" + measureWindowElement]);\n                    window[\"\" + measureWindowElement] = null;\n                }\n            }\n        }\n        var domTable = 'domTable';\n        window[\"\" + domTable] = {};\n        for (var i = 0; i < this.layers.length; i++) {\n            var currentLayer = this.layers[parseInt(i.toString(), 10)];\n            currentLayer.zIndexTable = {};\n        }\n        this.diagramActions = undefined;\n    };\n    //Wires the mouse events with diagram control\n    Diagram.prototype.wireEvents = function () {\n        var startEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent;\n        var stopEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent;\n        var moveEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent;\n        var cancelEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer ? 'pointerleave' : 'mouseleave';\n        var isIE11Pointer = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer;\n        var wheelEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.info.name === 'mozilla' ?\n            (isIE11Pointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, startEvent, this.eventHandler.mouseDown, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, moveEvent, this.eventHandler.mouseMove, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, stopEvent, this.eventHandler.mouseUp, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, cancelEvent, this.eventHandler.mouseLeave, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, 'keydown', this.eventHandler.keyDown, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, 'keyup', this.eventHandler.keyUp, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, 'dblclick', this.eventHandler.doubleClick, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, 'scroll', this.eventHandler.scrolled, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.diagramCanvas, wheelEvent, this.eventHandler.mouseWheel, this.eventHandler);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(window, 'resize', this.eventHandler.windowResize, this.eventHandler);\n        this.initDroppables();\n    };\n    //Unwires the mouse events from diagram control\n    Diagram.prototype.unWireEvents = function () {\n        var startEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent;\n        var moveEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent;\n        var cancelEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer ? 'pointerleave' : 'mouseleave';\n        var isIE11Pointer = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer;\n        var wheelEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.info.name === 'mozilla' ?\n            (isIE11Pointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';\n        var stopEvent = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent;\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, startEvent, this.eventHandler.mouseDown);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, moveEvent, this.eventHandler.mouseMove);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, stopEvent, this.eventHandler.mouseUp);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, cancelEvent, this.eventHandler.mouseLeave);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, 'keydown', this.eventHandler.keyDown);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, 'keyup', this.eventHandler.keyUp);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, 'dblclick', this.eventHandler.doubleClick);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, 'scroll', this.eventHandler.scrolled);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.diagramCanvas, wheelEvent, this.eventHandler.mouseWheel);\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(window, 'resize', this.eventHandler.windowResize);\n    };\n    //public methods - start region\n    /**\n     * Select a specified collection of nodes and connectors in the diagram. You can specify whether to clear the existing selection and provide an old value if needed. \\\n     *\n     * @returns { void } Select a specified collection of nodes and connectors in the diagram. You can specify whether to clear the existing selection and provide an old value if needed.\\\n     * @param {NodeModel | ConnectorModel} objects - An array containing the collection of nodes and connectors to be selected.\n     * @param {boolean} multipleSelection - Determines whether the existing selection should be cleared (default is false).\n     * @param {NodeModel | ConnectorModel} oldValue - Defines the old value\n     *\n     */\n    Diagram.prototype.select = function (objects, multipleSelection, oldValue) {\n        //Removed isBlazor code.\n        if (objects != null) {\n            this.commandHandler.selectObjects(objects, multipleSelection, oldValue);\n        }\n    };\n    /**\n     * Returns the diagram action as a string representation.\n     * @returns { string }\n     * @param { DiagramAction } diagramAction - The diagram action to be converted to a string.\n     */\n    //Feature (EJ2-18451) : For all client side events, cause argument data type should be string instead of flag enum and value should be easier to understand.\n    Diagram.prototype.getDiagramAction = function (diagramAction) {\n        var action;\n        if (diagramAction === 2 && _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) {\n            action = 'Render';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo) {\n            action = 'UndoRedo';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod) {\n            action = 'PublicMethod';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction) {\n            action = 'ToolAction';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.TextEdit) {\n            action = 'TextEdit';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Group) {\n            action = 'Group';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Interactions) {\n            action = 'Interactions';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory) {\n            action = 'PreventHistory';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DecoratorPropertyChange) {\n            action = 'DecoratorPropertyChange';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventZIndexOnDragging) {\n            action = 'PreventZIndexOnDragging';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.isGroupDragging) {\n            action = 'isGroupDragging';\n        }\n        else if (diagramAction & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DragUsingMouse) {\n            action = 'DragUsingMouse';\n        }\n        return action;\n    };\n    /**\n     *  Select all objects, including nodes and connectors, in the diagram. \\\n     *\n     * @returns { void }  Select all objects, including nodes and connectors, in the diagram.\\\n     *\n     */\n    Diagram.prototype.selectAll = function () {\n        var selectedItems = [];\n        selectedItems = this.getObjectsOfLayer(this.activeLayer.objects);\n        this.select(selectedItems);\n    };\n    /**\n     * Remove a specific object from the current selection in the diagram. \\\n     *\n     * @returns { void } Remove a specific object from the current selection in the diagram.\\\n     * @param {NodeModel | ConnectorModel} obj -  The object to remove from the selection.\n     *\n     */\n    Diagram.prototype.unSelect = function (obj) {\n        //Removed isBlazor code.\n        if (obj && (0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.isSelected)(this, obj)) {\n            this.commandHandler.unSelect(obj);\n            // this.commandHandler.updateBlazorSelector();\n        }\n    };\n    /**\n     * Removes all elements from the selection list, clearing the current selection.\\\n     *\n     * @returns { void } Removes all elements from the selection list, clearing the current selection.\\\n     *\n     */\n    Diagram.prototype.clearSelection = function () {\n        this.commandHandler.clearSelection(true);\n    };\n    /**\n     *  Updates the dimensions of the diagram viewport. \\\n     *\n     * @returns { void }  Updates the dimensions of the diagram viewport.\\\n     *\n     */\n    Diagram.prototype.updateViewPort = function () {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        this.eventHandler.updateViewPortSize(this.element);\n        this.updateBlazorDiagramProperties(attribute, true);\n    };\n    Diagram.prototype.cutCommand = function () {\n        this.cut();\n    };\n    /**\n     *  Removes the selected nodes and connectors from the diagram and moves them to the diagram clipboard for cutting. \\\n     *\n     * @returns { void }  Removes the selected nodes and connectors from the diagram and moves them to the diagram clipboard for cutting. \\\n     *\n     */\n    Diagram.prototype.cut = function () {\n        this.commandHandler.cut();\n    };\n    /**\n     *   Adds a process into the sub-process. \\\n     *\n     * @returns { void }  Adds a process into the sub-process. \\\n     * @param {NodeModel | ConnectorModel} process - A NodeModel representing the process to be added.\n     * @param {boolean} parentId - A string representing the parent ID where the process will be added.\n     *\n     */\n    Diagram.prototype.addProcess = function (process, parentId) {\n        if (this.bpmnModule) {\n            this.bpmnModule.addProcess(process, parentId, this);\n        }\n    };\n    /**\n     *  Removes a process from the BPMN sub-process. \\\n     *\n     * @returns { void }  Removes a process from the BPMN sub-process.\\\n     * @param {string} id - The ID of the process to be removed.\n     *\n     */\n    Diagram.prototype.removeProcess = function (id) {\n        if (this.bpmnModule) {\n            this.bpmnModule.removeProcess(id, this);\n        }\n    };\n    Diagram.prototype.pasteCommand = function () {\n        this.paste();\n    };\n    /**\n     * Adds the given objects or the objects in the diagram clipboard to the diagram control. \\\n     *\n     * @returns { void }  Adds the given objects or the objects in the diagram clipboard to the diagram control. \\\n     * @param {NodeModel[] | ConnectorModel[]} obj - An array of nodes or connectors objects to be added to diagram.\n     * @deprecated\n     *\n     */\n    Diagram.prototype.paste = function (obj) {\n        this.commandHandler.paste(obj);\n    };\n    /**\n     *  Fits the diagram to the page with respect to mode and region. \\\n     *\n     * @returns { void }  Fits the diagram to the page with respect to mode and region.\\\n     * @param {IFitOptions} options - specify the options for fitting the diagram to the page.\n     */\n    Diagram.prototype.fitToPage = function (options) {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        this.scroller.fitToPage(options);\n        this.updateBlazorDiagramProperties(attribute, true);\n    };\n    /**\n     * Brings the specified bounds into view within the diagram's viewport. \\\n     *\n     * @returns { void }  Brings the specified bounds into view within the diagram's viewport.\\\n     * @param {Rect} bound - Representing the bounds to be brought into view.\n     *\n     */\n    Diagram.prototype.bringIntoView = function (bound) {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        // EJ2-69238 - add true as an extra parameter to calcuate the horizontal and vertical offset\n        this.scroller.bringIntoView(bound, true);\n        this.updateBlazorDiagramProperties(attribute, true);\n    };\n    /**\n     * Brings the specified bounds to the center of the viewport. \\\n     *\n     * @returns { void }  Brings the specified bounds to the center of the viewport.\\\n     * @param {Rect} bound - representing the bounds to be centered in the viewport.\n     *\n     */\n    Diagram.prototype.bringToCenter = function (bound) {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        this.scroller.bringToCenter(bound);\n        this.updateBlazorDiagramProperties(attribute, true);\n    };\n    Diagram.prototype.copyCommand = function () {\n        this.copy();\n    };\n    /**\n     * Copies the selected nodes and connectors from the diagram to the diagram clipboard for copying. \\\n     *\n     * @returns { Object } Copies the selected nodes and connectors from the diagram to the diagram clipboard for copying.\\\n     *\n     */\n    Diagram.prototype.copy = function () {\n        var obj = this.commandHandler.copy();\n        return obj;\n    };\n    /**\n     *  Groups the selected nodes and connectors in the diagram. \\\n     *\n     * @returns { void }   Groups the selected nodes and connectors in the diagram.\\\n     *\n     */\n    Diagram.prototype.group = function () {\n        var selectedItems = [];\n        selectedItems = this.selectedItems.nodes;\n        selectedItems = selectedItems.concat(this.selectedItems.connectors);\n        if (selectedItems.length > 1) {\n            this.callBlazorModel = false;\n            this.insertBlazorDiagramObjects(this.selectedItems);\n            this.commandHandler.group();\n            this.callBlazorModel = true;\n            this.commandHandler.getBlazorOldValues();\n        }\n    };\n    /**\n     *  UnGroup the selected nodes and connectors in diagram \\\n     *\n     * @returns { void }   UnGroup the selected nodes and connectors in diagram.\\\n     *\n     */\n    Diagram.prototype.unGroup = function () {\n        this.callBlazorModel = false;\n        this.insertBlazorDiagramObjects(this.selectedItems);\n        this.commandHandler.unGroup();\n        this.callBlazorModel = true;\n        this.commandHandler.getBlazorOldValues();\n    };\n    /**\n     *  Use this method to move the currently selected nodes or connectors to the back of the drawing order. This effectively places them behind other elements in the diagram. \\\n     *\n     * @returns { void }   Use this method to move the currently selected nodes or connectors to the back of the drawing order. This effectively places them behind other elements in the diagram.\\\n     *\n     */\n    Diagram.prototype.sendToBack = function () {\n        this.commandHandler.sendToBack();\n    };\n    /**\n     * Specify which layer in the diagram should be considered the active layer. The active layer is the one where new elements will be added and where user interactions are primarily focused. \\\n     *\n     * @returns { void } Specify which layer in the diagram should be considered the active layer. The active layer is the one where new elements will be added and where user interactions are primarily focused. \\\n     * @param {string} layerName - The name of the layer to set as the active layer.\n     *\n     */\n    Diagram.prototype.setActiveLayer = function (layerName) {\n        var layer = this.commandHandler.getLayer(layerName);\n        this.activeLayer = layer;\n    };\n    /**\n     * add the layer into diagram\\\n     *\n     * @returns { void } Adds the specified layer to the diagram control along with its associated objects.\\\n     * @param {LayerModel} layer - representing the layer to be added to the diagram.\n     * @param {Object[]} layerObject -  An optional array of objects associated with the layer.\n     * @blazorArgsType layer|DiagramLayer\n     * @deprecated\n     *\n     */\n    Diagram.prototype.addLayer = function (layer, layerObject) {\n        this.commandHandler.addLayer(layer, layerObject);\n    };\n    /**\n     * remove the layer from diagram \\\n     *\n     * @returns { void } remove the layer from diagram.\\\n     * @param {string} layerId - provide the bound value.\n     * @deprecated\n     *\n     */\n    Diagram.prototype.removeLayer = function (layerId) {\n        this.commandHandler.removeLayer(layerId, (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)());\n    };\n    // /* eslint-enable */\n    /**\n     *Moves objects from one layer to another layer within the diagram. \\\n     *\n     * @returns { void } Moves objects from one layer to another layer within the diagram. \\\n     * @param {string[]} objects - An array of object IDs represented as strings to be moved.\n     * @param {string} targetLayer - The ID of the target layer to which the objects should be moved.\n     */\n    Diagram.prototype.moveObjects = function (objects, targetLayer) {\n        var oldValues = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.layers);\n        this.enableServerDataBinding(false);\n        this.commandHandler.moveObjects(objects, targetLayer);\n        //     const result: object = this.commandHandler.deepDiffer.map(oldValues, cloneObject(this.layers));\n        //     const diffValue: object = this.commandHandler.deepDiffer.frameObject({}, result);\n        //     this.oldDiagramObject = { layers: diffValue };\n        //     // this.commandHandler.updateBlazorProperties();\n    };\n    /* tslint:disable */\n    Diagram.prototype.layerObjectUpdate = function () {\n        //Removed isBlazor code.\n    };\n    /* tslint:enable */\n    /**\n     * Use this method to change the order of layers in the diagram. This moves the specified layer behind the layer that comes after it in the layer order. \\\n     *\n     * @returns { void } Use this method to change the order of layers in the diagram. This moves the specified layer behind the layer that comes after it in the layer order.\\\n     * @param {string} layerName - The name of the layer to be moved.\n     * @param {string} targetLayer - define the objects id of string array\n     *\n     */\n    Diagram.prototype.sendLayerBackward = function (layerName) {\n        this.layerObjectUpdate();\n        this.commandHandler.sendLayerBackward(layerName);\n        // comment blazor code\n        // this.commandHandler.updateLayerObject(this.oldDiagramObject, true);\n    };\n    /**\n     * Moves the specified layer forward in the drawing order. \\\n     *\n     * @returns { void } Moves the specified layer forward in the drawing order.\\\n     * @param {string} layerName - A string representing the name of the layer to be moved forward.\n     *\n     */\n    Diagram.prototype.bringLayerForward = function (layerName) {\n        this.layerObjectUpdate();\n        this.commandHandler.bringLayerForward(layerName);\n        // comment blazor code\n        // this.commandHandler.updateLayerObject(this.oldDiagramObject);\n    };\n    /**\n     * Clones a layer along with its objects.\\\n     *\n     * @returns { void } Clones a layer along with its objects.\\\n     * @param {string} layerName - A string representing the name of the layer to be cloned.\n     *\n     */\n    Diagram.prototype.cloneLayer = function (layerName) {\n        this.commandHandler.cloneLayer(layerName);\n    };\n    /**\n     *Brings the selected nodes or connectors to the front of the drawing order. \\\n     *\n     * @returns { void } Brings the selected nodes or connectors to the front of the drawing order. \\\n     *\n     */\n    Diagram.prototype.bringToFront = function () {\n        this.commandHandler.bringToFront();\n    };\n    /**\n     *Sends the selected nodes or connectors forward in the visual order.  \\\n     *\n     * @returns { void } Sends the selected nodes or connectors forward in the visual order. \\\n     *\n     */\n    Diagram.prototype.moveForward = function () {\n        this.commandHandler.sendForward();\n    };\n    /**\n     *Sends the selected nodes or connectors one step backward in the z-order.\\\n     *\n     * @returns { void } Sends the selected nodes or connectors one step backward in the z-order.\\\n     *\n     */\n    Diagram.prototype.sendBackward = function () {\n        this.commandHandler.sendBackward();\n    };\n    /**\n     *gets the node or connector having the given name \\\n     *\n     * @returns { void } gets the node or connector having the given name.\\\n     * @param {string} name - define the name of the layer\n     *\n     */\n    Diagram.prototype.getObject = function (name) {\n        return this.nameTable[\"\" + name];\n    };\n    /**\n     *Retrieves the node object for the given node ID.  \\\n     *\n     * @returns { void } Retrieves the node object for the given node ID. \\\n     * @param {string} id - The ID of the node for which the node object is to be retrieved.\n     *\n     */\n    Diagram.prototype.getNodeObject = function (id) {\n        return (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.nameTable[\"\" + id]);\n    };\n    /**\n     *Retrieves the connector object for the given node ID. \\\n     *\n     * @returns { void } Retrieves the connector object for the given node ID.\\\n     * @param {string} id - The ID of the node for which the connector object is to be retrieved.\n     *\n     */\n    Diagram.prototype.getConnectorObject = function (id) {\n        return (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.nameTable[\"\" + id]);\n    };\n    /**\n     * Retrieves the active layer. \\\n     *\n     * @returns { void } Retrieves the active layer.\\\n     *\n     */\n    Diagram.prototype.getActiveLayer = function () {\n        return this.activeLayer;\n    };\n    Diagram.prototype.nudgeCommand = function (direction, x, y) {\n        if (typeof direction !== 'object' && (this.selectedItems.nodes.length || this.selectedItems.connectors.length) > 0) {\n            var type = void 0;\n            if (x.type && x.type === 'KEYDOWN') {\n                type = x.type;\n            }\n            this.nudge(direction, undefined, undefined, type);\n        }\n    };\n    /**\n     * Moves the selected objects towards the given direction by a specified distance.\n     *\n     * @returns { void }  Moves the selected objects towards the given direction by a specified distance.  \\\n     * @param {NudgeDirection} direction -  Defines the direction in which the objects should be moved.\n     * @param {number} x - The horizontal distance by which the selected objects should be moved.\n     * @param {number} y -  The vertical distance by which the selected objects should be moved.\n     * @param {string} type -  A string that defines the type of nudge action.\n     */\n    Diagram.prototype.nudge = function (direction, x, y, type) {\n        var tx = 0;\n        var ty = 0;\n        var negativeDirection;\n        if (direction === 'Left' || direction === 'Right') {\n            negativeDirection = (direction === 'Left');\n            tx = (negativeDirection ? -1 : 1) * (x ? x : 1);\n        }\n        else {\n            negativeDirection = (direction === 'Up');\n            ty = (negativeDirection ? -1 : 1) * (y ? y : 1);\n        }\n        if (type === 'KEYDOWN') {\n            tx *= 5;\n            ty *= 5;\n        }\n        var obj = this.selectedItems;\n        var annotation = this.selectedItems.wrapper.children[0];\n        if (annotation instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) {\n            this.commandHandler.labelDrag(obj.nodes[0], annotation, tx, ty);\n        }\n        else {\n            var undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.selectedItems);\n            this.protectPropertyChange(true);\n            this.drag(obj, tx, ty);\n            this.protectPropertyChange(false);\n            var entry = {\n                type: 'PositionChanged',\n                redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.selectedItems), undoObject: undoObject, category: 'Internal'\n            };\n            this.addHistoryEntry(entry);\n        }\n        this.refreshCanvasLayers();\n    };\n    Diagram.prototype.insertBlazorDiagramObjects = function (actualObject) {\n        //Removed isBlazor code\n    };\n    /**\n     * Drags the given object (nodes, connectors, or selector) by the specified horizontal and vertical distances.\n     *\n     * @returns { void }  Drags the given object (nodes, connectors, or selector) by the specified horizontal and vertical distances.\\\n     * @param {NodeModel | ConnectorModel | SelectorModel} obj - representing the nodes, connectors, or selector to be dragged.\n     * @param {number} tx - A number representing the horizontal distance by which the given objects should be moved.\n     * @param {number} ty - A number representing the vertical distance by which the given objects should be moved.\n     */\n    Diagram.prototype.drag = function (obj, tx, ty) {\n        this.insertBlazorDiagramObjects(obj);\n        //Removed isBlazor code\n        if (this.bpmnModule && (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node)) {\n            var updated = this.bpmnModule.updateAnnotationDrag(obj, this, tx, ty);\n            if (updated) {\n                return;\n            }\n        }\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Selector) {\n            this.preventConnectorsUpdate = true;\n            if (obj.nodes && obj.nodes.length) {\n                for (var _i = 0, _a = obj.nodes; _i < _a.length; _i++) {\n                    var node = _a[_i];\n                    this.callBlazorModel = false;\n                    this.drag(node, tx, ty);\n                    if (node.parentId) {\n                        var parent_1 = this.nameTable[node.parentId];\n                        if (parent_1.isLane) {\n                            // 909151 - Connector not updating while dragging multiple selection.\n                            if (obj.nodes.length > 1) {\n                                this.preventConnectorsUpdate = false;\n                            }\n                            var swimlane = this.nameTable[parent_1.parentId];\n                            (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.updateLaneBoundsAfterAddChild)(parent_1, swimlane, node, this);\n                        }\n                    }\n                }\n                this.callBlazorModel = true;\n            }\n            if (obj.connectors && obj.connectors.length) {\n                this.callBlazorModel = false;\n                for (var _b = 0, _c = obj.connectors; _b < _c.length; _b++) {\n                    var conn = _c[_b];\n                    this.drag(conn, tx, ty);\n                    if (this.selectionConnectorsList.indexOf(conn) === -1) {\n                        this.selectionConnectorsList.push(conn);\n                    }\n                }\n                this.callBlazorModel = true;\n            }\n            this.updateSelector();\n            if ((this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DragUsingMouse)) {\n                this.updatePage();\n            }\n        }\n        else {\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                if (this.bpmnModule) {\n                    this.bpmnModule.updateAnnotationDrag(obj, this, tx, ty);\n                }\n            }\n            this.commandHandler.drag(obj, tx, ty);\n        }\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Selector) {\n            this.preventConnectorsUpdate = false;\n            for (var _d = 0, _e = this.selectionConnectorsList; _d < _e.length; _d++) {\n                var connectors = _e[_d];\n                this.updateConnectorProperties(this.nameTable[connectors.id]);\n                if (connectors.shape.type === 'Bpmn' && connectors.shape.sequence === 'Default' && connectors.shape.flow === 'Sequence') {\n                    this.commandHandler.updatePathElementOffset(connectors);\n                }\n            }\n            this.selectionConnectorsList = [];\n        }\n        // Bug 832880: Need to improve performance while nudging multiple nodes.\n        // Removed one if condition here to improve performance.\n        if (this.callBlazorModel && (!(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.interaction)) &&\n            (!(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.GroupClipboardInProcess))) {\n            this.commandHandler.getBlazorOldValues();\n        }\n    };\n    Diagram.prototype.disableStackContainerPadding = function (wrapper, disable) {\n        if (wrapper instanceof _core_containers_stack_panel__WEBPACK_IMPORTED_MODULE_44__.StackPanel) {\n            wrapper.considerPadding = disable;\n        }\n        if (wrapper.children) {\n            for (var _i = 0, _a = wrapper.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                this.disableStackContainerPadding(child, false);\n            }\n        }\n    };\n    /**\n     * Use this method to scale one or more objects in the diagram by specifying the horizontal and vertical scaling ratios. You can also provide a pivot point as a reference for scaling.\n     *\n     * @returns { void } Use this method to scale one or more objects in the diagram by specifying the horizontal and vertical scaling ratios. You can also provide a pivot point as a reference for scaling.\\\n     * @param {NodeModel | ConnectorModel | SelectorModel} obj - The objects to be resized.\n     * @param {number} sx - The horizontal scaling ratio.\n     * @param {number} sy - The vertical scaling ratio.\n     * @param {PointModel} pivot - The reference point with respect to which the objects will be resized.\n     */\n    Diagram.prototype.scale = function (obj, sx, sy, pivot) {\n        this.disableStackContainerPadding(obj.wrapper, false);\n        this.insertBlazorDiagramObjects(obj);\n        var checkBoundaryConstraints = true;\n        if (obj.id) {\n            obj = this.nameTable[obj.id] || obj;\n        }\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Selector) {\n            if (obj.nodes && obj.nodes.length) {\n                this.callBlazorModel = false;\n                for (var _i = 0, _a = obj.nodes; _i < _a.length; _i++) {\n                    var node = _a[_i];\n                    checkBoundaryConstraints = this.commandHandler.scale(node, sx, sy, pivot, obj);\n                    if (!this.commandHandler.checkBoundaryConstraints(undefined, undefined, obj.wrapper.bounds)) {\n                        this.commandHandler.scale(node, 1 / sx, 1 / sy, pivot, obj);\n                    }\n                }\n                this.callBlazorModel = true;\n            }\n            if (obj.connectors && obj.connectors.length) {\n                this.callBlazorModel = false;\n                for (var _b = 0, _c = obj.connectors; _b < _c.length; _b++) {\n                    var conn = _c[_b];\n                    this.commandHandler.scale(conn, sx, sy, pivot, obj);\n                    if (!this.commandHandler.checkBoundaryConstraints(undefined, undefined, obj.wrapper.bounds)) {\n                        this.commandHandler.scale(conn, 1 / sx, 1 / sy, pivot, obj);\n                    }\n                }\n                this.callBlazorModel = true;\n            }\n            var selector = this.selectedItems;\n            if (!((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.selectionHasConnector)(this, selector))) {\n                this.updateSelector();\n            }\n            this.refreshCanvasLayers();\n        }\n        else {\n            this.commandHandler.scale(obj, sx, sy, pivot, (obj.children ? obj : undefined));\n        }\n        if (this.callBlazorModel && (!(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.interaction)) &&\n            (!(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.GroupClipboardInProcess))) {\n            this.commandHandler.getBlazorOldValues();\n        }\n        this.disableStackContainerPadding(obj.wrapper, true);\n        return checkBoundaryConstraints;\n    };\n    /**\n     * Rotates the specified nodes, connectors, or selector by the given angle.\n     *\n     * @returns { void } Rotates the specified nodes, connectors, or selector by the given angle.\\\n     * @param {NodeModel | ConnectorModel | SelectorModel} obj - The objects to be rotated\n     * @param {number} angle - The angle by which the objects should be rotated (in degrees).\n     * @param {PointModel} pivot - The reference point with respect to which the objects will be rotated.\n     * @param {boolean} rotateUsingHandle - Whether to rotate using the handle.\n     */\n    Diagram.prototype.rotate = function (obj, angle, pivot, rotateUsingHandle) {\n        // Bug 842506: After multiple group node rotations, the undo functionality is not working.\n        // Added below condition to store the current obj to add it as undo element in rotation changed entry.\n        var undoObject;\n        var childTable = [];\n        if (!rotateUsingHandle) {\n            undoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj);\n            if (undoObject.nodes && undoObject.nodes.length > 0 && undoObject.nodes[0].children) {\n                var elements = [];\n                if (!this.fromUndo) {\n                    this.rotateUsingButton = true;\n                }\n                var nodes = this.commandHandler.getAllDescendants(undoObject.nodes[0], elements);\n                for (var i = 0; i < nodes.length; i++) {\n                    var node = this.commandHandler.cloneChild(nodes[parseInt(i.toString(), 10)].id);\n                    childTable[nodes[parseInt(i.toString(), 10)].id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(node);\n                }\n            }\n            if (angle < 0) {\n                angle = (angle + 360) % 360;\n            }\n        }\n        this.insertBlazorDiagramObjects(obj);\n        var checkBoundaryConstraints;\n        if (obj.id) {\n            obj = this.nameTable[obj.id] || obj;\n        }\n        if (obj) {\n            pivot = pivot || { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY };\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Selector) {\n                this.callBlazorModel = false;\n                obj.rotateAngle += angle;\n                obj.wrapper.rotateAngle += angle;\n                var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getBounds)(obj.wrapper);\n                checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, bounds);\n                if (!checkBoundaryConstraints) {\n                    obj.rotateAngle -= angle;\n                    obj.wrapper.rotateAngle -= angle;\n                    return checkBoundaryConstraints;\n                }\n                var objects = [];\n                objects = objects.concat(obj.nodes);\n                objects = objects.concat(obj.connectors);\n                this.commandHandler.rotateObjects(obj, objects, angle, pivot);\n                this.callBlazorModel = true;\n            }\n            else {\n                this.commandHandler.rotateObjects(obj, [obj], angle, pivot);\n            }\n        }\n        if (this.callBlazorModel && (!(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.interaction))) {\n            this.commandHandler.getBlazorOldValues();\n        }\n        if (!rotateUsingHandle && !this.fromUndo) {\n            // To add history entry for group node rotation.\n            if (undoObject.nodes && undoObject.nodes.length > 0 && undoObject.nodes[0].children) {\n                var entry = {\n                    type: 'RotationChanged', redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(undoObject), category: 'Internal',\n                    childTable: childTable\n                };\n                this.commandHandler.addHistoryEntry(entry);\n                this.commandHandler.updateSelector();\n            }\n        }\n        return checkBoundaryConstraints;\n    };\n    /**\n     * Moves the source point of the given connector by the specified horizontal and vertical distances.\n     *\n     * @returns { void }  Moves the source point of the given connector by the specified horizontal and vertical distances.\\\n     * @param {ConnectorModel} obj - representing the connector whose source point needs to be moved.\n     * @param {number} tx - A number representing the horizontal distance by which the source point should be moved.\n     * @param {number} ty - A number representing the vertical distance by which the source point should be moved.\n     */\n    Diagram.prototype.dragSourceEnd = function (obj, tx, ty) {\n        this.insertBlazorDiagramObjects(obj);\n        this.commandHandler.dragSourceEnd(obj, tx, ty);\n        if (this.callBlazorModel) {\n            this.commandHandler.getBlazorOldValues();\n        }\n    };\n    /**\n     * Moves the target point of the given connector by the specified horizontal and vertical distances.\n     *\n     * @returns { void }   Moves the target point of the given connector by the specified horizontal and vertical distances.\\\n     * @param {ConnectorModel} obj - representing the connector whose target point needs to be moved.\n     * @param {number} tx - A number representing the horizontal distance by which the target point should be moved.\n     * @param {number} ty - A number representing the vertical distance by which the target point should be moved.\n     */\n    Diagram.prototype.dragTargetEnd = function (obj, tx, ty) {\n        this.insertBlazorDiagramObjects(obj);\n        this.commandHandler.dragTargetEnd(obj, tx, ty);\n        if (this.callBlazorModel) {\n            this.commandHandler.getBlazorOldValues();\n        }\n    };\n    /**\n     * Finds all the objects that are under the given mouse position based on specified criteria.\n     *\n     * @returns { void }   Finds all the objects that are under the given mouse position based on specified criteria.\\\n     * @param {PointModel} position - The PointModel that defines the position. The objects under this position will be found.\n     * @param {IElement} source - Representing the source object. The objects under this source will be found.\n     */\n    Diagram.prototype.findObjectsUnderMouse = function (position, source) {\n        return this.eventHandler.findObjectsUnderMouse(position, source);\n    };\n    /**\n     * Finds the object that is under the given mouse position based on specified criteria.\n     *\n     * @returns { void }   Finds the object that is under the given mouse position based on specified criteria. \\\n     * @param {NodeModel[] | ConnectorModel[]}objects - A collection of NodeModel or ConnectorModel objects, from which the target object has to be found.\n     * @param {Actions} action - Defines the action used to find the relevant object.\n     * @param {boolean} inAction - A boolean indicating the active state of the action.\n     */\n    Diagram.prototype.findObjectUnderMouse = function (objects, action, inAction) {\n        return this.eventHandler.findObjectUnderMouse(objects, action, inAction);\n    };\n    /**\n     * Finds the object that is under the given active object (source) based on specified criteria.\n     *\n     * @returns { void } Finds the object that is under the given active object (source) based on specified criteria.\\\n     * @param {NodeModel[] | ConnectorModel[]} objects - A collection of node or connector objects, from which the target object has to be found.\n     * @param {Actions} action - defines the action used to find the relevant object.\n     * @param {boolean} inAction - A boolean indicating the active state of the action.\n     * @param {PointModel} position - The PointModel that defines the position\n     * @param {IElement} source - Representing the source element.\n     */\n    Diagram.prototype.findTargetObjectUnderMouse = function (objects, action, inAction, position, source) {\n        return this.eventHandler.findTargetUnderMouse(objects, action, inAction, position, source);\n    };\n    /**\n     * Finds the child element of the given object at the given position based on specified criteria.\n     *\n     * @returns { void } Finds the child element of the given object at the given position based on specified criteria.\\\n     * @param {IElement} obj - representing the object, the child element of which has to be found.\n     * @param {PointModel} position - defines the position. The child element under this position will be found.\n     * @param {Diagram} diagram - defines the diagram value.\n     * @param {number} padding - A number representing the padding for the search area around the position.\n     */\n    Diagram.prototype.findElementUnderMouse = function (obj, position, diagram, padding) {\n        return this.eventHandler.findElementUnderMouse(obj, position, diagram, padding);\n    };\n    /**\n     * Defines the action to be done, when the mouse hovers the given element of the given object\n     *\n     * @returns { void } Defines the action to be done, when the mouse hovers the given element of the given object .\\\n     * @param {NodeModel | ConnectorModel} obj - Defines the object under mouse\n     * @param {DiagramElement} wrapper - Defines the target element of the object under mouse\n     * @param {PointModel} position - Defines the current mouse position\n     * @param { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel} target - Defines the target\n     * @private\n     */\n    Diagram.prototype.findActionToBeDone = function (obj, wrapper, position, target) {\n        return this.eventHandler.findActionToBeDone(obj, wrapper, position, target);\n    };\n    // Feature 826644: Support to add ports to the connector. Added below method to update connector port on property change.\n    Diagram.prototype.updateConnectorPort = function (connector) {\n        if (connector.ports.length) {\n            var portContent = void 0;\n            for (var _i = 0, _a = connector.ports; _i < _a.length; _i++) {\n                var port = _a[_i];\n                portContent = this.getWrapper(connector.wrapper, port.id);\n                connector.initPortWrapper(port, connector.intermediatePoints, connector.wrapper.bounds, portContent);\n            }\n        }\n        connector.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(connector.wrapper.width, connector.wrapper.height));\n        connector.wrapper.arrange(connector.wrapper.desiredSize);\n    };\n    /**\n     * Returns the tool that handles the given action.\n     *\n     * @returns { ToolBase } Returns the tool that handles the given action. \\\n     * @param {string} action - A string that defines the action that is going to be performed.\n     */\n    Diagram.prototype.getTool = function (action) {\n        var tool;\n        var getCustomTool = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getFunction)(this.getCustomTool);\n        if (getCustomTool) {\n            tool = getCustomTool(action);\n            if (tool) {\n                return tool;\n            }\n        }\n        return this.eventHandler.getTool(action);\n    };\n    /**\n     * Defines the cursor that corresponds to the given action.\n     *\n     * @returns { string } Defines the cursor that corresponds to the given action. \\\n     * @param {string} action - The action for which the cursor is defined.\n     * @param {boolean} active - Indicates whether the action is active.\n     */\n    Diagram.prototype.getCursor = function (action, active) {\n        var cursor;\n        var getCustomCursor = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getFunction)(this.getCustomCursor);\n        if (getCustomCursor) {\n            cursor = getCustomCursor(action, active);\n            if (cursor) {\n                return cursor;\n            }\n        }\n        if (this.customCursor.length) {\n            for (var i = 0; i < this.customCursor.length; i++) {\n                if (this.customCursor[parseInt(i.toString(), 10)].action === action) {\n                    return this.customCursor[parseInt(i.toString(), 10)].cursor;\n                }\n            }\n        }\n        return this.eventHandler.getCursor(action);\n    };\n    /**\n     * Initializes the undo redo actions\n     *\n     * @returns { void } Initializes the undo redo actions \\\n     * @private\n     */\n    Diagram.prototype.initHistory = function () {\n        if (this.undoRedoModule) {\n            this.undoRedoModule.initHistory(this);\n        }\n    };\n    /**\n     * Adds a history entry for a change in the diagram control to the track.\n     *\n     * @returns { void } Adds a history entry for a change in the diagram control to the track. \\\n     * @param {HistoryEntry} entry - The history entry that describes a change in the diagram.\n     * @param {string[]} sourceId - An optional array of source IDs associated with the change.\n     */\n    Diagram.prototype.addHistoryEntry = function (entry, sourceId) {\n        if (this.undoRedoModule && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.UndoRedo)\n            && (!this.currentSymbol || this.checkCurrentSymbol(this.currentSymbol, entry))) {\n            if (entry.undoObject && entry.undoObject.id === 'helper') {\n                return;\n            }\n            var added = this.undoRedoModule.addHistoryEntry(entry, this);\n            if (entry.type !== 'StartGroup' && entry.type !== 'EndGroup' && added) {\n                this.historyChangeTrigger(entry, 'CustomAction', sourceId);\n            }\n        }\n    };\n    Diagram.prototype.checkCurrentSymbol = function (currentSymbol, entry) {\n        var check = false;\n        if (entry.undoObject && entry.redoObject) {\n            var undoObjects = entry.undoObject;\n            var redoObject = entry.undoObject;\n            if (redoObject.id && undoObjects.id && redoObject.id !== currentSymbol.id && undoObjects.id !== currentSymbol.id) {\n                return check = true;\n            }\n            else {\n                return check;\n            }\n        }\n        return check;\n    };\n    /**\n     * Adds the given custom change in the diagram control to the track\n     *\n     * @returns { void } Adds the given custom change in the diagram control to the track \\\n     * @param {HistoryEntry} entry - Defines the entry/information about a change in diagram\n     */\n    Diagram.prototype.addCustomHistoryEntry = function (entry) {\n        //Removed isBlazor code\n    };\n    /* eslint-disable */\n    /** @private */\n    Diagram.prototype.historyChangeTrigger = function (entry, action, sourceId) {\n        var change = {};\n        /* eslint-enable */\n        var oldValue = 'oldValue';\n        var newValue = 'newValue';\n        var type = 'type';\n        var entryType = 'entryType';\n        var source = [];\n        if (entry.category === 'Internal') {\n            if (entry && entry.redoObject && ((entry.redoObject.nodes) instanceof Array) &&\n                ((entry.redoObject.connectors) instanceof Array)) {\n                source = entry.redoObject.nodes.concat(entry.redoObject.connectors);\n            }\n            else {\n                if (entry.redoObject) {\n                    source.push(entry.redoObject);\n                }\n            }\n            change[\"\" + type] = entry.type;\n            //Removed isBlazor code\n            switch (entry.type) {\n                case 'PositionChanged':\n                    // 909584 - History change event args value is not updated properly\n                    if (action === 'Undo') {\n                        change[\"\" + oldValue] = {\n                            offsetX: entry.redoObject.offsetX,\n                            offsetY: entry.redoObject.offsetY\n                        };\n                        change[\"\" + newValue] = {\n                            offsetX: entry.undoObject.offsetX,\n                            offsetY: entry.undoObject.offsetY\n                        };\n                    }\n                    else {\n                        change[\"\" + oldValue] = {\n                            offsetX: entry.undoObject.offsetX,\n                            offsetY: entry.undoObject.offsetY\n                        };\n                        change[\"\" + newValue] = {\n                            offsetX: entry.redoObject.offsetX,\n                            offsetY: entry.redoObject.offsetY\n                        };\n                    }\n                    break;\n                case 'RotationChanged':\n                    if (action === 'Undo') {\n                        change[\"\" + oldValue] = { rotateAngle: entry.redoObject.rotateAngle };\n                        change[\"\" + newValue] = { rotateAngle: entry.undoObject.rotateAngle };\n                    }\n                    else {\n                        change[\"\" + oldValue] = { rotateAngle: entry.undoObject.rotateAngle };\n                        change[\"\" + newValue] = { rotateAngle: entry.redoObject.rotateAngle };\n                    }\n                    break;\n                case 'SizeChanged':\n                    if (action === 'Undo') {\n                        change[\"\" + oldValue] = {\n                            offsetX: entry.redoObject.offsetX, offsetY: entry.redoObject.offsetY,\n                            width: entry.redoObject.width, height: entry.redoObject.height\n                        };\n                        change[\"\" + newValue] = {\n                            offsetX: entry.undoObject.offsetX, offsetY: entry.undoObject.offsetY,\n                            width: entry.undoObject.width, height: entry.undoObject.height\n                        };\n                    }\n                    else {\n                        change[\"\" + oldValue] = {\n                            offsetX: entry.undoObject.offsetX, offsetY: entry.undoObject.offsetY,\n                            width: entry.undoObject.width, height: entry.undoObject.height\n                        };\n                        change[\"\" + newValue] = {\n                            offsetX: entry.redoObject.offsetX, offsetY: entry.redoObject.offsetY,\n                            width: entry.redoObject.width, height: entry.redoObject.height\n                        };\n                    }\n                    break;\n                case 'CollectionChanged':\n                    change[entry.changeType] = source;\n                    break;\n                case 'ConnectionChanged':\n                    if (action === 'Undo') {\n                        change[\"\" + oldValue] = {\n                            offsetX: entry.redoObject.offsetX,\n                            offsetY: entry.redoObject.offsetY\n                        };\n                        change[\"\" + newValue] = {\n                            offsetX: entry.undoObject.offsetX,\n                            offsetY: entry.undoObject.offsetY\n                        };\n                    }\n                    else {\n                        change[\"\" + oldValue] = {\n                            offsetX: entry.undoObject.offsetX,\n                            offsetY: entry.undoObject.offsetY\n                        };\n                        change[\"\" + newValue] = {\n                            offsetX: entry.redoObject.offsetX,\n                            offsetY: entry.redoObject.offsetY\n                        };\n                    }\n                    break;\n            }\n            /**Feature(EJ2-60228): Need to add Object ID in the history change event argument*/\n            var nodeSourceId = [];\n            var connectorSourceId = [];\n            if (sourceId === undefined && entry.type === 'PropertyChanged') {\n                for (var i = 0; i < Object.keys(entry.undoObject).length; i++) {\n                    if (Object.keys(entry.undoObject)[parseInt(i.toString(), 10)] === 'nodes') {\n                        for (var _i = 0, _a = Object.keys(entry.undoObject.nodes); _i < _a.length; _i++) {\n                            var key = _a[_i];\n                            var undoIndex = parseInt(key, 10);\n                            nodeSourceId.push(this.nodes[parseInt(undoIndex.toString(), 10)].id);\n                        }\n                    }\n                }\n                for (var i = 0; i < Object.keys(entry.undoObject).length; i++) {\n                    if (Object.keys(entry.undoObject)[parseInt(i.toString(), 10)] === 'connectors') {\n                        for (var _b = 0, _c = Object.keys(entry.undoObject.connectors); _b < _c.length; _b++) {\n                            var key = _c[_b];\n                            var undoIndex = parseInt(key, 10);\n                            connectorSourceId.push(this.connectors[parseInt(undoIndex.toString(), 10)].id);\n                        }\n                    }\n                }\n                sourceId = nodeSourceId.concat(connectorSourceId);\n            }\n            var arg = {\n                cause: entry.category, source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(source), change: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(change),\n                action: action, sourceId: sourceId\n            };\n            //Removed isBlazor code\n            if (source.length) {\n                this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.historyChange, arg);\n            }\n        }\n    };\n    /**\n     * Use this method to start a group action, allowing multiple actions to be treated as a single unit during undo/redo operations. This is useful when you want to group related actions together.\n     *\n     * @returns { void } Use this method to start a group action, allowing multiple actions to be treated as a single unit during undo/redo operations. This is useful when you want to group related actions together. \\\n     */\n    Diagram.prototype.startGroupAction = function () {\n        var entry = { type: 'StartGroup', category: 'Internal' };\n        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n            this.addHistoryEntry(entry);\n        }\n    };\n    /**\n     * Closes the grouping of actions that will be undone/restored as a whole.\n     *\n     * @returns { void } Closes the grouping of actions that will be undone/restored as a whole.\\\n     */\n    Diagram.prototype.endGroupAction = function () {\n        var entry = { type: 'EndGroup', category: 'Internal' };\n        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n            this.addHistoryEntry(entry);\n        }\n    };\n    /**\n     * Restores the last action that was performed.\n     *\n     * @returns { void } Restores the last action that was performed. \\\n     */\n    Diagram.prototype.undo = function () {\n        this.canEnableBlazorObject = true;\n        this.callBlazorModel = false;\n        if (this.undoRedoModule && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.UndoRedo)) {\n            this.isUndo = true;\n            this.undoRedoModule.undo(this);\n            this.isUndo = false;\n        }\n        else if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.UndoRedo) {\n            console.warn('[WARNING] :: Module \"UndoRedo\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n        this.commandHandler.getBlazorOldValues();\n        this.callBlazorModel = true;\n        this.canEnableBlazorObject = false;\n    };\n    /**\n     * Reverse an undo action, essentially restoring the state of the component to a previous state after an undo operation has been performed.\n     *\n     * @returns { void } Reverse an undo action, essentially restoring the state of the component to a previous state after an undo operation has been performed.\\\n     */\n    Diagram.prototype.redo = function () {\n        this.canEnableBlazorObject = true;\n        this.callBlazorModel = false;\n        if (this.undoRedoModule && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.UndoRedo)) {\n            this.undoRedoModule.redo(this);\n        }\n        else if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.UndoRedo) {\n            console.warn('[WARNING] :: Module \"UndoRedo\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n        this.commandHandler.getBlazorOldValues();\n        this.callBlazorModel = true;\n        this.canEnableBlazorObject = false;\n    };\n    Diagram.prototype.getBlazorDiagramObjects = function (objects) {\n        if (objects) {\n            for (var j = 0; j < objects.length; j++) {\n                this.insertBlazorDiagramObjects(objects[parseInt(j.toString(), 10)]);\n            }\n        }\n        else {\n            this.insertBlazorDiagramObjects(this.selectedItems);\n        }\n        this.callBlazorModel = false;\n        this.canEnableBlazorObject = true;\n    };\n    /**\n     * Aligns a group of objects with reference to the first object in the group.\n     *\n     * @returns { void } Aligns a group of objects with reference to the first object in the group.\\\n     * @param {AlignmentOptions}option - Defining the factor by which the objects have to be aligned.\n     * @param {NodeModel[] | ConnectorModel[]} objects - A collection of node or connector objects to be aligned.\n     * @param {AlignmentMode} type - Defines the type to be aligned\n     */\n    Diagram.prototype.align = function (option, objects, type) {\n        this.getBlazorDiagramObjects(objects);\n        if (!objects) {\n            objects = [];\n            objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n        }\n        this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod;\n        this.commandHandler.align(objects, option, (type ? type : 'Object'));\n        this.commandHandler.getBlazorOldValues();\n        this.callBlazorModel = true;\n        this.canEnableBlazorObject = false;\n    };\n    /**\n     * Arranges a group of objects with equal intervals within the group.\n     *\n     * @returns { void } Arranges a group of objects with equal intervals within the group.\\\n     * @param {NodeModel[] | ConnectorModel[]} option - Objects that have to be equally spaced within the group.\n     * @param {DistributeOptions} objects - Object defining the factor to distribute the shapes.\n     */\n    Diagram.prototype.distribute = function (option, objects) {\n        this.getBlazorDiagramObjects(objects);\n        if (!objects) {\n            objects = [];\n            objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n        }\n        this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod;\n        this.commandHandler.distribute(objects, option);\n        this.commandHandler.getBlazorOldValues();\n        this.canEnableBlazorObject = false;\n        this.callBlazorModel = true;\n    };\n    /**\n     * Scales the specified objects to match the size of the first object in the group.\n     *\n     * @returns { void } Scales the specified objects to match the size of the first object in the group.\\\n     * @param {SizingOptions} option - Specifies whether the objects should be horizontally scaled, vertically scaled, or both.\n     * @param {NodeModel[] | ConnectorModel[]}objects - The collection of objects to be scaled.\n     */\n    Diagram.prototype.sameSize = function (option, objects) {\n        this.getBlazorDiagramObjects(objects);\n        if (!objects) {\n            objects = [];\n            objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n        }\n        this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod;\n        this.commandHandler.sameSize(objects, option);\n        this.commandHandler.getBlazorOldValues();\n        this.canEnableBlazorObject = false;\n        this.callBlazorModel = true;\n    };\n    Diagram.prototype.updateBlazorDiagramProperties = function (attribute, canCall) {\n        //Removed isBlazor code\n        if (canCall) {\n            // this.commandHandler.getDiagramOldValues(this.oldDiagramObject, attribute);\n        }\n    };\n    Diagram.prototype.getZoomingAttribute = function () {\n        var attribute = [];\n        attribute.push('scrollSettings');\n        attribute.push('snapSettings');\n        return attribute;\n    };\n    /**\n     * Scales the diagram control based on the provided zoom factor. You can optionally specify a focused point around which the diagram will be zoomed.\n     *\n     * @returns { void } Scales the diagram control based on the provided zoom factor. You can optionally specify a focused point around which the diagram will be zoomed.\\\n     * @param {number} factor - Defines the factor by which the diagram is zoomed.\n     * @param {PointModel} focusedPoint - Defines the point with respect to which the diagram will be zoomed.\n     */\n    Diagram.prototype.zoom = function (factor, focusedPoint) {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        this.scroller.zoom(factor, 0, 0, focusedPoint);\n        if (!(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.interaction)) {\n            this.updateBlazorDiagramProperties(attribute, true);\n        }\n    };\n    /**\n     * Scales the diagram control based on the provided options, which include the desired zoom factor, focus point, and zoom type.\n     *\n     * @returns { void }  Scales the diagram control based on the provided options, which include the desired zoom factor, focus point, and zoom type.\\\n     * @param {ZoomOptions} options - An object specifying the zoom factor, focus point, and zoom type.\n     *\n     */\n    Diagram.prototype.zoomTo = function (options) {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        var factor = options.zoomFactor ? options.zoomFactor : 0.2;\n        factor = options.type === 'ZoomOut' ? 1 / (1 + factor) : (1 + factor);\n        this.scroller.zoom(factor, 0, 0, options.focusPoint);\n        this.updateBlazorDiagramProperties(attribute, true);\n    };\n    /**\n     * Pans the diagram control to the given horizontal and vertical offsets.\n     *\n     * @returns { void } Pans the diagram control to the given horizontal and vertical offsets.\\\n     * @param {number} horizontalOffset - The horizontal distance to which the diagram should be scrolled.\n     * @param {number} verticalOffset - The vertical distance to which the diagram should be scrolled.\n     * @param {PointModel} focusedPoint - representing the focused point during panning.\n     * @param {boolean} isInteractiveZoomPan - A boolean indicating whether the panning is interactive zoom pan.\n     */\n    Diagram.prototype.pan = function (horizontalOffset, verticalOffset, focusedPoint, isInteractiveZoomPan) {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        this.setCursor('grabbing');\n        this.scroller.zoom(1, horizontalOffset, verticalOffset, focusedPoint, isInteractiveZoomPan);\n        this.updateBlazorDiagramProperties(attribute, true);\n    };\n    /**\n     * Resets the zoom and scroller offsets to their default values.\n     *\n     * @returns { void } Resets the zoom and scroller offsets to their default values.\\\n     */\n    Diagram.prototype.reset = function () {\n        var attribute = this.getZoomingAttribute();\n        this.updateBlazorDiagramProperties(attribute);\n        this.scroller.zoom(1 / this.scroller.currentZoom, -this.scroller.horizontalOffset, -this.scroller.verticalOffset, { x: 0, y: 0 });\n        this.updateBlazorDiagramProperties(attribute, true);\n    };\n    /**\n     * Resets the segments of the connectors to their default state. This removes any custom segments and restores the connectors to their original configuration.\n     *\n     * @returns { void } Resets the segments of the connectors to their default state. This removes any custom segments and restores the connectors to their original configuration. \\\n     */\n    Diagram.prototype.resetSegments = function () {\n        var previousConnectorObject = [];\n        var updateConnectorObject = [];\n        var changeConnectors = [];\n        //Removed isBlazor code\n        if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting && this.lineRoutingModule) {\n            this.lineRoutingModule.lineRouting(this);\n        }\n        else {\n            this.protectPropertyChange(true);\n            var connector = void 0;\n            for (var i = 0; i < this.connectors.length; i++) {\n                connector = this.connectors[parseInt(i.toString(), 10)];\n                connector.segments = [];\n                this.connectorPropertyChange(connector, {}, { segments: connector.segments });\n                if (this.avoidLineOverlappingModule) {\n                    this.avoidLineOverlappingModule.removeConnector(connector);\n                }\n            }\n            this.protectPropertyChange(false);\n        }\n        //Removed isBlazor code\n    };\n    /**\n     * setBlazorDiagramProps method\n     *\n     * @returns {void} setBlazorDiagramProps method .\\\n     * @param {boolean} arg - provide the eventName value.\n     * @private\n     */\n    Diagram.prototype.setBlazorDiagramProps = function (arg) {\n        var attribute = this.getZoomingAttribute();\n        if (arg) {\n            this.updateBlazorDiagramProperties(attribute);\n        }\n        else {\n            this.updateBlazorDiagramProperties(attribute, true);\n        }\n    };\n    /**\n     * getDirection method\n     *\n     * @returns { Promise<void | object> } getDirection method .\\\n     * @param {DiagramEvent} eventName - provide the eventName value.\n     * @param {Object} args - provide the args value.\n     * @private\n     */\n    Diagram.prototype.triggerEvent = function (eventName, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var eventArgs;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (args) {\n                            this.updateEventValue(args);\n                        }\n                        return [4 /*yield*/, this.trigger(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent[\"\" + eventName], args)];\n                    case 1:\n                        eventArgs = _a.sent();\n                        //Removed isBlazor code.\n                        return [2 /*return*/, eventArgs];\n                }\n            });\n        });\n    };\n    Diagram.prototype.updateEventValue = function (args) {\n        var element = args.element;\n        if (args.element && element instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Selector && (element.nodes.length + element.connectors.length === 1)) {\n            args.element = (element.nodes.length === 1) ? element.nodes[0] : element.connectors[0];\n        }\n    };\n    /**\n     * Adds the specified node to a lane within a swimlane.\n     *\n     * @returns { void }     Adds the specified node to a lane within a swimlane. \\\n     * @param {NodeModel} node - representing the node to be added to the lane.\n     * @param {string} swimLane - A string representing the ID of the swimlane containing the lane.\n     * @param {string} lane - A string representing the ID of the lane where the node will be added.\n     * @deprecated\n     */\n    Diagram.prototype.addNodeToLane = function (node, swimLane, lane) {\n        if (this.nameTable[\"\" + swimLane]) {\n            var swimlaneNode = this.nameTable[\"\" + swimLane];\n            this.protectPropertyChange(true);\n            if (this.undoRedoModule) {\n                this.historyManager.startGroupAction();\n            }\n            if (!this.nameTable[node.id]) {\n                node.offsetX = swimlaneNode.wrapper.bounds.width + swimlaneNode.wrapper.bounds.x;\n                node.offsetY = swimlaneNode.wrapper.bounds.height + swimlaneNode.wrapper.bounds.y;\n                node = this.add(node);\n            }\n            node.parentId = '';\n            if (!swimlaneNode.shape.phases.length) {\n                var laneId = swimLane + lane + '0';\n                if (this.nameTable[\"\" + laneId]) {\n                    //Bug 913801: Adding an existing node into a lane as child won't be interactive.\n                    //Added below method call to update the zIndex of newly added child node.\n                    this.commandHandler.updateLaneChildrenZindex(node, this.nameTable[\"\" + laneId]);\n                    (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.addChildToContainer)(this, this.nameTable[\"\" + laneId], node, undefined, true);\n                    (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.updateLaneBoundsAfterAddChild)(this.nameTable[\"\" + laneId], swimlaneNode, node, this);\n                }\n            }\n            else {\n                for (var i = 0; i < swimlaneNode.shape.phases.length; i++) {\n                    var laneId = swimLane + lane + i;\n                    if (this.nameTable[\"\" + laneId] && this.nameTable[\"\" + laneId].isLane) {\n                        var laneNode = this.nameTable[\"\" + laneId].wrapper.bounds;\n                        var focusPoint = {\n                            x: laneNode.x +\n                                (laneNode.x - swimlaneNode.wrapper.bounds.x + node.margin.left + (node.wrapper.bounds.width / 2)),\n                            y: laneNode.y + swimlaneNode.wrapper.bounds.y - node.margin.top\n                        };\n                        if (swimlaneNode.shape.orientation === 'Horizontal') {\n                            focusPoint.y = laneNode.y;\n                        }\n                        else {\n                            focusPoint.x = laneNode.x;\n                            var laneHeaderId = this.nameTable[\"\" + laneId].parentId +\n                                swimlaneNode.shape.lanes[0].id + '_0_header';\n                            focusPoint.y = laneNode.y +\n                                (swimlaneNode.wrapper.bounds.y - this.nameTable[\"\" + laneHeaderId].wrapper.bounds.height +\n                                    node.margin.top + (node.wrapper.bounds.height / 2));\n                        }\n                        if ((laneId === swimLane + lane + (swimlaneNode.shape.phases.length - 1)) ||\n                            laneNode.containsPoint(focusPoint)) {\n                            //Bug 913801: Adding an existing node into a lane as child won't be interactive.\n                            //Added below method call to update the zIndex of newly added child node.\n                            this.commandHandler.updateLaneChildrenZindex(node, this.nameTable[\"\" + laneId]);\n                            (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.addChildToContainer)(this, this.nameTable[\"\" + laneId], node, undefined, true);\n                            (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.updateLaneBoundsAfterAddChild)(this.nameTable[\"\" + laneId], swimlaneNode, node, this);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (this.undoRedoModule) {\n                this.historyManager.endGroupAction();\n            }\n            this.protectPropertyChange(false);\n        }\n        this.updateDiagramElementQuad();\n    };\n    /**\n     * Displays a tooltip for the specified diagram object.\n     *\n     * @param {NodeModel | ConnectorModel} obj - The object for which the tooltip will be shown.\n     */\n    Diagram.prototype.showTooltip = function (obj) {\n        if (obj && obj.id && !obj.wrapper) {\n            obj = this.nameTable[obj.id];\n        }\n        var bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getBounds)(obj.wrapper);\n        var position = { x: 0, y: 0 };\n        var content = obj.tooltip.content ?\n            obj.tooltip.content : 'X:' + Math.round(bounds.x) + ' ' + 'Y:' + Math.round(bounds.y);\n        if (obj && obj.tooltip.openOn === 'Custom') {\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                position = { x: obj.offsetX + (obj.width / 2), y: obj.offsetY + (obj.height / 2) };\n            }\n            else {\n                position = { x: obj.targetPoint.x, y: obj.targetPoint.x };\n            }\n            this.commandHandler.showTooltip(obj, position, content, 'SelectTool', true);\n        }\n    };\n    /**\n     * Hides the tooltip for the corresponding diagram object.\n     *\n     * @param {NodeModel | ConnectorModel} obj - The node or connector object for which the tooltip should be hidden.\n     */\n    Diagram.prototype.hideTooltip = function (obj) {\n        if (obj && obj.tooltip.openOn === 'Custom') {\n            this.tooltipObject.close();\n        }\n    };\n    /**\n     * Adds the specified node to the diagram control.\n     *\n     * @returns { Node }     Adds the specified node to the diagram control.\\\n     * @param {NodeModel} obj - representing the node to be added to the diagram.\n     * @param {boolean} group - A boolean value indicating whether the node should be added to a group.\n     * @blazorArgsType obj|DiagramNode\n     */\n    Diagram.prototype.addNode = function (obj, group) {\n        return this.add(obj, group);\n    };\n    /**\n     * Adds the specified diagram object to the specified group node.\n     *\n     * @returns { void }     Adds the specified diagram object to the specified group node.\\\n     * @param {NodeModel} group - The group node to which the diagram object will be added.\n     * @param {string | NodeModel | ConnectorModel} child - The diagram object to be added to the group.\n     * @blazorArgsType obj|DiagramNode\n     */\n    Diagram.prototype.addChildToGroup = function (group, child) {\n        var severDataBind = this.allowServerDataBinding;\n        this.enableServerDataBinding(false);\n        var propChange = this.isProtectedOnChange;\n        this.protectPropertyChange(true);\n        group = this.getObject(group.id);\n        //Removed isBlazor code\n        var isHistoryAdded = (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo) && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Group) &&\n            !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory));\n        if (isHistoryAdded) {\n            this.startGroupAction();\n        }\n        var id = this.addChild(group, child);\n        if (isHistoryAdded) {\n            var childTable = {};\n            childTable[\"\" + id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.getObject(id));\n            var entry = {\n                type: 'AddChildToGroupNode', changeType: 'Insert', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(group),\n                redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(group), category: 'Internal', objectId: id, childTable: childTable\n            };\n            this.addHistoryEntry(entry);\n            this.endGroupAction();\n        }\n        //880811- Adding child to group node using addChildToGroup method is not working properly.\n        var element = this.nameTable[child] ? this.nameTable[child] : child;\n        var childElementToMove = document.getElementById(element.id + '_groupElement');\n        var targetGroupElement = document.getElementById(group.id + '_groupElement');\n        if (targetGroupElement && childElementToMove) {\n            targetGroupElement.appendChild(childElementToMove);\n        }\n        this.protectPropertyChange(propChange);\n        this.enableServerDataBinding(severDataBind);\n        this.updateSelector();\n        //Removed isBlazor code.\n    };\n    /**\n     * Removes the specified diagram object from the specified group node.\n     *\n     * @returns { void }     Removes the specified diagram object from the specified group node.\\\n     * @param {NodeModel} group - The group node to which the diagram object will be removed.\n     * @param {string | NodeModel | ConnectorModel} child - The diagram object to be removed from the group.\n     */\n    Diagram.prototype.removeChildFromGroup = function (group, child) {\n        var severDataBind = this.allowServerDataBinding;\n        this.enableServerDataBinding(false);\n        var propChange = this.isProtectedOnChange;\n        this.protectPropertyChange(true);\n        group = this.getObject(group.id);\n        var undoGroup = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(group);\n        var isHistoryAdded = (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo) && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Group) &&\n            !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory));\n        if (isHistoryAdded) {\n            this.startGroupAction();\n        }\n        var id = this.removeChild(group, child);\n        if (isHistoryAdded) {\n            var childTable = {};\n            childTable[\"\" + id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.getObject(id));\n            var entry = {\n                type: 'RemoveChildFromGroupNode', changeType: 'Remove', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(undoGroup),\n                redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(group), category: 'Internal', objectId: id, childTable: childTable\n            };\n            this.addHistoryEntry(entry);\n            this.endGroupAction();\n        }\n        //880811 - diagram elements not updated properly while grouping nodes at runtime\n        var element = this.nameTable[child] ? this.nameTable[child] : child;\n        var elementZindex = element.zIndex;\n        var layerNum = this.layers.indexOf(this.commandHandler.getObjectLayer(element.id));\n        var insertBeforeObj = this.layers[parseInt(layerNum.toString(), 10)].objects[elementZindex + 1];\n        var insertBeforeElement = document.getElementById(insertBeforeObj + '_groupElement');\n        var childElementToMove = document.getElementById(element.id + '_groupElement');\n        var targetGroupElement = document.getElementById(group.id + '_groupElement');\n        if (targetGroupElement && childElementToMove) {\n            if (insertBeforeObj && insertBeforeElement) {\n                if (targetGroupElement.contains(insertBeforeElement)) {\n                    targetGroupElement.insertBefore(childElementToMove, insertBeforeElement);\n                }\n                else if (targetGroupElement.parentNode.contains(insertBeforeElement) && insertBeforeElement.parentElement\n                    === targetGroupElement.parentElement) {\n                    targetGroupElement.parentNode.insertBefore(childElementToMove, insertBeforeElement);\n                }\n                else {\n                    targetGroupElement.parentNode.appendChild(childElementToMove);\n                }\n            }\n            else {\n                targetGroupElement.parentNode.appendChild(childElementToMove);\n            }\n        }\n        this.protectPropertyChange(propChange);\n        this.enableServerDataBinding(severDataBind);\n        this.updateSelector();\n    };\n    /**\n     * Retrieves the history stack values for either undo or redo actions.\n     *\n     * @returns { void } Retrieves the history stack values for either undo or redo actions.\\\n     * @param {boolean} isUndoStack - If `true`, retrieves the undo stack values; if `false`, retrieves the redo stack values.\n     */\n    Diagram.prototype.getHistoryStack = function (isUndoStack) {\n        //let temp: HistoryEntry[];\n        var historyEntry = [];\n        var temp = isUndoStack ? this.historyManager.undoStack : this.historyManager.redoStack;\n        if (this.historyManager.stackLimit !== undefined) {\n            for (var i = temp.length - 1; i >= 0; i--) {\n                historyEntry.push(temp[parseInt(i.toString(), 10)]);\n                if (historyEntry.length > this.historyManager.stackLimit) {\n                    return historyEntry;\n                }\n            }\n        }\n        else {\n            historyEntry = temp;\n        }\n        return historyEntry;\n    };\n    /* tslint:disable */\n    /**\n     * Returns the edges connected to the given node.\n     *\n     * @returns { string[] } Returns the edges connected to the given node. \\\n     * @deprecated\n     * @param {Object} args - An object containing information about the node for which edges are to be retrieved.\n     */\n    Diagram.prototype.getEdges = function (args) {\n        return args['outEdge'] ? this.nameTable[args['id']].outEdges : this.nameTable[args['id']].inEdges;\n    };\n    /* tslint:enable */\n    /**\n     * Returns the parent id for the node\n     *\n     * @returns { string }Returns the parent id for the node .\\\n     * @deprecated\n     * @param {string} id - returns the parent id\n     */\n    Diagram.prototype.getParentId = function (id) {\n        return this.nameTable[\"\" + id].parentId;\n    };\n    /**\n     * Adds the given connector to diagram control\n     * @returns { Connector } Adds the given connector to diagram control .\\\n     *\n     * @param {ConnectorModel} obj - Defines the connector that has to be added to diagram\n     * @blazorArgsType obj|DiagramConnector\n     */\n    Diagram.prototype.addConnector = function (obj) {\n        return this.add(obj);\n    };\n    /* eslint-disable */\n    /** @private */\n    Diagram.prototype.UpdateBlazorDiagramModelCollection = function (obj, copiedObject, multiSelectDelete, isBlazorGroupUpdate) {\n        /* eslint-enable */\n        //Removed isBlazor code\n    };\n    /**\n     *  UpdateBlazorDiagramModel method\n     *\n     * @returns { void }  UpdateBlazorDiagramModel method .\\\n     * @param {Node | Connector | ShapeAnnotation | PathAnnotation} obj - provide the obj value.\n     * @param {string} objectType - provide the objectType value.\n     * @param {number} removalIndex - provide the removalIndex value.\n     * @param {number} annotationNodeIndex - provide the annotationNodeIndex value.\n     *\n     * @private\n     */\n    Diagram.prototype.UpdateBlazorDiagramModel = function (obj, objectType, removalIndex, annotationNodeIndex) {\n        //Removed isBlazor code\n    };\n    // eslint-disable-next-line max-len\n    Diagram.prototype.UpdateBlazorLabelOrPortObjects = function (obj, objectType, removalIndex, nodeIndex) {\n        //Removed isBlazor code\n    };\n    /**\n     *  addBlazorDiagramObjects method\n     *\n     * @returns { void }  addBlazorDiagramObjects method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.addBlazorDiagramObjects = function () {\n        //Removed isBlazor code\n    };\n    Diagram.prototype.removeNodeEdges = function (elementId, id, isOutEdges) {\n        var node = this.nameTable[\"\" + elementId];\n        var edges = isOutEdges ? node.outEdges : node.inEdges;\n        if (edges.length > 0) {\n            for (var i = 0; i < edges.length; i++) {\n                if (edges[parseInt(i.toString(), 10)] === id) {\n                    edges.splice(i, 1);\n                }\n            }\n        }\n    };\n    /**\n     *  insertBlazorConnector method\n     *\n     * @returns { void }  insertBlazorConnector method .\\\n     * @param {Connector} obj - provide the nodeId value.\n     *\n     * @private\n     */\n    Diagram.prototype.insertBlazorConnector = function (obj) {\n        //Removed isBlazor code\n    };\n    /* tslint:disable */\n    /**\n     * Adds the provided object, which can be a node, group, or connector, onto the diagram canvas.\n     *\n     * @returns { Node | Connector }     Adds the provided object, which can be a node, group, or connector, onto the diagram canvas.\\\n     * @param {NodeModel | ConnectorModel} obj - Specifies the object to be added to the diagram.\n     * @param {boolean} group - If a group object is passed, set it to true.\n     */\n    Diagram.prototype.add = function (obj, group) {\n        var newObj;\n        var propertyChangeValue = this.isProtectedOnChange;\n        this.protectPropertyChange(true);\n        var isTextAnnotationNode = false;\n        if (obj) {\n            obj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj);\n            var args = void 0;\n            args = {\n                element: obj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions), state: 'Changing', type: 'Addition', cancel: false\n            };\n            if (this.parentObject) {\n                args.parentId = this.parentObject.id;\n            }\n            //Removed isBlazor code\n            if (obj.id !== 'helper' && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventCollectionChangeOnDragOver)) {\n                this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.collectionChange, args);\n            }\n            if (args.cancel && this.drawingObject) {\n                this.removeElements(args.element);\n                this.tooltipObject.close();\n                var sourceNodee = this.getObject(args.element.sourceID);\n                var isOutEdgee = void 0;\n                if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(args.element) === _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                    if (args.element.sourceID) {\n                        this.removeNodeEdges(args.element.sourceID, args.element.id, true);\n                        if (sourceNodee.ports.length > 0) {\n                            for (var i = 0; i < sourceNodee.ports.length; i++) {\n                                var port = sourceNodee.ports[parseInt(i.toString(), 10)];\n                                if (port.id === args.element.sourcePortID) {\n                                    if (port.outEdges.length > 0) {\n                                        isOutEdgee = false;\n                                    }\n                                    else {\n                                        isOutEdgee = true;\n                                    }\n                                }\n                            }\n                            this.removePortEdges(sourceNodee, args.element.sourcePortID, args.element.id, isOutEdgee);\n                        }\n                    }\n                    if (args.element.targetID) {\n                        this.removeNodeEdges(args.element.targetID, args.element.id, false);\n                    }\n                }\n            }\n            this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod;\n            obj.id = obj.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n            var layers = this.activeLayer;\n            // Bug 890792: Exception thrown when adding a node at runtime in the unit test case.\n            // The issue arises only when the diagram is not appended to the DOM. In such cases, the diagram will not be rendered, and the activeLayer property is undefined.\n            // Check if activeLayer is defined. If activeLayer is defined, then proceed with the operation.\n            if (!args.cancel && layers && !layers.lock) {\n                if (layers.objects.indexOf(obj.id) < 0 && !layers.lock) {\n                    if (!layers.visible) {\n                        layers.visible = true;\n                        this.dataBind();\n                    }\n                    layers.objects.push(obj.id);\n                }\n                if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(obj) === _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                    newObj = new _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector(this, 'connectors', obj, true);\n                    newObj.status = 'New';\n                    if (this.nameTable[newObj.targetID] && this.nameTable[newObj.targetID].shape.shape === 'TextAnnotation') {\n                        newObj.isBpmnAnnotationConnector = true;\n                        newObj.constraints = newObj.constraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ConnectorConstraints.Delete;\n                    }\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateDefaultValues)(newObj, obj, this.connectorDefaults);\n                    this.connectors.push(newObj);\n                    this.initObject(newObj);\n                    //Removed isBlazor code\n                    if (obj.visible === false) {\n                        this.updateElementVisibility(newObj.wrapper, newObj, obj.visible);\n                    }\n                    this.updateEdges(newObj);\n                    this.insertBlazorConnector(newObj);\n                }\n                else {\n                    newObj = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node(this, 'nodes', obj, true);\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateDefaultValues)(newObj, obj, this.nodeDefaults);\n                    newObj.parentId = (obj.parentId) ? obj.parentId : newObj.parentId;\n                    newObj.umlIndex = obj.umlIndex;\n                    newObj.status = 'New';\n                    isTextAnnotationNode = newObj.shape.shape === 'TextAnnotation';\n                    if (isTextAnnotationNode && !obj.isTextAnnotationCopied) {\n                        newObj.inEdges = obj.inEdges ? obj.inEdges : newObj.inEdges;\n                    }\n                    this.nodes.push(newObj);\n                    this.initObject(newObj, layers, undefined, group);\n                    if (isTextAnnotationNode) {\n                        if (this.bpmnModule) {\n                            for (var i = 0; i < this.bpmnModule.bpmnTextAnnotationConnector.length; i++) {\n                                if (this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)].wrapper === null) {\n                                    this.initConnectors(this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)], undefined, true);\n                                }\n                            }\n                        }\n                    }\n                    //Removed isBlazor code\n                    this.updateTemplate();\n                    if (this.bpmnModule) {\n                        if (newObj.shape.activity && newObj.shape.activity.subProcess.processes &&\n                            newObj.shape.activity.subProcess.processes.length) {\n                            this.bpmnModule.updateDocks(newObj, this);\n                        }\n                    }\n                    if (this.lineRoutingModule && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting)) {\n                        var objects = this.spatialSearch.findObjects(newObj.wrapper.outerBounds);\n                        for (var i = 0; i < objects.length; i++) {\n                            var object = objects[parseInt(i.toString(), 10)];\n                            if (object instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                                this.connectorPropertyChange(object, {}, {\n                                    sourceID: object.sourceID, targetID: object.targetID, sourcePortID: object.sourcePortID,\n                                    targetPortID: object.targetPortID, sourcePoint: object.sourcePoint, targetPoint: object.targetPoint\n                                });\n                            }\n                        }\n                    }\n                    else if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting) {\n                        console.warn('[WARNING] :: Module \"LineRouting\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n                    }\n                    if (newObj.umlIndex > -1 && obj.parentId && this.nameTable[obj.parentId] &&\n                        this.nameTable[obj.parentId].shape.type === 'UmlClassifier') {\n                        var parent_2 = this.nameTable[obj.parentId];\n                        parent_2.children.splice(newObj.umlIndex, 0, newObj.id);\n                        parent_2.wrapper.children.splice(newObj.umlIndex, 0, newObj.wrapper);\n                        parent_2.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size());\n                        parent_2.wrapper.arrange(parent_2.wrapper.desiredSize);\n                        this.updateDiagramObject(parent_2);\n                    }\n                }\n                args = {\n                    element: newObj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions), state: 'Changed', type: 'Addition', cancel: false\n                };\n                if (this.parentObject) {\n                    args.parentId = this.parentObject.id;\n                }\n                //Removed isBlazor code\n                if (obj.id !== 'helper' && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventCollectionChangeOnDragOver)) {\n                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.collectionChange, args);\n                }\n                if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo) && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Group) &&\n                    !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory)) {\n                    var entry = {\n                        type: 'CollectionChanged', changeType: 'Insert', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj),\n                        redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal'\n                    };\n                    this.addHistoryEntry(entry);\n                }\n                this.parentObject = undefined;\n                if (this.mode === 'SVG') {\n                    this.updateSvgNodes(newObj);\n                    this.updateTextElementValue(newObj);\n                    this.updateDiagramObject(newObj);\n                    if (isTextAnnotationNode) {\n                        var con = this.nameTable[newObj.inEdges[0]];\n                        this.updateDiagramObject(con);\n                    }\n                    if (newObj.shape.activity && newObj.shape.activity.subProcess.processes &&\n                        newObj.shape.activity.subProcess.processes.length) {\n                        this.updateProcesses(newObj);\n                    }\n                    this.updateBridging();\n                }\n            }\n        }\n        this.protectPropertyChange(propertyChangeValue);\n        this.resetDiagramActions(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod);\n        if (newObj && this.layers.length > 1) {\n            this.moveNode(newObj);\n        }\n        // Bug 890792: Exception thrown when adding a node at runtime in the unit test case.\n        // The issue arises only when the diagram is not appended to the DOM. In such cases, the diagram will not be rendered, and the views property is undefined.\n        // Check if views is defined before iterating. If views is defined, then refresh the canvas for each view.\n        if (this.views) {\n            for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n                var temp = _a[_i];\n                var view = this.views[\"\" + temp];\n                if (!(view instanceof Diagram)) {\n                    this.refreshCanvasDiagramLayer(view);\n                }\n            }\n        }\n        this.renderReactTemplates();\n        return newObj;\n    };\n    /**\n     * AddElements method allows us to add diagram elements such as nodes and connectors as a collection into the diagram canvas.\n     * @returns {void} -AddElements method.\n     * @param { NodeModel[] | ConnectorModel[]} obj -Specifies the colelction object to be added to the diagram.\n     * @public method\n     **/\n    Diagram.prototype.addElements = function (obj) {\n        for (var i = 0; i < obj.length; i++) {\n            this.add(obj[parseInt(i.toString(), 10)]);\n        }\n        // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes\n        if (this.pathDataStorage) {\n            this.pathDataStorage.clear();\n        }\n    };\n    /**\n     * getPathdata from path data storage to access the path elements points\n     * @returns {PointModel[]} - Ruturns points of the path data\n     * @param {string} key - Path data as key\n     *\n     * @private\n     */\n    Diagram.prototype.getPathData = function (key) {\n        // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes\n        if (!this.pathDataStorage) {\n            this.pathDataStorage = new Map();\n        }\n        if (!this.pathDataStorage.has(key)) {\n            return [];\n        }\n        return this.pathDataStorage.get(key);\n    };\n    /**\n     * setPathdata to path data storage to access the path elements points\n     * @returns {void} - Set Path data method\n     * @param {string} key - Path data as key\n     * @param {PointModel[]} data - Path data's points\n     *\n     * @private\n     */\n    Diagram.prototype.setPathData = function (key, data) {\n        // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes\n        var existingData = this.pathDataStorage.get(key) || [];\n        // Push data only if existingData is empty\n        if (existingData.length === 0) {\n            this.pathDataStorage.set(key, data);\n        }\n    };\n    /* tslint:enable */\n    Diagram.prototype.updateSvgNodes = function (node) {\n        if (node.children) {\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var j = _a[_i];\n                if (this.nameTable[\"\" + j] && this.nameTable[\"\" + j].parentId) {\n                    var child = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(j + '_groupElement', this.element.id);\n                    if (child) {\n                        child.parentNode.removeChild(child);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     *  updateProcesses method\n     *\n     * @returns { void }  updateProcesses method .\\\n     * @param {(Node | Connector)} node - provide the nodeId value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateProcesses = function (node) {\n        if (this.bpmnModule && node && node.shape && node.shape.activity &&\n            node.shape.activity.subProcess.processes &&\n            node.shape.activity.subProcess.processes.length) {\n            var processes = node.shape.activity.subProcess.processes;\n            this.moveSvgNode(node.id);\n            for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {\n                var j = processes_1[_i];\n                this.moveSvgNode(j);\n                var edges = [];\n                edges = edges.concat(this.nameTable[\"\" + j].outEdges, this.nameTable[\"\" + j].inEdges);\n                for (var i = edges.length - 1; i >= 0; i--) {\n                    this.moveSvgNode(edges[parseInt(i.toString(), 10)]);\n                }\n            }\n            for (var _a = 0, processes_2 = processes; _a < processes_2.length; _a++) {\n                var j = processes_2[_a];\n                if (this.nameTable[\"\" + j].shape.activity.subProcess.processes &&\n                    this.nameTable[\"\" + j].shape.activity.subProcess.processes.length) {\n                    this.updateProcesses(this.nameTable[\"\" + j]);\n                }\n            }\n        }\n        else {\n            this.moveSvgNode(node.id);\n        }\n    };\n    /**\n     *  moveSvgNode method\n     *\n     * @returns { void }  moveSvgNode method .\\\n     * @param {string} nodeId - provide the nodeId value.\n     *\n     * @private\n     */\n    Diagram.prototype.moveSvgNode = function (nodeId) {\n        var child = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(nodeId + '_groupElement', this.element.id);\n        var parent = child.parentElement;\n        child.parentNode.removeChild(child);\n        parent.appendChild(child);\n    };\n    /**\n     * Adds the given annotation to the specified node.\n     *\n     * @returns { void } Adds the given annotation to the specified node.\\\n     * @param {BpmnAnnotationModel} annotation - Object representing the annotation to be added.\n     * @param {NodeModel} node - object representing the node to which the annotation will be added.\n     * @deprecated\n     */\n    Diagram.prototype.addTextAnnotation = function (annotation, node) {\n        if (this.bpmnModule) {\n            this.getBPMNTextAnnotation(node, this, annotation, true);\n        }\n    };\n    //Splice the InEdge and OutEdge of the for the node with respect to corresponding connectors that is deleting\n    Diagram.prototype.spliceConnectorEdges = function (connector, isSource) {\n        //let node: Node;\n        var edges = [];\n        //let isInEdge: boolean;\n        var node = isSource ? this.nameTable[connector.sourceID] : this.nameTable[connector.targetID];\n        if (node) {\n            edges = isSource ? node.outEdges : node.inEdges;\n            for (var i = edges.length - 1; i >= 0; i--) {\n                if (edges[parseInt(i.toString(), 10)] === connector.id) {\n                    edges.splice(i, 1);\n                }\n            }\n            for (var j = 0; node.ports && j < node.ports.length; j++) {\n                var isInEdge = isSource ? false : true;\n                this.removePortEdges(node, node.ports[parseInt(j.toString(), 10)].id, connector.id, isInEdge);\n            }\n        }\n    };\n    /**\n     * Remove the dependent connectors if the node is deleted\n     * @returns { void } Remove the dependent connectors if the node is deleted .\\\n     * @param {Node} obj - provide the node value.\n     *\n     * @private\n     */\n    Diagram.prototype.removeDependentConnector = function (obj) {\n        if (obj) {\n            var connector = void 0;\n            var edges = [];\n            edges = edges.concat(obj.outEdges, obj.inEdges);\n            for (var i = edges.length - 1; i >= 0; i--) {\n                connector = this.nameTable[edges[parseInt(i.toString(), 10)]];\n                if (connector) {\n                    this.connectorTable[connector.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(connector);\n                    //To check for text annotation connector and remove the dependent text annotation node.\n                    if (connector.isBpmnAnnotationConnector) {\n                        var targetNode = this.nameTable[connector.targetID];\n                        this.removeObjectsFromLayer(connector);\n                        var index = this.connectors.indexOf(connector);\n                        if (index !== -1) {\n                            this.connectors.splice(index, 1);\n                        }\n                        this.removeElements(connector);\n                        this.removeFromAQuad(connector);\n                        delete this.nameTable[connector.id];\n                        var sourceNode = this.nameTable[connector.sourceID];\n                        if (sourceNode) {\n                            var index_1 = sourceNode.outEdges.indexOf(connector.id);\n                            if (index_1 !== -1) {\n                                sourceNode.outEdges.splice(index_1, 1);\n                            }\n                        }\n                        if (obj.id !== connector.targetID) {\n                            this.remove(targetNode);\n                        }\n                    }\n                    else {\n                        this.remove(connector);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Remove the dependent connectors if the node is deleted\n     * @returns { void } Remove the dependent connectors if the node is deleted .\\\n     * @param {(NodeModel | ConnectorModel)} obj - provide the node value.\n     *\n     * @private\n     */\n    Diagram.prototype.removeObjectsFromLayer = function (obj) {\n        if (obj.children) {\n            for (var i = 0; i < obj.children.length; i++) {\n                var object = this.nameTable[obj.children[parseInt(i.toString(), 10)]];\n                if (object) {\n                    this.removeObjectsFromLayer(object);\n                }\n            }\n        }\n        var layer = this.layers.indexOf(this.commandHandler.getObjectLayer(obj.id));\n        var objects = this.layers[parseInt(layer.toString(), 10)].objects;\n        var objIndex = objects.indexOf(obj.id);\n        if (objIndex > -1) {\n            if ((0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.isSelected)(this, obj)) {\n                this.unSelect(obj);\n            }\n            this.layers[parseInt(layer.toString(), 10)].objects.splice(objIndex, 1);\n            delete this.layers[parseInt(layer.toString(), 10)].zIndexTable[this.nameTable[obj.id].zIndex];\n        }\n    };\n    /**\n     * removeElements method \\\n     *\n     * @returns { string }     removeElements method .\\\n     * @param {NodeModel | ConnectorModel} currentObj - provide the currentObj value.\n     *\n     * @private\n     */\n    Diagram.prototype.removeElements = function (currentObj) {\n        if (this.mode === 'SVG' || (this.mode === 'Canvas' && currentObj.shape.type === 'Native')) {\n            var removeElement_1 = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(currentObj.id + '_groupElement', this.element.id);\n            var object = currentObj;\n            if ((object).ports && (object).ports.length > 0) {\n                for (var i = 0; i < (object).ports.length; i++) {\n                    var port = (object).ports[parseInt(i.toString(), 10)];\n                    var removePort = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(object.id + '_' + port.id + '_groupElement', this.element.id);\n                    if (removePort) {\n                        removePort.parentNode.removeChild(removePort);\n                    }\n                }\n            }\n            if (removeElement_1) {\n                removeElement_1.parentNode.removeChild(removeElement_1);\n            }\n        }\n        this.refreshCanvasLayers();\n        if (currentObj.wrapper) {\n            var children = currentObj.wrapper.children;\n            var element = void 0;\n            var view = void 0;\n            if (children) {\n                for (var i = 0; i < children.length; i++) {\n                    if (children[parseInt(i.toString(), 10)] instanceof _core_elements_native_element__WEBPACK_IMPORTED_MODULE_36__.DiagramNativeElement || ((children[parseInt(i.toString(), 10)].id) && (children[parseInt(i.toString(), 10)].id).indexOf('icon_content') > 0)) {\n                        if ((children[parseInt(i.toString(), 10)].id).indexOf('icon_content') > 0 && this.mode === 'SVG') {\n                            element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(children[parseInt(i.toString(), 10)].id + '_shape_groupElement', this.element.id);\n                            if (element) {\n                                element.parentNode.removeChild(element);\n                            }\n                            element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(children[parseInt(i.toString(), 10)].id + '_rect_groupElement', this.element.id);\n                            if (element) {\n                                element.parentNode.removeChild(element);\n                            }\n                        }\n                        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n                            var elementId = _a[_i];\n                            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(children[parseInt(i.toString(), 10)].id + '_groupElement', elementId);\n                            var nodeIndex = this.scroller.removeCollection.indexOf(currentObj.id);\n                            this.scroller.removeCollection.splice(nodeIndex, 1);\n                        }\n                    }\n                    else if (children[parseInt(i.toString(), 10)] instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_37__.DiagramHtmlElement) {\n                        for (var _b = 0, _c = this.views; _b < _c.length; _b++) {\n                            var elementId = _c[_b];\n                            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(currentObj.id + '_html_element', elementId);\n                            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(children[parseInt(i.toString(), 10)].id + '_html_element', elementId);\n                            //EJ2-63598 - Added below code to check whether platform is Angular or not.\n                            // If angular then we do not remove the node html element wrapper to retain the HTML element in it.\n                            var canUpdate = true;\n                            var parent_3 = this.nameTable[currentObj.parentId];\n                            //893691: HTML Template nodes are not visible after Zooming with Virtualisation\n                            if (((this.isAngular || this.isReact) || this.isVue) &&\n                                ((parent_3 && parent_3.isLane) || (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.Virtualization))) {\n                                canUpdate = false;\n                            }\n                            if (canUpdate) {\n                                this.clearTemplate(['nodeTemplate' + '_' + currentObj.id]);\n                                if (children[parseInt(i.toString(), 10)].annotationId) {\n                                    this.clearTemplate(['annotationTemplate' + '_' + currentObj.id +\n                                            (children[parseInt(i.toString(), 10)].annotationId)]);\n                                }\n                            }\n                        }\n                    }\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.removeGradient)(children[parseInt(i.toString(), 10)].id);\n                }\n            }\n        }\n    };\n    Diagram.prototype.removeCommand = function () {\n        this.remove();\n    };\n    /**\n     * Removes the specified object from the diagram.\n     *\n     * @param {NodeModel | ConnectorModel} obj - The node or connector object to be removed from the diagram.\n     */\n    /* tslint:disable */\n    Diagram.prototype.remove = function (obj) {\n        var selectedItems = [];\n        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n        var args;\n        var groupAction = false;\n        if (obj) {\n            obj = this.nameTable[obj.id];\n            this.insertBlazorConnector(obj);\n            if (obj && ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDelete)(obj) || (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear))) {\n                args = {\n                    element: obj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),\n                    state: 'Changing', type: 'Removal', cancel: false\n                };\n                //Removed isBlazor code\n                if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear) && (obj.id !== 'helper')) {\n                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.collectionChange, args);\n                }\n                if (!args.cancel) {\n                    if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDelete)(obj)) {\n                        if (obj && obj.shape && obj.shape.type === 'SwimLane') {\n                            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.removeSwimLane)(this, obj);\n                        }\n                    }\n                    if ((!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory) &&\n                        (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node || obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector)) {\n                        var entry = {\n                            type: 'CollectionChanged', changeType: 'Remove', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj),\n                            redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal'\n                        };\n                        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear)) {\n                            if (obj.children && !obj.isLane && !obj.isPhase && obj.children.length > 0 && this.undoRedoModule && this.layout.type === 'None') {\n                                this.historyManager.startGroupAction();\n                                groupAction = true;\n                            }\n                        }\n                        //875087 - Restrict removing dependent connectors when moveing between layers\n                        if ((obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node || obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) && this.deleteDependentConnector) {\n                            this.removeDependentConnector(obj);\n                        }\n                        if (!obj.isLane && !obj.isPhase) {\n                            if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear) && !this.isStackChild(obj)) {\n                                this.addHistoryEntry(entry);\n                            }\n                        }\n                    }\n                    if (obj.shape.shape === 'TextAnnotation') {\n                        this.removeDependentConnector(obj);\n                    }\n                    if (obj.children && !obj.isLane && !obj.isPhase &&\n                        (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo) || !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)())) {\n                        this.deleteGroup(obj);\n                    }\n                    if (obj.parentId) {\n                        this.deleteChild(obj, undefined, true);\n                        if (this.nameTable[obj.parentId] && this.nameTable[obj.parentId].shape.type === 'UmlClassifier') {\n                            this.updateDiagramObject(this.nameTable[obj.parentId]);\n                            this.updateConnectorEdges(this.nameTable[obj.parentId]);\n                        }\n                    }\n                    var index = void 0;\n                    this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod;\n                    var currentObj = this.nameTable[obj.id];\n                    if (currentObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                        if (currentObj.shape.type === 'Bpmn' && this.bpmnModule) {\n                            this.bpmnModule.removeBpmnProcesses(currentObj, this);\n                        }\n                        if (currentObj.isLane || currentObj.isPhase || currentObj.shape.type === 'SwimLane') {\n                            var swimLaneNode = (currentObj.isLane || currentObj.isPhase) ?\n                                this.nameTable[currentObj.parentId] : this.nameTable[currentObj.id];\n                            var grid = swimLaneNode.wrapper.children[0];\n                            if (currentObj.isLane) {\n                                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.removeLane)(this, currentObj, swimLaneNode);\n                            }\n                            else if (currentObj.isPhase) {\n                                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.removePhase)(this, currentObj, swimLaneNode);\n                            }\n                        }\n                        index = this.nodes.indexOf(currentObj);\n                        // Removed isBlazor code\n                        if (index !== -1) {\n                            this.crudDeleteNodes.push(this.nameTable[currentObj.id]);\n                            this.nodes.splice(index, 1);\n                            this.updateNodeEdges(currentObj);\n                        }\n                    }\n                    else {\n                        index = this.connectors.indexOf(currentObj);\n                        //Removed isBlazor code\n                        if (index !== -1) {\n                            this.crudDeleteNodes.push(this.nameTable[currentObj.id]);\n                            this.connectors.splice(index, 1);\n                        }\n                        this.updateEdges(currentObj);\n                        this.spliceConnectorEdges(obj, true);\n                        this.spliceConnectorEdges(obj, false);\n                    }\n                    if ((!this.isServerUpdate) && !(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.GroupClipboardInProcess)) {\n                        this.commandHandler.getBlazorOldValues();\n                    }\n                    if (groupAction) {\n                        this.historyManager.endGroupAction();\n                    }\n                    if ((0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.isSelected)(this, currentObj)) {\n                        this.unSelect(currentObj);\n                    }\n                    if (!currentObj.isPhase) {\n                        this.removeObjectsFromLayer(obj);\n                        if (this.currentDrawingObject) {\n                            this.currentDrawingObject.wrapper = undefined;\n                        }\n                        delete this.nameTable[obj.id];\n                        if (selectedItems.length > 0 && selectedItems[0].id === currentObj.id && currentObj.parentId) {\n                            var parentnode = this.nameTable[currentObj.parentId];\n                            if (parentnode && parentnode.isLane && this.nameTable[parentnode.parentId].shape.type === 'SwimLane') {\n                                var swimLaneNode = this.nameTable[parentnode.parentId];\n                                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.removeLaneChildNode)(this, swimLaneNode, parentnode, currentObj);\n                            }\n                        }\n                        this.removeElements(currentObj);\n                        this.updateBridging();\n                        if (this.mode !== 'SVG') {\n                            this.refreshDiagramLayer();\n                        }\n                        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear)) {\n                            this.removeFromAQuad(currentObj);\n                            args = {\n                                element: obj, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),\n                                state: 'Changed', type: 'Removal', cancel: false\n                            };\n                            //Removed isBlazor code\n                            if (obj.id !== 'helper') {\n                                this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.collectionChange, args);\n                            }\n                            this.resetTool();\n                        }\n                    }\n                }\n            }\n        }\n        else if (selectedItems.length > 0) {\n            if (this.undoRedoModule) {\n                this.historyManager.startGroupAction();\n                this.blazorActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.GroupingInProgress;\n                groupAction = true;\n            }\n            //Removed isBlazor code\n            for (var i = 0; i < selectedItems.length; i++) {\n                var node = selectedItems[parseInt(i.toString(), 10)];\n                var parent_4 = this.nameTable[node.parentId];\n                if (this.nameTable[selectedItems[parseInt(i.toString(), 10)].id]) {\n                    //Removed isBlazor code\n                    // 912905: Multi-selecting and deleting swimlane objects causes the diagram to break\n                    if (parent_4 && parent_4.shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.SwimLane && !node.isPhase) {\n                        if (node.isLane) {\n                            var parentHeader = parent_4.shape.header.id ? parent_4.shape.header.height : 0;\n                            if ((this.selectedItems.wrapper.bounds.x <= parent_4.wrapper.bounds.x &&\n                                this.selectedItems.wrapper.bounds.width >= parent_4.wrapper.bounds.width &&\n                                parent_4.shape.orientation === 'Horizontal') ||\n                                (this.selectedItems.wrapper.bounds.y <= parent_4.wrapper.bounds.y + parentHeader &&\n                                    this.selectedItems.wrapper.bounds.height >= parent_4.wrapper.bounds.height - parentHeader &&\n                                    parent_4.shape.orientation === 'Vertical')) {\n                                if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDelete)(parent_4) || parent_4.shape.lanes.length > 1) {\n                                    this.remove(selectedItems[parseInt(i.toString(), 10)]);\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        this.remove(selectedItems[parseInt(i.toString(), 10)]);\n                    }\n                    //Removed isBlazor code\n                }\n            }\n            if (groupAction) {\n                this.blazorActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.GroupingInProgress;\n                this.isServerUpdate = true;\n                this.commandHandler.getBlazorOldValues();\n                this.UpdateBlazorDiagramModelCollection(undefined, undefined, undefined, true);\n                this.historyManager.endGroupAction();\n                this.isServerUpdate = false;\n            }\n            this.clearSelection();\n        }\n        if (!(obj && ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDelete)(obj) || (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear)))) {\n            if ((!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory) &&\n                (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node || obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector)) {\n                var entry = {\n                    type: 'ConnectionChanged', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj),\n                    redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal'\n                };\n                if (!obj.isLane && !obj.isPhase) {\n                    if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear) && !this.isStackChild(obj)) {\n                        this.addHistoryEntry(entry);\n                    }\n                }\n            }\n        }\n        this.tooltipObject.close();\n        if (obj && obj.id !== 'helper' && this.lineRoutingModule && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting) &&\n            (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) && (this.layout.type !== 'ComplexHierarchicalTree')) {\n            var INFLATE_MARGIN = 40;\n            var nodeBounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getBounds)(obj.wrapper);\n            nodeBounds.Inflate(INFLATE_MARGIN);\n            var nearbyObjects = this.spatialSearch.findObjects(nodeBounds);\n            if (this.avoidLineOverlappingModule) {\n                this.avoidLineOverlappingModule.removeConnectors(nearbyObjects);\n            }\n            this.lineRoutingModule.renderVirtualRegion(this, true);\n            for (var _i = 0, nearbyObjects_1 = nearbyObjects; _i < nearbyObjects_1.length; _i++) {\n                var item = nearbyObjects_1[_i];\n                if (item instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && item.type === 'Orthogonal') {\n                    this.lineRoutingModule.refreshConnectorSegments(this, item, true);\n                }\n            }\n        }\n    };\n    /* tslint:enable */\n    Diagram.prototype.isStackChild = function (obj) {\n        var isstack;\n        var parent = this.nameTable[obj.parentId];\n        if (obj && obj.parentId && parent.container &&\n            (parent.container.type === 'Stack' &&\n                this.nameTable[obj.parentId].shape.type !== 'UmlClassifier')) {\n            isstack = true;\n            var redoElement = {\n                sourceIndex: parent.wrapper.children.indexOf(obj.wrapper), source: obj,\n                target: undefined, targetIndex: undefined\n            };\n            var entry = {\n                type: 'StackChildPositionChanged', redoObject: {\n                    sourceIndex: undefined, source: obj,\n                    target: undefined, targetIndex: undefined\n                },\n                undoObject: redoElement,\n                category: 'Internal'\n            };\n            if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n        return isstack;\n    };\n    /** @private */\n    Diagram.prototype.deleteChild = function (node, parentNode, allowChildInSwimlane) {\n        var id;\n        parentNode = parentNode ? this.nameTable[parentNode.id] : this.nameTable[node.parentId];\n        if (typeof node === 'string') {\n            id = node;\n        }\n        else {\n            id = node.id;\n        }\n        if (parentNode && parentNode.children) {\n            for (var i = 0; i < parentNode.children.length; i++) {\n                if (parentNode.children[parseInt(i.toString(), 10)] === id) {\n                    parentNode.children.splice(i, 1);\n                    for (var j = 0; j < parentNode.wrapper.children.length; j++) {\n                        if (parentNode.wrapper.children[parseInt(j.toString(), 10)].id === id) {\n                            parentNode.wrapper.children.splice(j, 1);\n                        }\n                    }\n                    // Bug 841849: Swimlane child are not positioned properly and throw exception after deleting and then undoing.\n                    // Added below condition to skip the child deletion inside swimlane when we add phase at runtime and delete swimlane.\n                    if (!allowChildInSwimlane) {\n                        // EJ2-57179 - Below lines added to remove the childs to swimlane after Redo.\n                        var swimlaneNode = this.getObject(parentNode.parentId);\n                        if (swimlaneNode && swimlaneNode.shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.SwimLane) {\n                            for (var h = 0; h < swimlaneNode.shape.lanes.length; h++) {\n                                var laneId = node.parentId.split(swimlaneNode.id);\n                                if (swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].id\n                                    === laneId[1].slice(0, -1)) {\n                                    for (var y = 0; y < swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].children.length; y++) {\n                                        if (node.id ===\n                                            swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].children[parseInt(y.toString(), 10)].id) {\n                                            swimlaneNode.shape.lanes[parseInt(h.toString(), 10)].children.splice(y, 1);\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            parentNode.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size());\n            parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);\n        }\n    };\n    /**\n     * addChild method \\\n     *\n     * @returns { string }     addChild method .\\\n     * @param {NodeModel} node - provide the node value.\n     * @param {string | NodeModel | ConnectorModel} child - provide the child value.\n     * @param {number} index - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    Diagram.prototype.addChild = function (node, child, index) {\n        var id;\n        var parentNode = this.nameTable[node.id];\n        if (!parentNode.children) {\n            parentNode.children = [];\n        }\n        if (parentNode.children) {\n            if (typeof child === 'string') {\n                if (this.nameTable[\"\" + child]) {\n                    id = child;\n                }\n            }\n            else {\n                id = child.id = child.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n                this.add(child);\n            }\n            if (id && (!child.umlIndex || child.umlIndex === -1)) {\n                var childNode = this.nameTable[\"\" + id];\n                childNode.parentId = parentNode.id;\n                if (parentNode.container && parentNode.container.type === 'Stack') {\n                    this.updateStackProperty(parentNode, childNode);\n                }\n                if (index) {\n                    parentNode.children.splice(index, 0, id);\n                    parentNode.wrapper.children.splice(index, 0, childNode.wrapper);\n                }\n                else {\n                    parentNode.children.push(id);\n                    parentNode.wrapper.children.push(childNode.wrapper);\n                    // SF-362880 - Below lines added for adding the childs to swimlane after Undo.\n                    var swimlane = this.getObject(node.parentId);\n                    var childAlreadyInCollection = false;\n                    if (swimlane && swimlane.shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.SwimLane) {\n                        for (var h = 0; h < swimlane.shape.lanes.length; h++) {\n                            var lane = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.findLane)(parentNode, this);\n                            if (swimlane.shape.lanes[parseInt(h.toString(), 10)].id === lane.id) {\n                                //Bug 876330: After performing cut operations followed by an undo, lanes and nodes in the swimlane are not rendered properly.\n                                // To avoid adding the child node multiple times in the collection.\n                                for (var i = 0; i < swimlane.shape.lanes[parseInt(h.toString(), 10)].children.length; i++) {\n                                    if (swimlane.shape.lanes[parseInt(h.toString(), 10)].children[parseInt(i.toString(), 10)].id === childNode.id) {\n                                        childAlreadyInCollection = true;\n                                        break;\n                                    }\n                                }\n                                if (!childAlreadyInCollection) {\n                                    swimlane.shape.lanes[parseInt(h.toString(), 10)].children.push(childNode);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n                parentNode.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size());\n                parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);\n                if (!parentNode.isLane) {\n                    this.nameTable[node.id].width = parentNode.wrapper.actualSize.width;\n                    this.nameTable[node.id].height = parentNode.wrapper.actualSize.height;\n                    this.nameTable[node.id].offsetX = parentNode.wrapper.offsetX;\n                    this.nameTable[node.id].offsetY = parentNode.wrapper.offsetY;\n                }\n                if (parentNode.container !== undefined) {\n                    childNode.offsetX = childNode.wrapper.offsetX;\n                    childNode.offsetY = childNode.wrapper.offsetY;\n                }\n                if (!parentNode.parentId ||\n                    (this.nameTable[parentNode.parentId] &&\n                        this.nameTable[parentNode.parentId].shape.type !== 'SwimLane')) {\n                    this.updateDiagramObject(parentNode);\n                }\n            }\n        }\n        return id;\n    };\n    /**\n     * removeChild method \\\n     *\n     * @returns { string }     removeChild method .\\\n     * @param {NodeModel} node - provide the node value.\n     * @param {string | NodeModel | ConnectorModel} child - provide the child value.\n     *\n     * @private\n     */\n    Diagram.prototype.removeChild = function (node, child) {\n        var id;\n        var parentNode = this.nameTable[node.id];\n        if (!parentNode.children) {\n            parentNode.children = [];\n        }\n        if (parentNode.children) {\n            if (typeof child === 'string') {\n                if (this.nameTable[\"\" + child]) {\n                    id = child;\n                }\n            }\n            else {\n                id = child.id = child.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n            }\n            if (id && (!child.umlIndex || child.umlIndex === -1)) {\n                var childNode = this.nameTable[\"\" + id];\n                childNode.parentId = '';\n                if (parentNode.container && parentNode.container.type === 'Stack') {\n                    this.updateStackProperty(parentNode, childNode);\n                }\n                for (var i = 0; i < parentNode.children.length; i++) {\n                    if (parentNode.children[parseInt(i.toString(), 10)] === id) {\n                        parentNode.children.splice(i, 1);\n                        for (var j = 0; j < parentNode.wrapper.children.length; j++) {\n                            if (parentNode.wrapper.children[parseInt(j.toString(), 10)] === childNode.wrapper) {\n                                parentNode.wrapper.children.splice(j, 1);\n                            }\n                        }\n                    }\n                }\n                parentNode.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size());\n                parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);\n                if (!parentNode.isLane) {\n                    this.nameTable[node.id].width = parentNode.wrapper.actualSize.width;\n                    this.nameTable[node.id].height = parentNode.wrapper.actualSize.height;\n                    this.nameTable[node.id].offsetX = parentNode.wrapper.offsetX;\n                    this.nameTable[node.id].offsetY = parentNode.wrapper.offsetY;\n                }\n                if (!parentNode.parentId ||\n                    (this.nameTable[parentNode.parentId] &&\n                        this.nameTable[parentNode.parentId].shape.type !== 'SwimLane')) {\n                    this.updateDiagramObject(parentNode);\n                }\n            }\n        }\n        return id;\n    };\n    /**\n     * Clears all nodes and objects in the diagram, effectively resetting the diagram to an empty state.\n     *\n     * @returns { void }     Clears all nodes and objects in the diagram, effectively resetting the diagram to an empty state.\\\n     * @deprecated\n     */\n    Diagram.prototype.clear = function () {\n        this.clearObjects();\n        this.clearLayers();\n    };\n    //Bug 872106: Layer object in diagram doesnot removed in clear method\n    Diagram.prototype.clearLayers = function () {\n        var layerCount = this.layers.length;\n        for (var i = layerCount - 1; i >= 0; i--) {\n            this.removeLayer(this.layers[parseInt(i.toString(), 10)].id);\n        }\n        //Create default layer\n        var defaultLayer = {\n            id: 'default_layer', visible: true, lock: false, objects: [], zIndex: 0,\n            objectZIndex: -1, zIndexTable: {}\n        };\n        this.commandHandler.addLayer(defaultLayer, null, true);\n        this.setActiveLayer(this.layers[this.layers.length - 1].id);\n    };\n    Diagram.prototype.clearObjects = function (collection) {\n        var objects = [];\n        if (!collection) {\n            objects = objects.concat(this.nodes);\n            objects = objects.concat(this.connectors);\n        }\n        else {\n            objects = collection;\n        }\n        this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear;\n        // Removed isBlazor code\n        for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {\n            var obj = objects_1[_i];\n            if (this.nameTable[obj.id]) {\n                this.remove(obj);\n            }\n        }\n        this.diagramActions = this.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Clear;\n        this.spatialSearch = new _interaction_spatial_search_spatial_search__WEBPACK_IMPORTED_MODULE_28__.SpatialSearch(this.nameTable);\n        this.initHistory();\n    };\n    Diagram.prototype.startEditCommad = function () {\n        var laneHeader;\n        var node = (this.selectedItems.nodes[0]) ? this.selectedItems.nodes[0] : undefined;\n        if (node && node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n            if (node.isLane && node.parentId) {\n                var swimlane = this.nameTable[node.parentId];\n                var lanes = swimlane.shape.lanes;\n                var canvasId = (node.id.slice(swimlane.id.length));\n                var currentParentId = canvasId.substring(0, canvasId.length - 1);\n                for (var i = 0; i < lanes.length; i++) {\n                    if (node.isLane && currentParentId === lanes[parseInt(i.toString(), 10)].id) {\n                        laneHeader = this.nameTable[lanes[parseInt(i.toString(), 10)].header.id];\n                    }\n                }\n            }\n            else if (node.shape.type === 'SwimLane' && node.shape.header && node.shape.hasHeader) {\n                var id = node.wrapper.children[0].rows[0].cells[0].children[0].id;\n                laneHeader = this.nameTable[\"\" + id];\n            }\n        }\n        this.startTextEdit(laneHeader);\n    };\n    /* tslint:disable */\n    /**\n     * Initiate the editing mode for a specific annotation within a node or connector.\n     *\n     * @returns { void }  Initiate the editing mode for a specific annotation within a node or connector. \\\n     * @param {NodeModel | ConnectorModel} node - The node or connector containing the annotation to be edited.\n     * @param {string} id - The ID of the annotation to be edited within the node or connector.\n     */\n    Diagram.prototype.startTextEdit = function (node, id) {\n        if ((!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canZoomPan)(this) && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMultiSelect)(this)) || (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canSingleSelect)(this)) {\n            this.textEditing = true;\n            var transform = this.scroller.transform;\n            var scale = (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canZoomTextEdit)(this) ? transform.scale : 1;\n            var minWidth = 90;\n            var text = void 0;\n            var bounds = void 0;\n            var attributes = void 0;\n            var x = void 0;\n            var y = void 0;\n            var textWrapper = void 0;\n            if (!node) {\n                node = (this.selectedItems.nodes[0]) ? this.selectedItems.nodes[0] : this.selectedItems.connectors[0];\n            }\n            if (node) {\n                //Removed isBlazor code\n                //893031: Exception throws while double click on UML Classifier connector\n                //Added the condition that the node is not an instance of a connector\n                if (node.shape && node.shape.type === 'UmlClassifier' && !(node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector)) {\n                    node = this.nameTable[node.children[0]];\n                }\n                var bpmnAnnotation = false;\n                if (!textWrapper) {\n                    if (node.shape.type !== 'Text' && node.annotations.length === 0) {\n                        if (!(node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.ReadOnly)) {\n                            this.activeLabel.isGroup = true;\n                            this.startGroupAction();\n                            this.addLabels(node, [{ id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)(), content: '' }]);\n                        }\n                    }\n                    if (!id && ((node.shape.type !== 'Text' && node.annotations.length > 0) || (node.shape.type === 'Text'))) {\n                        //(EJ2-840331)-Double click on node annotation will open the edit of invisible annotation\n                        if (node.shape.type === 'Text') {\n                            id = (node.wrapper.children[0].id).split('_')[1];\n                        }\n                        else {\n                            for (var i = node.annotations.length - 1; i >= 0; i--) {\n                                if (node.annotations[parseInt(i.toString(), 10)].visibility) {\n                                    id = node.annotations[parseInt(i.toString(), 10)].id;\n                                }\n                            }\n                        }\n                    }\n                    if (id) {\n                        textWrapper = this.getWrapper(node.wrapper, id);\n                    }\n                }\n                else {\n                    bpmnAnnotation = true;\n                }\n                if (node && textWrapper && !(textWrapper instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_37__.DiagramHtmlElement) &&\n                    (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.enableReadOnly)(textWrapper, node) || bpmnAnnotation)) {\n                    var style = (textWrapper.style);\n                    var maxWidth = void 0;\n                    maxWidth = textWrapper.bounds.width < node.wrapper.bounds.width ? textWrapper.bounds.width : node.wrapper.bounds.width;\n                    maxWidth = minWidth > maxWidth ? minWidth : maxWidth;\n                    var textEditing = document.getElementById(this.element.id + '_editTextBoxDiv');\n                    var textArea = document.getElementById(this.element.id + '_editBox');\n                    text = textArea ? textArea.value : textWrapper.content;\n                    this.activeLabel.text = text;\n                    if (!textEditing && !textArea) {\n                        textEditing = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', {});\n                        textArea = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('textarea', {});\n                        this.diagramCanvas.appendChild(textEditing);\n                        textEditing.appendChild(textArea);\n                        textArea.appendChild(document.createTextNode(text));\n                    }\n                    bounds = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.measureHtmlText)(textWrapper.style, text, undefined, undefined, maxWidth);\n                    if (bounds.isEmpty()) {\n                        if (node.shape.type !== 'Text') {\n                            bounds = new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findAnnotation)(node, (textWrapper.id).split(node.id + '_')[1]).width || 50, textWrapper.style.fontSize);\n                        }\n                        else {\n                            bounds = new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size((node.width > 50) ? 50 : node.width, textWrapper.style.fontSize);\n                        }\n                    }\n                    if (node.parentId && this.nameTable[node.parentId].shape.type === 'UmlClassifier') {\n                        bounds.width = node.wrapper.bounds.width - 20;\n                        x = ((((node.wrapper.bounds.center.x + transform.tx) * transform.scale) - (bounds.width / 2) * scale) - 2.5);\n                        y = ((((node.wrapper.bounds.center.y + transform.ty) * transform.scale) - (bounds.height / 2) * scale) - 3);\n                        textWrapper.style.textAlign = 'Left';\n                    }\n                    else {\n                        bounds.width = Math.max(bounds.width, 50);\n                        x = ((((textWrapper.bounds.center.x + transform.tx) * transform.scale) - (bounds.width / 2) * scale) - 2.5);\n                        y = ((((textWrapper.bounds.center.y + transform.ty) * transform.scale) - (bounds.height / 2) * scale) - 3);\n                    }\n                    attributes = {\n                        'id': this.element.id + '_editTextBoxDiv', 'style': 'position: absolute' + ';left:' + x + 'px;top:' +\n                            y + 'px;width:' + ((bounds.width + 1) * scale) + 'px;height:' + (bounds.height * scale) +\n                            'px; containerName:' + node.id + ';'\n                    };\n                    (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeHtml)(textEditing, attributes);\n                    //879137 - aria-label missing in annotation textEdit mode.\n                    attributes = {\n                        'aria-label': text, 'id': this.element.id + '_editBox', 'style': 'width:' + ((bounds.width + 1) * scale) +\n                            'px;height:' + (bounds.height * scale) + 'px;resize: none;outline: none;overflow: hidden;' +\n                            ';font-family:' + style.fontFamily +\n                            ';font-size:' + (style.fontSize * scale) + 'px;text-align:' +\n                            (textWrapper.style.textAlign.toLocaleLowerCase()) + ';', 'class': 'e-diagram-text-edit'\n                    };\n                    (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeHtml)(textArea, attributes);\n                    textArea.style.fontWeight = (style.bold) ? 'bold' : '';\n                    textArea.style.fontStyle = (style.italic) ? 'italic' : '';\n                    textArea.style.lineHeight = (style.fontSize * 1.2 + 'px;').toString();\n                    textArea.style.textDecoration = (style.textDecoration) ? style.textDecoration : '';\n                    this.activeLabel.parentId = node.id;\n                    this.activeLabel.id = id;\n                    textWrapper.visible = false;\n                    this.updateDiagramObject(node);\n                    this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.TextEdit;\n                    if (!this.isTriggerEvent) {\n                        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(textArea, 'input', this.eventHandler.inputChange, this.eventHandler);\n                        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(textArea, 'focusout', this.focusOutEdit, this);\n                        textArea.select();\n                    }\n                }\n            }\n        }\n    };\n    Diagram.prototype.updateConnectorfixedUserHandles = function (connector) {\n        if (connector.fixedUserHandles.length) {\n            var fixedUserHandleWrapper = void 0;\n            for (var _i = 0, _a = connector.fixedUserHandles; _i < _a.length; _i++) {\n                var fixedUserHandle = _a[_i];\n                fixedUserHandleWrapper = this.getWrapper(connector.wrapper, fixedUserHandle.id);\n                connector.updateAnnotation(fixedUserHandle, connector.intermediatePoints, connector.wrapper.bounds, fixedUserHandleWrapper);\n            }\n        }\n        connector.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(connector.wrapper.width, connector.wrapper.height));\n        connector.wrapper.arrange(connector.wrapper.desiredSize);\n    };\n    /* tslint:enable */\n    Diagram.prototype.updateNodeExpand = function (node, visibility) {\n        for (var i = 0; i < node.outEdges.length; i++) {\n            var connector = this.nameTable[node.outEdges[parseInt(i.toString(), 10)]];\n            var target = this.nameTable[connector.targetID];\n            connector.visible = visibility;\n            if (target) {\n                if (!visibility) {\n                    this.updateElementVisibility(connector.wrapper, connector, false);\n                    target.isExpanded = visibility;\n                }\n                this.updateNodeExpand(target, target.isExpanded);\n                target.visible = visibility;\n                if (!visibility) {\n                    this.updateElementVisibility(target.wrapper, target, false);\n                }\n            }\n        }\n    };\n    Diagram.prototype.updateConnectorAnnotation = function (connector) {\n        if (connector.annotations.length) {\n            var annotationWrapper = void 0;\n            for (var _i = 0, _a = connector.annotations; _i < _a.length; _i++) {\n                var annotation = _a[_i];\n                annotationWrapper = this.getWrapper(connector.wrapper, annotation.id);\n                connector.updateAnnotation(annotation, connector.intermediatePoints, connector.wrapper.bounds, annotationWrapper, (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Interactions));\n            }\n        }\n        connector.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(connector.wrapper.width, connector.wrapper.height));\n        connector.wrapper.arrange(connector.wrapper.desiredSize);\n    };\n    Diagram.prototype.removeChildrenFromLayout = function (nodes) {\n        var nodesCollection = [];\n        var node;\n        var parentId = 'parentId';\n        var processId = 'processId';\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[parseInt(i.toString(), 10)];\n            if (!node[\"\" + parentId] && !node[\"\" + processId]) {\n                nodesCollection.push(node);\n            }\n        }\n        return nodesCollection;\n    };\n    /* tslint:disable */\n    /**\n     * Automatically updates the diagram objects based on the type of the layout.\n     * @returns { ILayout | boolean }  Automatically updates the diagram objects based on the type of the layout.\\\n     */\n    Diagram.prototype.doLayout = function () {\n        var update = false;\n        var layout;\n        var canDoOverlap = (this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree');\n        var propChange = this.isProtectedOnChange;\n        this.protectPropertyChange(true);\n        var nodes = this.removeChildrenFromLayout(this.nodes);\n        var canEnableRouting = this.layout.enableRouting && this.layout.type === 'ComplexHierarchicalTree';\n        var viewPort = { x: this.scroller.viewPortWidth, y: this.scroller.viewPortHeight };\n        if (this.layout.type !== 'None') {\n            if (this.organizationalChartModule || this.mindMapChartModule || this.radialTreeModule || this.symmetricalLayoutModule\n                || this.complexHierarchicalTreeModule || this.flowchartLayoutModule) {\n                // Trigger the layoutUpdated event with the state set to 'Started' and the current layout type.\n                var args = { state: 'Started', type: this.layout.type };\n                this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.layoutUpdated, args);\n            }\n            //Bug 862601: Connectors are not rendered properly with lineRouting and lineDistribution enables during doLayout process.\n            //Removed initLineDistribution method call here and added it below after the complex hierarchical tree doLayout process.\n            if (this.organizationalChartModule) {\n                layout = this.organizationalChartModule.updateLayout(nodes, this.nameTable, this.layout, viewPort, this.dataSourceSettings.id, this.diagramActions);\n                update = true;\n                if (this.canDistribute(canEnableRouting, canDoOverlap)) {\n                    this.lineDistributionModule.initLineDistribution(this.layout, this);\n                }\n                if (this.layoutAnimateModule && layout.rootNode && !this.diagramActions) {\n                    this.updateNodeExpand(layout.rootNode, layout.rootNode.isExpanded);\n                }\n                // EJ2-58221 - added to render the layout properly based on parent node isExpanded property.\n                else if (!this.layoutAnimateModule && layout.rootNode && !layout.rootNode.isExpanded && !this.canExpand) {\n                    this.updateNodeExpand(layout.rootNode, layout.rootNode.isExpanded);\n                }\n            }\n            else if (this.mindMapChartModule) {\n                if (nodes && nodes.length > 0) {\n                    this.mindMapChartModule.updateLayout(nodes, this.nameTable, this.layout, viewPort, this.dataSourceSettings.id, this.dataSourceSettings.root);\n                }\n                update = true;\n            }\n            else if (this.radialTreeModule) {\n                this.radialTreeModule.updateLayout(nodes, this.nameTable, this.layout, viewPort);\n                update = true;\n            }\n            else if (this.symmetricalLayoutModule) {\n                this.symmetricalLayoutModule.maxIteration = this.layout.maxIteration;\n                this.symmetricalLayoutModule.springLength = this.layout.springLength;\n                this.symmetricalLayoutModule.springFactor = this.layout.springFactor;\n                this.symmetricalLayoutModule.updateLayout(nodes, this.connectors, this.symmetricalLayoutModule, this.nameTable, this.layout, viewPort);\n                update = true;\n            }\n            else if (this.complexHierarchicalTreeModule) {\n                //Bug 862601: Connectors are not rendered properly with lineRouting and lineDistribution enables during doLayout process.\n                //As the initLineDistribution method call removed from above and added below doLayout, we need to set diagram value and clear obstacle collection\n                // of connectors.\n                if (this.canDistribute(canEnableRouting, canDoOverlap)) {\n                    this.lineDistributionModule.diagram = this;\n                    var obstacleCollection_1 = 'obstaclePointCollection';\n                    this.connectors.forEach(function (connector) {\n                        connector[\"\" + obstacleCollection_1] = [];\n                    });\n                }\n                var nodes_1 = this.complexHierarchicalTreeModule.getLayoutNodesCollection(this.nodes);\n                if (nodes_1.length > 0) {\n                    // eslint-disable-next-line max-len\n                    this.complexHierarchicalTreeModule.doLayout(nodes_1, this.nameTable, this.layout, viewPort, this);\n                }\n                update = true;\n                //initLineDistribution method call after doLayout.\n                if (this.canDistribute(canEnableRouting, canDoOverlap)) {\n                    this.lineDistributionModule.initLineDistribution(this.layout, this);\n                }\n            }\n            else if (this.flowchartLayoutModule) {\n                this.flowchartLayoutModule.updateLayout(this.nodes, this);\n                update = true;\n            }\n            else {\n                var moduleName = this.layout.type === 'OrganizationalChart' ? 'HierarchicalTree' : this.layout.type;\n                console.warn('[WARNING] :: Module ' + moduleName + ' is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n            }\n            if (update) {\n                this.preventDiagramUpdate = true;\n                var connectors = {};\n                var updatedNodes = nodes;\n                // BLAZ-22230 - Added condition to check if canUpdateTemplate is false means then we can update the template for blazor\n                //Removed isBlazor code\n                for (var _i = 0, updatedNodes_1 = updatedNodes; _i < updatedNodes_1.length; _i++) {\n                    var obj = updatedNodes_1[_i];\n                    var node = obj;\n                    if (!this.preventNodesUpdate && (!this.diagramActions || !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventIconsUpdate))) {\n                        this.updateIcon(node);\n                        this.updateDefaultLayoutIcons(node);\n                    }\n                    this.preventNodesUpdate = true;\n                    this.nodePropertyChange(node, {}, { offsetX: node.offsetX, offsetY: node.offsetY }, true);\n                    this.preventNodesUpdate = false;\n                    node.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(node.wrapper.width, node.wrapper.height));\n                    node.wrapper.arrange(node.wrapper.desiredSize);\n                    this.updateDiagramObject(node, true);\n                    if (node.inEdges.length > 0) {\n                        for (var j = 0; j < node.inEdges.length; j++) {\n                            var connector = this.nameTable[node.inEdges[parseInt(j.toString(), 10)]];\n                            connectors[connector.id] = connector;\n                        }\n                    }\n                    if (node.outEdges.length > 0) {\n                        for (var k = 0; k < node.outEdges.length; k++) {\n                            var connection = this.nameTable[node.outEdges[parseInt(k.toString(), 10)]];\n                            connectors[connection.id] = connection;\n                        }\n                    }\n                }\n                for (var _a = 0, _b = Object.keys(connectors); _a < _b.length; _a++) {\n                    var conn = _b[_a];\n                    if (canEnableRouting) {\n                        this.lineDistributionModule.resetConnectorSegments(this.nameTable[\"\" + conn]);\n                    }\n                    var connector = connectors[\"\" + conn];\n                    var points = this.getPoints(connector);\n                    if (canEnableRouting) {\n                        this.lineDistributionModule.resetRoutingSegments(connector, this, points);\n                    }\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateConnector)(connector, points);\n                    if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default' && connector.shape.flow === 'Sequence') {\n                        this.commandHandler.updatePathElementOffset(connector);\n                    }\n                    connector.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(undefined, undefined));\n                    connector.wrapper.arrange(connector.wrapper.desiredSize);\n                    this.updateConnectorAnnotation(connector);\n                    this.updateConnectorfixedUserHandles(connector);\n                    this.updateQuad(connector);\n                    this.updateDiagramObject(connector, true);\n                }\n                if (canEnableRouting || this.layout.connectionPointOrigin === 'DifferentPoint' && this.lineDistributionModule && canDoOverlap) {\n                    this.lineDistributionModule.distributeLines(this.layout, this);\n                }\n                this.refreshFlowChartConnectors();\n                this.preventDiagramUpdate = false;\n                this.updatePage();\n                if ((!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render)) || this.mode === 'Canvas') {\n                    this.refreshDiagramLayer();\n                    this.isRefreshed = true;\n                }\n            }\n            if (!propChange) {\n                this.protectPropertyChange(propChange);\n            }\n        }\n        if (update) {\n            this.updateDiagramElementQuad();\n        }\n        if ((this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) && this.layout.enableRouting) {\n            this.refreshRoutingConnectors();\n        }\n        if (update) {\n            // Trigger the layoutUpdated event with the state set to 'Completed' and the current layout type.\n            var args = { state: 'Completed', type: this.layout.type };\n            this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.layoutUpdated, args);\n        }\n        return ((this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.expandNode) ? layout : true);\n    };\n    //Bug 877799: Optimize the routing segment distance while using enableRouting in layout.\n    //Stored the routingConnectors in resetRoutingSegments method and then Refresh the routing connectors after layout completion.\n    Diagram.prototype.refreshRoutingConnectors = function () {\n        this.isProtectedOnChange = true;\n        if (this.routingConnectors) {\n            for (var i = 0; i < this.routingConnectors.length; i++) {\n                var connector = this.routingConnectors[parseInt(i.toString(), 10)];\n                var sourceNode = this.nameTable[connector.sourceID];\n                var targetNode = this.nameTable[connector.targetID];\n                var lineRouting = new _interaction_line_routing__WEBPACK_IMPORTED_MODULE_42__.LineRouting();\n                if (sourceNode.visible && targetNode.visible) {\n                    lineRouting.renderVirtualRegion(this, true);\n                    lineRouting.refreshConnectorSegments(this, connector, false, true);\n                    var points = this.getPoints(connector);\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateConnector)(connector, points);\n                    connector.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(undefined, undefined));\n                    connector.wrapper.arrange(connector.wrapper.desiredSize);\n                    this.updateDiagramObject(connector, true);\n                    this.routingConnectors.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        this.isProtectedOnChange = false;\n    };\n    //To update new connector points in flowchart layout\n    Diagram.prototype.refreshFlowChartConnectors = function () {\n        if (this.flowchartLayoutModule) {\n            this.flowchartLayoutModule.reRouteFlowChartConnectors(this.layout.flowChartData, this);\n            for (var i = 0; i < this.connectors.length; i++) {\n                var connector = this.connectors[parseInt(i.toString(), 10)];\n                var points = this.getPoints(connector);\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateConnector)(connector, points);\n                connector.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(undefined, undefined));\n                connector.wrapper.arrange(connector.wrapper.desiredSize);\n                this.updateConnectorAnnotation(connector);\n                this.updateConnectorfixedUserHandles(connector);\n                this.updateQuad(connector);\n                this.updateDiagramObject(connector, true);\n            }\n        }\n    };\n    //Checks if line distribution is enabled.\n    Diagram.prototype.canDistribute = function (canEnableRouting, canDoOverlap) {\n        if ((canEnableRouting && this.lineDistributionModule) || (this.layout.connectionPointOrigin === 'DifferentPoint' && this.lineDistributionModule && canDoOverlap) || (this.layout.arrangement === 'Linear' && this.lineDistributionModule)) {\n            return true;\n        }\n        else {\n            if ((canEnableRouting) || (this.layout.connectionPointOrigin === 'DifferentPoint' && canDoOverlap) || (this.layout.arrangement === 'Linear')) {\n                console.warn('[WARNING] :: Module \"LineDistribution\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n            }\n            return false;\n        }\n    };\n    /* tslint:enable */\n    /**\n     * Serializes the diagram control as a string.\n     * @returns { string }     Serializes the diagram control as a string. \\\n     */\n    Diagram.prototype.saveDiagram = function () {\n        var children = [];\n        var node;\n        var grid;\n        var childTable;\n        var child;\n        var gridChild = 'childTable';\n        for (var i = 0; i < this.nodes.length; i++) {\n            node = this.nodes[parseInt(i.toString(), 10)];\n            if (node.shape.type === 'SwimLane') {\n                grid = node.wrapper.children[0];\n                childTable = grid[\"\" + gridChild];\n                for (var _i = 0, _a = Object.keys(childTable); _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    child = childTable[\"\" + key];\n                    children = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getChild)(child, children);\n                }\n                for (var i_1 = 0; i_1 < children.length; i_1++) {\n                    if (this.nameTable[children[parseInt(i_1.toString(), 10)]]) {\n                        this.swimlaneChildTable[children[parseInt(i_1.toString(), 10)]]\n                            = this.nameTable[children[parseInt(i_1.toString(), 10)]].zIndex;\n                    }\n                }\n                this.swimlaneZIndexTable[node.id] = node.zIndex;\n            }\n        }\n        return (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.serialize)(this);\n    };\n    /**\n     * Converts the given string into a Diagram Control.\n     *\n     * @returns { Object } Converts the given string into a Diagram Control. \\\n     * @param {string} data - The string representing the diagram model JSON to be loaded.\n     * @param {boolean} isEJ1Data - A boolean indicating whether the JSON data is EJ1 data.\n     */\n    Diagram.prototype.loadDiagram = function (data, isEJ1Data) {\n        if (isEJ1Data && this.ej1SerializationModule) {\n            var ejDiagram = JSON.parse(data);\n            data = this.ej1SerializationModule.getSerializedData(ejDiagram);\n        }\n        else if (isEJ1Data) {\n            console.warn('[WARNING] :: Module \"Ej1Serialization\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n        return (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.deserialize)(data, this);\n    };\n    /**\n     * Exports the current diagram to a string in Mermaid format.\n     * This method converts the current state of the diagram into Mermaid syntax, allowing it to be saved or shared.\n     * @returns {string} - A string containing the Mermaid text representation of the current diagram.\n     */\n    Diagram.prototype.saveDiagramAsMermaid = function () {\n        var mermaidData = '';\n        if (this.layout && this.layout.type === 'Flowchart') {\n            mermaidData = this.saveFlowDiagramInMermaidFormat();\n        }\n        else {\n            mermaidData = this.saveMindmapDiagramInMermaidFormat();\n        }\n        return mermaidData;\n    };\n    /**\n     * Converts the diagram to Mermaid format and saves it.\n     * If the diagram has a 'MindMap' layout, it will generate a Mermaid mind map.\n     * @returns {string} - The Mermaid formatted string representing the diagram.\n     */\n    Diagram.prototype.saveMindmapDiagramInMermaidFormat = function () {\n        var mermaidData = '';\n        var dataSourceCollection = [];\n        if (this.layout && this.layout.type === 'MindMap') {\n            dataSourceCollection.push('mindmap');\n            if (this.nodes.length > 0) {\n                var rootNode = this.nodes.filter(function (node) { return node.inEdges.length === 0; })[0];\n                var content = this.convertMindmapToMermaid(rootNode, 0);\n                dataSourceCollection.push(content);\n                var outConnectors = rootNode.outEdges;\n                this.updateTextDataSource(dataSourceCollection, outConnectors, 1);\n                dataSourceCollection = dataSourceCollection.filter(function (data) { return data.trim() !== ''; });\n                mermaidData = dataSourceCollection.join('\\n');\n            }\n        }\n        return mermaidData;\n    };\n    /**\n     * Creates a text data source for sub-level children in a Mermaid diagram.\n     * @param {string[]} dataSource - The data source to be updated.\n     * @param {string[]} outEdges - The out edges of the current node.\n     * @param {number} level - The level of the current node.\n     * @returns {void} - Creates a text data source for sub-level children in a Mermaid diagram.\n     */\n    Diagram.prototype.updateTextDataSource = function (dataSource, outEdges, level) {\n        var count = 0;\n        while (count < outEdges.length) {\n            var connector = this.getObject(outEdges[parseInt(count.toString(), 10)]);\n            var targetNode = this.getObject(connector.targetID);\n            var content = this.convertMindmapToMermaid(targetNode, level);\n            dataSource.push(content);\n            var childOutConnectors = targetNode.outEdges;\n            if (childOutConnectors.length > 0) {\n                this.updateTextDataSource(dataSource, childOutConnectors, level + 1);\n            }\n            count++;\n        }\n    };\n    /**\n     * Returns the text data source for the specified node in Mermaid format.\n     * @param {NodeModel} node - The node for which the Mermaid data is to be generated.\n     * @param {number} level - The level of the node in the diagram.\n     * @returns {string} - The text data source for the specified node in Mermaid format.\n     */\n    Diagram.prototype.convertMindmapToMermaid = function (node, level) {\n        var nodeId = node.id;\n        var spaceCount = (level + 1) * 2;\n        var spaces = ' '.repeat(spaceCount);\n        var annotationContent = node.annotations.length > 0\n            ? node.annotations[0].content.replace(/\\n/g, ' ')\n            : '';\n        var content = spaces + annotationContent;\n        var spaceWithNodeId = spaces + nodeId;\n        if (node.shape && node.shape.type === 'Basic') {\n            var basicShape = node.shape;\n            if (basicShape.shape === 'Rectangle') {\n                content = spaceWithNodeId + '[' + annotationContent + ']';\n            }\n            else if (basicShape.shape === 'Ellipse') {\n                content = spaceWithNodeId + '((' + annotationContent + '))';\n            }\n            else if (basicShape.shape === 'Hexagon') {\n                content = spaceWithNodeId + '{{' + annotationContent + '}}';\n            }\n        }\n        else if (node.shape && node.shape.type === 'Flow') {\n            var flowShape = node.shape;\n            if (flowShape.shape === 'Terminator') {\n                content = spaceWithNodeId + '(' + annotationContent + ')';\n            }\n        }\n        else if (node.shape && node.shape.type === 'Path') {\n            var pathShape = node.shape;\n            if (pathShape.data === this.bangShape) {\n                content = spaceWithNodeId + '))' + annotationContent + '((';\n            }\n            else if (pathShape.data === this.cloudShape) {\n                content = spaceWithNodeId + ')' + annotationContent + '(';\n            }\n        }\n        return content;\n    };\n    /**\n     * Converts the flowchart diagram to Mermaid format.\n     * @returns {string} - The exported flowchart diagram as Mermaid data.\n     */\n    Diagram.prototype.saveFlowDiagramInMermaidFormat = function () {\n        var _this = this;\n        var existingIds = [];\n        var mermaidCode = 'graph TD\\n';\n        var graph = { nodes: this.nodes, edges: this.connectors };\n        // Create a map of node labels for easy access\n        // accumulator - The object that stores the node ID and label pairs.\n        var nodeLabels = graph.nodes.reduce(function (accumulator, node) {\n            accumulator[node.id] = node.annotations.length ? node.annotations[0].content : '';\n            return accumulator;\n        }, {});\n        // Iterate through edges to create connections and node definitions\n        graph.edges.forEach(function (edge) {\n            var fromNodeId = edge.sourceID;\n            var toNodeId = edge.targetID;\n            var fromNodeLabel = nodeLabels[\"\" + fromNodeId];\n            var toNodeLabel = nodeLabels[\"\" + toNodeId];\n            var fromNode = _this.nameTable[\"\" + fromNodeId];\n            var toNode = _this.nameTable[\"\" + toNodeId];\n            var fromNodeShape = _this.getNodeShape(fromNode);\n            var toNodeShape = _this.getNodeShape(toNode);\n            var condition = (edge.annotations[0] && edge.annotations[0].content !== '') ? '|' + edge.annotations[0].content + '|' : '';\n            if (existingIds.indexOf(fromNodeId) === -1) {\n                existingIds.push(fromNodeId);\n            }\n            else {\n                fromNodeShape = '';\n            }\n            if (existingIds.indexOf(toNodeId) === -1) {\n                existingIds.push(toNodeId);\n            }\n            else {\n                toNodeShape = '';\n            }\n            var arrow = _this.arrowType(edge);\n            mermaidCode += \"    \" + fromNodeId + fromNodeShape + \" \" + arrow + condition + \" \" + toNodeId + toNodeShape + \"\\n\";\n        });\n        // Add styles for each node\n        graph.nodes.forEach(function (node) {\n            var nodeId = node.id;\n            var fill = node.style.fill;\n            var stroke = node.style.strokeColor;\n            var strokeWidth = node.style.strokeWidth + \"px\";\n            mermaidCode += \"    style \" + nodeId + \" fill:\" + fill + \",stroke:\" + stroke + \",stroke-width:\" + strokeWidth + \";\\n\";\n        });\n        return mermaidCode;\n    };\n    // Method to get the arrow type from connector\n    Diagram.prototype.arrowType = function (edge) {\n        var decoratorShape = edge.targetDecorator.shape;\n        var strokeDash = edge.style.strokeDashArray;\n        var strokeWidth = edge.style.strokeWidth;\n        var opacity = edge.style.opacity;\n        var arrow = '';\n        if (opacity < 1) {\n            arrow = '~~~';\n        }\n        else if (strokeDash !== '') {\n            arrow = '-.->';\n        }\n        else if (decoratorShape === 'Arrow') {\n            arrow = strokeWidth > 1 ? '==>' : '-->';\n        }\n        else if (decoratorShape === 'None') {\n            arrow = '---';\n        }\n        else {\n            arrow = '-->';\n        }\n        return arrow;\n    };\n    // Method to get the node shape\n    Diagram.prototype.getNodeShape = function (node) {\n        var label = node.annotations.length > 0 ? node.annotations[0].content : '';\n        var shape = node.shape.shape;\n        if (shape) {\n            switch (shape) {\n                case 'Terminator':\n                    return '([' + label + '])';\n                case 'Process':\n                    return '[' + label + ']';\n                case 'Decision':\n                    return '{' + label + '}';\n                case 'Parallelogram':\n                    return '[/' + label + '/]';\n                case 'Ellipse':\n                    return '((' + label + '))';\n                case 'PreDefinedProcess':\n                    return '[[' + label + ']]';\n                default:\n                    return '[' + label + ']';\n            }\n        }\n        else {\n            var data = node.shape.data;\n            if (data === 'M 0 0 A 1 1 0 0 0 7 0 A 1 1 0 0 0 0 0 M -1 0 A 1 1 0 0 0 8 0 A 1 1 0 0 0 -1 0') {\n                return '(((' + label + ')))';\n            }\n            else if (data === 'M 0 0 L 1 -1 L 5 -1 L 6 0 L 0 0') {\n                return '[/' + label + '\\\\]';\n            }\n            else if (data === 'M 0 1 L 0 6 C 2 7 4 7 6 6 L 6 1 C 5 0 1 0 0 1 C 1 2 5 2 6 1') {\n                return '[(' + label + ')]';\n            }\n            else if (data === 'M 0 0 L 12 0 L 14 2 L 2 2 L 0 0') {\n                return '[\\\\' + label + '\\\\]';\n            }\n            else if (data === 'M 0 0 L 5 0 L 4 1 L 1 1 L 0 0') {\n                return '[\\\\' + label + '/]';\n            }\n            else if (data === 'M 0 0 L 2 -2 L 11 -2 L 13 0 L 11 2 L 2 2 L 0 0') {\n                return '{{' + label + '}}';\n            }\n            else {\n                return '>' + label + ']';\n            }\n        }\n    };\n    /** Loads a diagram from a string containing Mermaid syntax.\n     * This method parses the provided Mermaid text data and updates the current diagram accordingly.\n     * Currently, only Mindmap and Flowchart diagrams can be loaded.\n     * To render the diagram properly, you should set the `Layout.type` to either `MindMap` or `FlowChart`, and ensure that the respective modules are injected.\n     * @param {string} data - The Mermaid text data representing the diagram to be loaded.\n     * @returns {void} - No return value. The method updates the diagram in place.\n     */\n    Diagram.prototype.loadDiagramFromMermaid = function (data) {\n        if (this.layout && this.layout.type === 'Flowchart' && this.flowchartLayoutModule) {\n            //Task 896394: To load the mermaid data as flowchart\n            this.convertMermaidToFlowChart(data);\n        }\n        else if (this.layout && this.layout.type === 'MindMap' && this.mindMapChartModule) {\n            //Task 900266: To load the mermaid data as mindmap\n            this.convertMermaidToMindmap(data);\n        }\n        else {\n            console.warn('[WARNING] :: Module \"FlowchartLayout\" or \"MindMap\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n    };\n    /**\n     * Counts the number of leading spaces in the specified string.\n     * @param {string} word The string to check for leading spaces.\n     * @returns { number } The number of leading spaces.\n     */\n    Diagram.prototype.countLeadingSpaces = function (word) {\n        var i = 0;\n        var length = word.length;\n        // Loop through the string to count leading spaces\n        while (i < length && word.charAt(i) === ' ') {\n            i++;\n        }\n        // Return the number of leading spaces\n        return i;\n    };\n    Diagram.prototype.convertMermaidToMindmap = function (data) {\n        if (data && this.layout && this.layout.type === 'MindMap' && this.mindMapChartModule) {\n            var dataSource = data.split(/\\r?\\n/).filter(function (s) { return s.trim().length > 0; });\n            this.clear();\n            this.mermaidNodeBaseCollection = [];\n            var dataStack = [];\n            var root = null;\n            var previousItem = { text: '', children: [], currentLevel: 0, branch: 'Left' };\n            var spaceAndItsLevels = [];\n            var startLevel = 1;\n            var haveBackticks = false;\n            var isEndBackticks = false;\n            var canCreateMindMap = false;\n            if (dataSource.length > 0) {\n                var _loop_1 = function (index) {\n                    var word = dataSource[parseInt(index.toString(), 10)];\n                    var level = 0;\n                    var text = '';\n                    var levelChar = ' ';\n                    var leadingWhiteSpace = this_1.countLeadingSpaces(word);\n                    var isStartBackticks = word.includes('\"`');\n                    isEndBackticks = word.includes('`\"');\n                    haveBackticks = isStartBackticks ? true : haveBackticks;\n                    canCreateMindMap = (!haveBackticks && !canCreateMindMap) ? leadingWhiteSpace === 0 && index > 0 : canCreateMindMap;\n                    if (haveBackticks && isEndBackticks && !isStartBackticks) {\n                        previousItem.text += '\\n' + word;\n                        haveBackticks = false;\n                        return \"continue\";\n                    }\n                    if (!isStartBackticks && haveBackticks) {\n                        previousItem.text += '\\n' + word;\n                        return \"continue\";\n                    }\n                    haveBackticks = isEndBackticks ? false : haveBackticks;\n                    if (word.length > 0 && ((/\\s/.test(word[0]) && index > 0) || (leadingWhiteSpace === 0))) {\n                        var spaceIndex = spaceAndItsLevels.findIndex(function (space) {\n                            return space.space === leadingWhiteSpace.toString();\n                        });\n                        if (spaceIndex !== -1) {\n                            for (var i = spaceAndItsLevels.length - 1; i >= 0; i--) {\n                                var currentSpace = spaceAndItsLevels[parseInt(i.toString(), 10)];\n                                var currentKey = parseFloat(currentSpace.space);\n                                if (currentKey > leadingWhiteSpace) {\n                                    spaceAndItsLevels.splice(i, 1); // Remove the element at index i\n                                }\n                                else if (currentKey < leadingWhiteSpace) {\n                                    spaceAndItsLevels.push({ space: leadingWhiteSpace.toString(), level: currentSpace.level + 1 });\n                                    level = currentSpace.level + 1;\n                                    break;\n                                }\n                                else if (currentKey === leadingWhiteSpace) {\n                                    level = currentSpace.level;\n                                    break;\n                                }\n                            }\n                        }\n                        else {\n                            if (spaceAndItsLevels.length === 0) {\n                                spaceAndItsLevels.push({ space: leadingWhiteSpace.toString(), level: startLevel });\n                                level = startLevel;\n                            }\n                            else {\n                                for (var i = spaceAndItsLevels.length - 1; i >= 0; i--) {\n                                    var currentElement = spaceAndItsLevels[parseInt(i.toString(), 10)];\n                                    var currentKey = parseFloat(currentElement.space);\n                                    if (currentKey > leadingWhiteSpace) {\n                                        spaceAndItsLevels.splice(i, 1); // Remove the element at index i\n                                    }\n                                    else {\n                                        var lastElement = spaceAndItsLevels[spaceAndItsLevels.length - 1];\n                                        spaceAndItsLevels.push({ space: leadingWhiteSpace.toString(), level: lastElement.level + 1 });\n                                        break;\n                                    }\n                                }\n                                level = spaceAndItsLevels[spaceAndItsLevels.length - 1].level;\n                            }\n                        }\n                        text = word.trim().replace(/^[+-]/, '');\n                        levelChar = ' ';\n                    }\n                    var currentItem = {\n                        text: text,\n                        branch: undefined,\n                        children: [],\n                        currentLevel: index === 0 ? 0 : level - 1\n                    };\n                    if (dataStack.length > 0) {\n                        while (dataStack.length >= level) {\n                            if (dataStack.length === 0) {\n                                break;\n                            }\n                            dataStack.pop();\n                        }\n                        if (dataStack.length > 0) {\n                            dataStack[dataStack.length - 1].children.push(currentItem);\n                        }\n                    }\n                    else {\n                        root = currentItem;\n                    }\n                    dataStack.push(currentItem);\n                    previousItem = currentItem;\n                };\n                var this_1 = this;\n                for (var index = 0; index < dataSource.length; index++) {\n                    _loop_1(index);\n                }\n                // Create dataSource\n                var hierarchyDataSource = dataStack[0];\n                if (hierarchyDataSource.text === 'mindmap' || canCreateMindMap) {\n                    if (canCreateMindMap) {\n                        var nodeDetails = this.getNodeDetails(hierarchyDataSource);\n                        var nodeObj = {\n                            id: nodeDetails.nodeId,\n                            shape: nodeDetails.nodeShapeData,\n                            annotations: [\n                                { content: nodeDetails.annotationContent }\n                            ]\n                        };\n                        this.mermaidNodeBaseCollection.push(nodeObj);\n                        this.createDataSource(hierarchyDataSource.children, hierarchyDataSource, nodeObj.id);\n                    }\n                    else {\n                        var hierarchyData = hierarchyDataSource.children[0];\n                        var nodeData = this.getNodeDetails(hierarchyData);\n                        var node = {\n                            id: nodeData.nodeId,\n                            shape: nodeData.nodeShapeData,\n                            annotations: [\n                                { content: nodeData.annotationContent }\n                            ]\n                        };\n                        this.mermaidNodeBaseCollection.push(node);\n                        this.createDataSource(hierarchyData.children, hierarchyData, node.id);\n                    }\n                    this.addElements(this.mermaidNodeBaseCollection);\n                    this.doLayout();\n                }\n            }\n        }\n    };\n    /**\n     * Creates a data source for the Mermaid diagram based on the provided hierarchy data.\n     * @param { HierarchyData[] } data The list of hierarchy data to process.\n     * @param { HierarchyData } parent The parent hierarchy data.\n     * @param { string } parentId The ID of the parent node.\n     * @returns { void }\n     */\n    Diagram.prototype.createDataSource = function (data, parent, parentId) {\n        var index = 0;\n        while (index < data.length) {\n            var child = data[parseInt(index.toString(), 10)];\n            var nodeData = this.getNodeDetails(child);\n            var node = {\n                id: nodeData.nodeId,\n                shape: nodeData.nodeShapeData,\n                annotations: [\n                    { content: nodeData.annotationContent }\n                ]\n            };\n            var connector = {\n                sourceID: parentId,\n                targetID: node.id\n            };\n            this.mermaidNodeBaseCollection.push(node);\n            this.mermaidNodeBaseCollection.push(connector);\n            this.createDataSource(child.children, child, node.id);\n            index++;\n        }\n    };\n    /**\n     * Retrieves the node details based on the provided hierarchy data for a mermaid diagram.\n     * @param { HierarchyData } hierarchyData The hierarchy data.\n     * @returns { NodeData } The node details.\n     */\n    Diagram.prototype.getNodeDetails = function (hierarchyData) {\n        var pattern = /^(.*?)\\s*([\\\\[\\\\(\\\\{][\\s\\S]*?[\\]\\\\)\\\\}]|[)\\\\(][\\s\\S]*|[)\\\\{][\\s\\S]*|[)\\\\(][^{}()\\\\[\\]]*$)/;\n        var annotationContent = hierarchyData.text;\n        var match = annotationContent.match(pattern);\n        var nodeId = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n        var annotationText = hierarchyData.text;\n        var shape = { type: 'Basic', shape: 'Rectangle' };\n        if (match) {\n            nodeId = match[1] ? match[1] : nodeId;\n            var content = match[2].trim().replace(/[\"`]/g, '');\n            var firstCharacter = content.charAt(0);\n            if (firstCharacter === '[') {\n                annotationText = content.slice(1, -1);\n            }\n            else if (firstCharacter === '(') {\n                if (content.startsWith('((')) {\n                    annotationText = content.slice(2, -1);\n                }\n                else {\n                    annotationText = content.slice(1, -1);\n                }\n                shape = content.startsWith('((') ?\n                    { type: 'Basic', shape: 'Ellipse' } :\n                    { type: 'Flow', shape: 'Terminator' };\n            }\n            else if (firstCharacter === ')') {\n                if (content.startsWith('))')) {\n                    annotationText = content.slice(2, -2);\n                }\n                else {\n                    annotationText = content.slice(1, -1);\n                }\n                shape = content.startsWith('))') ?\n                    { type: 'Path', data: this.bangShape } :\n                    { type: 'Path', data: this.cloudShape };\n            }\n            else if (firstCharacter === '{') {\n                annotationText = content.slice(2, -1);\n                shape = { type: 'Basic', shape: 'Hexagon' };\n            }\n        }\n        return {\n            nodeId: nodeId,\n            annotationContent: annotationText,\n            nodeShapeData: shape\n        };\n    };\n    /**\n     * To convert the Mermaid data to flowchart diagram\n     * @param {string} data - The Mermaid data to be converted to a flowchart diagram.\n     * @returns {void}\n     */\n    Diagram.prototype.convertMermaidToFlowChart = function (data) {\n        var dataCollection = [];\n        this.clear();\n        var lines = data.trim().split('\\n');\n        for (var i = 1; i < lines.length; i++) {\n            var line = lines[parseInt(i.toString(), 10)];\n            line = line.trim();\n            if (line !== '') {\n                if (line.startsWith('style')) {\n                    this.parseStyle(line, dataCollection);\n                }\n                else {\n                    var lineSplit = this.getLineSplitting(line);\n                    var parts = [lineSplit[0], lineSplit[1]];\n                    var data_1 = this.getNodeData(parts, dataCollection, lineSplit[2]);\n                    if (data_1.length > 0) {\n                        var lastItem = data_1[data_1.length - 1];\n                        lastItem.arrowType = lineSplit[2];\n                        if (lineSplit[3] !== '') {\n                            if (lastItem.label && lastItem.label.some(function (str) { return str.trim().length > 0; })) {\n                                lastItem.label.push(lineSplit[3]);\n                            }\n                            else {\n                                lastItem.label = [];\n                                lastItem.label[lastItem.parentId.length - 1] = lineSplit[3];\n                            }\n                        }\n                    }\n                    data_1.filter(function (flowData) {\n                        return flowData.parentId && flowData.parentId.length === 0;\n                    }).forEach(function (node) {\n                        node.parentId = null;\n                    });\n                    dataCollection = dataCollection.concat(data_1);\n                }\n            }\n        }\n        this.createFlowChart(dataCollection);\n        this.doLayout();\n        this.clearHistory();\n    };\n    /**\n     * To convert the dataCollection into flowchart nodes and connectors\n     * @param { FlowChartData[] } dataCollection - The data collection to be converted to flowchart nodes and connectors.\n     * @returns {void}\n     */\n    Diagram.prototype.createFlowChart = function (dataCollection) {\n        var flowchartNodesAndConnectors = [];\n        for (var n = 0; n < dataCollection.length; n++) {\n            var data = dataCollection[parseInt(n.toString(), 10)];\n            var node = {\n                id: data.id,\n                shape: data.shape,\n                annotations: [{ content: data.name }],\n                style: { fill: data.color, strokeColor: data.stroke, strokeWidth: data.strokeWidth }\n            };\n            flowchartNodesAndConnectors.push(node);\n        }\n        for (var c = 0; c < dataCollection.length; c++) {\n            var data = dataCollection[parseInt(c.toString(), 10)];\n            var connectorStyle = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getConnectorArrowType)(data);\n            if (data.parentId && data.parentId.length > 1) {\n                for (var i = 0; i < data.parentId.length; i++) {\n                    var connector = {\n                        id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)(),\n                        sourceID: data.parentId[parseInt(i.toString(), 10)],\n                        targetID: data.id,\n                        annotations: [{ content: data.label ? data.label[parseInt(i.toString(), 10)] : '' }],\n                        style: {\n                            strokeWidth: connectorStyle.strokeWidth ? connectorStyle.strokeWidth : 1,\n                            strokeDashArray: connectorStyle.strokeDashArray ? connectorStyle.strokeDashArray : '',\n                            opacity: connectorStyle.opacity !== undefined ? connectorStyle.opacity : 1\n                        },\n                        targetDecorator: { shape: connectorStyle.targetDecorator }\n                    };\n                    flowchartNodesAndConnectors.push(connector);\n                }\n            }\n            else if (data.parentId && data.parentId.length === 1) {\n                var connector = {\n                    id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)(),\n                    sourceID: data.parentId[0],\n                    targetID: data.id,\n                    annotations: [{ content: data.label ? data.label[0] : '' }],\n                    style: {\n                        strokeWidth: connectorStyle.strokeWidth ? connectorStyle.strokeWidth : 1,\n                        strokeDashArray: connectorStyle.strokeDashArray ? connectorStyle.strokeDashArray : '',\n                        opacity: connectorStyle.opacity !== undefined ? connectorStyle.opacity : 1\n                    },\n                    targetDecorator: { shape: connectorStyle.targetDecorator }\n                };\n                flowchartNodesAndConnectors.push(connector);\n            }\n        }\n        this.addElements(flowchartNodesAndConnectors);\n    };\n    /**\n     * Splits the line based on arrow\n     * @param { string } line - line to split\n     * @returns { string[] } - Splitted line\n     */\n    Diagram.prototype.getLineSplitting = function (line) {\n        var leftPart;\n        var rightPart;\n        var arrowName;\n        var arrowText = '';\n        // RegEx to split the line based on arrow\n        var regex = /^(.*?)\\s*(-->|---|--\\s*.*?\\s*-->|~~~|==>|===|==\\s*.*?\\s*==>|\\s*-\\.\\s*->|\\s*-\\.\\s*-|\\s*-\\.\\s*.*?\\s*\\.\\s*->|\\s*-\\..*?\\.\\s*->)(.*)$/;\n        var match = line.match(regex);\n        if (match) {\n            leftPart = match[1].trim();\n            var arrow = match[2].trim();\n            rightPart = match[3].trim();\n            // Detect and extract arrow text\n            var arrowRegex = /(-\\.|\\\\-\\\\-|==|--|~~)(.*?)(\\1>|\\.->|==>|\\\\->|~~>)/;\n            var arrowTextMatch = arrow.match(arrowRegex);\n            var arrowDetails = void 0;\n            var arrowType = '';\n            if (arrowTextMatch) {\n                var text = arrowTextMatch[2].trim() || null;\n                var arrowType_1 = arrowTextMatch[1] + arrowTextMatch[3];\n                arrowDetails = {\n                    text: text,\n                    arrowType: arrowType_1\n                };\n            }\n            else {\n                arrowDetails = {\n                    text: null,\n                    arrowType: arrow\n                };\n            }\n            arrowText = arrowDetails.text !== null ? arrowDetails.text : '';\n            arrowType = arrowDetails.arrowType;\n            // Identify arrow type\n            if (arrowType.includes('-->')) {\n                arrowName = 'single-line-arrow';\n            }\n            else if (arrowType.includes('---')) {\n                arrowName = 'single-line';\n            }\n            else if (arrowType.includes('==>')) {\n                arrowName = 'double-line-arrow';\n            }\n            else if (arrowType.includes('==')) {\n                arrowName = 'double-line';\n            }\n            else if (arrowType.includes('~~~')) {\n                arrowName = 'wiggly-arrow';\n            }\n            else if (arrowType.includes('-.->') || arrowType.includes('.->')) {\n                arrowName = 'dotted-arrow';\n            }\n            else if (arrowType.includes('-.-') || arrowType.includes('.-')) {\n                arrowName = 'dotted';\n            }\n            else {\n                arrowName = 'single-line-arrow';\n            }\n        }\n        return [leftPart, rightPart, arrowName, arrowText];\n    };\n    /**\n     * To parse the style of the node\n     * @param { string } line - line to parse\n     * @param { FlowChartData[] } dataCollection - data collection\n     * @returns { void }\n     */\n    Diagram.prototype.parseStyle = function (line, dataCollection) {\n        var styleRegex = /^style\\s+(\\w+)\\s+fill:([^,]+),stroke:([^,]+),stroke-width:(\\d+)px;/;\n        if (line.startsWith('style')) {\n            var match = line.match(styleRegex);\n            if (match) {\n                var id = match[1];\n                var fill = match[2];\n                var stroke = match[3];\n                var strokeWidth = parseInt(match[4], 10);\n                var data_2 = {\n                    id: id,\n                    fill: fill,\n                    stroke: stroke,\n                    strokeWidth: strokeWidth\n                };\n                var matchData = dataCollection.filter(function (x) { return x.id === data_2.id; });\n                matchData[0].color = data_2.fill;\n                matchData[0].stroke = data_2.stroke;\n                matchData[0].strokeWidth = data_2.strokeWidth;\n            }\n        }\n    };\n    /**\n     * @param {string[]} lines - The lines to be processed.\n     * @param {FlowChartData[]} dataCollection - The data collection to be updated.\n     * @param {string} arrowType - The type of arrow.\n     * @returns { void }\n     */\n    Diagram.prototype.getNodeData = function (lines, dataCollection, arrowType) {\n        var dataArray = [];\n        var firstId = null;\n        var secondId = null;\n        var isExistCount = 0;\n        var connectorLabel = '';\n        var _loop_2 = function (i) {\n            var line1 = lines[parseInt(i.toString(), 10)];\n            var text = this_2.splitNested(line1);\n            if (text[0].includes('|')) {\n                // Extract content outside the '|'\n                var match = text[0].match(/\\|([^|]*)\\|/);\n                if (match) {\n                    connectorLabel = match[1];\n                }\n                var parts = text[0].split('|');\n                if (parts.length >= 3) {\n                    text[0] = parts[2].trim();\n                }\n            }\n            var id = text[0].trim();\n            if (i === 0) {\n                firstId = id;\n            }\n            else {\n                secondId = id;\n            }\n            var exsist = dataCollection.find(function (data) { return data.id === id; });\n            if (!exsist) {\n                var labelShape = text.length > 1 ? text[1] : text[0];\n                var shape = this_2.getShape(labelShape);\n                var label = labelShape.replace(/[\\\\[\\]\\\\(\\\\)\\\\{\\\\}\\\\{\\\\}\\\\/>]/g, '');\n                var data = {\n                    id: id,\n                    name: label,\n                    shape: shape,\n                    color: 'white',\n                    parentId: []\n                };\n                dataArray.push(data);\n            }\n            else {\n                isExistCount++;\n            }\n        };\n        var this_2 = this;\n        for (var i = 0; i < lines.length; i++) {\n            _loop_2(i);\n        }\n        if (dataArray.length) {\n            var lastItem = dataArray[dataArray.length - 1];\n            if (lastItem.id !== firstId) {\n                lastItem.parentId.push(firstId);\n                if (lastItem.label) {\n                    lastItem.label.push(connectorLabel);\n                }\n                else {\n                    lastItem.label = [connectorLabel];\n                }\n            }\n            else {\n                var data = dataCollection.find(function (data) { return data.id === secondId; });\n                if (data.parentId) {\n                    data.parentId.push(firstId);\n                }\n                else {\n                    data.parentId = [firstId];\n                }\n                if (data.label) {\n                    data.label.push(connectorLabel);\n                }\n                else {\n                    data.label = [connectorLabel];\n                }\n            }\n        }\n        else if (isExistCount === 2) {\n            var filteredData = dataCollection.filter(function (flowData) { return flowData.id === secondId; })[0];\n            filteredData.parentId = filteredData.parentId || [];\n            filteredData.parentId.push(firstId);\n            filteredData.label = filteredData.label || [];\n            filteredData.label[filteredData.parentId.length - 1] = connectorLabel;\n        }\n        if (arrowType) {\n            var filteredData = dataCollection.filter(function (flowData) { return flowData.id === secondId; })[0];\n            if (filteredData) {\n                filteredData.arrowType = arrowType;\n            }\n        }\n        return dataArray;\n    };\n    /**\n     * To split the text based on the nested brackets\n     * @param {string} text - The text to be split based on nested brackets.\n     * @returns {string[]} An array of strings split based on the nested brackets.\n     */\n    Diagram.prototype.splitNested = function (text) {\n        var result = [];\n        var current = '';\n        var level = 0;\n        var delimiter = '';\n        for (var _i = 0, text_1 = text; _i < text_1.length; _i++) {\n            var char = text_1[_i];\n            if (char === '[' || char === '{' || char === '(' || char === '>') {\n                if (level === 0) {\n                    if (current.trim().length > 0) {\n                        result.push(current.trim());\n                    }\n                    current = char; // Include the delimiter in the current part\n                    delimiter = char;\n                    level++;\n                }\n                else {\n                    current += char;\n                    level++;\n                }\n            }\n            else if (char === ']' || char === '}' || char === ')') {\n                if (level === 1 && char === delimiter) {\n                    current += char; // Include the delimiter in the current part\n                    result.push(current.trim());\n                    current = '';\n                    level--;\n                }\n                else if (level > 1) {\n                    current += char;\n                    level--;\n                }\n                else {\n                    current += char;\n                }\n            }\n            else {\n                current += char;\n            }\n        }\n        if (current.trim().length > 0) {\n            result.push(current.trim());\n        }\n        return result;\n    };\n    // Get shape based on the bracket\n    Diagram.prototype.getShape = function (text) {\n        var shape = {};\n        if (text.startsWith('(((')) {\n            shape = { type: 'Path', data: 'M 0 0 A 1 1 0 0 0 7 0 A 1 1 0 0 0 0 0 M -1 0 A 1 1 0 0 0 8 0 A 1 1 0 0 0 -1 0' };\n        }\n        else if (text.startsWith('((')) {\n            shape = { shape: 'Ellipse', type: 'Basic' };\n        }\n        else if (text.startsWith('([')) {\n            shape = { type: 'Flow', shape: 'Terminator' };\n        }\n        else if (text.startsWith('(')) {\n            shape = { type: 'Flow', shape: 'Process' };\n        }\n        else if (text.startsWith('[[')) {\n            shape = { type: 'Flow', shape: 'PreDefinedProcess' };\n        }\n        else if (text.startsWith('[/')) {\n            if (text.endsWith('/]')) {\n                shape = { type: 'Basic', shape: 'Parallelogram' };\n            }\n            else {\n                shape = { type: 'Path', data: 'M 0 0 L 1 -1 L 5 -1 L 6 0 L 0 0' };\n            }\n        }\n        else if (text.startsWith('[(')) {\n            shape = { type: 'Path', data: 'M 0 1 L 0 6 C 2 7 4 7 6 6 L 6 1 C 5 0 1 0 0 1 C 1 2 5 2 6 1' };\n        }\n        else if (text.startsWith('[\\\\')) {\n            if (text.endsWith('\\\\]')) {\n                shape = { type: 'Path', data: 'M 0 0 L 12 0 L 14 2 L 2 2 L 0 0' };\n            }\n            else {\n                shape = { type: 'Path', data: 'M 0 0 L 5 0 L 4 1 L 1 1 L 0 0' };\n            }\n        }\n        else if (text.startsWith('[')) {\n            shape = { type: 'Basic', shape: 'Rectangle' };\n        }\n        else if (text.startsWith('{{')) {\n            shape = { type: 'Path', data: 'M 0 0 L 2 -2 L 11 -2 L 13 0 L 11 2 L 2 2 L 0 0' };\n        }\n        else if (text.startsWith('{')) {\n            shape = { type: 'Flow', shape: 'Decision' };\n        }\n        else if (text.startsWith('>')) {\n            shape = { type: 'Path', data: 'M 0 0 L 8 0 L 8 2 L 0 2 L 2 1 L 0 0' };\n        }\n        return shape;\n    };\n    /**\n     * To  get the html diagram content\n     *\n     * @returns { string }     getDirection method .\\\n     * @param {StyleSheetList} styleSheets - defines the collection of style files to be considered while exporting.\n     */\n    Diagram.prototype.getDiagramContent = function (styleSheets) {\n        if (this.printandExportModule) {\n            var data = this.printandExportModule.getDiagramContent(styleSheets);\n            return data;\n        }\n        else {\n            console.warn('[WARNING] :: Module \"PrintAndExport\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n            return '';\n        }\n    };\n    /**\n     * Exports a diagram as a image.\n     *\n     * @returns { void } Exports a diagram as a image.\\\n     * @param {string} image - A string representing the image content to be exported.\n     * @param {IExportOptions} options -An object defining the properties of the image export.\n     */\n    Diagram.prototype.exportImage = function (image, options) {\n        if (this.printandExportModule) {\n            this.printandExportModule.exportImages(image, options);\n        }\n        else {\n            console.warn('[WARNING] :: Module \"PrintAndExport\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n    };\n    /**\n     * Prints the native or HTML nodes of the diagram as an image.\n     *\n     * @returns { void } Prints the native or HTML nodes of the diagram as an image. \\\n     * @param {string} image - A string that defines the image content to be printed.\n     * @param {IExportOptions} options - An IExportOptions object that defines the properties of the image and printing options.\n     */\n    Diagram.prototype.printImage = function (image, options) {\n        if (this.printandExportModule) {\n            options.printOptions = true;\n            this.printandExportModule.exportImages(image, options);\n        }\n        else {\n            console.warn('[WARNING] :: Module \"PrintAndExport\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n    };\n    /**\n     * Define a limit on the number of history entries that the diagram's history manager can store. This can help manage memory usage and control the undo/redo history size. Or\n     * Sets the limit for the history entries in the diagram.\n     *\n     * @returns { void }  Define a limit on the number of history entries that the diagram's history manager can store. This can help manage memory usage and control the undo/redo history size. Or Sets the limit for the history entries in the diagram.\n     * @param {number} stackLimit - The limit for the history manager's stack.\n     */\n    Diagram.prototype.setStackLimit = function (stackLimit) {\n        if (this.undoRedoModule && stackLimit) {\n            this.historyManager.stackLimit = stackLimit;\n            this.undoRedoModule.applyLimit(this.historyManager.currentEntry, stackLimit, this, true);\n        }\n    };\n    /**\n     * Clears the history of the diagram, removing all the recorded actions from the undo and redo history.\n     * @returns { void } Clears the history of the diagram, removing all the recorded actions from the undo and redo history.\\\n     */\n    Diagram.prototype.clearHistory = function () {\n        if (this.undoRedoModule) {\n            this.undoRedoModule.clearHistory(this);\n        }\n    };\n    /**\n     * Retrieves the bounding rectangle that encloses the entire diagram.\n     * @returns { void } TRetrieves the bounding rectangle that encloses the entire diagram. \\\n     */\n    Diagram.prototype.getDiagramBounds = function () {\n        if (this.printandExportModule) {\n            var bounds = this.printandExportModule.getDiagramBounds('', {});\n            bounds.width = bounds.width > this.scrollSettings.viewPortWidth ?\n                bounds.width + (bounds.x > 0 ? bounds.x : 0) : this.scrollSettings.viewPortWidth;\n            bounds.height = bounds.height > this.scrollSettings.viewPortHeight ?\n                bounds.height + (bounds.y > 0 ? bounds.y : 0) : this.scrollSettings.viewPortHeight;\n            bounds.x = bounds.x > 0 ? 0 : bounds.x;\n            bounds.y = bounds.y > 0 ? 0 : bounds.y;\n            return bounds;\n        }\n        else {\n            console.warn('[WARNING] :: Module \"PrintAndExport\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n            return new _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect();\n        }\n    };\n    /**\n     * Exports the diagram as an image or SVG element based on the specified options.\n     *\n     * @returns { void } Exports the diagram as an image or SVG element based on the specified options.\\\n     * @param {IExportOptions} options - An object defining how the diagram image should be exported.\n     */\n    Diagram.prototype.exportDiagram = function (options) {\n        if (this.printandExportModule) {\n            var data = this.printandExportModule.exportDiagram(options);\n            return data;\n        }\n        else {\n            console.warn('[WARNING] :: Module \"PrintAndExport\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n            return '';\n        }\n    };\n    /**\n     * Prints the diagram.\n     *\n     * @returns { void }     Prints the diagram.\\\n     * @param {IPrintOptions} optons - An IPrintOptions object that defines how the diagram is to be printed.\n     */\n    Diagram.prototype.print = function (options) {\n        if (this.printandExportModule) {\n            this.printandExportModule.print(options);\n        }\n        else {\n            console.warn('[WARNING] :: Module \"PrintAndExport\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n    };\n    /**\n     * Adds ports to a node or connector at runtime. \\\n     *\n     * @returns { void }    Adds ports to a node or connector at runtime.\\\n     * @param { Node | ConnectorModel} obj - object representing the node or connector to which ports will be added.\n     * @param {ShapeAnnotationModel[] | PathAnnotationModel[]} ports - objects representing the ports to be added.\n     * @blazorArgsType obj|DiagramNode\n     */\n    Diagram.prototype.addPorts = function (obj, ports) {\n        this.protectPropertyChange(true);\n        var portCollection = [];\n        var isAddPortInServer = true;\n        var exist = false;\n        //Removed isBlazor code\n        obj = this.nameTable[obj.id] || obj;\n        var newObj;\n        if (ports.length > 1) {\n            this.startGroupAction();\n        }\n        var _loop_3 = function (i) {\n            //907755 - Issue in add/remove port on runtime\n            exist = obj.ports.some(function (port) { return port.id === ports[parseInt(i.toString(), 10)].id; });\n            if (exist) {\n                return \"continue\";\n            }\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                newObj = new _objects_port__WEBPACK_IMPORTED_MODULE_34__.PointPort(obj, 'ports', ports[parseInt(i.toString(), 10)], true);\n                obj.ports.push(newObj);\n            }\n            else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                newObj = new _objects_port__WEBPACK_IMPORTED_MODULE_34__.PathPort(obj, 'ports', ports[parseInt(i.toString(), 10)], true);\n                obj.ports.push(newObj);\n            }\n            //Removed isBlazor code\n            if (obj.children) {\n                // 907773: Add port to Group at runtime Issue Fix\n                var container = obj.wrapper;\n                for (var k = 0; k < container.children.length; k++) {\n                    var wrapper = container.children[parseInt(k.toString(), 10)];\n                    if ((wrapper.id).match(container.id)) {\n                        obj.initPort(this_3.getDescription, wrapper, newObj);\n                        break;\n                    }\n                }\n            }\n            else {\n                var canvas = obj.wrapper;\n                if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                    canvas.children.push(obj.initPortWrapper(obj.ports[obj.ports.length - 1]));\n                }\n                else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                    var points = obj.type === 'Bezier' ? obj.intermediatePoints : obj.getConnectorPoints(obj.type);\n                    points = obj.clipDecorators(obj, points);\n                    var bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect.toBounds(points);\n                    // eslint-disable-next-line max-len\n                    canvas.children.push(obj.initPort(obj.ports[obj.ports.length - 1], points, bounds, undefined));\n                }\n            }\n            if (!(this_3.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo) && !(this_3.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Group)) {\n                var entry = {\n                    type: 'PortCollectionChanged', changeType: 'Insert', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(newObj),\n                    redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal'\n                };\n                this_3.addHistoryEntry(entry);\n            }\n        };\n        var this_3 = this;\n        for (var i = 0; i < ports.length; i++) {\n            _loop_3(i);\n        }\n        if (ports.length > 1) {\n            this.endGroupAction();\n        }\n        //Removed isBlazor code\n        obj.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(obj.width, obj.height));\n        obj.wrapper.arrange(obj.wrapper.desiredSize);\n        this.updateDiagramObject(obj);\n        this.protectPropertyChange(false);\n    };\n    /**\n     * Adds constraints at run time. \\\n     *\n     * @returns { void }Add constraints at run time .\\\n     * @param {number} constraintsType - The source value for constraints.\n     * @param {number} constraintsValue - The target value for constraints.\n     *\n     */\n    Diagram.prototype.addConstraints = function (constraintsType, constraintsValue) {\n        return constraintsType | constraintsValue;\n    };\n    /**\n     * Remove constraints at run time. \\\n     *\n     * @returns { void }Remove constraints at run time.\\\n     * @param {number} constraintsType - The type of constraints to be removed.\n     * @param {number} constraintsValue - The value of constraints to be removed.\n     *\n     */\n    Diagram.prototype.removeConstraints = function (constraintsType, constraintsValue) {\n        return constraintsType & ~constraintsValue;\n    };\n    /**\n     * Add labels in node at the run time in the blazor platform  \\\n     *\n     * @returns { void } Add labels in node at the run time in the blazor platform  \\\n     * @param {NodeModel} obj - provide the obj value.\n     * @param {ShapeAnnotationModel[]} labels - provide the labels value.\n     *\n     */\n    Diagram.prototype.addNodeLabels = function (obj, labels) {\n        this.addLabels(obj, labels);\n    };\n    /**\n     * Adds labels to a connector at runtime in the Blazor platform.\\\n     *\n     * @returns { void } Adds labels to a connector at runtime in the Blazor platform.\\\n     * @param {ConnectorModel} obj - The connector to which labels will be added.\n     * @param {PathAnnotationModel[]} labels - An array of labels to add to the connector.\n     *\n     */\n    Diagram.prototype.addConnectorLabels = function (obj, labels) {\n        this.addLabels(obj, labels);\n    };\n    /**\n     * Adds labels to a node or connector at runtime. \\\n     *\n     * @returns { void } Adds labels to a node or connector at runtime.\\\n     * @param {NodeModel | ConnectorModel} obj - The node or connector to which labels will be added.\n     * @param {ShapeAnnotationModel[] | PathAnnotation[] | PathAnnotationModel[]} labels - An array of label objects to be added.\n     *\n     */\n    Diagram.prototype.addLabels = function (obj, labels) {\n        this.protectPropertyChange(true);\n        var isAddLabelInServer = true;\n        var annotationCollection = [];\n        //Removed isBlazor code\n        obj = this.nameTable[obj.id] || obj;\n        var canvas = obj.wrapper;\n        var newObj;\n        if (labels.length > 1) {\n            this.startGroupAction();\n        }\n        for (var i = 0; i < labels.length; i++) {\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                newObj = new _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.ShapeAnnotation(obj, 'annotations', labels[parseInt(i.toString(), 10)], true);\n                obj.annotations.push(newObj);\n                //Removed isBlazor code\n                if (obj.children) {\n                    var node = obj;\n                    for (var i_2 = 0; i_2 < node.wrapper.children.length; i_2++) {\n                        if (node.wrapper.children[parseInt(i_2.toString(), 10)].id === node.id + 'group_container') {\n                            var container = node.wrapper.children[parseInt(i_2.toString(), 10)];\n                            container.children.push(obj.initAnnotationWrapper(obj.annotations[obj.annotations.length - 1], this.element.id));\n                        }\n                    }\n                }\n                else {\n                    canvas.children.push(obj.initAnnotationWrapper(obj.annotations[obj.annotations.length - 1], this.element.id));\n                }\n            }\n            else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                newObj = new _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation(obj, 'annotations', labels[parseInt(i.toString(), 10)], true);\n                obj.annotations.push(newObj);\n                //Removed isBlazor code\n                var segment = canvas.children[0];\n                var bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect(segment.offsetX - segment.width / 2, segment.offsetY - segment.height / 2, segment.width, segment.height);\n                canvas.children.push(obj.getAnnotationElement(obj.annotations[obj.annotations.length - 1], obj.intermediatePoints, bounds, this.getDescription, this.element.id));\n            }\n            if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo) && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Group)) {\n                var entry = {\n                    type: 'LabelCollectionChanged', changeType: 'Insert', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(newObj),\n                    redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal'\n                };\n                this.addHistoryEntry(entry);\n            }\n        }\n        if (labels.length > 1) {\n            this.endGroupAction();\n        }\n        //Removed isBlazor code\n        obj.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(canvas.width, canvas.height));\n        obj.wrapper.arrange(canvas.desiredSize);\n        this.updateDiagramObject(obj);\n        this.protectPropertyChange(false);\n        //EJ2-908488 - Added for Update annotations in overview\n        this.refreshCanvasLayers();\n    };\n    /**\n     *addChildToUmlNode - Add methods, members and attributes into a UML class runtime. \\\n     *\n     * @returns { void } Add.\n     * @param {NodeModel} node - Specifies the existing UmlClass node in the diagram to which you intend to add child elements.\n     * @param {UmlClassMethodModel | UmlClassAttributeModel | UmlEnumerationMemberModel} child - Specify the child elements, such as attributes, members, or methods, to be added to the UML class.\n     * @param {UmlClassChildType} umlChildType - Specify the enum that you intend to add to the UML class.\n     *\n     */\n    Diagram.prototype.addChildToUmlNode = function (node, child, umlChildType) {\n        var classifier;\n        var method;\n        var attribute;\n        var member;\n        var textWrap = 'NoWrap';\n        //Members and attributes are exclusively added to the classShape and interfaceShape within the UML node\n        if (node.shape.classifier === 'Class' || node.shape.classifier === 'Interface') {\n            if (umlChildType === 'Method') {\n                method = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.UmlClassMethod(node, '', child);\n                if (node.shape.classifier === 'Class') {\n                    node.shape.classShape.methods.push(method);\n                    classifier = node.shape.classShape;\n                }\n                else if (node.shape.classifier === 'Interface') {\n                    node.shape.interfaceShape.methods.push(method);\n                    classifier = node.shape.interfaceShape;\n                }\n                //this method triggers for adding methods at runtime\n                (0,_utility_uml_util__WEBPACK_IMPORTED_MODULE_47__.getClassMembersChild)(node, this, classifier, textWrap);\n            }\n            else if (umlChildType === 'Attribute') {\n                attribute = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.UmlClassAttribute(node, '', child);\n                if (node.shape.classifier === 'Class') {\n                    node.shape.classShape.attributes.push(attribute);\n                    classifier = node.shape.classShape;\n                }\n                else if (node.shape.classifier === 'Interface') {\n                    node.shape.interfaceShape.attributes.push(attribute);\n                    classifier = node.shape.interfaceShape;\n                }\n                //this method triggers for adding attributes at runtime\n                (0,_utility_uml_util__WEBPACK_IMPORTED_MODULE_47__.getClassAttributesChild)(node, this, classifier, textWrap);\n            }\n        }\n        else if (node.shape.classifier === 'Enumeration' && umlChildType === 'Member') {\n            member = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.UmlEnumerationMember(node, '', child);\n            node.shape.enumerationShape.members.push(member);\n            classifier = node.shape.enumerationShape;\n            //this method triggers for adding members at runtime\n            (0,_utility_uml_util__WEBPACK_IMPORTED_MODULE_47__.getClassNodesChild)(node, this, classifier, textWrap);\n        }\n        //The clearSelection methods is invoked to update the newly added child type dynamically at runtime\n        this.clearSelection();\n        this.updateSelector();\n    };\n    /**\n     * Dynamically add lanes to a swimlane at runtime. You can specify the swimlane (node), the lanes to be added (lane), and an optional index to determine where the lanes should be inserted. \\\n     *\n     * @returns { void } Dynamically add lanes to a swimlane at runtime. You can specify the swimlane (node), the lanes to be added (lane), and an optional index to determine where the lanes should be inserted.\\\n     * @param {NodeModel} node - The swimlane to which lanes will be added.\n     * @param {LaneModel[]} lane -An array of LaneModel objects representing the lanes to be added.\n     * @param {number} index - The index at which the lanes should be inserted.\n     *\n     */\n    Diagram.prototype.addLanes = function (node, lane, index) {\n        node = this.nameTable[node.id] || node;\n        for (var i = 0; i < lane.length; i++) {\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.addLane)(this, node, lane[parseInt(i.toString(), 10)], index);\n            if (index !== undefined) {\n                index += 1;\n            }\n        }\n        this.updateDiagramElementQuad();\n    };\n    /**\n     * Adds phases to a swimlane at runtime.  \\\n     *\n     * @returns { void } Adds phases to a swimlane at runtime. \\\n     * @param {NodeModel} node - object representing the swimlane to which phases will be added.\n     * @param {PhaseModel[]} phases - objects representing the phases to be added.\n     *\n     */\n    Diagram.prototype.addPhases = function (node, phases) {\n        node = this.nameTable[node.id] || node;\n        for (var i = 0; i < phases.length; i++) {\n            //897967-Exception thrown when adding Phases at runtime and perform undo Action\n            this.protectPropertyChange(true);\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.addPhase)(this, node, phases[parseInt(i.toString(), 10)]);\n            this.protectPropertyChange(false);\n        }\n        this.updateDiagramElementQuad();\n    };\n    /**\n     *Removes a dynamic lane from a swimlane at runtime. \\\n     *\n     * @returns { void } Removes a dynamic lane from a swimlane at runtime.\\\n     * @param {NodeModel} node - representing the swimlane to remove the lane from.\n     * @param {LaneModel} lane - representing the dynamic lane to be removed.\n     *\n     */\n    Diagram.prototype.removeLane = function (node, lane) {\n        if (lane) {\n            // 912168- Undoing removed lane throws exception Issue Fix\n            var laneHead = this.nameTable[lane.header.id];\n            this.diagramActions = this.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod;\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.removeLane)(this, laneHead, node, undefined);\n            this.updateDiagramElementQuad();\n        }\n    };\n    /**\n     *Removes a phase from a swimlane at runtime.\\\n     *\n     * @returns { void } Removes a phase from a swimlane at runtime.\\\n     * @param {NodeModel} node - representing the swimlane to remove the phase from.\n     * @param {PhaseModel} phase - representing the phase to be removed.\n     *\n     */\n    Diagram.prototype.removePhase = function (node, phase) {\n        var id = phase.header.id;\n        var phaseObj = this.nameTable[\"\" + id];\n        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.removePhase)(this, phaseObj, node);\n        this.updateDiagramElementQuad();\n    };\n    //827745-support to edit Segment for Straight connector at runtime.\n    /**\n     * Used to add or remove intermediate segments to the straight connector.\n     *\n     * @returns { void }  Used to add or remove intermediate segments to the straight connector.\n     * @param {IEditSegmentOptions} editOptions - An object containing various options for adding/removing segments.\n     *\n     */\n    Diagram.prototype.editSegment = function (editOptions) {\n        if (editOptions.connector.type === 'Straight') {\n            var connector = editOptions.connector;\n            var mode = editOptions && editOptions.SegmentEditing ? editOptions.SegmentEditing : 'Toggle';\n            var point = editOptions.point;\n            var hasPoint = void 0;\n            var allowEdit = void 0;\n            for (var i = 0; i < connector.segments.length; i++) {\n                var segment = (connector.segments)[parseInt(i.toString(), 10)];\n                if ((0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.contains)(point, segment.point, connector.hitPadding)) {\n                    hasPoint = true;\n                    break;\n                }\n            }\n            if ((hasPoint && mode === 'Remove') || (!hasPoint && mode === 'Add')) {\n                allowEdit = true;\n            }\n            if ((connector.type === 'Straight') && (allowEdit || mode === 'Toggle')) {\n                this.connectorEditingToolModule.addOrRemoveSegment(connector, point, this.commandHandler);\n            }\n        }\n    };\n    Diagram.prototype.removelabelExtension = function (obj, labels, j, wrapper) {\n        for (var i = 0; i < wrapper.children.length; i++) {\n            var canvas = wrapper.children[parseInt(i.toString(), 10)];\n            if ((canvas instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) || (canvas instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_37__.DiagramHtmlElement)) {\n                if (canvas.id.match('_' + labels[parseInt(j.toString(), 10)].id + '$')) {\n                    for (var k = 0; k < obj.annotations.length; k++) {\n                        if (canvas.id.match('_' + obj.annotations[parseInt(k.toString(), 10)].id + '$')) {\n                            if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n                                var entry = {\n                                    type: 'LabelCollectionChanged', changeType: 'Remove', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj.annotations[parseInt(k.toString(), 10)]),\n                                    redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal'\n                                };\n                                this.addHistoryEntry(entry);\n                            }\n                            obj.annotations.splice(k, 1);\n                        }\n                    }\n                    wrapper.children.splice(i, 1);\n                    if (this.mode === 'SVG') {\n                        var element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(canvas.id, this.element.id);\n                        if (element) {\n                            var element_1 = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(canvas.id, this.element.id);\n                            element_1.parentNode.removeChild(element_1);\n                        }\n                        var textElement = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(canvas.id + '_text', this.element.id);\n                        if (textElement) {\n                            element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(canvas.id + '_text', this.element.id);\n                            element.parentNode.removeChild(element);\n                        }\n                        var htmlElement = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(canvas.id + '_html_element', this.element.id);\n                        if (htmlElement) {\n                            htmlElement.parentNode.removeChild(htmlElement);\n                        }\n                    }\n                    else {\n                        this.refreshCanvasLayers();\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Removes labels from a node or connector at runtime. \\\n     *\n     * @returns { string }    Removes labels from a node or connector at runtime. \\\n     * @param { Node | ConnectorModel} obj - Representing the node or connector to remove labels from.\n     * @param {ShapeAnnotationModel[] | PathAnnotationModel[]} labels - objects representing the labels to be removed.\n     *\n     */\n    Diagram.prototype.removeLabels = function (obj, labels) {\n        var isAddLabelInServer = true;\n        //Removed isBlazor code\n        obj = this.nameTable[obj.id] || obj;\n        // Removed isBlazor code\n        if (labels.length > 1) {\n            this.startGroupAction();\n        }\n        for (var j = labels.length - 1; j >= 0; j--) {\n            if (obj.children && obj.children.length > 0) {\n                //Bug 886881: Exception throws while ungrouping a group node with annotations.\n                //Added the condition to check the wrapper id is same as the obj id to remove the group node label alone while unGroup.\n                var groupWrapper = obj.wrapper.children.filter(function (wrapper) { return wrapper.id === obj.id + 'group_container'; });\n                if (groupWrapper && groupWrapper.length > 0) {\n                    this.removelabelExtension(obj, labels, j, groupWrapper[0]);\n                }\n            }\n            else {\n                this.removelabelExtension(obj, labels, j, obj.wrapper);\n            }\n        }\n        if (labels.length > 1) {\n            this.endGroupAction();\n        }\n        //EJ2-908488 - Added for Update annotations in overview\n        this.refreshCanvasLayers();\n    };\n    Diagram.prototype.removePortsExtenion = function (obj, ports, j, wrapper) {\n        for (var i = 0; i < wrapper.children.length; i++) {\n            var canvas = wrapper.children[parseInt(i.toString(), 10)];\n            if (canvas instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_15__.PathElement) {\n                if (canvas.id.match('_' + ports[parseInt(j.toString(), 10)].id + '$')) {\n                    for (var k = 0; k < obj.ports.length; k++) {\n                        if (canvas.id.match('_' + obj.ports[parseInt(k.toString(), 10)].id + '$')) {\n                            if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n                                var entry = {\n                                    type: 'PortCollectionChanged', changeType: 'Remove', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj.ports[parseInt(k.toString(), 10)]),\n                                    redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), category: 'Internal'\n                                };\n                                this.addHistoryEntry(entry);\n                            }\n                            obj.ports.splice(k, 1);\n                        }\n                    }\n                    wrapper.children.splice(i, 1);\n                    if (this.mode === 'SVG') {\n                        var element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(canvas.id, this.element.id);\n                        // 905159: undo redo the multi-node after the group and ungrouping the multi nodes Issue fix\n                        if (element) {\n                            element.parentNode.removeChild(element);\n                        }\n                    }\n                    else {\n                        this.refreshCanvasLayers();\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Removes Ports at run time. \\\n     *\n     * @returns { void } Removes Ports at run time.\\\n     * @param {Node} obj - The node or connector to remove ports from.\n     * @param {PointPortModel[]} ports - An array of ports to be removed.\n     *\n     */\n    Diagram.prototype.removePorts = function (obj, ports) {\n        var isAddPortInServer = true;\n        //Removed isBlazor code\n        obj = this.nameTable[obj.id] || obj;\n        var portLength = ports.length;\n        //Removed isBlazor code\n        if (portLength > 1) {\n            this.startGroupAction();\n        }\n        for (var j = ports.length - 1; j >= 0; j--) {\n            if (obj.children && obj.children.length > 0) {\n                for (var k = 0; k < obj.wrapper.children.length; k++) {\n                    //EJ2-66928 Bug- added for ungroup Issue to only remove the grouping ports and not to remove ports of the children nodes\n                    var wrapper = obj.wrapper.children[parseInt(k.toString(), 10)];\n                    if ((wrapper.id).match(obj.wrapper.id)) {\n                        this.removePortsExtenion(obj, ports, j, obj.wrapper.children[parseInt(k.toString(), 10)]);\n                    }\n                }\n            }\n            else {\n                this.removePortsExtenion(obj, ports, j, obj.wrapper);\n            }\n        }\n        if (portLength > 1) {\n            this.endGroupAction();\n        }\n    };\n    //public methods - end region\n    /**\n     * getSizeValue method \\\n     *\n     * @returns { string }     getSizeValue method .\\\n     * @param {string | number} real - provide the real value.\n     * @param {string | number} rulerSize - provide the rulerSize value.\n     *\n     * @private\n     */\n    Diagram.prototype.getSizeValue = function (real, rulerSize) {\n        var value;\n        if (real.toString().indexOf('px') > 0) {\n            value = real.toString();\n        }\n        else if (real.toString().indexOf('%') > 0) {\n            value = rulerSize !== undefined ? '100%' : real.toString();\n        }\n        else {\n            value = real.toString() + 'px';\n        }\n        if (rulerSize) {\n            var position = (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.getRulerSize)(this);\n            value = 'calc(' + value + ' - ' + rulerSize + 'px)';\n        }\n        return value;\n    };\n    Diagram.prototype.renderRulers = function () {\n        if (this.rulerSettings.showRulers) {\n            (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.renderOverlapElement)(this);\n            (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.renderRuler)(this, true);\n            (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.renderRuler)(this, false);\n        }\n        else {\n            (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.removeRulerElements)(this);\n        }\n    };\n    Diagram.prototype.intOffPageBackground = function () {\n        var position = new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size();\n        position = (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.getRulerSize)(this);\n        var element = document.getElementById(this.element.id + 'content');\n        //Task 913515: Handle null properties for diagram and barcode properties-phase1\n        if (!this.width) {\n            this.width = '100%';\n        }\n        if (!this.height) {\n            this.height = '100%';\n        }\n        var width = this.getSizeValue(this.width, position.width);\n        var height = this.getSizeValue(this.height, position.height);\n        var style = this.rulerSettings.showRulers ?\n            'width:' + width + '; height:' + height + ';' +\n                'top:' + position.height + 'px;left:' + position.width + 'px;' +\n                'overflow: scroll;position:absolute;overflow:auto;' :\n            'width:' + width + '; height:' + height + ';position:absolute;' +\n                ' left:0px;  top:0px;overflow: auto;';\n        var attr = {\n            'id': this.element.id + 'content',\n            'tabindex': '0',\n            'style': style\n        };\n        if (!element) {\n            this.diagramCanvas = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', attr);\n            this.element.appendChild(this.diagramCanvas);\n        }\n        else {\n            this.diagramCanvas = element;\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.applyStyleAgainstCsp)(this.diagramCanvas, style);\n        }\n        this.diagramCanvas.style.background = this.backgroundColor;\n    };\n    Diagram.prototype.initDiagram = function () {\n        this.intOffPageBackground();\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeHtml)(this.element, {\n            style: 'width:' + this.getSizeValue(this.width) + '; height:'\n                + this.getSizeValue(this.height) + ';position:relative;overflow:hidden;'\n        });\n    };\n    Diagram.prototype.renderHiddenUserHandleTemplateLayer = function (bounds) {\n        //let element: HTMLElement;\n        var attributes = {\n            'class': this.element.id + '_hiddenUserHandleTemplate',\n            'style': 'width:' + bounds.width + 'px; height:' + bounds.height + 'px;' + 'visibility:hidden ;  overflow: hidden;'\n        };\n        var element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', attributes);\n        this.element.appendChild(element);\n    };\n    Diagram.prototype.renderBackgroundLayer = function (bounds, commonStyle) {\n        var bgLayer = this.createSvg(this.element.id + '_backgroundLayer_svg', bounds.width, bounds.height);\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.applyStyleAgainstCsp)(bgLayer, commonStyle);\n        var backgroundImage = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', {\n            'id': this.element.id + '_backgroundImageLayer',\n            'class': 'e-background-image-layer'\n        });\n        bgLayer.appendChild(backgroundImage);\n        var attr = { 'id': this.element.id + '_backgroundLayer', 'class': 'e-background-layer' };\n        var background = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', attr);\n        bgLayer.appendChild(background);\n        this.diagramCanvas.appendChild(bgLayer);\n    };\n    Diagram.prototype.renderGridLayer = function (bounds, commonStyle) {\n        var svgGridSvg = this.createSvg(this.element.id + '_gridline_svg', bounds.width, bounds.height);\n        svgGridSvg.setAttribute('class', 'e-grid-layer');\n        var svgGrid = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', { 'id': this.element.id + '_gridline' });\n        var rect = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('rect', {\n            'id': this.element.id + '_grid_rect', 'x': '0', 'y': '0', 'width': '100%', 'height': '100%'\n        });\n        if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.checkBrowserInfo)()) {\n            //EJ2-832888-To remove the black grid lines appearing in the safari browser.\n            var url = new URL(window.location.href);\n            // Check if the URL contains a query string\n            if (url.search !== '') {\n                rect.setAttribute('fill', 'url(#' + this.element.id + '_pattern)');\n            }\n            else {\n                rect.setAttribute('fill', 'url(' + location.protocol + '//' + location.host + location.pathname +\n                    '#' + this.element.id + '_pattern)');\n            }\n        }\n        else {\n            rect.setAttribute('fill', 'url(#' + this.element.id + '_pattern)');\n        }\n        svgGrid.appendChild(rect);\n        svgGridSvg.appendChild(svgGrid);\n        this.diagramCanvas.appendChild(svgGridSvg);\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)(svgGridSvg, { 'style': commonStyle });\n    };\n    Diagram.prototype.renderDiagramLayer = function (bounds, commonStyle) {\n        var attributes = {\n            'id': this.element.id + '_diagramLayer_div',\n            'style': 'width:' + bounds.width + 'px; height:' + bounds.height + 'px;' + commonStyle\n        };\n        this.diagramLayerDiv = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', attributes);\n        if (this.mode === 'SVG') {\n            var diagramSvg = this.createSvg(this.element.id + '_diagramLayer_svg', bounds.width, bounds.height);\n            diagramSvg.style['pointer-events'] = 'none';\n            diagramSvg.setAttribute('class', 'e-diagram-layer');\n            var diagramLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', { 'id': this.element.id + '_diagramLayer' });\n            var transformationLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', {});\n            this.diagramLayer = diagramLayer;\n            diagramSvg.style['pointer-events'] = 'all';\n            transformationLayer.appendChild(diagramLayer);\n            diagramSvg.appendChild(transformationLayer);\n            this.diagramLayerDiv.appendChild(diagramSvg);\n        }\n        else {\n            this.diagramLayer = _rendering_canvas_renderer__WEBPACK_IMPORTED_MODULE_1__.CanvasRenderer.createCanvas(this.element.id + '_diagram', bounds.width, bounds.height);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.applyStyleAgainstCsp)(this.diagramLayer, 'position:absolute;left:0px;top:0px;');\n            this.diagramLayerDiv.appendChild(this.diagramLayer);\n        }\n        this.diagramCanvas.appendChild(this.diagramLayerDiv);\n    };\n    Diagram.prototype.initLayers = function () {\n        var commonStyle = 'position:absolute;top:0px;left:0px;overflow:hidden;pointer-events:none;';\n        var container = document.getElementById(this.element.id);\n        var bounds = container.getBoundingClientRect();\n        //Task 918932: Provide diagram control in powerapps- phase2\n        this.setScaleFromElement(bounds, container);\n        this.modifyBounds(bounds);\n        var scrollerSize = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getScrollerWidth)();\n        this.scroller.scrollerWidth = scrollerSize;\n        this.scroller.setViewPortSize(bounds.width, bounds.height);\n        this.renderRulers();\n        var measureWindowElement = 'measureElement';\n        if (window[\"\" + measureWindowElement]) {\n            window[\"\" + measureWindowElement] = null;\n            var measureElements = document.getElementById('measureElement');\n            measureElements.remove();\n        }\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createMeasureElements)();\n        // this.renderBackgroundImageLayer(bounds, commonStyle);\n        this.renderBackgroundLayer(bounds, commonStyle);\n        this.renderGridLayer(bounds, commonStyle);\n        this.renderDiagramLayer(bounds, commonStyle);\n        this.renderHTMLLayer(bounds, commonStyle);\n        this.renderPortsExpandLayer(bounds, commonStyle);\n        this.renderNativeLayer(bounds, commonStyle);\n        this.renderAdornerLayer(bounds, commonStyle);\n        this.renderHiddenUserHandleTemplateLayer(bounds);\n    };\n    /**\n     * @private\n     * @param { ClientRect } bounds - provide the bounds value\n     * @param { HTMLElement } container - provide the container value\n     * @returns { void }\n     *\n     */\n    Diagram.prototype.setScaleFromElement = function (bounds, container) {\n        var width = bounds.width / container.clientWidth;\n        this.scaleValue = width;\n    };\n    /**\n     * @private\n     * @returns { void }\n     * @param { any } bounds - provide the bounds value\n     */\n    Diagram.prototype.modifyBounds = function (bounds) {\n        var scale = this.scaleValue;\n        bounds.x = bounds.x / scale;\n        bounds.y = bounds.y / scale;\n        bounds.width = bounds.width / scale;\n        bounds.height = bounds.height / scale;\n    };\n    /**\n     * @private\n     * @returns { number } - Returns offset value\n     * @param { number } offset - provide the offset value\n     * @param { boolean } isTooltipOffset - provide the isTooltipOffset value\n     *\n     */\n    Diagram.prototype.modifyClientOffset = function (offset, isTooltipOffset) {\n        var scale = this.scaleValue;\n        var value = 0;\n        if (isTooltipOffset) {\n            value = offset * scale;\n        }\n        else {\n            value = offset / scale;\n        }\n        return value;\n    };\n    Diagram.prototype.renderAdornerLayer = function (bounds, commonStyle) {\n        var divElement = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', {\n            'id': this.element.id + '_diagramAdornerLayer',\n            'style': 'width:' + bounds.width + 'px;height:' + bounds.height + 'px;' + commonStyle\n        });\n        var element = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', {\n            'id': this.element.id + '_diagramUserHandleLayer',\n            'style': 'width:' + bounds.width + 'px;height:' + bounds.height + 'px;' + commonStyle\n        });\n        element.setAttribute('class', 'e-userHandle-layer');\n        divElement.appendChild(element);\n        var svgAdornerSvg = this.createSvg(this.element.id + '_diagramAdorner_svg', bounds.width, bounds.height);\n        svgAdornerSvg.setAttribute('class', 'e-adorner-layer');\n        svgAdornerSvg.style['pointer-events'] = 'none';\n        this.adornerLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', { 'id': this.element.id + '_diagramAdorner' });\n        this.adornerLayer.style[' pointer-events'] = 'all';\n        svgAdornerSvg.appendChild(this.adornerLayer);\n        divElement.appendChild(svgAdornerSvg);\n        this.diagramCanvas.appendChild(divElement);\n        var svgSelector = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', { 'id': this.element.id + '_SelectorElement' });\n        this.adornerLayer.appendChild(svgSelector);\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)(svgAdornerSvg, { style: 'pointer-events:none;' });\n    };\n    Diagram.prototype.renderPortsExpandLayer = function (bounds, commonStyle) {\n        var svgPortsSvg = this.createSvg(this.element.id + '_diagramPorts_svg', bounds.width, bounds.height);\n        svgPortsSvg.setAttribute('class', 'e-ports-expand-layer');\n        var svgPortsLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', {\n            'id': this.element.id + '_diagramPorts',\n            'class': 'e-ports-layer',\n            'style': 'pointer-events: all;'\n        });\n        svgPortsSvg.appendChild(svgPortsLayer);\n        var svgExpandLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', {\n            'id': this.element.id + '_diagramExpander',\n            'class': 'e-expand-layer',\n            'style': 'pointer-events: all;'\n        });\n        svgPortsSvg.appendChild(svgExpandLayer);\n        this.diagramCanvas.appendChild(svgPortsSvg);\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)(svgPortsSvg, { 'style': commonStyle });\n    };\n    Diagram.prototype.renderHTMLLayer = function (bounds, commonStyle) {\n        this.htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', {\n            'id': this.element.id + '_htmlLayer',\n            'style': 'width:' + bounds.width + 'px; height:' + bounds.height + 'px;position:absolute;top:0px;' +\n                'left:0px;overflow:hidden;pointer-events:none;',\n            'class': 'e-html-layer'\n        });\n        var htmlLayerDiv = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createHtmlElement)('div', {\n            'id': this.element.id + '_htmlLayer_div',\n            'style': 'position:absolute;top:0px;left:0px;pointer-events:all;'\n        });\n        this.htmlLayer.appendChild(htmlLayerDiv);\n        this.diagramCanvas.appendChild(this.htmlLayer);\n    };\n    Diagram.prototype.renderNativeLayer = function (bounds, commonStyle) {\n        var nativeLayerSvg = this.createSvg(this.element.id + '_nativeLayer_svg', bounds.width, bounds.height);\n        var nativeLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.createSvgElement)('g', { 'id': this.element.id + '_nativeLayer', 'style': 'pointer-events:all;' });\n        nativeLayerSvg.appendChild(nativeLayer);\n        this.diagramLayerDiv.appendChild(nativeLayerSvg);\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)(nativeLayerSvg, { 'class': 'e-native-layer', 'style': commonStyle });\n    };\n    /**\n     * createSvg method \\\n     *\n     * @returns { void }     createSvg method .\\\n     * @param {string} id - provide the source value.\n     * @param {string | number} width - provide the source value.\n     * @param {string | number} height - provide the source value.\n     *\n     * @private\n     */\n    Diagram.prototype.createSvg = function (id, width, height) {\n        var svgObj = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)(svgObj, { 'id': id, 'width': width, 'height': height });\n        return svgObj;\n    };\n    Diagram.prototype.updateBazorShape = function () {\n        for (var i = 0; i < this.nodes.length; i++) {\n            var node = this.nodes[parseInt(i.toString(), 10)];\n            switch (node.shape.type) {\n                case 'Bpmn':\n                    node.shape.bpmnShape =\n                        node.shape.shape;\n                    break;\n                case 'UmlActivity':\n                    node.shape.umlActivityShape =\n                        node.shape.shape;\n                    break;\n                case 'Flow':\n                    node.shape.flowShape =\n                        node.shape.shape;\n                    break;\n                case 'Basic':\n                    node.shape.basicShape =\n                        node.shape.shape;\n                    break;\n                case 'Text':\n                    node.shape.textContent =\n                        node.shape.content;\n                    break;\n            }\n        }\n    };\n    Diagram.prototype.initObjects = function (isLoad) {\n        this.updateBazorShape();\n        if (!this.isLoading) {\n            this.initData();\n        }\n        this.initLayerObjects();\n        this.updateBridging(isLoad);\n    };\n    /**\n     * initLayerObjects method \\\n     *\n     * @returns { void }     initLayerObjects method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.initLayerObjects = function () {\n        var hasLayers = this.layers.length > 1; //const set: boolean = false;\n        var connectors = [];\n        var blazor = 'Blazor';\n        //Removed isBlazor code\n        var tempTabel = {};\n        var bpmnTable = {};\n        var tempNode = [];\n        var groups = [];\n        var i = 0;\n        var previousNodeObject = [];\n        var previousConnectorObject = [];\n        var updateNodeObject = [];\n        var updateConnectorObject = [];\n        var changeNodes = [];\n        var changeConnectors = [];\n        //Removed isBlazor code\n        for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n            var obj = _a[_i];\n            obj.id = obj.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n            this.addToLayer(obj, hasLayers);\n            tempTabel[obj.id] = obj;\n        }\n        for (var _b = 0, _c = this.connectors; _b < _c.length; _b++) {\n            var obj = _c[_b];\n            obj.id = obj.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n            this.addToLayer(obj, hasLayers);\n            tempTabel[obj.id] = obj;\n        }\n        for (var _d = 0, _e = this.layers; _d < _e.length; _d++) {\n            var layer = _e[_d];\n            for (var _f = 0, _g = layer.objects; _f < _g.length; _f++) {\n                var obj = _g[_f];\n                if (tempTabel[\"\" + obj]) {\n                    if (!(tempTabel[\"\" + obj] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector)) {\n                        if (tempTabel[\"\" + obj].children) {\n                            groups.push(obj);\n                        }\n                        else if ((tempTabel[\"\" + obj].shape instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.BpmnShape) &&\n                            tempTabel[\"\" + obj].shape.activity.subProcess.processes &&\n                            tempTabel[\"\" + obj].shape.activity.subProcess.processes.length > 0) {\n                            bpmnTable[tempTabel[\"\" + obj].id] = obj;\n                        }\n                        else {\n                            this.initNodes(tempTabel[\"\" + obj], layer);\n                        }\n                    }\n                    else {\n                        var connector = tempTabel[\"\" + obj];\n                        if (connector.sourceID && connector.targetID) {\n                            var sourceNode = tempTabel[connector.sourceID];\n                            var targetNode = tempTabel[connector.targetID];\n                            var flag = true;\n                            if (this.isLoading && ((sourceNode && sourceNode.children && sourceNode.children.length > 0) ||\n                                (targetNode && targetNode.children && targetNode.children.length > 0))) {\n                                flag = false;\n                            }\n                            if ((sourceNode && sourceNode.wrapper && targetNode && targetNode.wrapper) && flag) {\n                                this.initConnectors(tempTabel[\"\" + obj], layer);\n                            }\n                            else {\n                                connectors.push(tempTabel[\"\" + obj]);\n                            }\n                        }\n                        else {\n                            // 908150: Connector not rendered properly when one end is a group and other end is an endpoint\n                            var sourceNode = tempTabel[connector.sourceID];\n                            var targetNode = tempTabel[connector.targetID];\n                            if ((sourceNode && sourceNode.children && sourceNode.children.length > 0) ||\n                                (targetNode && targetNode.children && targetNode.children.length > 0)) {\n                                connectors.push(tempTabel[\"\" + obj]);\n                            }\n                            else {\n                                this.initConnectors(tempTabel[\"\" + obj], layer);\n                            }\n                        }\n                    }\n                }\n            }\n            // 930450: Diagram Taking Too Long to Load Due to Complex Hierarchical Tree Layout with Path Nodes\n            if (this.pathDataStorage) {\n                this.pathDataStorage.clear();\n            }\n            if (this.bpmnModule) {\n                for (var _h = 0, _j = this.bpmnModule.bpmnTextAnnotationConnector; _h < _j.length; _h++) {\n                    var obj = _j[_h];\n                    this.initConnectors(obj, undefined, true);\n                }\n            }\n        }\n        for (var _k = 0, _l = Object.keys(bpmnTable); _k < _l.length; _k++) {\n            var obj = _l[_k];\n            this.initObject(tempTabel[\"\" + obj]);\n            this.bpmnModule.updateDocks(tempTabel[\"\" + obj], this);\n        }\n        var alignedGroups = this.alignGroup(groups, tempTabel);\n        for (var _m = 0, alignedGroups_1 = alignedGroups; _m < alignedGroups_1.length; _m++) {\n            var obj = alignedGroups_1[_m];\n            var layer = this.commandHandler.getObjectLayer(obj);\n            this.initNodes(tempTabel[\"\" + obj], layer);\n        }\n        for (var _o = 0, connectors_1 = connectors; _o < connectors_1.length; _o++) {\n            var connector = connectors_1[_o];\n            var layer = this.commandHandler.getObjectLayer(connector.id);\n            this.initConnectors(connector, layer);\n        }\n        //Removed isBlazor code\n    };\n    Diagram.prototype.alignGroup = function (parents, tempTabel) {\n        var newList = [];\n        var parentist = [];\n        var child;\n        var childNode;\n        var i;\n        var j;\n        for (i = 0; i < parents.length; i++) {\n            child = parents[parseInt(i.toString(), 10)];\n            childNode = tempTabel[\"\" + child];\n            var node = void 0;\n            if (childNode && childNode.children.length) {\n                for (j = 0; j < childNode.children.length; j++) {\n                    node = childNode.children[parseInt(j.toString(), 10)];\n                    if (parents.indexOf(node) > -1 && (newList.indexOf(node) === -1) &&\n                        (parentist.indexOf(node) === -1)) {\n                        newList.splice(0, 0, node);\n                    }\n                }\n            }\n            if (newList.indexOf(child) === -1) {\n                parentist.push(child);\n            }\n        }\n        newList = newList.concat(parentist);\n        return newList;\n    };\n    Diagram.prototype.addToLayer = function (obj, hasLayers) {\n        var layer;\n        var isSourceId = false;\n        var isTargetId = false;\n        if (hasLayers) {\n            layer = this.commandHandler.getObjectLayer(obj.id);\n        }\n        if (!hasLayers || !layer) {\n            if (this.activeLayer.objects.indexOf(obj.id) === -1) {\n                this.activeLayer.objects.push(obj.id);\n            }\n        }\n        if ((obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node || obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) &&\n            (obj.shape.type !== 'SwimLane' || (obj.children && obj.children.length > 0))) {\n            if (obj.parentId) {\n                var zIndex = this.swimlaneZIndexTable[obj.parentId];\n                //EJ2-69247 - Unable to select node in swimlane after save and load\n                var childzIndex = this.swimlaneChildTable[obj.id];\n                if ((zIndex && zIndex !== -1) || ((childzIndex && childzIndex !== -1))) {\n                    obj.zIndex = this.swimlaneChildTable[obj.id];\n                }\n            }\n            if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && (obj.sourceID && obj.targetID)) {\n                //EJ2-69577 - We have removed findNodeInLane method to improve the performance.\n                if (this.activeLayer.objects.indexOf(obj.sourceID) !== -1 &&\n                    this.activeLayer.objects.indexOf(obj.targetID) !== -1) {\n                    this.setZIndex(layer || this.activeLayer, obj);\n                }\n            }\n            else {\n                this.setZIndex(layer || this.activeLayer, obj);\n            }\n        }\n    };\n    Diagram.prototype.updateLayer = function (newProp) {\n        for (var _i = 0, _a = Object.keys(newProp.layers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var layerObject = this.layers[\"\" + key].objects;\n            for (var _b = 0, layerObject_1 = layerObject; _b < layerObject_1.length; _b++) {\n                var obj = layerObject_1[_b];\n                var node = this.nameTable[\"\" + obj];\n                if (newProp.layers[\"\" + key].visible !== undefined) {\n                    this.updateElementVisibility(node.wrapper, node, newProp.layers[\"\" + key].visible);\n                }\n                else if (newProp.layers[\"\" + key].lock === true) {\n                    this.unSelect(node);\n                }\n            }\n            if (newProp.layers[\"\" + key].lock !== undefined) {\n                this.layers[\"\" + key].lock = newProp.layers[\"\" + key].lock;\n            }\n        }\n        if (this.mode !== 'SVG') {\n            this.refreshDiagramLayer();\n        }\n    };\n    Diagram.prototype.updateScrollSettings = function (newProp) {\n        var hPan = (-this.scroller.horizontalOffset + newProp.scrollSettings.horizontalOffset || 0);\n        var vPan = (-this.scroller.verticalOffset + newProp.scrollSettings.verticalOffset || 0);\n        var oldValue = {\n            VerticalOffset: this.scrollSettings.verticalOffset, HorizontalOffset: this.scrollSettings.horizontalOffset,\n            ViewportHeight: this.scrollSettings.viewPortHeight, ViewportWidth: this.scrollSettings.viewPortWidth,\n            CurrentZoom: this.scroller.currentZoom\n        };\n        if (hPan !== 0 || vPan !== 0) {\n            this.pan(hPan, vPan);\n        }\n        var newValue = {\n            VerticalOffset: this.scrollSettings.verticalOffset, HorizontalOffset: this.scrollSettings.horizontalOffset,\n            ViewportHeight: this.scrollSettings.viewPortHeight, ViewportWidth: this.scrollSettings.viewPortWidth,\n            CurrentZoom: this.scroller.currentZoom\n        };\n        var panStatus = 'Start';\n        if (this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PanInProgress) {\n            panStatus = 'Progress';\n        }\n        var arg = {\n            oldValue: oldValue,\n            newValue: newValue, source: this,\n            panState: panStatus\n        };\n        //Removed isBlazor code\n        this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.scrollChange, arg);\n        this.commandHandler.updatePanState(true);\n        if (this.mode === 'Canvas' && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.Virtualization)) {\n            this.refreshDiagramLayer();\n        }\n    };\n    Diagram.prototype.initData = function () {\n        var dataSourceSettings = this.dataSourceSettings.dataManager || this.dataSourceSettings.dataSource;\n        var adapter = 'adaptorName';\n        if (this.dataBindingModule && !(this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventDataInit)) {\n            if (dataSourceSettings && this.dataSourceSettings.connectionDataSource.dataManager) {\n                var dataManager = this.dataSourceSettings.dataManager || this.dataSourceSettings.dataSource;\n                this.nodes = this.generateData(dataManager, true);\n                this.connectors = this.generateData(this.dataSourceSettings.connectionDataSource.dataManager, false);\n            }\n            else if (dataSourceSettings && dataSourceSettings.dataSource &&\n                (dataSourceSettings.dataSource.url || (dataSourceSettings[\"\" + adapter] === 'BlazorAdaptor' &&\n                    !dataSourceSettings.dataSource.url))) {\n                this.dataBindingModule.initSource(this.dataSourceSettings, this);\n            }\n            else {\n                this.dataBindingModule.initData(this.dataSourceSettings, this);\n            }\n        }\n        else if (dataSourceSettings && !this.dataBindingModule) {\n            console.warn('[WARNING] :: Module \"DataBinding\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n    };\n    Diagram.prototype.generateData = function (dataSource, isNode) {\n        var nodes = [];\n        var i;\n        for (i = 0; i < dataSource.length; i++) {\n            var row = dataSource[parseInt(i.toString(), 10)];\n            var node = isNode ? this.makeData(row, true) : this.makeData(row, false);\n            if (node && node.id && (!(0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findNodeByName)(nodes, node.id))) {\n                nodes.push(node);\n            }\n        }\n        return (nodes);\n    };\n    Diagram.prototype.makeData = function (row, isNode) {\n        var i;\n        var fields = isNode ? this.dataSourceSettings : this.dataSourceSettings.connectionDataSource;\n        var data = {};\n        data.id = row[fields.id] ? row[fields.id] : (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n        if (fields.sourceID) {\n            data.sourceID = row[fields.sourceID];\n        }\n        if (fields.targetID) {\n            data.targetID = row[fields.targetID];\n        }\n        if (row[fields.sourcePointX] && row[fields.sourcePointY]) {\n            data.sourcePoint = { 'x': Number(row[fields.sourcePointX]), 'y': Number(row[fields.sourcePointY]) };\n        }\n        if (row[fields.targetPointX] && row[fields.targetPointY]) {\n            data.targetPoint = { 'x': Number(row[fields.targetPointX]), 'y': Number(row[fields.targetPointY]) };\n        }\n        if (fields.crudAction.customFields && fields.crudAction.customFields.length > 0) {\n            for (i = 0; i < fields.crudAction.customFields.length; i++) {\n                data[fields.crudAction.customFields[parseInt(i.toString(), 10)]]\n                    = row[fields.crudAction.customFields[parseInt(i.toString(), 10)]];\n            }\n        }\n        return data;\n    };\n    Diagram.prototype.initNodes = function (obj, layer) {\n        this.preventDiagramUpdate = true;\n        this.initObject(obj, layer);\n        this.preventDiagramUpdate = false;\n    };\n    Diagram.prototype.initConnectors = function (obj, layer, independentObj) {\n        this.preventDiagramUpdate = true;\n        this.initObject(obj, layer, independentObj);\n        this.updateEdges(obj);\n        this.preventDiagramUpdate = false;\n    };\n    Diagram.prototype.setZIndex = function (layer, obj) {\n        //should be changed\n        var currentLayer = layer;\n        if ((obj).zIndex === Number.MIN_VALUE) {\n            while (currentLayer.zIndexTable[currentLayer.objectZIndex + 1]) {\n                layer.objectZIndex++;\n            }\n            // obj.zIndex = ++currentLayer.objectZIndex;\n            this.setIndex(layer, obj);\n        }\n        else {\n            var index = (obj.zIndex !== null ? obj.zIndex : currentLayer.objectZIndex + 1);\n            if (currentLayer.zIndexTable[parseInt(index.toString(), 10)]) {\n                var tabelLength = Object.keys(currentLayer.zIndexTable).length;\n                var j = 0;\n                for (var i = 0; i < tabelLength; i++) {\n                    if (i === index) {\n                        for (var j_1 = tabelLength; j_1 > index; j_1--) {\n                            currentLayer.zIndexTable[parseInt(j_1.toString(), 10)] = currentLayer.zIndexTable[j_1 - 1];\n                            if (this.nameTable[currentLayer.zIndexTable[parseInt(j_1.toString(), 10)]]) {\n                                this.nameTable[currentLayer.zIndexTable[parseInt(j_1.toString(), 10)]].zIndex = j_1;\n                            }\n                        }\n                        currentLayer.zIndexTable[parseInt(i.toString(), 10)] = obj.id;\n                    }\n                    j++;\n                }\n            }\n        }\n    };\n    Diagram.prototype.setIndex = function (layer, obj) {\n        var _this = this;\n        // Helper function to assign object zIndex and increment the objectZIndex of layer\n        var assignZIndex = function (element) {\n            element.zIndex = ++layer.objectZIndex;\n            if ((element.shape.type === 'Bpmn' && element.shape.activity &&\n                element.shape.activity.subProcess && element.shape.activity.subProcess.processes &&\n                element.shape.activity.subProcess.processes.length)) {\n                var processArray = element.shape.activity.subProcess.processes;\n                processArray.forEach(function (processId) {\n                    var processess = _this.nameTable[\"\" + processId];\n                    if (processess) {\n                        processess.zIndex = ++layer.objectZIndex;\n                    }\n                });\n            }\n        };\n        // Function to handle updating zIndex for child elements\n        var updateChildIndex = function (childId) {\n            // Find if the child is a node or a connector\n            var childNode = _this.nodes.find(function (node) { return node.id === childId; });\n            var childConnector = _this.connectors.find(function (connector) { return connector.id === childId; });\n            if (childNode) {\n                if (childNode.children && childNode.children.length > 0) {\n                    // Recursively update the z-index for children of group nodes\n                    _this.setIndex(layer, childNode);\n                }\n                else {\n                    // Assign zIndex to non-group child node\n                    assignZIndex(childNode);\n                }\n            }\n            else if (childConnector) {\n                // Assign zIndex to child connector\n                assignZIndex(childConnector);\n            }\n        };\n        // check object is present in current layer\n        var currentLayerObject = layer.objects.find(function (object) { return object === obj.id; });\n        if (currentLayerObject) {\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                // Assign zIndex to group or standalone node\n                assignZIndex(obj);\n                if (obj.shape.type !== 'SwimLane' && obj.children && obj.children.length > 0) {\n                    // Update zIndex for each child if there are children\n                    for (var k = 0; k < obj.children.length; k++) {\n                        updateChildIndex(obj.children[parseInt(k.toString(), 10)]);\n                    }\n                }\n            }\n            else {\n                // Assign zIndex to a connector\n                assignZIndex(obj);\n            }\n        }\n    };\n    Diagram.prototype.initializeDiagramLayers = function () {\n        //const tempLayers: LayerModel[] = this.layers;\n        for (var i = 0; i < this.layers.length; i++) {\n            if (this.layers[parseInt(i.toString(), 10)].zIndex !== -1) {\n                var temp = this.layers[parseInt(i.toString(), 10)];\n                this.layers[parseInt(i.toString(), 10)] = this.layers[this.layers[parseInt(i.toString(), 10)].zIndex];\n                this.layers[temp.zIndex] = temp;\n            }\n        }\n        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\n            var layer = _a[_i];\n            layer.zIndex = layer.zIndex !== -1 ? layer.zIndex : this.layers.indexOf(layer);\n            this.layerZIndexTable[layer.zIndex] = layer.id;\n        }\n        for (var i = 0; i < this.layers.length; i++) {\n            for (var j = i + 1; j < this.layers.length; j++) {\n                if (this.layers[parseInt(i.toString(), 10)].zIndex > this.layers[parseInt(j.toString(), 10)].zIndex) {\n                    var temp = this.layers[parseInt(i.toString(), 10)];\n                    this.layers[parseInt(i.toString(), 10)] = this.layers[parseInt(j.toString(), 10)];\n                    this.layers[parseInt(j.toString(), 10)] = temp;\n                }\n            }\n        }\n        if (this.layers.length === 0) {\n            var defaultLayer = {\n                id: 'default_layer', visible: true, lock: false, objects: [], zIndex: 0,\n                objectZIndex: -1, zIndexTable: {}\n            };\n            this.commandHandler.addLayer(defaultLayer, null, true);\n        }\n        this.setActiveLayer(this.layers[this.layers.length - 1].id);\n    };\n    /**\n     * resetTool method \\\n     *\n     * @returns { void }     resetTool method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.resetTool = function () {\n        this.eventHandler.resetTool();\n    };\n    Diagram.prototype.initObjectExtend = function (obj, layer, independentObj) {\n        if (independentObj) {\n            var checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, obj.wrapper.bounds, true);\n            //EJ2-71853 - Need to improve performance of diagram while rendering large number of nodes and connectors.\n            // Removed the for loop which is iterating through the zindex table and removing the object from the table as it is not covered in any scenario.\n            //EJ2-840575 - Order commands not working between Swimlane and other nodes while drag and drop from the palette\n            if (obj.shape.type === 'SwimLane') {\n                for (var i = 0, a = Object.keys(layer.zIndexTable); i < a.length; i++) {\n                    if (layer.zIndexTable[a[parseInt(i.toString(), 10)]] &&\n                        layer.zIndexTable[a[parseInt(i.toString(), 10)]] === obj.id) {\n                        delete layer.zIndexTable[a[parseInt(i.toString(), 10)]];\n                    }\n                }\n            }\n            layer.zIndexTable[obj.zIndex] = obj.id;\n            if (!checkBoundaryConstraints) {\n                var node = obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node ? this.nodes : this.connectors;\n                for (var i = 0; i <= node.length; i++) {\n                    if (node[parseInt(i.toString(), 10)] && obj.id\n                        === node[parseInt(i.toString(), 10)].id) {\n                        node.splice(i, 1);\n                    }\n                }\n                delete layer.zIndexTable[obj.zIndex];\n            }\n        }\n    };\n    /* tslint:disable */\n    /**\n     * initObject method \\\n     *\n     * @returns { void }     initObject method .\\\n     * @param {End} obj - provide the obj value.\n     * @param {End} layer - provide the layer value.\n     * @param {LayoutOrientation} independentObj - provide the independentObj value.\n     * @param {boolean} group - provide the independentObj value.\n     *\n     * @private\n     */\n    Diagram.prototype.initObject = function (obj, layer, independentObj, group) {\n        if (independentObj === void 0) { independentObj = true; }\n        if (obj !== undefined) {\n            if (independentObj) {\n                if (!layer) {\n                    this.addToLayer(obj, false);\n                    layer = this.activeLayer;\n                }\n                //Move the common properties like zindex and id to an abstract class\n                if ((obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node || obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) &&\n                    (obj.shape.type !== 'SwimLane' || (obj.children && obj.children.length > 0))) {\n                    this.setZIndex(layer, obj);\n                }\n            }\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                if (independentObj) {\n                    // 939249: Duplicate Ports Added to Group After Grouping and Undoing.\n                    if (obj.id !== 'helper' && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n                        var getDefaults = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getFunction)(this.getNodeDefaults);\n                        if (getDefaults) {\n                            var defaults = getDefaults(obj, this);\n                            if (defaults && defaults.ports) {\n                                for (var i = 0; i < defaults.ports.length; i++) {\n                                    defaults.ports[parseInt(i.toString(), 10)].inEdges = [];\n                                    defaults.ports[parseInt(i.toString(), 10)].outEdges = [];\n                                }\n                            }\n                            if (defaults && defaults !== obj) {\n                                (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.extendObject)(defaults, obj);\n                            }\n                        }\n                    }\n                    this.initNode(obj, this.element.id);\n                }\n            }\n            else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                var getDefaults = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getFunction)(this.getConnectorDefaults);\n                if (getDefaults) {\n                    var defaults = getDefaults(obj, this);\n                    if (defaults && defaults !== obj) {\n                        (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.extendObject)(defaults, obj);\n                    }\n                    if (obj.segments.length) {\n                        if (obj.type !== obj.segments[0].type) {\n                            obj.segments = [];\n                        }\n                    }\n                }\n                var sourceNode = this.nameTable[obj.sourceID];\n                var targetNode = this.nameTable[obj.targetID];\n                var port = this.getConnectedPort(sourceNode, obj, true);\n                var targetPort = this.getConnectedPort(targetNode, obj);\n                var outPort = this.findInOutConnectPorts(sourceNode, false);\n                var inPort = this.findInOutConnectPorts(targetNode, true);\n                if ((sourceNode !== undefined && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canOutConnect)(sourceNode)) || (obj.sourcePortID !== ''\n                    && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canPortOutConnect)(outPort))) {\n                    obj.sourceWrapper = this.getEndNodeWrapper(sourceNode, obj, true);\n                    if (obj.sourcePortID) {\n                        // eslint-disable-next-line max-len\n                        if (port && port.constraints && !(port.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortConstraints.None) && (port.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortConstraints.OutConnect)) {\n                            obj.sourcePortWrapper = this.getWrapper(sourceNode.wrapper, obj.sourcePortID);\n                        }\n                    }\n                }\n                if ((targetNode !== undefined && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canInConnect)(targetNode)) || (obj.targetPortID !== ''\n                    && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canPortInConnect)(inPort))) {\n                    obj.targetWrapper = this.getEndNodeWrapper(targetNode, obj, false);\n                    if (obj.targetPortID) {\n                        // eslint-disable-next-line max-len\n                        if (targetPort && targetPort.constraints && !(targetPort.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortConstraints.None) && (targetPort.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortConstraints.InConnect)) {\n                            obj.targetPortWrapper = this.getWrapper(targetNode.wrapper, obj.targetPortID);\n                        }\n                    }\n                }\n                if (!independentObj) {\n                    var points = obj.getConnectorPoints(obj.type);\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateConnector)(obj, points);\n                }\n                if (independentObj) {\n                    obj.init(this);\n                }\n                for (var k = 0; k < obj.wrapper.children.length; k++) {\n                    if (this.pathTable[obj.wrapper.children[parseInt(k.toString(), 10)].data]) {\n                        obj.wrapper.children[parseInt(k.toString(), 10)].absoluteBounds =\n                            this.pathTable[obj.wrapper.children[parseInt(k.toString(), 10)].data].absoluteBounds;\n                    }\n                }\n                obj.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(undefined, undefined));\n                obj.wrapper.arrange(obj.wrapper.desiredSize);\n                if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && obj.type === 'Bezier') {\n                    this.updateConnectorAnnotation(obj);\n                    this.updateConnectorfixedUserHandles(obj);\n                }\n                for (var j = 0; j < obj.wrapper.children.length; j++) {\n                    this.pathTable[obj.wrapper.children[parseInt(j.toString(), 10)].data] = {};\n                    this.pathTable[obj.wrapper.children[parseInt(j.toString(), 10)].data].absoluteBounds =\n                        obj.wrapper.children[parseInt(j.toString(), 10)].absoluteBounds;\n                }\n            }\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node && obj.children && obj.container) {\n                for (var i = 0; i < obj.children.length; i++) {\n                    this.nameTable[obj.children[parseInt(i.toString(), 10)]].offsetX\n                        = this.nameTable[obj.children[parseInt(i.toString(), 10)]].wrapper.offsetX;\n                    this.nameTable[obj.children[parseInt(i.toString(), 10)]].offsetY\n                        = this.nameTable[obj.children[parseInt(i.toString(), 10)]].wrapper.offsetY;\n                }\n            }\n            // 908606: The nodes goes outside the subprocess while node rotation  Issue Fix\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node && obj.shape &&\n                obj.shape.shape === 'Activity' && obj.shape.activity.activity === 'SubProcess') {\n                if (obj.shape.activity.subProcess.processes) {\n                    var children = obj.shape.activity.subProcess.processes;\n                    for (var i = 0; i < children.length; i++) {\n                        if (this.nameTable[children[parseInt(i.toString(), 10)]]) {\n                            this.nameTable[children[parseInt(i.toString(), 10)]].offsetX\n                                = this.nameTable[children[parseInt(i.toString(), 10)]].wrapper.offsetX;\n                            this.nameTable[children[parseInt(i.toString(), 10)]].offsetY\n                                = this.nameTable[children[parseInt(i.toString(), 10)]].wrapper.offsetY;\n                        }\n                    }\n                }\n            }\n            this.initObjectExtend(obj, layer, independentObj);\n            this.nameTable[obj.id] = obj;\n            if (!this.refreshing) {\n                //To create text annotation node if we define shape annotations in parent node.\n                if (obj.shape.annotations && obj.shape.annotations.length > 0) {\n                    for (var i = 0; i < obj.shape.annotations.length\n                        && obj.shape.annotations[parseInt(i.toString(), 10)].text; i++) {\n                        this.getBPMNTextAnnotation(obj, this, obj.shape.annotations[parseInt(i.toString(), 10)], false);\n                    }\n                }\n            }\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node && obj.children) {\n                this.preventNodesUpdate = true;\n                this.preventConnectorsUpdate = true;\n                if (!group && !obj.container) {\n                    this.updateGroupOffset(obj, true);\n                }\n                this.groupTable[obj.id] = obj.children;\n                for (var i = 0; i < obj.children.length; i++) {\n                    var node = (this.nameTable[obj.children[parseInt(i.toString(), 10)]]);\n                    if (node) {\n                        node.parentId = obj.id;\n                    }\n                }\n                // 941671: Undo not functioning correctly after Group, Rotate, and Ungroup Actions in Diagram\n                if (!this.isLoading && obj.rotateAngle && !obj.container && !this.isUndo) {\n                    this.commandHandler.rotateObjects(obj, [obj], obj.rotateAngle, { x: obj.offsetX, y: obj.offsetY }, false);\n                }\n                this.preventNodesUpdate = false;\n                this.preventConnectorsUpdate = false;\n            }\n            if (this['enterObject'] === undefined) {\n                this.updateQuad(obj);\n            }\n        }\n        if (obj.visible === false) {\n            this.updateElementVisibility(obj.wrapper, obj, false);\n        }\n    };\n    /* tslint:enable */\n    Diagram.prototype.getConnectedPort = function (node, connector, isSource) {\n        if (node && node.ports) {\n            for (var _i = 0, _a = node.ports; _i < _a.length; _i++) {\n                var port = _a[_i];\n                if (port.id === connector.sourcePortID && isSource) {\n                    return port;\n                }\n                else if (port.id === connector.targetPortID && !isSource) {\n                    return port;\n                }\n            }\n        }\n        return null;\n    };\n    Diagram.prototype.scaleObject = function (obj, size, isWidth) {\n        var actualSize = isWidth ? obj.wrapper.actualSize.width : obj.wrapper.actualSize.height;\n        var sw = (isWidth) ? 1 + ((size - actualSize) / actualSize) : 1;\n        var sh = (isWidth) ? 1 : 1 + ((size - actualSize) / actualSize);\n        //const groupOffsetX: number = obj.offsetX; const groupOffsetY: number = obj.offsetY;\n        this.realActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventDrag;\n        this.scale(obj, sw, sh, { x: 0.5, y: 0.5 });\n        this.realActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventDrag;\n    };\n    Diagram.prototype.updateDefaultLayoutIcons = function (node) {\n        if (this.layout.type === 'OrganizationalChart' || this.layout.type === 'HierarchicalTree' ||\n            this.layout.type === 'ComplexHierarchicalTree') {\n            {\n                this.updateDefaultLayoutIcon(node, node.expandIcon);\n                this.updateDefaultLayoutIcon(node, node.collapseIcon);\n            }\n        }\n    };\n    Diagram.prototype.updateDefaultLayoutIcon = function (node, icon) {\n        if (icon.shape !== 'None') {\n            if (icon.horizontalAlignment === 'Auto' && icon.verticalAlignment === 'Auto' &&\n                icon.offset.x === .5 && icon.offset.y === 1) {\n                var iconWrapper = this.getWrapper(node.wrapper, 'icon_content');\n                var offsetX = void 0;\n                var offsetY = void 0;\n                if (this.layout.orientation === 'TopToBottom' || this.layout.orientation === 'BottomToTop') {\n                    offsetX = .5;\n                    offsetY = this.layout.orientation === 'TopToBottom' ? 1 : 0;\n                }\n                else if (this.layout.orientation === 'RightToLeft' || this.layout.orientation === 'LeftToRight') {\n                    offsetX = this.layout.orientation === 'LeftToRight' ? 1 : 0;\n                    offsetY = .5;\n                }\n                iconWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');\n                iconWrapper.horizontalAlignment = 'Center';\n                iconWrapper.verticalAlignment = 'Center';\n                node.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(node.wrapper.width, node.wrapper.height));\n                node.wrapper.arrange(node.wrapper.desiredSize);\n            }\n        }\n    };\n    /**\n     * updateGroupOffset method \\\n     *\n     * @returns { void }     updateGroupOffset method .\\\n     * @param {NodeModel | ConnectorModel} node - provide the source value.\n     * @param {boolean} isUpdateSize - provide the target value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateGroupOffset = function (node, isUpdateSize) {\n        var isUpdateGroupToBlazor = false;\n        if ((node.children && node.children.length > 0 && (!node.container)) || (node.processId)) {\n            var node1 = this.nameTable[node.id];\n            if (!(this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventScale) && !(this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventDrag)) {\n                if (node1.offsetX && ((this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.EnableGroupAction) ||\n                    ((!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) && (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)\n                        && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod))))) {\n                    this.realActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventScale;\n                    var diffX = (node1.offsetX - node.wrapper.offsetX);\n                    node1.offsetX = node.wrapper.offsetX;\n                    var diffY = (node1.offsetY - node.wrapper.offsetY);\n                    node1.offsetY = node.wrapper.offsetY;\n                    if ((diffX + diffY) !== 0) {\n                        this.drag(node1, diffX, diffY);\n                    }\n                    this.realActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventScale;\n                }\n                else {\n                    //Removed isBlazor code\n                    node1.offsetX = node.wrapper.offsetX;\n                }\n                if (node1.offsetY && ((this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.EnableGroupAction) ||\n                    ((!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) && (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)\n                        && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod))))) {\n                    this.realActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventScale;\n                    var diffY = (node1.offsetY - node.wrapper.offsetY);\n                    node1.offsetY = node.wrapper.offsetY;\n                    this.drag(node1, 0, diffY);\n                    this.realActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.PreventScale;\n                }\n                else {\n                    //Removed isBlazor code\n                    node1.offsetY = node.wrapper.offsetY;\n                }\n                if (this.diagramActions) {\n                    //Removed isBlazor code\n                    node1.width = node.wrapper.actualSize.width;\n                    node1.height = node.wrapper.actualSize.height;\n                }\n            }\n        }\n        if ((node) && node.annotations && node.annotations.length > 0) {\n            node.wrapper.children.forEach(function (wrapperChild) {\n                if (wrapperChild instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas) {\n                    wrapperChild.children.forEach(function (child) {\n                        if (child && child instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) {\n                            child.refreshTextElement();\n                        }\n                    });\n                }\n            });\n            node.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(node.width, node.height), node.id, this.onLoadImageSize.bind(this));\n            node.wrapper.arrange(node.wrapper.desiredSize);\n        }\n        if (isUpdateSize) {\n            if ((node.children && node.children.length > 0)) {\n                if (this.nameTable[node.id].width !== undefined) {\n                    this.scaleObject(node, this.nameTable[node.id].width, true);\n                }\n                else {\n                    //Removed isBlazor code\n                    this.nameTable[node.id].width = node.wrapper.actualSize.width;\n                }\n                if (this.nameTable[node.id].height !== undefined) {\n                    this.scaleObject(node, this.nameTable[node.id].height, false);\n                }\n                else {\n                    //Removed isBlazor code\n                    this.nameTable[node.id].height = node.wrapper.actualSize.height;\n                }\n            }\n        }\n        //Removed Blazor code\n    };\n    /* eslint-disable */\n    Diagram.prototype.initNode = function (obj, diagramId, group) {\n        var canvas = obj.initContainer();\n        var portContainer = new _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas();\n        var content;\n        if (!this.diagramSettings.inversedAlignment) {\n            canvas.inversedAlignment = false;\n        }\n        if (!canvas.children) {\n            canvas.children = [];\n        }\n        if (obj.children) {\n            canvas.measureChildren = false;\n            portContainer.id = obj.id + 'group_container';\n            // Bug 853721: Grid lines remain hidden when lane fill is set to transparent.\n            // Added below code to set swimlane fill while dragging from palette to diagram.\n            if (obj.shape && obj.shape.type === 'SwimLane') {\n                portContainer.style.fill = obj.style.fill;\n            }\n            else {\n                portContainer.style.fill = 'none';\n            }\n            portContainer.style.strokeColor = 'none';\n            portContainer.horizontalAlignment = 'Stretch';\n            portContainer.verticalAlignment = 'Stretch';\n            //EJ2-865476 - Issue with Pivot Point in group node during resizing\n            portContainer.pivot = obj.pivot;\n            canvas.style = obj.style;\n            canvas.padding.left = obj.padding.left;\n            canvas.padding.right = obj.padding.right;\n            canvas.padding.top = obj.padding.top;\n            canvas.padding.bottom = obj.padding.bottom;\n            portContainer.children = [];\n            portContainer.preventContainer = true;\n            if (obj.container) {\n                portContainer.relativeMode = 'Object';\n            }\n            if (obj.container && (obj.container.type === 'Grid')) {\n                for (var i = 0; i < obj.children.length; i++) {\n                    var childCollection = new _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas();\n                    var child = this.nameTable[obj.children[i]];\n                    childCollection.children = [];\n                    childCollection.children.push(child.wrapper);\n                    if (child) {\n                        canvas.addObject(child.wrapper, child.rowIndex, child.columnIndex, child.rowSpan, child.columnSpan);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < obj.children.length; i++) {\n                    if (this.nameTable[obj.children[i]]) {\n                        var child = this.nameTable[obj.children[i]];\n                        this.updateStackProperty(obj, child, i);\n                        canvas.children.push(child.wrapper);\n                        canvas.elementActions = canvas.elementActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ElementAction.ElementIsGroup;\n                        child.wrapper.flip = child.wrapper.flip ^=\n                            obj.wrapper.flip;\n                    }\n                }\n            }\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(obj.container) ||\n                (obj.container && (obj.container.type !== 'Grid'))) {\n                canvas.children.push(portContainer);\n            }\n        }\n        else {\n            var setNodeTemplate = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getFunction)(this.setNodeTemplate);\n            if (setNodeTemplate && obj.id !== 'helper') {\n                content = setNodeTemplate(obj, this);\n            }\n            if (!content) {\n                content = obj.init(this);\n            }\n            canvas.children.push(content);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var wrapperContent;\n        wrapperContent = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.getFunction)(this.getDescription);\n        if (wrapperContent) {\n            (obj.children ? canvas : content).description = wrapperContent;\n        }\n        else {\n            (obj.children ? canvas : content).description = obj.annotations.length ? obj.annotations[0].content : obj.id;\n        }\n        var container = obj.children ? portContainer : canvas;\n        obj.initAnnotations(this.getDescription, container, this.element.id, (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) ? true : false, this.annotationTemplate);\n        obj.initPorts(this.getDescription, container);\n        obj.initIcons(this.getDescription, this.layout, container, diagramId);\n        for (var i = 0; obj.fixedUserHandles !== undefined, i < obj.fixedUserHandles.length; i++) {\n            var fixedUserHandles = obj.initFixedUserHandles(obj.fixedUserHandles[i], this.fixedUserHandleTemplate, this.element.id);\n            container.children.push(fixedUserHandles);\n        }\n        if (obj.shape.type === 'SwimLane' && obj.wrapper && obj.wrapper.children.length > 0 &&\n            obj.wrapper.children[0] instanceof _core_containers_grid__WEBPACK_IMPORTED_MODULE_21__.GridPanel) {\n            this.setZIndex(this.activeLayer, obj);\n            if (this.connectors.length > 0) {\n                for (var i = 0; i < this.connectors.length; i++) {\n                    var obj_1 = this.connectors[i];\n                    if ((obj_1.sourceID && obj_1.targetID) && (this.activeLayer.objects.indexOf(obj_1.sourceID) === -1 &&\n                        this.activeLayer.objects.indexOf(obj_1.targetID) === -1)) {\n                        this.setZIndex(this.activeLayer, obj_1);\n                    }\n                }\n            }\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.swimLaneMeasureAndArrange)(obj);\n            (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.arrangeChildNodesInSwimLane)(this, obj);\n            this.updateDiagramElementQuad();\n        }\n        else {\n            canvas.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(obj.width, obj.height), obj.id, this.onLoadImageSize.bind(this));\n            if (canvas instanceof _core_containers_grid__WEBPACK_IMPORTED_MODULE_21__.GridPanel) {\n                canvas.arrange(canvas.desiredSize, true);\n            }\n            else {\n                canvas.arrange(canvas.desiredSize);\n            }\n        }\n        if (obj.wrapper.flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None) {\n            if (obj.children && obj.children.length > 0) {\n                for (var i = 0; i < obj.children.length; i++) {\n                    var node = this.nameTable[obj.children[i]];\n                    if (node) {\n                        if (!this.refreshing && !this.commandHandler.cloningInProgress && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n                            node.flip ^= obj.flip;\n                            node.flipMode = obj.flipMode;\n                        }\n                        if (node.flipMode !== 'None' && node.flipMode !== 'Label' && node.flipMode !== 'LabelText' && node.flipMode !== 'LabelAndLabelText') {\n                            this.updatePorts(node, node.flip);\n                        }\n                        else {\n                            this.updatePorts(node, _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None);\n                        }\n                        this.applyWrapperFlip(node);\n                        node.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(node.wrapper.bounds.width, node.wrapper.bounds.height), node.id, this.onLoadImageSize.bind(this));\n                        node.wrapper.arrange(node.wrapper.desiredSize);\n                    }\n                }\n                var groupWrapperCanvas = obj.wrapper.children[obj.wrapper.children.length - 1];\n                groupWrapperCanvas.flip = obj.wrapper.flip;\n                groupWrapperCanvas.flipMode = obj.wrapper.flipMode;\n                for (var j = 0; j < groupWrapperCanvas.children.length; j++) {\n                    var wrapperChild = groupWrapperCanvas.children[j];\n                    if (wrapperChild instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) {\n                        if (obj.flipMode !== 'Port' && obj.flipMode !== 'None') {\n                            wrapperChild.flip = obj.wrapper.flip;\n                            wrapperChild.flipMode = obj.wrapper.flipMode;\n                        }\n                    }\n                }\n                if (!this.refreshing && !this.commandHandler.cloningInProgress && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.alignElement)(obj.wrapper, obj.wrapper.offsetX, obj.wrapper.offsetY, this, obj.wrapper.flip, undefined, undefined, true);\n                }\n            }\n            else {\n                //To apply flip and flip mode for the text elements of node.\n                this.applyWrapperFlip(obj);\n            }\n        }\n        if (obj.shape.type === 'Bpmn') {\n            if (obj.shape.shape === 'TextAnnotation') {\n                var isbpmnTextConnector = false;\n                for (var i = 0; i < this.connectors.length; i++) {\n                    if (this.connectors[parseInt(i.toString(), 10)].id === (obj.id + \"_connector\")) {\n                        this.connectors[parseInt(i.toString(), 10)].isBpmnAnnotationConnector = true;\n                        isbpmnTextConnector = true;\n                        break;\n                    }\n                }\n                if (!isbpmnTextConnector) {\n                    this.addBpmnAnnotationConnector(obj, canvas);\n                }\n            }\n        }\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node && obj.container && (obj.width < canvas.outerBounds.width || obj.height < canvas.outerBounds.height) &&\n            canvas.bounds.x <= canvas.outerBounds.x && canvas.bounds.y <= canvas.outerBounds.y) {\n            obj.width = canvas.width = canvas.outerBounds.width;\n            obj.height = canvas.height = canvas.outerBounds.height;\n            canvas.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(obj.width, obj.height));\n            canvas.arrange(canvas.desiredSize);\n        }\n        if (obj.container && obj.container.type === 'Grid' && obj.children && obj.children.length > 0) {\n            this.updateChildPosition(obj);\n        }\n    };\n    Diagram.prototype.applyWrapperFlip = function (obj) {\n        obj.wrapper.flip = obj.flip;\n        obj.wrapper.flipMode = obj.flipMode;\n        obj.wrapper.children[0].flip = obj.flip;\n        obj.wrapper.children[0].flipMode = obj.flipMode;\n        for (var i = 0; i < obj.wrapper.children.length; i++) {\n            var wrapperChild = obj.wrapper.children[i];\n            if (wrapperChild instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas) {\n                //To update the flip and flipmode for the node wrapper childs.\n                this.applyWrapperCanvasFlip(wrapperChild, obj);\n            }\n            else {\n                wrapperChild.flip = obj.flip;\n                wrapperChild.flipMode = obj.flipMode;\n            }\n        }\n    };\n    Diagram.prototype.applyWrapperCanvasFlip = function (wrapper, obj) {\n        for (var i = 0; i < wrapper.children.length; i++) {\n            var wrapperChild = wrapper.children[parseInt(i.toString(), 10)];\n            if (wrapperChild instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas) {\n                this.applyWrapperCanvasFlip(wrapperChild, obj);\n            }\n            else if (obj.flipMode !== 'None') {\n                wrapperChild.flip = obj.flip;\n                wrapperChild.flipMode = obj.flipMode;\n            }\n        }\n    };\n    Diagram.prototype.addBpmnAnnotationConnector = function (node, wrapper) {\n        if (node.parentObj instanceof Diagram || node.parentObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Lane) {\n            var bpmnAnnotation = node.shape;\n            var direction = bpmnAnnotation.textAnnotation.textAnnotationDirection;\n            var hasTarget = (bpmnAnnotation.textAnnotation.textAnnotationTarget !== '' && this.nameTable[bpmnAnnotation.textAnnotation.textAnnotationTarget]);\n            var targetNode = hasTarget ? this.nameTable[bpmnAnnotation.textAnnotation.textAnnotationTarget] : null;\n            var targetWrapper = targetNode != null ? targetNode.wrapper : null;\n            var port = node.ports[0];\n            var sourcePoint = { x: 0, y: 0 };\n            switch (direction) {\n                case 'Left':\n                    port.offset = { x: 0, y: 0.5 };\n                    sourcePoint.x = wrapper.bounds.left - 40;\n                    sourcePoint.y = wrapper.bounds.bottom + 30;\n                    break;\n                case 'Right':\n                    port.offset = { x: 1, y: 0.5 };\n                    sourcePoint.x = wrapper.bounds.right + 40;\n                    sourcePoint.y = wrapper.bounds.bottom + 30;\n                    break;\n                case 'Top':\n                    port.offset = { x: 0.5, y: 0 };\n                    sourcePoint.x = wrapper.bounds.right + 30;\n                    sourcePoint.y = wrapper.bounds.top - 40;\n                    break;\n                case 'Bottom':\n                    port.offset = { x: 0.5, y: 1 };\n                    sourcePoint.x = wrapper.bounds.right + 30;\n                    sourcePoint.y = wrapper.bounds.bottom + 40;\n                    break;\n                default:\n                    port.offset = { x: 0, y: 0.5 };\n                    sourcePoint.x = wrapper.bounds.left - 40;\n                    sourcePoint.y = wrapper.bounds.bottom + 30;\n                    if (hasTarget && wrapper != null && targetWrapper != null) {\n                        if (wrapper.bounds.left > targetWrapper.bounds.right) {\n                            port.offset = { x: 0, y: 0.5 };\n                        }\n                        else if (wrapper.bounds.right < targetWrapper.bounds.left) {\n                            port.offset = { x: 1, y: 0.5 };\n                        }\n                        else if (wrapper.bounds.bottom > targetWrapper.bounds.top) {\n                            port.offset = { x: 0.5, y: 0 };\n                        }\n                        else if (wrapper.bounds.top < targetWrapper.bounds.bottom) {\n                            port.offset = { x: 0.5, y: 1 };\n                        }\n                    }\n                    break;\n            }\n            var connector = new _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector(this, 'connectors', {\n                id: node.id + \"_connector\",\n                targetID: node.id,\n                targetPortID: port.id,\n                type: 'Straight',\n                shape: {\n                    type: \"Bpmn\", flow: 'Association'\n                },\n                constraints: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ConnectorConstraints.Default & ~(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ConnectorConstraints.DragTargetEnd | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ConnectorConstraints.Delete),\n                isBpmnAnnotationConnector: true,\n            }, true);\n            if (hasTarget) {\n                connector.sourceID = bpmnAnnotation.textAnnotation.textAnnotationTarget;\n            }\n            else {\n                connector.sourcePoint = sourcePoint;\n            }\n            var oldProtectOnChange = this.isProtectedOnChange;\n            this.isProtectedOnChange = true;\n            node.constraints |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.InConnect;\n            this.connectors.push(connector);\n            if (!(this.bpmnModule).bpmnTextAnnotationConnector) {\n                (this.bpmnModule).bpmnTextAnnotationConnector = [];\n            }\n            (this.bpmnModule).bpmnTextAnnotationConnector.push(connector);\n            var shadowSet = (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Shadow) !== 0;\n            var allowMovingSet = (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.AllowMovingOutsideLane) !== 0;\n            node.constraints = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Default & ~(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.OutConnect | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.InConnect);\n            if (shadowSet) {\n                node.constraints |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Shadow;\n            }\n            if (allowMovingSet) {\n                node.constraints |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.AllowMovingOutsideLane;\n            }\n            this.isProtectedOnChange = oldProtectOnChange;\n        }\n    };\n    /** @private */\n    Diagram.prototype.getBPMNTextAnnotation = function (node, diagram, annotation, isDynamic) {\n        // create new text annotation node\n        var obj = {\n            id: annotation.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)(),\n            height: annotation.height || 100,\n            width: annotation.width || 100,\n            annotations: [{ id: (annotation.id ? annotation.id : (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)()) + annotation.text, content: annotation.text }],\n            offsetX: node.offsetX + annotation.length *\n                Math.cos(annotation.angle * (Math.PI / 180)),\n            offsetY: node.offsetY + annotation.length *\n                Math.sin(annotation.angle * (Math.PI / 180)),\n            shape: { type: 'Bpmn', shape: 'TextAnnotation', textAnnotation: { textAnnotationDirection: 'Auto', textAnnotationTarget: node.id } },\n            constraints: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Default & ~(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.OutConnect | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.InConnect)\n        };\n        var parentBounds = node.wrapper.bounds;\n        var position = { x: obj.offsetX, y: obj.offsetY };\n        var direction = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_48__.getPortDirection)(position, parentBounds, parentBounds, false);\n        var segment;\n        switch (direction) {\n            case 'Right':\n                segment = {\n                    x1: parentBounds.right, y1: parentBounds.top,\n                    x2: parentBounds.right, y2: parentBounds.bottom\n                };\n                break;\n            case 'Left':\n                segment = {\n                    x1: parentBounds.left, y1: parentBounds.top,\n                    x2: parentBounds.left, y2: parentBounds.bottom\n                };\n                break;\n            case 'Bottom':\n                segment = {\n                    x1: parentBounds.right, y1: parentBounds.bottom,\n                    x2: parentBounds.left, y2: parentBounds.bottom\n                };\n                break;\n            case 'Top':\n                segment = {\n                    x1: parentBounds.right, y1: parentBounds.top,\n                    x2: parentBounds.left, y2: parentBounds.top\n                };\n                break;\n        }\n        var center = parentBounds.center;\n        var endPoint = _primitives_point__WEBPACK_IMPORTED_MODULE_46__.Point.transform(position, annotation.angle, Math.max(parentBounds.width, parentBounds.height));\n        var point = (0,_utility_connector__WEBPACK_IMPORTED_MODULE_48__.getIntersectionPoints)(segment, [center, endPoint], false, center);\n        if (annotation.length !== undefined && annotation.angle !== undefined && point) {\n            point = _primitives_point__WEBPACK_IMPORTED_MODULE_46__.Point.transform(point, annotation.angle, annotation.length);\n            obj.offsetX = point.x;\n            obj.offsetY = point.y;\n        }\n        if (direction === 'Right') {\n            obj.offsetX += obj.width / 2;\n        }\n        else if (direction === 'Left') {\n            obj.offsetX -= obj.width / 2;\n        }\n        else if (direction === 'Bottom') {\n            obj.offsetY += obj.height / 2;\n        }\n        else {\n            obj.offsetY -= obj.height / 2;\n        }\n        if (isDynamic) {\n            this.add(obj);\n        }\n        else {\n            var bpmnTextNode = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node(this, 'nodes', obj, true);\n            diagram.initObject(bpmnTextNode, undefined, undefined, true);\n            diagram.nodes.push(bpmnTextNode);\n        }\n    };\n    /* eslint-enable */\n    /**\n     * updateDiagramElementQuad method \\\n     *\n     * @returns { void }     updateDiagramElementQuad method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.updateDiagramElementQuad = function () {\n        for (var i = 0; i < this.nodes.length; i++) {\n            if (this.nodes[parseInt(i.toString(), 10)].wrapper && (this.nodes[parseInt(i.toString(), 10)].wrapper instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_6__.Container)) {\n                this.updateQuad(this.nodes[parseInt(i.toString(), 10)]);\n            }\n        }\n    };\n    Diagram.prototype.onLoadImageSize = function (id, size) {\n        var obj = this.getObject(id);\n        var image = document.getElementById(id + 'sf-imageNode');\n        if (image) {\n            image.parentNode.removeChild(image);\n        }\n        this.nodePropertyChange(obj, {}, { width: size.width, height: size.height });\n        var args = { element: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(obj), size: size };\n        this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.onImageLoad, args);\n    };\n    Diagram.prototype.updateChildPosition = function (obj) {\n        for (var i = 0; i < obj.children.length; i++) {\n            var child = this.getObject(obj.children[parseInt(i.toString(), 10)]);\n            child.offsetX = child.wrapper.offsetX;\n            child.offsetY = child.wrapper.offsetY;\n            if (child.children && child.children.length > 0) {\n                this.updateChildPosition(child);\n            }\n        }\n    };\n    Diagram.prototype.canExecute = function () {\n        return true;\n    };\n    Diagram.prototype.updateStackProperty = function (obj, child, index) {\n        if (obj.container && obj.container.type === 'Stack') {\n            if (!child.width) {\n                child.wrapper.horizontalAlignment = 'Stretch';\n                child.horizontalAlignment = 'Stretch';\n            }\n            if (!child.height) {\n                child.verticalAlignment = 'Stretch';\n                child.wrapper.verticalAlignment = 'Stretch';\n            }\n            if (index && obj.shape.type === 'UmlClassifier') {\n                child.umlIndex = index;\n            }\n        }\n    };\n    Diagram.prototype.initViews = function () {\n        if (!this.isLoading) {\n            this.views.push(this.element.id);\n            this.views[this.element.id] = this;\n        }\n    };\n    Diagram.prototype.initCommands = function () {\n        var i;\n        var newCommands = this.commandManager.commands;\n        var commands = {\n            'copy': {\n                execute: this.copyCommand.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.C, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'paste': {\n                execute: this.pasteCommand.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.V, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'cut': {\n                execute: this.cutCommand.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.X, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'delete': {\n                execute: this.removeCommand.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Delete }\n            },\n            'selectAll': {\n                execute: this.selectAll.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.A, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'undo': {\n                execute: this.undo.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Z, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'redo': {\n                execute: this.redo.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Y, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'nudgeUp': {\n                execute: this.nudgeCommand.bind(this, 'Up'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Up },\n                parameter: 'up'\n            },\n            'nudgeRight': {\n                execute: this.nudgeCommand.bind(this, 'Right'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Right },\n                parameter: 'right'\n            },\n            'nudgeDown': {\n                execute: this.nudgeCommand.bind(this, 'Down'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Down },\n                parameter: 'down'\n            },\n            'nudgeLeft': {\n                execute: this.nudgeCommand.bind(this, 'Left'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Left },\n                parameter: 'left'\n            },\n            'startEdit': {\n                execute: this.startEditCommad.bind(this),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.F2 }\n            },\n            'endEdit': {\n                execute: this.endEditCommand.bind(this),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Escape }\n            },\n            //EJ2-866418-keyboard shortcut keys\n            'focusToNextItem': {\n                execute: this.navigateItems.bind(this, true),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Tab }\n            },\n            'focusToPreviousItem': {\n                execute: this.navigateItems.bind(this, false), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Tab, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'selectFocusedItem': {\n                execute: this.startEditCommad.bind(this),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Enter }\n            },\n            'bold': {\n                execute: this.fontStyleCommand.bind(this, 'bold'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.B, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'italic': {\n                execute: this.fontStyleCommand.bind(this, 'italic'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.I, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'underline': {\n                execute: this.fontStyleCommand.bind(this, 'underline'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.U, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'duplicate': {\n                execute: this.duplicateCommand.bind(this), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.D, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'group': {\n                execute: this.groupCommand.bind(this, 'group'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.G, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'ungroup': {\n                execute: this.groupCommand.bind(this, 'ungroup'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.U, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'rotateClockwise': {\n                execute: this.rotateCommand.bind(this, 'clockwise'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.R, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'rotateAntiClockwise': {\n                execute: this.rotateCommand.bind(this, 'antiClockwise'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.L, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'flipHorizontal': {\n                execute: this.flipCommand.bind(this, 'horizontal'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.H, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'flipVertical': {\n                execute: this.flipCommand.bind(this, 'vertical'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.J, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'pointerTool': {\n                execute: this.toolCommand.bind(this, 'pointer'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Number1, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'textTool': {\n                execute: this.toolCommand.bind(this, 'text'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Number2, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'connectTool': {\n                execute: this.toolCommand.bind(this, 'connect'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Number3, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'freeForm': {\n                execute: this.toolCommand.bind(this, 'freeForm'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Number5, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'lineTool': {\n                execute: this.toolCommand.bind(this, 'line'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Number6, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'rectangleTool': {\n                execute: this.toolCommand.bind(this, 'rectangle'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Number8, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'ellipseTool': {\n                execute: this.toolCommand.bind(this, 'ellipse'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Number9, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'zoomIn': {\n                execute: this.zoomCommand.bind(this, 'zoomIn'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Plus, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'zoomOut': {\n                execute: this.zoomCommand.bind(this, 'zoomOut'), canExecute: this.canExecute.bind(this),\n                gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Minus, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'shiftUp': {\n                execute: this.shiftCommand.bind(this, 'Up'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Up, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'shiftDown': {\n                execute: this.shiftCommand.bind(this, 'Down'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Down, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'shiftLeft': {\n                execute: this.shiftCommand.bind(this, 'Left'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Left, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'shiftRight': {\n                execute: this.shiftCommand.bind(this, 'Right'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.Right, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'alignTextCenter': {\n                execute: this.alignCommand.bind(this, 'center'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.C, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'alignTextLeft': {\n                execute: this.alignCommand.bind(this, 'right'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.L, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'alignTextRight': {\n                execute: this.alignCommand.bind(this, 'left'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.R, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'alignTextTop': {\n                execute: this.alignCommand.bind(this, 'top'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.E, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'alignTextCenterVertical': {\n                execute: this.alignCommand.bind(this, 'centerVertical'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.M, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'alignTextBottom': {\n                execute: this.alignCommand.bind(this, 'bottom'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.V, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'alignJustify': {\n                execute: this.alignCommand.bind(this, 'justify'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.J, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'sendToBack': {\n                execute: this.orderCommand.bind(this, 'sendToBack'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.B, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'bringToFront': {\n                execute: this.orderCommand.bind(this, 'bringToFront'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.F, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Shift }\n            },\n            'sendBackward': {\n                execute: this.orderCommand.bind(this, 'sendBackward'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.BracketLeft, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            },\n            'bringForward': {\n                execute: this.orderCommand.bind(this, 'bringForward'),\n                canExecute: this.canExecute.bind(this), gesture: { key: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.Keys.BracketRight, keyModifiers: _enum_enum__WEBPACK_IMPORTED_MODULE_14__.KeyModifiers.Control }\n            }\n        };\n        this.initCommandManager(newCommands, commands);\n    };\n    Diagram.prototype.overrideCommands = function (newCommand, commands) {\n        var command;\n        for (var _i = 0, _a = Object.keys(commands); _i < _a.length; _i++) {\n            var key = _a[_i];\n            command = commands[\"\" + key];\n            if (newCommand.gesture.key === command.gesture.key && newCommand.gesture.keyModifiers === command.gesture.keyModifiers) {\n                delete commands[\"\" + key];\n                break;\n            }\n        }\n    };\n    Diagram.prototype.initCommandManager = function (newCommands, commands) {\n        var i = 0;\n        if (newCommands) {\n            for (i = 0; i < newCommands.length; i++) {\n                if (commands[newCommands[parseInt(i.toString(), 10)].name] && newCommands[parseInt(i.toString(), 10)]) {\n                    if (newCommands[parseInt(i.toString(), 10)].canExecute) {\n                        commands[newCommands[parseInt(i.toString(), 10)].name].canExecute\n                            = newCommands[parseInt(i.toString(), 10)].canExecute;\n                    }\n                    if (newCommands[parseInt(i.toString(), 10)].execute) {\n                        commands[newCommands[parseInt(i.toString(), 10)].name].execute\n                            = newCommands[parseInt(i.toString(), 10)].execute;\n                    }\n                    if (newCommands[parseInt(i.toString(), 10)].gesture.key\n                        || newCommands[parseInt(i.toString(), 10)].gesture.keyModifiers) {\n                        commands[newCommands[parseInt(i.toString(), 10)].name].gesture\n                            = newCommands[parseInt(i.toString(), 10)].gesture;\n                    }\n                    if (newCommands[parseInt(i.toString(), 10)].parameter !== '') {\n                        commands[newCommands[parseInt(i.toString(), 10)].name].parameter\n                            = newCommands[parseInt(i.toString(), 10)].parameter;\n                    }\n                }\n                else {\n                    this.overrideCommands(newCommands[parseInt(i.toString(), 10)], commands);\n                    commands[newCommands[parseInt(i.toString(), 10)].name] = {\n                        execute: newCommands[parseInt(i.toString(), 10)].execute,\n                        canExecute: newCommands[parseInt(i.toString(), 10)].canExecute,\n                        gesture: newCommands[parseInt(i.toString(), 10)].gesture,\n                        parameter: newCommands[parseInt(i.toString(), 10)].parameter\n                    };\n                }\n            }\n        }\n        this.commands = commands;\n    };\n    /**\n     * updateNodeEdges method \\\n     *\n     * @returns { void }     updateNodeEdges method .\\\n     * @param {Node} node - provide the source value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateNodeEdges = function (node) {\n        for (var _i = 0, _a = node.inEdges; _i < _a.length; _i++) {\n            var edge = _a[_i];\n            if (this.nameTable[\"\" + edge]) {\n                this.nameTable[\"\" + edge].targetID = '';\n            }\n        }\n        for (var _b = 0, _c = node.outEdges; _b < _c.length; _b++) {\n            var edge = _c[_b];\n            if (this.nameTable[\"\" + edge]) {\n                this.nameTable[\"\" + edge].sourceID = '';\n            }\n        }\n        node.inEdges = [];\n        node.outEdges = [];\n    };\n    /**\n     * updateIconVisibility method \\\n     *\n     * @returns { void }     updateIconVisibility method .\\\n     * @param {Node} node - provide the source value.\n     * @param {boolean} visibility - provide the source value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateIconVisibility = function (node, visibility) {\n        for (var i = 0; i < node.wrapper.children.length; i++) {\n            var child = node.wrapper.children[parseInt(i.toString(), 10)];\n            if (child.id) {\n                var id = child.id.split(node.id)[1];\n                if (id && id.match('^_icon')) {\n                    child.visible = visibility;\n                    this.updateDiagramContainerVisibility(child, visibility);\n                }\n            }\n        }\n    };\n    /**\n     * updateEdges method \\\n     *\n     * @returns { void }     updateEdges method .\\\n     * @param {Connector} obj - provide the source value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateEdges = function (obj) {\n        if (obj.sourceID !== undefined && obj.sourceID !== '') {\n            var object = this.nameTable[obj.sourceID];\n            if (object && object.outEdges && object.outEdges.length === 0) {\n                object.outEdges = [];\n            }\n            if (object && object.outEdges && object.outEdges.indexOf(obj.id) === -1) {\n                object.outEdges.push(obj.id);\n            }\n            this.updatePortEdges(object, obj, false);\n        }\n        if (obj.targetID !== undefined && obj.targetID !== '') {\n            var node = this.nameTable[obj.targetID];\n            if (node && node.inEdges && node.inEdges.length === 0) {\n                node.inEdges = [];\n            }\n            if (node && node.inEdges && node.inEdges.indexOf(obj.id) === -1) {\n                node.inEdges.push(obj.id);\n            }\n            this.updatePortEdges(node, obj, true);\n            if (node && node.visible && node.outEdges) {\n                var value = node.outEdges.length === 0 ? false : true;\n                this.updateIconVisibility(node, value);\n            }\n        }\n    };\n    /**\n     * updatePortEdges method \\\n     *\n     * @returns { void }     updatePortEdges method .\\\n     * @param {NodeModel} node - provide the source value.\n     * @param {ConnectorModel} obj - provide the target value.\n     * @param {boolean} isInEdges - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    Diagram.prototype.updatePortEdges = function (node, obj, isInEdges) {\n        if (node) {\n            for (var i = 0; i < node.ports.length; i++) {\n                var port = node.ports[parseInt(i.toString(), 10)];\n                var portId = (isInEdges) ? obj.targetPortID : obj.sourcePortID;\n                if (port.id === portId) {\n                    var portEdges = (isInEdges) ? port.inEdges : port.outEdges;\n                    if (portEdges.indexOf(obj.id) === -1) {\n                        portEdges.push(obj.id);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * refreshDiagram method \\\n     *\n     * @returns { void }     refreshDiagram method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.refreshDiagram = function () {\n        this.initLayerObjects();\n        this.doLayout();\n        this.updateBridging();\n        this.scroller.setSize();\n        this.addBlazorDiagramObjects();\n        //Removed isBlazor code\n        this.updateFitToPage();\n    };\n    Diagram.prototype.updateCanupdateStyle = function (element, value) {\n        for (var j = 0; j < element.length; j++) {\n            if (element[parseInt(j.toString(), 10)].children) {\n                this.updateCanupdateStyle(element[parseInt(j.toString(), 10)].children, value);\n            }\n            element[parseInt(j.toString(), 10)].canApplyStyle = value;\n        }\n    };\n    Diagram.prototype.getZindexPosition = function (obj, viewId) {\n        var objects = [];\n        var index = undefined;\n        objects = objects.concat(this.nodes);\n        objects = objects.concat(this.connectors);\n        var type;\n        var greaterIndex;\n        if (obj.children) {\n            greaterIndex = this.commandHandler.findMaxZIndex(obj);\n        }\n        else {\n            greaterIndex = obj.zIndex;\n        }\n        if (obj.zIndex !== Number.MIN_VALUE) {\n            for (var i = 0; i < objects.length; i++) {\n                if (objects[parseInt(i.toString(), 10)].zIndex > greaterIndex) {\n                    if (obj.shape.type === 'HTML' || obj.shape.type === 'Native') {\n                        type = obj.shape.type === 'HTML' ? 'html' : 'native';\n                    }\n                    index = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDomIndex)(viewId, objects[parseInt(i.toString(), 10)].id, type);\n                    break;\n                }\n            }\n        }\n        return index;\n    };\n    /**\n     *updateDiagramObject method \\\n     *\n     * @returns { void } updateDiagramObject method .\\\n     * @param { (NodeModel | ConnectorModel) } obj - provide the obj value.\n     * @param { boolean } canIgnoreIndex - provide the canIgnoreIndex value.\n     * @param { boolean } isUpdateObject - provide the isUpdateObject value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateDiagramObject = function (obj, canIgnoreIndex, isUpdateObject) {\n        var view;\n        var domTable = 'domTable';\n        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            view = this.views[\"\" + temp];\n            if (this.diagramActions) {\n                if (view.mode === 'SVG') {\n                    var hasLayers = this.layers.length > 1;\n                    var layer = void 0;\n                    if (hasLayers) {\n                        layer = this.commandHandler.getObjectLayer(obj.id);\n                    }\n                    if ((layer === undefined || (layer && layer.visible)) || isUpdateObject) {\n                        var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getHTMLLayer)(this.element.id);\n                        if (!window[\"\" + domTable][view.element.id + '_diagramLayer']) {\n                            window[\"\" + domTable][view.element.id + '_diagramLayer'] =\n                                document.getElementById(view.element.id + '_diagramLayer');\n                        }\n                        var diagramElementsLayer = window[\"\" + domTable][view.element.id + '_diagramLayer'];\n                        if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Interactions) {\n                            this.updateCanupdateStyle(obj.wrapper.children, true);\n                        }\n                        var centerPoint = this.getMidPoint(obj);\n                        this.diagramRenderer.updateNode(obj.wrapper, diagramElementsLayer, htmlLayer, undefined, canIgnoreIndex ? undefined : this.getZindexPosition(obj, view.element.id), centerPoint, this.portCenterPoint);\n                        this.updateCanupdateStyle(obj.wrapper.children, true);\n                    }\n                }\n            }\n        }\n    };\n    //Method used to apply margin for Bezier Curve points.\n    Diagram.prototype.applyMarginBezier = function (obj, centerPoint) {\n        centerPoint.cx = centerPoint.cx + obj.margin.left;\n        centerPoint.cx = centerPoint.cx - obj.margin.right;\n        centerPoint.cy = centerPoint.cy + obj.margin.top;\n        centerPoint.cy = centerPoint.cy - obj.margin.bottom;\n    };\n    //Method used to get mid point of Bezier Curve\n    Diagram.prototype.getMidPoint = function (obj) {\n        var finalPoint;\n        if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && obj.type === 'Bezier') {\n            finalPoint = [];\n            var totalPoints = this.getBezierPoints(obj);\n            var totalLength = _primitives_point__WEBPACK_IMPORTED_MODULE_46__.Point.getLengthFromListOfPoints(totalPoints);\n            // Bug 905077: Fixed improper positioning of multiple annotations for Bezier connectors.\n            // Iterated through annotations and ports to correctly determine their positions.\n            for (var i = 0; i < obj.annotations.length; i++) {\n                var centerPoint = obj.annotations[parseInt(i.toString(), 10)].offset;\n                var absoluteLength = centerPoint * totalLength;\n                var position = this.commandHandler.getPointAtLength(absoluteLength, totalPoints, 0);\n                var annotationPosition = { cx: position.x, cy: position.y };\n                // EJ2-64114 -Horizontal and Vertical alignment not applied properly for the bezier connector annotation\n                for (var j = 0; j < obj.wrapper.children.length; j++) {\n                    if (obj.wrapper && obj.wrapper.children[parseInt(j.toString(), 10)] instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) {\n                        if (obj.wrapper.children[parseInt(j.toString(), 10)].id === obj.id + '_' + obj.annotations[parseInt(i.toString(), 10)].id) {\n                            this.applyMarginBezier(obj.wrapper.children[parseInt(j.toString(), 10)], annotationPosition);\n                            finalPoint[obj.id + '_' + obj.annotations[parseInt(i.toString(), 10)].id] =\n                                this.applyAlignment(obj.wrapper.children[parseInt(j.toString(), 10)], annotationPosition, obj.annotations[parseInt(i.toString(), 10)].displacement);\n                        }\n                    }\n                }\n            }\n            // Bug 835525: Connector Port feature. Below code is used to get the port position for bezier connector.\n            for (var i = 0; i < obj.ports.length; i++) {\n                var portOffset = obj.ports[parseInt(i.toString(), 10)].offset;\n                var length_1 = portOffset * totalLength;\n                var portPosition = this.commandHandler.getPointAtLength(length_1, totalPoints, 0);\n                var portPoint = { cx: portPosition.x, cy: portPosition.y };\n                for (var j = 0; j < obj.wrapper.children.length; j++) {\n                    if (obj.wrapper && obj.wrapper.children[parseInt(j.toString(), 10)] instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_15__.PathElement &&\n                        obj.wrapper.children[parseInt(j.toString(), 10)].isPathPort) {\n                        if (obj.wrapper.children[parseInt(j.toString(), 10)].id === obj.id + '_' + obj.ports[parseInt(i.toString(), 10)].id) {\n                            this.applyMarginBezier(obj.wrapper.children[parseInt(j.toString(), 10)], portPoint);\n                            this.portCenterPoint[obj.id + '_' + obj.ports[parseInt(i.toString(), 10)].id] =\n                                this.applyAlignment(obj.wrapper.children[parseInt(j.toString(), 10)], portPoint, obj.ports[parseInt(i.toString(), 10)].displacement);\n                        }\n                    }\n                }\n            }\n        }\n        return finalPoint;\n    };\n    /**\n     * Apply alignment to bezier port\n     * @returns {PointModel} return the port alignment points\n     * @param {PathElement | TextElement} child - provide the obj value.\n     * @param {any} finalPoint - provide final point value.\n     * @param {PointModel} displacement - provide displacement value.\n     */\n    Diagram.prototype.applyAlignment = function (child, finalPoint, displacement) {\n        switch (child.horizontalAlignment) {\n            case 'Auto':\n            case 'Left':\n                finalPoint.cx = child.inversedAlignment ? finalPoint.cx : (finalPoint.cx - child.desiredSize.width);\n                finalPoint.cx += displacement.x;\n                break;\n            case 'Stretch':\n            case 'Center':\n                finalPoint.cx -= child.desiredSize.width * child.pivot.x;\n                break;\n            case 'Right':\n                finalPoint.cx = child.inversedAlignment ? (finalPoint.cx - child.desiredSize.width) : finalPoint.cx;\n                finalPoint.cx -= displacement.x;\n                break;\n        }\n        switch (child.verticalAlignment) {\n            case 'Auto':\n            case 'Top':\n                finalPoint.cy = child.inversedAlignment ? finalPoint.cy : (finalPoint.cy - child.desiredSize.height);\n                finalPoint.cy += displacement.y;\n                break;\n            case 'Stretch':\n            case 'Center':\n                finalPoint.cy -= child.desiredSize.height * child.pivot.y;\n                break;\n            case 'Bottom':\n                finalPoint.cy = child.inversedAlignment ? (finalPoint.cy - child.desiredSize.height) : finalPoint.cy;\n                finalPoint.cy -= displacement.y;\n                break;\n        }\n        return finalPoint;\n    };\n    //(EJ2-62683) Method used to get total points in bezier connector\n    Diagram.prototype.getBezierPoints = function (obj) {\n        var points = [];\n        var i;\n        var source = { x: obj.sourcePoint.x, y: obj.sourcePoint.y };\n        points.push(source);\n        for (i = 0; i < obj.segments.length; i++) {\n            var total = obj.segments[parseInt(i.toString(), 10)].getPoints(obj.segments[parseInt(i.toString(), 10)], source);\n            // 878719: Resolve ESLint errors\n            // eslint-disable-next-line prefer-spread\n            points.push.apply(points, total);\n            source = points[points.length - 1];\n        }\n        return points;\n    };\n    /**\n     *updateGridContainer method \\\n     *\n     * @returns { void } updateGridContainer method .\\\n     * @param { GridPanel } grid - provide the objectArray value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateGridContainer = function (grid) {\n        var view;\n        var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getHTMLLayer)(this.element.id);\n        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            view = this.views[\"\" + temp];\n            if (view.mode === 'SVG' && this.diagramActions) {\n                var diagramElementsLayer = document.getElementById(view.element.id + '_diagramLayer');\n                this.diagramRenderer.updateNode(grid, diagramElementsLayer, htmlLayer, undefined);\n            }\n            else {\n                this.refreshCanvasDiagramLayer(view);\n            }\n        }\n    };\n    /**\n     *Retrieves the node or connector with the given id. \\\n     *\n     * @returns { (NodeModel | ConnectorModel)[] } Retrieves the node or connector with the given id.\\\n     * @param { string[] } objectArray - The id of the node or connector to be retrieved.\n     *\n     * @private\n     */\n    Diagram.prototype.getObjectsOfLayer = function (objectArray) {\n        var nodeArray = [];\n        for (var _i = 0, objectArray_1 = objectArray; _i < objectArray_1.length; _i++) {\n            var obj = objectArray_1[_i];\n            if (this.nameTable[\"\" + obj]) {\n                nodeArray.push(this.nameTable[\"\" + obj]);\n            }\n        }\n        return nodeArray;\n    };\n    /**\n     *refreshDiagramLayer method \\\n     *\n     * @returns { void } refreshDiagramLayer method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.refreshDiagramLayer = function () {\n        var view;\n        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            view = this.views[\"\" + temp];\n            switch (view.mode) {\n                case 'SVG':\n                    this.refreshSvgDiagramLayer(view);\n                    break;\n                case 'Canvas':\n                    this.refreshCanvasLayers(view);\n                    break;\n            }\n        }\n    };\n    /**\n     *refreshCanvasLayers method \\\n     *\n     * @returns { void } refreshCanvasLayers method .\\\n     * @param { View } view - provide the view value.\n     *\n     * @private\n     */\n    Diagram.prototype.refreshCanvasLayers = function (view) {\n        if (!view) {\n            for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n                var temp = _a[_i];\n                var view_1 = this.views[\"\" + temp];\n                this.refreshCanvasDiagramLayer(view_1);\n            }\n        }\n        else {\n            this.refreshCanvasDiagramLayer(view);\n        }\n    };\n    Diagram.prototype.renderBasicElement = function (view) {\n        var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getHTMLLayer)(view.element.id);\n        for (var i = 0; i < this.basicElements.length; i++) {\n            var element = this.basicElements[parseInt(i.toString(), 10)];\n            if (element instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_6__.Container) {\n                element.prevRotateAngle = 0;\n            }\n            element.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(element.width, element.height));\n            element.arrange(element.desiredSize);\n            view.diagramRenderer.renderElement(element, view.diagramLayer, htmlLayer);\n        }\n    };\n    Diagram.prototype.refreshElements = function (view) {\n        var isOverView = false;\n        if (!this.isDestroyed) {\n            this.clearCanvas(view);\n            if (view instanceof Diagram) {\n                view.diagramLayer.getContext('2d').setTransform(view.scroller.currentZoom, 0, 0, view.scroller.currentZoom, 0, 0);\n                view.diagramLayer.getContext('2d').scale(1.5, 1.5);\n            }\n            else {\n                isOverView = true;\n                var element = document.getElementById(view.element.id + '_nativeLayer');\n                if (element.children.length > 0) {\n                    view.updateView(view);\n                }\n            }\n            var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getHTMLLayer)(view.element.id);\n            //const bounds: Rect = this.spatialSearch.getPageBounds();\n            this.renderDiagramElements(view.diagramLayer, view.diagramRenderer, htmlLayer, undefined, undefined, isOverView);\n            for (var i = 0; i < this.basicElements.length; i++) {\n                var element = this.basicElements[parseInt(i.toString(), 10)];\n                element.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(element.width, element.height));\n                element.arrange(element.desiredSize);\n                view.diagramRenderer.renderElement(element, view.diagramLayer, htmlLayer);\n            }\n            if (view instanceof Diagram) {\n                view.diagramLayer.style.transform = 'scale(' + (2 / 3) + ')';\n                view.diagramLayer.style.transformOrigin = '0 0';\n            }\n            this.renderTimer = null;\n        }\n    };\n    /**\n     *refreshCanvasDiagramLayer method \\\n     *\n     * @returns { void } refreshCanvasDiagramLayer method .\\\n     * @param { View } view - provide the view value.\n     *\n     * @private\n     */\n    Diagram.prototype.refreshCanvasDiagramLayer = function (view) {\n        var _this = this;\n        if (view.mode !== 'SVG' && !this.isDestroyed) {\n            if (this.basicElements.length > 0) {\n                this.renderBasicElement(view);\n            }\n            if ((!this.diagramActions || (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) === 0)\n                || (_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction & this.diagramActions) || (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) || (this.scroller.currentZoom !== 1)) {\n                this.refreshElements(view);\n            }\n            else if (!this.renderTimer) {\n                this.renderTimer = setTimeout(function () {\n                    _this.refreshElements(view);\n                }, 40);\n            }\n        }\n    };\n    /**\n     *updatePortVisibility method \\\n     *\n     * @returns { void } updatePortVisibility method .\\\n     * @param { Node } obj - provide the node value.\n     * @param { PortVisibility } portVisibility - provide the portVisibility value.\n     * @param { Boolean } inverse - provide the inverse value.\n     *\n     * @private\n     */\n    Diagram.prototype.updatePortVisibility = function (obj, portVisibility, inverse) {\n        var portElement;\n        var drawingObject = !(this.drawingObject && this.drawingObject.shape) ? true : false;\n        if ((obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node || obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) && drawingObject && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMove)(obj)) {\n            var ports = obj.ports;\n            var changed = false;\n            for (var i = 0; i < ports.length; i++) {\n                portElement = this.getWrapper(obj.wrapper, ports[parseInt(i.toString(), 10)].id);\n                if ((portVisibility & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortVisibility.Hover || portVisibility & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortVisibility.Connect)) {\n                    if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.checkPortRestriction)(ports[parseInt(i.toString(), 10)], portVisibility)) {\n                        portElement.visible = !inverse;\n                        changed = true;\n                    }\n                }\n            }\n            if (changed) {\n                this.updateDiagramObject(obj);\n            }\n            //EJ2-59672 - Added the below code to render the ports while hovering over the node\n            if (this.mode === 'Canvas') {\n                this.refreshCanvasLayers();\n            }\n        }\n    };\n    /**\n     *refreshSvgDiagramLayer method \\\n     *\n     * @returns { void } refreshSvgDiagramLayer method .\\\n     * @param { View } view - provide the object value.\n     *\n     * @private\n     */\n    Diagram.prototype.refreshSvgDiagramLayer = function (view) {\n        var element;\n        var diagramElementsLayer = document.getElementById(view.element.id + '_diagramLayer');\n        var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getHTMLLayer)(view.element.id);\n        if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this)) {\n            for (var i = 0; i < this.basicElements.length; i++) {\n                element = this.basicElements[parseInt(i.toString(), 10)];\n                element.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(element.width, element.height));\n                element.arrange(element.desiredSize, (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) ? true : false));\n                this.diagramRenderer.renderElement(element, diagramElementsLayer, htmlLayer);\n            }\n            this.renderDiagramElements(diagramElementsLayer, this.diagramRenderer, htmlLayer);\n        }\n        else {\n            this.scroller.virtualizeElements();\n        }\n    };\n    /**\n     *removeVirtualObjects method \\\n     *\n     * @returns { void } removeVirtualObjects method .\\\n     * @param { Object } clearIntervalVal - provide the object value.\n     *\n     * @private\n     */\n    Diagram.prototype.removeVirtualObjects = function (clearIntervalVal) {\n        if (this.deleteVirtualObject) {\n            for (var i = 0; i < this.scroller.removeCollection.length; i++) {\n                var obj = this.nameTable[this.scroller.removeCollection[parseInt(i.toString(), 10)]];\n                //EJ2-840437 - Exception occurs When Removing connector with Virtualization Enabled\n                if (obj !== undefined) {\n                    this.removeElements(obj);\n                }\n            }\n            this.deleteVirtualObject = false;\n        }\n        clearInterval(clearIntervalVal);\n    };\n    /**\n     *updateTextElementValue method \\\n     *\n     * @returns { void } updateTextElementValue method .\\\n     * @param {  NodeModel | ConnectorModel } object - provide the object value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateTextElementValue = function (object) {\n        for (var j = 0; j < object.wrapper.children.length; j++) {\n            var element = object.wrapper.children[parseInt(j.toString(), 10)];\n            if (element instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) {\n                element.canMeasure = true;\n                //866384-Annotation Alignment is wrong when virtualisation constraints enabled\n                var viewPortHeight = this.scroller.viewPortHeight;\n                var viewPortWidth = this.scroller.viewPortWidth;\n                var measureText = false;\n                if (object.offsetX < viewPortWidth && object.offsetY < viewPortHeight) {\n                    measureText = true;\n                }\n                if (measureText && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) && element.actualSize.height === undefined\n                    && element.actualSize.width === undefined) {\n                    object.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(object.width, object.height), object.id, this.onLoadImageSize.bind(this));\n                    object.wrapper.arrange(object.wrapper.desiredSize);\n                }\n                element.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(object.width, object.height));\n                element.arrange(element.desiredSize);\n            }\n        }\n    };\n    /**\n     *updateVirtualObjects method \\\n     *\n     * @returns { void } updateVirtualObjects method .\\\n     * @param { string[] } collection - provide the collection value.\n     * @param { boolean } remove - provide the remove value.\n     * @param { string[] } tCollection - provide the htmlLayer value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateVirtualObjects = function (collection, remove, tCollection) {\n        var diagramElementsLayer = document.getElementById(this.element.id + '_diagramLayer');\n        var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getHTMLLayer)(this.element.id);\n        if (this.mode === 'SVG') {\n            for (var i = 0; i < collection.length; i++) {\n                var index = this.scroller.removeCollection.indexOf(collection[parseInt(i.toString(), 10)]);\n                if (index >= 0) {\n                    this.scroller.removeCollection.splice(index, 1);\n                }\n                var object = this.nameTable[collection[parseInt(i.toString(), 10)]];\n                this.updateTextElementValue(object);\n                this.diagramRenderer.renderElement(object.wrapper, diagramElementsLayer, htmlLayer, undefined, undefined, undefined, undefined, object.zIndex);\n            }\n            for (var k = 0; k < tCollection.length; k++) {\n                this.scroller.removeCollection.push(tCollection[parseInt(k.toString(), 10)]);\n            }\n            if (this.scroller.currentZoom !== 1) {\n                this.eventHandler.updateVirtualization();\n            }\n        }\n        else if (this.diagramActions) {\n            this.refreshDiagramLayer();\n        }\n    };\n    /**\n     *renderDiagramElements method \\\n     *\n     * @returns { void } renderDiagramElements method .\\\n     * @param { HTMLCanvasElement | SVGElement} canvas - provide the canvas value.\n     * @param { DiagramRenderer } renderer - provide the renderer value.\n     * @param { HTMLElement } htmlLayer - provide the htmlLayer value.\n     * @param {boolean } transform - provide the transform value.\n     * @param {boolean } fromExport - provide the fromExport value.\n     * @param { boolean } isOverView - provide the isOverView value.\n     *\n     * @private\n     */\n    Diagram.prototype.renderDiagramElements = function (canvas, renderer, htmlLayer, transform, fromExport, isOverView) {\n        if (transform === void 0) { transform = true; }\n        var pageBounds = this.scroller.getPageBounds();\n        pageBounds.x *= this.scroller.currentZoom;\n        pageBounds.y *= this.scroller.currentZoom;\n        pageBounds.width *= this.scroller.currentZoom;\n        pageBounds.height *= this.scroller.currentZoom;\n        var difX = -this.scroller.horizontalOffset - pageBounds.x;\n        var difY = -this.scroller.verticalOffset - pageBounds.y;\n        var getCenterPoint;\n        for (var _i = 0, _a = Object.keys(this.layerZIndexTable); _i < _a.length; _i++) {\n            var layerId = _a[_i];\n            var layer = this.commandHandler.getLayer(this.layerZIndexTable[\"\" + layerId]);\n            var left = void 0;\n            var top_1 = void 0;\n            if (this.mode === 'Canvas' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) && !this.diagramActions) {\n                this.scroller.virtualizeElements();\n            }\n            var id = (this.mode === 'Canvas' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) &&\n                this.scroller.oldCollectionObjects.length > 0) ?\n                this.scroller.oldCollectionObjects : undefined;\n            // Sort layer objects to arrange nodes with negative zIndex values at the beginning of the array.\n            // Due to the new implementation with order commands, the zIndex of a node may become negative.\n            // Therefore, we need to sort the zIndex values, with the least negative values coming first, followed by positive values.\n            var layerObjects = Object.keys(id || layer.zIndexTable);\n            layerObjects.sort(function (a, b) { return parseInt(\"\" + a, 10) - parseInt(\"\" + b, 10); });\n            for (var _b = 0, layerObjects_1 = layerObjects; _b < layerObjects_1.length; _b++) {\n                var node = layerObjects_1[_b];\n                var renderNode = id ? this.nameTable[id[\"\" + node]] : this.nameTable[layer.zIndexTable[\"\" + node]];\n                if (renderNode && !(renderNode.parentId) && layer.visible &&\n                    (!(renderNode.processId) || this.refreshing)) {\n                    //EJ2-68738 - Overview content not updated properly on zoom out the diagram\n                    var transformValue = void 0;\n                    //828826 - In canvas mode diagram transform values are not updated properly while Zoom out action\n                    if (this.scroller.currentZoom < 1 && this.mode === 'SVG') {\n                        transformValue = {\n                            tx: (-pageBounds.x) / this.scroller.currentZoom,\n                            ty: (-pageBounds.y) / this.scroller.currentZoom,\n                            scale: this.scroller.transform.scale\n                        };\n                    }\n                    else {\n                        transformValue = {\n                            tx: this.scroller.transform.tx,\n                            ty: this.scroller.transform.ty,\n                            scale: this.scroller.transform.scale\n                        };\n                    }\n                    // Bug 880945: Overview is not updated properly with 4k monitor.\n                    //To render the overview elements based on the pageBounds.\n                    if (isOverView) {\n                        transformValue = {\n                            tx: (-pageBounds.x) / this.scroller.currentZoom,\n                            ty: (-pageBounds.y) / this.scroller.currentZoom,\n                            scale: this.scroller.transform.scale\n                        };\n                    }\n                    if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this)) {\n                        if (this.scroller.currentZoom < 1) {\n                            if (pageBounds.x < 0 || this.scroller.horizontalOffset < 0) {\n                                var verticalValue = this.scroller.verticalOffset < 0 ? this.scroller.verticalOffset : 0;\n                                left = (difX > 0 ? difX : 0) + 'px';\n                                top_1 = ((this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.vScrollbarMoved) ? 0 : -verticalValue) + 'px';\n                            }\n                            else {\n                                left = 0 + 'px';\n                                top_1 = 0 + 'px';\n                            }\n                            if (this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.hScrollbarMoved) {\n                                this.realActions = this.realActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.hScrollbarMoved;\n                            }\n                            if (this.realActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.vScrollbarMoved) {\n                                this.realActions = this.realActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.RealAction.vScrollbarMoved;\n                            }\n                        }\n                        else {\n                            left = (pageBounds.x < 0 ? difX : -this.scroller.horizontalOffset) + 'px';\n                            top_1 = (pageBounds.y < 0 ? difY : -this.scroller.verticalOffset) + 'px';\n                        }\n                        this.diagramLayer.style.left = left;\n                        this.diagramLayer.style.top = top_1;\n                        //EJ2-69578 - Overview is not updated properly when we enable virtualization.\n                        transformValue.tx = (-pageBounds.x) / transformValue.scale;\n                        transformValue.ty = (-pageBounds.y) / transformValue.scale;\n                    }\n                    var status_1 = true;\n                    if (fromExport) {\n                        status_1 = false;\n                    }\n                    this.updateTextElementValue(renderNode);\n                    if (this.refreshing) {\n                        if (renderNode.shape.activity && renderNode.shape.activity.subProcess\n                            && renderNode.shape.activity.subProcess.processes) {\n                            for (var i = 0; i < renderNode.shape.activity.subProcess.processes.length; i++) {\n                                var process = renderNode.shape.activity.subProcess.processes[parseInt(i.toString(), 10)];\n                                renderNode.wrapper.children.push(this.nameTable[\"\" + process].wrapper);\n                            }\n                            renderNode.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(renderNode.wrapper.bounds.width, renderNode.wrapper.bounds.height));\n                            renderNode.wrapper.arrange(renderNode.wrapper.desiredSize);\n                        }\n                    }\n                    if (renderNode instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && renderNode.type === 'Bezier') {\n                        getCenterPoint = this.getMidPoint(renderNode);\n                        // (EJ2-58802) - Added the below code to add the transform x and y values to center point value in canvas mode\n                        if (this.mode === 'Canvas' && transform) {\n                            getCenterPoint.cx += transformValue.tx;\n                            getCenterPoint.cy += transformValue.ty;\n                        }\n                    }\n                    else {\n                        getCenterPoint = null;\n                    }\n                    renderer.renderElement(renderNode.wrapper, canvas, htmlLayer, (!renderer.isSvgMode && transform) ? transformValue : undefined, undefined, undefined, status_1 && (!this.diagramActions || isOverView), undefined, undefined, getCenterPoint, this.portCenterPoint);\n                }\n            }\n        }\n    };\n    /**\n     *updateBridging method \\\n     *\n     * @returns { void } updateBridging method .\\\n     * @param {string} isLoad - provide the isLoad value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateBridging = function (isLoad) {\n        if (this.bridgingModule) {\n            for (var i = 0; i < this.connectors.length; i++) {\n                var connector = this.connectors[parseInt(i.toString(), 10)];\n                this.bridgingModule.updateBridging(connector, this);\n                var canvas = this.connectors[parseInt(i.toString(), 10)].wrapper;\n                if (canvas && canvas.children && canvas.children.length > 0) {\n                    var pathSegment = canvas.children[0];\n                    var data = pathSegment.data;\n                    if (connector.isBezierEditing && this.selectedItems.connectors[0].id === connector.id || connector.type !== 'Bezier') {\n                        connector.getSegmentElement(connector, pathSegment, this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree' ?\n                            this.layout.orientation : undefined, undefined, false);\n                    }\n                    if (pathSegment.data !== data) {\n                        canvas.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size());\n                        canvas.arrange(canvas.desiredSize);\n                        if (this.mode === 'SVG' && !isLoad) {\n                            this.updateDiagramObject(connector);\n                        }\n                    }\n                }\n            }\n        }\n        else if (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.Bridging) {\n            console.warn('[WARNING] :: Module \"ConnectorBridging\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n        }\n    };\n    /**\n     *setCursor method \\\n     *\n     * @returns { void } setCursor method .\\\n     * @param {string} cursor - provide the width value.\n     *\n     * @private\n     */\n    Diagram.prototype.setCursor = function (cursor) {\n        this.diagramRenderer.setCursor(this.diagramCanvas, cursor);\n    };\n    /**\n     *clearCanvas method \\\n     *\n     * @returns { void } clearCanvas method .\\\n     * @param {View} view - provide the width value.\n     *\n     * @private\n     */\n    Diagram.prototype.clearCanvas = function (view) {\n        //let width: number;\n        //let height: number;\n        var width = view.contentWidth || view.diagramLayer.width / this.scroller.currentZoom;\n        var height = view.contentHeight || view.diagramLayer.height / this.scroller.currentZoom;\n        if (view.mode !== 'SVG') {\n            var ctx = _rendering_canvas_renderer__WEBPACK_IMPORTED_MODULE_1__.CanvasRenderer.getContext(view.diagramLayer);\n            ctx.clearRect(0, 0, width, height);\n        }\n    };\n    /**\n     *updateScrollOffset method \\\n     *\n     * @returns { void } updateScrollOffset method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.updateScrollOffset = function () {\n        this.scroller.setScrollOffset(this.diagramCanvas.scrollLeft, this.diagramCanvas.scrollTop);\n        (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.updateRuler)(this);\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this)) {\n            this.scroller.virtualizeElements();\n        }\n    };\n    /**\n     *setOffset method \\\n     *\n     * @returns { void } setOffset method .\\\n     * @param {number} offsetX - provide the width value.\n     * @param {number} offsetY - provide the height value.\n     *\n     * @private\n     */\n    Diagram.prototype.setOffset = function (offsetX, offsetY) {\n        var domTable = 'domTable';\n        if (!window[\"\" + domTable][this.element.id + 'content']) {\n            window[\"\" + domTable][this.element.id + 'content'] = document.getElementById(this.element.id + 'content');\n        }\n        var container = window[\"\" + domTable][this.element.id + 'content'];\n        if (container) {\n            container.scrollLeft = offsetX;\n            container.scrollTop = offsetY;\n        }\n    };\n    /**\n     *setSize method \\\n     *\n     * @returns { void } setSize method .\\\n     * @param {number} width - provide the width value.\n     * @param {number} height - provide the height value.\n     *\n     * @private\n     */\n    Diagram.prototype.setSize = function (width, height) {\n        if (this.diagramLayer && !this.preventDiagramUpdate) {\n            var position = (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_12__.getRulerSize)(this);\n            width -= position.width;\n            height -= position.height;\n            var bounds = this.spatialSearch.getPageBounds();\n            bounds.x *= this.scroller.currentZoom;\n            bounds.y *= this.scroller.currentZoom;\n            bounds.width *= this.scroller.currentZoom;\n            bounds.height *= this.scroller.currentZoom;\n            var factor = this.mode === 'SVG' ? 1 : 1.5;\n            var diagramLayer = this.mode === 'SVG' ?\n                (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramLayerSvg)(this.element.id) : this.diagramLayer;\n            var w = (this.mode === 'Canvas' &&\n                (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.Virtualization)) ? this.scroller.viewPortWidth : width;\n            var h = (this.mode === 'Canvas' &&\n                (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.Virtualization)) ? this.scroller.viewPortHeight : height;\n            diagramLayer.setAttribute('width', (factor * w).toString());\n            diagramLayer.setAttribute('height', (factor * h).toString());\n            var hiddenUserHandleTemplate = document.getElementById(this.element.id + '_diagramUserHandleLayer');\n            if (hiddenUserHandleTemplate) {\n                hiddenUserHandleTemplate.style.width = width + 'px';\n                hiddenUserHandleTemplate.style.height = height + 'px';\n            }\n            var attr = { 'width': width.toString(), 'height': height.toString() };\n            this.diagramLayerDiv.style.width = width + 'px';\n            this.diagramLayerDiv.style.height = height + 'px';\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)((0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getNativeLayerSvg)(this.element.id), attr);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)((0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getPortLayerSvg)(this.element.id), attr);\n            var adornerSVG = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getAdornerLayerSvg)(this.element.id);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)(adornerSVG, attr);\n            adornerSVG.parentNode.style.width = width + 'px';\n            adornerSVG.parentNode.style.height = height + 'px';\n            var gridLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getGridLayerSvg)(this.element.id);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)(gridLayer, attr);\n            this.diagramRenderer.updateGrid(this.snapSettings, gridLayer, this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.setAttributeSvg)((0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getBackgroundLayerSvg)(this.element.id), attr);\n            this.htmlLayer.style.width = width + 'px';\n            this.htmlLayer.style.height = height + 'px';\n            if (this.mode !== 'SVG' && !((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this))) {\n                this.refreshDiagramLayer();\n            }\n            if (this.mode === 'SVG' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this)) {\n                this.scroller.virtualizeElements();\n            }\n        }\n    };\n    /**\n     *transformLayers method \\\n     *\n     * @returns { void } Defines how to remove the Page breaks .\\\n     *\n     * @private\n     */\n    Diagram.prototype.transformLayers = function () {\n        var bounds = this.spatialSearch.getPageBounds();\n        bounds.x *= this.scroller.currentZoom;\n        bounds.y *= this.scroller.currentZoom;\n        bounds.width *= this.scroller.currentZoom;\n        bounds.height *= this.scroller.currentZoom;\n        this.diagramRenderer.updateGrid(this.snapSettings, (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getGridLayerSvg)(this.element.id), this.scroller.transform, this.rulerSettings, this.hRuler, this.vRuler);\n        this.diagramRenderer.transformLayers(this.scroller.transform, this.mode === 'SVG');\n        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DragUsingMouse)) {\n            this.updateSelector();\n        }\n        this.renderPageBreaks(bounds);\n    };\n    /**\n     *Defines how to remove the Page breaks \\\n     *\n     * @returns { void } Defines how to remove the Page breaks .\\\n     *\n     * @private\n     */\n    Diagram.prototype.removePageBreaks = function () {\n        if (this.diagramLayer) {\n            var line = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getBackgroundLayer)(this.element.id);\n            if (line && line.childNodes) {\n                var length_2 = line.childNodes.length;\n                for (var i = 0; i < length_2; i++) {\n                    line.removeChild(line.childNodes[0]);\n                }\n            }\n        }\n    };\n    /**\n     * Defines how the page breaks has been rendered \\\n     *\n     * @returns { void } Defines how the page breaks has been rendered .\\\n     * @param {Rect} bounds - provide the overview value.\n     *\n     * @private\n     */\n    Diagram.prototype.renderPageBreaks = function (bounds) {\n        this.removePageBreaks();\n        var backgroundLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getBackgroundLayer)(this.element.id);\n        if (backgroundLayer) {\n            var i = 0;\n            bounds = this.scroller.getPageBounds(true);\n            var x = (this.scroller.transform.tx + bounds.x) * this.scroller.currentZoom;\n            var y = (this.scroller.transform.ty + bounds.y) * this.scroller.currentZoom;\n            var height = bounds.height * this.scroller.currentZoom;\n            var width = bounds.width * this.scroller.currentZoom;\n            _rendering_renderer__WEBPACK_IMPORTED_MODULE_3__.DiagramRenderer.renderSvgBackGroundImage(this.pageSettings.background, this.element, x, y, width, height);\n            var options = {\n                id: backgroundLayer.id + 'rect', x: x,\n                y: y,\n                height: height,\n                width: width, angle: 0, stroke: '', strokeWidth: 1,\n                fill: this.pageSettings.background.color, opacity: 1,\n                pivotX: 0, pivotY: 0, visible: true, dashArray: '0'\n            };\n            this.diagramRenderer.drawRect(backgroundLayer, options);\n            if (this.pageSettings.showPageBreaks) {\n                var collection = this.scroller.getPageBreak(bounds);\n                for (i = 0; i < collection.length; i++) {\n                    this.diagramRenderer.drawLine(backgroundLayer, {\n                        class: 'e-diagram-page-break',\n                        fill: 'none', stroke: '#aaaaaa', strokeWidth: 1, dashArray: '10 10',\n                        opacity: 2, x: 0, y: 0, width: 0, height: 0, angle: 0, pivotX: 0, pivotY: 0, visible: true,\n                        startPoint: {\n                            x: (collection[parseInt(i.toString(), 10)].x1 + this.scroller.transform.tx) * this.scroller.currentZoom,\n                            y: (collection[parseInt(i.toString(), 10)].y1 + this.scroller.transform.ty) * this.scroller.currentZoom\n                        },\n                        endPoint: {\n                            x: (collection[parseInt(i.toString(), 10)].x2 + this.scroller.transform.tx) * this.scroller.currentZoom,\n                            y: (collection[parseInt(i.toString(), 10)].y2 + this.scroller.transform.ty) * this.scroller.currentZoom\n                        }, id: collection[parseInt(i.toString(), 10)].y1 === collection[parseInt(i.toString(), 10)].y2 ? 'HorizontalLines' : 'VerticalLines'\n                    });\n                }\n            }\n        }\n    };\n    Diagram.prototype.validatePageSize = function () {\n        var temp = 0;\n        if (this.pageSettings.orientation === 'Portrait') {\n            if (this.pageSettings.width > this.pageSettings.height) {\n                temp = this.pageSettings.height;\n                this.pageSettings.height = this.pageSettings.width;\n                this.pageSettings.width = temp;\n            }\n        }\n        else {\n            if (this.pageSettings.height > this.pageSettings.width) {\n                temp = this.pageSettings.width;\n                this.pageSettings.width = this.pageSettings.height;\n                this.pageSettings.height = temp;\n            }\n        }\n    };\n    /**\n     * setOverview method \\\n     *\n     * @returns { void }     setOverview method .\\\n     * @param {View} overview - provide the overview value.\n     * @param {string} id - provide the boolean value.\n     *\n     * @private\n     */\n    Diagram.prototype.setOverview = function (overview, id) {\n        if (overview) {\n            if (overview) {\n                this.views.push(overview.id);\n                this.views[overview.id] = overview;\n                overview.renderDocument(overview);\n                overview.diagramRenderer.setLayers();\n                overview.updateView(overview);\n                this.renderNodes(overview);\n            }\n        }\n        else {\n            for (var i = 0; i < this.views.length; i++) {\n                if (this.views[parseInt(i.toString(), 10)] === id) {\n                    overview = (this.views[\"\" + id]);\n                }\n            }\n            this.views[\"\" + id] = undefined;\n            var index = this.views.indexOf(id);\n            this.views.splice(index, 1);\n        }\n    };\n    Diagram.prototype.renderNodes = function (overview) {\n        if (overview) {\n            var renderer = new _rendering_renderer__WEBPACK_IMPORTED_MODULE_3__.DiagramRenderer(overview.id, new _rendering_svg_renderer__WEBPACK_IMPORTED_MODULE_2__.SvgRenderer(), false);\n            var g = document.getElementById(overview.element.id + '_diagramLayer');\n            var htmlLayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getHTMLLayer)(overview.element.id);\n            this.renderDiagramElements(g, overview.diagramRenderer || renderer, htmlLayer, undefined, undefined, true);\n        }\n    };\n    Diagram.prototype.updateThumbConstraints = function (node, selectorModel, canInitialize) {\n        var state = 0;\n        var length = node.length;\n        for (var i = 0; i < length; i++) {\n            var obj = node[parseInt(i.toString(), 10)];\n            var hideRotate = false;\n            var hideResize = false;\n            var thumbConstraints = selectorModel.thumbsConstraints;\n            var isInsideSwimlane = false;\n            if (this.nameTable[obj.parentId]) {\n                var lane = this.nameTable[obj.parentId];\n                isInsideSwimlane = lane.isLane;\n            }\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                //Bug 913796: Multiselect swimlane with outside node, drag, rotate is not proper.\n                //Hided rotate thumb for swimlane\n                hideRotate = (obj.shape.type === 'Bpmn' && (obj.shape.shape === 'Activity' &&\n                    (obj.shape.activity.subProcess.collapsed === false))) || obj.shape.type === 'SwimLane' || isInsideSwimlane;\n                // hideResize = (obj.shape.type === 'Bpmn' && (obj.shape as BpmnShapeModel).shape === 'TextAnnotation');\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canRotate)(obj) || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Rotate) || hideRotate) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Rotate;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'SouthEast') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouthEast) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouthEast;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'NorthWest') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorthWest) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorthWest;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'East') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeEast) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeEast;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'West') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeWest) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeWest;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'North') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorth) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorth;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'South') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouth) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouth;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'NorthEast') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorthEast) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorthEast;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj, 'SouthWest') || !(thumbConstraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouthWest) || hideResize) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouthWest;\n                }\n            }\n            else if (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                if (!canInitialize) {\n                    thumbConstraints = thumbConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Default;\n                }\n                if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDragSourceEnd)(obj)) {\n                    thumbConstraints = thumbConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ConnectorSource;\n                }\n                else {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ConnectorSource;\n                }\n                if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDragTargetEnd)(obj)) {\n                    thumbConstraints = thumbConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ConnectorTarget;\n                }\n                else {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ConnectorTarget;\n                }\n            }\n            else {\n                if (!canInitialize) {\n                    thumbConstraints = thumbConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Default;\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canResize)(obj)) {\n                    thumbConstraints = thumbConstraints & ~(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouthEast | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouthWest |\n                        _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeSouth | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeEast | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeWest |\n                        _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorth | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorthEast | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.ResizeNorthWest);\n                }\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canRotate)(obj)) {\n                    thumbConstraints = thumbConstraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Rotate;\n                }\n            }\n            selectorModel.thumbsConstraints = thumbConstraints;\n        }\n    };\n    /**\n     * renderSelector method \\\n     *\n     * @returns { void }     renderSelector method .\\\n     * @param {boolean} multipleSelection - provide the multipleSelection value.\n     * @param {boolean} isSwimLane - provide the boolean value.\n     * @param { Canvas } canvas - provide the lane or swimlane canvas\n     *\n     * @private\n     */\n    Diagram.prototype.renderSelector = function (multipleSelection, isSwimLane, canvas) {\n        var isProtectedOnChangeValue = this.isProtectedOnChange;\n        //Removed isBlazor code\n        var size = new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size();\n        var selectorModel = this.selectedItems;\n        var selectorConstraints = selectorModel.constraints;\n        var rendererActions = this.diagramRenderer.rendererActions;\n        var innertemplate = document.getElementsByClassName('blazor-inner-template');\n        var i;\n        var div;\n        this.diagramRenderer.rendererActions = this.currentSymbol ?\n            this.addConstraints(rendererActions, _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RendererAction.DrawSelectorBorder) :\n            this.removeConstraints(rendererActions, _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RendererAction.DrawSelectorBorder);\n        this.clearSelectorLayer();\n        if (this.commandHandler.hasSelection()) {\n            if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n                selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n                selectorModel.pivot = selectorModel.nodes[0].pivot;\n            }\n            selectorModel.wrapper.measure(size);\n            selectorModel.wrapper.arrange(selectorModel.wrapper.desiredSize);\n            selectorModel.width = selectorModel.wrapper.actualSize.width;\n            selectorModel.height = selectorModel.wrapper.actualSize.height;\n            selectorModel.offsetX = selectorModel.wrapper.offsetX;\n            selectorModel.offsetY = selectorModel.wrapper.offsetY;\n            if (selectorModel.rotateAngle !== 0) {\n                for (var _i = 0, _a = selectorModel.nodes; _i < _a.length; _i++) {\n                    var obj = _a[_i];\n                    obj.offsetX = obj.wrapper.offsetX;\n                    obj.offsetY = obj.wrapper.offsetY;\n                }\n                for (var _b = 0, _c = selectorModel.connectors; _b < _c.length; _b++) {\n                    var conn = _c[_b];\n                    //update connections\n                }\n            }\n            var bounds = this.spatialSearch.getPageBounds();\n            //let selectorElement: (SVGElement | HTMLCanvasElement);\n            var selectorElement = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getSelectorElement)(this.element.id);\n            //let diagramUserHandlelayer: (SVGElement | HTMLElement);\n            var diagramUserHandlelayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getUserHandleLayer)(this.element.id);\n            selectorModel.thumbsConstraints = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Default;\n            if (selectorModel.annotation) {\n                this.updateThumbConstraints([selectorModel.annotation], selectorModel);\n            }\n            else {\n                this.updateThumbConstraints(selectorModel.nodes, selectorModel);\n                this.updateThumbConstraints(selectorModel.connectors, selectorModel, true);\n            }\n            if (selectorModel.annotation) {\n                this.renderSelectorForAnnotation(selectorModel, selectorElement);\n            }\n            else if (selectorModel.nodes.length + selectorModel.connectors.length === 1 || this.nameTable['helper']) {\n                if (selectorModel.nodes[0] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                    var node = selectorModel.nodes[0];\n                    if ((0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.checkParentAsContainer)(this, node)) {\n                        if (!isSwimLane && (node.shape.type !== 'UmlClassifier' && !(node.parentId &&\n                            this.nameTable[node.parentId]\n                            && this.nameTable[node.parentId].shape.type === 'UmlClassifier'))) {\n                            selectorModel.thumbsConstraints &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Rotate;\n                        }\n                    }\n                    var constraints = isSwimLane ? true : ((node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.HideThumbs) ? true : false);\n                    var swimlane = (node.shape.type === 'SwimLane' || node.isLane || node.isPhase || isSwimLane) ? true : false;\n                    this.diagramRenderer.renderResizeHandle(isSwimLane ? canvas : selectorModel.wrapper.children[0], selectorElement, selectorModel.thumbsConstraints, this.scroller.currentZoom, selectorModel.constraints, this.scroller.transform, undefined, (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMove)(node), constraints, swimlane, selectorModel.handleSize);\n                }\n                else if (selectorModel.connectors[0] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDrawThumbs)(this.diagramRenderer.rendererActions)) {\n                    var connector = selectorModel.connectors[0];\n                    this.diagramRenderer.renderEndPointHandle(connector, selectorElement, selectorModel.thumbsConstraints, selectorModel.constraints, this.scroller.transform, connector.sourceWrapper !== undefined, connector.targetWrapper !== undefined, (this.connectorEditingToolModule && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDragSegmentThumb)(connector)) ? true : false, this.connectorEditingToolModule ? true : false, selectorModel.handleSize);\n                }\n            }\n            else {\n                this.diagramRenderer.renderResizeHandle(selectorModel.wrapper, selectorElement, selectorModel.thumbsConstraints, this.scroller.currentZoom, selectorModel.constraints, this.scroller.transform, undefined, (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMove)(selectorModel), null, null, selectorModel.handleSize);\n            }\n            if (!(selectorModel.annotation) && !this.currentSymbol) {\n                this.diagramRenderer.renderUserHandler(selectorModel, selectorElement, this.scroller.transform, diagramUserHandlelayer, this.eventHandler.currentAction, this.eventHandler.inAction);\n                //Removed isBlazor code\n            }\n        }\n        // EJ2-56919 - Add below code to render the selection rectangle for node if selected objects length is greater than one\n        if (this.selectedItems.selectedObjects.length > 1) {\n            this.updateSelectionRectangle();\n        }\n        this.isProtectedOnChange = isProtectedOnChangeValue;\n    };\n    Diagram.prototype.updateSelectionRectangle = function () {\n        var selectorElement = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getSelectorElement)(this.element.id);\n        var isFirst = false;\n        for (var i = 0; i < this.selectedItems.selectedObjects.length; i++) {\n            // EJ2-56919 - For first selected object we need to set stroke as 2, so check below condition as i is zero or not\n            // For first element we passed isFirst argument(last arg) as true in both render selection line and rectangle method\n            isFirst = i === 0 ? true : false;\n            if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(this.selectedItems.selectedObjects[parseInt(i.toString(), 10)]) === _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                // EJ2-56919 - If selected object type is connector means then render selection line for connector\n                this.diagramRenderer.renderSelectionLine(this.selectedItems.selectedObjects[parseInt(i.toString(), 10)].wrapper.children[0], selectorElement, this.scroller.transform, isFirst);\n            }\n            else {\n                // EJ2-56919 - If selected object type is node means then render selection rectangle for node\n                this.diagramRenderer.renderSelectionRectangle(this.selectedItems.selectedObjects[parseInt(i.toString(), 10)].wrapper, selectorElement, this.scroller.transform, isFirst);\n            }\n        }\n    };\n    /**\n     * updateSelector method \\\n     *\n     * @returns { void }     updateSelector method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.updateSelector = function () {\n        var severDataBind = this.allowServerDataBinding;\n        this.enableServerDataBinding(false);\n        var size = new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size();\n        var selector = this.selectedItems;\n        var selectorConstraints = selector.constraints;\n        var innertemplate = document.getElementsByClassName('blazor-inner-template');\n        var i;\n        var div;\n        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction) && this.selectedItems.nodes.length === 1) {\n            this.selectedItems.rotateAngle = this.selectedItems.nodes[0].rotateAngle;\n            this.selectedItems.wrapper.rotateAngle = this.selectedItems.nodes[0].rotateAngle;\n        }\n        if (this.selectedItems !== undefined) {\n            this.clearSelectorLayer();\n            if (selector.wrapper !== null && selector.wrapper.children && selector.wrapper.children.length) {\n                var canUpdate = true;\n                var canRender = true;\n                if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.selectionHasConnector)(this, selector)) {\n                    var eventHandler = 'eventHandler';\n                    var rotate = this[\"\" + eventHandler].action;\n                    var isRotate = rotate.includes('Rotate');\n                    var isSelect = rotate.includes('None') || rotate.includes('Select') || rotate.includes('Drag');\n                    if (isRotate || isSelect) {\n                        canRender = false;\n                    }\n                    if (!isSelect) {\n                        canUpdate = false;\n                    }\n                }\n                if (canUpdate) {\n                    selector.wrapper.measure(size);\n                    selector.wrapper.arrange(selector.wrapper.desiredSize);\n                }\n                if (selector.rotateAngle !== 0 || selector.rotateAngle !== selector.wrapper.prevRotateAngle) {\n                    for (var _i = 0, _a = selector.nodes; _i < _a.length; _i++) {\n                        var obj = _a[_i];\n                        obj.offsetX = obj.wrapper.offsetX;\n                        obj.offsetY = obj.wrapper.offsetY;\n                    }\n                }\n                selector.width = selector.wrapper.actualSize.width;\n                selector.height = selector.wrapper.actualSize.height;\n                selector.offsetX = selector.wrapper.offsetX;\n                selector.offsetY = selector.wrapper.offsetY;\n                //let selectorEle: (SVGElement | HTMLCanvasElement);\n                var selectorEle = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getSelectorElement)(this.element.id);\n                //let diagramUserHandlelayer: (SVGElement | HTMLElement);\n                var diagramUserHandlelayer = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getUserHandleLayer)(this.element.id);\n                var canHideResizers = this.eventHandler.canHideResizers();\n                selector.thumbsConstraints = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Default;\n                if (selector.annotation) {\n                    this.updateThumbConstraints([selector.annotation], selector);\n                }\n                else {\n                    this.updateThumbConstraints(selector.nodes, selector);\n                    this.updateThumbConstraints(selector.connectors, selector, true);\n                }\n                if ((this.selectedItems.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.SelectorConstraints.UserHandle) && (!(selector.annotation)) && !this.currentSymbol) {\n                    this.diagramRenderer.renderUserHandler(selector, selectorEle, this.scroller.transform, diagramUserHandlelayer, this.eventHandler.currentAction, this.eventHandler.inAction);\n                    //Removed isBlazor code\n                }\n                if (selector.annotation) {\n                    this.renderSelectorForAnnotation(selector, selectorEle);\n                }\n                else if (selector.nodes.length + selector.connectors.length === 1) {\n                    if (selector.connectors[0] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDrawThumbs)(this.diagramRenderer.rendererActions)) {\n                        var connector = selector.connectors[0];\n                        this.diagramRenderer.renderEndPointHandle(connector, selectorEle, selector.thumbsConstraints, selectorConstraints, this.scroller.transform, connector.sourceWrapper !== undefined, connector.targetWrapper !== undefined, (this.connectorEditingToolModule && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canDragSegmentThumb)(connector)) ? true : false, this.connectorEditingToolModule ? true : false, selector.handleSize);\n                    }\n                    else if (selector.nodes[0] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                        var stackPanel = selector.nodes[0];\n                        if ((0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.checkParentAsContainer)(this, selector.nodes[0])) {\n                            if (stackPanel.shape.type !== 'UmlClassifier' && !(stackPanel.parentId &&\n                                this.nameTable[stackPanel.parentId]\n                                && this.nameTable[stackPanel.parentId].shape.type === 'UmlClassifier')) {\n                                selector.thumbsConstraints &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.ThumbsConstraints.Rotate;\n                            }\n                        }\n                        var swimlane = (stackPanel.shape.type === 'SwimLane' || stackPanel.isLane ||\n                            stackPanel.isPhase) ? true : false;\n                        this.diagramRenderer.renderResizeHandle(selector.wrapper.children[0], selectorEle, selector.thumbsConstraints, this.scroller.currentZoom, selector.constraints, this.scroller.transform, canHideResizers, (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMove)(selector.nodes[0]), (selector.nodes[0].constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.HideThumbs) ? true : false, swimlane, selector.handleSize);\n                    }\n                }\n                else {\n                    if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Interactions) {\n                        this.diagramRenderer.rendererActions = this.diagramRenderer.rendererActions | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RendererAction.PreventRenderSelector;\n                    }\n                    if (!((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.selectionHasConnector)(this, selector) && canRender)) {\n                        this.diagramRenderer.renderResizeHandle(selector.wrapper, selectorEle, selector.thumbsConstraints, this.scroller.currentZoom, selector.constraints, this.scroller.transform, canHideResizers, (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMove)(selector), null, null, selector.handleSize);\n                    }\n                    this.diagramRenderer.rendererActions = this.diagramRenderer.rendererActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.RendererAction.PreventRenderSelector;\n                }\n            }\n        }\n        // EJ2-56919 - Add below code to render selection rectangle for node if selected objects length is greater than one\n        if (this.selectedItems.selectedObjects.length > 1) {\n            this.updateSelectionRectangle();\n        }\n        this.enableServerDataBinding(severDataBind);\n    };\n    /**\n     * renderSelectorForAnnotation method \\\n     *\n     * @returns { void }     renderSelectorForAnnotation method .\\\n     * @param {Selector} selectorModel - provide the x value.\n     * @param {(SVGElement | HTMLCanvasElement)} selectorElement - provide the y value.\n     *\n     * @private\n     */\n    //(EJ2-66036)- Annotation interaction not rendered properly\n    Diagram.prototype.renderSelectorForAnnotation = function (selectorModel, selectorElement) {\n        this.diagramRenderer.renderResizeHandle(selectorModel.wrapper.children[0], selectorElement, selectorModel.thumbsConstraints, this.scroller.currentZoom, selectorModel.constraints, this.scroller.transform, undefined, (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMove)(selectorModel.annotation), undefined, undefined, selectorModel.handleSize);\n    };\n    /**\n     * drawSelectionRectangle method \\\n     *\n     * @returns { void }     drawSelectionRectangle method .\\\n     * @param {number} x - provide the x value.\n     * @param {number} y - provide the y value.\n     * @param {number} width - provide the width value.\n     * @param {number} height - provide the height value.\n     *\n     * @private\n     */\n    Diagram.prototype.drawSelectionRectangle = function (x, y, width, height) {\n        this.clearSelectorLayer();\n        this.diagramRenderer.drawSelectionRectangle(x, y, width, height, this.adornerLayer, this.scroller.transform);\n    };\n    /**\n     * renderHighlighter method \\\n     *\n     * @returns { void }     renderHighlighter method .\\\n     * @param {DiagramElement} element - provide the node value.\n     *\n     * @private\n     */\n    Diagram.prototype.renderHighlighter = function (element) {\n        var adornerSvg = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getAdornerLayerSvg)(this.element.id);\n        this.diagramRenderer.renderHighlighter(element, adornerSvg, this.scroller.transform);\n    };\n    /**\n     * clearHighlighter method \\\n     *\n     * @returns { void }     clearHighlighter method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.clearHighlighter = function () {\n        var adornerSvg = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getAdornerLayerSvg)(this.element.id);\n        var highlighter = adornerSvg.getElementById(adornerSvg.id + '_highlighter');\n        if (highlighter) {\n            highlighter.parentNode.removeChild(highlighter);\n        }\n    };\n    /**\n     * getNodesConnectors method \\\n     *\n     * @returns { (NodeModel | ConnectorModel)[] }     getNodesConnectors method .\\\n     * @param {(NodeModel | ConnectorModel)[]} selectedItems - provide the node value.\n     *\n     * @private\n     */\n    Diagram.prototype.getNodesConnectors = function (selectedItems) {\n        for (var i = 0; i < this.nodes.length; i++) {\n            var node = this.nodes[parseInt(i.toString(), 10)];\n            selectedItems.push(node);\n        }\n        for (var i = 0; i < this.connectors.length; i++) {\n            var conn = this.connectors[parseInt(i.toString(), 10)];\n            selectedItems.push(conn);\n        }\n        return selectedItems;\n    };\n    /**\n     * clearSelectorLayer method \\\n     *\n     * @returns { void }     clearSelectorLayer method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.clearSelectorLayer = function () {\n        var adornerSvg = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getAdornerLayerSvg)(this.element.id);\n        var innertemplate = document.getElementsByClassName('blazor-inner-template');\n        var i;\n        var div;\n        var j;\n        if (!this.currentSymbol) {\n            var selectionRect = adornerSvg.getElementById(this.adornerLayer.id + '_selected_region');\n            if (selectionRect) {\n                selectionRect.parentNode.removeChild(selectionRect);\n            }\n            this.clearHighlighter();\n            var childNodes = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getSelectorElement)(this.element.id).childNodes;\n            var child = void 0;\n            //Bug 914365: Node is not resizable using touch interaction\n            //Added below code to get the target which we are dragging using touch interaction\n            var handleId = this.eventHandler.touchArgs ? this.eventHandler.touchArgs.target.id : undefined;\n            if (handleId && handleId.includes('bezierLine')) {\n                handleId = undefined;\n            }\n            for (var i_3 = childNodes.length; i_3 > 0; i_3--) {\n                //Added below code to prevent the removal of target element from DOM while doing touch move interaction\n                if (this.eventHandler && this.eventHandler.touchArgs && this.eventHandler.touchArgs.type === 'touchmove') {\n                    this.diagramRenderer.touchMove = true;\n                    if (!(handleId && handleId === childNodes[i_3 - 1].id)) {\n                        child = childNodes[i_3 - 1];\n                        child.parentNode.removeChild(child);\n                    }\n                }\n                else {\n                    child = childNodes[i_3 - 1];\n                    child.parentNode.removeChild(child);\n                }\n            }\n            //Removed isBlazor code\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)()) {\n                var templates = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getUserHandleLayer)(this.element.id).childNodes;\n                for (i = templates.length; i > 0; i--) {\n                    templates[i - 1].parentNode.removeChild(templates[i - 1]);\n                }\n            }\n        }\n        else {\n            var symbolBorder = adornerSvg.getElementById('borderRect_symbol');\n            if (symbolBorder) {\n                symbolBorder.parentNode.removeChild(symbolBorder);\n            }\n        }\n    };\n    /**\n     * getWrapper method \\\n     *\n     * @returns { void }     getWrapper method .\\\n     * @param {Container} nodes - provide the node value.\n     * @param {string} id - provide the childernCollection value.\n     *\n     * @private\n     */\n    Diagram.prototype.getWrapper = function (nodes, id) {\n        var wrapper;\n        id = nodes.id + '_' + id;\n        var container = nodes instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas ? nodes : this.getPortContainer(this.nameTable[nodes.id]);\n        for (var i = 0; i < container.children.length; i++) {\n            if (id === container.children[parseInt(i.toString(), 10)].id) {\n                wrapper = container.children[parseInt(i.toString(), 10)];\n            }\n        }\n        return wrapper;\n    };\n    /**\n     * DiagramElement method \\\n     *\n     * @returns { void }     getEndNodeWrapper method .\\\n     * @param {NodeModel | ConnectorModel} node - provide the node value.\n     * @param {ConnectorModel} connector - provide the childernCollection value.\n     * @param {boolean} source - provide the childernCollection value.\n     *\n     * @private\n     */\n    Diagram.prototype.getEndNodeWrapper = function (node, connector, source) {\n        if (node.shape.type === 'Bpmn' && node.wrapper.children[0] instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas) {\n            if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)() && node.shape.shape === 'Activity')) {\n                if (source && node.shape.activity.subProcess.type === 'Transaction'\n                    && connector.sourcePortID) {\n                    var portId = connector.sourcePortID;\n                    var parent_5 = node.wrapper.children[0].children[0].children[2];\n                    if (parent_5.children) {\n                        for (var _i = 0, _a = parent_5.children; _i < _a.length; _i++) {\n                            var child = _a[_i];\n                            if (child.visible && child.id === node.id + '_' + portId) {\n                                return child.children[0];\n                            }\n                        }\n                    }\n                }\n                return node.wrapper.children[0].children[0].children[0];\n            }\n            if (node.shape.shape === 'Group') {\n                return node.wrapper.children[0];\n            }\n            return node.wrapper.children[0].children[0];\n        }\n        if (!this.containsMargin(node.wrapper.children[0])) {\n            if (!node.children) {\n                return node.wrapper.children[0];\n            }\n        }\n        return node.wrapper;\n    };\n    Diagram.prototype.containsMargin = function (node) {\n        return node.margin && (node.margin.left !== 0 || node.margin.top !== 0 || node.margin.right !== 0 || node.margin.bottom !== 0);\n    };\n    Diagram.prototype.focusOutEdit = function () {\n        this.endEdit();\n        // EJ2-57743 - Added below code to refresh the diagram layer after the annotation gets edited in canvas mode.\n        if (this.mode === 'Canvas' && this.scroller.currentZoom !== 1) {\n            this.refreshDiagramLayer();\n        }\n    };\n    Diagram.prototype.endEditCommand = function () {\n        this.endEdit();\n        this.textEditing = false;\n        // EJ2-57743 - Added below code to refresh the diagram layer after the annotation gets edited in canvas mode.\n        if (this.mode === 'Canvas' && this.scroller.currentZoom !== 1) {\n            this.refreshDiagramLayer();\n        }\n    };\n    // EJ2-866418-keyboard shortcut keys method starting\n    //Change the text style of nodes,swimlane,textnode\n    Diagram.prototype.fontStyleCommand = function (format) {\n        for (var i = 0; i < this.selectedItems.nodes.length; i++) {\n            var node = this.selectedItems.nodes[parseInt(i.toString(), 10)];\n            if (node.shape.type === 'SwimLane') {\n                if (node.shape.hasHeader) {\n                    this.applyStyleText(format, node.shape.header.annotation);\n                }\n            }\n            if (node.isLane) {\n                var laneHeader = this.getObject(node.shape.header[0].id);\n                this.applyStyle(format, laneHeader.annotations);\n            }\n            if (node.shape.type === 'Text') {\n                var textNode = node;\n                this.applyStyleText(format, textNode);\n            }\n            if (node.annotations.length > 0) {\n                var annotationLength = node.annotations;\n                this.applyStyle(format, annotationLength);\n            }\n        }\n        for (var i = 0; i < this.selectedItems.connectors.length; i++) {\n            if (this.selectedItems.connectors[parseInt(i.toString(), 10)].annotations.length > 0) {\n                var annotationLength = this.selectedItems.connectors[parseInt(i.toString(), 10)].annotations;\n                this.applyStyle(format, annotationLength);\n            }\n        }\n    };\n    Diagram.prototype.applyStyle = function (format, annotationLength) {\n        for (var j = 0; j < annotationLength.length; j++) {\n            switch (format) {\n                case 'bold':\n                    annotationLength[parseInt(j.toString(), 10)].style.bold = !annotationLength[parseInt(j.toString(), 10)].style.bold;\n                    break;\n                case 'italic':\n                    annotationLength[parseInt(j.toString(), 10)].style.italic = !annotationLength[parseInt(j.toString(), 10)].style.italic;\n                    break;\n                case 'underline':\n                    if (annotationLength[parseInt(j.toString(), 10)].style.textDecoration === 'None') {\n                        annotationLength[parseInt(j.toString(), 10)].style.textDecoration = 'Underline';\n                    }\n                    else if (annotationLength[parseInt(j.toString(), 10)].style.textDecoration === 'Underline') {\n                        annotationLength[parseInt(j.toString(), 10)].style.textDecoration = 'None';\n                    }\n                    break;\n            }\n        }\n        this.dataBind();\n    };\n    Diagram.prototype.applyStyleText = function (format, textNode) {\n        switch (format) {\n            case 'bold':\n                textNode.style.bold = !textNode.style.bold;\n                break;\n            case 'italic':\n                textNode.style.italic = !textNode.style.italic;\n                break;\n            case 'underline':\n                if (textNode.style.textDecoration === 'None') {\n                    textNode.style.textDecoration = 'Underline';\n                }\n                else if (textNode.style.textDecoration === 'Underline') {\n                    textNode.style.textDecoration = 'None';\n                }\n                break;\n        }\n        this.dataBind();\n    };\n    //To duplicate the elements on clicking Ctrl+D\n    Diagram.prototype.duplicateCommand = function () {\n        var selectedItems = [];\n        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n        this.copy();\n        this.paste();\n    };\n    //To group and ungroup the elements\n    Diagram.prototype.groupCommand = function (group) {\n        switch (group) {\n            case 'group':\n                this.group();\n                break;\n            case 'ungroup':\n                this.unGroup();\n                break;\n        }\n    };\n    //To rotate clockwise and anti-clockwise the elements\n    Diagram.prototype.rotateCommand = function (rotateValue) {\n        var selectedItems = this.selectedItems;\n        switch (rotateValue) {\n            case 'clockwise':\n                this.rotate(selectedItems, 90);\n                break;\n            case 'antiClockwise':\n                this.rotate(selectedItems, -90);\n                break;\n        }\n    };\n    //To flip horizontally and vertically the elements\n    Diagram.prototype.flipCommand = function (flipValue) {\n        var selectedItems = [];\n        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n        for (var i = 0; i < selectedItems.length; i++) {\n            switch (flipValue) {\n                case 'horizontal':\n                    selectedItems[parseInt(i.toString(), 10)].flip = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Horizontal;\n                    break;\n                case 'vertical':\n                    selectedItems[parseInt(i.toString(), 10)].flip = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Vertical;\n                    break;\n            }\n        }\n        this.dataBind();\n    };\n    //To exceute the tool commands\n    Diagram.prototype.toolCommand = function (tool) {\n        switch (tool) {\n            case 'pointer': {\n                this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.Default;\n                this.dataBind();\n                break;\n            }\n            case 'text': {\n                var textnode = {\n                    shape: { type: 'Text' }\n                };\n                this.drawingObject = textnode;\n                this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.DrawOnce;\n                this.dataBind();\n                break;\n            }\n            case 'connect': {\n                var connectors = {\n                    id: 'connector1',\n                    type: 'Straight'\n                };\n                this.drawingObject = connectors;\n                this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.DrawOnce;\n                this.dataBind();\n                break;\n            }\n            case 'freeForm': {\n                var freeform = { id: 'connector1', type: 'Freehand' };\n                this.drawingObject = freeform;\n                this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.DrawOnce;\n                this.dataBind();\n                break;\n            }\n            case 'line': {\n                var polyline = { id: 'connector1', type: 'Polyline' };\n                this.drawingObject = polyline;\n                this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.DrawOnce;\n                this.dataBind();\n                break;\n            }\n            case 'rectangle': {\n                var drawingshape = { type: 'Basic', shape: 'Rectangle' };\n                var basicNode = {\n                    shape: drawingshape\n                };\n                this.drawingObject = basicNode;\n                this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.DrawOnce;\n                this.dataBind();\n                break;\n            }\n            case 'ellipse': {\n                var drawingNode = { type: 'Basic', shape: 'Ellipse' };\n                var ellipseNode = {\n                    shape: drawingNode\n                };\n                this.drawingObject = ellipseNode;\n                this.tool = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.DrawOnce;\n                this.dataBind();\n                break;\n            }\n        }\n    };\n    //To zoomin and zoom-out the diagram\n    Diagram.prototype.zoomCommand = function (zoomValue) {\n        switch (zoomValue) {\n            case 'zoomIn':\n                this.zoomTo({ type: 'ZoomIn', zoomFactor: 0.2 });\n                break;\n            case 'zoomOut':\n                this.zoomTo({ type: 'ZoomOut', zoomFactor: 0.2 });\n                break;\n        }\n    };\n    //To move the diagram elements five pixel based on the arrow keys\n    Diagram.prototype.shiftCommand = function (direction) {\n        for (var i = 0; i < this.selectedItems.nodes.length; i++) {\n            var pixel = 5;\n            if (direction === 'Up') {\n                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY\n                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY - pixel;\n            }\n            else if (direction === 'Down') {\n                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY\n                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY + pixel;\n            }\n            else if (direction === 'Left') {\n                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX\n                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX - pixel;\n            }\n            else if (direction === 'Right') {\n                this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX\n                    = this.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX + pixel;\n            }\n        }\n        for (var i = 0; i < this.selectedItems.connectors.length; i++) {\n            var connector = this.selectedItems;\n            if (direction === 'Up') {\n                this.drag(connector, 0, -5);\n            }\n            else if (direction === 'Down') {\n                this.drag(connector, 0, 5);\n            }\n            else if (direction === 'Left') {\n                this.drag(connector, -5, 0);\n            }\n            else if (direction === 'Right') {\n                this.drag(connector, 5, 0);\n            }\n        }\n    };\n    //To execute the text align\n    Diagram.prototype.alignCommand = function (alignDirection) {\n        if (this.selectedItems.nodes.length > 0) {\n            for (var i = 0; i < this.selectedItems.nodes.length; i++) {\n                this.updateNodesAndConnectorAnnotation(this.selectedItems.nodes[parseInt(i.toString(), 10)], alignDirection);\n            }\n        }\n    };\n    Diagram.prototype.updateNodesAndConnectorAnnotation = function (object, alignDirection) {\n        var annotation;\n        for (var i = 0; i < object.annotations.length; i++) {\n            annotation = object.annotations[parseInt(i.toString(), 10)];\n            switch (alignDirection) {\n                case 'left':\n                    annotation.horizontalAlignment = 'Left';\n                    break;\n                case 'center':\n                    annotation.horizontalAlignment = 'Center';\n                    break;\n                case 'right':\n                    annotation.horizontalAlignment = 'Right';\n                    break;\n                case 'justify':\n                    annotation.style.textAlign = 'Justify';\n                    break;\n                case 'top':\n                    annotation.verticalAlignment = 'Top';\n                    break;\n                case 'centerVertical':\n                    annotation.verticalAlignment = 'Center';\n                    break;\n                case 'bottom':\n                    annotation.verticalAlignment = 'Bottom';\n                    break;\n            }\n            this.dataBind();\n        }\n    };\n    //To execute ordercommands using keyboard shortcuts\n    Diagram.prototype.orderCommand = function (orderCommand) {\n        switch (orderCommand) {\n            case 'sendToBack':\n                this.sendToBack();\n                break;\n            case 'bringToFront':\n                this.bringToFront();\n                break;\n            case 'sendBackward':\n                this.sendBackward();\n                break;\n            case 'bringForward':\n                this.moveForward();\n                break;\n        }\n    };\n    //To execute the selection of elements on clicking tab key\n    Diagram.prototype.navigateItems = function (tabCommand) {\n        var currentSelectedNodeIndex = 0;\n        var lastZIndex = this.activeLayer.objectZIndex;\n        var selectedItems = [];\n        var selectables = [];\n        selectedItems = selectedItems.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n        selectables = selectables.concat(this.nodes, this.connectors);\n        if (selectedItems.length > 0) {\n            currentSelectedNodeIndex = selectedItems[0].zIndex + (tabCommand ? 1 : -1);\n        }\n        else {\n            currentSelectedNodeIndex = tabCommand ? 0 : lastZIndex;\n        }\n        if (currentSelectedNodeIndex < 0) {\n            currentSelectedNodeIndex = lastZIndex;\n        }\n        else if (currentSelectedNodeIndex > lastZIndex) {\n            currentSelectedNodeIndex = 0;\n        }\n        var isSelected = false;\n        do {\n            for (var i = 0; i < selectables.length; i++) {\n                var nextObject = selectables[parseInt(i.toString(), 10)];\n                if (currentSelectedNodeIndex === nextObject.zIndex) {\n                    this.clearSelection();\n                    this.select([nextObject]);\n                    isSelected = true;\n                    break; // Exit the loop once a node or connector is selected\n                }\n            }\n            if (!isSelected) {\n                if (tabCommand) {\n                    currentSelectedNodeIndex++; // If no selection has been made, increment currentSelectedNodeIndex for Tab command\n                }\n                else {\n                    currentSelectedNodeIndex--; // If no selection has been made, decrement currentSelectedNodeIndex for shift + Tab\n                }\n            }\n        } while (!isSelected);\n    };\n    /**\n     * @private\n     */\n    /* tslint:disable */\n    Diagram.prototype.endEdit = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var blazor, blazorInterop, oldValues, changedvalues, annotations, textArea, text, element, node, annotation, args, textWrapper, index, deleteNode, contentModified, index, changesAnnotation, nodeIndex, oldnodes, newnodes, clonedObject, selectedNode, swimLaneNode, laneHeader, phaseHeader, collection, j;\n            return __generator(this, function (_a) {\n                if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.TextEdit) {\n                    blazor = 'Blazor';\n                    blazorInterop = 'sfBlazor';\n                    oldValues = void 0;\n                    changedvalues = void 0;\n                    annotations = {};\n                    this.enableServerDataBinding(false);\n                    textArea = document.getElementById(this.element.id + '_editBox');\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)()) {\n                        text = textArea.value;\n                        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(textArea, 'input', this.eventHandler.inputChange);\n                        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(textArea, 'focusout', this.focusOutEdit);\n                        element = document.getElementById(this.element.id + '_editTextBoxDiv');\n                        node = void 0;\n                        node = this.nameTable[this.activeLabel.parentId];\n                        annotation = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findAnnotation)(node, this.activeLabel.id);\n                        args = { oldValue: this.activeLabel.text, newValue: text, cancel: false, element: node, annotation: annotation };\n                        //Removed isBlazor code\n                        element.parentNode.removeChild(element);\n                        textWrapper = void 0;\n                        if (annotation && !(annotation instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Text)) {\n                            index = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findObjectIndex)(node, annotation.id, true);\n                            annotations[\"\" + index] = { content: annotation.content };\n                            oldValues = { annotations: annotations };\n                        }\n                        else {\n                            //Removed isBlazor code\n                            oldValues = { shape: { content: node.shape.content } };\n                        }\n                        deleteNode = false;\n                        if (this.eventHandler['currentAction'] === 'Draw') {\n                            deleteNode = this.eventHandler.isAddTextNode(node, true);\n                        }\n                        if (!deleteNode && (element.textContent !== text || text !== this.activeLabel.text)) {\n                            //Removed isBlaor code\n                            this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.textEdit, args);\n                        }\n                        if (!textWrapper) {\n                            textWrapper = this.getWrapper(node.wrapper, this.activeLabel.id);\n                        }\n                        contentModified = false;\n                        if (annotation.content !== text && !args.cancel) {\n                            contentModified = true;\n                            if (!this.activeLabel.isGroup) {\n                                this.startGroupAction();\n                            }\n                            if (node.parentId && this.nameTable[node.parentId].shape.type === 'UmlClassifier'\n                                && text.indexOf('+') === -1 && text.indexOf('-') === -1 && text.indexOf('#') === -1\n                                && text.indexOf('~') === -1 && node.id.indexOf('_umlClass_header') === -1) {\n                                text = ' + ' + text;\n                            }\n                            if (node.isLane || node.isPhase) {\n                                this.protectPropertyChange(true);\n                            }\n                            if (!(annotation instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Text)) {\n                                index = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.findObjectIndex)(node, annotation.id, true);\n                                changesAnnotation = {};\n                                changesAnnotation[\"\" + index] = { content: text };\n                                changedvalues = { annotations: changesAnnotation };\n                            }\n                            else {\n                                //Removed isBlazor code\n                                changedvalues = { shape: { content: text } };\n                            }\n                            nodeIndex = this.getIndex(node, node.id);\n                            if (nodeIndex) {\n                                oldnodes = {};\n                                oldnodes[\"\" + nodeIndex] = oldValues;\n                                newnodes = {};\n                                newnodes[\"\" + nodeIndex] = changedvalues;\n                                if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(node) === _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                                    this.onPropertyChanged({ nodes: newnodes }, { nodes: oldnodes });\n                                }\n                                else {\n                                    this.onPropertyChanged({ connectors: newnodes }, { connectors: oldnodes });\n                                }\n                            }\n                            this.protectPropertyChange(true);\n                            //Removed isBlazor code\n                            annotation.content = text;\n                            this.protectPropertyChange(false);\n                            this.updateSelector();\n                            if (node.isLane || node.isPhase) {\n                                this.protectPropertyChange(false);\n                            }\n                        }\n                        if (deleteNode) {\n                            this.removeObjectsFromLayer(node);\n                            this.removeFromAQuad(node);\n                            delete this.nameTable[this.activeLabel.parentId];\n                            if (text !== '') {\n                                this.clearSelection();\n                                clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(node);\n                                node = this.add(clonedObject);\n                                this.updateDiagramObject(node);\n                                this.commandHandler.oldSelectedObjects = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneSelectedObjects)(this);\n                                this.commandHandler.select(this.nameTable[node.id]);\n                                // this.commandHandler.updateBlazorSelector();\n                            }\n                        }\n                        if (this.selectedItems.nodes.length) {\n                            selectedNode = this.nameTable[this.activeLabel.parentId];\n                            swimLaneNode = this.nameTable[selectedNode.parentId];\n                            if ((swimLaneNode && swimLaneNode.shape.type === 'SwimLane') || (selectedNode.shape.type === 'SwimLane')) {\n                                laneHeader = 'LaneHeaderParent';\n                                phaseHeader = 'PhaseHeaderParent';\n                                if ((selectedNode.shape.type === 'SwimLane')) {\n                                    swimLaneNode = this.nameTable[this.activeLabel.parentId];\n                                    selectedNode = node;\n                                }\n                                if ((selectedNode.isLane || selectedNode.isPhase)) {\n                                    collection = selectedNode.isLane ?\n                                        swimLaneNode.shape.lanes : swimLaneNode.shape.phases;\n                                    for (j = 0; j < collection.length; j++) {\n                                        if (collection[parseInt(j.toString(), 10)].id === (selectedNode[\"\" + laneHeader] || selectedNode[\"\" + phaseHeader])) {\n                                            collection[parseInt(j.toString(), 10)].header.annotation.content = selectedNode.annotations[0].content;\n                                        }\n                                    }\n                                }\n                                else if (selectedNode.isHeader && swimLaneNode.shape.hasHeader) {\n                                    swimLaneNode.shape.header.annotation.content = selectedNode.annotations[0].content;\n                                }\n                            }\n                            this.dataBind();\n                        }\n                        textWrapper.visible = true;\n                        this.updateDiagramObject(node);\n                        this.diagramActions = this.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.TextEdit;\n                        if (this.activeLabel.isGroup || contentModified) {\n                            this.endGroupAction();\n                        }\n                        this.activeLabel = { id: '', parentId: '', isGroup: false, text: undefined };\n                        this.commandHandler.getBlazorOldValues();\n                        //Removed isBlazor code\n                        this.enableServerDataBinding(true);\n                    }\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * getIndex method \\\n     *\n     * @returns { void }     getIndex method .\\\n     * @param {NodeModel | ConnectorModel} node - provide the node value.\n     * @param {string} id - provide the childernCollection value.\n     *\n     * @private\n     */\n    Diagram.prototype.getIndex = function (node, id) {\n        //let index: number;\n        var collection = ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(node) === _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) ? this.nodes : this.connectors;\n        for (var i = 0; i < collection.length; i++) {\n            if (collection[parseInt(i.toString(), 10)].id.toString() === id.toString()) {\n                return i.toString();\n            }\n        }\n        return null;\n    };\n    /* tslint:enable */\n    //Removed getBlazorTextEditArgs method\n    /**\n     * canLogChange method \\\n     *\n     * @returns { void }     canLogChange method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.canLogChange = function () {\n        if ((this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) && (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)) &&\n            (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) && (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod))) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Diagram.prototype.modelChanged = function (newProp, oldProp) {\n        if (newProp.connectors || oldProp.connectors || newProp.nodes || oldProp.connectors\n            || newProp.pageSettings || oldProp.pageSettings || newProp.bridgeDirection || oldProp.bridgeDirection) {\n            return true;\n        }\n        return false;\n    };\n    Diagram.prototype.resetDiagramActions = function (action) {\n        var isAction = action ? true : false;\n        if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo && (!isAction || (action === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo))) {\n            this.diagramActions = this.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo;\n        }\n        if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod && (!isAction || action === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod)) {\n            this.diagramActions = this.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PublicMethod;\n        }\n    };\n    /**\n     * removeNode method \\\n     *\n     * @returns { void }     removeNode method .\\\n     * @param {NodeModel} node - provide the node value.\n     * @param {NodeModel} childrenCollection - provide the childrenCollection value.\n     *\n     * @private\n     */\n    Diagram.prototype.removeNode = function (node, childrenCollection) {\n        this.removeObjectsFromLayer(node);\n        this.removeFromAQuad(this.nameTable[node.id]);\n        var groupElement = document.getElementById(node.id + '_groupElement');\n        delete this.nameTable[node.id];\n        if (node.children) {\n            delete this.groupTable[node.id];\n        }\n        //Removed isBlazor code\n        this.nodes.splice(this.nodes.indexOf(node), 1);\n        if (groupElement && groupElement.children && groupElement.children.length > 0) {\n            var beforeElement = undefined;\n            for (var j = groupElement.children.length - 1; j >= 0; j--) {\n                var childElement = groupElement.children[parseInt(j.toString(), 10)];\n                //EJ2-863636 - Nodes Removed from Diagram upon Ungrouping\n                if (childrenCollection.length > 0 && childrenCollection.indexOf(childElement.id.split('_groupElement')[0]) !== -1) {\n                    if (!beforeElement) {\n                        groupElement.parentNode.insertBefore(childElement, groupElement);\n                    }\n                    else {\n                        groupElement.parentNode.insertBefore(childElement, beforeElement);\n                    }\n                    beforeElement = childElement;\n                }\n            }\n        }\n        if (groupElement) {\n            groupElement.parentNode.removeChild(groupElement);\n        }\n    };\n    /**\n     * deleteGroup method \\\n     *\n     * @returns { void }     deleteGroup method .\\\n     * @param {NodeModel} node - provide the source value.\n     *\n     * @private\n     */\n    Diagram.prototype.deleteGroup = function (node) {\n        var elements = [];\n        var tempNode = [];\n        if (node.children) {\n            tempNode = this.commandHandler.getChildren(node, elements);\n        }\n        this.UpdateBlazorDiagramModelCollection(node);\n        for (var _i = 0, tempNode_1 = tempNode; _i < tempNode_1.length; _i++) {\n            var nodes = tempNode_1[_i];\n            if (nodes && this.nameTable[nodes.id]) {\n                this.remove(nodes);\n            }\n        }\n    };\n    //helper methods - end region\n    //property changes - start region\n    /** @private */\n    /**\n     * updateObject method \\\n     *\n     * @returns { void }     updateObject method .\\\n     * @param {Node | Connector} actualObject - provide the source value.\n     * @param {Node | Connector} oldObject - provide the target value.\n     * @param {Node | Connector} changedProp - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateObject = function (actualObject, oldObject, changedProp) {\n        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)) {\n            var bound = actualObject.wrapper.children[0].bounds;\n            var checkBoundaryConstraints = this.commandHandler.checkBoundaryConstraints(undefined, undefined, bound, true);\n            if (!checkBoundaryConstraints) {\n                if (actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                    var oldNode = oldObject;\n                    for (var _i = 0, _a = Object.keys(changedProp); _i < _a.length; _i++) {\n                        var key = _a[_i];\n                        switch (key) {\n                            case 'width':\n                                actualObject.width = oldNode.width;\n                                break;\n                            case 'height':\n                                actualObject.height = oldNode.height;\n                                break;\n                            case 'offsetX':\n                                actualObject.offsetX = oldNode.offsetX;\n                                break;\n                            case 'offsetY':\n                                actualObject.offsetY = oldNode.offsetY;\n                                break;\n                            case 'rotateAngle':\n                                actualObject.rotateAngle = oldNode.rotateAngle;\n                                break;\n                        }\n                    }\n                    this.nodePropertyChange(actualObject, changedProp, oldObject);\n                }\n                else {\n                    for (var _b = 0, _c = Object.keys(changedProp); _b < _c.length; _b++) {\n                        var key = _c[_b];\n                        var oldConnector = oldObject;\n                        var actualSourcePoint = actualObject.sourcePoint;\n                        var actualTargetPoint = actualObject.targetPoint;\n                        switch (key) {\n                            case 'sourcePoint':\n                                actualSourcePoint.x = oldConnector.sourcePoint.x || actualSourcePoint.x;\n                                actualSourcePoint.y = oldConnector.sourcePoint.y || actualSourcePoint.y;\n                                break;\n                            case 'targetPoint':\n                                actualTargetPoint.x = oldConnector.targetPoint.x || actualTargetPoint.x;\n                                actualTargetPoint.y = oldConnector.targetPoint.y || actualTargetPoint.y;\n                        }\n                    }\n                    this.connectorPropertyChange(actualObject, changedProp, oldObject);\n                }\n            }\n        }\n    };\n    Diagram.prototype.nodePropertyChangeExtend = function (actualObject, oldObject, node, update) {\n        if (node.style !== undefined && actualObject.shape.type !== 'Bpmn') {\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateStyle)(node.style, actualObject.wrapper.children[0]);\n            update = true;\n        }\n        if (node.shadow !== undefined) {\n            this.updateShadow(actualObject.shadow, node.shadow);\n            update = true;\n        }\n        if (node.constraints !== undefined) {\n            if ((oldObject.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select) &&\n                (!(node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select)) && (0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.isSelected)(this, actualObject)) {\n                this.clearSelection();\n            }\n            else {\n                this.updateThumbConstraints(this.selectedItems.nodes, this.selectedItems);\n                this.updateSelector();\n                update = true;\n            }\n        }\n        this.updateTextAnnotationInSwimlane(actualObject, node);\n        this.swimLaneNodePropertyChange(actualObject, oldObject, node, update);\n        return update;\n    };\n    //To update text annotation node inside swimlane while dragging the text annotation parent.\n    Diagram.prototype.updateTextAnnotationInSwimlane = function (actualObject, node) {\n        if (actualObject.hasTextAnnotation && this.isPositionUndo) {\n            for (var i = 0; i < actualObject.outEdges.length; i++) {\n                var con = this.nameTable[actualObject.outEdges[parseInt(i.toString(), 10)]];\n                if (con.isBpmnAnnotationConnector) {\n                    var textNode = this.nameTable[con.targetID];\n                    this.isProtectedOnChange = true;\n                    if (actualObject.laneMargin && textNode) {\n                        var dx = actualObject.margin.left - actualObject.laneMargin.left;\n                        var dy = actualObject.margin.top - actualObject.laneMargin.top;\n                        textNode.margin.left += dx;\n                        textNode.margin.top += dy;\n                        textNode.offsetX += dx;\n                        textNode.offsetY += dy;\n                        textNode.wrapper.offsetX += dx;\n                        textNode.wrapper.offsetY += dy;\n                        textNode.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(textNode.wrapper.width, textNode.wrapper.height));\n                        textNode.wrapper.arrange(textNode.wrapper.desiredSize);\n                        this.updateDiagramObject(textNode);\n                    }\n                    this.isProtectedOnChange = false;\n                }\n            }\n        }\n    };\n    /* tslint:disable */\n    Diagram.prototype.swimLaneNodePropertyChange = function (actualObject, oldObject, node, update) {\n        if (actualObject.shape.type === 'SwimLane' && !this.currentSymbol) {\n            if (oldObject.shape) {\n                var shape = node.shape;\n                var actualShape = actualObject.shape;\n                var orientation_1 = (actualShape.orientation === 'Horizontal') ? true : false;\n                var padding = actualShape.padding;\n                var oldShape = oldObject.shape;\n                var grid = actualObject.wrapper.children[0];\n                var oldObjects = void 0;\n                var newObjects = void 0;\n                var id = void 0;\n                if (oldShape.lanes || oldShape.phases) {\n                    if (oldShape.lanes) {\n                        for (var _i = 0, _a = Object.keys(shape.lanes); _i < _a.length; _i++) {\n                            var count = _a[_i];\n                            var indexValue = Number(count);\n                            var lane = oldShape.lanes[parseInt(indexValue.toString(), 10)];\n                            var laneIndex = void 0;\n                            var newLane = shape.lanes[parseInt(indexValue.toString(), 10)];\n                            if (newLane && newLane.header) {\n                                id = actualShape.lanes[parseInt(indexValue.toString(), 10)].header.id;\n                                oldObjects = lane.header;\n                                newObjects = newLane.header;\n                                // EJ2-913790  Save Load for header font change won't be as saved\n                                if (newObjects.annotation && newObjects.annotation.content) {\n                                    this.nameTable[\"\" + id].annotations[0].content = newObjects.annotation.content;\n                                }\n                                if (newObjects.annotation && newObjects.annotation.style) {\n                                    this.nameTable[\"\" + id].annotations[0].style = newObjects.annotation.style;\n                                }\n                                this.nodePropertyChange(this.nameTable[\"\" + id], oldObjects, newObjects);\n                            }\n                            if (lane.children) {\n                                for (var _b = 0, _c = Object.keys(lane.children); _b < _c.length; _b++) {\n                                    var childNodeIndex = _c[_b];\n                                    id = actualShape.lanes[parseInt(indexValue.toString(), 10)].children[Number(childNodeIndex)].id;\n                                    var node_1 = this.nameTable[\"\" + id];\n                                    oldObjects = lane.children[Number(childNodeIndex)];\n                                    newObjects = newLane.children[Number(childNodeIndex)];\n                                    this.nodePropertyChange(node_1, oldObjects, newObjects);\n                                }\n                            }\n                            if (lane.width && !orientation_1) {\n                                laneIndex = (actualShape.phases && actualShape.phaseSize) ? indexValue + 1 : indexValue;\n                                grid.updateColumnWidth(laneIndex, newLane.width, true, padding);\n                                this.updateDiagramElementQuad();\n                            }\n                            if (lane.height && orientation_1) {\n                                laneIndex = (actualShape.header && actualShape.hasHeader) ? indexValue + 1 : indexValue;\n                                laneIndex += (actualShape.phases && actualShape.phaseSize) ? 1 : 0;\n                                grid.updateRowHeight(laneIndex, newLane.height, true, padding);\n                                this.updateDiagramElementQuad();\n                            }\n                        }\n                    }\n                    if (shape.phases) {\n                        for (var _d = 0, _e = Object.keys(shape.phases); _d < _e.length; _d++) {\n                            var key = _e[_d];\n                            var indexValue = Number(key);\n                            var phase = shape.phases[parseInt(indexValue.toString(), 10)];\n                            var size = void 0;\n                            var rowIndex = (actualShape.header && actualShape.hasHeader) ? 1 : 0;\n                            if (phase && phase.header) {\n                                id = actualShape.phases[parseInt(indexValue.toString(), 10)].header.id;\n                                oldObjects = oldShape.phases[parseInt(indexValue.toString(), 10)].header;\n                                newObjects = phase.header;\n                                // EJ2-913790  Save Load for header font change won't be as saved\n                                if (newObjects.annotation && newObjects.annotation.content) {\n                                    this.nameTable[\"\" + id].annotations[0].content = newObjects.annotation.content;\n                                }\n                                if (newObjects.annotation && newObjects.annotation.style) {\n                                    this.nameTable[\"\" + id].annotations[0].style = newObjects.annotation.style;\n                                }\n                                this.nodePropertyChange(this.nameTable[\"\" + id], oldObjects, newObjects);\n                            }\n                            if (phase.offset) {\n                                if (indexValue === 0) {\n                                    size = phase.offset;\n                                }\n                                else {\n                                    var previousPhase = actualShape.phases[indexValue - 1];\n                                    size = phase.offset - previousPhase.offset;\n                                    if (size <= 0) {\n                                        size = phase.offset;\n                                    }\n                                }\n                                if (orientation_1) {\n                                    grid.updateColumnWidth(indexValue, size, true, padding);\n                                    (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.updatePhaseMaxWidth)(actualObject, this, grid.rows[parseInt(rowIndex.toString(), 10)].cells[parseInt(indexValue.toString(), 10)], indexValue);\n                                }\n                                else {\n                                    grid.updateRowHeight(rowIndex + indexValue, size, true, padding);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (shape.phaseSize !== undefined && actualShape.phases.length) {\n                    if (shape.phaseSize === 0 || oldShape.phaseSize === 0) {\n                        if (oldShape.phaseSize) {\n                            if (orientation_1) {\n                                grid.removeRow((actualShape.header && actualShape.hasHeader) ? 1 : 0);\n                                actualObject.height = actualObject.wrapper.height = grid.height;\n                            }\n                            else {\n                                if (actualShape.header && actualShape.hasHeader) {\n                                    grid.rows[0].cells[1].children = grid.rows[0].cells[0].children;\n                                    grid.rows[0].cells[1].columnSpan = grid.rows[0].cells[0].columnSpan - 1;\n                                    grid.rows[0].cells[0].children = [];\n                                }\n                                grid.removeColumn(0);\n                            }\n                        }\n                        else {\n                            if (orientation_1) {\n                                var rowDef = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_21__.RowDefinition();\n                                rowDef.height = shape.phaseSize;\n                                grid.addRow((actualShape.header && actualShape.hasHeader) ? 1 : 0, rowDef, true);\n                                actualObject.height = actualObject.wrapper.height += shape.phaseSize;\n                            }\n                            else {\n                                var colDef = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_21__.ColumnDefinition();\n                                colDef.width = shape.phaseSize;\n                                grid.addColumn(0, colDef, true);\n                                if (actualShape.header && actualShape.hasHeader) {\n                                    grid.rows[0].cells[0].children = grid.rows[0].cells[1].children;\n                                    grid.rows[0].cells[1].children = [];\n                                    grid.rows[0].cells[1].columnSpan = 1;\n                                    grid.rows[0].cells[1].minWidth = undefined;\n                                    grid.rows[0].cells[0].columnSpan = actualShape.lanes.length + 1;\n                                }\n                            }\n                            for (var k = 0; k < actualShape.phases.length; k++) {\n                                if (actualShape.phases[parseInt(k.toString(), 10)].id === '') {\n                                    actualShape.phases[parseInt(k.toString(), 10)].id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n                                }\n                                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.phaseDefine)(grid, this, actualObject, (actualShape.header && actualShape.hasHeader) ? 1 : 0, orientation_1, k);\n                            }\n                        }\n                    }\n                    else {\n                        if (orientation_1) {\n                            grid.updateRowHeight((actualShape.header && actualShape.hasHeader) ? 1 : 0, shape.phaseSize, false);\n                        }\n                        else {\n                            grid.updateColumnWidth(0, shape.phaseSize, false);\n                        }\n                    }\n                }\n                if (actualShape.header && actualShape.hasHeader && oldShape.header) {\n                    var id_1 = grid.rows[0].cells[0].children[0].id;\n                    var headerNode = this.nameTable[\"\" + id_1];\n                    this.nodePropertyChange(headerNode, (oldShape.header), shape.header);\n                }\n                actualObject.height = actualObject.wrapper.height = grid.height;\n                actualObject.width = actualObject.wrapper.width = grid.width;\n            }\n            else if (oldObject.constraints) {\n                var oldSelectConstraints = (oldObject.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select);\n                var newSelectConstraints = (node.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select);\n                if (oldSelectConstraints !== newSelectConstraints) {\n                    var shape = actualObject.shape;\n                    // Header - constraints\n                    var headerNode = this.nameTable[actualObject.id + shape.header.id];\n                    headerNode.constraints = (!newSelectConstraints) ? headerNode.constraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select :\n                        headerNode.constraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select;\n                    // Phase - Constraints\n                    var phaseNode = void 0;\n                    if (shape.phaseSize > 0) {\n                        for (var i = 0; i < shape.phases.length; i++) {\n                            phaseNode = this.nameTable[actualObject.id + shape.phases[parseInt(i.toString(), 10)].id + '_header'];\n                            phaseNode.constraints = (!newSelectConstraints) ? phaseNode.constraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select :\n                                phaseNode.constraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select;\n                        }\n                    }\n                    // Header - Constraints\n                    var laneNode = void 0;\n                    var laneHeader = void 0;\n                    var value = shape.phases.length || 1;\n                    for (var i = 0; i < shape.lanes.length; i++) {\n                        for (var l = 0; l < value; l++) {\n                            laneNode = this.nameTable[actualObject.id + shape.lanes[parseInt(i.toString(), 10)].id + l];\n                            laneNode.constraints = (!newSelectConstraints) ? laneNode.constraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select :\n                                laneNode.constraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select;\n                            if (l === 0) {\n                                laneHeader = this.nameTable[actualObject.id + shape.lanes[parseInt(i.toString(), 10)].id + '_' + l + '_header'];\n                                laneHeader.constraints = (!newSelectConstraints) ? laneHeader.constraints & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select :\n                                    laneHeader.constraints | _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Select;\n                            }\n                        }\n                    }\n                }\n            }\n            update = true;\n        }\n        return update;\n    };\n    /** @private */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Diagram.prototype.insertValue = function (oldNodeObject, isNode) {\n        if (!(this.blazorActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.BlazorAction.GroupClipboardInProcess)) {\n            var value = void 0;\n            var oldObjects = isNode ? this.oldNodeObjects : this.oldConnectorObjects;\n            for (var i = 0; i < oldObjects.length; i++) {\n                if (oldObjects[parseInt(i.toString(), 10)].id === oldNodeObject.id) {\n                    value = true;\n                }\n            }\n            if (!value) {\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                isNode ? (this.oldNodeObjects.push(oldNodeObject)) : this.oldConnectorObjects.push(oldNodeObject);\n            }\n        }\n    };\n    /* tslint:disable */\n    /** @private */\n    // eslint-disable-next-line max-len\n    Diagram.prototype.nodePropertyChange = function (actualObject, oldObject, node, isLayout, rotate, propertyChange) {\n        if (this.canEnableBlazorObject && actualObject.id !== 'helper') {\n            var node_2 = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(actualObject);\n            this.insertValue(node_2, true);\n        }\n        var existingBounds = actualObject.wrapper.outerBounds;\n        var existingInnerBounds = actualObject.wrapper.bounds;\n        var updateConnector = false;\n        var i;\n        var j;\n        var offsetX;\n        var offsetY;\n        var update;\n        var tx;\n        var ty;\n        var oldBpmnOffsetX = 0;\n        var newBpmnOffsetX = 0;\n        var oldBpmnOffsetY = 0;\n        var newBpmnOffsetY = 0;\n        var sizeChanged = false;\n        var offsetChanged = false;\n        var angleChanged = false;\n        if (node.width !== undefined) {\n            if (!actualObject.children) {\n                actualObject.wrapper.children[0].width = node.width;\n                update = true;\n                updateConnector = true;\n            }\n            else if (!actualObject.container) {\n                this.scaleObject(actualObject, node.width, true);\n            }\n            else {\n                actualObject.wrapper.width = node.width;\n            }\n            sizeChanged = true;\n        }\n        if (node.height !== undefined) {\n            if (!actualObject.children) {\n                actualObject.wrapper.children[0].height = node.height;\n                update = true;\n                updateConnector = true;\n            }\n            else if (!actualObject.container) {\n                this.scaleObject(actualObject, node.height, false);\n            }\n            else {\n                actualObject.wrapper.height = node.height;\n            }\n            sizeChanged = true;\n        }\n        update = this.nodePropertyChangeExtend(actualObject, oldObject, node, update);\n        if (node.constraints !== undefined && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canShadow)(oldObject) !== (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canShadow)(node)) {\n            actualObject.wrapper.children[0].shadow = (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canShadow)(actualObject) ? actualObject.shadow : null;\n        }\n        if (node.offsetX !== undefined) {\n            oldBpmnOffsetX = oldObject.offsetX;\n            newBpmnOffsetX = node.offsetX;\n            if (actualObject.wrapper.flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None) {\n                if (actualObject.offsetX !== actualObject.wrapper.offsetX && oldObject.offsetX !== undefined) {\n                    var offsetX_1 = node.offsetX - oldObject.offsetX;\n                    actualObject.wrapper.offsetX = actualObject.wrapper.offsetX + offsetX_1;\n                    this.updateFlipOffset(actualObject.wrapper, offsetX_1, 0, actualObject.wrapper.flip);\n                }\n                //EJ2-895070: Flipping and moving the node are not working properly\n                else {\n                    actualObject.wrapper.offsetX = node.offsetX;\n                }\n            }\n            else {\n                actualObject.wrapper.offsetX = node.offsetX;\n            }\n            update = true;\n            updateConnector = true;\n            offsetChanged = true;\n        }\n        if (node.offsetY !== undefined) {\n            oldBpmnOffsetY = oldObject.offsetY;\n            newBpmnOffsetY = node.offsetY;\n            if (actualObject.wrapper.flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None) {\n                if (actualObject.offsetY !== actualObject.wrapper.offsetY && oldObject.offsetY !== undefined) {\n                    var offsetY_1 = node.offsetY - oldObject.offsetY;\n                    actualObject.wrapper.offsetY = actualObject.wrapper.offsetY + offsetY_1;\n                    this.updateFlipOffset(actualObject.wrapper, 0, offsetY_1, actualObject.wrapper.flip);\n                }\n                //EJ2-895070: Flipping and moving the node are not working properly\n                else {\n                    actualObject.wrapper.offsetY = node.offsetY;\n                }\n            }\n            else {\n                actualObject.wrapper.offsetY = node.offsetY;\n            }\n            update = true;\n            updateConnector = true;\n            offsetChanged = true;\n        }\n        if (node.padding !== undefined) {\n            actualObject.wrapper.padding.left = node.padding.left !== undefined ? node.padding.left : actualObject.wrapper.padding.left;\n            actualObject.wrapper.padding.right = node.padding.right !== undefined ? node.padding.right : actualObject.wrapper.padding.right;\n            actualObject.wrapper.padding.top = node.padding.top !== undefined ? node.padding.top : actualObject.wrapper.padding.top;\n            actualObject.wrapper.padding.bottom = node.padding.bottom !== undefined ? node.padding.bottom\n                : actualObject.wrapper.padding.bottom;\n            update = true;\n        }\n        if (node.pivot !== undefined) {\n            actualObject.wrapper.pivot = node.pivot;\n            update = true;\n        }\n        if (node.minWidth !== undefined) {\n            actualObject.wrapper.minWidth = actualObject.wrapper.children[0].minWidth = node.minWidth;\n            update = true;\n            updateConnector = true;\n            sizeChanged = true;\n        }\n        if (node.minHeight !== undefined) {\n            actualObject.wrapper.minHeight = actualObject.wrapper.children[0].minHeight = node.minHeight;\n            update = true;\n            updateConnector = true;\n            sizeChanged = true;\n        }\n        if (node.maxWidth !== undefined) {\n            actualObject.wrapper.maxWidth = node.maxWidth;\n            update = true;\n            updateConnector = true;\n            sizeChanged = true;\n        }\n        if (node.maxHeight !== undefined) {\n            actualObject.wrapper.maxHeight = node.maxHeight;\n            update = true;\n            updateConnector = true;\n            sizeChanged = true;\n        }\n        if (node.flip !== undefined) {\n            var horizontal = ((node.flip & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Horizontal) ^\n                (actualObject.wrapper.flip & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Horizontal)) === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Horizontal;\n            var vertical = ((node.flip & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Vertical) ^\n                (actualObject.wrapper.flip & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Vertical)) === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Vertical;\n            if (horizontal) {\n                actualObject.wrapper.flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Horizontal;\n            }\n            if (vertical) {\n                actualObject.wrapper.flip ^= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Vertical;\n            }\n            update = true;\n            updateConnector = true;\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.alignElement)(actualObject.wrapper, actualObject.offsetX, actualObject.offsetY, this, undefined, horizontal, vertical);\n            //To update the port and text wrapper element flip\n            this.updateWrapperChildFlip(actualObject);\n        }\n        if (node.flipMode !== undefined) {\n            var changeFlipMode = '';\n            changeFlipMode = actualObject.wrapper.flipMode = node.flipMode;\n            update = true;\n            updateConnector = true;\n            //To update the port and text wrapper element flip mode\n            this.updateWrapperChildFlip(actualObject, changeFlipMode);\n        }\n        if (node.rotateAngle !== undefined && (actualObject.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.NodeConstraints.Rotate)) {\n            if (actualObject.children && rotate) {\n                // eslint-disable-next-line max-len\n                this.commandHandler.rotateObjects(actualObject, [actualObject], actualObject.rotateAngle - actualObject.wrapper.rotateAngle, { x: actualObject.offsetX, y: actualObject.offsetY }, false);\n            }\n            actualObject.wrapper.rotateAngle = node.rotateAngle;\n            update = true;\n            updateConnector = true;\n            angleChanged = true;\n        }\n        if (node.backgroundColor !== undefined) {\n            actualObject.wrapper.style.fill = node.backgroundColor;\n        }\n        if (node.visible !== undefined) {\n            this.updateElementVisibility(actualObject.wrapper, actualObject, actualObject.visible);\n        }\n        if (node.shape !== undefined && actualObject.shape.type !== 'Bpmn') {\n            update = true;\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateShape)(node, actualObject, oldObject, this);\n            updateConnector = true;\n        }\n        if (node.margin) {\n            update = true;\n            this.updateMargin(actualObject, node);\n            updateConnector = true;\n            offsetChanged = true;\n        }\n        if ((((node.shape !== undefined && (node.shape.type === undefined)) || node.width !== undefined || node.height !== undefined ||\n            node.style !== undefined) && actualObject.shape.type === 'Bpmn' && this.bpmnModule)) {\n            update = true;\n            updateConnector = true;\n            this.bpmnModule.updateBPMN(node, oldObject, actualObject, this);\n        }\n        if (actualObject.shape.type === 'UmlActivity' && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)() && actualObject.shape.shape === 'FinalNode'))) {\n            update = true;\n            updateConnector = true;\n            this.updateUMLActivity(node, oldObject, actualObject, this);\n        }\n        if ((actualObject.shape && actualObject.shape.type === 'UmlClassifier') || (actualObject.parentId &&\n            this.nameTable[actualObject.parentId] && this.nameTable[actualObject.parentId].shape.type === 'UmlClassifier')) {\n            update = true;\n            updateConnector = true;\n        }\n        if (node.ports !== undefined) {\n            for (var _i = 0, _a = Object.keys(node.ports); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var index = Number(key);\n                update = true;\n                var changedObject = node.ports[\"\" + key];\n                var actualPort = actualObject.ports[parseInt(index.toString(), 10)];\n                this.updatePort(changedObject, actualPort, actualObject.wrapper);\n                if (actualObject.flip !== _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None) {\n                    if (actualObject.flipMode === 'Port' || actualObject.flipMode === 'PortAndLabel' || actualObject.flipMode === 'PortAndLabelText' || actualObject.flipMode === 'All') {\n                        this.updatePorts(actualObject, actualObject.flip);\n                    }\n                }\n                updateConnector = true;\n            }\n        }\n        if (node.annotation !== undefined || node.annotations !== undefined || node.width !== undefined) {\n            for (var _b = 0, _c = Object.keys(node.annotations || actualObject.annotations); _b < _c.length; _b++) {\n                var key = _c[_b];\n                var index = Number(key);\n                update = true;\n                var changedObject = void 0;\n                if (node.annotation) {\n                    changedObject = node.annotation;\n                }\n                else {\n                    changedObject = node.annotations ? node.annotations[\"\" + key] : actualObject.annotations;\n                }\n                var actualAnnotation = actualObject.annotations[parseInt(index.toString(), 10)];\n                if (actualAnnotation) {\n                    var updateSize = actualObject.width ? true : false;\n                    this.updateAnnotation(changedObject, actualAnnotation, actualObject.wrapper, actualObject, updateSize);\n                    var swimLaneNode = this.nameTable[actualObject.parentId];\n                    if ((swimLaneNode && swimLaneNode.shape.type === 'SwimLane')) {\n                        var laneHeader = 'LaneHeaderParent';\n                        var phaseHeader = 'PhaseHeaderParent';\n                        if ((actualObject.isLane || actualObject.isPhase)) {\n                            var collection = actualObject.isLane ?\n                                swimLaneNode.shape.lanes : swimLaneNode.shape.phases;\n                            for (var j_2 = 0; j_2 < collection.length; j_2++) {\n                                if (collection[parseInt(j_2.toString(), 10)].id === (actualObject[\"\" + laneHeader] || actualObject[\"\" + phaseHeader])) {\n                                    collection[parseInt(j_2.toString(), 10)].header.annotation.content = actualObject.annotations[0].content;\n                                    collection[parseInt(j_2.toString(), 10)].header.annotation.style = actualObject.annotations[0].style;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (node.expandIcon !== undefined || node.collapseIcon !== undefined || node.isExpanded !== undefined) {\n            this.updateIcon(actualObject);\n            this.updateDefaultLayoutIcons(actualObject);\n            if (node.isExpanded !== undefined) {\n                this.canExpand = true;\n                //EJ2-844814 - Expand and collapse not working properly at runtime\n                this.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventIconsUpdate;\n                this.commandHandler.expandNode(actualObject, this);\n                this.diagramActions = this.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventIconsUpdate;\n            }\n            update = true;\n            this.canExpand = false;\n        }\n        if (node.fixedUserHandles !== undefined) {\n            var index = void 0;\n            var changedObject = void 0;\n            var actualfixedUserHandle = void 0;\n            for (var _d = 0, _e = Object.keys(node.fixedUserHandles); _d < _e.length; _d++) {\n                var key = _e[_d];\n                index = Number(key);\n                update = true;\n                if (node.fixedUserHandles[parseInt(index.toString(), 10)]) {\n                    changedObject = node.fixedUserHandles[parseInt(index.toString(), 10)];\n                }\n                actualfixedUserHandle = actualObject.fixedUserHandles[parseInt(index.toString(), 10)];\n                if (actualfixedUserHandle) {\n                    this.updateNodefixedUserHandle(changedObject, actualfixedUserHandle, actualObject.wrapper, actualObject);\n                }\n            }\n        }\n        if (node.tooltip !== undefined) {\n            this.updateTooltip(actualObject, node);\n        }\n        if (update) {\n            if (this.bpmnModule !== undefined && (offsetChanged || sizeChanged) && !angleChanged) {\n                // eslint-disable-next-line max-len\n                this.updateBpmnAnnotationPosition(oldBpmnOffsetX, oldBpmnOffsetY, newBpmnOffsetX, newBpmnOffsetY, actualObject, actualObject.wrapper, actualObject.shape, actualObject.shape.shape === 'TextAnnotation', oldObject, sizeChanged, this.sizeUndo);\n            }\n            if (this.checkSelectedItem(actualObject) && actualObject.wrapper.children[0] instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) {\n                actualObject.wrapper.children[0].refreshTextElement();\n            }\n            actualObject.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(actualObject.wrapper.bounds.width, actualObject.wrapper.bounds.height), actualObject.id, this.onLoadImageSize.bind(this));\n            actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);\n            this.updateObject(actualObject, oldObject, node);\n            if (actualObject.shape.type === 'SwimLane' && !this.currentSymbol && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)) {\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.updateHeaderMaxWidth)(this, actualObject);\n                var grid = actualObject.wrapper.children[0];\n                var shape = actualObject.shape;\n                var column = grid.columnDefinitions().length;\n                if (shape.orientation === 'Horizontal') {\n                    var index = (shape.header && shape.hasHeader) ? 1 : 0;\n                    (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.updatePhaseMaxWidth)(actualObject, this, grid.rows[parseInt(index.toString(), 10)].cells[column - 1], column - 1);\n                }\n                actualObject.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(actualObject.wrapper.bounds.width, actualObject.wrapper.bounds.height));\n                actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);\n            }\n            if ((!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)) || (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo)) {\n                if (this.checkSelectedItem(actualObject)) {\n                    this.updateSelector();\n                }\n            }\n            if (existingBounds.equals(existingBounds, actualObject.wrapper.outerBounds) === false) {\n                this.updateQuad(actualObject);\n                // EJ2-57436 - Added the below code to check if node has parent id or not.\n                // If node has parentId means then send the parent node to updatequad method to add the parent node in negative quadrant\n                if (actualObject.parentId && this.nameTable[actualObject.parentId]) {\n                    var parentNode = this.nameTable[actualObject.parentId];\n                    this.updateQuad(parentNode);\n                }\n            }\n            if (!isLayout) {\n                // eslint-disable-next-line max-len\n                this.commandHandler.connectorSegmentChange(actualObject, existingInnerBounds, (node.rotateAngle !== undefined) ? true : false);\n                // if (updateConnector) {\n                //     this.updateConnectorEdges(actualObject);\n                // }\n            }\n            else {\n                if (actualObject && actualObject.visible && actualObject.outEdges) {\n                    this.updateIconVisibility(actualObject, (actualObject.outEdges.length === 0 ? false : true));\n                }\n            }\n            if (this.bpmnModule !== undefined) {\n                this.bpmnModule.updateDocks(actualObject, this);\n            }\n            if ((!node.annotations || !actualObject.processId) && node.flip === undefined) {\n                this.updateGroupOffset(actualObject);\n            }\n            // if (existingBounds.equals(existingBounds, actualObject.wrapper.outerBounds) === false) { this.updateQuad(actualObject); }\n            // EJ2-42005 - The parent of the actualObject is not measured and arranged when a node or connector is selected.\n            // The condition restricts the measure and arrange of the actualObject whenever a node or connector is selected.\n            // Commented @Dheepshiva\n            // let objects: (NodeModel | ConnectorModel)[] = [];\n            // objects = objects.concat(this.selectedItems.nodes, this.selectedItems.connectors);\n            // if (objects.length === 0) {\n            if (actualObject.parentId && this.nameTable[actualObject.parentId]) {\n                var parent_6 = this.nameTable[actualObject.parentId];\n                parent_6.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(parent_6.wrapper.width, actualObject.wrapper.height));\n                parent_6.wrapper.arrange(parent_6.wrapper.desiredSize);\n                parent_6.offsetX = parent_6.wrapper.offsetX;\n                parent_6.offsetY = parent_6.wrapper.offsetY;\n            }\n            // }\n            if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {\n                if (this.eventHandler.currentAction !== 'Drag') {\n                    this.updateGroupSize(actualObject);\n                }\n                if (actualObject.children) {\n                    this.updateGroupOffset(actualObject);\n                }\n            }\n            if (actualObject.shape.type === 'SwimLane' && !this.currentSymbol && (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render)) {\n                var connectors = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.getConnectors)(this, actualObject.wrapper.children[0], undefined, true);\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_39__.updateConnectorsProperties)(connectors, this);\n            }\n            if (!this.preventNodesUpdate) {\n                if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) && this.scroller.oldCollectionObjects.indexOf(actualObject.id) > -1)) {\n                    if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventZIndexOnDragging) {\n                        this.updateDiagramObject(actualObject, true);\n                    }\n                    else {\n                        this.updateDiagramObject(actualObject);\n                    }\n                    if (actualObject.parentId) {\n                        var parent_7 = this.nameTable[actualObject.parentId];\n                        if (parent_7.shape.type !== 'BPMN') {\n                            if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventZIndexOnDragging) {\n                                this.updateDiagramObject(parent_7, true);\n                            }\n                            else {\n                                this.updateDiagramObject(parent_7);\n                            }\n                        }\n                    }\n                }\n                if (!isLayout && updateConnector) {\n                    if (this.lineRoutingModule && this.diagramActions && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting) && actualObject.id !== 'helper') {\n                        if (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)) {\n                            this.lineRoutingModule.renderVirtualRegion(this, true);\n                        }\n                    }\n                    else if (this.diagramActions && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting) && actualObject.id !== 'helper') {\n                        console.warn('[WARNING] :: Module \"LineRouting\" is not available in Diagram component! You either misspelled the module name or forgot to load it.');\n                    }\n                    this.updateConnectorEdges(actualObject);\n                    if (actualObject.id !== 'helper' && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)) {\n                        var objects = this.spatialSearch.findObjects(actualObject.wrapper.outerBounds);\n                        for (var i_4 = 0; i_4 < objects.length; i_4++) {\n                            var object = objects[parseInt(i_4.toString(), 10)];\n                            if (object instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                                this.connectorPropertyChange(objects[parseInt(i_4.toString(), 10)], {}, {\n                                    sourceID: object.sourceID,\n                                    targetID: object.targetID,\n                                    sourcePortID: object.sourcePortID,\n                                    targetPortID: object.targetPortID,\n                                    sourcePoint: object.sourcePoint,\n                                    targetPoint: object.targetPoint\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            if (actualObject.status !== 'New' && this.diagramActions) {\n                actualObject.status = 'Update';\n            }\n        }\n        if (!propertyChange) {\n            var element = actualObject;\n            var args = {\n                element: element, cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),\n                oldValue: oldObject, newValue: node\n            };\n            //Removed isBlazor code\n            this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.propertyChange, args);\n        }\n    };\n    Diagram.prototype.updateWrapperChildFlip = function (actualObject, changeFlipMode) {\n        if (actualObject && actualObject.children && actualObject.children.length > 0) {\n            for (var i = 0; i < actualObject.children.length; i++) {\n                var child = actualObject.children[parseInt(i.toString(), 10)];\n                var updateNode = this.nameTable[\"\" + child];\n                var modifiedFlipMode = '';\n                if (!changeFlipMode) {\n                    modifiedFlipMode = updateNode.flipMode;\n                }\n                else {\n                    modifiedFlipMode = changeFlipMode;\n                    updateNode.wrapper.flipMode = modifiedFlipMode;\n                    updateNode.flipMode = modifiedFlipMode;\n                }\n                if (modifiedFlipMode === 'None' || modifiedFlipMode === 'Label' || modifiedFlipMode === 'LabelText' || modifiedFlipMode === 'LabelAndLabelText') {\n                    this.updatePorts(updateNode, _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None);\n                }\n                else {\n                    this.updatePorts(updateNode, updateNode.wrapper.flip);\n                }\n                //To update the wrapper of node with flip and flip mode.\n                this.updateWrapperFlip(updateNode.wrapper, updateNode);\n            }\n        }\n        changeFlipMode = actualObject.flipMode;\n        if (changeFlipMode === 'None' || changeFlipMode === 'Label' || changeFlipMode === 'LabelText' || changeFlipMode === 'LabelAndLabelText') {\n            this.updatePorts(actualObject, _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None);\n        }\n        else {\n            this.updatePorts(actualObject, actualObject.wrapper.flip);\n        }\n        var wrapperCanvas;\n        if (actualObject.children) {\n            wrapperCanvas = actualObject.wrapper.children[actualObject.wrapper.children.length - 1];\n        }\n        else {\n            wrapperCanvas = actualObject.wrapper;\n        }\n        wrapperCanvas.flip = actualObject.wrapper.flip;\n        wrapperCanvas.flipMode = actualObject.flipMode;\n        //To update the wrapper of node with flip and flip mode.\n        this.updateWrapperFlip(wrapperCanvas, actualObject);\n    };\n    Diagram.prototype.updateWrapperFlip = function (wrapperCanvas, obj) {\n        for (var k = 0; k < wrapperCanvas.children.length; k++) {\n            var wrapperChild = wrapperCanvas.children[parseInt(k.toString(), 10)];\n            if (wrapperChild instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_16__.TextElement) {\n                if (obj.flipMode !== 'None' && obj.flipMode !== 'Port') {\n                    wrapperChild.flip = obj.wrapper.flip;\n                    wrapperChild.flipMode = obj.flipMode;\n                }\n                else {\n                    wrapperChild.flip = _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.None;\n                }\n            }\n            else if (wrapperChild instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas) {\n                this.applyWrapperCanvasFlip(wrapperChild, obj);\n            }\n        }\n    };\n    //Get resize handle name based on the old and new size properties of node.\n    Diagram.prototype.getResizeHandle = function (oldX, oldY, oldWidth, oldHeight, newX, newY, newWidth, newHeight) {\n        var dx = newX - oldX;\n        var dy = newY - oldY;\n        var dw = newWidth - oldWidth;\n        var dh = newHeight - oldHeight;\n        if (dh === 0 && ((dx > 0 && dw > 0) || (dx < 0 && dw < 0))) {\n            return 'ResizeEast';\n        }\n        if (dh === 0 && ((dx > 0 && dw < 0) || (dx < 0 && dw > 0))) {\n            return 'ResizeWest';\n        }\n        // **North & South Handles (Height Change Only)**\n        if (dw === 0 && ((dy > 0 && dh < 0) || (dy < 0 && dh > 0))) {\n            return 'ResizeNorth';\n        }\n        if (dw === 0 && ((dy > 0 && dh > 0) || (dy < 0 && dh < 0))) {\n            return 'ResizeSouth';\n        }\n        // **Diagonal Resizing (Both Width & Height Change)**\n        if (((dx > 0 && dw > 0) || (dx < 0 && dw < 0)) && ((dy > 0 && dh > 0) || (dy < 0 && dh < 0))) {\n            return 'ResizeSouthEast'; // Bottom-right\n        }\n        if (((dx > 0 && dw < 0) || (dx < 0 && dw > 0)) && ((dy > 0 && dh > 0) || (dy < 0 && dh < 0))) {\n            return 'ResizeSouthWest'; // Bottom-left\n        }\n        if (((dx > 0 && dw > 0) || (dx < 0 && dw < 0)) && ((dy > 0 && dh < 0) || (dy < 0 && dh > 0))) {\n            return 'ResizeNorthEast'; // Top-right\n        }\n        if (((dx > 0 && dw < 0) || (dx < 0 && dw > 0)) && ((dy > 0 && dh < 0) || (dy < 0 && dh > 0))) {\n            return 'ResizeNorthWest'; // Top-left\n        }\n        return null;\n    };\n    /**\n     * To get new offset used to calculate the text annotation offset while resizing the parent node.\n     * getTextAnnotationOffset method \\\n     *\n     * @param {Node} actualObject - The current state of the parent node being resized.\n     * @param {NodeModel} textAnnotation - The text annotation attached to the parent node.\n     * @param {Node} oldObject - The previous state of the parent node before resizing.\n     * @param {number} oldBpmnOffsetX - The previous X offset.\n     * @param {number} oldBpmnOffsetY - The previous Y offset.\n     * @returns { PointModel }    - Returns new offset\n     *\n     * @private\n     */\n    Diagram.prototype.getTextAnnotationOffset = function (actualObject, textAnnotation, oldObject, oldBpmnOffsetX, oldBpmnOffsetY) {\n        var sx = actualObject.width - oldObject.width;\n        var sy = actualObject.height - oldObject.height;\n        var side = this.getTextAnnotationQuadrant(actualObject, textAnnotation);\n        var resizeSide = this.getResizeHandle(oldObject.offsetX, oldObject.offsetY, oldObject.width, oldObject.height, actualObject.offsetX, actualObject.offsetY, actualObject.width, actualObject.height);\n        var dx = 0;\n        var dy = 0;\n        var needsXAdjustment = function (side) {\n            if (resizeSide === 'ResizeEast' || resizeSide === 'ResizeNorthEast' || resizeSide === 'ResizeSouthEast') {\n                return side.includes('East');\n            }\n            if (resizeSide === 'ResizeWest' || resizeSide === 'ResizeNorthWest' || resizeSide === 'ResizeSouthWest') {\n                return side.includes('West');\n            }\n            return false;\n        };\n        var needsYAdjustment = function (side) {\n            if (resizeSide === 'ResizeSouth' || resizeSide === 'ResizeSouthWest' || resizeSide === 'ResizeSouthEast') {\n                return side.includes('South');\n            }\n            if (resizeSide === 'ResizeNorth' || resizeSide === 'ResizeNorthWest' || resizeSide === 'ResizeNorthEast') {\n                return side.includes('North');\n            }\n            return false;\n        };\n        if (needsXAdjustment(side)) {\n            dx = (resizeSide.includes('West') ? -sx : sx);\n        }\n        if (needsYAdjustment(side)) {\n            dy = (resizeSide.includes('North') ? -sy : sy);\n        }\n        return { x: oldBpmnOffsetX + dx, y: oldBpmnOffsetY + dy };\n    };\n    //To get which side the text annotation node is placed based on its parent node\n    Diagram.prototype.getTextAnnotationQuadrant = function (parent, textAnnotation) {\n        var left = parent.wrapper.bounds.left;\n        var right = parent.wrapper.bounds.right;\n        var top = parent.wrapper.bounds.top;\n        var bottom = parent.wrapper.bounds.bottom;\n        var textX = textAnnotation.wrapper.bounds.center.x;\n        var textY = textAnnotation.wrapper.bounds.center.y;\n        // Check if exactly aligned with any edge\n        if (textX >= left && textX <= right) {\n            if (textY < top) {\n                return 'North';\n            }\n            if (textY > bottom) {\n                return 'South';\n            }\n        }\n        if (textY >= top && textY <= bottom) {\n            if (textX < left) {\n                return 'West';\n            }\n            if (textX > right) {\n                return 'East';\n            }\n        }\n        // Quadrants\n        if (textX < left && textY < top) {\n            return 'NorthWest';\n        }\n        if (textX > right && textY < top) {\n            return 'NorthEast';\n        }\n        if (textX < left && textY > bottom) {\n            return 'SouthWest';\n        }\n        if (textX > right && textY > bottom) {\n            return 'SouthEast';\n        }\n        return '';\n    };\n    //To update text annotation position while dragging the text annotation's parent node.\n    Diagram.prototype.updateBpmnAnnotationPosition = function (oldX, oldY, newX, newY, node, wrapper, shape, isTextAnnotation, oldObject, sizeChanged, isUndo) {\n        var x = newX > oldX ? Math.abs(newX - oldX) : Math.abs(oldX - newX);\n        var y = newY > oldY ? Math.abs(newY - oldY) : Math.abs(oldY - newY);\n        var laneX;\n        var laneY;\n        if ((x === 0 && y === 0) || (Number.isNaN(x) && Number.isNaN(y))) {\n            if (node.laneMargin) {\n                laneX = node.margin.left - node.laneMargin.left;\n                laneY = node.margin.top - node.laneMargin.top;\n            }\n        }\n        var width = node.width;\n        var height = node.height;\n        var bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect(0, 0, 0, 0);\n        if (width !== 0 && height !== 0) {\n            bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect((newX !== 0 ? newX : node.offsetX) - width / 2, (newY !== 0 ? newY : node.offsetY) - height / 2, width, height);\n        }\n        //To update text annotation position\n        if (isTextAnnotation) {\n            var bpmnAnnotation = shape;\n            var hasTarget = bpmnAnnotation.textAnnotation.textAnnotationTarget !== '' && this.nameTable[bpmnAnnotation.textAnnotation.textAnnotationTarget];\n            var selectedNode = this.selectedItems.nodes ? this.selectedItems.nodes[0] : undefined;\n            var isTextNodeSelected = selectedNode && selectedNode.shape && selectedNode.shape.shape === 'TextAnnotation';\n            if (hasTarget) {\n                //To check whether the text annotation inside the swimlane\n                if (node.parentId === '' || isTextNodeSelected) {\n                    if (bpmnAnnotation.textAnnotation.textAnnotationDirection === 'Auto') {\n                        if (wrapper.children[0] instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas && wrapper.children[0].children[0] instanceof _core_elements_path_element__WEBPACK_IMPORTED_MODULE_15__.PathElement) {\n                            var diagramCanvas = wrapper.children[0];\n                            var parentElement = document.getElementById(diagramCanvas.id + '_groupElement');\n                            var elementToRemove = document.getElementById(diagramCanvas.children[0].id + '_groupElement');\n                            parentElement.removeChild(elementToRemove);\n                            diagramCanvas.children.splice(0, 1);\n                            this.isProtectedOnChange = true;\n                            this.bpmnModule.setAnnotationPath(bounds, diagramCanvas, node, bpmnAnnotation, bpmnAnnotation.textAnnotation.textAnnotationDirection, this);\n                            this.isProtectedOnChange = false;\n                        }\n                    }\n                }\n                else {\n                    this.isPositionUndo = true;\n                    this.updateTextAnnotationInSwimlane(node, node);\n                    this.isPositionUndo = false;\n                }\n            }\n            else { //To update text annotation connector source point.\n                if (node.inEdges.length > 0) {\n                    var connectorID = node.inEdges[0];\n                    var connector = this.nameTable[\"\" + connectorID];\n                    if (connector && connector.isBpmnAnnotationConnector) {\n                        connector.sourcePoint =\n                            {\n                                x: newX > oldX ? connector.sourcePoint.x + x : connector.sourcePoint.x - x,\n                                y: newY > oldY ? connector.sourcePoint.y + y : connector.sourcePoint.y - y\n                            };\n                    }\n                }\n            }\n            var newValue = { ports: [{ offset: node.ports[0].offset }] };\n            //To update port offset of text annotation node\n            this.nodePropertyChange(node, {}, newValue);\n        }\n        else {\n            for (var _i = 0, _a = node.outEdges; _i < _a.length; _i++) {\n                var id = _a[_i];\n                var connector = this.nameTable[\"\" + id];\n                if (connector && connector.isBpmnAnnotationConnector) {\n                    var targetNode = this.nameTable[connector.targetID];\n                    var textAnnotationTargetId = targetNode.shape.textAnnotation.textAnnotationTarget;\n                    var textAnnotationTarget = this.nameTable[\"\" + textAnnotationTargetId];\n                    if (sizeChanged && !isUndo) {\n                        var newResizeOffset = this.getTextAnnotationOffset(node, targetNode, oldObject, oldX, oldY);\n                        newX = newResizeOffset.x;\n                        newY = newResizeOffset.y;\n                        x = newX > oldX ? Math.abs(newX - oldX) : Math.abs(oldX - newX);\n                        y = newY > oldY ? Math.abs(newY - oldY) : Math.abs(oldY - newY);\n                    }\n                    if (targetNode.shape.shape === 'TextAnnotation' && !(0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.isSelected)(this, targetNode)\n                        && (0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.isSelected)(this, textAnnotationTarget)) {\n                        var oldValue = void 0;\n                        var newValue = void 0;\n                        if (node.isResized) {\n                            oldValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };\n                            var resizeOffset = node.resizeDif[targetNode.id];\n                            if (resizeOffset) {\n                                targetNode.margin.left += resizeOffset.x;\n                                targetNode.margin.top += resizeOffset.y;\n                                newValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };\n                            }\n                        }\n                        else if (laneX !== undefined && laneY !== undefined) {\n                            if (targetNode.parentId) {\n                                oldValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };\n                                targetNode.margin.left += laneX;\n                                targetNode.margin.top += laneY;\n                                newValue = { margin: { left: targetNode.margin.left, top: targetNode.margin.top } };\n                            }\n                            else {\n                                oldValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };\n                                targetNode.offsetX += laneX;\n                                targetNode.offsetY += laneY;\n                                newValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };\n                            }\n                        }\n                        else {\n                            oldValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };\n                            targetNode.offsetX = newX > oldX ? targetNode.offsetX + x : targetNode.offsetX - x;\n                            targetNode.offsetY = newY > oldY ? targetNode.offsetY + y : targetNode.offsetY - y;\n                            newValue = { offsetX: targetNode.offsetX, offsetY: targetNode.offsetY };\n                        }\n                        this.nodePropertyChange(targetNode, oldValue, newValue);\n                    }\n                }\n            }\n        }\n    };\n    Diagram.prototype.updatePorts = function (actualObject, flip) {\n        if (actualObject && actualObject.ports.length > 0) {\n            for (var _i = 0, _a = Object.keys(actualObject.ports); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var index = Number(key);\n                var actualPort = actualObject.ports[parseInt(index.toString(), 10)];\n                var portWrapper = this.getWrapper(actualObject.wrapper, actualPort.id);\n                portWrapper = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updatePortEdges)(portWrapper, flip, actualPort);\n                portWrapper.relativeMode = 'Point';\n                if (actualObject.wrapper.measureChildren === undefined) {\n                    actualObject.wrapper.measureChildren = false;\n                }\n                portWrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(portWrapper.width, portWrapper.height));\n                portWrapper.arrange(portWrapper.desiredSize);\n            }\n        }\n    };\n    Diagram.prototype.updateFlipOffset = function (element, diffX, diffY, flip) {\n        if (element.hasChildren()) {\n            for (var _i = 0, _a = element.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Horizontal || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Both) {\n                    child.flipOffset.x = child.flipOffset.x + diffX;\n                }\n                if (flip === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Vertical || flip === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.FlipDirection.Both) {\n                    child.flipOffset.y = child.flipOffset.y + diffY;\n                }\n                if (child instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_20__.Canvas || child instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_6__.Container) {\n                    this.updateFlipOffset(child, diffX, diffY, flip);\n                }\n            }\n        }\n    };\n    Diagram.prototype.updateUMLActivity = function (changedProp, oldObject, actualObject, diagram) {\n        var sizeChanged = changedProp.width !== undefined || changedProp.height !== undefined;\n        if (sizeChanged) {\n            var innerFinalNode = actualObject.wrapper.children[0].children[0];\n            innerFinalNode.width = changedProp.width;\n            innerFinalNode.height = changedProp.height;\n            var outerFinalNode = actualObject.wrapper.children[0].children[1];\n            outerFinalNode.width = changedProp.width / 1.5;\n            outerFinalNode.height = changedProp.height / 1.5;\n        }\n    };\n    Diagram.prototype.updateConnectorProperties = function (connector) {\n        if (this.preventConnectorsUpdate) {\n            var index = this.selectionConnectorsList.indexOf(connector);\n            if (index === -1 && connector) {\n                this.selectionConnectorsList.push(connector);\n            }\n        }\n        else {\n            var conn = {\n                sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint, sourceID: connector.sourceID,\n                targetID: connector.targetID, sourcePortID: connector.sourcePortID, targetPortID: connector.targetPortID\n            };\n            this.connectorPropertyChange(connector, {}, conn, undefined, true);\n        }\n    };\n    /**\n     * updateConnectorEdges method \\\n     *\n     * @returns { void }     Updates the connectorPropertyChange of the diagram container .\\\n     * @param {Node} actualObject - provide the actualObject value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateConnectorEdges = function (actualObject) {\n        if (actualObject.inEdges.length > 0) {\n            for (var j = 0; j < actualObject.inEdges.length; j++) {\n                this.updateConnectorProperties(this.nameTable[actualObject.inEdges[parseInt(j.toString(), 10)]]);\n            }\n        }\n        if (actualObject.outEdges.length > 0) {\n            for (var k = 0; k < actualObject.outEdges.length; k++) {\n                this.updateConnectorProperties(this.nameTable[actualObject.outEdges[parseInt(k.toString(), 10)]]);\n            }\n        }\n        // Bug: 909563 - Max Call Stack exception upon dragging group's child connector end point\n        if (!(actualObject instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) && actualObject.parentId && this.nameTable[actualObject.parentId]) {\n            this.updateConnectorEdges(this.nameTable[actualObject.parentId]);\n        }\n    };\n    /* tslint:enable */\n    Diagram.prototype.connectorProprtyChangeExtend = function (actualObject, oldProp, newProp, updateSelector) {\n        if (newProp.type !== undefined && newProp.type !== oldProp.type) {\n            if (actualObject.segments.length > 0 && newProp.segments === undefined) {\n                actualObject.segments = [];\n            }\n        }\n        if ((newProp.shape !== undefined) && actualObject.shape !== undefined &&\n            actualObject.shape && actualObject.shape.type === 'Bpmn' && this.bpmnModule) {\n            this.bpmnModule.updateBPMNConnector(actualObject, oldProp, newProp, this);\n        }\n        if (actualObject.constraints !== undefined) {\n            this.updateThumbConstraints(this.selectedItems.connectors, this.selectedItems);\n            return updateSelector = true;\n        }\n        return updateSelector;\n    };\n    /* tslint:disable */\n    /**\n     * Updates the connectorPropertyChange of the diagram container \\\n     *\n     * @returns { void }     Updates the connectorPropertyChange of the diagram container .\\\n     * @param {DiagramElement} actualObject - provide the actualObject value.\n     * @param {boolean} oldProp - provide the oldProp value.\n     * @param {boolean} newProp - provide the newProp value.\n     * @param {boolean} disableBridging - provide the disableBridging value.\n     * @param {boolean} propertyChange - provide the propertyChange value.\n     *\n     * @private\n     */\n    Diagram.prototype.connectorPropertyChange = function (actualObject, oldProp, newProp, disableBridging, propertyChange) {\n        if (this.canEnableBlazorObject) {\n            var node = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(actualObject);\n            this.insertValue(node, false);\n        }\n        var existingBounds = actualObject.wrapper.bounds;\n        var updateSelector = false;\n        var points = [];\n        updateSelector = this.connectorProprtyChangeExtend(actualObject, oldProp, newProp, updateSelector);\n        var inPort;\n        var outPort;\n        var source;\n        var target;\n        if (newProp.visible !== undefined) {\n            this.updateElementVisibility(actualObject.wrapper, actualObject, actualObject.visible);\n        }\n        if (newProp.sourcePoint !== undefined || newProp.targetPoint !== undefined\n            || newProp.sourceID !== undefined || newProp.targetID !== undefined || newProp.targetPadding !== undefined ||\n            newProp.sourcePortID !== undefined || newProp.targetPortID !== undefined || newProp.sourcePadding !== undefined ||\n            newProp.type !== undefined || newProp.segments !== undefined || newProp.flip !== undefined) {\n            if ((newProp.sourceID !== undefined && newProp.sourceID !== oldProp.sourceID) || newProp.sourcePortID) {\n                var sourceNode = this.nameTable[actualObject.sourceID];\n                outPort = this.findInOutConnectPorts(sourceNode, false);\n                if (!sourceNode || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canOutConnect)(sourceNode) || (actualObject.sourcePortID !== '' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canPortOutConnect)(outPort)))) {\n                    actualObject.sourceWrapper = sourceNode ? this.getEndNodeWrapper(sourceNode, actualObject, true) : undefined;\n                    if (actualObject.sourcePortID && newProp.sourcePortID === undefined) {\n                        actualObject.sourcePortWrapper = sourceNode ? this.getWrapper(sourceNode.wrapper, actualObject.sourcePortID) : undefined;\n                    }\n                    this.removePortEdges(this.nameTable[oldProp.sourceID] || sourceNode, oldProp.sourcePortID || actualObject.sourcePortID, actualObject.id, false);\n                }\n                if (newProp.sourceID !== undefined && oldProp.sourceID !== undefined && oldProp.sourceID !== '') {\n                    var oldSource = this.nameTable[oldProp.sourceID];\n                    if (oldSource !== undefined && oldSource.outEdges && oldSource.outEdges.indexOf(actualObject.id) !== -1) {\n                        (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.removeItem)(oldSource.outEdges, actualObject.id);\n                    }\n                }\n                this.updateEdges(actualObject);\n            }\n            if (newProp.targetID !== undefined && newProp.targetID !== oldProp.targetID) {\n                var targetNode = this.nameTable[newProp.targetID];\n                inPort = this.findInOutConnectPorts(targetNode, true);\n                if (!targetNode || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canInConnect)(targetNode) || (actualObject.targetPortID !== '' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canPortInConnect)(inPort)))) {\n                    actualObject.targetWrapper = targetNode ? this.getEndNodeWrapper(targetNode, actualObject, false) : undefined;\n                    if (actualObject.targetPortID && newProp.targetPortID === undefined) {\n                        actualObject.targetPortWrapper = targetNode ? this.getWrapper(targetNode.wrapper, actualObject.targetPortID) : undefined;\n                    }\n                    this.removePortEdges(this.nameTable[oldProp.targetID] || targetNode, oldProp.targetPortID || actualObject.targetPortID, actualObject.id, true);\n                }\n                if (oldProp !== undefined && oldProp.targetID !== undefined && oldProp.targetID !== '') {\n                    var oldTarget = this.nameTable[oldProp.targetID];\n                    if (oldTarget !== undefined && oldTarget.inEdges && oldTarget.inEdges.indexOf(actualObject.id) !== -1) {\n                        (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.removeItem)(oldTarget.inEdges, actualObject.id);\n                    }\n                }\n                this.updateEdges(actualObject);\n            }\n            if (newProp.sourcePortID !== undefined && newProp.sourcePortID !== oldProp.sourcePortID) {\n                if (actualObject.sourceID && this.nameTable[actualObject.sourceID]) {\n                    source = this.nameTable[actualObject.sourceID].wrapper;\n                }\n                var sourceNode = this.nameTable[actualObject.sourceID];\n                if (!sourceNode || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canOutConnect)(sourceNode) || (actualObject.sourcePortID !== '' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canPortOutConnect)(outPort)))) {\n                    actualObject.sourcePortWrapper = source ? this.getWrapper(source, newProp.sourcePortID) : undefined;\n                }\n                else if (actualObject.sourcePortID === '' && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canOutConnect)(sourceNode)) {\n                    actualObject.sourcePortWrapper = undefined;\n                }\n            }\n            if (newProp.targetPortID !== undefined && newProp.targetPortID !== oldProp.targetPortID) {\n                var targetNode = this.nameTable[actualObject.targetID];\n                if (actualObject.targetID && this.nameTable[actualObject.targetID]) {\n                    target = this.nameTable[actualObject.targetID].wrapper;\n                }\n                if (!targetNode || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canInConnect)(targetNode) || (actualObject.targetPortID !== '' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canPortInConnect)(inPort)))) {\n                    actualObject.targetPortWrapper = target ? this.getWrapper(target, newProp.targetPortID) : undefined;\n                }\n                else if (actualObject.targetPortID === '' && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canInConnect)(targetNode)) {\n                    actualObject.targetPortWrapper = undefined;\n                }\n            }\n            if (newProp.flip !== undefined) {\n                actualObject.flip = newProp.flip;\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.flipConnector)(actualObject);\n            }\n            //EJ2-867479 - Performance issue in complexhierarchical layout due to linerouting injection\n            if (actualObject.type === 'Orthogonal' && this.lineRoutingModule && this.diagramActions &&\n                (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting) && !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction) && this.layout.type !== 'ComplexHierarchicalTree') {\n                this.lineRoutingModule.renderVirtualRegion(this, true);\n                // EJ2-65876 - Exception occurs on line routing injection module\n                if (actualObject.sourceID !== actualObject.targetID && actualObject.segments.length > 1) {\n                    //EJ2-69573 - Excecption occurs when calling doLayout method with the lineRouting module\n                    this.lineRoutingModule.refreshConnectorSegments(this, actualObject, false);\n                }\n            }\n            points = this.getPoints(actualObject);\n        } //Add prop change for zindex, alignments and margin\n        if (newProp.style !== undefined) {\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateStyle)(newProp.style, actualObject.wrapper.children[0]);\n        }\n        if (points.length > 0 || newProp.sourceDecorator !== undefined || (newProp.targetDecorator !== undefined\n            && ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.canMeasureDecoratorPath)(Object.keys(newProp.targetDecorator)))) || newProp.cornerRadius !== undefined) {\n            (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateConnector)(actualObject, points.length > 0 ? points : actualObject.intermediatePoints, this.diagramActions);\n            if (newProp.type !== undefined) {\n                updateSelector = true;\n            }\n            if (points.length > 0) {\n                actualObject.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(actualObject.wrapper.width, actualObject.wrapper.height));\n                actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);\n                // eslint-disable-next-line max-len\n                this.updateConnectorAnnotation(actualObject);\n                this.updateConnectorPort(actualObject);\n                this.updateConnectorfixedUserHandles(actualObject);\n                this.updateObject(actualObject, oldProp, newProp);\n            } //work-around to update intersected connector bridging\n        }\n        if ((newProp.sourcePoint || newProp.targetPoint || newProp.segments)\n            && this.diagramActions === _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) {\n            updateSelector = true;\n        }\n        if (actualObject.shape.type === 'Bpmn' && actualObject.shape.sequence === 'Default' && actualObject.shape.flow === 'Sequence') {\n            this.commandHandler.updatePathElementOffset(actualObject);\n        }\n        // eslint-disable-next-line max-len\n        if (!disableBridging) {\n            this.updateBridging();\n        }\n        this.updateAnnotations(newProp, actualObject);\n        this.updateConnectorPorts(newProp, actualObject);\n        this.updatefixedUserHandle(newProp, actualObject);\n        actualObject.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(actualObject.wrapper.width, actualObject.wrapper.height));\n        actualObject.wrapper.arrange(actualObject.wrapper.desiredSize);\n        if (existingBounds.equals(existingBounds, actualObject.wrapper.bounds) === false) {\n            this.updateQuad(actualObject);\n            if (this.eventHandler.currentAction !== 'Drag') {\n                this.updateGroupSize(actualObject);\n            }\n        }\n        if (updateSelector === true && this.checkSelectedItem(actualObject) && (!(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.ToolAction)\n            || (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.UndoRedo))) {\n            this.updateSelector();\n        }\n        if (!this.preventConnectorsUpdate) {\n            if (!(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canVitualize)(this) && this.scroller.oldCollectionObjects.indexOf(actualObject.id) > -1)) {\n                if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventZIndexOnDragging) {\n                    this.updateDiagramObject(actualObject, true);\n                }\n                else {\n                    this.updateDiagramObject(actualObject);\n                }\n            }\n        }\n        this.updateConnectorEdges(actualObject);\n        if (this.diagramActions && actualObject.status !== 'New') {\n            actualObject.status = 'Update';\n        }\n        this.triggerPropertyChange(propertyChange, actualObject, oldProp, newProp);\n    };\n    /* tslint:enable */\n    /**\n     * getDirection methods \\\n     *\n     * @returns { void }  getDirection methods .\\\n     * @param {NodeModel} node - provide the node value.\n     * @param {string} portId - provide the portId value.\n     * @param {string} item - provide the item value.\n     * @param {number} isInEdges - provide the isInEdges value.\n     *\n     * @private\n     */\n    Diagram.prototype.removePortEdges = function (node, portId, item, isInEdges) {\n        if (node) {\n            for (var i = 0; i < node.ports.length; i++) {\n                var port = node.ports[parseInt(i.toString(), 10)];\n                if (port.id === portId) {\n                    var portEdge = (isInEdges) ? port.inEdges : port.outEdges;\n                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.removeItem)(portEdge, item);\n                }\n            }\n        }\n    };\n    //Removed blazor getpropertyChangeArgs method\n    // Feature 826644: Support to add ports to the connector. Added below method to update connector ports\n    // on connector property change.\n    Diagram.prototype.updateConnectorPorts = function (newProp, actualObject) {\n        if (newProp.ports !== undefined) {\n            for (var _i = 0, _a = Object.keys(newProp.ports); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var index = Number(key);\n                var changedObject = newProp.ports[\"\" + key];\n                var actualPort = actualObject.ports[parseInt(index.toString(), 10)];\n                this.updatePort(changedObject, actualPort, actualObject.wrapper, actualObject);\n            }\n        }\n    };\n    Diagram.prototype.triggerPropertyChange = function (propertyChange, actualObject, oldProp, newProp) {\n        if (!propertyChange) {\n            var element = actualObject;\n            var args = {\n                element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(element), cause: this.diagramActions, diagramAction: this.getDiagramAction(this.diagramActions),\n                oldValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(oldProp), newValue: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(newProp)\n            };\n            //Removed isBlazor code\n            this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.propertyChange, args);\n        }\n    };\n    Diagram.prototype.findInOutConnectPorts = function (node, isInconnect) {\n        var port = {};\n        if (node) {\n            port = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getInOutConnectPorts)(node, isInconnect);\n        }\n        return port;\n    };\n    Diagram.prototype.getPoints = function (actualObject, points) {\n        //let pts: PointModel[];\n        //871158: Connector splitting point change with line distribution module injection\n        var lineDistributionModule = (this.lineDistributionModule && this.layout.connectionPointOrigin === 'DifferentPoint') ? true : false;\n        var pts = actualObject.getConnectorPoints(actualObject.type, points, this.layout.type === 'ComplexHierarchicalTree' || this.layout.type === 'HierarchicalTree' ?\n            this.layout.orientation : undefined, lineDistributionModule);\n        return pts;\n    };\n    /**\n     * update the  opacity  and visibility for the node  once the layout animation starts \\\n     *\n     * @returns { void }  update the  opacity  and visibility for the node  once the layout animation starts .\\\n     * @param {Container} element - provide the element value.\n     * @param {boolean} visible - provide the visible value.\n     * @param {number} opacity - provide the opacity value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateNodeProperty = function (element, visible, opacity) {\n        if (visible === undefined) {\n            this.updateElementVisibility(element, this.nameTable[element.id], visible);\n        }\n        else {\n            element.style.opacity = opacity;\n            for (var i = 0; i < element.children.length; i++) {\n                if (element.children[parseInt(i.toString(), 10)] instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_6__.Container) {\n                    this.updateNodeProperty(element.children[parseInt(i.toString(), 10)], undefined, opacity);\n                }\n                element.children[parseInt(i.toString(), 10)].style.opacity = opacity;\n            }\n        }\n    };\n    /**\n     * checkSelected Item for Connector \\\n     *\n     * @returns { void }  checkSelected Item for Connector .\\\n     * @param {Connector | Node} actualObject - provide the element value.\n     *\n     * @private\n     */\n    Diagram.prototype.checkSelectedItem = function (actualObject) {\n        var selectorModel = this.selectedItems;\n        var isSelected = false;\n        var selItems = [];\n        selItems = selItems.concat(selectorModel.nodes, selectorModel.connectors);\n        if (selItems.length > 0) {\n            if (actualObject.id === selItems[selItems.length - 1].id) {\n                isSelected = true;\n            }\n        }\n        return isSelected;\n    };\n    /**\n     * Updates the visibility of the diagram container \\\n     *\n     * @returns { void }     Updates the visibility of the diagram container .\\\n     * @param {DiagramElement} element - provide the element value.\n     * @param {boolean} visible - provide the target value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateDiagramContainerVisibility = function (element, visible) {\n        if (element instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_6__.Container) {\n            for (var i = 0; i < element.children.length; i++) {\n                this.updateDiagramContainerVisibility(element.children[parseInt(i.toString(), 10)], visible);\n            }\n        }\n        element.visible = visible;\n    };\n    /**\n     * Updates the visibility of the node/connector \\\n     *\n     * @returns { void }  Updates the visibility of the node/connector .\\\n     * @param {Container} element - provide the element value.\n     * @param {Connector | Node} obj - provide the obj value.\n     * @param {boolean} visible - provide the visible value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateElementVisibility = function (element, obj, visible) {\n        if (visible !== undefined) {\n            element.visible = visible;\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                //content\n                if (!obj.children) {\n                    element.children[0].visible = visible;\n                    this.updateDiagramContainerVisibility(element.children[0], visible);\n                    if (obj.shape.type === 'Bpmn' && this.bpmnModule) {\n                        this.bpmnModule.updateElementVisibility(obj, visible, this);\n                    }\n                }\n                else {\n                    for (var _i = 0, _a = obj.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        this.updateElementVisibility(this.nameTable[\"\" + child].wrapper, this.nameTable[\"\" + child], visible);\n                    }\n                }\n                if ((obj.shape.type === 'Bpmn') && obj.shape.shape === 'TextAnnotation' && this.diagramActions) {\n                    var connector = this.nameTable[obj.inEdges[0]];\n                    var oldValue = connector.visible;\n                    connector.visible = visible;\n                    this.connectorPropertyChange(connector, { visible: oldValue }, { visible: visible });\n                }\n                //ports\n                if (obj.ports) {\n                    for (var _b = 0, _c = obj.ports; _b < _c.length; _b++) {\n                        var port = _c[_b];\n                        if (port.visibility & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortVisibility.Visible) {\n                            var wrapper = this.getWrapper(element, port.id);\n                            wrapper.visible = visible;\n                        }\n                    }\n                }\n                if (obj.annotations) {\n                    for (var _d = 0, _e = obj.annotations; _d < _e.length; _d++) {\n                        var annotation = _e[_d];\n                        var wrapper = this.getWrapper(element, annotation.id);\n                        if (visible) {\n                            wrapper.visible = wrapper.annotationVisibility === 'Visible' ? true : false;\n                        }\n                        else {\n                            wrapper.visible = visible;\n                        }\n                    }\n                }\n            }\n            else {\n                //path and decorators\n                //942121: Visibility of BPMN flow connector not correctly applied\n                if (obj.shape.type === 'Bpmn') {\n                    for (var i = 0; i < 4; i++) {\n                        element.children[parseInt(i.toString(), 10)].visible = visible;\n                    }\n                }\n                else {\n                    for (var i = 0; i < 3; i++) {\n                        element.children[parseInt(i.toString(), 10)].visible = visible;\n                    }\n                }\n            }\n            if (obj.annotations) {\n                //annotations\n                for (var _f = 0, _g = obj.annotations; _f < _g.length; _f++) {\n                    var annotation = _g[_f];\n                    var wrapper = this.getWrapper(element, annotation.id);\n                    //Bug 855273: Annotation visible property is not working while changing node visibility at runtime.\n                    if (visible) {\n                        wrapper.visible = wrapper.annotationVisibility === 'Visible' ? true : false;\n                    }\n                    else {\n                        wrapper.visible = visible;\n                    }\n                }\n            }\n            if (obj.expandIcon || obj.collapseIcon) {\n                var wrapper = this.getWrapper(element, 'icon_content');\n                if (wrapper) {\n                    for (var i = 0; i < wrapper.children.length; i++) {\n                        wrapper.children[parseInt(i.toString(), 10)].visible = visible;\n                    }\n                    wrapper.visible = visible;\n                }\n                if (obj && obj.visible && obj.outEdges) {\n                    this.updateIconVisibility(obj, (obj.outEdges.length === 0 ? false : true));\n                }\n            }\n            if (visible === false) {\n                this.unSelect(this.nameTable[element.id]);\n            }\n            if ((obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node && !this.preventNodesUpdate) || (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector && !this.preventConnectorsUpdate)) {\n                //Avoid calling updateDiagramObject method during rendering\n                if (this.diagramActions) {\n                    this.updateDiagramObject(this.nameTable[element.id], undefined, true);\n                }\n            }\n        }\n    };\n    Diagram.prototype.updateAnnotations = function (newProp, actualObject) {\n        if (newProp.annotations !== undefined) {\n            for (var _i = 0, _a = Object.keys(newProp.annotations); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var index = Number(key);\n                var changedObject = newProp.annotations[\"\" + key];\n                var actualAnnotation = actualObject.annotations[parseInt(index.toString(), 10)];\n                this.updateAnnotation(changedObject, actualAnnotation, actualObject.wrapper, actualObject);\n            }\n        }\n    };\n    Diagram.prototype.updatefixedUserHandle = function (newProp, actualObject) {\n        if (newProp.fixedUserHandles !== undefined) {\n            var index = void 0;\n            var changedObject = void 0;\n            var actualAnnotation = void 0;\n            for (var _i = 0, _a = Object.keys(newProp.fixedUserHandles); _i < _a.length; _i++) {\n                var key = _a[_i];\n                index = Number(key);\n                changedObject = newProp.fixedUserHandles[\"\" + key];\n                actualAnnotation = actualObject.fixedUserHandles[parseInt(index.toString(), 10)];\n                this.updateConnectorfixedUserHandle(changedObject, actualAnnotation, actualObject.wrapper, actualObject);\n            }\n        }\n    };\n    /**\n     * updateConnectorfixedUserHandle method \\\n     *\n     * @returns { void }  updateConnectorfixedUserHandle method .\\\n     * @param {ConnectorFixedUserHandleModel} changedObject - provide the changedObject value.\n     * @param {ConnectorFixedUserHandleModel} actualfixedUserHandle - provide the actualfixedUserHandle value.\n     * @param {Container} nodes - provide the nodes value.\n     * @param {Object} actualObject - provide the actualObject value.\n     * @param {boolean} canUpdateSize - provide the canUpdateSize value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateConnectorfixedUserHandle = function (changedObject, actualfixedUserHandle, nodes, actualObject, canUpdateSize) {\n        var isMeasure = false;\n        var fixedUserHandleWrapper = this.getWrapper(nodes, actualfixedUserHandle.id);\n        if (fixedUserHandleWrapper !== undefined) {\n            if (changedObject.width !== undefined) {\n                fixedUserHandleWrapper.width = changedObject.width;\n                isMeasure = true;\n            }\n            if (changedObject.height !== undefined) {\n                fixedUserHandleWrapper.height = changedObject.height;\n                isMeasure = true;\n            }\n            if (actualfixedUserHandle instanceof _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_45__.ConnectorFixedUserHandle &&\n                (changedObject.offset !== undefined)) {\n                actualObject.updateAnnotation(actualfixedUserHandle, actualObject.intermediatePoints, actualObject.wrapper.bounds, fixedUserHandleWrapper);\n            }\n            if ((actualfixedUserHandle instanceof _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_45__.ConnectorFixedUserHandle) && changedObject.displacement) {\n                if (changedObject.displacement.x !== undefined ||\n                    changedObject.displacement.y !== undefined) {\n                    isMeasure = true;\n                }\n            }\n            if (changedObject.fill !== undefined) {\n                fixedUserHandleWrapper.style.fill = changedObject.fill;\n            }\n            if (changedObject.handleStrokeColor !== undefined) {\n                fixedUserHandleWrapper.style.strokeColor = changedObject.handleStrokeColor;\n            }\n            if (changedObject.handleStrokeWidth !== undefined) {\n                fixedUserHandleWrapper.style.strokeWidth = changedObject.handleStrokeWidth;\n            }\n            if (changedObject.visibility !== undefined) {\n                fixedUserHandleWrapper.visible = changedObject.visibility;\n            }\n            if (changedObject.cornerRadius !== undefined) {\n                fixedUserHandleWrapper.cornerRadius = changedObject.cornerRadius;\n            }\n            this.updatefixedUserHandleContent(changedObject, isMeasure, fixedUserHandleWrapper, actualObject, actualfixedUserHandle, nodes);\n            if (isMeasure === true) {\n                fixedUserHandleWrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(fixedUserHandleWrapper.width, fixedUserHandleWrapper.height));\n                fixedUserHandleWrapper.arrange(fixedUserHandleWrapper.desiredSize);\n            }\n        }\n    };\n    /**\n     * updateAnnotation method \\\n     *\n     * @returns { void }  updateAnnotation method .\\\n     * @param {AnnotationModel} changedObject - provide the changedObject value.\n     * @param {ShapeAnnotationModel} actualAnnotation - provide the actualAnnotation value.\n     * @param {Container} nodes - provide the nodes value.\n     * @param {Object} actualObject - provide the actualObject value.\n     * @param {boolean} canUpdateSize - provide the canUpdateSize value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateAnnotation = function (changedObject, actualAnnotation, nodes, actualObject, canUpdateSize) {\n        var isMeasure = false;\n        // eslint-disable-next-line max-len\n        var annotationWrapper = this.getWrapper(nodes, actualAnnotation.id);\n        if (annotationWrapper !== undefined) {\n            if (changedObject.width !== undefined && changedObject.height !== undefined) {\n                annotationWrapper.width = changedObject.width;\n                annotationWrapper.height = changedObject.height;\n                isMeasure = true;\n            }\n            if (changedObject.rotateAngle !== undefined) {\n                annotationWrapper.rotateAngle = changedObject.rotateAngle;\n            }\n            if (canUpdateSize && !(annotationWrapper instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_37__.DiagramHtmlElement)) {\n                annotationWrapper.refreshTextElement();\n            }\n            if (actualAnnotation instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation && changedObject.segmentAngle !== undefined) {\n                annotationWrapper.rotateAngle = actualAnnotation.rotateAngle;\n            }\n            if ((changedObject).rotationReference !== undefined) {\n                annotationWrapper.rotationReference = changedObject.rotationReference;\n            }\n            if (actualAnnotation instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.ShapeAnnotation &&\n                changedObject.offset !== undefined) {\n                var offset = changedObject.offset;\n                isMeasure = true;\n                var offsetX = offset.x !== undefined ? offset.x :\n                    actualAnnotation.offset.x;\n                var offsetY = offset.y !== undefined ? offset.y :\n                    actualAnnotation.offset.y;\n                annotationWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');\n                annotationWrapper.relativeMode = 'Point';\n                //911103- Text alignment for connectors not updated properly for connectors annotation at run time\n            }\n            else if (actualAnnotation instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation &&\n                (changedObject.offset !== undefined ||\n                    changedObject.segmentAngle !== undefined ||\n                    changedObject.alignment !== undefined)) {\n                actualObject.updateAnnotation(actualAnnotation, actualObject.intermediatePoints, actualObject.wrapper.bounds, annotationWrapper);\n            }\n            if ((actualAnnotation instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation) && changedObject.displacement) {\n                if (changedObject.displacement.x !== undefined ||\n                    changedObject.displacement.y !== undefined) {\n                    isMeasure = true;\n                    actualObject.updateAnnotation(actualAnnotation, actualObject.intermediatePoints, actualObject.wrapper.bounds, annotationWrapper);\n                }\n            }\n            if (changedObject.margin !== undefined) {\n                isMeasure = true;\n                if (changedObject.margin.bottom !== undefined) {\n                    annotationWrapper.margin.bottom = changedObject.margin.bottom;\n                }\n                if (changedObject.margin.top !== undefined) {\n                    annotationWrapper.margin.top = changedObject.margin.top;\n                }\n                if (changedObject.margin.left !== undefined) {\n                    annotationWrapper.margin.left = changedObject.margin.left;\n                }\n                if (changedObject.margin.right !== undefined) {\n                    annotationWrapper.margin.right = changedObject.margin.right;\n                }\n            }\n            if (isMeasure || canUpdateSize) {\n                annotationWrapper.width = (actualAnnotation.width || actualObject.width);\n                if (actualAnnotation.template) {\n                    annotationWrapper.width = (annotationWrapper.width || annotationWrapper.actualSize.width);\n                    annotationWrapper.height = (actualAnnotation.height || actualObject.height ||\n                        annotationWrapper.actualSize.height);\n                }\n            }\n            if (changedObject.horizontalAlignment !== undefined) {\n                annotationWrapper.horizontalAlignment = changedObject.horizontalAlignment;\n                isMeasure = true;\n            }\n            if (changedObject.verticalAlignment !== undefined) {\n                annotationWrapper.verticalAlignment = changedObject.verticalAlignment;\n                isMeasure = true;\n            }\n            if (changedObject.visibility !== undefined) {\n                annotationWrapper.visible = (nodes.visible && changedObject.visibility) ? true : false;\n                annotationWrapper.annotationVisibility = annotationWrapper.visible ? 'Visible' : 'Collapsed';\n            }\n            if (changedObject.constraints !== undefined) {\n                var updateSelector = false;\n                if ((annotationWrapper.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.AnnotationConstraints.Select) &&\n                    (!(changedObject.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.AnnotationConstraints.Select)) &&\n                    (0,_interaction_actions__WEBPACK_IMPORTED_MODULE_27__.isSelected)(this, actualObject, false, annotationWrapper)) {\n                    //updateSelector = true;\n                }\n                annotationWrapper.constraints = changedObject.constraints;\n                if (updateSelector) {\n                    this.clearSelection();\n                }\n            }\n            if (changedObject.style !== undefined) {\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateStyle)(changedObject.style, annotationWrapper);\n            }\n            if (changedObject.hyperlink !== undefined) {\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.updateHyperlink)(changedObject.hyperlink, annotationWrapper, actualAnnotation);\n            }\n            this.updateAnnotationContent(changedObject, isMeasure, annotationWrapper, actualObject, actualAnnotation, nodes);\n            if (isMeasure === true) {\n                annotationWrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(annotationWrapper.width, annotationWrapper.height));\n                annotationWrapper.arrange(annotationWrapper.desiredSize);\n            }\n            if (!(annotationWrapper instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_37__.DiagramHtmlElement)) {\n                annotationWrapper.refreshTextElement();\n            }\n            // this.refresh(); this.refreshDiagramLayer();\n        }\n    };\n    Diagram.prototype.updatefixedUserHandleContent = function (changedObject, isMeasure, fixedUserHandleWrapper, actualObject, fixedUserHandleAnnotation, nodes) {\n        if (changedObject !== undefined) {\n            this.updateConnectorfixedUserHandleWrapper(fixedUserHandleWrapper, actualObject, fixedUserHandleAnnotation, nodes);\n        }\n    };\n    Diagram.prototype.updateConnectorfixedUserHandleWrapper = function (fixedUserHandleWrapper, actualObject, actualAnnotation, nodes) {\n        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n            var elementId = _a[_i];\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(fixedUserHandleWrapper.id + '_groupElement', elementId);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(fixedUserHandleWrapper.id + '_html_element', elementId);\n        }\n        if (actualObject instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n            var canvas = actualObject.wrapper;\n            var segment = canvas.children[0];\n            var bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect(segment.offsetX - segment.width / 2, segment.offsetY - segment.height / 2, segment.width, segment.height);\n            fixedUserHandleWrapper =\n                actualObject.getFixedUserHandle(actualObject.fixedUserHandles[actualObject.fixedUserHandles.length - 1], actualObject.intermediatePoints, bounds, undefined, undefined);\n        }\n        for (var i = 0; i < nodes.children.length; i++) {\n            if (fixedUserHandleWrapper.id === nodes.children[parseInt(i.toString(), 10)].id) {\n                nodes.children.splice(i, 1, fixedUserHandleWrapper);\n            }\n        }\n    };\n    Diagram.prototype.updateAnnotationContent = function (changedObject, isMeasure, annotationWrapper, actualObject, actualAnnotation, nodes) {\n        if (changedObject.content !== undefined) {\n            if (annotationWrapper) {\n                isMeasure = true;\n                if (actualObject.shape.type === 'UmlActivity' &&\n                    ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)() && actualObject.shape.shape === 'StructuredNode'))) {\n                    annotationWrapper.content = '<<' + changedObject.content + '>>';\n                }\n                else {\n                    annotationWrapper.content = changedObject.content;\n                }\n            }\n            if (annotationWrapper instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_37__.DiagramHtmlElement) {\n                this.updateAnnotationWrapper(annotationWrapper, actualObject, actualAnnotation, nodes);\n            }\n        }\n        if (changedObject.template !== undefined) {\n            annotationWrapper.content = changedObject.template;\n            this.updateAnnotationWrapper(annotationWrapper, actualObject, actualAnnotation, nodes);\n        }\n    };\n    Diagram.prototype.updateAnnotationWrapper = function (annotationWrapper, actualObject, actualAnnotation, nodes) {\n        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n            var elementId = _a[_i];\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(annotationWrapper.id + '_groupElement', elementId);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(annotationWrapper.id + '_html_element', elementId);\n        }\n        if (actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n            annotationWrapper =\n                actualObject.initAnnotationWrapper(actualAnnotation, this.element.id);\n        }\n        else if (actualObject instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n            var canvas = actualObject.wrapper;\n            var segment = canvas.children[0];\n            var bounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect(segment.offsetX - segment.width / 2, segment.offsetY - segment.height / 2, segment.width, segment.height);\n            annotationWrapper =\n                actualObject.getAnnotationElement(actualObject.annotations[actualObject.annotations.length - 1], actualObject.intermediatePoints, bounds, this.getDescription, this.element.id);\n        }\n        for (var i = 0; i < nodes.children.length; i++) {\n            if (annotationWrapper.id === nodes.children[parseInt(i.toString(), 10)].id) {\n                nodes.children.splice(i, 1, annotationWrapper);\n            }\n        }\n    };\n    /**\n     * updateNodefixedUserHandle method \\\n     *\n     * @returns { void }  updateNodefixedUserHandle method .\\\n     * @param {NodeFixedUserHandleModel} changedObject - provide the changedObject value.\n     * @param {NodeFixedUserHandleModel} actualfixedUserHandle - provide the actualfixedUserHandle value.\n     * @param {Container} nodes - provide the changedObject value.\n     * @param {Object} actualObject - provide the changedObject value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateNodefixedUserHandle = function (changedObject, actualfixedUserHandle, nodes, actualObject) {\n        //let fixedUserHandleWrapper: Canvas;\n        var isMeasure = false;\n        var fixedUserHandleWrapper = this.getWrapper(nodes, actualfixedUserHandle.id);\n        if (fixedUserHandleWrapper !== undefined) {\n            if (changedObject.width !== undefined) {\n                fixedUserHandleWrapper.actualSize.width = changedObject.width;\n                isMeasure = true;\n            }\n            if (changedObject.height !== undefined) {\n                fixedUserHandleWrapper.height = changedObject.height;\n                isMeasure = true;\n            }\n            if (actualfixedUserHandle instanceof _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_45__.NodeFixedUserHandle &&\n                changedObject.offset !== undefined) {\n                var offset = changedObject.offset;\n                isMeasure = true;\n                var offsetX = offset.x !== undefined ? offset.x :\n                    actualfixedUserHandle.offset.x;\n                var offsetY = offset.y !== undefined ? offset.y :\n                    actualfixedUserHandle.offset.y;\n                fixedUserHandleWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');\n                fixedUserHandleWrapper.relativeMode = 'Point';\n            }\n            if (changedObject.margin !== undefined) {\n                isMeasure = true;\n                if (changedObject.margin.bottom !== undefined) {\n                    fixedUserHandleWrapper.margin.bottom = changedObject.margin.bottom;\n                }\n                if (changedObject.margin.top !== undefined) {\n                    fixedUserHandleWrapper.margin.top = changedObject.margin.top;\n                }\n                if (changedObject.margin.left !== undefined) {\n                    fixedUserHandleWrapper.margin.left = changedObject.margin.left;\n                }\n                if (changedObject.margin.right !== undefined) {\n                    fixedUserHandleWrapper.margin.right = changedObject.margin.right;\n                }\n            }\n            if (changedObject.visibility !== undefined) {\n                fixedUserHandleWrapper.visible = changedObject.visibility;\n            }\n            if (changedObject.fill !== undefined) {\n                fixedUserHandleWrapper.style.fill = changedObject.fill;\n            }\n            if (changedObject.handleStrokeColor !== undefined) {\n                fixedUserHandleWrapper.style.strokeColor = changedObject.handleStrokeColor;\n            }\n            if (changedObject.handleStrokeWidth !== undefined) {\n                fixedUserHandleWrapper.style.strokeWidth = changedObject.handleStrokeWidth;\n            }\n            if (changedObject.cornerRadius !== undefined) {\n                fixedUserHandleWrapper.cornerRadius = changedObject.cornerRadius;\n            }\n            this.updatefixedUserHandleWrapper(fixedUserHandleWrapper, actualObject, actualfixedUserHandle, nodes);\n            if (isMeasure === true) {\n                fixedUserHandleWrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(fixedUserHandleWrapper.width, fixedUserHandleWrapper.height));\n                fixedUserHandleWrapper.arrange(fixedUserHandleWrapper.desiredSize);\n            }\n        }\n    };\n    Diagram.prototype.updatefixedUserHandleWrapper = function (fixedUserHandleWrapper, actualObject, actualAnnotation, nodes) {\n        for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n            var elementId = _a[_i];\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(fixedUserHandleWrapper.id + '_groupElement', elementId);\n            (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.removeElement)(fixedUserHandleWrapper.id + '_html_element', elementId);\n        }\n        if (actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n            fixedUserHandleWrapper = actualObject.initFixedUserHandles(actualAnnotation, undefined, undefined);\n        }\n        for (var i = 0; i < nodes.children.length; i++) {\n            if (fixedUserHandleWrapper.id === nodes.children[parseInt(i.toString(), 10)].id) {\n                nodes.children.splice(i, 1, fixedUserHandleWrapper);\n            }\n        }\n    };\n    /**\n     * updatePort method \\\n     *\n     * @returns { void }  updatePort method .\\\n     * @param {PointPortModel} changedObject - provide the changedObject value.\n     * @param {PointPortModel} actualPort - provide the changedObject value.\n     * @param {Container} nodes - provide the changedObject value.\n     * @param {Connector} actualObject - The actual connector object to be used.\n     * @private\n     */\n    Diagram.prototype.updatePort = function (changedObject, actualPort, nodes, actualObject) {\n        var isMeasure = false;\n        var portWrapper = this.getWrapper(nodes, actualPort.id);\n        if (portWrapper !== undefined) {\n            if (changedObject.offset !== undefined) {\n                isMeasure = true;\n                if (!actualObject) {\n                    var offsetX = changedObject.offset.x !== undefined ? changedObject.offset.x :\n                        actualPort.offset.x;\n                    var offsetY = changedObject.offset.y !== undefined ? changedObject.offset.y :\n                        actualPort.offset.y;\n                    portWrapper.setOffsetWithRespectToBounds(offsetX, offsetY, 'Fraction');\n                    portWrapper.relativeMode = 'Point';\n                }\n                else {\n                    if (changedObject.offset !== undefined) {\n                        actualObject.updateAnnotation(actualPort, actualObject.intermediatePoints, actualObject.wrapper.bounds, portWrapper);\n                    }\n                }\n            }\n            if (changedObject.width !== undefined) {\n                isMeasure = true;\n                portWrapper.width = changedObject.width;\n            }\n            if (changedObject.height !== undefined) {\n                isMeasure = true;\n                portWrapper.height = changedObject.height;\n            }\n            if (changedObject.connectionDirection !== undefined) {\n                portWrapper.connectionDirection = changedObject.connectionDirection;\n            }\n            if (changedObject.visibility !== undefined) {\n                portWrapper.visible = (nodes.visible && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.checkPortRestriction)(actualPort, _enum_enum__WEBPACK_IMPORTED_MODULE_14__.PortVisibility.Visible)) ? true : false;\n            }\n            if (changedObject.margin !== undefined) {\n                isMeasure = true;\n                if (changedObject.margin.bottom !== undefined) {\n                    portWrapper.margin.bottom = changedObject.margin.bottom;\n                }\n                if (changedObject.margin.top !== undefined) {\n                    portWrapper.margin.top = changedObject.margin.top;\n                }\n                if (changedObject.margin.right !== undefined) {\n                    portWrapper.margin.right = changedObject.margin.right;\n                }\n                if (changedObject.margin.left !== undefined) {\n                    portWrapper.margin.left = changedObject.margin.left;\n                }\n            }\n            if (changedObject.horizontalAlignment !== undefined) {\n                isMeasure = true;\n                portWrapper.horizontalAlignment = changedObject.horizontalAlignment;\n            }\n            if (changedObject.verticalAlignment !== undefined) {\n                isMeasure = true;\n                portWrapper.verticalAlignment = changedObject.verticalAlignment;\n            }\n            if (changedObject.style !== undefined) {\n                if (changedObject.style.fill !== undefined) {\n                    portWrapper.style.fill = changedObject.style.fill;\n                }\n                if (changedObject.style.opacity !== undefined) {\n                    portWrapper.style.opacity = changedObject.style.opacity;\n                }\n                if (changedObject.style.strokeColor !== undefined) {\n                    portWrapper.style.strokeColor = changedObject.style.strokeColor;\n                }\n                if (changedObject.style.strokeWidth !== undefined) {\n                    portWrapper.style.strokeWidth = changedObject.style.strokeWidth;\n                }\n                if (changedObject.style.strokeDashArray !== undefined) {\n                    portWrapper.style.strokeDashArray = changedObject.style.strokeDashArray;\n                }\n            }\n            if (changedObject.shape !== undefined) {\n                if (portWrapper) {\n                    var pathdata = (0,_objects_dictionary_common__WEBPACK_IMPORTED_MODULE_18__.getPortShape)(changedObject.shape);\n                    portWrapper.data = pathdata;\n                    portWrapper.canMeasurePath = true;\n                }\n            }\n            if (changedObject.pathData !== undefined) {\n                portWrapper.data = String(changedObject.pathData);\n                isMeasure = true;\n            }\n            if (isMeasure === true) {\n                portWrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size(portWrapper.width, portWrapper.height));\n                portWrapper.arrange(portWrapper.desiredSize);\n            }\n            //this.refresh(); this.refreshDiagramLayer();\n        }\n    };\n    /**\n     * updateIcon method \\\n     *\n     * @returns { void }  updateIcon method .\\\n     * @param {Node} actualObject - provide the obj value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateIcon = function (actualObject) {\n        var iconContainer = this.getWrapper(actualObject.wrapper, 'icon_content');\n        var diagramId = (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) ? this.element.id : undefined;\n        if (iconContainer) {\n            if (this.mode === 'SVG') {\n                var icon = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(actualObject.wrapper.id + '_icon_content', diagramId);\n                if (icon) {\n                    var iconRect = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(icon.id + '_rect', diagramId);\n                    var iconShape = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(icon.id + '_shape', diagramId);\n                    var nativeContent = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_29__.getDiagramElement)(iconShape.id + '_native_element', diagramId);\n                    if (nativeContent) {\n                        nativeContent.parentNode.removeChild(nativeContent);\n                    }\n                    iconShape.parentNode.removeChild(iconShape);\n                    iconRect.parentNode.removeChild(iconRect);\n                    icon.parentNode.removeChild(icon);\n                }\n            }\n            var index = actualObject.wrapper.children.indexOf(iconContainer);\n            actualObject.wrapper.children.splice(index, 1);\n        }\n        var portContainer = this.getPortContainer(actualObject);\n        actualObject.initIcons(this.getDescription, this.layout, portContainer, this.element.id);\n    };\n    Diagram.prototype.getPortContainer = function (actualObject) {\n        if (actualObject.children) {\n            for (var i = 0; i < actualObject.wrapper.children.length; i++) {\n                if (actualObject.wrapper.children[parseInt(i.toString(), 10)].id === actualObject.id + 'group_container') {\n                    return actualObject.wrapper.children[parseInt(i.toString(), 10)];\n                }\n            }\n        }\n        return actualObject.wrapper;\n    };\n    Diagram.prototype.updateTooltip = function (actualObject, node) {\n        if (node.tooltip.content !== undefined) {\n            actualObject.tooltip.content = node.tooltip.content;\n        }\n        if (node.tooltip.position !== undefined) {\n            actualObject.tooltip.position = node.tooltip.position;\n        }\n        if (node.tooltip.height !== undefined) {\n            actualObject.tooltip.height = node.tooltip.height;\n        }\n        if (node.tooltip.width !== undefined) {\n            actualObject.tooltip.width = node.tooltip.width;\n        }\n        if (node.tooltip.showTipPointer !== undefined) {\n            actualObject.tooltip.showTipPointer = node.tooltip.showTipPointer;\n        }\n        if (node.tooltip.relativeMode !== undefined) {\n            actualObject.tooltip.relativeMode = node.tooltip.relativeMode;\n        }\n    };\n    /**\n     * updateQuad method \\\n     *\n     * @returns { void }  updateQuad method .\\\n     * @param {IElement} obj - provide the obj value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateQuad = function (obj) {\n        var modified = this.spatialSearch.updateQuad(obj.wrapper);\n        if (modified && !this.preventDiagramUpdate) {\n            this.updatePage();\n        }\n    };\n    /**\n     * removeFromAQuad method \\\n     *\n     * @returns { void }  removeFromAQuad method .\\\n     * @param {IElement} obj - provide the node value.\n     *\n     * @private\n     */\n    Diagram.prototype.removeFromAQuad = function (obj) {\n        if (obj.children) {\n            var child = void 0;\n            var children = obj.children;\n            for (var i = 0; i < children.length; i++) {\n                child = this.nameTable[children[parseInt(i.toString(), 10)]];\n                if (child) {\n                    this.removeFromAQuad(child);\n                }\n            }\n        }\n        this.spatialSearch.removeFromAQuad(obj.wrapper);\n        var isSwimLane = obj.shape.type === 'SwimLane' ? true : false;\n        var modified = this.spatialSearch.updateBounds(obj.wrapper, isSwimLane);\n        if (modified && !this.preventDiagramUpdate) {\n            this.updatePage();\n        }\n    };\n    /**\n     * updateGroupSize method \\\n     *\n     * @returns { void }  updateGroupSize method .\\\n     * @param {NodeModel | ConnectorModel} node - provide the node value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateGroupSize = function (node) {\n        var tempNode;\n        if (node.parentId) {\n            tempNode = this.nameTable[node.parentId];\n            if (tempNode) {\n                if (tempNode.parentId) {\n                    this.updateGroupSize(tempNode);\n                }\n                else {\n                    tempNode.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_13__.Size());\n                    tempNode.wrapper.arrange(tempNode.wrapper.desiredSize);\n                    this.updateGroupOffset(tempNode);\n                    this.updateDiagramObject(tempNode);\n                }\n            }\n        }\n    };\n    Diagram.prototype.updatePage = function () {\n        if ((this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.Render) &&\n            !(this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DragUsingMouse)) {\n            this.scroller.updateScrollOffsets();\n            this.scroller.setSize();\n            //updating overview\n            for (var _i = 0, _a = this.views; _i < _a.length; _i++) {\n                var temp = _a[_i];\n                var view = this.views[\"\" + temp];\n                if (!(view instanceof Diagram)) {\n                    view.updateView(view);\n                }\n            }\n        }\n        if (this.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.DragUsingMouse) {\n            this.renderPageBreaks();\n            // EJ2-826378 - Scroller not updated properly when dragging a node outside the viewport.\n            // We need to update the scroller while dragging.\n            // If pageSize is defined, we don't need to update the scrollbar.\n            // If pageSize is not defined, we need to update the scrollbar because the content is treated as page bounds, and if the content goes beyond the viewport, the scrollbar should be updated.\n            if (!(this.pageSettings.width && this.pageSettings.height) || this.pageSettings.multiplePage) {\n                this.scroller.updateScrollOffsets();\n                this.scroller.setSize();\n            }\n        }\n    };\n    /**\n     * protectPropertyChange method \\\n     *\n     * @returns { void }  protectPropertyChange method .\\\n     * @param {boolean} enable - provide the enable value.\n     *\n     * @private\n     */\n    Diagram.prototype.protectPropertyChange = function (enable) {\n        this.isProtectedOnChange = enable;\n    };\n    /**\n     * getProtectPropertyChangeValue method \\\n     *\n     * @returns { boolean }  getProtectPropertyChangeValue method .\\\n     *\n     * @private\n     */\n    Diagram.prototype.getProtectPropertyChangeValue = function () {\n        return this.isProtectedOnChange;\n    };\n    /**\n     * enableServerDataBinding method \\\n     *\n     * @returns { void }  enableServerDataBinding method .\\\n     * @param {boolean} enable - provide the node value.\n     *\n     * @private\n     */\n    Diagram.prototype.enableServerDataBinding = function (enable) {\n        //Removed isBlazor code\n    };\n    /**\n     * updateShadow method \\\n     *\n     * @returns { void }  updateShadow method .\\\n     * @param {ShadowModel} nodeShadow - provide the node value.\n     * @param {ShadowModel} changedShadow - provide the Node value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateShadow = function (nodeShadow, changedShadow) {\n        if (changedShadow.angle !== undefined) {\n            nodeShadow.angle = changedShadow.angle;\n        }\n        if (changedShadow.color !== undefined) {\n            nodeShadow.color = changedShadow.color;\n        }\n        if (changedShadow.distance !== undefined) {\n            nodeShadow.distance = changedShadow.distance;\n        }\n        if (changedShadow.opacity !== undefined) {\n            nodeShadow.opacity = changedShadow.opacity;\n        }\n    };\n    /**\n     * updateMargin method \\\n     *\n     * @returns { void }  updateMargin method .\\\n     * @param {Node} node - provide the node value.\n     * @param {Node} changes - provide the Node value.\n     *\n     * @private\n     */\n    Diagram.prototype.updateMargin = function (node, changes) {\n        if (changes.margin.top !== undefined) {\n            node.margin.top = changes.margin.top;\n        }\n        if (changes.margin.bottom !== undefined) {\n            node.margin.bottom = changes.margin.bottom;\n        }\n        if (changes.margin.left !== undefined) {\n            node.margin.left = changes.margin.left;\n        }\n        if (changes.margin.right !== undefined) {\n            node.margin.right = changes.margin.right;\n        }\n    };\n    Diagram.prototype.removePreviewChildren = function (preview) {\n        if (preview.children && preview.children.length &&\n            preview.shape && preview.shape.type === 'SwimLane') {\n            for (var z = 0; z < preview.children.length; z++) {\n                var previewChildId = preview.children[parseInt(z.toString(), 10)];\n                var previewIndex_1 = this.nodes.indexOf(this.nameTable[\"\" + previewChildId]);\n                if (previewIndex_1 >= 0) {\n                    this.nodes.splice(previewIndex_1, 1);\n                }\n                delete this.nameTable[\"\" + previewChildId];\n            }\n            var previewIndex = this.nodes.indexOf(this.nameTable[this.currentSymbol.id]);\n            if (previewIndex >= 0) {\n                this.nodes.splice(previewIndex, 1);\n            }\n        }\n    };\n    Diagram.prototype.selectDragedNode = function (newObj, args, selectedSymbol) {\n        this.currentSymbol = newObj;\n        if (this.mode !== 'SVG') {\n            this.refreshDiagramLayer();\n        }\n        this.commandHandler.oldSelectedObjects = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneSelectedObjects)(this);\n        this.commandHandler.select(newObj);\n        // this.commandHandler.updateBlazorSelector();\n        this.eventHandler.mouseDown(args.event);\n        this.eventHandler.mouseMove(args.event, args);\n        this.preventDiagramUpdate = false;\n        this.updatePage();\n        selectedSymbol.style.opacity = '0';\n    };\n    //property changes - end region\n    /* tslint:disable */\n    Diagram.prototype.initDroppables = function () {\n        var _this = this;\n        // initiates droppable event\n        var childTable = {};\n        var entryTable = {};\n        var header;\n        var lane;\n        var selectedSymbols = 'selectedSymbols';\n        this.droppable = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Droppable(this.element);\n        var dragLeft = 5;\n        // this.droppable.accept = '.e-dragclone';\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.droppable.over = function (args) {\n            //Bug 855292: Swimlane dragging from palette jumps out of viewport when multiple page is set as true.\n            // Added below code to prevent the negative x value of swimlane bounds when multiple page and ruler is enabled to prevent swimlane jump.\n            if (_this.rulerSettings.showRulers) {\n                var vRuler = document.getElementById(_this.element.id + '_vRuler');\n                var vRulerWidth = parseFloat(vRuler.style.width);\n                dragLeft = vRulerWidth + 1;\n            }\n            //EJ2-59341- SelectionChange OldValue argument is null\n            if (_this.previousSelectedObjects.length === 0 && !_this.currentSymbol) {\n                _this.previousSelectedObjects = _this.commandHandler.getSelectedObject();\n            }\n            _this.commandHandler.PreventConnectorSplit = true;\n            if (!_this.currentSymbol) {\n                var dragDataHelper = null;\n                if (!args.dragData && args.name === 'drag') {\n                    var helper = document.getElementsByClassName('e-dragclone')[0];\n                    if (helper) {\n                        dragDataHelper = helper;\n                    }\n                }\n                if (args.dragData || dragDataHelper) {\n                    var newObj = void 0;\n                    var isHorizontal = void 0;\n                    document.getElementById(_this.element.id + 'content').focus();\n                    var position = _this.eventHandler.getMousePosition(args.event);\n                    var clonedObject = void 0;\n                    var selectedSymbol = dragDataHelper || args.dragData.helper;\n                    var paletteId = selectedSymbol.getAttribute('paletteId');\n                    var nodeDragSize = void 0;\n                    var nodePreviewSize = void 0;\n                    var paletteDragSize = void 0;\n                    var preview = void 0;\n                    if (!paletteId && args.dragData) {\n                        var arg = {\n                            source: null, element: newObj, cancel: false,\n                            diagram: _this,\n                            dragData: args.dragData.draggedElement.ej2_instances[0].dragData,\n                            dragItem: newObj\n                        };\n                        _this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.dragEnter, arg);\n                        var newNode = void 0;\n                        var newConnector = void 0;\n                        // EJ2-61664 - Check whether dragItem is returned from dragEnter event or not.\n                        // If it does not returned means then we do not change the treeview object as node\n                        if (arg.dragItem) {\n                            if (arg.dragItem.sourcePoint && arg.dragItem.targetPoint) {\n                                newConnector = new _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector(_this, 'connectors', arg.dragItem, true);\n                            }\n                            else {\n                                newNode = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node(_this, 'nodes', arg.dragItem, true);\n                            }\n                            newObj = newNode ? newNode : newConnector;\n                            _this.initObject(newObj, undefined, undefined, true);\n                            _this['enterObject'] = newObj;\n                            _this['enterTable'] = entryTable;\n                            if (newObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                                newNode.offsetX = position.x + 5 + (newNode.width) * newNode.pivot.x;\n                                newNode.offsetY = position.y + (newNode.height) * newNode.pivot.y;\n                            }\n                            else if (newObj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                                var newObjBounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect.toBounds([newObj.sourcePoint, newObj.targetPoint]);\n                                var diffx = position.x - newObjBounds.left;\n                                var diffy = position.y - newObjBounds.top;\n                                newObj.sourcePoint.x += diffx;\n                                newObj.sourcePoint.y += diffy;\n                                newObj.targetPoint.x += diffx;\n                                newObj.targetPoint.y += diffy;\n                            }\n                            _this.preventDiagramUpdate = true;\n                            _this.currentSymbol = newObj;\n                            if (_this.mode !== 'SVG') {\n                                _this.refreshDiagramLayer();\n                            }\n                            _this.selectDragedNode(newObj, args, selectedSymbol);\n                            delete _this['enterObject'];\n                            delete _this['enterTable'];\n                            _this.droppable[\"\" + selectedSymbols] = selectedSymbol;\n                            _this.allowServerDataBinding = true;\n                        }\n                    }\n                    if (paletteId) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        var sourceElement = document.getElementById(paletteId).ej2_instances[0];\n                        var source = 'sourceElement';\n                        _this.droppable[\"\" + source] = sourceElement;\n                        var childtable = 'childTable';\n                        if (sourceElement) {\n                            var obj = sourceElement[\"\" + selectedSymbols];\n                            _this.allowServerDataBinding = false;\n                            clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(sourceElement[\"\" + selectedSymbols]);\n                            childTable = sourceElement[\"\" + childtable];\n                            var wrapper = obj.wrapper.children[0].children[0];\n                            preview = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getPreviewSize)(sourceElement, clonedObject, wrapper);\n                            if (sourceElement[\"\" + selectedSymbols] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                                if (obj.shape.shape === 'TextAnnotation') {\n                                    // eslint-disable-next-line max-len\n                                    clonedObject.offsetX = position.x + 11 + (preview.width) * clonedObject.pivot.x;\n                                    // eslint-disable-next-line max-len\n                                    clonedObject.offsetY = position.y + 11 + (preview.height) * clonedObject.pivot.y;\n                                }\n                                else {\n                                    // eslint-disable-next-line max-len\n                                    clonedObject.offsetX = position.x + 5 + (preview.width) * clonedObject.pivot.x;\n                                    // eslint-disable-next-line max-len\n                                    clonedObject.offsetY = position.y + (preview.height) * clonedObject.pivot.y;\n                                }\n                                var newNode = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node(_this, 'nodes', clonedObject, true);\n                                if (newNode.shape.type === 'Bpmn' && newNode.shape.activity.subProcess.processes\n                                    && newNode.shape.activity.subProcess.processes.length) {\n                                    newNode.shape.activity.subProcess.processes = [];\n                                }\n                                nodeDragSize = newNode.dragSize;\n                                nodePreviewSize = newNode.previewSize;\n                                paletteDragSize = sourceElement['symbolDragSize'];\n                                var palettePreview = sourceElement['symbolPreview'];\n                                // eslint-disable-next-line max-len\n                                newNode.width = nodeDragSize.width || paletteDragSize.width || nodePreviewSize.width || palettePreview.width || newNode.width;\n                                // eslint-disable-next-line max-len\n                                newNode.height = nodeDragSize.height || paletteDragSize.height || nodePreviewSize.height || palettePreview.height || newNode.height;\n                                if (newNode.shape.type === 'SwimLane') {\n                                    _this.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory;\n                                    if (newNode.shape.isLane) {\n                                        newNode.children = [];\n                                        header = {\n                                            id: 'header' + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)()\n                                        };\n                                        if (newNode.shape.orientation === 'Horizontal') {\n                                            header.width = newNode.shape.lanes[0].header.width;\n                                            header.height = newNode.shape.lanes[0].height;\n                                        }\n                                        else {\n                                            header.width = newNode.shape.lanes[0].width;\n                                            header.height = newNode.shape.lanes[0].header.height;\n                                        }\n                                        header.style = newNode.shape.lanes[0].header.style;\n                                        header.offsetX = position.x + dragLeft + header.width / 2;\n                                        header.offsetY = position.y + header.height / 2;\n                                        _this.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventCollectionChangeOnDragOver;\n                                        header = _this.add(header);\n                                        lane = {\n                                            id: 'body' + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)()\n                                        };\n                                        if (newNode.shape.orientation === 'Horizontal') {\n                                            lane.width = newNode.shape.lanes[0].width - header.width;\n                                            lane.height = newNode.shape.lanes[0].height;\n                                            // eslint-disable-next-line max-len\n                                            lane.offsetX = position.x + dragLeft + (newNode.shape.lanes[0].header.width + (lane.width / 2));\n                                            lane.offsetY = position.y + lane.height / 2;\n                                        }\n                                        else {\n                                            lane.width = newNode.shape.lanes[0].width;\n                                            lane.height = newNode.shape.lanes[0].height - header.height;\n                                            lane.offsetX = position.x + dragLeft + lane.width / 2;\n                                            // eslint-disable-next-line max-len\n                                            lane.offsetY = position.y + (newNode.shape.lanes[0].header.height + (lane.height / 2));\n                                        }\n                                        lane.style = newNode.shape.lanes[0].style;\n                                        lane = _this.add(lane);\n                                        var group = {\n                                            id: 'group' + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)(),\n                                            children: [header.id, lane.id]\n                                        };\n                                        group.shape = newNode.shape;\n                                        group.width = newNode.shape.lanes[0].width;\n                                        group.height = newNode.shape.lanes[0].height;\n                                        group.previewSize = newNode.previewSize;\n                                        group.dragSize = newNode.dragSize;\n                                        group.addInfo = newNode.addInfo;\n                                        newNode = _this.add(group);\n                                        _this.diagramActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventCollectionChangeOnDragOver;\n                                    }\n                                    _this.diagramActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramAction.PreventHistory;\n                                }\n                                if (newNode.shape.isPhase) {\n                                    isHorizontal = (newNode.shape.orientation === 'Horizontal') ? true : false;\n                                    if (isHorizontal) {\n                                        newNode.offsetX = position.x + dragLeft + (newNode.width || wrapper.actualSize.width) / 2;\n                                        newNode.offsetY = position.y;\n                                        newNode.shape.data =\n                                            'M' + 20 + ',' + (newNode.height / 2) + ' L' + (newNode.width - 20) + ',' +\n                                                (newNode.height / 2) + 'z';\n                                        newNode.height = 1;\n                                    }\n                                    else {\n                                        newNode.offsetX = position.x + 5;\n                                        newNode.offsetY = position.y + (newNode.height || wrapper.actualSize.height) / 2;\n                                        newNode.shape.data =\n                                            'M' + (newNode.width / 2) + ',' + 20 + ' L' + (newNode.width / 2) +\n                                                ',' + (newNode.height - 20) + 'z';\n                                        newNode.width = 1;\n                                    }\n                                }\n                                if (newNode.shape.type === 'UmlClassifier') {\n                                    //When dragging a node from the palette to the diagram, set the children, width, and height values to undefined to avoid incorrect values.\n                                    newNode.children = newNode.width = newNode.height = undefined;\n                                    clonedObject.children = undefined;\n                                    //An empty child type is added during drag enter for every node if no child types are specified in the palette.\n                                    if (newNode.shape.classifier === 'Class') {\n                                        if (newNode.shape.classShape.methods.length <= 0\n                                            && newNode.shape.classShape.attributes.length <= 0) {\n                                            newNode.shape.classShape.attributes = [\n                                                { name: 'Name', type: 'Type', style: {} }\n                                            ];\n                                        }\n                                    }\n                                    if (newNode.shape.classifier === 'Enumeration') {\n                                        if (newNode.shape.enumerationShape.members.length <= 0) {\n                                            newNode.shape.enumerationShape.members = [\n                                                {\n                                                    name: 'Name'\n                                                }\n                                            ];\n                                        }\n                                    }\n                                    if (newNode.shape.classifier === 'Interface') {\n                                        if (newNode.shape.interfaceShape.methods.length <= 0\n                                            && newNode.shape.interfaceShape.attributes.length <= 0) {\n                                            newNode.shape.interfaceShape.attributes = [\n                                                { name: 'Name', type: 'Type', style: {} }\n                                            ];\n                                        }\n                                    }\n                                }\n                                newObj = newNode;\n                                if (clonedObject.children) {\n                                    var parentNode = clonedObject;\n                                    var tempTable = {};\n                                    entryTable = _this.getChildren(parentNode, tempTable, childTable);\n                                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.arrangeChild)(parentNode, -parentNode.offsetX, -parentNode.offsetY, entryTable, true, _this);\n                                }\n                            }\n                            else if (sourceElement[\"\" + selectedSymbols] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                                newObj = new _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector(_this, 'connectors', clonedObject, true);\n                                var bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_17__.Rect.toBounds([newObj.sourcePoint, newObj.targetPoint]);\n                                var tx = position.x - bounds.left;\n                                var ty = position.y - bounds.top;\n                                newObj.sourcePoint.x += tx;\n                                newObj.sourcePoint.y += ty;\n                                newObj.targetPoint.x += tx;\n                                newObj.targetPoint.y += ty;\n                            }\n                            if (!newObj.shape.isLane) {\n                                newObj.id += (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n                            }\n                            var arg = {\n                                source: sourceElement, element: newObj, cancel: false,\n                                diagram: _this, dragData: null, dragItem: newObj\n                            };\n                            //Removed isBlazor code\n                            _this['enterObject'] = newObj;\n                            _this['enterTable'] = entryTable;\n                            _this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.dragEnter, arg);\n                            if ((newObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) && newObj.shape.type === 'SwimLane' && newObj.shape.isLane) {\n                                var swimLaneObj = arg.element;\n                                var laneObj = swimLaneObj.shape.lanes[0];\n                                //let child1: NodeModel; let child2: NodeModel;\n                                isHorizontal = (swimLaneObj.shape.orientation === 'Horizontal') ? true : false;\n                                var child1 = _this.nameTable[newObj.children[0]];\n                                var child2 = _this.nameTable[newObj.children[1]];\n                                nodeDragSize = newObj.dragSize;\n                                nodePreviewSize = newObj.previewSize;\n                                paletteDragSize = sourceElement['symbolDragSize'];\n                                laneObj.width = nodeDragSize.width || paletteDragSize.width || nodePreviewSize.width || laneObj.width;\n                                laneObj.height = nodeDragSize.height || paletteDragSize.height || nodePreviewSize.height || laneObj.height;\n                                if (isHorizontal) {\n                                    header.width = laneObj.header.width;\n                                    header.height = laneObj.height;\n                                    lane.width = laneObj.width - header.width;\n                                    lane.height = laneObj.height;\n                                    lane.offsetX = position.x + dragLeft + (laneObj.header.width + (child2.width / 2));\n                                    lane.offsetY = position.y + child2.height / 2;\n                                }\n                                else {\n                                    header.width = laneObj.width;\n                                    header.height = laneObj.header.height;\n                                    lane.width = laneObj.width;\n                                    lane.height = laneObj.height - header.height;\n                                    lane.offsetX = position.x + dragLeft + child2.width / 2;\n                                    lane.offsetY = position.y + (laneObj.header.height + (child2.height / 2));\n                                }\n                                header.offsetX = position.x + dragLeft + child1.width / 2;\n                                header.offsetY = position.y + child1.height / 2;\n                                newObj.width = laneObj.width;\n                                newObj.height = laneObj.height;\n                            }\n                            if ((newObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) && newObj.shape.isPhase) {\n                                if (isHorizontal) {\n                                    newObj.height = 1;\n                                }\n                                else {\n                                    newObj.width = 1;\n                                }\n                            }\n                            if (!_this.activeLayer.lock && !arg.cancel) {\n                                _this.preventDiagramUpdate = true;\n                                if (newObj.children) {\n                                    _this.findChild(newObj, entryTable);\n                                }\n                                _this.preventDiagramUpdate = true;\n                                if (newObj.zIndex !== Number.MIN_VALUE) {\n                                    newObj.zIndex = Number.MIN_VALUE;\n                                }\n                                _this.initObject(newObj, undefined, undefined, true);\n                                if (_this.bpmnModule) {\n                                    for (var i = 0; i < _this.bpmnModule.bpmnTextAnnotationConnector.length; i++) {\n                                        if (_this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)].wrapper === null) {\n                                            _this.initConnectors(_this.bpmnModule.bpmnTextAnnotationConnector[parseInt(i.toString(), 10)], undefined, true);\n                                        }\n                                    }\n                                }\n                                _this.selectDragedNode(newObj, args, selectedSymbol);\n                            }\n                            delete _this['enterObject'];\n                            delete _this['enterTable'];\n                        }\n                        _this.droppable[\"\" + selectedSymbols] = selectedSymbol;\n                        _this.allowServerDataBinding = true;\n                    }\n                }\n            }\n            else {\n                if (args.event.touches && args.event.touches.length) {\n                    _this.eventHandler.mouseMove(args.event, args.event.touches);\n                }\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.droppable.drop = function (args) { return __awaiter(_this, void 0, void 0, function () {\n            var source, value, isPhase, orientation_2, isConnector, arg, id, clonedObject, nodeId, newObj, arg, clonedObject, id, selectedSymbols, draggableElement, i;\n            return __generator(this, function (_a) {\n                this.allowServerDataBinding = false;\n                source = 'sourceElement';\n                if (this.currentSymbol) {\n                    isPhase = false;\n                    isConnector = (this.currentSymbol instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) ? true : false;\n                    if (args.event.touches) {\n                        this.eventHandler.mouseUp(args.event);\n                    }\n                    arg = {\n                        source: this.droppable[\"\" + source],\n                        element: this.currentSymbol,\n                        //EJ2-895314: Connector splits while dropping node on diagram, even after moving node away from connector highlighter\n                        target: this.eventHandler['hoverNode'] ||\n                            (this.findObjectsUnderMouse(this.eventHandler.getMousePosition(args.event))[0]) || this,\n                        cancel: false,\n                        position: { x: this.currentSymbol.wrapper.offsetX, y: this.currentSymbol.wrapper.offsetY }\n                    };\n                    // Removed isBlazor code\n                    this.commandHandler.PreventConnectorSplit = false;\n                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.drop, arg);\n                    id = 'id';\n                    clonedObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(this.currentSymbol);\n                    clonedObject['hasTarget'] = this.currentSymbol['hasTarget'];\n                    this.removeFromAQuad(this.currentSymbol);\n                    this.removeObjectsFromLayer(this.nameTable[this.currentSymbol.id]);\n                    this.removeElements(this.currentSymbol);\n                    //887625-UML class nodes cloned in diagram canvas while dragging nodes outside diagram page\n                    if ((this.currentSymbol.shape.isLane ||\n                        this.currentSymbol.shape.isPhase) || this.currentSymbol.shape.type === 'UmlClassifier') {\n                        this.removeChildInNodes(this.currentSymbol);\n                    }\n                    if (arg.cancel) {\n                        (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.removeChildNodes)(this.currentSymbol, this);\n                    }\n                    if (this.currentSymbol.shape.isPhase) {\n                        isPhase = true;\n                        orientation_2 = this.currentSymbol.shape.orientation;\n                        clonedObject.shape.phases = this.currentSymbol.shape.phases;\n                    }\n                    this.removePreviewChildren(this.currentSymbol);\n                    delete this.nameTable[this.currentSymbol.id];\n                    this.currentSymbol = null;\n                    this.protectPropertyChange(true);\n                    if (!arg.cancel) {\n                        this.startGroupAction();\n                        if (clonedObject && (clonedObject.shape.isLane || isPhase)) {\n                            if (isPhase) {\n                                clonedObject.shape.isPhase = isPhase;\n                                clonedObject.shape.orientation = orientation_2;\n                            }\n                            this.eventHandler.addSwimLaneObject(clonedObject);\n                        }\n                        //The following condition is designed to ensure that only UML nodes are added to the diagram during the drop operation\n                        if (clonedObject && clonedObject.shape.type === 'UmlClassifier' && !clonedObject.shape.relationship) {\n                            clonedObject.children = undefined;\n                            this.clearSelectorLayer();\n                            this.add(clonedObject);\n                        }\n                        if (clonedObject.shape.type === 'Bpmn' && clonedObject.shape.annotation\n                            && clonedObject['hasTarget']) {\n                            nodeId = clonedObject.shape.annotation.nodeId;\n                            clonedObject.shape.annotation.id = clonedObject.id;\n                            this.addTextAnnotation(clonedObject.shape.annotation, this.nameTable[\"\" + nodeId]);\n                            clonedObject.nodeId = '';\n                        }\n                        if (!clonedObject.shape.isLane && !isPhase && (clonedObject.type !== undefined || clonedObject.shape.type !== 'UmlClassifier')) {\n                            if (clonedObject.children) {\n                                this.addChildNodes(clonedObject);\n                            }\n                            //Bug 880814: Adding element to bpmn expanded subprocess located in swimlane throws an exception.\n                            // isTargetSubProcess is checked.\n                            if (arg.target && (arg.target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) && !isConnector && (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.checkParentAsContainer)(this, arg.target)\n                                && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canAllowDrop)(arg.target) && !this.commandHandler.isTargetSubProcess(arg.target)) {\n                                (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_38__.addChildToContainer)(this, arg.target, clonedObject);\n                            }\n                            else {\n                                // EJ2-62652 - Added below code to empty the segment collection if connector type is bezier\n                                if (clonedObject.type === 'Bezier' && clonedObject.segments.length > 0) {\n                                    clonedObject.segments = [];\n                                }\n                                value = this.add(clonedObject, true);\n                            }\n                            //EJ2-864543 - Added symbols don't get correctly selected in MultipleSelect mode in Diagram\n                            if ((clonedObject || value) && ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canSingleSelect)(this) || (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_31__.canMultiSelect)(this))) {\n                                this.select([this.nameTable[clonedObject[\"\" + id]]], false, this.previousSelectedObjects);\n                            }\n                            //EJ2-909180 - Line routing does not take place when drag and drop from symbol Palatte\n                            if (this.lineRoutingModule && (this.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.LineRouting)) {\n                                this.commandHandler.updateSelectedNodeProperties(this.selectedItems);\n                            }\n                            if (arg.target && arg.target instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                                if (this.enableConnectorSplit === true) {\n                                    if (this.nameTable[clonedObject[\"\" + id]] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node) {\n                                        this.commandHandler.connectorSplit(this.nameTable[clonedObject[\"\" + id]], arg.target);\n                                        this.commandHandler.PreventConnectorSplit = false;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        this.clearSelectorLayer();\n                    }\n                    this.protectPropertyChange(false);\n                    newObj = this.nameTable[clonedObject[\"\" + id]];\n                    if (clonedObject['hasTarget']) {\n                        clonedObject.nodeId = clonedObject['hasTarget'];\n                        this.remove(clonedObject);\n                    }\n                    if (this.bpmnModule && newObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node && clonedObject.processId) {\n                        newObj.processId = clonedObject.processId;\n                        this.bpmnModule.dropBPMNchild(this.nameTable[newObj.processId], newObj, this);\n                    }\n                    if (!arg.cancel) {\n                        this.endGroupAction();\n                    }\n                    if (this.mode !== 'SVG') {\n                        this.refreshDiagramLayer();\n                    }\n                    delete this.droppable[\"\" + source];\n                }\n                else {\n                    arg = {\n                        source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(args.droppedElement),\n                        element: undefined,\n                        target: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(this.eventHandler['hoverNode'] || (this.eventHandler['lastObjectUnderMouse']) || this), cancel: false,\n                        position: undefined\n                    };\n                    //Removed is Blazor code.\n                    this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.drop, arg);\n                    clonedObject = void 0;\n                    id = 'id';\n                }\n                selectedSymbols = 'selectedSymbols';\n                // eslint-disable-next-line max-len\n                if (this.droppable[\"\" + selectedSymbols] && this.droppable[\"\" + selectedSymbols].parentNode) {\n                    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.remove)(this.droppable[\"\" + selectedSymbols]);\n                }\n                else {\n                    draggableElement = document.getElementsByClassName('e-dragclone');\n                    for (i = 0; i < draggableElement.length; i++) {\n                        draggableElement[parseInt(i.toString(), 10)].remove();\n                    }\n                }\n                this.allowServerDataBinding = true;\n                this.previousSelectedObjects = [];\n                return [2 /*return*/];\n            });\n        }); };\n        this.droppable.out = function (args) {\n            // EJ2-57221 - Added the below code to check if we drag the node from symbol palette using touch or mouse.\n            if (args.evt.type === 'touchmove') {\n                _this.eventHandler.mouseLeave(args.evt);\n            }\n            if (_this.currentSymbol && (!_this.eventHandler.focus)) {\n                _this.unSelect(_this.currentSymbol);\n                _this.removeFromAQuad(_this.currentSymbol);\n                if (_this.mode !== 'SVG' && _this.currentSymbol.shape.type === 'Native') {\n                    _this.removeElements(_this.currentSymbol);\n                }\n                _this.removeObjectsFromLayer(_this.nameTable[_this.currentSymbol.id]);\n                if (_this.currentSymbol.shape && _this.currentSymbol.shape.shape === 'TextAnnotation') {\n                    var con = _this.nameTable[_this.currentSymbol.inEdges[0]];\n                    _this.removeObjectsFromLayer(_this.nameTable[con.id]);\n                    _this.removeFromAQuad(con);\n                    _this.removePreviewChildren(con);\n                    delete _this.nameTable[con.id];\n                    var index = _this.connectors.indexOf(con);\n                    _this.connectors.splice(index, 1);\n                    _this.removeElements(con);\n                }\n                _this.removePreviewChildren(_this.currentSymbol);\n                delete _this.nameTable[_this.currentSymbol.id];\n                var args_1 = {\n                    element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(_this.currentSymbol),\n                    diagram: _this\n                };\n                //Removed is Blazor code\n                _this.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramEvent.dragLeave, args_1);\n                if (_this.mode !== 'SVG') {\n                    _this.refreshDiagramLayer();\n                }\n                else {\n                    _this.removeElements(_this.currentSymbol);\n                    //EJ2-833020-To remove the child element from the group node while dragging the group node from palette\n                    //EJ2-842739- Error When Dragging Swimlane from Palette to Diagram and Exiting Without Dropping\n                    if (_this.currentSymbol.shape.type !== 'SwimLane' && _this.currentSymbol.children && _this.currentSymbol.children.length > 0) {\n                        for (var i = 0; i < _this.currentSymbol.children.length; i++) {\n                            var child = _this.nameTable[_this.currentSymbol.children[parseInt(i.toString(), 10)]];\n                            _this.removeElements(child);\n                            delete _this.nameTable[_this.currentSymbol.children[parseInt(i.toString(), 10)]];\n                        }\n                    }\n                }\n                _this.currentSymbol = null;\n                var selectedSymbols_1 = 'selectedSymbols';\n                _this.droppable[\"\" + selectedSymbols_1].style.opacity = '1';\n                var source = 'sourceElement';\n                delete _this.droppable[\"\" + source];\n                _this.diagramRenderer.rendererActions =\n                    _this.removeConstraints(_this.diagramRenderer.rendererActions, _enum_enum__WEBPACK_IMPORTED_MODULE_14__.RendererAction.DrawSelectorBorder);\n                if (_this.previousSelectedObject) {\n                    _this.select(_this.previousSelectedObject, _this.previousSelectedObject.length > 1 ? true : false);\n                }\n                _this.previousSelectedObject = null;\n            }\n        };\n    };\n    // Removed Blazor getBlazorDragLeaveEventArgs method\n    Diagram.prototype.getDropEventArgs = function (arg) {\n        if ((this.eventHandler['lastObjectUnderMouse'] || this.eventHandler['hoverNode'])) {\n            var object = this.eventHandler['lastObjectUnderMouse'] || this.eventHandler['hoverNode'];\n            // eslint-disable-next-line max-len\n            arg.target = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(object) === _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector ? { connector: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(object) } : { node: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(object) };\n        }\n        else {\n            arg.target.diagramId = this.element.id;\n        }\n    };\n    Diagram.prototype.removeChildInNodes = function (node) {\n        if (node) {\n            if (node.children) {\n                for (var i = 0; i < node.children.length; i++) {\n                    this.removeChildInNodes(this.nameTable[node.children[parseInt(i.toString(), 10)]]);\n                }\n            }\n            var index = this.nodes.indexOf(node);\n            if (index !== -1) {\n                this.nodes.splice(index, 1);\n            }\n        }\n    };\n    Diagram.prototype.getBlazorDragEventArgs = function (args) {\n        args = {\n            // eslint-disable-next-line max-len\n            source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(args.source), element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.getObjectType)(args.element) === _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector ? { connector: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(args.element) }\n                : { node: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_8__.cloneBlazorObject)(args.element) },\n            cancel: args.cancel, diagramId: this.element.id\n        };\n        return args;\n    };\n    Diagram.prototype.findChild = function (node, childTable) {\n        var group;\n        var newNode;\n        for (var i = 0; i < node.children.length; i++) {\n            group = childTable[node.children[parseInt(i.toString(), 10)]];\n            if (group) {\n                if (group.children) {\n                    this.findChild(group, childTable);\n                }\n                group.id = group.id + (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.randomId)();\n                childTable[group.id] = group;\n                node.children[parseInt(i.toString(), 10)] = group.id;\n                newNode = new _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node(this, 'nodes', group, true);\n                this.initObject(newNode, undefined, undefined, true);\n                //this.add(group, true);\n            }\n        }\n    };\n    Diagram.prototype.getChildren = function (node, entryTable, childTable) {\n        var temp;\n        for (var i = 0; i < node.children.length; i++) {\n            temp = (childTable[node.children[parseInt(i.toString(), 10)]]);\n            if (temp) {\n                if (temp.children) {\n                    entryTable = this.getChildren(temp, entryTable, childTable);\n                }\n                entryTable[temp.id] = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_32__.cloneObject)(temp);\n            }\n        }\n        return entryTable;\n    };\n    Diagram.prototype.addChildNodes = function (node) {\n        var temp;\n        for (var i = 0; i < node.children.length; i++) {\n            temp = (this.nameTable[node.children[parseInt(i.toString(), 10)]]);\n            if (temp) {\n                if (temp.children) {\n                    this.addChildNodes(temp);\n                }\n                this.add(temp, true);\n            }\n        }\n    };\n    Diagram.prototype.moveNode = function (node) {\n        var currentLayer = this.commandHandler.getObjectLayer(node.id);\n        var index = currentLayer.zIndex;\n        var length = currentLayer.objects.length;\n        var targetLayer;\n        for (var i = 0; i < this.layers.length; i++) {\n            if (index === this.layers[parseInt(i.toString(), 10)].zIndex) {\n                targetLayer = this.layers[i + 1];\n            }\n        }\n        if (length > 1) {\n            // Bug 830365: Exception raised on adding group node in layers dynamically.\n            // Added below code to check the group node and iterate its children in layer to find the last object in the layer.\n            var num = 2;\n            if (node.children && node.children.length > 0) {\n                while (node.children.indexOf(currentLayer.objects[length - num]) > -1) {\n                    num++;\n                }\n            }\n            this.commandHandler.moveSvgNode(node.id, currentLayer.objects[length - num]);\n            this.commandHandler.moveSvgNode(currentLayer.objects[length - num], node.id);\n        }\n        else {\n            if (targetLayer) {\n                var targetObject = this.commandHandler.getLayer(this.layerZIndexTable[targetLayer.zIndex]).objects[0];\n                if (targetObject) {\n                    this.commandHandler.moveSvgNode(node.id, targetObject);\n                    this.commandHandler.updateNativeNodeIndex(node.id, targetObject);\n                }\n                else {\n                    this.moveObjectsUp(node, currentLayer);\n                }\n            }\n            else {\n                this.moveObjectsUp(node, currentLayer);\n            }\n        }\n    };\n    /**\n     * Moves the node or connector forward within the given layer. \\\n     *\n     * @returns { void }  Moves the node or connector forward within the given layer.\\\n     * @param {Node | Connector} node - The node or connector to be moved forward within the layer.\n     * @param {LayerModel} currentLayer - representing the layer in which the node or connector should be moved.\n     *\n     */\n    Diagram.prototype.moveObjectsUp = function (node, currentLayer) {\n        var targetLayer;\n        for (var i = this.layers.length - 1; i >= 0; i--) {\n            targetLayer = this.layers[parseInt(i.toString(), 10)];\n            if (currentLayer.id !== targetLayer.id) {\n                // eslint-disable-next-line max-len\n                var targetObject = this.commandHandler.getLayer(this.layerZIndexTable[targetLayer.zIndex]).objects[targetLayer.objects.length - 1];\n                if (targetObject) {\n                    this.commandHandler.moveSvgNode(node.id, targetObject);\n                    this.commandHandler.moveSvgNode(targetObject, node.id);\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * Inserts a newly added element into the database. \\\n     *\n     * @returns { void }  Inserts a newly added element into the database.\\\n     * @param {Node | Connector} node - The node or connector to be inserted into the database.\n     *\n     */\n    Diagram.prototype.insertData = function (node) {\n        return this.crudOperation(node, 'create', this.getNewUpdateNodes('New'));\n    };\n    /**\n     * Updates user-defined element properties in the existing database. \\\n     *\n     * @returns { void }     Updates user-defined element properties in the existing database.\\\n     * @param {Node | Connector} node - The source value representing the element to update.\n     *\n     */\n    Diagram.prototype.updateData = function (node) {\n        return this.crudOperation(node, 'update', this.getNewUpdateNodes('Update'));\n    };\n    /**\n     * Removes the user-deleted element from the existing database.\\\n     *\n     * @returns { void }     Removes the user-deleted element from the existing database.\\\n     * @param {Node | Connector} node - The node or connector to be removed from the database.\n     *\n     */\n    Diagram.prototype.removeData = function (node) {\n        return this.crudOperation(node, 'destroy', this.getDeletedNodes());\n    };\n    Diagram.prototype.crudOperation = function (node, crud, getNodesCollection) {\n        if (node) {\n            var data = this.parameterMap(node, node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector ? false : true);\n            if (data) {\n                // eslint-disable-next-line max-len\n                var url = node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector ? this.dataSourceSettings.connectionDataSource.crudAction[\"\" + crud] : this.dataSourceSettings.crudAction[\"\" + crud];\n                this.raiseAjaxPost(JSON.stringify(data), url);\n            }\n            return data;\n        }\n        else {\n            var newObjects = getNodesCollection;\n            // eslint-disable-next-line max-len\n            this.processCrudCollection(newObjects, this.dataSourceSettings.crudAction[\"\" + crud], this.dataSourceSettings.connectionDataSource.crudAction[\"\" + crud]);\n            return newObjects;\n        }\n    };\n    Diagram.prototype.processCrudCollection = function (newObjects, nodeCrudAction, connectorCrudAction) {\n        if (newObjects.nodes) {\n            var data = [];\n            var i = void 0;\n            for (i = 0; i < newObjects.nodes.length; i++) {\n                data.push(this.parameterMap(newObjects.nodes[parseInt(i.toString(), 10)], true));\n            }\n            if (data && data.length > 0) {\n                this.raiseAjaxPost(JSON.stringify(data), nodeCrudAction);\n            }\n        }\n        if (newObjects.connectors) {\n            var data = [];\n            var i = void 0;\n            for (i = 0; i < newObjects.connectors.length; i++) {\n                data.push(this.parameterMap(newObjects.connectors[parseInt(i.toString(), 10)], false));\n            }\n            if (data && data.length > 0) {\n                this.raiseAjaxPost(JSON.stringify(data), connectorCrudAction);\n            }\n        }\n    };\n    Diagram.prototype.parameterMap = function (object, isNode) {\n        var mappingObj = {};\n        var i;\n        var fields = isNode ? this.dataSourceSettings : this.dataSourceSettings.connectionDataSource;\n        if (fields.id) {\n            mappingObj[fields.id] = object.id;\n        }\n        if (fields.sourcePointX && fields.sourcePointY) {\n            mappingObj[fields.sourcePointX] = object.sourcePoint.x;\n            mappingObj[fields.sourcePointY] = object.sourcePoint.y;\n        }\n        if (fields.targetPointX && fields.targetPointY) {\n            mappingObj[fields.targetPointX] = object.targetPoint.x;\n            mappingObj[fields.targetPointY] = object.targetPoint.y;\n        }\n        if (fields.sourceID) {\n            mappingObj[fields.sourceID] = object.sourceID;\n        }\n        if (fields.targetID) {\n            mappingObj[fields.targetID] = object.targetID;\n        }\n        if (fields.crudAction && fields.crudAction.customFields && fields.crudAction.customFields.length > 0) {\n            for (i = 0; i < fields.crudAction.customFields.length; i++) {\n                mappingObj[fields.crudAction.customFields[parseInt(i.toString(), 10)]]\n                    = object[fields.crudAction.customFields[parseInt(i.toString(), 10)]];\n            }\n        }\n        return mappingObj;\n    };\n    Diagram.prototype.getNewUpdateNodes = function (status) {\n        var nodes = [];\n        var connectors = [];\n        // eslint-disable-next-line guard-for-in\n        for (var name_1 in this.nameTable) {\n            var node = this.nameTable[\"\" + name_1];\n            if (node.status === status) {\n                if (node && node instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector) {\n                    node.status = 'None';\n                    connectors.push(node);\n                }\n                else {\n                    node.status = 'None';\n                    nodes.push(node);\n                }\n            }\n        }\n        return { nodes: nodes, connectors: connectors };\n    };\n    Diagram.prototype.getDeletedNodes = function () {\n        var nodes = [];\n        var connectors = [];\n        var i;\n        for (i = 0; i < this.crudDeleteNodes.length; i++) {\n            var node = this.crudDeleteNodes[parseInt(i.toString(), 10)];\n            if (node && node.segments) {\n                connectors.push(node);\n            }\n            else if (node) {\n                nodes.push(node);\n            }\n        }\n        this.crudDeleteNodes = [];\n        return { nodes: nodes, connectors: connectors };\n    };\n    Diagram.prototype.raiseAjaxPost = function (value, url) {\n        var callback = new _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Fetch(url, 'POST', 'application/json');\n        var data = JSON.stringify(JSON.parse(value));\n        callback.send(data).then();\n        /* eslint-disable */\n        callback.onSuccess = function (data) {\n        };\n        /* eslint-enable */\n    };\n    Diagram.prototype.getHiddenItems = function (args) {\n        var hiddenItems = [];\n        if (this.contextMenuModule) {\n            this.contextMenuModule.hiddenItems = [];\n            for (var _i = 0, _a = args.items; _i < _a.length; _i++) {\n                var item = _a[_i];\n                this.contextMenuModule.ensureItems(item, args.event);\n                if (item.items && item.items.length) {\n                    for (var _b = 0, _c = item.items; _b < _c.length; _b++) {\n                        var newItem = _c[_b];\n                        this.contextMenuModule.ensureItems(newItem, args.event);\n                    }\n                }\n            }\n            return this.contextMenuModule.hiddenItems;\n        }\n        return hiddenItems;\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('100%')\n    ], Diagram.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], Diagram.prototype, \"enableConnectorSplit\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('SVG')\n    ], Diagram.prototype, \"mode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('100%')\n    ], Diagram.prototype, \"height\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Circle')\n    ], Diagram.prototype, \"segmentThumbShape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], Diagram.prototype, \"segmentThumbSize\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_keyboard_commands__WEBPACK_IMPORTED_MODULE_30__.ContextMenuSettings)\n    ], Diagram.prototype, \"contextMenuSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramConstraints.Default)\n    ], Diagram.prototype, \"constraints\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(_enum_enum__WEBPACK_IMPORTED_MODULE_14__.DiagramTools.Default)\n    ], Diagram.prototype, \"tool\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Top')\n    ], Diagram.prototype, \"bridgeDirection\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('transparent')\n    ], Diagram.prototype, \"backgroundColor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_grid_lines__WEBPACK_IMPORTED_MODULE_10__.SnapSettings)\n    ], Diagram.prototype, \"snapSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_ruler_settings__WEBPACK_IMPORTED_MODULE_11__.RulerSettings)\n    ], Diagram.prototype, \"rulerSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_page_settings__WEBPACK_IMPORTED_MODULE_4__.PageSettings)\n    ], Diagram.prototype, \"pageSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_serialization_settings__WEBPACK_IMPORTED_MODULE_40__.SerializationSettings)\n    ], Diagram.prototype, \"serializationSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], _objects_node__WEBPACK_IMPORTED_MODULE_7__.Node)\n    ], Diagram.prototype, \"nodes\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"drawingObject\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], _objects_connector__WEBPACK_IMPORTED_MODULE_9__.Connector)\n    ], Diagram.prototype, \"connectors\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)([])\n    ], Diagram.prototype, \"basicElements\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _objects_tooltip__WEBPACK_IMPORTED_MODULE_33__.DiagramTooltip)\n    ], Diagram.prototype, \"tooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_data_source__WEBPACK_IMPORTED_MODULE_22__.DataSource)\n    ], Diagram.prototype, \"dataSourceSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"addInfo\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"historyManager\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"nodeTemplate\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"annotationTemplate\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"userHandleTemplate\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"fixedUserHandleTemplate\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"getNodeDefaults\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"nodeDefaults\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"getConnectorDefaults\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"connectorDefaults\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"setNodeTemplate\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"getDescription\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"getCustomProperty\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"getCustomTool\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"getCustomCursor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], _diagram_custom_cursor__WEBPACK_IMPORTED_MODULE_41__.CustomCursorAction)\n    ], Diagram.prototype, \"customCursor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Diagram.prototype, \"updateSelection\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_diagram_settings__WEBPACK_IMPORTED_MODULE_43__.DiagramSettings)\n    ], Diagram.prototype, \"diagramSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _objects_node__WEBPACK_IMPORTED_MODULE_7__.Selector)\n    ], Diagram.prototype, \"selectedItems\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_page_settings__WEBPACK_IMPORTED_MODULE_4__.ScrollSettings)\n    ], Diagram.prototype, \"scrollSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _layout_layout_base__WEBPACK_IMPORTED_MODULE_23__.Layout)\n    ], Diagram.prototype, \"layout\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _diagram_keyboard_commands__WEBPACK_IMPORTED_MODULE_30__.CommandManager)\n    ], Diagram.prototype, \"commandManager\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"dataLoaded\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"dragEnter\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"dragLeave\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"dragOver\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"click\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"historyChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"historyStateChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"doubleClick\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"textEdit\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"scrollChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"mouseWheel\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"selectionChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"sizeChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"connectionChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"sourcePointChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"targetPointChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"propertyChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"positionChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"keyUp\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"keyDown\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"animationComplete\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"rotateChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"collectionChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"fixedUserHandleClick\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onUserHandleMouseDown\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onUserHandleMouseUp\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onUserHandleMouseEnter\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onUserHandleMouseLeave\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onFixedUserHandleMouseDown\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onFixedUserHandleMouseUp\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onFixedUserHandleMouseEnter\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onFixedUserHandleMouseLeave\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"segmentCollectionChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"onImageLoad\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"expandStateChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"load\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"created\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"mouseEnter\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"mouseLeave\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"mouseOver\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"elementDraw\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"contextMenuOpen\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"contextMenuBeforeItemRender\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"contextMenuClick\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"commandExecute\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], _diagram_layer__WEBPACK_IMPORTED_MODULE_35__.Layer)\n    ], Diagram.prototype, \"layers\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"drop\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"segmentChange\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"loaded\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Event)()\n    ], Diagram.prototype, \"layoutUpdated\", void 0);\n    return Diagram;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Component));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/diagram.js?");

/***/ })

}]);