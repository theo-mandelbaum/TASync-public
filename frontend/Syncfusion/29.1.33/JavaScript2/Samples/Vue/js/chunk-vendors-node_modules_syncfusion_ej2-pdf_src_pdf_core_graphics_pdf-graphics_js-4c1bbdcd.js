"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdf_src_pdf_core_graphics_pdf-graphics_js-4c1bbdcd"],{

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-graphics.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-graphics.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PdfBrush: () => (/* binding */ PdfBrush),\n/* harmony export */   PdfGraphics: () => (/* binding */ PdfGraphics),\n/* harmony export */   PdfGraphicsState: () => (/* binding */ PdfGraphicsState),\n/* harmony export */   PdfPen: () => (/* binding */ PdfPen),\n/* harmony export */   _Matrix: () => (/* binding */ _Matrix),\n/* harmony export */   _PdfTransformationMatrix: () => (/* binding */ _PdfTransformationMatrix),\n/* harmony export */   _PdfUnitConvertor: () => (/* binding */ _PdfUnitConvertor),\n/* harmony export */   _TextRenderingMode: () => (/* binding */ _TextRenderingMode)\n/* harmony export */ });\n/* harmony import */ var _pdf_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../pdf-page */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-page.js\");\n/* harmony import */ var _pdf_stream_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pdf-stream-writer */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-stream-writer.js\");\n/* harmony import */ var _base_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../base-stream */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/base-stream.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utils */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/utils.js\");\n/* harmony import */ var _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../pdf-primitives */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-primitives.js\");\n/* harmony import */ var _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../fonts/pdf-standard-font */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/pdf-standard-font.js\");\n/* harmony import */ var _fonts_string_layouter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./../fonts/string-layouter */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/string-layouter.js\");\n/* harmony import */ var _enumerator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./../enumerator */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/enumerator.js\");\n/* harmony import */ var _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../fonts/pdf-string-format */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/pdf-string-format.js\");\n/* harmony import */ var _pdf_template__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pdf-template */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-template.js\");\n/* harmony import */ var _pdf_path__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pdf-path */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-path.js\");\n/* harmony import */ var _fonts_unicode_true_type_font__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../fonts/unicode-true-type-font */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/unicode-true-type-font.js\");\n/* harmony import */ var _graphics_rightToLeft_text_renderer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./../graphics/rightToLeft/text-renderer */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/rightToLeft/text-renderer.js\");\n/* harmony import */ var _images_pdf_image__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./images/pdf-image */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/images/pdf-image.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Represents a graphics from a PDF page.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * //Create a new pen.\n * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n * //Draw line on the page graphics.\n * graphics.drawLine(pen, 10, 10, 100, 100);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfGraphics = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `PdfGraphics` class.\n     *\n     * @param {number[]} size The graphics client size.\n     * @param {_PdfContentStream} content Content stream.\n     * @param {_PdfCrossReference} xref Cross reference.\n     * @param {PdfPage | PdfTemplate} source Source object of the graphics.\n     * @private\n     */\n    function PdfGraphics(size, content, xref, source) {\n        this._pendingResource = []; // eslint-disable-line\n        this._isItalic = false;\n        this._hasResourceReference = false;\n        if (source instanceof _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfPage) {\n            this._source = source._pageDictionary;\n            this._page = source;\n        }\n        else if (source instanceof _pdf_template__WEBPACK_IMPORTED_MODULE_9__.PdfTemplate) {\n            this._source = source._content.dictionary;\n            this._template = source;\n        }\n        if (this._source && this._source.has('Resources')) {\n            var obj = this._source.getRaw('Resources'); // eslint-disable-line\n            if (obj) {\n                if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                    this._hasResourceReference = true;\n                    this._resourceObject = xref._fetch(obj);\n                }\n                else if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary) {\n                    this._resourceObject = obj;\n                }\n            }\n        }\n        else {\n            this._resourceObject = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary();\n            this._source.update('Resources', this._resourceObject);\n        }\n        this._crossReference = xref;\n        this._sw = new _pdf_stream_writer__WEBPACK_IMPORTED_MODULE_1__._PdfStreamWriter(content);\n        this._size = size;\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('PDF', this._resourceObject);\n        this._initialize();\n    }\n    Object.defineProperty(PdfGraphics.prototype, \"clientSize\", {\n        /**\n         * Gets the size of the canvas reduced by margins and page templates (Read only).\n         *\n         * @returns {number[]} The width and height of the client area as number array.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Access first page\n         * let page: PdfPage = document.getPage(0);\n         * // Gets the graphics client size.\n         * let size: number[] = page.graphics.clientSize;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return [this._clipBounds[2], this._clipBounds[3]];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfGraphics.prototype, \"_matrix\", {\n        get: function () {\n            if (typeof this._m === 'undefined') {\n                this._m = new _PdfTransformationMatrix();\n            }\n            return this._m;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfGraphics.prototype, \"_resources\", {\n        get: function () {\n            var _this = this;\n            if (typeof this._resourceMap === 'undefined') {\n                this._resourceMap = new Map();\n                if (this._resourceObject && this._resourceObject.has('Font')) {\n                    var fonts = this._resourceObject.get('Font');\n                    if (fonts && fonts.size > 0) {\n                        fonts.forEach(function (key, value) {\n                            if (value !== null && typeof value !== 'undefined' && value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                                _this._resourceMap.set(value, _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfName.get(key));\n                            }\n                        });\n                    }\n                }\n                if (this._resourceObject.has('XObject')) {\n                    var other = this._resourceObject.get('XObject');\n                    if (other && other.size > 0) {\n                        other.forEach(function (key, value) {\n                            if (value !== null && typeof value !== 'undefined' && value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                                _this._resourceMap.set(value, _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfName.get(key));\n                            }\n                        });\n                    }\n                }\n                if (this._resourceObject.has('ExtGState')) {\n                    var state = this._resourceObject.get('ExtGState');\n                    if (state && state.size > 0) {\n                        if (!this._transparencies) {\n                            this._transparencies = new Map();\n                        }\n                        state.forEach(function (key, value) {\n                            if (value !== null && typeof value !== 'undefined' && value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                                _this._setTransparencyData(value, _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfName.get(key));\n                            }\n                        });\n                    }\n                }\n            }\n            return this._resourceMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Save the current graphics state.\n     *\n     * @returns {PdfGraphicsState} graphics state.\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new font\n     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // Save the graphics\n     * let state: PdfGraphicsState = graphics.save();\n     * //Set graphics translate transform.\n     * graphics.translateTransform(100, 100);\n     * //Draws the String.\n     * graphics.drawString(\"Hello world!\", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n     * //Restore the graphics.\n     * graphics.restore(state);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.save = function () {\n        var state = new PdfGraphicsState(this, this._matrix);\n        state._textRenderingMode = this._textRenderingMode;\n        state._charSpacing = this._characterSpacing;\n        state._textScaling = this._textScaling;\n        state._wordSpacing = this._wordSpacing;\n        state._currentBrush = this._currentBrush;\n        state._currentPen = this._currentPen;\n        state._currentFont = this._currentFont;\n        this._graphicsState.push(state);\n        this._sw._saveGraphicsState();\n        return state;\n    };\n    /**\n     * Restore the graphics state.\n     *\n     * @param {PdfGraphicsState} state graphics state.\n     * @returns {void} restore of the graphics state.\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new font\n     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // Save the graphics\n     * let state: PdfGraphicsState = graphics.save();\n     * //Set graphics translate transform.\n     * graphics.translateTransform(100, 100);\n     * //Draws the String.\n     * graphics.drawString(\"Hello world!\", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n     * //Restore the graphics.\n     * graphics.restore(state);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.restore = function (state) {\n        if (this._graphicsState.length > 0) {\n            if (typeof state === 'undefined') {\n                this._doRestore();\n            }\n            else {\n                if (this._graphicsState.length > 0 && this._graphicsState.indexOf(state) !== -1) {\n                    while (this._graphicsState.length > 0) {\n                        if (this._doRestore() === state) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    PdfGraphics.prototype._doRestore = function () {\n        var state = this._graphicsState.pop();\n        this._m = state._transformationMatrix;\n        this._currentBrush = state._currentBrush;\n        this._currentPen = state._currentPen;\n        this._currentFont = state._currentFont;\n        this._characterSpacing = state._charSpacing;\n        this._wordSpacing = state._wordSpacing;\n        this._textScaling = state._textScaling;\n        this._textRenderingMode = state._textRenderingMode;\n        this._sw._restoreGraphicsState();\n        return state;\n    };\n    PdfGraphics.prototype.drawRectangle = function (x, y, width, height, first, second) {\n        this._beginMarkContent();\n        var result = this._setPenBrush(first, second);\n        this._sw._appendRectangle(x, y, width, height);\n        this._drawGraphicsPath(result.pen, result.brush);\n        this._endMarkContent();\n    };\n    /**\n     * Draws a Bezier curve using a specified pen and coordinates for the start point, two control points, and end point.\n     *\n     * @param {number} startX The x-coordinate of the starting point of the Bezier curve.\n     * @param {number} startY The y-coordinate of the starting point of the Bezier curve.\n     * @param {number} firstX The x-coordinate of the first control point of the Bezier curve.\n     * @param {number} firstY The y-coordinate of the first control point of the Bezier curve.\n     * @param {number} secondX The x-coordinate of the second control point of the Bezier curve.\n     * @param {number} secondY The y-coordinate of the second control point of the Bezier curve.\n     * @param {number} endX The x-coordinate of the ending point of the Bezier curve.\n     * @param {number} endY The y-coordinate of the ending point of the Bezier curve.\n     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the Bezier curve.\n     * @returns {void} Nothing\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new pen\n     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n     * // Draw a Bezier curve on the page graphics\n     * graphics.drawBezier(50, 100, 200, 50, 100, 150, 150, 100, pen);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.drawBezier = function (startX, startY, firstX, firstY, secondX, secondY, endX, endY, pen) {\n        this._beginMarkContent();\n        this._stateControl(pen, null, null);\n        this._sw._beginPath(startX, startY);\n        this._sw._appendBezierSegment(firstX, firstY, secondX, secondY, endX, endY);\n        this._drawGraphicsPath(pen);\n        this._endMarkContent();\n    };\n    PdfGraphics.prototype.drawPie = function (x, y, width, height, startAngle, sweepAngle, first, second) {\n        this._beginMarkContent();\n        var result = this._setPenBrush(first, second);\n        this._constructPiePath(x, y, x + width, y + height, startAngle, sweepAngle);\n        this._sw._appendLineSegment(x + width / 2, y + height / 2);\n        this._drawGraphicsPath(result.pen, result.brush, null, true);\n        this._endMarkContent();\n    };\n    PdfGraphics.prototype.drawPolygon = function (points, first, second) {\n        this._beginMarkContent();\n        if (points.length > 0) {\n            var result = this._setPenBrush(first, second);\n            this._sw._beginPath(points[0][0], points[0][1]);\n            for (var i = 1; i < points.length; i++) {\n                this._sw._appendLineSegment(points[Number.parseInt(i.toString(), 10)][0], points[Number.parseInt(i.toString(), 10)][1]);\n            }\n            this._drawGraphicsPath(result.pen, result.brush, _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfFillMode.winding, true);\n        }\n        this._endMarkContent();\n    };\n    PdfGraphics.prototype.drawEllipse = function (x, y, width, height, first, second) {\n        this._beginMarkContent();\n        var result = this._setPenBrush(first, second);\n        this._constructArcPath(x, y, x + width, y + height, 0, 360);\n        this._drawGraphicsPath(result.pen, result.brush, _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfFillMode.winding, true);\n        this._endMarkContent();\n    };\n    /**\n     * Draw arc on the page graphics.\n     *\n     * @param {number} x The x-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the arc shape comes.\n     * @param {number} y The y-coordinate of the upper-left corner of the bounding rectangle that defines the ellipse from which the arc shape comes.\n     * @param {number} width Width of the bounding rectangle that defines the ellipse from which the arc shape comes.\n     * @param {number} height Height of the bounding rectangle that defines the ellipse from which the arc shape comes.\n     * @param {number} startAngle Angle measured in degrees clockwise from the x-axis to the first side of the arc shape.\n     * @param {number} sweepAngle Angle measured in degrees clockwise from the startAngle parameter to the second side of the arc shape.\n     * @param {PdfPen} pen Pen that determines the stroke color, width, and style of the arc.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new pen\n     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n     * // Draw an arc on the page graphics\n     * graphics.drawArc(10, 20, 100, 200, 20, 30, pen);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.drawArc = function (x, y, width, height, startAngle, sweepAngle, pen) {\n        if (sweepAngle !== 0) {\n            this._beginMarkContent();\n            this._stateControl(pen);\n            this._constructArcPath(x, y, x + width, y + height, startAngle, sweepAngle);\n            this._drawGraphicsPath(pen, null, _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfFillMode.winding, false);\n            this._endMarkContent();\n        }\n    };\n    PdfGraphics.prototype._beginMarkContent = function () {\n        if (this._layer) {\n            this._layer._beginLayer(this);\n        }\n    };\n    PdfGraphics.prototype._endMarkContent = function () {\n        if (this._layer) {\n            if (this._layer._isEndState && this._layer._parentLayer.length !== 0) {\n                for (var i = 0; i < this._layer._parentLayer.length; i++) {\n                    this._sw._write('EMC');\n                }\n            }\n            if (this._layer._isEndState) {\n                this._sw._write('EMC');\n            }\n        }\n    };\n    PdfGraphics.prototype.drawImage = function (arg1, arg2, arg3, arg4, arg5) {\n        this._beginMarkContent();\n        if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {\n            var size = arg1.physicalDimension;\n            this.drawImage(arg1, arg2, arg3, size[0], size[1]);\n        }\n        else {\n            arg1._save();\n            var matrix = new _PdfTransformationMatrix();\n            this._getTranslateTransform(arg2, (arg3 + arg5), matrix);\n            this._getScaleTransform(arg4, arg5, matrix);\n            this._sw._write('q');\n            this._sw._modifyCtm(matrix);\n            var sourceDictionary = void 0;\n            var keyName = void 0;\n            var isNew = true;\n            if (this._resourceObject.has('XObject')) {\n                var obj = this._resourceObject.getRaw('XObject'); // eslint-disable-line\n                if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary) {\n                    sourceDictionary = obj;\n                }\n                if (sourceDictionary) {\n                    isNew = false;\n                }\n            }\n            if (isNew) {\n                sourceDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary(this._crossReference);\n                this._resourceObject.update('XObject', sourceDictionary);\n            }\n            if (typeof keyName === 'undefined') {\n                keyName = _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._getNewGuidString)());\n            }\n            if (this._crossReference) {\n                this._updateImageResource(arg1, keyName, sourceDictionary, this._crossReference);\n                this._source.update('Resources', this._resourceObject);\n                this._source._updated = true;\n            }\n            else {\n                this._pendingResource.push({ 'resource': arg1, 'key': keyName, 'source': sourceDictionary });\n            }\n            this._sw._executeObject(keyName);\n            this._sw._write('Q');\n            this._sw._write('\\r\\n');\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('ImageB', this._resourceObject);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('ImageC', this._resourceObject);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('ImageI', this._resourceObject);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('Text', this._resourceObject);\n        }\n        this._endMarkContent();\n    };\n    /**\n     * Draws a PDF template onto the page graphics.\n     *\n     * @param {PdfTemplate} template The PDF template to be drawn.\n     * @param {{x: number, y: number, width: number, height: number}} bounds The bounds of the template.\n     * @param {number} bounds.x The x-coordinate of the upper-left corner where the template will be drawn.\n     * @param {number} bounds.y The y-coordinate of the upper-left corner where the template will be drawn.\n     * @param {number} bounds.width The width of the area where the template will be drawn.\n     * @param {number} bounds.height The height of the area where the template will be drawn.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Get the first annotation of the page\n     * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;\n     * // Get the appearance template of the annotation\n     * let template: PdfTemplate = annotation.createTemplate();\n     * // Get the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Draw the template on the page graphics within the specified bounds\n     * graphics.drawTemplate(template, { x: 10, y: 20, width: template.size[0], height: template.size[1] });\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.drawTemplate = function (template, bounds) {\n        var _this = this;\n        this._beginMarkContent();\n        if (typeof template !== 'undefined') {\n            if (template._isExported || template._isResourceExport) {\n                if (this._crossReference) {\n                    template._crossReference = this._crossReference;\n                    template._importStream(true, template._isResourceExport);\n                }\n                else {\n                    template._importStream(false, template._isResourceExport);\n                    this._pendingResource.push(template);\n                }\n            }\n            var scaleX = (template && template._size[0] > 0) ? bounds.width / template._size[0] : 1;\n            var scaleY = (template && template._size[1] > 0) ? bounds.height / template._size[1] : 1;\n            var needScale = !(Math.trunc(scaleX * 1000) / 1000 === 1 && Math.trunc(scaleY * 1000) / 1000 === 1);\n            var cropBox = void 0;\n            var mediaBox = void 0;\n            if (this._page) {\n                cropBox = this._page.cropBox;\n                mediaBox = this._page.mediaBox;\n                if (this._page._pageDictionary.has('CropBox') && this._page._pageDictionary.has('MediaBox')) {\n                    if (cropBox[0] > 0 && cropBox[1] > 0 && mediaBox[0] < 0 && mediaBox[1] < 0) {\n                        this.translateTransform(cropBox[0], -cropBox[1]);\n                        bounds.x = -cropBox[0];\n                        bounds.y = cropBox[1];\n                    }\n                }\n            }\n            var state = this.save();\n            var matrix = new _PdfTransformationMatrix();\n            if (this._page) {\n                var needTransform = (this._page._pageDictionary.has('CropBox') &&\n                    this._page._pageDictionary.has('MediaBox') && cropBox && mediaBox &&\n                    cropBox[0] === mediaBox[0] && cropBox[1] === mediaBox[1] && cropBox[2] === mediaBox[2] && cropBox[3] === mediaBox[3]) ||\n                    (this._page._pageDictionary.has('MediaBox') && mediaBox && mediaBox[3] === 0);\n                matrix._translate(bounds.x, -(bounds.y + ((this._page._origin[0] >= 0 || needTransform) ? bounds.height : 0)));\n            }\n            else {\n                matrix._translate(bounds.x, -(bounds.y + bounds.height));\n            }\n            var scaleApplied = false;\n            if (template._content && template._content.dictionary) {\n                var dictionary = template._content.dictionary;\n                if (dictionary.has('Matrix') && dictionary.has('BBox')) {\n                    var templateMatrix = dictionary.getArray('Matrix');\n                    var templateBox = dictionary.getArray('BBox');\n                    if (templateMatrix && templateBox && templateMatrix.length > 5 && templateBox.length > 3) {\n                        var templateScaleX = Number.parseFloat((0,_utils__WEBPACK_IMPORTED_MODULE_3__._numberToString)(-templateMatrix[1]));\n                        var templateScaleY = Number.parseFloat((0,_utils__WEBPACK_IMPORTED_MODULE_3__._numberToString)(templateMatrix[2]));\n                        var roundScaleX = Number.parseFloat((0,_utils__WEBPACK_IMPORTED_MODULE_3__._numberToString)(scaleX));\n                        var roundScaleY = Number.parseFloat((0,_utils__WEBPACK_IMPORTED_MODULE_3__._numberToString)(scaleY));\n                        if (roundScaleX === templateScaleX &&\n                            roundScaleY === templateScaleY &&\n                            templateBox[2] === template._size[0] &&\n                            templateBox[3] === template._size[1] && template._isAnnotationTemplate\n                            && template._needScale && needScale) {\n                            matrix = new _PdfTransformationMatrix();\n                            matrix._translate(bounds.x - templateMatrix[4], -(bounds.y + templateMatrix[5]));\n                            matrix._scale(1, 1);\n                            scaleApplied = true;\n                        }\n                        else if (templateBox[0] !== 0 && templateBox[1] !== 0 && templateBox[0] === bounds.x &&\n                            this._page && template._isSignature) {\n                            matrix._translate(bounds.x - templateBox[0], -this._page.size[1]);\n                            matrix._scale(scaleX, scaleY);\n                            scaleApplied = true;\n                        }\n                    }\n                }\n            }\n            if (needScale && !scaleApplied) {\n                matrix._scale(scaleX, scaleY);\n            }\n            this._sw._modifyCtm(matrix);\n            var sourceDictionary = void 0;\n            var isReference = false;\n            var keyName_1;\n            var isNew = true;\n            var ref_1;\n            if (this._resourceObject.has('XObject')) {\n                var obj = this._resourceObject.getRaw('XObject'); // eslint-disable-line\n                if (obj) {\n                    if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                        isReference = true;\n                        sourceDictionary = this._crossReference._fetch(obj);\n                    }\n                    else if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary) {\n                        sourceDictionary = obj;\n                    }\n                }\n                if (sourceDictionary) {\n                    isNew = false;\n                    this._resources.forEach(function (value, key) {\n                        if (key && key instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                            var base = _this._crossReference._fetch(key);\n                            if (base && template && base === template._content) {\n                                keyName_1 = value;\n                                ref_1 = key;\n                            }\n                        }\n                    });\n                }\n            }\n            if (isNew) {\n                sourceDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary(this._crossReference);\n                this._resourceObject.update('XObject', sourceDictionary);\n            }\n            if (typeof keyName_1 === 'undefined') {\n                keyName_1 = _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._getNewGuidString)());\n                if (template && template._content.reference) {\n                    ref_1 = template._content.reference;\n                }\n                else if (this._crossReference) {\n                    ref_1 = this._crossReference._getNextReference();\n                }\n                else {\n                    this._pendingResource.push({ 'resource': template._content, 'key': keyName_1, 'source': sourceDictionary });\n                }\n                if (ref_1 && this._crossReference) {\n                    if (!this._crossReference._cacheMap.has(ref_1) && template && template._content) {\n                        this._crossReference._cacheMap.set(ref_1, template._content);\n                    }\n                    sourceDictionary.update(keyName_1.name, ref_1);\n                    this._resources.set(ref_1, keyName_1);\n                }\n                this._resourceObject._updated = true;\n            }\n            if (isReference) {\n                this._resourceObject._updated = true;\n            }\n            if (this._hasResourceReference) {\n                this._source._updated = true;\n            }\n            this._sw._executeObject(keyName_1);\n            this.restore(state);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('ImageB', this._resourceObject);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('ImageC', this._resourceObject);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('ImageI', this._resourceObject);\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('Text', this._resourceObject);\n        }\n        this._endMarkContent();\n    };\n    PdfGraphics.prototype._processResources = function (crossReference) {\n        this._crossReference = crossReference;\n        if (this._pendingResource.length > 0) {\n            for (var i = 0; i < this._pendingResource.length; i++) {\n                var entry = this._pendingResource[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n                if (entry instanceof _pdf_template__WEBPACK_IMPORTED_MODULE_9__.PdfTemplate) {\n                    entry._crossReference = crossReference;\n                    entry._updatePendingResource(crossReference);\n                }\n                else if (entry.resource instanceof _base_stream__WEBPACK_IMPORTED_MODULE_2__._PdfBaseStream) {\n                    var reference = void 0;\n                    if (entry.resource._reference) {\n                        reference = entry.resource._reference;\n                    }\n                    else {\n                        reference = crossReference._getNextReference();\n                        entry.resource._reference = reference;\n                    }\n                    if (!crossReference._cacheMap.has(reference) && entry.resource) {\n                        crossReference._cacheMap.set(reference, entry.resource);\n                    }\n                    entry.source.update(entry.key.name, reference);\n                    this._resources.set(reference, entry.key);\n                }\n                else if (entry.resource instanceof _images_pdf_image__WEBPACK_IMPORTED_MODULE_13__.PdfImage) {\n                    this._updateImageResource(entry.resource, entry.key, entry.source, crossReference);\n                }\n                else if (entry.resource instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfFont) {\n                    this._updateFontResource(entry.resource, entry.key, entry.source, crossReference);\n                }\n                this._source.update('Resources', this._resourceObject);\n                this._source._updated = true;\n            }\n            this._pendingResource = [];\n        }\n    };\n    PdfGraphics.prototype._updateImageResource = function (image, keyName, source, crossReference) {\n        var reference;\n        if (image._reference) {\n            reference = image._reference;\n        }\n        else {\n            reference = crossReference._getNextReference();\n            image._reference = reference;\n        }\n        if (!crossReference._cacheMap.has(reference)) {\n            if (image && image._imageStream && image._imageStream.dictionary) {\n                crossReference._cacheMap.set(reference, image._imageStream);\n                image._imageStream.dictionary._updated = true;\n                if (image._maskStream && image._maskStream.dictionary) {\n                    var ref = void 0;\n                    if (image._maskReference) {\n                        ref = image._maskReference;\n                    }\n                    else {\n                        ref = crossReference._getNextReference();\n                        image._maskReference = ref;\n                    }\n                    crossReference._cacheMap.set(ref, image._maskStream);\n                    image._maskStream.dictionary._updated = true;\n                    image._imageStream.dictionary.set('SMask', ref);\n                }\n            }\n        }\n        source.update(keyName.name, reference);\n        this._resources.set(reference, keyName);\n        this._resourceObject._updated = true;\n    };\n    PdfGraphics.prototype._updateFontResource = function (font, keyName, source, crossReference) {\n        var reference;\n        if (font._reference) {\n            reference = font._reference;\n        }\n        else {\n            reference = crossReference._getNextReference();\n            font._reference = reference;\n        }\n        if (!crossReference._cacheMap.has(reference)) {\n            if (font._dictionary) {\n                crossReference._cacheMap.set(reference, font._dictionary);\n                source.update(keyName.name, reference);\n                this._resources.set(reference, keyName);\n            }\n            else if (font instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfTrueTypeFont) {\n                var internal = font._fontInternal;\n                if (internal && internal._fontDictionary) {\n                    crossReference._cacheMap.set(reference, internal._fontDictionary);\n                }\n                source.update(keyName.name, reference);\n                this._resources.set(reference, keyName);\n            }\n        }\n    };\n    PdfGraphics.prototype.drawPath = function (path, first, second) {\n        this._beginMarkContent();\n        var result = this._setPenBrush(first, second);\n        if (result.pen || result.brush) {\n            this._buildUpPath(path._points, path._pathTypes);\n            this._drawGraphicsPath(result.pen, result.brush, path.fillMode, false);\n        }\n        this._endMarkContent();\n    };\n    /**\n     * Draws a rounded rectangle on the page graphics.\n     *\n     * @param {number} x The x-coordinate of the upper-left corner of the rounded rectangle.\n     * @param {number} y The y-coordinate of the upper-left corner of the rounded rectangle.\n     * @param {number} width The width of the rounded rectangle.\n     * @param {number} height The height of the rounded rectangle.\n     * @param {number} radius The radius of the rounded corners of the rectangle.\n     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the rectangle.\n     * @param {PdfBrush} brush The brush that determines the fill color and texture of the rectangle.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new pen\n     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n     * // Create a new brush\n     * let brush: PdfBrush = new PdfBrush([0, 0, 255]);\n     * // Draw a rounded rectangle on the page graphics\n     * graphics.drawRoundedRectangle(10, 20, 100, 200, 5, pen, brush);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.drawRoundedRectangle = function (x, y, width, height, radius, pen, brush) {\n        if (pen === null) {\n            throw new Error('pen');\n        }\n        if (brush === null) {\n            throw new Error('brush');\n        }\n        var bounds = [x, y, width, height];\n        var diameter = radius * 2;\n        var size = [diameter, diameter];\n        var arc = [bounds[0], bounds[1], size[0], size[1]];\n        var path = new _pdf_path__WEBPACK_IMPORTED_MODULE_10__.PdfPath();\n        if (radius === 0) {\n            path.addRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);\n            this.drawPath(path, pen, brush);\n        }\n        else {\n            path._isRoundedRectangle = true;\n            path.addArc(arc[0], arc[1], arc[2], arc[3], 180, 90);\n            arc[0] = (bounds[0] + bounds[2]) - diameter;\n            path.addArc(arc[0], arc[1], arc[2], arc[3], 270, 90);\n            arc[1] = (bounds[1] + bounds[3]) - diameter;\n            path.addArc(arc[0], arc[1], arc[2], arc[3], 0, 90);\n            arc[0] = bounds[0];\n            path.addArc(arc[0], arc[1], arc[2], arc[3], 90, 90);\n            path.closeFigure();\n            this.drawPath(path, pen, brush);\n        }\n    };\n    PdfGraphics.prototype._constructArcPath = function (x1, y1, x2, y2, start, sweep) {\n        var points = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getBezierArc)(x1, y1, x2, y2, start, sweep);\n        if (points.length === 8) {\n            return;\n        }\n        var point = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];\n        this._sw._beginPath(point[0], point[1]);\n        for (var i = 0; i < points.length; i = i + 8) {\n            point = [points[Number.parseInt(i.toString(), 10)],\n                points[i + 1],\n                points[i + 2],\n                points[i + 3],\n                points[i + 4],\n                points[i + 5],\n                points[i + 6],\n                points[i + 7]];\n            this._sw._appendBezierSegment(point[2], point[3], point[4], point[5], point[6], point[7]);\n        }\n    };\n    PdfGraphics.prototype._constructPiePath = function (x1, y1, x2, y2, start, sweep) {\n        var points = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getBezierArc)(x1, y1, x2, y2, start, sweep);\n        if (points.length === 8) {\n            var point = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];\n            this._sw._beginPath(point[0], point[1]);\n            for (var i = 0; i < points.length; i = i + 8) {\n                point = [points[Number.parseInt(i.toString(), 10)],\n                    points[i + 1],\n                    points[i + 2],\n                    points[i + 3],\n                    points[i + 4],\n                    points[i + 5],\n                    points[i + 6],\n                    points[i + 7]];\n                this._sw._appendBezierSegment(point[2], point[3], point[4], point[5], point[6], point[7]);\n            }\n        }\n    };\n    PdfGraphics.prototype._writePen = function (pen) {\n        var lineWidth = pen._width;\n        var pattern = pen._dashPattern;\n        var setPattern = [];\n        for (var i = 0; i < pattern.length; ++i) {\n            setPattern[i] = pattern[i] * pen._width; // eslint-disable-line\n        }\n        this._sw._setLineDashPattern(setPattern, pen._dashOffset * lineWidth);\n        this._sw._setLineWidth(pen._width);\n        this._sw._setLineJoin(pen._lineJoin);\n        this._sw._setLineCap(pen._lineCap);\n        if (pen._miterLimit > 0) {\n            this._sw._setMiterLimit(pen._miterLimit);\n        }\n        this._sw._setColor(pen._color, true);\n    };\n    /**\n     * Draw text on the page graphics.\n     *\n     * @param {string} value The string to be drawn.\n     * @param {PdfFont} font The font used to draw the string.\n     * @param {number[]} bounds An array specifying the bounds [x, y, width, height] where the string will be drawn.\n     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the string.\n     * @param {PdfBrush} brush The brush that determines the fill color and texture of the string.\n     * @param {PdfStringFormat} format The format that specifies text layout information such as alignment, line spacing, and trimming.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new pen\n     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n     * // Create a new font\n     * let font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.helvetica, 12);\n     * // Create a new string format\n     * let format: PdfStringFormat = new PdfStringFormat();\n     * format.alignment = PdfTextAlignment.center;\n     * // Draw text on the page graphics\n     * graphics.drawString('Hello World', font, [10, 20, 100, 200], pen, new PdfBrush([0, 0, 255]), format);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.drawString = function (value, font, bounds, pen, brush, format) {\n        this._beginMarkContent();\n        var layouter = new _fonts_string_layouter__WEBPACK_IMPORTED_MODULE_6__._PdfStringLayouter();\n        if (!format) {\n            format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfStringFormat();\n        }\n        var result = layouter._layout(value, font, format, [bounds[2], bounds[3]]);\n        if (!result._empty) {\n            var rect = this._checkCorrectLayoutRectangle(result._actualSize, bounds[0], bounds[1], format);\n            if (bounds[2] <= 0) {\n                bounds[0] = rect[0];\n                bounds[2] = rect[2];\n            }\n            if (bounds[3] <= 0) {\n                bounds[1] = rect[1];\n                bounds[3] = rect[3];\n            }\n            this._drawStringLayoutResult(result, font, pen, brush, bounds, format);\n        }\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('Text', this._resourceObject);\n        this._endMarkContent();\n    };\n    PdfGraphics.prototype._buildUpPath = function (points, types) {\n        for (var i = 0; i < points.length; i++) {\n            var point = points[Number.parseInt(i.toString(), 10)];\n            var type = types[Number.parseInt(i.toString(), 10)];\n            switch (type & 0xf) {\n                case _enumerator__WEBPACK_IMPORTED_MODULE_7__.PathPointType.start:\n                    this._sw._beginPath(point[0], point[1]);\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_7__.PathPointType.bezier:\n                    var result = this._getBezierPoint(points, types, i); // eslint-disable-line\n                    i = result.index;\n                    var first = result.point; // eslint-disable-line\n                    result = this._getBezierPoint(points, types, i);\n                    i = result.index;\n                    var second = result.point; // eslint-disable-line\n                    this._sw._appendBezierSegment(point[0], point[1], first[0], first[1], second[0], second[1]);\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_7__.PathPointType.line:\n                    this._sw._appendLineSegment(point[0], point[1]);\n                    break;\n                default:\n                    throw new Error('Incorrect path formation.');\n            }\n            type = types[Number.parseInt(i.toString(), 10)];\n            if ((type & _enumerator__WEBPACK_IMPORTED_MODULE_7__.PathPointType.closePath) === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PathPointType.closePath) {\n                this._sw._closePath();\n            }\n        }\n    };\n    PdfGraphics.prototype._getBezierPoint = function (points, types, index) {\n        if (types[Number.parseInt(index.toString(), 10)] !== _enumerator__WEBPACK_IMPORTED_MODULE_7__.PathPointType.bezier) {\n            throw new Error('Malforming path.');\n        }\n        index++;\n        return { 'index': index, 'point': points[Number.parseInt(index.toString(), 10)] };\n    };\n    PdfGraphics.prototype._initialize = function () {\n        this._mediaBoxUpperRightBound = 0;\n        this._characterSpacing = -1;\n        this._wordSpacing = -1;\n        this._textScaling = -100;\n        this._textRenderingMode = -1;\n        this._graphicsState = [];\n        this._clipBounds = [0, 0, this._size[0], this._size[1]];\n        this._colorSpaceInitialized = false;\n        this._startCutIndex = -1;\n    };\n    PdfGraphics.prototype._initializeCurrentColorSpace = function () {\n        if (!this._colorSpaceInitialized) {\n            this._sw._setColorSpace('DeviceRGB', true);\n            this._sw._setColorSpace('DeviceRGB', false);\n            this._colorSpaceInitialized = true;\n        }\n    };\n    PdfGraphics.prototype._brushControl = function (brush) {\n        this._sw._setColor(brush._color, false);\n        this._currentBrush = brush;\n    };\n    PdfGraphics.prototype._penControl = function (pen) {\n        this._currentPen = pen;\n        this._writePen(pen);\n        this._currentPen = pen;\n    };\n    PdfGraphics.prototype._fontControl = function (font, format) {\n        var _this = this;\n        var size = font._metrics._getSize(format);\n        this._currentFont = font;\n        var sourceDictionary;\n        var isReference = false;\n        var keyName;\n        var isNew = true;\n        var ref;\n        var hasResource = false;\n        if (this._resourceObject.has('Font')) {\n            var obj = this._resourceObject.getRaw('Font'); // eslint-disable-line\n            if (obj !== null && typeof obj !== 'undefined') {\n                if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                    isReference = true;\n                    sourceDictionary = this._crossReference._fetch(obj);\n                }\n                else if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary) {\n                    sourceDictionary = obj;\n                }\n            }\n            if (typeof sourceDictionary !== 'undefined' && sourceDictionary !== null) {\n                isNew = false;\n                this._resources.forEach(function (value, key) {\n                    if (_this._crossReference) {\n                        if (key !== null && typeof key !== 'undefined') {\n                            var dictionary = _this._crossReference._fetch(key);\n                            if (dictionary && ((font instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfStandardFont && dictionary === font._dictionary) ||\n                                (font instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfTrueTypeFont && dictionary === font._fontInternal._fontDictionary))) {\n                                keyName = value;\n                                ref = key;\n                                hasResource = true;\n                            }\n                        }\n                    }\n                    else if (font._reference && font._reference === key) {\n                        keyName = value;\n                        ref = key;\n                        hasResource = true;\n                    }\n                });\n            }\n        }\n        if (isNew) {\n            sourceDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary(this._crossReference);\n            this._resourceObject.update('Font', sourceDictionary);\n        }\n        if (typeof keyName === 'undefined') {\n            keyName = _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._getNewGuidString)());\n            if (!ref) {\n                if (font._reference) {\n                    ref = font._reference;\n                    sourceDictionary.update(keyName.name, ref);\n                }\n                else if (this._crossReference) {\n                    ref = this._crossReference._getNextReference();\n                }\n                else {\n                    this._pendingResource.push({ 'resource': font, 'key': keyName, 'source': sourceDictionary });\n                }\n            }\n            if (ref && this._crossReference) {\n                if (!font._reference) {\n                    font._reference = ref;\n                }\n                if (font._dictionary) {\n                    this._crossReference._cacheMap.set(ref, font._dictionary);\n                    sourceDictionary.update(keyName.name, ref);\n                }\n                else if (font instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfTrueTypeFont) {\n                    var internal = font._fontInternal;\n                    if (internal && internal._fontDictionary) {\n                        this._crossReference._cacheMap.set(ref, internal._fontDictionary);\n                    }\n                    sourceDictionary.update(keyName.name, ref);\n                }\n            }\n            if (!hasResource) {\n                this._resources.set(ref, keyName);\n            }\n        }\n        if (isReference) {\n            this._resourceObject._updated = true;\n        }\n        if (this._hasResourceReference) {\n            this._source._updated = true;\n        }\n        this._sw._setFont(keyName.name, size);\n    };\n    PdfGraphics.prototype._setPenBrush = function (first, second) {\n        var pen;\n        var brush;\n        if (first) {\n            if (first instanceof PdfPen) {\n                pen = first;\n            }\n            else {\n                brush = first;\n            }\n        }\n        if (second && second instanceof PdfBrush) {\n            brush = second;\n        }\n        this._stateControl(pen, brush, null);\n        return { pen: pen, brush: brush };\n    };\n    PdfGraphics.prototype._stateControl = function (pen, brush, font, format) {\n        if (pen || brush) {\n            this._initializeCurrentColorSpace();\n        }\n        if (pen) {\n            this._penControl(pen);\n        }\n        if (brush) {\n            this._brushControl(brush);\n        }\n        if (font) {\n            this._fontControl(font, format);\n        }\n    };\n    PdfGraphics.prototype._drawStringLayoutResult = function (result, font, pen, brush, layoutRectangle, format) {\n        if (!result._empty) {\n            var allowPartialLines = (format && typeof format.lineLimit !== 'undefined' && !format.lineLimit);\n            var shouldClip = (typeof format === 'undefined' || (format && typeof format.noClip !== 'undefined'\n                && !format.noClip));\n            var clipRegion = allowPartialLines && shouldClip;\n            var state = void 0;\n            if (clipRegion) {\n                state = this.save();\n                var clipBounds = [layoutRectangle[0], layoutRectangle[1], result._actualSize[0], result._actualSize[1]];\n                if (layoutRectangle[2] > 0) {\n                    clipBounds[2] = layoutRectangle[2];\n                }\n                if (format.lineAlignment === _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.middle) {\n                    clipBounds[1] += (layoutRectangle[3] - clipBounds[3]) / 2;\n                }\n                else if (format.lineAlignment === _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.bottom) {\n                    clipBounds[1] += (layoutRectangle[3] - clipBounds[3]);\n                }\n                this.setClip(clipBounds);\n            }\n            if (font && font instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfTrueTypeFont && font._fontInternal &&\n                font._fontInternal instanceof _fonts_unicode_true_type_font__WEBPACK_IMPORTED_MODULE_11__._UnicodeTrueTypeFont && font.isItalic) {\n                if (!font._fontInternal._ttfMetrics._isItalic) {\n                    state = this.save();\n                    this._isItalic = true;\n                }\n            }\n            this._applyStringSettings(font, pen, brush, format);\n            var textScaling = (typeof format !== 'undefined' && format !== null) ? format.horizontalScalingFactor : 100.0;\n            if (textScaling !== this._textScaling) {\n                this._sw._setTextScaling(textScaling);\n                this._textScaling = textScaling;\n            }\n            var verticalAlignShift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);\n            var height = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?\n                font._metrics._getHeight(format) :\n                format.lineSpacing + font._metrics._getHeight(format);\n            var script = (format !== null && typeof format !== 'undefined' &&\n                format.subSuperScript === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfSubSuperScript.subScript);\n            var shift = 0;\n            shift = (script) ? height - (font.height + font._metrics._getDescent(format)) : (height - font._metrics._getAscent(format));\n            if (format && format.lineAlignment === _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.bottom) {\n                if (layoutRectangle[3] - result._actualSize[1] !== 0 &&\n                    (layoutRectangle[3] - result._actualSize[1]) < (font._metrics._size / 2) - 1) {\n                    if (Number.parseFloat((0,_utils__WEBPACK_IMPORTED_MODULE_3__._numberToString)(layoutRectangle[3])) <=\n                        Number.parseFloat((0,_utils__WEBPACK_IMPORTED_MODULE_3__._numberToString)(font._metrics._getHeight(format)))) {\n                        shift = -(height / font._metrics._size);\n                    }\n                }\n            }\n            var matrix = new _PdfTransformationMatrix();\n            if (this._isItalic) {\n                this.translateTransform(layoutRectangle[0] + font.size / 5, layoutRectangle[1] - shift + verticalAlignShift);\n                this._skewTransform(0, -11);\n            }\n            else {\n                matrix._translate(layoutRectangle[0], (-(layoutRectangle[1] + font._metrics._getHeight(format)) -\n                    (font._metrics._getDescent(format) > 0 ? -font._metrics._getDescent(format) : font._metrics._getDescent(format))) -\n                    verticalAlignShift);\n                this._sw._modifyTM(matrix);\n            }\n            if (layoutRectangle[3] < font._metrics._size) {\n                if ((result._actualSize[1] - layoutRectangle[3]) < (font._metrics._size / 2) - 1) {\n                    verticalAlignShift = 0;\n                }\n            }\n            if (verticalAlignShift !== 0) {\n                if (format !== null && format.lineAlignment === _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.bottom) {\n                    if (layoutRectangle[3] - result._actualSize[1] !== 0 &&\n                        (layoutRectangle[3] - result._actualSize[1]) > (font._metrics._size / 2) - 1) {\n                        verticalAlignShift -= (shift - (height - font._metrics._size)) / 2;\n                    }\n                }\n            }\n            if (this._isItalic) {\n                this._sw._startNextLine(0, 0);\n                this._sw._setLeading(+height);\n            }\n            this._drawLayoutResult(result, font, format, layoutRectangle);\n            if (verticalAlignShift !== 0) {\n                this._sw._startNextLine(0, -(verticalAlignShift - result._lineHeight));\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('Text', this._resourceObject);\n            this._sw._endText();\n            if (this._isItalic) {\n                this.restore(state);\n            }\n            this._underlineStrikeoutText(brush, result, font, layoutRectangle, format);\n            if (clipRegion) {\n                this.restore(state);\n            }\n        }\n    };\n    PdfGraphics.prototype._getNextPage = function () {\n        var page;\n        var pageCount = this._crossReference._document.pageCount;\n        if (this._page._pageIndex <= pageCount - 2) {\n            page = this._crossReference._document.getPage(this._page._pageIndex + 1);\n        }\n        else {\n            page = this._crossReference._document.addPage();\n        }\n        return page;\n    };\n    PdfGraphics.prototype._applyStringSettings = function (font, pen, brush, format) {\n        var tm = _TextRenderingMode.fill;\n        var setLineWidth = false;\n        if (pen && brush) {\n            tm = _TextRenderingMode.fillStroke;\n        }\n        else if (pen) {\n            tm = _TextRenderingMode.stroke;\n        }\n        else if (brush) {\n            tm = _TextRenderingMode.fill;\n        }\n        if (font && font instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfTrueTypeFont && (font.isUnicode || (font._style & _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_5__.PdfFontStyle.bold) !== 0)) {\n            var fontName = font._fontInternal._metrics._postScriptName;\n            var isBoldFont = false;\n            if (fontName && fontName.toLocaleLowerCase().includes('bold')) {\n                isBoldFont = true;\n            }\n            if (font._fontInternal && font._fontInternal._metrics && font._fontInternal._metrics._isBold !==\n                font.isBold && font.isBold === true && !isBoldFont) {\n                if (!pen && brush) {\n                    pen = new PdfPen(brush._color, 1);\n                }\n                tm = _TextRenderingMode.fillStroke;\n                setLineWidth = true;\n            }\n        }\n        if (format && format.clipPath) {\n            tm |= _TextRenderingMode.clipFlag;\n        }\n        this._sw._beginText();\n        this._stateControl(pen, brush, font, format);\n        if (tm !== this._textRenderingMode) {\n            this._sw._setTextRenderingMode(tm);\n            this._textRenderingMode = tm;\n        }\n        var cs = (typeof format !== 'undefined' && format !== null) ? format.characterSpacing : 0;\n        if (cs !== this._characterSpacing) {\n            this._sw._setCharacterSpacing(cs);\n            this._characterSpacing = cs;\n        }\n        var ws = (typeof format !== 'undefined' && format !== null) ? format.wordSpacing : 0;\n        if (ws !== this._wordSpacing) {\n            this._sw._setWordSpacing(ws);\n            this._wordSpacing = ws;\n        }\n        if (font && setLineWidth) {\n            this._sw._setLineWidth(font.size / 30);\n        }\n    };\n    PdfGraphics.prototype._drawLayoutResult = function (result, font, format, layoutRectangle) {\n        var height = (typeof format === 'undefined' || format === null || format.lineSpacing === 0) ?\n            font._metrics._getHeight(format) :\n            format.lineSpacing + font._metrics._getHeight(format);\n        var lines = result._lines;\n        var ttfFont = font;\n        var unicode = (ttfFont !== null && ttfFont.isUnicode);\n        for (var i = 0, len = lines.length; (i < len && i !== this._startCutIndex); i++) {\n            var lineInfo = lines[Number.parseInt(i.toString(), 10)];\n            var lineWidth = lineInfo._width;\n            var hAlignShift = this._getHorizontalAlignShift(lineWidth, layoutRectangle[2], format) +\n                this._getLineIndent(lineInfo, format, layoutRectangle[2], (i === 0));\n            if (hAlignShift !== 0) {\n                this._sw._startNextLine(hAlignShift, 0);\n            }\n            if (unicode) {\n                this._drawUnicodeLine(lineInfo, layoutRectangle[2], font, format);\n            }\n            else {\n                this._drawAsciiLine(lineInfo, layoutRectangle[2], format, font);\n            }\n            if ((i + 1 !== len)) {\n                var vAlignShift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);\n                var matrix = new _PdfTransformationMatrix();\n                var baseline = ((-(layoutRectangle[1] + font._metrics._getHeight(format)) -\n                    font._metrics._getDescent(format)) -\n                    vAlignShift) -\n                    (height * (i + 1));\n                matrix._translate(layoutRectangle[0], baseline);\n                this._sw._modifyTM(matrix);\n            }\n        }\n    };\n    PdfGraphics.prototype._drawUnicodeLine = function (lineInfo, width, font, format) {\n        var line = lineInfo._text;\n        var rtl = (format !== null && typeof format !== 'undefined' && format.rightToLeft);\n        var useWordSpace = (format !== null && typeof format !== 'undefined' && format.wordSpacing > 0);\n        var ttfFont = font;\n        var wordSpacing = this._justifyLine(lineInfo, width, format, ttfFont);\n        var rtlRender = new _graphics_rightToLeft_text_renderer__WEBPACK_IMPORTED_MODULE_12__._RtlRenderer();\n        if (rtl || (format !== null && typeof format !== 'undefined' && format.textDirection !== _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextDirection.none)) {\n            var blocks = [];\n            var rightAlign = (format !== null && typeof format !== 'undefined' && format.alignment === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.right);\n            if (format !== null && typeof format !== 'undefined' && format.textDirection !== _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextDirection.none) {\n                blocks = rtlRender._layout(line, ttfFont, (format.textDirection === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextDirection.rightToLeft) ? true : false, useWordSpace, format);\n            }\n            else {\n                blocks = rtlRender._layout(line, ttfFont, rightAlign, useWordSpace, format);\n            }\n            var words = [];\n            if (blocks.length > 1) {\n                if (format !== null && typeof format !== 'undefined' && format.textDirection !== _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextDirection.none) {\n                    words = rtlRender._splitLayout(line, ttfFont, (format.textDirection === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextDirection.rightToLeft) ? true : false, useWordSpace, format);\n                }\n            }\n            else {\n                words = [line];\n            }\n            this._drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);\n        }\n        else {\n            if (useWordSpace) {\n                var result = this._breakUnicodeLine(line, ttfFont, null);\n                var blocks = result.tokens;\n                var words = result.words;\n                this._drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);\n            }\n            else {\n                var token = this._convertToUnicode(line, ttfFont);\n                this._sw._showNextLineText(token, true);\n            }\n        }\n    };\n    PdfGraphics.prototype._drawUnicodeBlocks = function (blocks, words, font, format, wordSpacing) {\n        if (blocks !== null && typeof blocks !== 'undefined' && blocks.length > 0 && words !== null && typeof words !== 'undefined' &&\n            words.length > 0 && font !== null && typeof font !== 'undefined') {\n            this._sw._startNextLine();\n            var x = 0;\n            var xShift = 0;\n            var firstLineIndent = 0;\n            var paragraphIndent = 0;\n            try {\n                if (format !== null && typeof format !== 'undefined') {\n                    firstLineIndent = format.firstLineIndent;\n                    paragraphIndent = format.paragraphIndent;\n                    format.firstLineIndent = 0;\n                    format.paragraphIndent = 0;\n                }\n                var spaceWidth = font._getCharacterWidth(_fonts_string_layouter__WEBPACK_IMPORTED_MODULE_6__._StringTokenizer._whiteSpace, format) + wordSpacing;\n                var characterSpacing = (format !== null) ? format.characterSpacing : 0;\n                var wordSpace = (format !== null && typeof format !== 'undefined' && wordSpacing === 0) ? format.wordSpacing : 0;\n                spaceWidth += characterSpacing + wordSpace;\n                for (var i = 0; i < blocks.length; i++) {\n                    var token = blocks[i]; //eslint-disable-line\n                    var word = words[i]; //eslint-disable-line\n                    var tokenWidth = 0;\n                    if (x !== 0) {\n                        this._sw._startNextLine(x, 0);\n                    }\n                    if (word.length > 0) {\n                        tokenWidth += font.measureString(word, format)[0];\n                        tokenWidth += characterSpacing;\n                        this._sw._showText(token);\n                    }\n                    if (i !== blocks.length - 1) {\n                        x = tokenWidth + spaceWidth;\n                        xShift += x;\n                    }\n                }\n                if (xShift > 0) {\n                    this._sw._startNextLine(-xShift, 0);\n                }\n            }\n            finally {\n                if (format !== null && typeof format !== 'undefined') {\n                    format.firstLineIndent = firstLineIndent;\n                    format.paragraphIndent = paragraphIndent;\n                }\n            }\n        }\n    };\n    PdfGraphics.prototype._breakUnicodeLine = function (line, ttfFont, words) {\n        var tokens = [];\n        if (line !== null && typeof line !== 'undefined' && line.length > 0) {\n            words = line.split(null);\n            for (var i = 0; i < words.length; i++) {\n                var word = words[i]; //eslint-disable-line\n                var token = this._convertToUnicode(word, ttfFont);\n                tokens[Number.parseInt(i.toString(), 10)] = token;\n            }\n        }\n        return { tokens: tokens, words: words };\n    };\n    PdfGraphics.prototype._convertToUnicode = function (text, ttfFont) {\n        var token = null;\n        if (text !== null && typeof text !== 'undefined' && ttfFont !== null && typeof ttfFont !== 'undefined' &&\n            ttfFont._fontInternal instanceof _fonts_unicode_true_type_font__WEBPACK_IMPORTED_MODULE_11__._UnicodeTrueTypeFont) {\n            var ttfReader = ttfFont._fontInternal._ttfReader;\n            ttfFont._setSymbols(text);\n            token = ttfReader._convertString(text);\n            var bytes = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._stringToUnicodeArray)(token);\n            token = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._bytesToString)(bytes);\n        }\n        return token;\n    };\n    PdfGraphics.prototype._getTextVerticalAlignShift = function (textHeight, boundsHeight, format) {\n        var shift = 0;\n        if (boundsHeight >= 0 && (typeof format !== 'undefined' && format !== null) && format.lineAlignment !== _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.top) {\n            switch (format.lineAlignment) {\n                case _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.middle:\n                    shift = (boundsHeight - textHeight) / 2;\n                    break;\n                case _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.bottom:\n                    shift = boundsHeight - textHeight;\n                    break;\n            }\n        }\n        return shift;\n    };\n    PdfGraphics.prototype._getHorizontalAlignShift = function (lineWidth, boundsWidth, format) {\n        var shift = 0;\n        if (boundsWidth >= 0 && (typeof format !== 'undefined' && format !== null) && format.alignment !== _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.left) {\n            switch (format.alignment) {\n                case _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.center:\n                    shift = (boundsWidth - lineWidth) / 2;\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.right:\n                    shift = boundsWidth - lineWidth;\n                    break;\n            }\n        }\n        return shift;\n    };\n    PdfGraphics.prototype._getLineIndent = function (lineInfo, format, width, firstLine) {\n        var lineIndent = 0;\n        var firstParagraphLine = ((lineInfo._lineType & _fonts_string_layouter__WEBPACK_IMPORTED_MODULE_6__._LineType.firstParagraphLine) > 0);\n        if (format && firstParagraphLine) {\n            lineIndent = (firstLine) ? format.firstLineIndent : format.paragraphIndent;\n            lineIndent = (width > 0) ? Math.min(width, lineIndent) : lineIndent;\n        }\n        return lineIndent;\n    };\n    PdfGraphics.prototype._drawAsciiLine = function (lineInfo, width, format, font) {\n        this._justifyLine(lineInfo, width, format, font);\n        var value = '';\n        if (lineInfo._text.indexOf('(') !== -1 || lineInfo._text.indexOf(')') !== -1) {\n            for (var i = 0; i < lineInfo._text.length; i++) {\n                if (lineInfo._text[Number.parseInt(i.toString(), 10)] === '(') {\n                    value += '\\\\\\('; // eslint-disable-line\n                }\n                else if (lineInfo._text[Number.parseInt(i.toString(), 10)] === ')') {\n                    value += '\\\\\\)'; // eslint-disable-line\n                }\n                else {\n                    value += lineInfo._text[Number.parseInt(i.toString(), 10)];\n                }\n            }\n        }\n        if (value === '') {\n            value = lineInfo._text;\n        }\n        this._sw._showNextLineText('(' + value + ')');\n    };\n    PdfGraphics.prototype._justifyLine = function (lineInfo, boundsWidth, format, font) {\n        var line = lineInfo._text;\n        var lineWidth = lineInfo._width;\n        var shouldJustify = this._shouldJustify(lineInfo, boundsWidth, format, font);\n        var hasWordSpacing = (format && format.wordSpacing !== 0);\n        var whitespacesCount = font._getCharacterCount(line, [' ', '\\t']);\n        var wordSpace = 0;\n        if (shouldJustify) {\n            if (hasWordSpacing) {\n                lineWidth -= (whitespacesCount * format.wordSpacing);\n            }\n            wordSpace = (boundsWidth - lineWidth) / whitespacesCount;\n            this._sw._setWordSpacing(wordSpace);\n        }\n        else if (format && format.alignment === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.justify) {\n            this._sw._setWordSpacing(0);\n        }\n        return wordSpace;\n    };\n    PdfGraphics.prototype._shouldJustify = function (lineInfo, boundsWidth, format, font) {\n        var line = lineInfo._text;\n        var lineWidth = lineInfo._width;\n        var justifyStyle = (format && format.alignment === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.justify);\n        var goodWidth = (boundsWidth >= 0 && lineWidth < boundsWidth);\n        var whitespacesCount = font._getCharacterCount(line, [' ', '\\t']);\n        var hasSpaces = (whitespacesCount > 0 && line[0] !== ' ');\n        var goodLineBreakStyle = ((lineInfo._lineType & _fonts_string_layouter__WEBPACK_IMPORTED_MODULE_6__._LineType.layoutBreak) > 0);\n        return (justifyStyle && goodWidth && hasSpaces && goodLineBreakStyle);\n    };\n    PdfGraphics.prototype._underlineStrikeoutText = function (brush, result, font, layoutRectangle, format) {\n        if (font.isUnderline || font.isStrikeout) {\n            var linePen = this._createUnderlineStrikeoutPen(brush, font);\n            if (typeof linePen !== 'undefined' && linePen !== null) {\n                var shift = this._getTextVerticalAlignShift(result._actualSize[1], layoutRectangle[3], format);\n                var underlineYOffset = layoutRectangle[1] + shift + font._metrics._getAscent(format) + 1.5 * linePen._width;\n                var strikeoutYOffset = layoutRectangle[1] + shift + font._metrics._getHeight(format) / 2 + 1.5 * linePen._width;\n                var lines = result._lines;\n                for (var i = 0; i < result._lineCount; i++) {\n                    var lineInfo = lines[Number.parseInt(i.toString(), 10)];\n                    var lineWidth = lineInfo._width;\n                    var hShift = this._getHorizontalAlignShift(lineWidth, layoutRectangle[2], format);\n                    var lineIndent = this._getLineIndent(lineInfo, format, layoutRectangle[2], (i === 0));\n                    var x1 = layoutRectangle[0] + hShift;\n                    var x2 = (!this._shouldJustify(lineInfo, layoutRectangle[2], format, font)) ?\n                        x1 + lineWidth - lineIndent :\n                        x1 + layoutRectangle[2] - lineIndent;\n                    if (font.isUnderline) {\n                        this.drawLine(linePen, x1, underlineYOffset, x2, underlineYOffset);\n                        underlineYOffset += result._lineHeight;\n                    }\n                    if (font.isStrikeout) {\n                        this.drawLine(linePen, x1, strikeoutYOffset, x2, strikeoutYOffset);\n                        strikeoutYOffset += result._lineHeight;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Draws a line on the page graphics.\n     *\n     * @param {PdfPen} pen The pen that determines the stroke color, width, and style of the line.\n     * @param {number} x1 The x-coordinate of the starting point of the line.\n     * @param {number} y1 The y-coordinate of the starting point of the line.\n     * @param {number} x2 The x-coordinate of the ending point of the line.\n     * @param {number} y2 The y-coordinate of the ending point of the line.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new pen\n     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n     * // Draw a line on the page graphics\n     * graphics.drawLine(pen, 10, 10, 100, 100);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.drawLine = function (pen, x1, y1, x2, y2) {\n        this._beginMarkContent();\n        this._stateControl(pen);\n        this._sw._beginPath(x1, y1);\n        this._sw._appendLineSegment(x2, y2);\n        this._sw._strokePath();\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._addProcSet)('PDF', this._resourceObject);\n        this._endMarkContent();\n    };\n    PdfGraphics.prototype._createUnderlineStrikeoutPen = function (brush, font) {\n        return new PdfPen(brush._color, font._metrics._size / 20);\n    };\n    PdfGraphics.prototype._checkCorrectLayoutRectangle = function (textSize, x, y, format) {\n        var layoutedRectangle = [x, y, textSize[0], textSize[0]];\n        if (format) {\n            switch (format.alignment) {\n                case _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.center:\n                    layoutedRectangle[0] = layoutedRectangle[0] - layoutedRectangle[2] / 2;\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfTextAlignment.right:\n                    layoutedRectangle[0] = layoutedRectangle[0] - layoutedRectangle[2];\n                    break;\n            }\n            switch (format.lineAlignment) {\n                case _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.middle:\n                    layoutedRectangle[1] = layoutedRectangle[1] - layoutedRectangle[3] / 2;\n                    break;\n                case _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_8__.PdfVerticalAlignment.bottom:\n                    layoutedRectangle[1] = layoutedRectangle[1] - layoutedRectangle[3];\n                    break;\n            }\n        }\n        return layoutedRectangle;\n    };\n    PdfGraphics.prototype._drawGraphicsPath = function (pen, brush, fillMode, needClosing) {\n        if (typeof fillMode === 'undefined') {\n            fillMode = _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfFillMode.winding;\n        }\n        var isBrush = (typeof brush !== 'undefined' && brush !== null);\n        var isPen = (typeof pen !== 'undefined' && pen !== null);\n        var isEvenOdd = fillMode === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfFillMode.alternate;\n        if (isPen && isBrush) {\n            if (needClosing) {\n                this._sw._closeFillStrokePath(isEvenOdd);\n            }\n            else {\n                this._sw._fillStrokePath(isEvenOdd);\n            }\n        }\n        else if (!isPen && !isBrush) {\n            this._sw._endPath();\n        }\n        else if (isPen) {\n            if (needClosing) {\n                this._sw._closeStrokePath();\n            }\n            else {\n                this._sw._strokePath();\n            }\n        }\n        else {\n            if (needClosing) {\n                this._sw._closeFillPath(isEvenOdd);\n            }\n            else {\n                this._sw._fillPath(isEvenOdd);\n            }\n        }\n    };\n    PdfGraphics.prototype._initializeCoordinates = function (page) {\n        var cbox;\n        if (page) {\n            var location_1 = [0, 0];\n            var needTransformation = false;\n            if (page._pageDictionary.has('CropBox') && page._pageDictionary.has('MediaBox')) {\n                cbox = page._pageDictionary.getArray('CropBox');\n                var mbox = page._pageDictionary.getArray('MediaBox');\n                if (cbox[0] === mbox[0] && cbox[1] === mbox[1] && cbox[2] === mbox[2] && cbox[3] === mbox[3]) {\n                    needTransformation = true;\n                }\n                if (cbox[0] > 0 && cbox[3] > 0 && mbox[0] < 0 && mbox[1] < 0) {\n                    this.translateTransform(cbox[0], -cbox[3]);\n                    location_1[0] = -cbox[0];\n                    location_1[1] = cbox[3];\n                }\n                else if (!page._pageDictionary.has('CropBox')) {\n                    needTransformation = true;\n                }\n                if (needTransformation) {\n                    this._sw._writeComment('Change co-ordinate system to left/top.');\n                    if (this._cropBox) {\n                        this.translateTransform(this._cropBox[0], -this._cropBox[3]);\n                    }\n                    else {\n                        if (-(page._origin[1]) < this._mediaBoxUpperRightBound || this._mediaBoxUpperRightBound === 0) {\n                            this.translateTransform(0, -this._size[1]);\n                        }\n                        else {\n                            this.translateTransform(0, -this._mediaBoxUpperRightBound);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            this._sw._writeComment('Change co-ordinate system to left/top.');\n            if (this._mediaBoxUpperRightBound !== (-this._size[1])) {\n                if (this._cropBox) {\n                    cbox = this._cropBox;\n                    if (cbox[0] > 0 || cbox[1] > 0 || this._size[0] === cbox[2] || this._size[1] === cbox[3]) {\n                        this.translateTransform(cbox[0], -cbox[3]);\n                    }\n                    else {\n                        if (this._mediaBoxUpperRightBound === this._size[1] || this._mediaBoxUpperRightBound === 0) {\n                            this.translateTransform(0, -this._size[1]);\n                        }\n                        else {\n                            this.translateTransform(0, -this._mediaBoxUpperRightBound);\n                        }\n                    }\n                }\n                else {\n                    if (this._mediaBoxUpperRightBound === this._size[1] || this._mediaBoxUpperRightBound === 0) {\n                        this.translateTransform(0, -this._size[1]);\n                    }\n                    else {\n                        this.translateTransform(0, -this._mediaBoxUpperRightBound);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Represents a scale transform of the graphics.\n     *\n     * @param {number} scaleX Scale factor in the x direction.\n     * @param {number} scaleY Scale factor in the y direction.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new font\n     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // Save the current graphics state\n     * let state: PdfGraphicsState = graphics.save();\n     * // Apply scale transform\n     * graphics.scaleTransform(0.5, 0.5);\n     * // Draw a string with the scaled transformation\n     * graphics.drawString(\"Hello world!\", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n     * // Restore the graphics to its previous state\n     * graphics.restore(state);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.scaleTransform = function (scaleX, scaleY) {\n        var matrix = new _PdfTransformationMatrix();\n        matrix._scale(scaleX, scaleY);\n        this._sw._modifyCtm(matrix);\n        this._matrix._multiply(matrix);\n    };\n    /**\n     * Represents a translate transform of the graphics.\n     *\n     * @param {number} x x-coordinate of the translation.\n     * @param {number} y y-coordinate of the translation.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new font\n     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // Save the current graphics state\n     * let state: PdfGraphicsState = graphics.save();\n     * // Apply translate transform\n     * graphics.translateTransform(100, 100);\n     * // Draw a string with the translation applied\n     * graphics.drawString(\"Hello world!\", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n     * // Restore the graphics to its previous state\n     * graphics.restore(state);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.translateTransform = function (x, y) {\n        var matrix = new _PdfTransformationMatrix();\n        matrix._translate(x, -y);\n        this._sw._modifyCtm(matrix);\n        this._matrix._multiply(matrix);\n    };\n    /**\n     * Represents a rotate transform of the graphics.\n     *\n     * @param {number} angle Angle of rotation in degrees.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new font\n     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // Save the current graphics state\n     * let state: PdfGraphicsState = graphics.save();\n     * // Apply rotate transform\n     * graphics.rotateTransform(-90);\n     * // Draw a string with the rotation applied\n     * graphics.drawString(\"Hello world!\", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n     * // Restore the graphics to its previous state\n     * graphics.restore(state);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.rotateTransform = function (angle) {\n        var matrix = new _PdfTransformationMatrix();\n        matrix._rotate(-angle);\n        this._sw._modifyCtm(matrix);\n        this._matrix._multiply(matrix);\n    };\n    /**\n     * Represents a clipping region of this graphics.\n     *\n     * @param {number[]} bounds Rectangle structure that represents the new clip region, specified as [x, y, width, height].\n     * @param {PdfFillMode} mode Member of the PdfFillMode enumeration that specifies the filling operation to use.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new font\n     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // Set clipping region\n     * graphics.setClip([0, 0, 50, 12], PdfFillMode.alternate);\n     * // Draw a string within the clipping region\n     * graphics.drawString(\"Hello world!\", font, [0, 0, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.setClip = function (bounds, mode) {\n        if (typeof mode === 'undefined') {\n            mode = _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfFillMode.winding;\n        }\n        this._sw._appendRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);\n        this._sw._clipPath(mode === _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfFillMode.alternate);\n    };\n    /**\n     * Sets the transparency for the graphics.\n     *\n     * @param {number} stroke The transparency value for strokes.\n     * @param {number} fill The transparency value for fills.\n     * @param {PdfBlendMode} mode The blend mode to use.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new font\n     * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n     * // Set transparency\n     * graphics.setTransparency(0.5, 0.5, PdfBlendMode.multiply);\n     * // Draw the string\n     * graphics.drawString(\"Hello world!\", font, [0, 0, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfGraphics.prototype.setTransparency = function (stroke, fill, mode) {\n        if (typeof fill === 'undefined') {\n            fill = stroke;\n        }\n        if (typeof mode === 'undefined') {\n            mode = _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfBlendMode.normal;\n        }\n        if (typeof this._transparencies === 'undefined') {\n            this._transparencies = new Map();\n        }\n        var transparencyKey = 'CA:' + stroke.toString() + '_ca:' + fill.toString() + '_BM:' + mode.toString();\n        var transparencyData;\n        if (this._transparencies.size > 0) {\n            this._transparencies.forEach(function (value, key) {\n                if (value === transparencyKey) {\n                    transparencyData = key;\n                }\n            });\n        }\n        if (!transparencyData) {\n            transparencyData = new _TransparencyData();\n            var transparencyDict = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary();\n            transparencyDict.update('CA', stroke);\n            transparencyDict.update('ca', fill);\n            transparencyDict.update('BM', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapBlendMode)(mode));\n            var ref = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(ref, transparencyDict);\n            transparencyData._dictionary = transparencyDict;\n            transparencyData._key = transparencyKey;\n            transparencyData._name = _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._getNewGuidString)());\n            transparencyData._reference = ref;\n            var dictionary = void 0;\n            var isReference = false;\n            if (this._resourceObject.has('ExtGState')) {\n                var obj = this._resourceObject.getRaw('ExtGState'); // eslint-disable-line\n                if (obj !== null && typeof obj !== 'undefined') {\n                    if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfReference) {\n                        isReference = true;\n                        dictionary = this._crossReference._fetch(obj);\n                    }\n                    else if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary) {\n                        dictionary = obj;\n                    }\n                }\n            }\n            else {\n                dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_4__._PdfDictionary(this._crossReference);\n                this._resourceObject.update('ExtGState', dictionary);\n            }\n            dictionary.update(transparencyData._name.name, ref);\n            if (isReference) {\n                this._resourceObject._updated = true;\n            }\n            if (this._hasResourceReference) {\n                this._source._updated = true;\n            }\n        }\n        this._sw._setGraphicsState(transparencyData._name);\n    };\n    PdfGraphics.prototype._setTransparencyData = function (ref, name) {\n        this._resourceMap.set(ref, name);\n        var dictionary = this._crossReference._fetch(ref);\n        var stroke = 0;\n        var fill = 0;\n        var mode = 0;\n        if (dictionary) {\n            if (dictionary.has('CA')) {\n                stroke = dictionary.get('CA');\n            }\n            if (dictionary.has('ca')) {\n                fill = dictionary.get('ca');\n            }\n            if (dictionary.has('ca')) {\n                fill = dictionary.get('ca');\n            }\n            if (dictionary.has('BM')) {\n                mode = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBlendMode)(dictionary.get('BM'));\n            }\n        }\n        var tkey = 'CA:' + stroke.toString() + '_ca:' + fill.toString() + '_BM:' + mode.toString();\n        var tdata = new _TransparencyData();\n        tdata._dictionary = dictionary;\n        tdata._key = tkey;\n        tdata._name = name;\n        tdata._reference = ref;\n        this._transparencies.set(tdata, tkey);\n    };\n    PdfGraphics.prototype._getTranslateTransform = function (x, y, input) {\n        input._translate(x, -y);\n        return input;\n    };\n    PdfGraphics.prototype._getScaleTransform = function (x, y, input) {\n        if (input === null || typeof input === 'undefined') {\n            input = new _PdfTransformationMatrix();\n        }\n        input._scale(x, y);\n        return input;\n    };\n    PdfGraphics.prototype._clipTranslateMargins = function (clipBounds) {\n        this._clipBounds = clipBounds;\n        this._sw._writeComment('Clip margins.');\n        this._sw._appendRectangle(clipBounds[0], clipBounds[1], clipBounds[2], clipBounds[3]);\n        this._sw._closePath();\n        this._sw._clipPath(false);\n        this._sw._writeComment('Translate co-ordinate system.');\n        this.translateTransform(clipBounds[0], clipBounds[1]);\n    };\n    PdfGraphics.prototype._skewTransform = function (angleX, angleY) {\n        var matrix = new _PdfTransformationMatrix();\n        this._getSkewTransform(angleX, angleY, matrix);\n        this._sw._modifyCtm(matrix);\n        matrix._multiply(matrix);\n    };\n    PdfGraphics.prototype._getSkewTransform = function (angleX, angleY, input) {\n        input._skew(-angleX, -angleY);\n        return input;\n    };\n    return PdfGraphics;\n}());\n\nvar _PdfTransformationMatrix = /** @class */ (function () {\n    function _PdfTransformationMatrix() {\n        this._matrix = new _Matrix(1, 0, 0, 1, 0, 0);\n    }\n    _PdfTransformationMatrix.prototype._translate = function (x, y) {\n        this._matrix._translate(x, y);\n    };\n    _PdfTransformationMatrix.prototype._scale = function (x, y) {\n        this._matrix._elements[0] = x;\n        this._matrix._elements[3] = y;\n    };\n    _PdfTransformationMatrix.prototype._rotate = function (angle) {\n        angle = (angle * Math.PI) / 180;\n        this._matrix._elements[0] = Math.cos(angle);\n        this._matrix._elements[1] = Math.sin(angle);\n        this._matrix._elements[2] = -Math.sin(angle);\n        this._matrix._elements[3] = Math.cos(angle);\n    };\n    _PdfTransformationMatrix.prototype._multiply = function (matrix) {\n        this._matrix._multiply(matrix._matrix);\n    };\n    _PdfTransformationMatrix.prototype._toString = function () {\n        var builder = '';\n        for (var i = 0, len = this._matrix._elements.length; i < len; i++) {\n            builder += (0,_utils__WEBPACK_IMPORTED_MODULE_3__._floatToString)(this._matrix._elements[Number.parseInt(i.toString(), 10)]) + ' ';\n        }\n        return builder;\n    };\n    _PdfTransformationMatrix.prototype._skew = function (angleX, angleY) {\n        var tanA = Math.tan(this._degreeToRadians(angleX));\n        var tanB = Math.tan(this._degreeToRadians(angleY));\n        var skew = new _Matrix(1, tanA, tanB, 1, 0, 0);\n        this._matrix._multiply(skew);\n    };\n    _PdfTransformationMatrix.prototype._degreeToRadians = function (degreesX) {\n        var degreeRadFactor = Math.PI / 180;\n        return degreeRadFactor * degreesX;\n    };\n    return _PdfTransformationMatrix;\n}());\n\nvar _Matrix = /** @class */ (function () {\n    function _Matrix(arg1, arg2, arg3, arg4, arg5, arg6) {\n        if (typeof arg1 === 'undefined') {\n            this._elements = [];\n        }\n        else if (typeof arg1 === 'number') {\n            this._elements = [arg1, arg2, arg3, arg4, arg5, arg6];\n        }\n        else {\n            this._elements = arg1;\n        }\n    }\n    Object.defineProperty(_Matrix.prototype, \"_offsetX\", {\n        get: function () {\n            return this._elements[4];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_Matrix.prototype, \"_offsetY\", {\n        get: function () {\n            return this._elements[5];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    _Matrix.prototype._clone = function () {\n        return new _Matrix(this._elements.slice());\n    };\n    _Matrix.prototype._translate = function (x, y) {\n        this._elements[4] = x;\n        this._elements[5] = y;\n    };\n    _Matrix.prototype._transform = function (points) {\n        var x = points[0];\n        var y = points[1];\n        var x2 = x * this._elements[0] + y * this._elements[2] + this._offsetX;\n        var y2 = x * this._elements[1] + y * this._elements[3] + this._offsetY;\n        return [x2, y2];\n    };\n    _Matrix.prototype._multiply = function (matrix) {\n        this._elements = [(this._elements[0] * matrix._elements[0] + this._elements[1] * matrix._elements[2]),\n            (this._elements[0] * matrix._elements[1] + this._elements[1] * matrix._elements[3]),\n            (this._elements[2] * matrix._elements[0] + this._elements[3] * matrix._elements[2]),\n            (this._elements[2] * matrix._elements[1] + this._elements[3] * matrix._elements[3]),\n            (this._offsetX * matrix._elements[0] + this._offsetY * matrix._elements[2] + matrix._offsetX),\n            (this._offsetX * matrix._elements[1] + this._offsetY * matrix._elements[3] + matrix._offsetY)];\n    };\n    return _Matrix;\n}());\n\n/**\n * Represents a state of the graphics from a PDF page.\n *\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new font\n * let font: PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);\n * // Save the graphics state\n * let state: PdfGraphicsState = graphics.save();\n * // Set graphics translate transform\n * graphics.translateTransform(100, 100);\n * // Draw the string\n * graphics.drawString(\"Hello world!\", font, [10, 20, 100, 200], undefined, new PdfBrush([0, 0, 255]));\n * // Restore the graphics state\n * graphics.restore(state);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfGraphicsState = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `PdfGraphicsState` class.\n     *\n     * @private\n     * @param {PdfGraphics} graphics Graphics.\n     * @param {_PdfTransformationMatrix} matrix Matrix.\n     *\n     */\n    function PdfGraphicsState(graphics, matrix) {\n        if (graphics) {\n            this._g = graphics;\n            this._transformationMatrix = matrix;\n        }\n        this._charSpacing = 0;\n        this._wordSpacing = 0;\n        this._textScaling = 100;\n        this._textRenderingMode = _TextRenderingMode.fill;\n    }\n    return PdfGraphicsState;\n}());\n\nvar _TransparencyData = /** @class */ (function () {\n    function _TransparencyData() {\n    }\n    return _TransparencyData;\n}());\nvar _TextRenderingMode;\n(function (_TextRenderingMode) {\n    _TextRenderingMode[_TextRenderingMode[\"fill\"] = 0] = \"fill\";\n    _TextRenderingMode[_TextRenderingMode[\"stroke\"] = 1] = \"stroke\";\n    _TextRenderingMode[_TextRenderingMode[\"fillStroke\"] = 2] = \"fillStroke\";\n    _TextRenderingMode[_TextRenderingMode[\"none\"] = 3] = \"none\";\n    _TextRenderingMode[_TextRenderingMode[\"clipFlag\"] = 4] = \"clipFlag\";\n    _TextRenderingMode[_TextRenderingMode[\"clipFill\"] = 4] = \"clipFill\";\n    _TextRenderingMode[_TextRenderingMode[\"clipStroke\"] = 5] = \"clipStroke\";\n    _TextRenderingMode[_TextRenderingMode[\"clipFillStroke\"] = 6] = \"clipFillStroke\";\n    _TextRenderingMode[_TextRenderingMode[\"clip\"] = 7] = \"clip\";\n})(_TextRenderingMode || (_TextRenderingMode = {}));\n/**\n * Represents a brush for the PDF page.\n *\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new brush\n * let brush: PdfBrush = new PdfBrush([0, 255, 255]);\n * // Draw a rectangle using brush\n * graphics.drawRectangle(10, 10, 100, 100, brush);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfBrush = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `PdfBrush` class.\n     *\n     * @param {number[]} color Color.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new brush\n     * let brush: PdfBrush = new PdfBrush([0, 255, 255]);\n     * // Draw a rectangle using brush\n     * graphics.drawRectangle(10, 10, 100, 100, brush);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    function PdfBrush(color) {\n        this._color = typeof color !== 'undefined' ? color : [0, 0, 0];\n    }\n    return PdfBrush;\n}());\n\n/**\n * Represents a pen for the PDF page.\n *\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Gets the graphics of the PDF page\n * let graphics: PdfGraphics = page.graphics;\n * // Create a new pen\n * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n * // Draw a rectangle using pen\n * graphics.drawRectangle(150, 50, 50, 50, pen);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPen = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `PdfPen` class.\n     *\n     * @param {number[]} color Color.\n     * @param {number} width Width.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access first page\n     * let page: PdfPage = document.getPage(0);\n     * // Gets the graphics of the PDF page\n     * let graphics: PdfGraphics = page.graphics;\n     * // Create a new pen\n     * let pen: PdfPen = new PdfPen([0, 0, 0], 1);\n     * // Draw a rectangle using pen\n     * graphics.drawRectangle(150, 50, 50, 50, pen);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    function PdfPen(color, width) {\n        this._color = color;\n        this._width = width;\n        this._dashOffset = 0;\n        this._dashPattern = [];\n        this._dashStyle = _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfDashStyle.solid;\n        this._miterLimit = 0;\n        this._lineCap = _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfLineCap.flat;\n        this._lineJoin = _enumerator__WEBPACK_IMPORTED_MODULE_7__.PdfLineJoin.miter;\n    }\n    return PdfPen;\n}());\n\nvar _PdfUnitConvertor = /** @class */ (function () {\n    function _PdfUnitConvertor() {\n        this._horizontalResolution = 96;\n        this._proportions = this._updateProportions(this._horizontalResolution);\n    }\n    _PdfUnitConvertor.prototype._updateProportions = function (pixel) {\n        return [pixel / 2.54, pixel / 6.0, 1, pixel / 72.0, pixel, pixel / 300.0, pixel / 25.4];\n    };\n    _PdfUnitConvertor.prototype._convertUnits = function (value, from, to) {\n        return this._convertFromPixels(this._convertToPixels(value, from), to);\n    };\n    _PdfUnitConvertor.prototype._convertFromPixels = function (value, to) {\n        var index = to;\n        return (value / this._proportions[Number.parseInt(index.toString(), 10)]);\n    };\n    _PdfUnitConvertor.prototype._convertToPixels = function (value, from) {\n        var index = from;\n        return (value * this._proportions[Number.parseInt(index.toString(), 10)]);\n    };\n    return _PdfUnitConvertor;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-graphics.js?");

/***/ })

}]);