"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_annotation_annotation_js-1329ff9e"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/annotation.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/annotation.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnnotBoundsBase: () => (/* binding */ AnnotBoundsBase),\n/* harmony export */   AnnotBoundsRect: () => (/* binding */ AnnotBoundsRect),\n/* harmony export */   AnnotFontBase: () => (/* binding */ AnnotFontBase),\n/* harmony export */   AnnotRectBase: () => (/* binding */ AnnotRectBase),\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationBaseSettings: () => (/* binding */ AnnotationBaseSettings),\n/* harmony export */   AnnotationsBase: () => (/* binding */ AnnotationsBase),\n/* harmony export */   AnnotationsInternal: () => (/* binding */ AnnotationsInternal),\n/* harmony export */   IBounds: () => (/* binding */ IBounds)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-inputs */ \"./node_modules/@syncfusion/ej2-inputs/index.js\");\n/* harmony import */ var _syncfusion_ej2_popups__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @syncfusion/ej2-popups */ \"./node_modules/@syncfusion/ej2-popups/index.js\");\n/* harmony import */ var _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-splitbuttons */ \"./node_modules/@syncfusion/ej2-splitbuttons/index.js\");\n/* harmony import */ var _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @syncfusion/ej2-drawings */ \"./node_modules/@syncfusion/ej2-drawings/index.js\");\n/* harmony import */ var _drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawing/drawing-util */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/drawing-util.js\");\n/* harmony import */ var _drawing_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../drawing/tools */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/tools.js\");\n/* harmony import */ var _drawing_connector_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../drawing/connector-util */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/connector-util.js\");\n/* harmony import */ var _free_text_annotation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./free-text-annotation */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/free-text-annotation.js\");\n/* harmony import */ var _input_element__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./input-element */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/input-element.js\");\n/* harmony import */ var _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @syncfusion/ej2-inplace-editor */ \"./node_modules/@syncfusion/ej2-inplace-editor/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The `Annotation` module is used to handle annotation actions of PDF viewer.\n */\nvar Annotation = /** @class */ (function () {\n    /**\n     * @param {PdfViewer} pdfViewer - pdfViewer\n     * @param {PdfViewerBase} viewerBase - viewerBase\n     * @private\n     */\n    function Annotation(pdfViewer, viewerBase) {\n        /**\n         * @private\n         */\n        this.isUndoRedoAction = false;\n        this.isFreeTextFontsizeChanged = false;\n        this.isUndoAction = false;\n        this.annotationSelected = true;\n        this.isAnnotDeletionApiCall = false;\n        this.removedDocumentAnnotationCollection = [];\n        /**\n         * @private\n         * It is used to store the non render page selected annotation.\n         */\n        this.nonRenderSelectedAnnotation = null;\n        /**\n         * @private\n         */\n        this.isShapeCopied = false;\n        /**\n         * @private\n         */\n        this.actionCollection = [];\n        /**\n         * @private\n         */\n        this.redoCollection = [];\n        /**\n         * @private\n         */\n        this.isPopupNoteVisible = false;\n        /**\n         * @private\n         */\n        this.undoCommentsElement = [];\n        /**\n         * @private\n         */\n        this.redoCommentsElement = [];\n        /**\n         * @private\n         */\n        this.selectAnnotationId = null;\n        /**\n         * @private\n         */\n        this.isAnnotationSelected = false;\n        /**\n         * @private\n         */\n        this.annotationPageIndex = null;\n        this.previousIndex = null;\n        /**\n         * @private\n         */\n        this.annotationType = null;\n        this.overlappedAnnotations = [];\n        /**\n         * @private\n         */\n        this.overlappedCollections = [];\n        /**\n         * @private\n         */\n        this.isFormFieldShape = false;\n        /**\n         * @private\n         */\n        this.removedAnnotationCollection = [];\n        this.pdfViewer = pdfViewer;\n        this.pdfViewerBase = viewerBase;\n        if (this.pdfViewer.enableTextMarkupAnnotation) {\n            this.textMarkupAnnotationModule = new _index__WEBPACK_IMPORTED_MODULE_0__.TextMarkupAnnotation(this.pdfViewer, this.pdfViewerBase);\n        }\n        if (this.pdfViewer.enableShapeAnnotation) {\n            this.shapeAnnotationModule = new _index__WEBPACK_IMPORTED_MODULE_0__.ShapeAnnotation(this.pdfViewer, this.pdfViewerBase);\n        }\n        if (this.pdfViewer.enableMeasureAnnotation) {\n            this.measureAnnotationModule = new _index__WEBPACK_IMPORTED_MODULE_0__.MeasureAnnotation(this.pdfViewer, this.pdfViewerBase);\n        }\n        this.stampAnnotationModule = new _index__WEBPACK_IMPORTED_MODULE_0__.StampAnnotation(this.pdfViewer, this.pdfViewerBase);\n        this.stickyNotesAnnotationModule = new _index__WEBPACK_IMPORTED_MODULE_0__.StickyNotesAnnotation(this.pdfViewer, this.pdfViewerBase);\n        this.freeTextAnnotationModule = new _free_text_annotation__WEBPACK_IMPORTED_MODULE_9__.FreeTextAnnotation(this.pdfViewer, this.pdfViewerBase);\n        this.inputElementModule = new _input_element__WEBPACK_IMPORTED_MODULE_10__.InputElement(this.pdfViewer, this.pdfViewerBase);\n        this.inkAnnotationModule = new _index__WEBPACK_IMPORTED_MODULE_0__.InkAnnotation(this.pdfViewer, this.pdfViewerBase);\n    }\n    /**\n     * Set annotation type to be added in next user interaction in PDF Document.\n     *\n     * @param {AnnotationType} type - type\n     * @param {DynamicStampItem} dynamicStampItem - dynamicStampItem\n     * @param {SignStampItem} signStampItem - signStampItem\n     * @param {StandardBusinessStampItem} standardBusinessStampItem - standardBusinessStampItem.\n     * @returns {void}\n     */\n    Annotation.prototype.setAnnotationMode = function (type, dynamicStampItem, signStampItem, standardBusinessStampItem) {\n        var allowServerDataBind = this.pdfViewer.allowServerDataBinding;\n        this.pdfViewer.enableServerDataBinding(false);\n        if (this.pdfViewer.tool === 'Stamp' && this.pdfViewer.toolbarModule) {\n            this.pdfViewer.toolbarModule.updateStampItems();\n        }\n        if (this.pdfViewer.toolbarModule && this.pdfViewer.toolbarModule.annotationToolbarModule) {\n            this.pdfViewer.toolbarModule.annotationToolbarModule.resetFreeTextAnnot();\n        }\n        if (type !== 'None') {\n            this.triggerAnnotationUnselectEvent();\n        }\n        this.pdfViewer.tool = '';\n        if (this.pdfViewer.toolbarModule) {\n            this.pdfViewer.toolbarModule.deSelectCommentAnnotation();\n        }\n        if (type === 'None') {\n            this.clearAnnotationMode();\n        }\n        else if (type === 'Highlight' || type === 'Strikethrough' || type === 'Underline') {\n            if (this.textMarkupAnnotationModule) {\n                this.textMarkupAnnotationModule.isSelectionMaintained = false;\n                this.textMarkupAnnotationModule.drawTextMarkupAnnotations(type.toString());\n            }\n        }\n        else if (type === 'Line' || type === 'Arrow' || type === 'Rectangle' || type === 'Circle' || type === 'Polygon') {\n            if (this.shapeAnnotationModule) {\n                this.shapeAnnotationModule.setAnnotationType(type);\n            }\n        }\n        else if (type === 'Distance' || type === 'Perimeter' || type === 'Area' || type === 'Radius' || type === 'Volume') {\n            if (this.measureAnnotationModule) {\n                this.measureAnnotationModule.setAnnotationType(type);\n            }\n        }\n        else if (type === 'FreeText' && this.freeTextAnnotationModule) {\n            this.freeTextAnnotationModule.setAnnotationType('FreeText');\n            this.freeTextAnnotationModule.isNewFreeTextAnnot = true;\n            this.freeTextAnnotationModule.isNewAddedAnnot = true;\n        }\n        else if (type === 'HandWrittenSignature') {\n            this.pdfViewerBase.signatureModule.setAnnotationMode();\n        }\n        else if (type === 'Initial') {\n            this.pdfViewerBase.signatureModule.setInitialMode();\n        }\n        else if (type === 'Ink') {\n            this.inkAnnotationModule.setAnnotationMode();\n        }\n        else if (type === 'StickyNotes') {\n            this.pdfViewerBase.isCommentIconAdded = true;\n            this.pdfViewerBase.isAddComment = true;\n            var pageDiv = document.getElementById(this.pdfViewer.element.id + '_pageDiv_' + (this.pdfViewerBase.currentPageNumber - 1));\n            if (pageDiv) {\n                pageDiv.addEventListener('mousedown', this.pdfViewer.annotationModule.stickyNotesAnnotationModule.drawIcons.bind(this));\n            }\n        }\n        else if (type === 'Stamp') {\n            this.pdfViewer.annotation.stampAnnotationModule.isStampAddMode = true;\n            this.pdfViewer.annotationModule.stampAnnotationModule.isStampAnnotSelected = true;\n            this.pdfViewerBase.stampAdded = true;\n            if (dynamicStampItem) {\n                // eslint-disable-next-line\n                var stampName = _index__WEBPACK_IMPORTED_MODULE_0__.DynamicStampItem[dynamicStampItem];\n                this.pdfViewerBase.isDynamicStamp = true;\n                this.stampAnnotationModule.retrieveDynamicStampAnnotation(stampName);\n            }\n            else if (signStampItem) {\n                // eslint-disable-next-line\n                var stampName = _index__WEBPACK_IMPORTED_MODULE_0__.SignStampItem[signStampItem];\n                this.pdfViewerBase.isDynamicStamp = false;\n                this.stampAnnotationModule.retrievestampAnnotation(stampName);\n            }\n            else if (standardBusinessStampItem) {\n                // eslint-disable-next-line\n                var stampName = _index__WEBPACK_IMPORTED_MODULE_0__.StandardBusinessStampItem[standardBusinessStampItem];\n                this.pdfViewerBase.isDynamicStamp = false;\n                this.stampAnnotationModule.retrievestampAnnotation(stampName);\n            }\n        }\n        this.pdfViewer.enableServerDataBinding(allowServerDataBind, true);\n        this.pdfViewerBase.initiateTextSelection();\n    };\n    Annotation.prototype.deleteAnnotationById = function (annotationId) {\n        if (annotationId) {\n            this.isAnnotDeletionApiCall = true;\n            this.annotationSelected = false;\n            this.selectAnnotation(annotationId);\n            this.deleteAnnotation();\n            this.isAnnotDeletionApiCall = false;\n            if (this.pdfViewer.textSelectionModule) {\n                this.pdfViewer.textSelectionModule.clearTextSelection();\n            }\n        }\n    };\n    Annotation.prototype.clearAnnotationMode = function () {\n        if (this.textMarkupAnnotationModule) {\n            this.textMarkupAnnotationModule.isTextMarkupAnnotationMode = false;\n        }\n        if (this.freeTextAnnotationModule) {\n            this.freeTextAnnotationModule.isNewFreeTextAnnot = false;\n            this.freeTextAnnotationModule.isNewAddedAnnot = false;\n        }\n        if (this.pdfViewerBase.isTextMarkupAnnotationModule()) {\n            this.pdfViewer.annotation.textMarkupAnnotationModule.currentTextMarkupAddMode = '';\n        }\n        if (this.pdfViewerBase.isShapeAnnotationModule()) {\n            this.pdfViewer.annotation.shapeAnnotationModule.currentAnnotationMode = '';\n        }\n        if (this.pdfViewerBase.isCalibrateAnnotationModule()) {\n            this.pdfViewer.annotation.measureAnnotationModule.currentAnnotationMode = '';\n        }\n        if (this.pdfViewer.annotationModule.inkAnnotationModule) {\n            var currentPageNumber = parseInt(this.pdfViewer.annotationModule.inkAnnotationModule.currentPageNumber, 10);\n            this.pdfViewer.annotationModule.inkAnnotationModule.drawInkAnnotation(currentPageNumber);\n        }\n    };\n    Annotation.prototype.deleteAnnotation = function () {\n        if (this.textMarkupAnnotationModule) {\n            this.textMarkupAnnotationModule.deleteTextMarkupAnnotation();\n        }\n        var selectedAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        if (selectedAnnotation) {\n            var data = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_formfields');\n            var formFieldsData = JSON.parse(data);\n            var newFormFieldsData = [];\n            if (formFieldsData) {\n                for (var x = 0; x < formFieldsData.length; x++) {\n                    // eslint-disable-next-line\n                    if (formFieldsData[parseInt(x.toString(), 10)].uniqueID == selectedAnnotation.id) {\n                        formFieldsData[parseInt(x.toString(), 10)].Value = '';\n                        for (var y = 0; y < formFieldsData.length; y++) {\n                            if (formFieldsData[parseInt(y.toString(), 10)].Name === 'ink') {\n                                formFieldsData[parseInt(y.toString(), 10)].Value = '';\n                            }\n                            if (formFieldsData[parseInt(x.toString(), 10)].FieldName === formFieldsData[parseInt(y.toString(), 10)].FieldName && formFieldsData[parseInt(y.toString(), 10)].Name === 'ink') {\n                                formFieldsData.splice(y, 1);\n                            }\n                        }\n                        newFormFieldsData.push(formFieldsData[parseInt(x.toString(), 10)]);\n                    }\n                    else {\n                        newFormFieldsData.push(formFieldsData[parseInt(x.toString(), 10)]);\n                    }\n                }\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_formfields', JSON.stringify(newFormFieldsData));\n            }\n        }\n        var isLock = false;\n        var isReadOnly = false;\n        if (this.pdfViewer.selectedItems.annotations.length > 0) {\n            var annotation_1 = this.pdfViewer.selectedItems.annotations[0];\n            var type = annotation_1.shapeAnnotationType;\n            if (type === 'Path' || annotation_1.formFieldAnnotationType === 'SignatureField' || annotation_1.formFieldAnnotationType === 'InitialField' || type === 'HandWrittenSignature' || type === 'SignatureText' || type === 'SignatureImage') {\n                var inputFields = document.getElementById(annotation_1.id);\n                if (inputFields && inputFields.disabled) {\n                    isReadOnly = true;\n                }\n            }\n            if (annotation_1.annotationSettings) {\n                isLock = annotation_1.annotationSettings.isLock;\n                if (isLock && this.checkAllowedInteractions('Delete', annotation_1)) {\n                    isLock = false;\n                }\n            }\n            if (!isLock && !isReadOnly) {\n                var pageNumber = annotation_1.pageIndex;\n                var shapeType = annotation_1.shapeAnnotationType;\n                var undoElement = void 0;\n                if (shapeType === 'Line' || shapeType === 'LineWidthArrowHead' || shapeType === 'Polygon' || shapeType === 'Ellipse' || shapeType === 'Rectangle' || shapeType === 'Radius' || shapeType === 'Distance') {\n                    if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation_1.measureType) || annotation_1.measureType === '') {\n                        this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(annotation_1, 'shape');\n                        this.updateImportAnnotationCollection(annotation_1, pageNumber, 'shapeAnnotation');\n                    }\n                    else {\n                        this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(annotation_1, 'measure');\n                        this.updateImportAnnotationCollection(annotation_1, pageNumber, 'measureShapeAnnotation');\n                    }\n                    undoElement = this.modifyInCollections(annotation_1, 'delete');\n                }\n                else if (shapeType === 'FreeText') {\n                    this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(annotation_1, 'FreeText', 'delete');\n                    undoElement = this.modifyInCollections(annotation_1, 'delete');\n                    this.updateImportAnnotationCollection(annotation_1, pageNumber, 'freeTextAnnotation');\n                }\n                else if (shapeType === 'HandWrittenSignature' || shapeType === 'SignatureImage' || shapeType === 'SignatureText') {\n                    undoElement = this.modifyInCollections(annotation_1, 'delete');\n                }\n                else if (shapeType === 'Ink') {\n                    this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(annotation_1, 'Ink', 'delete');\n                    undoElement = this.modifyInCollections(annotation_1, 'delete');\n                    this.updateImportAnnotationCollection(annotation_1, pageNumber, 'signatureInkAnnotation');\n                }\n                else {\n                    undoElement = this.pdfViewer.selectedItems.annotations[0];\n                    this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(undoElement, undoElement.shapeAnnotationType, 'delete');\n                    this.pdfViewer.annotation.stampAnnotationModule.updateSessionStorage(annotation_1, null, 'delete');\n                }\n                if (shapeType === 'StickyNotes') {\n                    this.updateImportAnnotationCollection(annotation_1, pageNumber, 'stickyNotesAnnotation');\n                }\n                if (shapeType === 'Stamp' || shapeType === 'Image') {\n                    this.updateImportAnnotationCollection(annotation_1, pageNumber, 'stampAnnotations');\n                }\n                var formFieldObj = this.pdfViewer.nameTable[annotation_1.id.split('_')[0]];\n                if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(formFieldObj) || !(formFieldObj.formFieldAnnotationType === 'SignatureField' || formFieldObj.formFieldAnnotationType === 'InitialField')) {\n                    this.pdfViewer.annotation.addAction(pageNumber, null, annotation_1, 'Delete', '', undoElement, annotation_1);\n                }\n                var removeDiv = void 0;\n                if (annotation_1.annotName !== '') {\n                    removeDiv = document.getElementById(annotation_1.annotName);\n                }\n                else {\n                    if (undoElement) {\n                        if (undoElement.annotName !== '') {\n                            removeDiv = document.getElementById(undoElement.annotName);\n                        }\n                    }\n                }\n                this.removeCommentPanelDiv(removeDiv);\n                var selectedAnnot = this.pdfViewer.selectedItems.annotations[0];\n                var annotationId = selectedAnnot.annotName;\n                var annotType = this.getAnnotationType(selectedAnnot.shapeAnnotationType, selectedAnnot.measureType);\n                if (shapeType === 'Path' || selectedAnnot.formFieldAnnotationType === 'SignatureField' || selectedAnnot.formFieldAnnotationType === 'InitialField' || shapeType === 'HandWrittenSignature' || shapeType === 'SignatureText' || shapeType === 'SignatureImage') {\n                    var formFieldCollection = this.pdfViewer.retrieveFormFields();\n                    var index = formFieldCollection.findIndex(function (el) { return el.id === annotation_1.id; });\n                    var formFieldName = void 0;\n                    if (index > -1) {\n                        formFieldName = formFieldCollection[parseInt(index.toString(), 10)].name;\n                    }\n                    for (var m = 0; m < formFieldCollection.length; m++) {\n                        if (selectedAnnot.id === formFieldCollection[parseInt(m.toString(), 10)].id ||\n                            ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(formFieldName) && formFieldName === formFieldCollection[parseInt(m.toString(), 10)].name)) {\n                            formFieldCollection[parseInt(m.toString(), 10)].value = '';\n                            formFieldCollection[parseInt(m.toString(), 10)].signatureType = '';\n                            var annotation_2 = this.getAnnotationsFromCollections(formFieldCollection[parseInt(m.toString(), 10)].id);\n                            this.updateInputFieldDivElement(annotation_2);\n                            undoElement = this.modifyInCollections(annotation_2, 'delete');\n                            this.pdfViewer.annotation.addAction(annotation_2.pageIndex, null, annotation_2, 'Delete', '', undoElement, annotation_2);\n                            if (this.pdfViewer.formDesignerModule && selectedAnnot.formFieldAnnotationType) {\n                                this.updateFormFieldCollection(annotation_2);\n                            }\n                            else {\n                                this.updateAnnotationCollection(annotation_2);\n                            }\n                            this.pdfViewer.remove(annotation_2);\n                        }\n                    }\n                    if (this.pdfViewer.formDesignerModule && selectedAnnot.formFieldAnnotationType) {\n                        this.updateFormFieldCollection(annotation_1);\n                    }\n                    else {\n                        this.updateAnnotationCollection(annotation_1);\n                    }\n                }\n                if (this.pdfViewer.formDesignerModule && selectedAnnot.formFieldAnnotationType) {\n                    this.updateFormFieldCollection(annotation_1);\n                }\n                else {\n                    this.updateAnnotationCollection(annotation_1);\n                }\n                if (formFieldObj != null && (formFieldObj.formFieldAnnotationType === 'SignatureField' || formFieldObj.formFieldAnnotationType === 'InitialField')) {\n                    var index = this.pdfViewer.formFieldCollections.findIndex(function (el) { return el.id === annotation_1.id.split('_')[0]; });\n                    var formFieldName = void 0;\n                    if (index > -1) {\n                        formFieldName = this.pdfViewer.formFieldCollections[parseInt(index.toString(), 10)].name;\n                    }\n                    for (var i = 0; i < this.pdfViewer.formFieldCollections.length; i++) {\n                        if (formFieldName === this.pdfViewer.formFieldCollections[parseInt(i.toString(), 10)].name) {\n                            var formFieldsIndex = this.pdfViewer.formFieldCollections[parseInt(i.toString(), 10)];\n                            this.pdfViewer.fireFormFieldPropertiesChangeEvent('formFieldPropertiesChange', formFieldsIndex, formFieldsIndex.pageIndex, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, formFieldsIndex.value, '');\n                            formFieldsIndex.value = '';\n                            formFieldsIndex.signatureType = '';\n                            this.pdfViewer.formDesignerModule.updateFormFieldCollections(formFieldsIndex);\n                            var annotation_3 = this.getAnnotationsFromCollections(formFieldsIndex.id + '_content');\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation_3)) {\n                                undoElement = this.modifyInCollections(annotation_3, 'delete');\n                                this.pdfViewer.annotation.addAction(annotation_3.pageIndex, null, annotation_3, 'Delete', '', undoElement, annotation_3);\n                                this.updateInputFieldDivElement(annotation_3);\n                                var formFieldObject = this.pdfViewer.nameTable[annotation_3.id.split('_')[0]];\n                                formFieldObject.wrapper.children.splice(formFieldObject.wrapper.children.\n                                    indexOf(annotation_3.wrapper.children[0]), 1);\n                                this.pdfViewer.remove(annotation_3);\n                            }\n                        }\n                    }\n                }\n                this.pdfViewer.remove(annotation_1);\n                this.pdfViewer.renderDrawing();\n                this.pdfViewer.clearSelection(pageNumber);\n                this.pdfViewerBase.setItemInSessionStorage(this.pdfViewerBase.formFieldCollection, '_formDesigner');\n                this.pdfViewerBase.updateDocumentEditedProperty(true);\n                this.pdfViewerBase.tool = null;\n                this.pdfViewer.tool = null;\n                if (selectedAnnot.shapeAnnotationType === 'HandWrittenSignature' || selectedAnnot.shapeAnnotationType === 'SignatureText' || selectedAnnot.shapeAnnotationType === 'SignatureImage' || selectedAnnot.shapeAnnotationType === 'Path') {\n                    var bounds = { left: selectedAnnot.bounds.x, top: selectedAnnot.bounds.y,\n                        width: selectedAnnot.bounds.width, height: selectedAnnot.bounds.height };\n                    this.pdfViewer.fireSignatureRemove(pageNumber, selectedAnnot.id, selectedAnnot.shapeAnnotationType, bounds);\n                }\n                else if (this.pdfViewer.annotationModule) {\n                    this.pdfViewer.fireAnnotationRemove(pageNumber, annotationId, annotType, selectedAnnot.bounds);\n                }\n                if (this.pdfViewer.textSelectionModule) {\n                    this.pdfViewer.textSelectionModule.enableTextSelectionMode();\n                }\n            }\n        }\n        else if (this.nonRenderSelectedAnnotation && this.nonRenderSelectedAnnotation.annotationId && this.isAnnotDeletionApiCall) {\n            var annotationId = this.nonRenderSelectedAnnotation.annotationId;\n            var pageIndex = this.nonRenderSelectedAnnotation.pageNumber ? this.nonRenderSelectedAnnotation.pageNumber :\n                this.nonRenderSelectedAnnotation.pageIndex;\n            var collections = this.updateCollectionForNonRenderedPages(this.nonRenderSelectedAnnotation, annotationId, pageIndex);\n            collections.pageIndex = pageIndex;\n            this.pdfViewer.annotation.addAction(pageIndex, null, collections, 'Delete', '', collections, collections);\n            this.undoCommentsElement.push(collections);\n            var removeDiv = document.getElementById(annotationId);\n            this.removeCommentPanelDiv(removeDiv);\n            this.nonRenderSelectedAnnotation = null;\n        }\n        this.updateToolbar(true);\n        if (this.pdfViewer.toolbarModule) {\n            if (this.pdfViewer.toolbarModule.annotationToolbarModule && !isLock) {\n                this.pdfViewer.toolbarModule.annotationToolbarModule.selectAnnotationDeleteItem(false, true);\n                this.pdfViewer.toolbarModule.annotationToolbarModule.enableTextMarkupAnnotationPropertiesTools(false);\n            }\n        }\n    };\n    /**\n     * @param {string} annotationId - annotationId\n     * @returns {void}\n     */\n    Annotation.prototype.getAnnotationsFromCollections = function (annotationId) {\n        var collections = this.pdfViewer.annotations;\n        if (collections && annotationId) {\n            for (var i = 0; i < collections.length; i++) {\n                if (collections[parseInt(i.toString(), 10)].id === annotationId) {\n                    return collections[parseInt(i.toString(), 10)];\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @returns {void}\n     */\n    Annotation.prototype.updateInputFieldDivElement = function (annotation) {\n        var inputFields = document.getElementById(annotation.id);\n        var signatureFieldElement = document.getElementById(annotation.id + '_html_element');\n        if (inputFields === null && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(signatureFieldElement)) {\n            inputFields = signatureFieldElement.children[0].children[0];\n        }\n        if (inputFields && inputFields.classList.contains('e-pdfviewer-signatureformfields-signature')) {\n            inputFields.className = 'e-pdfviewer-signatureformfields';\n            inputFields.style.pointerEvents = '';\n            inputFields.parentElement.style.pointerEvents = '';\n        }\n        if (this.pdfViewer.formDesignerModule) {\n            this.pdfViewer.formDesignerModule.updateSignatureValue(annotation.id);\n        }\n        else {\n            this.pdfViewer.formFieldsModule.updateDataInSession(inputFields, '');\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @param {number} pageNumber - pageNumber\n     * @param {boolean} isNeedToReorderCollection - Ensures whether need to reorder the collection or not\n     * @param {number} orderNumber - Gets the order number\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.storeAnnotationCollections = function (annotation, pageNumber, isNeedToReorderCollection, orderNumber) {\n        if (this.isFormFieldShape) {\n            var collectionDetails = this.checkFormDesignCollection(annotation);\n            var selectAnnotation = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(annotation);\n            selectAnnotation.formFieldId = annotation.annotName;\n            selectAnnotation.pageNumber = pageNumber;\n            delete selectAnnotation.annotName;\n            if (annotation.id) {\n                selectAnnotation.uniqueKey = annotation.id;\n                delete selectAnnotation.id;\n            }\n            if (collectionDetails.isExisting) {\n                this.pdfViewer.formFieldCollection.splice(collectionDetails.position, 0, selectAnnotation);\n            }\n            else {\n                this.pdfViewer.formFieldCollection.push(selectAnnotation);\n            }\n        }\n        else {\n            var collectionDetails = this.checkAnnotationCollection(annotation);\n            var selectAnnotation = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(annotation);\n            selectAnnotation.annotationId = annotation.annotName;\n            selectAnnotation.pageNumber = pageNumber;\n            delete selectAnnotation.annotName;\n            if (annotation.shapeAnnotationType === 'stamp') {\n                selectAnnotation.uniqueKey = annotation.randomId;\n                delete selectAnnotation.randomId;\n            }\n            if (annotation.shapeAnnotationType === 'sticky') {\n                selectAnnotation.uniqueKey = annotation.annotName;\n            }\n            if (annotation.id) {\n                selectAnnotation.uniqueKey = annotation.id;\n                delete selectAnnotation.id;\n            }\n            if (selectAnnotation.customData && annotation.customData && JSON.stringify(selectAnnotation.customData) !==\n                JSON.stringify(annotation.customData)) {\n                selectAnnotation.customData = annotation.customData;\n            }\n            if (collectionDetails.isExisting) {\n                this.pdfViewer.annotationCollection.splice(collectionDetails.position, 0, selectAnnotation);\n            }\n            else if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(isNeedToReorderCollection) && isNeedToReorderCollection) {\n                this.pdfViewer.annotationCollection.splice(orderNumber, 0, selectAnnotation);\n            }\n            else {\n                this.pdfViewer.annotationCollection.push(selectAnnotation);\n            }\n        }\n    };\n    Annotation.prototype.checkFormDesignCollection = function (annotation) {\n        var collections = this.pdfViewer.formFieldCollection;\n        if (collections && annotation) {\n            for (var i = 0; i < collections.length; i++) {\n                if (collections[parseInt(i.toString(), 10)].formFieldId === annotation.annotName) {\n                    this.pdfViewer.formFieldCollection.splice(i, 1);\n                    return { isExisting: true, position: i };\n                }\n            }\n        }\n        return { isExisting: false, position: null };\n    };\n    Annotation.prototype.updateFormFieldCollection = function (annotation) {\n        var collections = this.pdfViewer.formFieldCollection;\n        if (collections && annotation) {\n            for (var i = 0; i < collections.length; i++) {\n                if (collections[parseInt(i.toString(), 10)].formFieldId === annotation.annotName) {\n                    this.removedAnnotationCollection.push(collections[parseInt(i.toString(), 10)]);\n                    this.pdfViewer.formFieldCollection.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.getCustomData = function (annotation) {\n        var customData;\n        if (annotation.ExistingCustomData && !annotation.CustomData) {\n            customData = JSON.parse(annotation.ExistingCustomData);\n        }\n        else if (annotation.CustomData === null) {\n            if (annotation.shapeAnnotationType === 'sticky') {\n                customData = this.pdfViewer.stickyNotesSettings.customData;\n            }\n            if (annotation.shapeAnnotationType === 'Stamp') {\n                customData = this.pdfViewer.stampSettings.customData;\n            }\n            if (annotation.shapeAnnotationType === 'FreeText') {\n                customData = this.pdfViewer.freeTextSettings.customData;\n            }\n            if (annotation.id === 'shape') {\n                customData = this.getShapeData(annotation.ShapeAnnotationType, annotation.subject);\n            }\n            if (annotation.id === 'measure') {\n                customData = this.getMeasureData(annotation.Subject);\n            }\n            if (annotation.shapeAnnotationType === 'textMarkup') {\n                customData = this.getTextMarkupData(annotation.subject);\n            }\n            if (annotation.shapeAnnotationType === 'Ink') {\n                customData = this.pdfViewer.inkAnnotationSettings.customData;\n            }\n        }\n        else {\n            var data = annotation.CustomData ? annotation.CustomData : annotation.customData;\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(data)) {\n                customData = typeof data === 'string' ? JSON.parse(data) : data;\n            }\n        }\n        return customData;\n    };\n    /**\n     * @param {string} type - type\n     * @param {string} subject - subject\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.getShapeData = function (type, subject) {\n        var customData;\n        if (type === 'Line' && subject !== 'Arrow' && this.pdfViewer.lineSettings.customData) {\n            customData = this.pdfViewer.lineSettings.customData;\n        }\n        else if ((type === 'LineWidthArrowHead' || subject === 'Arrow') && this.pdfViewer.arrowSettings.customData) {\n            customData = this.pdfViewer.arrowSettings.customData;\n        }\n        else if ((type === 'Rectangle' || type === 'Square') && this.pdfViewer.rectangleSettings.customData) {\n            customData = this.pdfViewer.rectangleSettings.customData;\n        }\n        else if ((type === 'Ellipse' || type === 'Circle') && this.pdfViewer.circleSettings.customData) {\n            customData = this.pdfViewer.circleSettings.customData;\n        }\n        else if (type === 'Polygon' && this.pdfViewer.polygonSettings.customData) {\n            customData = this.pdfViewer.polygonSettings.customData;\n        }\n        else if (this.pdfViewer.annotationSettings.customData) {\n            customData = this.pdfViewer.annotationSettings.customData;\n        }\n        return customData;\n    };\n    /**\n     * @param {string} type - type\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.getMeasureData = function (type) {\n        var customData;\n        if ((type === 'Distance' || type === 'Distance calculation') && this.pdfViewer.distanceSettings.customData) {\n            customData = this.pdfViewer.distanceSettings.customData;\n        }\n        else if ((type === 'Line' || type === 'Perimeter calculation') && this.pdfViewer.lineSettings.customData) {\n            customData = this.pdfViewer.lineSettings.customData;\n        }\n        else if ((type === 'Polygon' || type === 'Area calculation' || type === 'Volume calculation') && this.pdfViewer.polygonSettings.customData) {\n            customData = this.pdfViewer.polygonSettings.customData;\n        }\n        else if ((type === 'Radius' || type === 'Radius calculation') && this.pdfViewer.radiusSettings.customData) {\n            customData = this.pdfViewer.radiusSettings.customData;\n        }\n        else if (this.pdfViewer.annotationSettings.customData) {\n            customData = this.pdfViewer.annotationSettings.customData;\n        }\n        return customData;\n    };\n    /**\n     * @param {string} type - type\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.getTextMarkupData = function (type) {\n        var customData;\n        if (type === 'Highlight' && this.pdfViewer.highlightSettings.customData) {\n            customData = this.pdfViewer.highlightSettings.customData;\n        }\n        else if (type === 'Underline' && this.pdfViewer.underlineSettings.customData) {\n            customData = this.pdfViewer.underlineSettings.customData;\n        }\n        else if (type === 'Strikethrough' && this.pdfViewer.strikethroughSettings.customData) {\n            customData = this.pdfViewer.strikethroughSettings.customData;\n        }\n        else if (this.pdfViewer.annotationSettings.customData) {\n            customData = this.pdfViewer.annotationSettings.customData;\n        }\n        return customData;\n    };\n    /**\n     * @param {string} type - type\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.getData = function (type) {\n        var customData;\n        if (type === 'FreeText' && this.pdfViewer.freeTextSettings.customData) {\n            customData = this.pdfViewer.freeTextSettings.customData;\n        }\n        else if ((type === 'image' || type === 'Stamp') && this.pdfViewer.stampSettings.customData) {\n            customData = this.pdfViewer.stampSettings.customData;\n        }\n        else if (type === 'sticky' && this.pdfViewer.stickyNotesSettings.customData) {\n            customData = this.pdfViewer.stickyNotesSettings.customData;\n        }\n        else if (this.pdfViewer.annotationSettings.customData) {\n            customData = this.pdfViewer.annotationSettings.customData;\n        }\n        return customData;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.clearAnnotationStorage = function () {\n        var sessionSize = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getWindowSessionStorageSize();\n        var maxSessionSize = 4500;\n        if (this.pdfViewerBase.isDeviceiOS || this.pdfViewerBase.isMacSafari) {\n            maxSessionSize = 2000;\n        }\n        if (sessionSize > maxSessionSize) {\n            var storageLength = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getSessionLength();\n            var annotationList = [];\n            for (var i = 0; i < storageLength; i++) {\n                if (_index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getKey(i) && _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getKey(i).split('_')[3]) {\n                    if (_index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getKey(i).split('_')[3] === 'annotations') {\n                        this.pdfViewerBase.annotationStorage[_index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getKey(i)] =\n                            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(_index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getKey(i));\n                        annotationList.push(_index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getKey(i));\n                    }\n                }\n            }\n            if (annotationList) {\n                for (var i = 0; i < annotationList.length; i++) {\n                    _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(annotationList[parseInt(i.toString(), 10)]);\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {Object} - Object\n     */\n    Annotation.prototype.checkAnnotationCollection = function (annotation) {\n        var collections = this.pdfViewer.annotationCollection;\n        if (collections && annotation) {\n            for (var i = 0; i < collections.length; i++) {\n                if (collections[parseInt(i.toString(), 10)].annotationId === annotation.annotName) {\n                    this.pdfViewer.annotationCollection.splice(i, 1);\n                    return { isExisting: true, position: i };\n                }\n            }\n        }\n        return { isExisting: false, position: null };\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.updateAnnotationCollection = function (annotation) {\n        var collections = this.pdfViewer.annotationCollection;\n        if (collections && annotation) {\n            for (var i = 0; i < collections.length; i++) {\n                if (collections[parseInt(i.toString(), 10)].annotationId ===\n                    annotation.annotName || collections[parseInt(i.toString(), 10)].annotationId === annotation.annotationId) {\n                    this.removedAnnotationCollection.push(collections[parseInt(i.toString(), 10)]);\n                    this.pdfViewer.annotationCollection.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @param {number} pageNumber - pageNumber\n     * @param {string} annotationType - annotationType\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.updateImportAnnotationCollection = function (annotation, pageNumber, annotationType) {\n        if (this.pdfViewerBase.isImportAction) {\n            if (this.pdfViewerBase.importedAnnotation && this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)]) {\n                var currentPageAnnotations = this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)];\n                if (currentPageAnnotations[\"\" + annotationType] &&\n                    !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)].annotationOrder)) {\n                    this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)].annotationOrder =\n                        this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)].annotationOrder.filter(function (currentAnnotation) {\n                            return !(annotation.annotName === currentAnnotation.AnnotName\n                                || annotation.annotName === currentAnnotation.annotName);\n                        });\n                }\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.importedAnnotation) &&\n                    !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)])\n                    && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)][\"\" + annotationType])) {\n                    this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)][\"\" + annotationType] = this.pdfViewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)][\"\" + annotationType].filter(function (currentAnnotation) {\n                        return annotation.annotName !== currentAnnotation.AnnotName;\n                    });\n                }\n            }\n        }\n        var documentcollections = this.pdfViewerBase.documentAnnotationCollections;\n        if (documentcollections && documentcollections[parseInt(pageNumber.toString(), 10)]) {\n            var documentPageCollections = documentcollections[parseInt(pageNumber.toString(), 10)];\n            if (documentPageCollections && documentPageCollections[\"\" + annotationType]) {\n                for (var i = 0; i < documentPageCollections[\"\" + annotationType].length; i++) {\n                    if (annotation.annotName === documentPageCollections[\"\" + annotationType][parseInt(i.toString(), 10)].AnnotName) {\n                        this.pdfViewerBase.documentAnnotationCollections[parseInt(pageNumber.toString(), 10)][\"\" + annotationType].splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Select the annotations using annotation object or annotation Id.\n     *\n     * @param {string | object} annotationId - annptationId\n     * @returns {void}\n     */\n    Annotation.prototype.selectAnnotation = function (annotationId) {\n        var annotation;\n        var id;\n        if (typeof annotationId === 'object') {\n            annotation = annotationId;\n            id = annotation.annotationId;\n            annotation = this.getAnnotationsFromAnnotationCollections(id);\n        }\n        if (typeof annotationId === 'string') {\n            annotation = this.getAnnotationsFromAnnotationCollections(annotationId);\n            id = annotationId;\n        }\n        if (annotation) {\n            var pageIndex = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.pageNumber) ? annotation.pageIndex : annotation.pageNumber;\n            var isRender = false;\n            isRender = this.findRenderPageList(pageIndex);\n            var currentSelector = this.pdfViewer.annotationSelectorSettings;\n            //let pageIndex: number = this.getPageNumberFromAnnotationCollections(annotation);\n            if (annotation && pageIndex >= 0) {\n                if (annotation.shapeAnnotationType === 'textMarkup') {\n                    if (annotation.rect || annotation.bounds) {\n                        var scrollValue = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)].top *\n                            this.pdfViewerBase.getZoomFactor() + (this.getAnnotationTop(annotation)) * this.pdfViewerBase.getZoomFactor();\n                        if (!this.isAnnotDeletionApiCall) {\n                            var scroll_1 = (scrollValue - 20).toString();\n                            this.pdfViewerBase.viewerContainer.scrollTop = parseInt(scroll_1, 10);\n                            this.pdfViewerBase.viewerContainer.scrollLeft = this.getAnnotationLeft(annotation) *\n                                this.pdfViewerBase.getZoomFactor();\n                        }\n                    }\n                    else {\n                        if (this.pdfViewer.navigation) {\n                            this.pdfViewer.navigation.goToPage(pageIndex + 1);\n                        }\n                    }\n                }\n                else {\n                    if (annotation.bounds) {\n                        var scrollValue = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)].top *\n                            this.pdfViewerBase.getZoomFactor() + (annotation.bounds.top) *\n                            this.pdfViewerBase.getZoomFactor();\n                        var scrollLeft = annotation.bounds.left * this.pdfViewerBase.getZoomFactor();\n                        if (annotation.shapeAnnotationType === 'Ink') {\n                            scrollValue = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)].top *\n                                this.pdfViewerBase.getZoomFactor() + (annotation.bounds.y) *\n                                this.pdfViewerBase.getZoomFactor();\n                            scrollLeft = annotation.bounds.x * this.pdfViewerBase.getZoomFactor();\n                        }\n                        if (!this.isAnnotDeletionApiCall) {\n                            var scroll_2 = (scrollValue - 20).toString();\n                            this.pdfViewerBase.viewerContainer.scrollTop = parseInt(scroll_2, 10);\n                            this.pdfViewerBase.viewerContainer.scrollLeft = scrollLeft;\n                        }\n                    }\n                    else {\n                        if (this.pdfViewer.navigation) {\n                            this.pdfViewer.navigation.goToPage(pageIndex + 1);\n                        }\n                    }\n                }\n                if (isRender) {\n                    if (this.previousIndex) {\n                        this.pdfViewer.clearSelection(this.previousIndex);\n                    }\n                    this.pdfViewer.clearSelection(pageIndex);\n                    this.previousIndex = pageIndex;\n                    if (annotation.shapeAnnotationType === 'textMarkup') {\n                        this.pdfViewer.annotationModule.textMarkupAnnotationModule.clearCurrentAnnotationSelection(pageIndex, true);\n                        var canvasId = annotation.textMarkupAnnotationType === 'Highlight' ? '_blendAnnotationsIntoCanvas_' : '_annotationCanvas_';\n                        var canvas = (canvasId === '_blendAnnotationsIntoCanvas_') ? this.pdfViewerBase.getElement(canvasId + pageIndex) :\n                            this.pdfViewerBase.getAnnotationCanvas(canvasId, pageIndex);\n                        var textMarkupAnnotation = this.getTextMarkupAnnotations(pageIndex, annotation);\n                        if (textMarkupAnnotation) {\n                            this.textMarkupAnnotationModule.currentTextMarkupAnnotation = null;\n                            this.textMarkupAnnotationModule.isSelectedAnnotation = true;\n                            this.textMarkupAnnotationModule.showHideDropletDiv(true);\n                            this.textMarkupAnnotationModule.annotationClickPosition = null;\n                            this.textMarkupAnnotationModule.selectAnnotation(textMarkupAnnotation, canvas, pageIndex, null, true);\n                            this.textMarkupAnnotationModule.currentTextMarkupAnnotation = textMarkupAnnotation;\n                            this.textMarkupAnnotationModule.selectTextMarkupCurrentPage = pageIndex;\n                            this.textMarkupAnnotationModule.enableAnnotationPropertiesTool(true);\n                            this.textMarkupAnnotationModule.isSelectedAnnotation = false;\n                            if (this.pdfViewer.toolbarModule && this.pdfViewer.enableAnnotationToolbar) {\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.isToolbarHidden = true;\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.\n                                    showAnnotationToolbar(this.pdfViewer.toolbarModule.annotationItem);\n                            }\n                        }\n                    }\n                    else if (annotation.shapeAnnotationType === 'stamp' || annotation.ShapeAnnotationType === 'stamp') {\n                        this.pdfViewer.select([annotation.uniqueKey], currentSelector);\n                        this.pdfViewer.annotation.onAnnotationMouseDown();\n                    }\n                    else if (annotation.shapeAnnotationType === 'sticky' || annotation.ShapeAnnotationType === 'sticky') {\n                        this.pdfViewer.select([annotation.annotationId], currentSelector);\n                        this.pdfViewer.annotation.onAnnotationMouseDown();\n                    }\n                    else if (annotation.uniqueKey) {\n                        this.pdfViewer.select([annotation.uniqueKey], currentSelector);\n                        this.pdfViewer.annotation.onAnnotationMouseDown();\n                    }\n                    else {\n                        this.selectAnnotationId = id;\n                        this.isAnnotationSelected = true;\n                        this.annotationPageIndex = pageIndex;\n                        this.annotationType = annotation.stampAnnotationType;\n                    }\n                    var commentElement = document.getElementById(this.pdfViewer.element.id + '_commantPanel');\n                    if (commentElement && commentElement.style.display === 'block') {\n                        var accordionExpand = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + this.pdfViewer.currentPageNumber);\n                        if (accordionExpand) {\n                            accordionExpand.ej2_instances[0].expandItem(true);\n                        }\n                        var commentsDiv = document.getElementById(id);\n                        if (commentsDiv) {\n                            if (!commentsDiv.classList.contains('e-pv-comments-border')) {\n                                commentsDiv.firstChild.click();\n                            }\n                        }\n                    }\n                }\n                else if (annotation.uniqueKey || (annotation.shapeAnnotationType === 'textMarkup' && annotation.annotationAddMode === 'Imported Annotation') || !this.isAnnotDeletionApiCall) {\n                    this.selectAnnotationId = id;\n                    this.isAnnotationSelected = true;\n                    this.annotationPageIndex = pageIndex;\n                    this.annotationType = annotation.stampAnnotationType;\n                    if (annotation.uniqueKey || (annotation.shapeAnnotationType === 'textMarkup' && annotation.annotationAddMode === 'Imported Annotation')) {\n                        this.selectAnnotationFromCodeBehind();\n                    }\n                }\n                else if (!isRender && !annotation.uniqueKey && this.isAnnotDeletionApiCall) {\n                    this.nonRenderSelectedAnnotation = annotation;\n                }\n            }\n        }\n    };\n    // To update the collections for the non-rendered pages.\n    Annotation.prototype.updateCollectionForNonRenderedPages = function (annotation, id, pageIndex) {\n        var collections;\n        var annotationCollection = this.pdfViewer.annotationCollection;\n        if (annotationCollection.length) {\n            var collectionDetails = annotationCollection.filter(function (annotCollection) {\n                return annotCollection.annotationId === id;\n            });\n            collections = collectionDetails[0];\n            this.updateAnnotationCollection(collectionDetails[0]);\n        }\n        var annotationType = this.getTypeOfAnnotation(annotation);\n        var collection = this.pdfViewerBase.documentAnnotationCollections[parseInt(pageIndex.toString(), 10)];\n        if (collection[\"\" + annotationType].length) {\n            for (var x = 0; x < collection[\"\" + annotationType].length; x++) {\n                if (collection[\"\" + annotationType][parseInt(x.toString(), 10)].AnnotName === annotation.annotationId) {\n                    var type = collection[\"\" + annotationType][parseInt(x.toString(), 10)];\n                    this.removedDocumentAnnotationCollection.push(type);\n                    collection[\"\" + annotationType].splice(x, 1);\n                    break;\n                }\n            }\n        }\n        return collections;\n    };\n    // To get the annotation type to update the document Annotation collections\n    Annotation.prototype.getTypeOfAnnotation = function (annotation) {\n        var annotationType;\n        if (annotation.id && annotation.id.toLowerCase() === 'shape') {\n            annotationType = 'shapeAnnotation';\n        }\n        else if (annotation.id && annotation.id.toLowerCase() === 'measure') {\n            annotationType = 'measureShapeAnnotation';\n        }\n        else if (annotation.id && annotation.id.toLowerCase() === 'freetext') {\n            annotationType = 'freeTextAnnotation';\n        }\n        else if (annotation.shapeAnnotationType && annotation.shapeAnnotationType.toLowerCase() === 'textmarkup') {\n            annotationType = 'textMarkupAnnotation';\n        }\n        else if (annotation.shapeAnnotationType && annotation.shapeAnnotationType.toLowerCase() === 'stamp') {\n            annotationType = 'stampAnnotations';\n        }\n        else if (annotation.shapeAnnotationType && annotation.shapeAnnotationType.toLowerCase() === 'ink') {\n            annotationType = 'signatureInkAnnotation';\n        }\n        else if (annotation.shapeAnnotationType && annotation.shapeAnnotationType.toLowerCase() === 'sticky') {\n            annotationType = 'stickyNotesAnnotation';\n        }\n        return annotationType;\n    };\n    // To remove the commnet panel div\n    Annotation.prototype.removeCommentPanelDiv = function (removeDiv) {\n        if (removeDiv) {\n            if (removeDiv.parentElement.childElementCount === 1) {\n                this.stickyNotesAnnotationModule.updateAccordionContainer(removeDiv);\n            }\n            else {\n                removeDiv.remove();\n            }\n        }\n    };\n    /**\n     * Clear the annotation selection.\n     *\n     * @returns {void}\n     */\n    Annotation.prototype.clearSelection = function () {\n        if (this.textMarkupAnnotationModule && this.textMarkupAnnotationModule.currentTextMarkupAnnotation) {\n            this.textMarkupAnnotationModule.clearCurrentSelectedAnnotation();\n            this.textMarkupAnnotationModule.clearCurrentAnnotationSelection(this.textMarkupAnnotationModule.selectTextMarkupCurrentPage);\n        }\n        else {\n            if (this.pdfViewer.selectedItems && this.pdfViewer.selectedItems.annotations[0]) {\n                var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n                this.pdfViewer.clearSelection(currentAnnotation.pageIndex);\n            }\n            else {\n                this.pdfViewer.clearSelection(this.pdfViewer.currentPageNumber - 1);\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {number} - number\n     */\n    Annotation.prototype.getAnnotationTop = function (annotation) {\n        if (annotation.rect && (annotation.rect.Top || annotation.rect.top)) {\n            return annotation.rect.Top || annotation.rect.top;\n        }\n        else {\n            return annotation.bounds[0].Top || annotation.bounds[0].top;\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @returns {number} - number\n     */\n    Annotation.prototype.getAnnotationLeft = function (annotation) {\n        if (annotation.rect) {\n            if (annotation.rect.Left) {\n                return annotation.rect.Left;\n            }\n            else {\n                return annotation.rect.left;\n            }\n        }\n        else {\n            if (annotation.bounds[0].Left) {\n                return annotation.bounds[0].Left;\n            }\n            else {\n                return annotation.bounds[0].left;\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.selectAnnotationFromCodeBehind = function () {\n        if (this.isAnnotationSelected && this.selectAnnotationId) {\n            var annotation = this.getAnnotationsFromAnnotationCollections(this.selectAnnotationId);\n            var id = this.selectAnnotationId;\n            var pageIndex = annotation.pageNumber;\n            var currentSelector = this.pdfViewer.annotationSelectorSettings;\n            if (annotation && (this.annotationPageIndex >= 0) && this.annotationPageIndex === pageIndex) {\n                if (this.previousIndex) {\n                    this.pdfViewer.clearSelection(this.previousIndex);\n                }\n                this.pdfViewer.clearSelection(pageIndex);\n                this.previousIndex = pageIndex;\n                if (annotation.shapeAnnotationType === 'textMarkup') {\n                    this.pdfViewer.annotationModule.textMarkupAnnotationModule.clearCurrentAnnotationSelection(pageIndex, true);\n                    var canvasId = annotation.textMarkupAnnotationType === 'Highlight' ? '_blendAnnotationsIntoCanvas_' : '_annotationCanvas_';\n                    var canvas = (canvasId === '_blendAnnotationsIntoCanvas_') ? this.pdfViewerBase.getElement(canvasId + pageIndex) :\n                        this.pdfViewerBase.getAnnotationCanvas(canvasId, pageIndex);\n                    var textMarkupAnnotation = this.getTextMarkupAnnotations(pageIndex, annotation);\n                    if (textMarkupAnnotation) {\n                        this.textMarkupAnnotationModule.currentTextMarkupAnnotation = null;\n                        this.textMarkupAnnotationModule.isSelectedAnnotation = true;\n                        this.textMarkupAnnotationModule.showHideDropletDiv(true);\n                        this.textMarkupAnnotationModule.annotationClickPosition = null;\n                        this.textMarkupAnnotationModule.selectAnnotation(textMarkupAnnotation, canvas, pageIndex);\n                        this.textMarkupAnnotationModule.currentTextMarkupAnnotation = textMarkupAnnotation;\n                        this.textMarkupAnnotationModule.selectTextMarkupCurrentPage = pageIndex;\n                        this.textMarkupAnnotationModule.enableAnnotationPropertiesTool(true);\n                        this.textMarkupAnnotationModule.isSelectedAnnotation = false;\n                        if (this.pdfViewer.toolbarModule && this.pdfViewer.enableAnnotationToolbar) {\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.isToolbarHidden = true;\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.\n                                showAnnotationToolbar(this.pdfViewer.toolbarModule.annotationItem);\n                        }\n                    }\n                }\n                else if (annotation.shapeAnnotationType === 'stamp' || annotation.ShapeAnnotationType === 'stamp') {\n                    this.pdfViewer.select([annotation.uniqueKey], currentSelector);\n                    this.pdfViewer.annotation.onAnnotationMouseDown();\n                }\n                else if (annotation.shapeAnnotationType === 'sticky' || annotation.ShapeAnnotationType === 'sticky') {\n                    this.pdfViewer.select([annotation.annotationId], currentSelector);\n                    this.pdfViewer.annotation.onAnnotationMouseDown();\n                }\n                else if (annotation.uniqueKey) {\n                    this.pdfViewer.select([annotation.uniqueKey], currentSelector);\n                    this.pdfViewer.annotation.onAnnotationMouseDown();\n                }\n                else {\n                    this.pdfViewer.select([annotation.annotationId], currentSelector);\n                    this.pdfViewer.annotation.onAnnotationMouseDown();\n                }\n                var commentElement = document.getElementById(this.pdfViewer.element.id + '_commantPanel');\n                if (commentElement && commentElement.style.display === 'block') {\n                    var accordionExpand = document.getElementById(this.pdfViewer.element.id + '_accordionContainer' + this.pdfViewer.currentPageNumber);\n                    if (accordionExpand) {\n                        accordionExpand.ej2_instances[0].expandItem(true);\n                    }\n                    var commentsDiv = document.getElementById(id);\n                    if (commentsDiv) {\n                        if (!commentsDiv.classList.contains('e-pv-comments-border')) {\n                            commentsDiv.firstChild.click();\n                        }\n                    }\n                }\n            }\n            this.isAnnotationSelected = false;\n            this.selectAnnotationId = null;\n            this.annotationPageIndex = null;\n        }\n    };\n    /**\n     * @param {number} pageIndex - pageIndex\n     * @private\n     * @returns {boolean} - boolean\n     */\n    Annotation.prototype.findRenderPageList = function (pageIndex) {\n        var isRender = false;\n        var pageList = this.pdfViewerBase.renderedPagesList;\n        if (pageList) {\n            for (var i = 0; i < pageList.length; i++) {\n                if (pageList[parseInt(i.toString(), 10)] === pageIndex) {\n                    isRender = true;\n                    return isRender;\n                }\n            }\n        }\n        return isRender;\n    };\n    Annotation.prototype.getAnnotationsFromAnnotationCollections = function (annotationId) {\n        var collections = this.pdfViewer.annotationCollection;\n        if (collections && annotationId) {\n            for (var i = 0; i < collections.length; i++) {\n                if (collections[parseInt(i.toString(), 10)].annotationId === annotationId) {\n                    return collections[parseInt(i.toString(), 10)];\n                }\n            }\n        }\n        if (this.pdfViewer.selectedItems.annotations.length === 0) {\n            this.pdfViewer.selectedItems.annotations.push(this.pdfViewer.nameTable[\"\" + annotationId]);\n        }\n    };\n    Annotation.prototype.getTextMarkupAnnotations = function (pageIndex, annotation) {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_textMarkup'];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            var index = this.getPageCollection(annotObject, pageIndex);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                for (var i = 0; i < annotObject[parseInt(index.toString(), 10)].annotations.length; i++) {\n                    if (annotObject[parseInt(index.toString(), 10)].annotations[parseInt(i.toString(), 10)].annotName ===\n                        annotation.annotationId) {\n                        return annotObject[parseInt(index.toString(), 10)].annotations[parseInt(i.toString(), 10)];\n                    }\n                }\n                return null;\n            }\n            return null;\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * @param {string} type -string\n     * @param {string} measureType - measureType\n     * @private\n     * @returns {AnnotationType} - type\n     */\n    Annotation.prototype.getAnnotationType = function (type, measureType) {\n        var annotType;\n        if (measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(measureType)) {\n            switch (type) {\n                case 'Line':\n                    annotType = 'Line';\n                    break;\n                case 'LineWidthArrowHead':\n                    annotType = 'Arrow';\n                    break;\n                case 'Rectangle':\n                    annotType = 'Rectangle';\n                    break;\n                case 'Ellipse':\n                    annotType = 'Circle';\n                    break;\n                case 'Polygon':\n                    annotType = 'Polygon';\n                    break;\n                case 'Stamp':\n                    annotType = 'Stamp';\n                    break;\n                case 'Image':\n                    annotType = 'Image';\n                    break;\n                case 'FreeText':\n                    annotType = 'FreeText';\n                    break;\n                case 'Ink':\n                    annotType = 'Ink';\n                    break;\n                case 'StickyNotes':\n                    annotType = 'StickyNotes';\n                    break;\n            }\n        }\n        else {\n            switch (measureType) {\n                case 'Distance':\n                    annotType = 'Distance';\n                    break;\n                case 'Perimeter':\n                    annotType = 'Perimeter';\n                    break;\n                case 'Area':\n                    annotType = 'Area';\n                    break;\n                case 'Radius':\n                    annotType = 'Radius';\n                    break;\n                case 'Volume':\n                    annotType = 'Volume';\n                    break;\n            }\n        }\n        return annotType;\n    };\n    /**\n     * @param {number} pageNumber - pageNumber\n     * @param {string} annotationId - annotationId\n     * @private\n     * @returns {number} - number\n     */\n    Annotation.prototype.getAnnotationIndex = function (pageNumber, annotationId) {\n        var pageAnnotationBases = this.pdfViewer.drawing.getPageObjects(pageNumber);\n        var index = null;\n        for (var i = 0; i < pageAnnotationBases.length; i++) {\n            if (pageAnnotationBases[parseInt(i.toString(), 10)].id === annotationId) {\n                index = i;\n                break;\n            }\n        }\n        return index;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.initializeCollection = function () {\n        this.actionCollection = [];\n        this.redoCollection = [];\n        if (!this.popupNote) {\n            this.createNote();\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.showCommentsPanel = function () {\n        if (this.pdfViewer.enableCommentPanel) {\n            var commentPanel = document.getElementById(this.pdfViewer.element.id + '_commantPanel');\n            if (commentPanel) {\n                if (commentPanel.style.display === 'none') {\n                    commentPanel.style.display = 'block';\n                    if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                        var viewer = document.getElementById(this.pdfViewer.element.id + '_viewerMainContainer');\n                        viewer.insertBefore(this.pdfViewerBase.navigationPane.commentPanelContainer, this.pdfViewer.toolbarModule.toolbarElement);\n                    }\n                    if (this.pdfViewerBase.navigationPane.commentPanelResizer) {\n                        this.pdfViewerBase.navigationPane.commentPanelResizer.style.display = 'block';\n                    }\n                    this.pdfViewerBase.navigationPane.setCommentPanelResizeIconTop();\n                    this.pdfViewer.annotation.stickyNotesAnnotationModule.updateCommentPanelTextTop();\n                    var viewerContainer = document.getElementById(this.pdfViewer.element.id + '_viewerContainer');\n                    var pageContainer = document.getElementById(this.pdfViewer.element.id + '_pageViewContainer');\n                    if (viewerContainer) {\n                        if (this.pdfViewer.enableRtl) {\n                            viewerContainer.style.left = this.pdfViewerBase.navigationPane.getViewerContainerRight() + 'px';\n                        }\n                        else {\n                            viewerContainer.style.right = this.pdfViewerBase.navigationPane.getViewerContainerRight() + 'px';\n                        }\n                        viewerContainer.style.width = (this.pdfViewer.element.clientWidth - this.pdfViewerBase.navigationPane.getViewerContainerLeft() - this.pdfViewerBase.navigationPane.getViewerContainerRight()) + 'px';\n                        pageContainer.style.width = (viewerContainer.offsetWidth - this.pdfViewerBase.navigationPane.getViewerContainerScrollbarWidth()) + 'px';\n                    }\n                    this.pdfViewerBase.updateZoomValue();\n                    if (this.pdfViewer.annotation && this.pdfViewer.annotation.textMarkupAnnotationModule) {\n                        this.pdfViewer.annotation.textMarkupAnnotationModule.showHideDropletDiv(true);\n                    }\n                    if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                        commentPanel.style.height = this.pdfViewerBase.viewerMainContainer.clientHeight + 'px';\n                        if (this.pdfViewer.selectedItems.annotations.length > 0) {\n                            var commentDiv = document.getElementById(this.pdfViewer.selectedItems.annotations[0].annotName);\n                            if (commentDiv && commentDiv.lastElementChild.children[1] &&\n                                commentDiv.lastElementChild.children[1].ej2_instances) {\n                                commentDiv.lastElementChild.children[1].ej2_instances[0].enableEditMode = true;\n                            }\n                            else if (commentDiv && commentDiv.lastElementChild.ej2_instances) {\n                                commentDiv.lastElementChild.ej2_instances[0].enableEditMode = true;\n                                commentDiv.lastElementChild.style.display = 'block';\n                                if (commentDiv.lastElementChild.children[1]) {\n                                    commentDiv.lastElementChild.children[1].style.display = 'block';\n                                }\n                            }\n                        }\n                        if (this.pdfViewer.toolbarModule.annotationToolbarModule.toolbar) {\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.toolbar.element.style.display = 'none';\n                            if (this.pdfViewer.toolbarModule.annotationToolbarModule.propertyToolbar) {\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.propertyToolbar.element.style.display = 'none';\n                            }\n                        }\n                    }\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.navigationPane)) {\n                        this.pdfViewerBase.navigationPane.calculateCommentPanelWidth();\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {number} pageNumber - This is pageNumber\n     * @param {number} index - index\n     * @param {any} annotation - annotation\n     * @param {string} actionString - actionString\n     * @param {string} property - property\n     * @param {any} node - node\n     * @param {any} redo - redo\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.addAction = function (pageNumber, index, annotation, actionString, property, node, redo) {\n        var action = {\n            pageIndex: pageNumber, index: index, annotation: annotation,\n            action: actionString, modifiedProperty: property, undoElement: node, redoElement: redo\n        };\n        this.actionCollection.push(action);\n        this.updateToolbar();\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.undo = function () {\n        var _this = this;\n        var actionObject = this.actionCollection.pop();\n        if (actionObject) {\n            var shapeType = actionObject.annotation.shapeAnnotationType;\n            this.isUndoRedoAction = true;\n            this.isUndoAction = true;\n            switch (actionObject.action) {\n                case 'Text Markup Added':\n                case 'Text Markup Deleted':\n                    if (this.textMarkupAnnotationModule) {\n                        this.textMarkupAnnotationModule.undoTextMarkupAction(actionObject.annotation, actionObject.pageIndex, actionObject.index, actionObject.action);\n                    }\n                    break;\n                case 'Text Markup Property modified':\n                    if (this.textMarkupAnnotationModule) {\n                        actionObject.annotation =\n                            this.textMarkupAnnotationModule.undoRedoPropertyChange(actionObject.annotation, actionObject.pageIndex, actionObject.index, actionObject.modifiedProperty, true);\n                    }\n                    break;\n                case 'Drag':\n                case 'Resize':\n                    if ((0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.isLineShapes)(actionObject.annotation)) {\n                        this.pdfViewer.nodePropertyChange(actionObject.annotation, {\n                            bounds: actionObject.undoElement.bounds,\n                            vertexPoints: actionObject.undoElement.vertexPoints, leaderHeight: actionObject.undoElement.leaderHeight\n                        });\n                    }\n                    else {\n                        this.pdfViewer.nodePropertyChange(actionObject.annotation, { bounds: actionObject.undoElement.bounds });\n                    }\n                    if (actionObject.annotation.measureType === 'Distance' || actionObject.annotation.measureType === 'Perimeter' || actionObject.annotation.measureType === 'Area' ||\n                        actionObject.annotation.measureType === 'Radius' || actionObject.annotation.measureType === 'Volume') {\n                        this.pdfViewer.nodePropertyChange(actionObject.annotation, { notes: actionObject.undoElement.notes });\n                        this.updateCalibrateValues(actionObject.annotation);\n                    }\n                    if (actionObject.annotation.formFieldAnnotationType) {\n                        this.pdfViewer.formDesigner.updateHTMLElement(actionObject.annotation);\n                    }\n                    this.pdfViewer.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    this.pdfViewer.select([actionObject.annotation.id]);\n                    if (actionObject.annotation.shapeAnnotationType === 'Line' || actionObject.annotation.shapeAnnotationType === 'Rectangle' || actionObject.annotation.shapeAnnotationType === 'Ellipse' || actionObject.annotation.shapeAnnotationType === 'Polygon' || actionObject.annotation.shapeAnnotationType === 'LineWidthArrowHead' ||\n                        actionObject.annotation.shapeAnnotationType === 'Radius' || actionObject.annotation.shapeAnnotationType === 'FreeText' || actionObject.annotation.shapeAnnotationType === 'HandWrittenSignature' || actionObject.annotation.shapeAnnotationType === 'SignatureText' || actionObject.annotation.shapeAnnotationType === 'SignatureImage' || actionObject.annotation.shapeAnnotationType === 'Ink') {\n                        this.modifyInCollections(actionObject.annotation, 'bounds');\n                    }\n                    break;\n                case 'Addition':\n                    if (this.pdfViewer.formDesigner && actionObject.annotation.formFieldAnnotationType) {\n                        this.pdfViewer.formDesigner.deleteFormField(actionObject.undoElement.id, false);\n                    }\n                    else {\n                        var isAnnotationUpdate = false;\n                        if (shapeType === 'Line' || shapeType === 'LineWidthArrowHead' || shapeType === 'Polygon' ||\n                            shapeType === 'Ellipse' || shapeType === 'Rectangle' || shapeType === 'Radius' || shapeType === 'Distance') {\n                            if (actionObject.annotation.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(actionObject.annotation.measureType)) {\n                                this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, 'shape', null, true);\n                            }\n                            else {\n                                this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, 'measure', null, true);\n                            }\n                            isAnnotationUpdate = true;\n                            var annotationObject = actionObject.annotation;\n                            var wrapper = annotationObject.wrapper ? annotationObject.wrapper : null;\n                            if (wrapper && wrapper.bounds) {\n                                actionObject.annotation.bounds = wrapper.bounds;\n                            }\n                            actionObject.duplicate = this.modifyInCollections(actionObject.annotation, 'delete');\n                        }\n                        if (shapeType === 'Stamp' || shapeType === 'Image') {\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, actionObject.annotation.shapeAnnotationType, 'delete', true);\n                            this.stampAnnotationModule.updateSessionStorage(actionObject.annotation, null, 'delete');\n                            actionObject.duplicate = this.modifyInCollections(actionObject.annotation, 'delete');\n                            isAnnotationUpdate = true;\n                        }\n                        if (shapeType === 'FreeText' || shapeType === 'HandWrittenSignature' ||\n                            shapeType === 'SignatureImage' || shapeType === 'SignatureText' || shapeType === 'Ink') {\n                            isAnnotationUpdate = true;\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, actionObject.annotation.shapeAnnotationType, 'delete', true);\n                            actionObject.duplicate = this.modifyInCollections(actionObject.annotation, 'delete');\n                        }\n                        if (!isAnnotationUpdate) {\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, actionObject.annotation.shapeAnnotationType, 'delete', true);\n                        }\n                        this.pdfViewer.clearSelection((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.activeElements.activePageID) &&\n                            !isNaN(this.pdfViewerBase.activeElements.activePageID)) ?\n                            this.pdfViewerBase.activeElements.activePageID : actionObject.annotation.pageIndex);\n                        this.pdfViewer.remove(actionObject.annotation);\n                        var filteredAnnotations = this.pdfViewer.annotationCollection.filter(function (annotation) {\n                            var excludeAnnotation = annotation.annotationId !== actionObject.annotation.annotName;\n                            if (excludeAnnotation) {\n                                var removeDiv_1 = document.getElementById(annotation.annotName);\n                                if (removeDiv_1) {\n                                    if (removeDiv_1.parentElement.childElementCount === 1) {\n                                        _this.stickyNotesAnnotationModule.updateAccordionContainer(removeDiv_1);\n                                    }\n                                    else {\n                                        removeDiv_1.parentElement.removeChild(removeDiv_1);\n                                    }\n                                }\n                            }\n                            return !excludeAnnotation;\n                        });\n                        this.pdfViewer.renderDrawing(null, actionObject.annotation.pageIndex);\n                        var removeDiv = document.getElementById(actionObject.annotation.annotName);\n                        if (removeDiv) {\n                            if (removeDiv.parentElement.childElementCount === 1) {\n                                this.stickyNotesAnnotationModule.updateAccordionContainer(removeDiv);\n                            }\n                            else {\n                                removeDiv.parentElement.removeChild(removeDiv);\n                            }\n                        }\n                        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode) {\n                            var mobileAnnotationToolbar = document.getElementById(this.pdfViewer.element.id + '_propertyToolbar');\n                            if (mobileAnnotationToolbar && mobileAnnotationToolbar.children.length > 0) {\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.toolbarCreated = false;\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.createAnnotationToolbarForMobile();\n                            }\n                        }\n                    }\n                    break;\n                case 'Delete':\n                    if (this.pdfViewer.formDesigner && actionObject.annotation.formFieldAnnotationType) {\n                        actionObject.undoElement.bounds.x = actionObject.undoElement.wrapper.bounds.x;\n                        actionObject.undoElement.bounds.y = actionObject.undoElement.wrapper.bounds.y;\n                        this.pdfViewer.formDesigner.drawFormField(actionObject.undoElement);\n                    }\n                    else {\n                        if (shapeType === 'Line' || shapeType === 'LineWidthArrowHead' || shapeType === 'Polygon' || shapeType === 'Ellipse' || shapeType === 'Rectangle' || shapeType === 'Radius' || shapeType === 'Distance') {\n                            if (actionObject.annotation.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(actionObject.annotation.measureType)) {\n                                shapeType = 'shape';\n                                this.shapeAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.undoElement);\n                            }\n                            else {\n                                shapeType = 'shape_measure';\n                                this.measureAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.undoElement);\n                            }\n                        }\n                        if (shapeType === 'Stamp' || shapeType === 'Image') {\n                            this.stampAnnotationModule.updateDeleteItems(actionObject.annotation.pageIndex, actionObject.annotation);\n                        }\n                        else if (shapeType === 'FreeText') {\n                            this.freeTextAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.undoElement);\n                        }\n                        else if (shapeType === 'Ink') {\n                            this.inkAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.undoElement);\n                        }\n                        else if (shapeType === 'HandWrittenSignature' || shapeType === 'SignatureText' || shapeType === 'SignatureImage') {\n                            this.pdfViewerBase.signatureModule.addInCollection(actionObject.annotation.pageIndex, actionObject.undoElement);\n                        }\n                        if (!actionObject.annotation.annotationId) {\n                            var addedAnnot = this.pdfViewer.add(actionObject.annotation);\n                            if ((shapeType === 'FreeText' || addedAnnot.enableShapeLabel) && addedAnnot) {\n                                this.pdfViewer.nodePropertyChange(addedAnnot, {});\n                            }\n                        }\n                        var formFieldObj = void 0;\n                        if (actionObject.annotation.id) {\n                            formFieldObj = this.pdfViewer.nameTable[actionObject.annotation.id.split('_')[0]];\n                        }\n                        if (formFieldObj != null && (formFieldObj.formFieldAnnotationType === 'SignatureField' || formFieldObj.formFieldAnnotationType === 'InitialField')) {\n                            formFieldObj.wrapper.children.push(actionObject.annotation.wrapper.children[0]);\n                            if (actionObject.annotation.shapeAnnotationType === 'SignatureText') {\n                                formFieldObj.wrapper.children.push(actionObject.annotation.wrapper.children[1]);\n                            }\n                            var key = actionObject.annotation.id.split('_')[0] + '_content';\n                            var data = null;\n                            if (this.pdfViewer.formDesignerModule) {\n                                data = this.pdfViewerBase.getItemFromSessionStorage('_formDesigner');\n                            }\n                            if (data) {\n                                var formFieldsData = JSON.parse(data);\n                                for (var i = 0; i < formFieldsData.length; i++) {\n                                    if (formFieldsData[parseInt(i.toString(), 10)].Key === key) {\n                                        if (actionObject.annotation.shapeAnnotationType === 'SignatureText') {\n                                            formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = 'Text';\n                                            formFieldsData[parseInt(i.toString(), 10)].FormField.value = actionObject.annotation.data;\n                                            this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.value =\n                                                actionObject.annotation.data;\n                                            this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = 'Text';\n                                        }\n                                        else if (actionObject.annotation.shapeAnnotationType === 'SignatureImage') {\n                                            formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = 'Image';\n                                            formFieldsData[parseInt(i.toString(), 10)].FormField.value = actionObject.annotation.data;\n                                            this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.value =\n                                                actionObject.annotation.data;\n                                            this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = 'Image';\n                                        }\n                                        else {\n                                            formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = 'Path';\n                                            this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = 'Path';\n                                            var collectionData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__.processPathData)(actionObject.annotation.data);\n                                            var csData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__.splitArrayCollection)(collectionData);\n                                            formFieldsData[parseInt(i.toString(), 10)].FormField.value = JSON.stringify(csData);\n                                            this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.value =\n                                                JSON.stringify(csData);\n                                        }\n                                    }\n                                }\n                                this.pdfViewerBase.setItemInSessionStorage(this.pdfViewerBase.formFieldCollection, '_formDesigner');\n                            }\n                        }\n                        this.pdfViewer.renderDrawing(null, actionObject.annotation.pageIndex);\n                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                            addAnnotationComments(actionObject.annotation.pageIndex, shapeType, true);\n                        if (actionObject.annotation.annotationId) {\n                            var removedAnnotationCollection = this.removedAnnotationCollection[this.removedAnnotationCollection.length - 1];\n                            var annotationType = this.getTypeOfAnnotation(removedAnnotationCollection);\n                            this.pdfViewer.annotationCollection.push(removedAnnotationCollection);\n                            this.removedAnnotationCollection.splice(this.removedAnnotationCollection.length - 1);\n                            var pageNumber = actionObject.annotation.pageNumber >= 0 ? actionObject.annotation.pageNumber :\n                                actionObject.annotation.pageIndex;\n                            this.pdfViewerBase.documentAnnotationCollections[parseInt(pageNumber.toString(), 10)][\"\" + annotationType].\n                                push(this.removedDocumentAnnotationCollection[this.removedDocumentAnnotationCollection.length - 1]);\n                            this.removedDocumentAnnotationCollection.splice(this.removedDocumentAnnotationCollection.length - 1);\n                        }\n                    }\n                    break;\n                case 'stampOpacity':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { opacity: actionObject.undoElement.opacity });\n                    this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(actionObject.annotation, null, true);\n                    actionObject.annotation.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                    break;\n                case 'Shape Stroke':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { strokeColor: actionObject.undoElement.strokeColor });\n                    this.modifyInCollections(actionObject.annotation, 'stroke');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Shape Fill':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { fillColor: actionObject.undoElement.fillColor });\n                    this.modifyInCollections(actionObject.annotation, 'fill');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Shape Opacity':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { opacity: actionObject.undoElement.opacity });\n                    if (actionObject.annotation.shapeAnnotationType === 'StickyNotes') {\n                        this.stickyNotesAnnotationModule.updateOpacityValue(actionObject.annotation);\n                        this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(actionObject.annotation, null, true);\n                        actionObject.annotation.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                    }\n                    else {\n                        this.modifyInCollections(actionObject.annotation, 'opacity');\n                    }\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Shape Thickness':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { thickness: actionObject.undoElement.thickness });\n                    this.modifyInCollections(actionObject.annotation, 'thickness');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Line properties change':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, {\n                        fillColor: actionObject.undoElement.fillColor, borderDashArray: actionObject.undoElement.borderDashArray,\n                        borderStyle: actionObject.undoElement.borderStyle,\n                        strokeColor: actionObject.undoElement.strokeColor, opacity: actionObject.undoElement.opacity,\n                        thickness: actionObject.undoElement.thickness,\n                        sourceDecoraterShapes: this.getArrowType(actionObject.undoElement.lineHeadStart),\n                        taregetDecoraterShapes: this.getArrowType(actionObject.undoElement.lineHeadEnd)\n                    });\n                    this.updateCollectionForLineProperty(actionObject.annotation);\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Text Property Added':\n                    actionObject.annotation = this.pdfViewer.annotationModule.\n                        stickyNotesAnnotationModule.undoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(actionObject.annotation, null, true);\n                    actionObject.annotation.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                    break;\n                case 'Comments Property Added':\n                    actionObject.annotation = this.pdfViewer.annotationModule.\n                        stickyNotesAnnotationModule.undoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    break;\n                case 'Status Property Added':\n                    actionObject.annotation = this.pdfViewer.annotationModule.\n                        stickyNotesAnnotationModule.undoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    break;\n                case 'Comments Reply Deleted':\n                    actionObject.annotation = this.pdfViewer.annotationModule.\n                        stickyNotesAnnotationModule.undoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    break;\n                case 'dynamicText Change':\n                    this.pdfViewer.annotation.freeTextAnnotationModule.isFreeTextValueChange = true;\n                    actionObject.annotation.dynamicText = actionObject.undoElement.dynamicText;\n                    if (this.pdfViewer.selectedItems.annotations[0]) {\n                        this.pdfViewer.selectedItems.annotations[0].dynamicText = actionObject.undoElement.dynamicText;\n                    }\n                    this.pdfViewer.annotationModule.\n                        stickyNotesAnnotationModule.undoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(actionObject.annotation, null, true);\n                    this.modifyInCollections(actionObject.annotation, 'dynamicText');\n                    if (this.pdfViewer.selectedItems.annotations[0]) {\n                        this.pdfViewer.nodePropertyChange(this.pdfViewer.selectedItems.annotations[0], {});\n                    }\n                    else {\n                        this.pdfViewer.nodePropertyChange(actionObject.annotation, {});\n                    }\n                    this.pdfViewer.annotation.freeTextAnnotationModule.isFreeTextValueChange = false;\n                    this.pdfViewer.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    break;\n                case 'fontColor':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { fontColor: actionObject.undoElement.fontColor });\n                    this.modifyInCollections(actionObject.annotation, 'fontColor');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'fontSize':\n                    this.isFreeTextFontsizeChanged = true;\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { fontSize: actionObject.undoElement.fontSize });\n                    this.modifyInCollections(actionObject.annotation, 'fontSize');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'fontFamily':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { fontFamily: actionObject.undoElement.fontFamily });\n                    this.modifyInCollections(actionObject.annotation, 'fontFamily');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'textAlign':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { textAlign: actionObject.undoElement.textAlign });\n                    this.modifyInCollections(actionObject.annotation, 'textAlign');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'textPropertiesChange':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation, { font: actionObject.undoElement.font });\n                    this.modifyInCollections(actionObject.annotation, 'textPropertiesChange');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Rotate':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation.annotations[0], {\n                        bounds: actionObject.undoElement.bounds,\n                        rotateAngle: actionObject.undoElement.rotateAngle\n                    });\n                    this.modifyInCollections(actionObject.annotation.annotations[0], 'bounds');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'FormDesigner Properties Change':\n                    if (actionObject.undoElement && actionObject.undoElement.isMultiline !== actionObject.redoElement.isMultiline) {\n                        this.undoRedoMultiline(actionObject.undoElement);\n                    }\n                    this.updateFormFieldPropertiesChanges(actionObject.undoElement.formFieldAnnotationType, actionObject.undoElement);\n                    break;\n                case 'FormField Value Change':\n                    if (actionObject.annotation.formFieldAnnotationType) {\n                        if (actionObject.annotation.formFieldAnnotationType === 'RadioButton') {\n                            this.updateFormFieldValueChange(actionObject.annotation.formFieldAnnotationType, actionObject.undoElement, false);\n                            this.updateFormFieldValueChange(actionObject.annotation.formFieldAnnotationType, actionObject.redoElement, true);\n                        }\n                        else {\n                            this.updateFormFieldValueChange(actionObject.annotation.formFieldAnnotationType, actionObject.annotation, actionObject.undoElement);\n                        }\n                    }\n                    else {\n                        var spanElement = document.getElementById(actionObject.annotation.id + '_html_element').children[0].children[0];\n                        spanElement.className = 'e-pdfviewer-signatureformfields';\n                        var formFieldObj = this.pdfViewer.nameTable[actionObject.annotation.id.split('_')[0]];\n                        var annotationObj = this.pdfViewer.nameTable[actionObject.annotation.id];\n                        if (actionObject.annotation.annotName === 'SignatureField' || actionObject.annotation.annotName === 'SignatureText') {\n                            actionObject.annotation.bounds = annotationObj.wrapper.bounds;\n                        }\n                        formFieldObj.wrapper.children.splice(formFieldObj.wrapper.children.indexOf(annotationObj.wrapper.children[0]), 1);\n                        if (actionObject.annotation.shapeAnnotationType === 'SignatureText') {\n                            formFieldObj.wrapper.children.splice(formFieldObj.wrapper.children.indexOf(annotationObj.wrapper.children[1]), 1);\n                        }\n                        var key = actionObject.annotation.id.split('_')[0] + '_content';\n                        var data = null;\n                        if (this.pdfViewer.formDesignerModule) {\n                            data = this.pdfViewerBase.getItemFromSessionStorage('_formDesigner');\n                        }\n                        if (data) {\n                            var formFieldsData = JSON.parse(data);\n                            for (var i = 0; i < formFieldsData.length; i++) {\n                                if (formFieldsData[parseInt(i.toString(), 10)].Key === key) {\n                                    formFieldsData[parseInt(i.toString(), 10)].FormField.value = '';\n                                    formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = '';\n                                    this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.value = '';\n                                    this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = '';\n                                }\n                            }\n                            this.pdfViewer.remove(actionObject.annotation);\n                            this.pdfViewer.renderDrawing();\n                            this.pdfViewerBase.setItemInSessionStorage(this.pdfViewerBase.formFieldCollection, '_formDesigner');\n                        }\n                    }\n            }\n            this.redoCollection.push(actionObject);\n            this.updateToolbar();\n            this.isUndoRedoAction = false;\n            this.isUndoAction = false;\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.redo = function () {\n        var actionObject = this.redoCollection.pop();\n        var annotationObject = this.pdfViewer.nameTable[actionObject.annotation.id];\n        if (actionObject) {\n            var shapeType = actionObject.annotation.shapeAnnotationType;\n            this.isUndoRedoAction = true;\n            switch (actionObject.action) {\n                case 'Text Markup Property modified':\n                    if (this.textMarkupAnnotationModule) {\n                        actionObject.annotation = this.textMarkupAnnotationModule.\n                            undoRedoPropertyChange(actionObject.annotation, actionObject.pageIndex, actionObject.index, actionObject.modifiedProperty);\n                    }\n                    break;\n                case 'Text Markup Added':\n                case 'Text Markup Deleted':\n                    if (this.textMarkupAnnotationModule) {\n                        this.textMarkupAnnotationModule.\n                            redoTextMarkupAction(actionObject.annotation, actionObject.pageIndex, actionObject.index, actionObject.action);\n                    }\n                    break;\n                case 'Drag':\n                case 'Resize':\n                    if ((0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.isLineShapes)(actionObject.annotation)) {\n                        this.pdfViewer.nodePropertyChange(annotationObject, { bounds: actionObject.redoElement.bounds, vertexPoints: actionObject.redoElement.vertexPoints, leaderHeight: actionObject.redoElement.leaderHeight });\n                    }\n                    else {\n                        this.pdfViewer.nodePropertyChange(annotationObject, { bounds: actionObject.redoElement.bounds });\n                    }\n                    if (actionObject.annotation.measureType === 'Distance' || actionObject.annotation.measureType === 'Perimeter' || actionObject.annotation.measureType === 'Area' ||\n                        actionObject.annotation.measureType === 'Radius' || actionObject.annotation.measureType === 'Volume') {\n                        this.pdfViewer.nodePropertyChange(annotationObject, { notes: actionObject.redoElement.notes });\n                        this.updateCalibrateValues(annotationObject);\n                    }\n                    if (actionObject.annotation.formFieldAnnotationType) {\n                        this.pdfViewer.formDesigner.updateHTMLElement(actionObject.annotation);\n                    }\n                    this.pdfViewer.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    this.pdfViewer.select([annotationObject.id]);\n                    if (actionObject.annotation.shapeAnnotationType === 'Line' || actionObject.annotation.shapeAnnotationType === 'Rectangle' || actionObject.annotation.shapeAnnotationType === 'Ellipse' || actionObject.annotation.shapeAnnotationType === 'Polygon' || actionObject.annotation.shapeAnnotationType === 'LineWidthArrowHead'\n                        || actionObject.annotation.shapeAnnotationType === 'Radius' || actionObject.annotation.shapeAnnotationType === 'FreeText' || actionObject.annotation.shapeAnnotationType === 'HandWrittenSignature' || actionObject.annotation.shapeAnnotationType === 'SignatureText' || actionObject.annotation.shapeAnnotationType === 'SignatureImage' || actionObject.annotation.shapeAnnotationType === 'Ink') {\n                        this.modifyInCollections(annotationObject, 'bounds');\n                    }\n                    break;\n                case 'Addition':\n                    if (this.pdfViewer.formDesigner && actionObject.annotation.formFieldAnnotationType) {\n                        actionObject.redoElement.bounds.x = actionObject.redoElement.wrapper.bounds.x;\n                        actionObject.redoElement.bounds.y = actionObject.redoElement.wrapper.bounds.y;\n                        this.pdfViewer.formDesigner.drawFormField(actionObject.redoElement);\n                    }\n                    else {\n                        if (shapeType === 'Line' || shapeType === 'LineWidthArrowHead' || shapeType === 'Polygon' || shapeType === 'Ellipse' || shapeType === 'Rectangle' || shapeType === 'Radius' || shapeType === 'Distance') {\n                            if (actionObject.annotation.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(actionObject.annotation.measureType)) {\n                                shapeType = 'shape';\n                                this.shapeAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.duplicate);\n                            }\n                            else {\n                                shapeType = 'shape_measure';\n                                this.measureAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.duplicate);\n                            }\n                        }\n                        if (shapeType === 'FreeText') {\n                            this.freeTextAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.duplicate);\n                        }\n                        if (shapeType === 'Stamp' || shapeType === 'Image') {\n                            this.stampAnnotationModule.updateDeleteItems(actionObject.annotation.pageIndex, actionObject.redoElement);\n                        }\n                        if (shapeType === 'HandWrittenSignature' || shapeType === 'SignatureText' || shapeType === 'SignatureImage') {\n                            this.pdfViewerBase.signatureModule.addInCollection(actionObject.annotation.pageIndex, actionObject.duplicate);\n                        }\n                        if (shapeType === 'Ink') {\n                            this.inkAnnotationModule.addInCollection(actionObject.annotation.pageIndex, actionObject.duplicate);\n                        }\n                        var addedAnnot = this.pdfViewer.add(actionObject.annotation);\n                        this.pdfViewer.select([actionObject.annotation.id]);\n                        if ((shapeType === 'FreeText' || addedAnnot.enableShapeLabel) && addedAnnot) {\n                            this.pdfViewer.nodePropertyChange(addedAnnot, {});\n                        }\n                        this.pdfViewer.renderDrawing(null, actionObject.annotation.pageIndex);\n                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                            addAnnotationComments(actionObject.annotation.pageIndex, shapeType, false);\n                        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode) {\n                            var mobileAnnotationToolbar = document.getElementById(this.pdfViewer.element.id + '_propertyToolbar');\n                            if (mobileAnnotationToolbar && mobileAnnotationToolbar.children.length > 0) {\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.toolbarCreated = false;\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.createAnnotationToolbarForMobile();\n                            }\n                        }\n                    }\n                    break;\n                case 'Delete':\n                    if (this.pdfViewer.formDesigner && actionObject.annotation.formFieldAnnotationType) {\n                        this.pdfViewer.formDesigner.deleteFormField(actionObject.redoElement.id, false);\n                    }\n                    else {\n                        var isUpdate = false;\n                        var sType = actionObject.annotation.shapeAnnotationType;\n                        if (shapeType === 'Line' || shapeType === 'LineWidthArrowHead' || shapeType === 'Polygon' || shapeType === 'Ellipse' || shapeType === 'Rectangle' || shapeType === 'Radius' || shapeType === 'Distance') {\n                            if (actionObject.annotation.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(actionObject.annotation.measureType)) {\n                                sType = 'shape';\n                            }\n                            else {\n                                sType = 'measure';\n                            }\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, sType, 'delete');\n                            this.modifyInCollections(actionObject.annotation, 'delete');\n                            isUpdate = true;\n                        }\n                        if (shapeType === 'Stamp' || shapeType === 'Image') {\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, sType, 'delete');\n                            this.stampAnnotationModule.updateSessionStorage(actionObject.annotation, null, 'delete');\n                            this.modifyInCollections(actionObject.annotation, 'delete');\n                            isUpdate = true;\n                        }\n                        if (shapeType === 'FreeText' || shapeType === 'HandWrittenSignature' || shapeType === 'SignatureText' || shapeType === 'SignatureImage') {\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, sType, 'delete');\n                            this.modifyInCollections(actionObject.annotation, 'delete');\n                        }\n                        if (!isUpdate) {\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.findPosition(actionObject.annotation, sType, 'delete');\n                        }\n                        var formFieldObj = void 0;\n                        if (actionObject.annotation.id) {\n                            formFieldObj = this.pdfViewer.nameTable[actionObject.annotation.id.split('_')[0]];\n                        }\n                        if (formFieldObj != null && (formFieldObj.formFieldAnnotationType === 'SignatureField' || formFieldObj.formFieldAnnotationType === 'InitialField')) {\n                            formFieldObj.wrapper.children.splice(formFieldObj.wrapper.children.\n                                indexOf(actionObject.annotation.wrapper.children[0]), 1);\n                            if (actionObject.annotation.shapeAnnotationType === 'SignatureText') {\n                                formFieldObj.wrapper.children.splice(formFieldObj.wrapper.children.\n                                    indexOf(actionObject.annotation.wrapper.children[1]), 1);\n                            }\n                            var key = actionObject.annotation.id.split('_')[0] + '_content';\n                            var data = null;\n                            if (this.pdfViewer.formDesignerModule) {\n                                data = this.pdfViewerBase.getItemFromSessionStorage('_formDesigner');\n                            }\n                            if (data) {\n                                var formFieldsData = JSON.parse(data);\n                                for (var i = 0; i < formFieldsData.length; i++) {\n                                    if (formFieldsData[parseInt(i.toString(), 10)].Key === key) {\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.value = '';\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = '';\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.value = '';\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = '';\n                                    }\n                                }\n                                this.pdfViewerBase.setItemInSessionStorage(this.pdfViewerBase.formFieldCollection, '_formDesigner');\n                            }\n                        }\n                        this.pdfViewer.clearSelection(actionObject.annotation.pageIndex);\n                        this.pdfViewer.remove(actionObject.annotation);\n                        this.pdfViewer.renderDrawing(null, actionObject.annotation.pageIndex);\n                        var id = actionObject.annotation.annotName ? actionObject.annotation.\n                            annotName : actionObject.annotation.annotationId;\n                        var removeDiv = document.getElementById(id);\n                        this.removeCommentPanelDiv(removeDiv);\n                        if (actionObject.annotation.annotationId) {\n                            var collections = this.\n                                updateCollectionForNonRenderedPages(actionObject.annotation, id, actionObject.annotation.pageIndex);\n                            this.undoCommentsElement.push(collections);\n                        }\n                    }\n                    break;\n                case 'stampOpacity':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { opacity: actionObject.redoElement.opacity });\n                    this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(annotationObject, null, true);\n                    break;\n                case 'Shape Stroke':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { strokeColor: actionObject.redoElement.strokeColor });\n                    this.modifyInCollections(annotationObject, 'stroke');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Shape Fill':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { fillColor: actionObject.redoElement.fillColor });\n                    this.modifyInCollections(annotationObject, 'fill');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Shape Opacity':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { opacity: actionObject.redoElement.opacity });\n                    if (actionObject.annotation.shapeAnnotationType === 'StickyNotes') {\n                        this.stickyNotesAnnotationModule.updateOpacityValue(annotationObject);\n                        this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(annotationObject, null, true);\n                    }\n                    else {\n                        this.modifyInCollections(annotationObject, 'opacity');\n                    }\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Shape Thickness':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { thickness: actionObject.redoElement.thickness });\n                    this.modifyInCollections(annotationObject, 'thickness');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Line properties change':\n                    this.pdfViewer.nodePropertyChange(annotationObject, {\n                        fillColor: actionObject.redoElement.fillColor, strokeColor: actionObject.redoElement.strokeColor,\n                        opacity: actionObject.redoElement.opacity, thickness: actionObject.redoElement.thickness,\n                        sourceDecoraterShapes: this.getArrowType(actionObject.redoElement.lineHeadStart),\n                        taregetDecoraterShapes: this.getArrowType(actionObject.redoElement.lineHeadEnd),\n                        borderDashArray: actionObject.redoElement.borderDashArray, borderStyle: actionObject.redoElement.borderStyle\n                    });\n                    this.updateCollectionForLineProperty(annotationObject);\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Text Property Added':\n                    actionObject.annotation = this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        redoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(actionObject.annotation, null, true);\n                    break;\n                case 'Comments Property Added':\n                    actionObject.annotation = this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        redoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    break;\n                case 'Status Property Added':\n                    actionObject.annotation = this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        redoAction(actionObject.annotation, actionObject.action);\n                    break;\n                case 'Comments Reply Deleted':\n                    actionObject.annotation = this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        redoAction(actionObject.annotation, actionObject.action);\n                    break;\n                case 'dynamicText Change': {\n                    this.pdfViewer.annotation.freeTextAnnotationModule.isFreeTextValueChange = true;\n                    annotationObject.dynamicText = actionObject.redoElement.dynamicText;\n                    var annotation = this.pdfViewer.selectedItems.annotations[0];\n                    if (annotation) {\n                        annotation.dynamicText = actionObject.redoElement.dynamicText;\n                        annotation.bounds.height = actionObject.redoElement.bounds.height;\n                    }\n                    this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        redoAction(actionObject.annotation, actionObject.action, actionObject.undoElement);\n                    this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(annotationObject, null, true);\n                    this.modifyInCollections(annotationObject, 'dynamicText');\n                    if (annotation) {\n                        this.pdfViewer.nodePropertyChange(annotation, {});\n                    }\n                    else {\n                        this.pdfViewer.nodePropertyChange(annotationObject, {});\n                    }\n                    this.pdfViewer.annotation.freeTextAnnotationModule.isFreeTextValueChange = false;\n                    this.pdfViewer.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    this.pdfViewer.select([annotationObject.id]);\n                    break;\n                }\n                case 'fontColor':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { fontColor: actionObject.redoElement.fontColor });\n                    this.modifyInCollections(annotationObject, 'fontColor');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'fontSize':\n                    this.isFreeTextFontsizeChanged = true;\n                    this.pdfViewer.nodePropertyChange(annotationObject, { fontSize: actionObject.redoElement.fontSize });\n                    this.modifyInCollections(annotationObject, 'fontSize');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'textAlign':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { textAlign: actionObject.redoElement.textAlign });\n                    this.modifyInCollections(annotationObject, 'textAlign');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'textPropertiesChange':\n                    this.pdfViewer.nodePropertyChange(annotationObject, { font: actionObject.redoElement.font });\n                    this.modifyInCollections(annotationObject, 'textPropertiesChange');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'Rotate':\n                    this.pdfViewer.nodePropertyChange(actionObject.annotation.annotations[0], { bounds: actionObject.redoElement.bounds,\n                        rotateAngle: actionObject.redoElement.rotateAngle });\n                    this.modifyInCollections(actionObject.annotation.annotations[0], 'bounds');\n                    this.pdfViewer.renderDrawing();\n                    break;\n                case 'FormDesigner Properties Change':\n                    if (actionObject.redoElement && actionObject.undoElement.isMultiline !== actionObject.redoElement.isMultiline) {\n                        this.undoRedoMultiline(actionObject.redoElement);\n                    }\n                    this.updateFormFieldPropertiesChanges(actionObject.redoElement.formFieldAnnotationType, actionObject.redoElement);\n                    break;\n                case 'FormField Value Change':\n                    if (actionObject.annotation.formFieldAnnotationType) {\n                        if (actionObject.annotation.formFieldAnnotationType === 'RadioButton') {\n                            this.updateFormFieldValueChange(actionObject.annotation.formFieldAnnotationType, actionObject.undoElement, true);\n                            this.updateFormFieldValueChange(actionObject.annotation.formFieldAnnotationType, actionObject.redoElement, false);\n                        }\n                        else {\n                            this.updateFormFieldValueChange(actionObject.annotation.formFieldAnnotationType, actionObject.annotation, actionObject.redoElement);\n                        }\n                    }\n                    else {\n                        var spanElement = document.getElementById(actionObject.annotation.id + '_html_element').children[0].children[0];\n                        spanElement.className = 'e-pdfviewer-signatureformfields-signature';\n                        var formFieldObj = this.pdfViewer.nameTable[actionObject.annotation.id.split('_')[0]];\n                        var annotationObj = this.pdfViewer.nameTable[actionObject.annotation.id];\n                        formFieldObj.wrapper.children.push(annotationObj.wrapper.children[0]);\n                        if (actionObject.annotation.shapeAnnotationType === 'SignatureText') {\n                            formFieldObj.wrapper.children.push(annotationObj.wrapper.children[1]);\n                        }\n                        var key = actionObject.annotation.id.split('_')[0] + '_content';\n                        var data = null;\n                        if (this.pdfViewer.formDesignerModule) {\n                            data = this.pdfViewerBase.getItemFromSessionStorage('_formDesigner');\n                        }\n                        if (data) {\n                            var formFieldsData = JSON.parse(data);\n                            for (var i = 0; i < formFieldsData.length; i++) {\n                                if (formFieldsData[parseInt(i.toString(), 10)].Key === key) {\n                                    if (actionObject.annotation.shapeAnnotationType === 'SignatureText') {\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = 'Text';\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.value = actionObject.annotation.data;\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].\n                                            FormField.value = actionObject.annotation.data;\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = 'Text';\n                                    }\n                                    else if (actionObject.annotation.shapeAnnotationType === 'SignatureImage') {\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = 'Image';\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.value = actionObject.annotation.data;\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].\n                                            FormField.value = actionObject.annotation.data;\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = 'Image';\n                                    }\n                                    else {\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.signatureType = 'Path';\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].FormField.signatureType = 'Path';\n                                        var collectionData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__.processPathData)(actionObject.annotation.data);\n                                        var csData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__.splitArrayCollection)(collectionData);\n                                        formFieldsData[parseInt(i.toString(), 10)].FormField.value = JSON.stringify(csData);\n                                        this.pdfViewerBase.formFieldCollection[parseInt(i.toString(), 10)].\n                                            FormField.value = JSON.stringify(csData);\n                                    }\n                                }\n                            }\n                            this.pdfViewer.add(actionObject.annotation);\n                            var canvass = this.pdfViewerBase.getAnnotationCanvas('_annotationCanvas_', actionObject.pageIndex);\n                            this.pdfViewer.renderDrawing(canvass, actionObject.pageIndex);\n                            this.pdfViewerBase.setItemInSessionStorage(this.pdfViewerBase.formFieldCollection, '_formDesigner');\n                        }\n                    }\n            }\n            if (actionObject.redoElement && actionObject.redoElement.modifiedDate !== undefined) {\n                actionObject.annotation.modifiedDate = actionObject.redoElement.modifiedDate;\n            }\n            this.actionCollection.push(actionObject);\n            this.updateToolbar();\n            this.isUndoRedoAction = false;\n        }\n    };\n    Annotation.prototype.undoRedoMultiline = function (element) {\n        if (element.isMultiline && element.formFieldAnnotationType === 'Textbox') {\n            this.pdfViewer.formDesignerModule.renderMultilineText(element, true);\n        }\n        else if (element.formFieldAnnotationType === 'Textbox') {\n            this.pdfViewer.formDesignerModule.renderTextbox(element, true);\n        }\n    };\n    Annotation.prototype.updateFormFieldValueChange = function (formFieldAnnotationType, annotation, value) {\n        if (annotation) {\n            var formFieldModel = this.pdfViewer.formDesigner.getFormField(annotation.id.split('_')[0]);\n            var data = null;\n            if (this.pdfViewer.formDesignerModule) {\n                data = this.pdfViewerBase.getItemFromSessionStorage('_formDesigner');\n            }\n            if (data) {\n                var formFieldsData = JSON.parse(data);\n                var index = this.pdfViewer.formDesigner.getFormFiledIndex(annotation.id.split('_')[0]);\n                switch (formFieldAnnotationType) {\n                    case 'Textbox':\n                    case 'PasswordField':\n                    case 'RadioButton':\n                    case 'DropdownList':\n                    case 'ListBox': {\n                        var inputElement = document.getElementById(annotation.id.split('_')[0] + '_content_html_element').firstElementChild.firstElementChild;\n                        if (formFieldAnnotationType === 'Textbox' || formFieldAnnotationType === 'PasswordField') {\n                            formFieldModel.value = value;\n                            this.pdfViewer.formDesigner.updateValuePropertyChange(formFieldModel, inputElement, true, index, formFieldsData);\n                        }\n                        else if (formFieldAnnotationType === 'RadioButton') {\n                            formFieldModel.isSelected = value;\n                            this.pdfViewer.formDesigner.updateIsSelectedPropertyChange(formFieldModel, inputElement.firstElementChild, true, index, formFieldsData);\n                        }\n                        else if (formFieldAnnotationType === 'DropdownList' || formFieldAnnotationType === 'ListBox') {\n                            formFieldModel.selectedIndex = value;\n                            formFieldsData[parseInt(index.toString(), 10)].FormField.selectedIndex = value;\n                            this.pdfViewerBase.formFieldCollection[parseInt(index.toString(), 10)].FormField.selectedIndex = value;\n                            this.pdfViewer.nameTable[formFieldsData[parseInt(index.toString(), 10)].Key.split('_')[0]].selectedIndex = value;\n                            if (formFieldAnnotationType === 'ListBox') {\n                                for (var k = 0; k < inputElement.options.length; k++) {\n                                    inputElement.options[parseInt(k.toString(), 10)].selected = value.includes(k) ? true : false;\n                                }\n                            }\n                            else {\n                                inputElement.selectedIndex = value;\n                            }\n                        }\n                        break;\n                    }\n                    case 'Checkbox': {\n                        var checkboxDivElement = document.getElementById(annotation.id.split('_')[0] + '_content_html_element').firstElementChild.firstElementChild.lastElementChild;\n                        formFieldModel.isChecked = value;\n                        this.pdfViewer.formDesigner.updateIsCheckedPropertyChange(formFieldModel, checkboxDivElement, true, index, formFieldsData);\n                        break;\n                    }\n                }\n                this.pdfViewerBase.setItemInSessionStorage(this.pdfViewerBase.formFieldCollection, '_formDesigner');\n            }\n        }\n    };\n    Annotation.prototype.updateFormFieldPropertiesChanges = function (formFieldAnnotationType, element) {\n        switch (formFieldAnnotationType) {\n            case 'Textbox':\n            case 'PasswordField':\n                this.pdfViewer.formDesigner.updateTextboxFormDesignerProperties(element, true);\n                break;\n            case 'Checkbox':\n                this.pdfViewer.formDesigner.updateCheckboxFormDesignerProperties(element, true, true);\n                break;\n            case 'RadioButton':\n                this.pdfViewer.formDesigner.updateRadioButtonDesignerProperties(element, true, true);\n                break;\n            case 'DropdownList':\n                this.pdfViewer.formDesigner.updateDropdownFormDesignerProperties(element, true);\n                break;\n            case 'ListBox':\n                this.pdfViewer.formDesigner.updateListBoxFormDesignerProperties(element, true);\n                break;\n            case 'SignatureField':\n            case 'InitialField':\n                this.pdfViewer.formDesigner.updateSignatureTextboxProperties(element, true);\n        }\n    };\n    Annotation.prototype.updateCollectionForLineProperty = function (pdfAnnotationBase) {\n        this.modifyInCollections(pdfAnnotationBase, 'fill');\n        this.modifyInCollections(pdfAnnotationBase, 'stroke');\n        this.modifyInCollections(pdfAnnotationBase, 'opacity');\n        this.modifyInCollections(pdfAnnotationBase, 'thickness');\n        this.modifyInCollections(pdfAnnotationBase, 'dashArray');\n        this.modifyInCollections(pdfAnnotationBase, 'startArrow');\n        this.modifyInCollections(pdfAnnotationBase, 'endArrow');\n    };\n    Annotation.prototype.updateToolbar = function (isAnnotationDelete) {\n        if (this.pdfViewer.toolbarModule) {\n            this.pdfViewer.toolbarModule.updateUndoRedoButtons();\n        }\n        if (this.actionCollection && this.actionCollection.length === 0) {\n            this.pdfViewerBase.updateDocumentEditedProperty(false);\n        }\n        else {\n            this.pdfViewerBase.updateDocumentEditedProperty(true);\n        }\n        if (isAnnotationDelete) {\n            //This below lines are commented for the below task -EJ2-61754-IsDocumentEdited API is not Properly working for delete annotations\n            //Also refer EJ2-55205-The isDocumentEdited property is False on adding handwritten signature\n            // let isEdited: boolean = false;\n            // if (this.pdfViewer.annotationCollection && this.pdfViewer.annotationCollection.length > 0 && this.pdfViewer.signatureCollection && this.pdfViewer.signatureCollection.length > 0) {\n            //     isEdited = true;\n            // }\n            // if (!isEdited && this.pdfViewer.isDocumentEdited) {\n            this.pdfViewerBase.updateDocumentEditedProperty(true);\n            // }\n        }\n    };\n    Annotation.prototype.createNote = function () {\n        this.popupNote = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_annotation_note', className: 'e-pv-annotation-note', styles: 'display:none' });\n        this.popupNoteAuthor = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_annotation_note_author', className: 'e-pv-annotation-note-author' });\n        this.popupNote.appendChild(this.popupNoteAuthor);\n        this.popupNoteContent = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: this.pdfViewer.element.id + '_annotation_note_content', className: 'e-pv-annotation-note-content' });\n        this.popupNote.appendChild(this.popupNoteContent);\n        if (this.pdfViewerBase.mainContainer) {\n            this.pdfViewerBase.mainContainer.appendChild(this.popupNote);\n        }\n    };\n    /**\n     * @param {any} event - event\n     * @param {string} color - color\n     * @param {string} author - author\n     * @param {string} note - note\n     * @param {string} type - type\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.showPopupNote = function (event, color, author, note, type) {\n        var mainContainerPosition = this.pdfViewerBase.mainContainer.getBoundingClientRect();\n        var popupNoteClientRect = this.popupNote.getBoundingClientRect();\n        if (author) {\n            this.popupNoteAuthor.textContent = author;\n        }\n        this.popupNoteContent.textContent = note;\n        if (type === 'Highlight') {\n            this.popupNote.style.backgroundColor = 'rgb(237, 232, 177)';\n        }\n        else if (type === 'Underline') {\n            this.popupNote.style.backgroundColor = 'rgb(187, 241, 191)';\n        }\n        else if (type === 'Strikethrough') {\n            this.popupNote.style.backgroundColor = 'rgb(242, 188, 207)';\n        }\n        this.popupNote.style.display = 'block';\n        var topPosition = (event.pageY - mainContainerPosition.top + 5);\n        var leftPosition = (event.pageX - mainContainerPosition.left + 5);\n        if (leftPosition + popupNoteClientRect.width > mainContainerPosition.width) {\n            leftPosition = leftPosition - popupNoteClientRect.width;\n        }\n        if (topPosition + popupNoteClientRect.height > mainContainerPosition.height) {\n            topPosition = topPosition - popupNoteClientRect.height;\n        }\n        this.popupNote.style.top = topPosition + 'px';\n        this.popupNote.style.left = leftPosition + 'px';\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.hidePopupNote = function () {\n        if (this.popupNote) {\n            this.popupNote.style.display = 'none';\n        }\n    };\n    Annotation.prototype.createTextMarkupPopup = function () {\n        var _this = this;\n        var elementId = this.pdfViewer.element.id;\n        this.popupElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementId + '_popup_annotation_note', className: 'e-pv-annotation-popup-menu', styles: 'display:none' });\n        var headerElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementId + '_popup_header', className: 'e-pv-annotation-popup-header' });\n        this.authorPopupElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementId + '_popup_author', className: 'e-pv-annotation-popup-author' });\n        headerElement.appendChild(this.authorPopupElement);\n        var closeBtn = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { id: elementId + '_popup_close', className: 'e-pv-annotation-popup-close e-pv-icon' });\n        headerElement.appendChild(closeBtn);\n        this.popupElement.appendChild(headerElement);\n        this.modifiedDateElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementId + '_popup_modified_time', className: 'e-pv-annotation-modified-time' });\n        this.popupElement.appendChild(this.modifiedDateElement);\n        var contentContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementId + '_popup_content_container', className: 'e-pv-annotation-popup-note-container' });\n        this.noteContentElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementId + '_popup_content', className: 'e-pv-annotation-popup-content' });\n        this.noteContentElement.contentEditable = 'true';\n        contentContainer.appendChild(this.noteContentElement);\n        this.popupElement.appendChild(contentContainer);\n        this.pdfViewerBase.viewerContainer.appendChild(this.popupElement);\n        closeBtn.addEventListener('click', this.saveClosePopupMenu.bind(this));\n        closeBtn.addEventListener('touchend', this.saveClosePopupMenu.bind(this));\n        this.popupElement.addEventListener('mousedown', this.onPopupElementMoveStart.bind(this));\n        this.popupElement.addEventListener('mousemove', this.onPopupElementMove.bind(this));\n        window.addEventListener('mouseup', this.onPopupElementMoveEnd.bind(this));\n        this.popupElement.addEventListener('touchstart', this.onPopupElementMoveStart.bind(this));\n        this.popupElement.addEventListener('touchmove', this.onPopupElementMove.bind(this));\n        window.addEventListener('touchend', this.onPopupElementMoveEnd.bind(this));\n        this.noteContentElement.addEventListener('mousedown', function () {\n            _this.noteContentElement.focus();\n        });\n    };\n    Annotation.prototype.onPopupElementMoveStart = function (event) {\n        if (event.type === 'touchstart') {\n            event = event.changedTouches[0];\n        }\n        if ((event.target.id !== (this.noteContentElement.id) || !(event.target.contains(this.noteContentElement.childNodes[0])))) {\n            this.isPopupMenuMoved = true;\n            var popupElementClientRect = this.popupElement.getBoundingClientRect();\n            this.clientX = event.clientX - popupElementClientRect.left;\n            this.clientY = (event.clientY - popupElementClientRect.top) +\n                (this.pdfViewerBase.pageSize[this.currentAnnotPageNumber].top * this.pdfViewerBase.getZoomFactor());\n        }\n    };\n    Annotation.prototype.onPopupElementMove = function (event) {\n        if (event.type === 'touchmove') {\n            event = event.changedTouches[0];\n        }\n        if (this.isPopupMenuMoved && (event.target.id !== (this.noteContentElement.id) ||\n            !(event.target.contains(this.noteContentElement.childNodes[0])))) {\n            var left = (event.clientX - this.clientX) + parseFloat(this.popupElement.style.left);\n            var top_1 = ((event.clientY - this.clientY) + parseFloat(this.popupElement.style.top));\n            this.clientX = event.clientX;\n            this.clientY = event.clientY;\n            var clientPosition = this.popupElement.getBoundingClientRect();\n            var pageDiv = document.getElementById(this.pdfViewer.element.id + '_pageDiv_' + this.currentAnnotPageNumber);\n            if (left > parseFloat(pageDiv.style.left) && (left + clientPosition.width) <\n                (parseFloat(pageDiv.style.left) + parseFloat(pageDiv.style.width))) {\n                this.popupElement.style.left = (left) + 'px';\n            }\n            else {\n                this.popupElement.style.left = parseFloat(this.popupElement.style.left) + 'px';\n            }\n            if (top_1 > parseFloat(pageDiv.style.top) && (top_1 + clientPosition.height) <\n                (parseFloat(pageDiv.style.top) + parseFloat(pageDiv.style.height))) {\n                this.popupElement.style.top = (top_1) + 'px';\n            }\n            else {\n                this.popupElement.style.top = parseFloat(this.popupElement.style.top) + 'px';\n            }\n        }\n    };\n    Annotation.prototype.onPopupElementMoveEnd = function () {\n        this.isPopupMenuMoved = false;\n    };\n    Annotation.prototype.saveClosePopupMenu = function () {\n        if (this.textMarkupAnnotationModule) {\n            this.textMarkupAnnotationModule.saveNoteContent(this.currentAnnotPageNumber, this.noteContentElement.innerText);\n        }\n        this.closePopupMenu();\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.closePopupMenu = function () {\n        if (this.popupElement) {\n            this.popupElement.parentElement.removeChild(this.popupElement);\n            this.popupElement = null;\n            this.isPopupNoteVisible = false;\n        }\n    };\n    /**\n     * @param {any} event - event\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.showAnnotationPopup = function (event) {\n        if (this.textMarkupAnnotationModule) {\n            this.currentAnnotPageNumber = this.getEventPageNumber(event);\n            if (this.textMarkupAnnotationModule && (event.target !== (this.noteContentElement) ||\n                (event.target.contains(this.noteContentElement.childNodes[0])))) {\n                this.hidePopupNote();\n                if (!this.popupElement) {\n                    this.createTextMarkupPopup();\n                    this.popupElement.style.display = 'block';\n                    this.authorPopupElement.textContent = this.textMarkupAnnotationModule.currentTextMarkupAnnotation.author;\n                    this.modifiedDateElement.textContent = this.getProperDate(this.textMarkupAnnotationModule.currentTextMarkupAnnotation.\n                        modifiedDate);\n                    this.noteContentElement.textContent = this.textMarkupAnnotationModule.currentTextMarkupAnnotation.note;\n                    var clientPosition = this.popupElement.getBoundingClientRect();\n                    var pageDiv = document.getElementById(this.pdfViewer.element.id + '_pageDiv_' + this.currentAnnotPageNumber);\n                    var canvasPosition = pageDiv.getBoundingClientRect();\n                    var topPosition = ((event.clientY) - canvasPosition.top) + parseFloat(pageDiv.style.top);\n                    var leftPosition = (event.clientX);\n                    if ((leftPosition + clientPosition.width) > (parseFloat(pageDiv.style.left) + parseFloat(pageDiv.style.width))) {\n                        this.popupElement.style.left = (leftPosition - clientPosition.width) + 'px';\n                    }\n                    else {\n                        this.popupElement.style.left = leftPosition + 'px';\n                    }\n                    if ((topPosition + clientPosition.height) > (parseFloat(pageDiv.style.top) + parseFloat(pageDiv.style.height))) {\n                        this.popupElement.style.top = (topPosition - clientPosition.height) + 'px';\n                    }\n                    else {\n                        this.popupElement.style.top = topPosition + 'px';\n                    }\n                    this.isPopupNoteVisible = true;\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} args - args\n     * @param {boolean} isOpacity - isOpacity\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyOpacity = function (args, isOpacity) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var opacityValue = 1;\n        if (isOpacity) {\n            opacityValue = args / 100;\n        }\n        else {\n            opacityValue = args.value / 100;\n        }\n        if (currentAnnotation.opacity !== opacityValue) {\n            redoClonedObject.opacity = opacityValue;\n            this.pdfViewer.nodePropertyChange(currentAnnotation, { opacity: opacityValue });\n            if (currentAnnotation.shapeAnnotationType === 'StickyNotes') {\n                this.stickyNotesAnnotationModule.updateOpacityValue(currentAnnotation);\n            }\n            else {\n                this.modifyInCollections(currentAnnotation, 'opacity');\n            }\n            if (currentAnnotation.shapeAnnotationType === 'HandWrittenSignature' || currentAnnotation.shapeAnnotationType === 'SignatureImage' || currentAnnotation.shapeAnnotationType === 'SignatureText') {\n                this.pdfViewer.fireSignaturePropertiesChange(currentAnnotation.pageIndex, currentAnnotation.signatureName, currentAnnotation.shapeAnnotationType, false, true, false, clonedObject.opacity, redoClonedObject.opacity);\n            }\n            else {\n                this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n            }\n            this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Opacity', '', clonedObject, redoClonedObject);\n            this.pdfViewer.renderDrawing();\n        }\n    };\n    /**\n     * @param {string} currentColor - currentColor\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyFontColor = function (currentColor) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        redoClonedObject.fontColor = currentColor;\n        this.pdfViewer.nodePropertyChange(currentAnnotation, { fontColor: currentColor });\n        this.modifyInCollections(currentAnnotation, 'fontColor');\n        this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n        this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'fontColor', '', clonedObject, redoClonedObject);\n        this.pdfViewer.renderDrawing();\n    };\n    /**\n     * @param {string} currentValue - currentValue\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyFontFamily = function (currentValue) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        redoClonedObject.fontFamily = currentValue;\n        if (this.pdfViewer.freeTextSettings.enableAutoFit) {\n            this.updateFontFamilyRenderSize(currentAnnotation, currentValue);\n        }\n        else {\n            this.pdfViewer.nodePropertyChange(currentAnnotation, { fontFamily: currentValue });\n        }\n        this.modifyInCollections(currentAnnotation, 'fontFamily');\n        this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n        this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'fontFamily', '', clonedObject, redoClonedObject);\n        this.pdfViewer.renderDrawing();\n    };\n    /**\n     * @param {number} currentValue - currentValue\n     * @param {boolean} isInteracted - isInteracted\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyFontSize = function (currentValue, isInteracted) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        redoClonedObject.fontSize = currentValue;\n        var freeTextAnnotation = this.freeTextAnnotationModule;\n        var x = currentAnnotation.bounds.x;\n        var y = currentAnnotation.bounds.y;\n        currentAnnotation.fontSize = currentValue;\n        if (freeTextAnnotation && !freeTextAnnotation.isNewFreeTextAnnot && currentAnnotation.dynamicText !== '') {\n            freeTextAnnotation.addInuptElemet({ x: x, y: y }, currentAnnotation);\n            if (currentAnnotation) {\n                if (currentAnnotation.previousFontSize !== currentValue) {\n                    freeTextAnnotation.inputBoxElement.style.height = 'auto';\n                    if (isInteracted || this.isFreeTextFontsizeChanged\n                        || freeTextAnnotation.inputBoxElement.scrollHeight + 5 > currentAnnotation.bounds.height) {\n                        this.isFreeTextFontsizeChanged = false;\n                        freeTextAnnotation.inputBoxElement.style.height = freeTextAnnotation.inputBoxElement.scrollHeight + 5 + 'px';\n                    }\n                    else {\n                        freeTextAnnotation.inputBoxElement.style.height = currentAnnotation.bounds.height + 'px';\n                    }\n                }\n                var inputEleHeight = parseFloat(freeTextAnnotation.inputBoxElement.style.height);\n                var inputEleWidth = parseFloat(freeTextAnnotation.inputBoxElement.style.width);\n                var zoomFactor = this.pdfViewerBase.getZoomFactor();\n                inputEleWidth = ((inputEleWidth) / zoomFactor);\n                inputEleHeight = ((inputEleHeight) / zoomFactor);\n                var heightDiff = (inputEleHeight - currentAnnotation.bounds.height);\n                var y_1 = undefined;\n                if (heightDiff > 0) {\n                    y_1 = currentAnnotation.wrapper.offsetY + (heightDiff / 2);\n                    y_1 = y_1 > 0 ? y_1 : undefined;\n                }\n                else {\n                    heightDiff = Math.abs(heightDiff);\n                    y_1 = currentAnnotation.wrapper.offsetY - (heightDiff / 2);\n                    y_1 = y_1 > 0 ? y_1 : undefined;\n                }\n                var widthDiff = (inputEleWidth - currentAnnotation.bounds.width);\n                var x_1 = undefined;\n                if (widthDiff > 0) {\n                    x_1 = currentAnnotation.wrapper.offsetX + (widthDiff / 2);\n                    x_1 = x_1 > 0 ? x_1 : undefined;\n                }\n                else {\n                    widthDiff = Math.abs(widthDiff);\n                    x_1 = currentAnnotation.wrapper.offsetX - (widthDiff / 2);\n                }\n                currentAnnotation.bounds.width = inputEleWidth;\n                currentAnnotation.bounds.height = inputEleHeight;\n                this.pdfViewer.nodePropertyChange(currentAnnotation, { fontSize: currentValue, bounds: { width: currentAnnotation.bounds.width, height: currentAnnotation.bounds.height, y: y_1, x: x_1 } });\n                this.pdfViewer.renderSelector(currentAnnotation.pageIndex, this.pdfViewer.annotationSelectorSettings);\n                currentAnnotation.previousFontSize = currentValue;\n            }\n            this.modifyInCollections(currentAnnotation, 'fontSize');\n            this.modifyInCollections(currentAnnotation, 'bounds');\n            this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n            if (isInteracted) {\n                this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'fontSize', '', clonedObject, redoClonedObject);\n            }\n            freeTextAnnotation.inputBoxElement.blur();\n        }\n        var canvas = this.pdfViewerBase.getAnnotationCanvas('_annotationCanvas_', currentAnnotation.pageIndex);\n        this.pdfViewer.drawing.refreshCanvasDiagramLayer(canvas, currentAnnotation.pageIndex);\n    };\n    /**\n     * @param {number} fontSize - font size\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.handleFontSizeUpdate = function (fontSize) {\n        // const fontSize: number = parseFloat(size);\n        if (this.pdfViewer.selectedItems.annotations.length === 1 && fontSize) {\n            if (this.isUndoRedoAction) {\n                this.modifyFontSize(fontSize, false);\n            }\n            else {\n                this.modifyFontSize(fontSize, true);\n            }\n        }\n        else if (this.freeTextAnnotationModule) {\n            this.pdfViewer.freeTextSettings.fontSize = fontSize;\n            this.freeTextAnnotationModule.updateTextProperties();\n        }\n    };\n    /**\n     * @param {string} currentValue - currentValue\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyTextAlignment = function (currentValue) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        this.pdfViewer.nodePropertyChange(currentAnnotation, { textAlign: currentValue });\n        this.modifyInCollections(currentAnnotation, 'textAlign');\n        this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n        this.pdfViewer.renderDrawing();\n    };\n    /**\n     * @param {PdfFontModel} fontInfo - fontInfo\n     * @param {string} action - action\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyTextProperties = function (fontInfo, action) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        if (action === 'bold') {\n            redoClonedObject.font.isBold = fontInfo.isBold;\n        }\n        else if (action === 'italic') {\n            redoClonedObject.font.isItalic = fontInfo.isItalic;\n        }\n        else if (action === 'underline') {\n            redoClonedObject.font.isUnderline = fontInfo.isUnderline;\n            if (redoClonedObject.font.isUnderline && redoClonedObject.font.isStrikeout) {\n                redoClonedObject.font.isStrikeout = false;\n            }\n        }\n        else if (action === 'strikeout') {\n            redoClonedObject.font.isStrikeout = fontInfo.isStrikeout;\n            if (redoClonedObject.font.isUnderline && redoClonedObject.font.isStrikeout) {\n                redoClonedObject.font.isUnderline = false;\n            }\n        }\n        this.pdfViewer.nodePropertyChange(currentAnnotation, { font: fontInfo });\n        this.modifyInCollections(currentAnnotation, 'textPropertiesChange');\n        this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n        this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'textPropertiesChange', '', clonedObject, redoClonedObject);\n        this.pdfViewer.renderDrawing();\n    };\n    /**\n     * @param {number} thicknessValue - thicknessValue\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyThickness = function (thicknessValue) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        if (currentAnnotation.thickness !== thicknessValue) {\n            var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            redoClonedObject.thickness = thicknessValue;\n            this.pdfViewer.nodePropertyChange(currentAnnotation, { thickness: thicknessValue });\n            this.modifyInCollections(currentAnnotation, 'thickness');\n            if (currentAnnotation.shapeAnnotationType === 'HandWrittenSignature' || currentAnnotation.shapeAnnotationType === 'SignatureText' || currentAnnotation.shapeAnnotationType === 'SignatureImage') {\n                this.pdfViewer.fireSignaturePropertiesChange(currentAnnotation.pageIndex, currentAnnotation.signatureName, currentAnnotation.shapeAnnotationType, false, false, true, clonedObject.thickness, redoClonedObject.thickness);\n            }\n            else {\n                this.triggerAnnotationPropChange(currentAnnotation, false, false, true, false);\n            }\n            this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Thickness', '', clonedObject, redoClonedObject);\n            this.pdfViewer.renderDrawing();\n        }\n    };\n    /**\n     * @param {string} color - color\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyStrokeColor = function (color) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        redoClonedObject.strokeColor = color;\n        this.pdfViewer.nodePropertyChange(currentAnnotation, { strokeColor: color });\n        this.modifyInCollections(currentAnnotation, 'stroke');\n        if (currentAnnotation.shapeAnnotationType === 'HandWrittenSignature' || currentAnnotation.shapeAnnotationType === 'SignatureText' || currentAnnotation.shapeAnnotationType === 'SignatureImage') {\n            this.pdfViewer.fireSignaturePropertiesChange(currentAnnotation.pageIndex, currentAnnotation.signatureName, currentAnnotation.shapeAnnotationType, true, false, false, clonedObject.strokeColor, redoClonedObject.strokeColor);\n        }\n        else {\n            this.triggerAnnotationPropChange(currentAnnotation, false, true, false, false);\n        }\n        this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Stroke', '', clonedObject, redoClonedObject);\n        this.pdfViewer.renderDrawing();\n    };\n    /**\n     * @param {string} color -color\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyFillColor = function (color) {\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        redoClonedObject.fillColor = color;\n        this.pdfViewer.nodePropertyChange(this.pdfViewer.selectedItems.annotations[0], { fillColor: color });\n        this.modifyInCollections(currentAnnotation, 'fill');\n        this.triggerAnnotationPropChange(currentAnnotation, true, false, false, false);\n        this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Fill', '', clonedObject, redoClonedObject);\n        this.pdfViewer.renderDrawing();\n    };\n    /**\n     * @param {string} dynamicText - dynamicText\n     * @param {string} annotName - annotName\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.modifyDynamicTextValue = function (dynamicText, annotName) {\n        var currentAnnotation = null;\n        currentAnnotation = this.pdfViewer.annotations.filter(function (s) { return s.annotName === annotName; })[0];\n        if (currentAnnotation) {\n            var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            currentAnnotation.dynamicText = dynamicText;\n            redoClonedObject.dynamicText = dynamicText;\n            if (clonedObject.dynamicText === '') {\n                clonedObject.dynamicText = this.freeTextAnnotationModule.previousText;\n            }\n            this.pdfViewer.nodePropertyChange(currentAnnotation, { dynamicText: dynamicText });\n            this.pdfViewer.renderSelector(currentAnnotation.pageIndex, currentAnnotation.annotationSelectorSettings);\n            if (clonedObject.dynamicText !== redoClonedObject.dynamicText) {\n                this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'dynamicText Change', '', clonedObject, redoClonedObject);\n                this.modifyInCollections(currentAnnotation, 'dynamicText');\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.freeTextAnnotationModule) && this.freeTextAnnotationModule.previousText\n                !== currentAnnotation.dynamicText) {\n                this.triggerAnnotationPropChange(currentAnnotation, false, false, false, false, false, false, false, true, this.freeTextAnnotationModule.previousText, currentAnnotation.dynamicText);\n            }\n            this.pdfViewer.renderDrawing();\n        }\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} annotationBase - annotationBase\n     * @param {string} property - property\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.modifyInCollections = function (annotationBase, property) {\n        var returnObj;\n        if (annotationBase.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotationBase.measureType)) {\n            if (annotationBase.shapeAnnotationType === 'FreeText') {\n                returnObj = this.freeTextAnnotationModule.modifyInCollection(property, annotationBase.pageIndex, annotationBase);\n            }\n            else if (annotationBase.shapeAnnotationType === 'HandWrittenSignature' || annotationBase.shapeAnnotationType === 'SignatureText' || annotationBase.shapeAnnotationType === 'SignatureImage') {\n                returnObj = this.pdfViewerBase.signatureModule.\n                    modifySignatureCollection(property, annotationBase.pageIndex, annotationBase);\n            }\n            else if (annotationBase.shapeAnnotationType === 'Stamp' || annotationBase.shapeAnnotationType === 'Image') {\n                returnObj = this.stampAnnotationModule.modifyInCollection(property, annotationBase.pageIndex, annotationBase, null);\n            }\n            else if (annotationBase.shapeAnnotationType === 'Ink') {\n                returnObj = this.inkAnnotationModule.modifySignatureInkCollection(property, annotationBase.pageIndex, annotationBase);\n            }\n            else {\n                returnObj = this.shapeAnnotationModule.modifyInCollection(property, annotationBase.pageIndex, annotationBase, null);\n            }\n        }\n        else if (annotationBase.measureType === 'Distance' || annotationBase.measureType === 'Perimeter' ||\n            annotationBase.measureType === 'Radius' || annotationBase.measureType === 'Area' || annotationBase.measureType === 'Volume') {\n            returnObj = this.measureAnnotationModule.modifyInCollection(property, annotationBase.pageIndex, annotationBase);\n        }\n        if (this.isUndoRedoAction) {\n            this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(annotationBase, null, true);\n            if (this.isUndoAction) {\n                annotationBase.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n            }\n        }\n        else {\n            if (property !== 'bounds') {\n                this.stickyNotesAnnotationModule.updateAnnotationModifiedDate(annotationBase);\n            }\n        }\n        if (this.isUndoRedoAction && property === 'delete') {\n            this.updateAnnotationCollection(annotationBase);\n        }\n        return returnObj;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.createPropertiesWindow = function () {\n        var _this = this;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n            var elementID = this.pdfViewer.element.id;\n            var dialogDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementID + '_properties_window', className: 'e-pv-properties-window' });\n            var appearanceTab = this.createAppearanceTab();\n            this.pdfViewerBase.pageContainer.appendChild(dialogDiv);\n            this.propertiesDialog = new _syncfusion_ej2_popups__WEBPACK_IMPORTED_MODULE_3__.Dialog({\n                showCloseIcon: true, closeOnEscape: false, isModal: true, header: this.pdfViewer.localeObj.getConstant('Line Properties'),\n                target: this.pdfViewer.element, content: appearanceTab, close: function () {\n                    _this.destroyPropertiesWindow();\n                }\n            });\n            if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice || this.pdfViewer.enableDesktopMode) {\n                this.propertiesDialog.buttons = [\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('OK'), isPrimary: true }, click: this.onOkClicked.bind(this) },\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('Cancel') }, click: this.onCancelClicked.bind(this) }\n                ];\n            }\n            else {\n                this.propertiesDialog.buttons = [\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('Cancel') }, click: this.onCancelClicked.bind(this) },\n                    { buttonModel: { content: this.pdfViewer.localeObj.getConstant('OK'), isPrimary: true }, click: this.onOkClicked.bind(this) }\n                ];\n            }\n            if (this.pdfViewer.enableRtl) {\n                this.propertiesDialog.enableRtl = true;\n            }\n            this.propertiesDialog.appendTo(dialogDiv);\n            if (this.pdfViewer.selectedItems.annotations[0] && this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Line') {\n                var fillColor = document.getElementById(this.pdfViewer.element.id + '_properties_fill_color');\n                fillColor.disabled = true;\n            }\n            this.startArrowDropDown.content = this.\n                createContent(this.getArrowString(this.pdfViewer.selectedItems.annotations[0].sourceDecoraterShapes)).outerHTML;\n            this.endArrowDropDown.content = this.\n                createContent(this.getArrowString(this.pdfViewer.selectedItems.annotations[0].taregetDecoraterShapes)).outerHTML;\n            this.thicknessBox.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeWidth;\n            this.fillColorPicker.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.fill;\n            this.refreshColorPicker(this.fillColorPicker);\n            this.strokeColorPicker.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeColor;\n            this.refreshColorPicker(this.strokeColorPicker);\n            this.updateColorInIcon(this.fillDropDown.element, this.fillColorPicker.value);\n            this.updateColorInIcon(this.strokeDropDown.element, this.strokeColorPicker.value);\n            this.opacitySlider.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.opacity * 100;\n            this.updateOpacityIndicator();\n            if (parseInt(this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeDashArray, 10) >= 3) {\n                this.lineStyleDropDown.content = this.createDropDownContent('dashed').outerHTML;\n            }\n            else if (this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeDashArray === '2') {\n                this.lineStyleDropDown.content = this.createDropDownContent('dotted').outerHTML;\n            }\n            else if (this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeDashArray === '0') {\n                this.lineStyleDropDown.content = this.createDropDownContent('solid').outerHTML;\n            }\n            this.selectedLineStyle = this.pdfViewer.selectedItems.annotations[0].borderStyle;\n            this.selectedLineDashArray = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeDashArray;\n            if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Distance') {\n                this.leaderLengthBox.value = this.pdfViewer.selectedItems.annotations[0].leaderHeight;\n            }\n        }\n        else {\n            var opacityValue = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.opacity * 100;\n            var lineStartElement = this.getArrowString(this.pdfViewer.selectedItems.annotations[0].sourceDecoraterShapes);\n            var lineEndElement = this.getArrowString(this.pdfViewer.selectedItems.annotations[0].taregetDecoraterShapes);\n            var lineStyleElement = void 0;\n            if (parseInt(this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeDashArray, 10) >= 3) {\n                lineStyleElement = 'Dashed';\n            }\n            else if (this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeDashArray === '2') {\n                lineStyleElement = 'Dotted';\n            }\n            else if (this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeDashArray === '0') {\n                lineStyleElement = 'Solid';\n            }\n            this.pdfViewer._dotnetInstance.invokeMethodAsync('OpenPropertiesDialog', opacityValue, lineStartElement, lineEndElement, lineStyleElement);\n        }\n    };\n    //Commented unused method - 878987\n    // private updatePropertiesWindowInBlazor(): void {\n    //     const thicknessElement: any = document.querySelector('#' + this.pdfViewer.element.id + '_line_thickness');\n    //     const fillColorElement: any = document.querySelector('#' + this.pdfViewer.element.id + '_properties_fill_color_button');\n    //     const strokeColorElement: any = document.querySelector('#' + this.pdfViewer.element.id + '_properties_stroke_color_button');\n    //     const leaderLengthElement: any = document.querySelector('#' + this.pdfViewer.element.id + '_properties_leader_length');\n    //     thicknessElement.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeWidth;\n    //     fillColorElement.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.fill;\n    //     strokeColorElement.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeColor;\n    //     this.onStrokeColorChange(strokeColorElement.value);\n    //     this.onFillColorChange(fillColorElement.value);\n    //     if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Distance') {\n    //         leaderLengthElement.value = parseInt(this.pdfViewer.selectedItems.annotations[0].leaderHeight.toString(), 10);\n    //     }\n    // }\n    Annotation.prototype.destroyPropertiesWindow = function () {\n        if (this.strokeColorPicker) {\n            this.strokeColorPicker.destroy();\n            this.strokeColorPicker = null;\n        }\n        if (this.fillColorPicker) {\n            this.fillColorPicker.destroy();\n            this.fillColorPicker = null;\n        }\n        if (this.endArrowDropDown) {\n            this.endArrowDropDown.destroy();\n            this.endArrowDropDown = null;\n        }\n        if (this.startArrowDropDown) {\n            this.startArrowDropDown.destroy();\n            this.startArrowDropDown = null;\n        }\n        if (this.opacitySlider) {\n            this.opacitySlider.destroy();\n            this.opacitySlider = null;\n        }\n        if (this.thicknessBox) {\n            this.thicknessBox.destroy();\n            this.thicknessBox = null;\n        }\n        if (this.lineStyleDropDown) {\n            this.lineStyleDropDown.destroy();\n            this.lineStyleDropDown = null;\n        }\n        if (this.leaderLengthBox) {\n            this.leaderLengthBox.destroy();\n            this.leaderLengthBox = null;\n        }\n        if (this.propertiesDialog) {\n            this.propertiesDialog.destroy();\n            this.propertiesDialog = null;\n        }\n        var dialogElement = this.pdfViewerBase.getElement('_properties_window');\n        if (dialogElement) {\n            dialogElement.parentElement.removeChild(dialogElement);\n        }\n    };\n    Annotation.prototype.refreshColorPicker = function (colorPick) {\n        colorPick.setProperties({ 'value': colorPick.value }, true);\n        colorPick.refresh();\n    };\n    Annotation.prototype.createAppearanceTab = function () {\n        var _this = this;\n        var elementID = this.pdfViewer.element.id;\n        var items = [{ text: this.pdfViewer.localeObj.getConstant('None') }, { text: this.pdfViewer.localeObj.getConstant('Open Arrow') }, { text: this.pdfViewer.localeObj.getConstant('Closed Arrow') },\n            { text: this.pdfViewer.localeObj.getConstant('Round Arrow') }, { text: this.pdfViewer.localeObj.getConstant('Square Arrow') }, { text: this.pdfViewer.localeObj.getConstant('Diamond Arrow') }];\n        var appearanceDiv = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: elementID + '_properties_appearance' });\n        var lineStyleContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-properties-line-style-prop' });\n        appearanceDiv.appendChild(lineStyleContainer);\n        var lineHeadStartElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('Start Arrow'), lineStyleContainer, 'text', 'button', true, 'e-pv-properties-line-start', elementID + '_properties_line_start');\n        this.startArrowDropDown = new _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__.DropDownButton({ items: items, cssClass: 'e-pv-properties-line-start', select: this.onStartArrowHeadStyleSelect.bind(this) }, lineHeadStartElement);\n        var lineHeadEndElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('End Arrow'), lineStyleContainer, 'text', 'button', true, 'e-pv-properties-line-end', elementID + '_properties_line_end');\n        var borderStyleContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-properties-border-style' });\n        appearanceDiv.appendChild(borderStyleContainer);\n        this.endArrowDropDown = new _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__.DropDownButton({ items: items, cssClass: 'e-pv-properties-line-end', select: this.onEndArrowHeadStyleSelect.bind(this) }, lineHeadEndElement);\n        var lineStyleElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('Line Style'), borderStyleContainer, 'text', 'button', true, 'e-pv-properties-line-style', elementID + '_properties_line_style');\n        var dropDownTarget = this.createStyleList();\n        this.lineStyleDropDown = new _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__.DropDownButton({ cssClass: 'e-pv-properties-line-style', target: dropDownTarget }, lineStyleElement);\n        var thicknessElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('Line Thickness'), borderStyleContainer, 'text', 'input', true, 'e-pv-properties-line-thickness', elementID + '_properties_thickness');\n        this.thicknessBox = new _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_2__.NumericTextBox({ value: 0, format: '## pt', cssClass: 'e-pv-properties-line-thickness', min: 0, max: 12 }, thicknessElement);\n        var colorStyleContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-properties-color-style' });\n        appearanceDiv.appendChild(colorStyleContainer);\n        var fillColorElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('Fill Color'), colorStyleContainer, 'color', 'button', true, 'e-pv-properties-line-fill-color', elementID + '_properties_fill_color');\n        this.fillColorPicker = this.createColorPicker(elementID + '_properties_fill_color', true);\n        this.fillColorPicker.change = function (args) {\n            var currentColor = (args.currentValue.hex === '') ? '#ffffff00' : args.currentValue.hex;\n            _this.fillDropDown.toggle();\n            _this.updateColorInIcon(_this.fillDropDown.element, currentColor);\n        };\n        this.fillDropDown = this.createDropDownButton(fillColorElement, 'e-pv-properties-fill-color-icon', this.fillColorPicker.element.parentElement);\n        this.fillDropDown.beforeOpen = this.onFillDropDownBeforeOpen.bind(this);\n        this.fillDropDown.open = function () {\n            _this.fillColorPicker.refresh();\n        };\n        var strokeColorElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('Line Color'), colorStyleContainer, 'color', 'button', true, 'e-pv-properties-line-stroke-color', elementID + '_properties_stroke_color');\n        this.strokeColorPicker = this.createColorPicker(elementID + '_properties_stroke_color', false);\n        this.strokeColorPicker.change = function (args) {\n            var currentColor = (args.currentValue.hex === '') ? '#ffffff00' : args.currentValue.hex;\n            _this.strokeDropDown.toggle();\n            _this.updateColorInIcon(_this.strokeDropDown.element, currentColor);\n        };\n        this.strokeDropDown = this.createDropDownButton(strokeColorElement, 'e-pv-properties-stroke-color-icon', this.strokeColorPicker.element.parentElement);\n        this.strokeDropDown.beforeOpen = this.onStrokeDropDownBeforeOpen.bind(this);\n        this.strokeDropDown.open = function () {\n            _this.strokeColorPicker.refresh();\n        };\n        var opacityContainer = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-properties-opacity-style' });\n        appearanceDiv.appendChild(opacityContainer);\n        var opacityElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('Opacity'), opacityContainer, '', 'div', true, 'e-pv-properties-line-opacity', elementID + '_properties_opacity');\n        this.opacitySlider = new _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_2__.Slider({\n            type: 'MinRange', max: 100, min: 0, cssClass: 'e-pv-properties-line-opacity', change: function () {\n                _this.updateOpacityIndicator();\n            }\n        }, opacityElement);\n        if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Distance') {\n            var lineLengthElement = this.createInputElement(this.pdfViewer.localeObj.getConstant('Leader Length'), opacityContainer, 'text', 'input', true, 'e-pv-properties-line-leader-length', elementID + '_properties_leader_length');\n            this.leaderLengthBox = new _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_2__.NumericTextBox({ value: 0, format: '## pt', cssClass: 'e-pv-properties-line-leader-length', min: 0, max: 100 }, lineLengthElement);\n        }\n        return appearanceDiv;\n    };\n    Annotation.prototype.createContent = function (text) {\n        var divElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-properties-line-style-content' });\n        divElement.textContent = text;\n        return divElement;\n    };\n    Annotation.prototype.onStrokeDropDownBeforeOpen = function () {\n        if (this.pdfViewer.selectedItems.annotations.length === 1) {\n            this.strokeColorPicker.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeColor;\n        }\n        this.strokeColorPicker.refresh();\n    };\n    Annotation.prototype.onFillDropDownBeforeOpen = function () {\n        if (this.pdfViewer.selectedItems.annotations.length === 1) {\n            this.fillColorPicker.value = this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.strokeColor;\n        }\n        this.fillColorPicker.refresh();\n    };\n    Annotation.prototype.createStyleList = function () {\n        var _this = this;\n        var ulElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('ul');\n        document.body.appendChild(ulElement);\n        var solidLi = this.createListForStyle('solid');\n        solidLi.addEventListener('click', function () {\n            _this.setThickness('0', 'solid');\n        });\n        ulElement.appendChild(solidLi);\n        var dottedLi = this.createListForStyle('dotted');\n        dottedLi.addEventListener('click', function () {\n            _this.setThickness('2', 'dotted');\n        });\n        ulElement.appendChild(dottedLi);\n        var dashedLi = this.createListForStyle('dashed');\n        dashedLi.addEventListener('click', function () {\n            _this.setThickness('3', 'dashed');\n        });\n        ulElement.appendChild(dashedLi);\n        return ulElement;\n    };\n    Annotation.prototype.createColorPicker = function (idString, isNoColor) {\n        var inputElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('input', { id: idString + '_target' });\n        document.body.appendChild(inputElement);\n        var colorPicker = new _syncfusion_ej2_inputs__WEBPACK_IMPORTED_MODULE_2__.ColorPicker({\n            inline: true, mode: 'Palette', enableOpacity: false, value: '#000000', showButtons: false, modeSwitcher: false,\n            noColor: isNoColor\n        });\n        if (this.pdfViewer.enableRtl) {\n            colorPicker.enableRtl = true;\n        }\n        colorPicker.appendTo(inputElement);\n        return colorPicker;\n    };\n    Annotation.prototype.createDropDownButton = function (element, iconClass, target) {\n        var dropDownButton = new _syncfusion_ej2_splitbuttons__WEBPACK_IMPORTED_MODULE_4__.DropDownButton({ iconCss: iconClass + ' e-pv-icon', target: target });\n        if (this.pdfViewer.enableRtl) {\n            dropDownButton.enableRtl = true;\n        }\n        dropDownButton.appendTo(element);\n        return dropDownButton;\n    };\n    Annotation.prototype.updateColorInIcon = function (element, color) {\n        element.childNodes[0].style.borderBottomColor = color;\n    };\n    /**\n     * @param {string} color - color\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.onFillColorChange = function (color) {\n        var colorElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_fill_color_button');\n        if (color !== 'transparent') {\n            colorElement.children[0].style.borderBottomColor = color;\n        }\n    };\n    /**\n     * @param {string} color - color\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.onStrokeColorChange = function (color) {\n        var colorElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_stroke_color_button');\n        if (color !== 'transparent') {\n            colorElement.children[0].style.borderBottomColor = color;\n        }\n    };\n    Annotation.prototype.setThickness = function (value, style, isBlazor) {\n        if (!isBlazor) {\n            this.lineStyleDropDown.content = this.createDropDownContent(style).outerHTML;\n        }\n        this.selectedLineDashArray = value;\n        if (value === '0') {\n            this.selectedLineStyle = 'Solid';\n        }\n        else if (value === '2' || value === '3') {\n            this.selectedLineStyle = 'Dashed';\n        }\n    };\n    Annotation.prototype.createDropDownContent = function (style) {\n        var divElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-line-styles-content-container' });\n        var spanElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { className: 'e-pv-line-styles-content', styles: 'border-bottom-style:' + style });\n        divElement.appendChild(spanElement);\n        return divElement;\n    };\n    Annotation.prototype.createListForStyle = function (style) {\n        var liElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('li', { className: 'e-menu-item' });\n        var divElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { className: 'e-pv-line-styles-container' });\n        var spanElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { className: 'e-pv-line-styles-item', styles: 'border-bottom-style:' + style });\n        divElement.appendChild(spanElement);\n        liElement.appendChild(divElement);\n        return liElement;\n    };\n    Annotation.prototype.onStartArrowHeadStyleSelect = function (args) {\n        this.startArrowDropDown.content = this.createContent(args.item.text).outerHTML;\n    };\n    Annotation.prototype.onEndArrowHeadStyleSelect = function (args) {\n        this.endArrowDropDown.content = this.createContent(args.item.text).outerHTML;\n    };\n    Annotation.prototype.createInputElement = function (labelText, parentElement, inputType, input, isLabelNeeded, className, idString) {\n        var container = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: idString + '_container', className: className + '-container' });\n        if (isLabelNeeded) {\n            var label = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('div', { id: idString + '_label', className: className + '-label' });\n            label.textContent = labelText;\n            container.appendChild(label);\n        }\n        if (this.pdfViewer.localeObj.getConstant('Opacity') === labelText) {\n            this.opacityIndicator = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('span', { className: 'e-pv-properties-opacity-indicator' });\n            container.appendChild(this.opacityIndicator);\n        }\n        var textBoxInput = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)(input, { id: idString });\n        if (input === 'input') {\n            textBoxInput.type = inputType;\n        }\n        container.appendChild(textBoxInput);\n        parentElement.appendChild(container);\n        return textBoxInput;\n    };\n    Annotation.prototype.updateOpacityIndicator = function () {\n        this.opacityIndicator.textContent = this.opacitySlider.value + '%';\n    };\n    /**\n     * @param {number} opacityValue - opacityValue\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.onOkClicked = function (opacityValue) {\n        var startArrow;\n        var endArrow;\n        var thickness;\n        var strokeColor;\n        var fillColor;\n        var opacity;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n            startArrow = this.getArrowTypeFromDropDown(this.startArrowDropDown.content);\n            endArrow = this.getArrowTypeFromDropDown(this.endArrowDropDown.content);\n            thickness = this.thicknessBox.value;\n            strokeColor = this.strokeColorPicker.getValue(this.strokeColorPicker.value, 'hex');\n            strokeColor = (strokeColor === '') ? '#ffffff00' : strokeColor;\n            fillColor = this.fillColorPicker.getValue(this.fillColorPicker.value, 'hex');\n            fillColor = (fillColor === '' || fillColor === '#transp' || this.fillColorPicker.value === '#ffffff00') ? '#ffffff00' : fillColor;\n            opacity = this.opacitySlider.value / 100;\n        }\n        else {\n            var lineStartElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_line_start');\n            var lineEndElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_line_end');\n            var thicknessElement = document.querySelector('#' + this.pdfViewer.element.id + '_line_thickness');\n            var lineStyleElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_style');\n            var fillColorElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_fill_color_button');\n            var strokeColorElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_stroke_color_button');\n            var opacityElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_opacity');\n            startArrow = this.getArrowTypeFromDropDown(lineStartElement.value, true);\n            endArrow = this.getArrowTypeFromDropDown(lineEndElement.value, true);\n            thickness = parseInt(thicknessElement.value, 10);\n            strokeColor = this.getValue(strokeColorElement.children[0].style.borderBottomColor, 'hex');\n            strokeColor = (strokeColor === '') ? '#ffffff00' : strokeColor;\n            fillColor = this.getValue(fillColorElement.children[0].style.borderBottomColor, 'hex');\n            fillColor = (fillColor === '') ? '#ffffff00' : fillColor;\n            if (opacityValue) {\n                opacity = (opacityValue) / 100;\n            }\n            else {\n                opacity = opacityElement.value / 100;\n            }\n            if (lineStyleElement.value) {\n                if (lineStyleElement.value === 'Solid') {\n                    this.setThickness('0', 'solid', true);\n                }\n                else if (lineStyleElement.value === 'Dotted') {\n                    this.setThickness('2', 'dotted', true);\n                }\n                else if (lineStyleElement.value === 'Dashed') {\n                    this.setThickness('3', 'dashed', true);\n                }\n            }\n        }\n        var currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n        var newNode = {};\n        var isColorChanged = false;\n        var isStrokeColorChanged = false;\n        var isThicknessChanged = false;\n        var isOpacityChanged = false;\n        var isLineHeadStartStyleChanged = false;\n        var isLineHeadEndStyleChanged = false;\n        var isBorderDashArrayChanged = false;\n        if (startArrow !== currentAnnotation.sourceDecoraterShapes) {\n            newNode.sourceDecoraterShapes = startArrow;\n            redoClonedObject.lineHeadStart = this.getArrowString(startArrow);\n            isLineHeadStartStyleChanged = true;\n        }\n        if (endArrow !== currentAnnotation.taregetDecoraterShapes) {\n            newNode.taregetDecoraterShapes = endArrow;\n            redoClonedObject.lineHeadEnd = this.getArrowString(endArrow);\n            isLineHeadEndStyleChanged = true;\n        }\n        if (thickness !== currentAnnotation.wrapper.children[0].style.strokeWidth) {\n            newNode.thickness = thickness;\n            redoClonedObject.thickness = thickness;\n            isThicknessChanged = true;\n        }\n        if (strokeColor !== currentAnnotation.wrapper.children[0].style.strokeColor) {\n            newNode.strokeColor = strokeColor;\n            redoClonedObject.strokeColor = strokeColor;\n            isStrokeColorChanged = true;\n        }\n        if (fillColor !== currentAnnotation.wrapper.children[0].style.fill) {\n            newNode.fillColor = fillColor;\n            redoClonedObject.fillColor = fillColor;\n            isColorChanged = true;\n        }\n        if (opacity !== currentAnnotation.wrapper.children[0].style.opacity) {\n            newNode.opacity = opacity;\n            redoClonedObject.opacity = opacity;\n            isOpacityChanged = true;\n        }\n        if (this.selectedLineDashArray !== currentAnnotation.wrapper.children[0].style.strokeDashArray) {\n            newNode.borderDashArray = this.selectedLineDashArray;\n            newNode.borderStyle = this.selectedLineStyle;\n            redoClonedObject.borderDashArray = newNode.borderDashArray;\n            redoClonedObject.borderStyle = newNode.borderStyle;\n            isBorderDashArrayChanged = true;\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n            if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Distance' && this.leaderLengthBox.value !== this.pdfViewer.selectedItems.annotations[0].leaderHeight) {\n                newNode.leaderHeight = this.leaderLengthBox.value;\n            }\n        }\n        else {\n            var leaderLengthElement = document.querySelector('#' + this.pdfViewer.element.id + '_properties_leader_length');\n            if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Distance' && parseInt(leaderLengthElement.value, 10) !== this.pdfViewer.selectedItems.annotations[0].leaderHeight) {\n                newNode.leaderHeight = parseInt(leaderLengthElement.value, 10);\n            }\n        }\n        this.pdfViewer.nodePropertyChange(this.pdfViewer.selectedItems.annotations[0], newNode);\n        this.pdfViewer.selectedItems.annotations[0].wrapper.children[0].style.fill = fillColor;\n        this.triggerAnnotationPropChange(this.pdfViewer.selectedItems.annotations[0], isColorChanged, isStrokeColorChanged, isThicknessChanged, isOpacityChanged, isLineHeadStartStyleChanged, isLineHeadEndStyleChanged, isBorderDashArrayChanged);\n        this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'thickness');\n        this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'stroke');\n        this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'fill');\n        this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'opacity');\n        this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'dashArray');\n        this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'startArrow');\n        this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'endArrow');\n        if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Distance') {\n            this.modifyInCollections(this.pdfViewer.selectedItems.annotations[0], 'leaderLength');\n        }\n        this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Line properties change', '', clonedObject, redoClonedObject);\n        this.renderAnnotations(currentAnnotation.pageIndex, null, null, null);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n            this.propertiesDialog.hide();\n        }\n    };\n    Annotation.prototype.onCancelClicked = function () {\n        this.propertiesDialog.hide();\n    };\n    Annotation.prototype.getArrowTypeFromDropDown = function (arrowType, isBlazor) {\n        if (!isBlazor) {\n            arrowType = arrowType.split('</div>')[0].split('\">')[1];\n        }\n        var arrow = 'None';\n        switch (arrowType) {\n            case this.pdfViewer.localeObj.getConstant('None'):\n                arrow = 'None';\n                break;\n            case this.pdfViewer.localeObj.getConstant('Open Arrow'):\n                arrow = 'OpenArrow';\n                break;\n            case this.pdfViewer.localeObj.getConstant('Closed Arrow'):\n                arrow = 'Arrow';\n                break;\n            case this.pdfViewer.localeObj.getConstant('Round Arrow'):\n                arrow = 'Circle';\n                break;\n            case this.pdfViewer.localeObj.getConstant('Square Arrow'):\n                arrow = 'Square';\n                break;\n            case this.pdfViewer.localeObj.getConstant('Diamond Arrow'):\n                arrow = 'Diamond';\n                break;\n            case this.pdfViewer.localeObj.getConstant('Butt'):\n                arrow = 'Butt';\n                break;\n        }\n        return arrow;\n    };\n    /**\n     * @param {DecoratorShapes} arrow - arrow\n     * @private\n     * @returns {string}- string\n     */\n    Annotation.prototype.getArrowString = function (arrow) {\n        var arrowType = this.pdfViewer.localeObj.getConstant('None');\n        switch (arrow) {\n            case 'Arrow':\n                arrowType = this.pdfViewer.localeObj.getConstant('Closed');\n                break;\n            case 'OpenArrow':\n                arrowType = this.pdfViewer.localeObj.getConstant('Open Arrow');\n                break;\n            case 'Circle':\n                arrowType = this.pdfViewer.localeObj.getConstant('Round');\n                break;\n            case 'None':\n            case 'Square':\n            case 'Diamond':\n                arrowType = this.pdfViewer.localeObj.getConstant(arrow);\n                break;\n            case 'Butt':\n                arrowType = this.pdfViewer.localeObj.getConstant('Butt');\n                break;\n        }\n        return arrowType;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.onAnnotationMouseUp = function () {\n        if (this.pdfViewer.selectedItems.annotations.length !== 0) {\n            if (this.pdfViewer.toolbar && this.pdfViewer.toolbar.annotationToolbarModule) {\n                this.enableBasedOnType();\n                this.pdfViewer.toolbar.annotationToolbarModule.selectAnnotationDeleteItem(true);\n                if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice) {\n                    this.pdfViewer.toolbar.annotationToolbarModule.updateAnnnotationPropertyItems();\n                }\n            }\n            if (this.pdfViewer.textSelectionModule && !this.pdfViewer.textSelectionModule.isTextSelection) {\n                this.pdfViewerBase.disableTextSelectionMode();\n            }\n        }\n        else {\n            if (this.pdfViewer.textSelectionModule && !this.pdfViewerBase.isPanMode && !this.pdfViewer.designerMode) {\n                this.pdfViewer.textSelectionModule.enableTextSelectionMode();\n            }\n            if (this.pdfViewer.toolbar && this.pdfViewer.toolbar.annotationToolbarModule &&\n                (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice || this.pdfViewer.enableDesktopMode)) {\n                var isSkip = this.pdfViewer.toolbar.annotationToolbarModule.inkAnnotationSelected;\n                if (this.pdfViewer.annotation.freeTextAnnotationModule &&\n                    !this.pdfViewer.annotation.freeTextAnnotationModule.isInuptBoxInFocus && !isSkip) {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableAnnotationPropertiesTools(false);\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableFreeTextAnnotationPropertiesTools(false);\n                }\n                this.pdfViewer.toolbar.annotationToolbarModule.updateAnnnotationPropertyItems();\n                this.pdfViewer.toolbar.annotationToolbarModule.selectAnnotationDeleteItem(false);\n            }\n        }\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} pdfAnnotationBase - pdfAnnotationBase\n     * @param {any} event - event\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.onShapesMouseup = function (pdfAnnotationBase, event) {\n        pdfAnnotationBase = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.selectedItems.annotations[0]) ?\n            this.pdfViewer.selectedItems.annotations[0] : pdfAnnotationBase;\n        var isToolMoved = false;\n        if (this.pdfViewerBase.prevPosition.x !== this.pdfViewerBase.currentPosition.x ||\n            this.pdfViewerBase.prevPosition.y !== this.pdfViewerBase.currentPosition.y) {\n            isToolMoved = true;\n        }\n        if (pdfAnnotationBase) {\n            if (this.textMarkupAnnotationModule && this.textMarkupAnnotationModule.currentTextMarkupAnnotation) {\n                this.textMarkupAnnotationModule.currentTextMarkupAnnotation = null;\n                this.textMarkupAnnotationModule.selectTextMarkupCurrentPage = null;\n            }\n            if ((this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.NodeDrawingTool ||\n                this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.LineTool) && !this.pdfViewerBase.tool.dragging) {\n                var setting = {\n                    opacity: pdfAnnotationBase.opacity, fillColor: pdfAnnotationBase.fillColor, strokeColor: pdfAnnotationBase.strokeColor,\n                    thickness: pdfAnnotationBase.thickness, author: pdfAnnotationBase.author, subject: pdfAnnotationBase.subject,\n                    modifiedDate: pdfAnnotationBase.modifiedDate\n                };\n                var index = this.getAnnotationIndex(pdfAnnotationBase.pageIndex, pdfAnnotationBase.id);\n                if (this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.LineTool) {\n                    setting.lineHeadStartStyle = this.getArrowString(pdfAnnotationBase.sourceDecoraterShapes);\n                    setting.lineHeadEndStyle = this.getArrowString(pdfAnnotationBase.taregetDecoraterShapes);\n                    setting.borderDashArray = pdfAnnotationBase.borderDashArray;\n                }\n                if (!this.pdfViewerBase.isAnnotationAdded || pdfAnnotationBase.measureType === 'Distance') {\n                    if (pdfAnnotationBase.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(pdfAnnotationBase.measureType)) {\n                        this.shapeAnnotationModule.\n                            renderShapeAnnotations(pdfAnnotationBase, this.pdfViewer.annotation.getEventPageNumber(event));\n                    }\n                    else if (pdfAnnotationBase.measureType === 'Distance' || pdfAnnotationBase.measureType === 'Perimeter' ||\n                        pdfAnnotationBase.measureType === 'Radius') {\n                        this.measureAnnotationModule.\n                            renderMeasureShapeAnnotations(pdfAnnotationBase, this.pdfViewer.annotation.getEventPageNumber(event));\n                    }\n                }\n                this.pdfViewerBase.updateDocumentEditedProperty(true);\n            }\n            else if (this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.MoveTool || this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.ResizeTool) {\n                if (isToolMoved) {\n                    this.pdfViewerBase.updateDocumentEditedProperty(true);\n                }\n                if (pdfAnnotationBase.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(pdfAnnotationBase.measureType)) {\n                    if (pdfAnnotationBase.shapeAnnotationType === 'FreeText') {\n                        this.pdfViewer.annotation.freeTextAnnotationModule.modifyInCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase);\n                    }\n                    else if (pdfAnnotationBase.shapeAnnotationType === 'HandWrittenSignature' || pdfAnnotationBase.shapeAnnotationType === 'SignatureImage' || pdfAnnotationBase.shapeAnnotationType === 'SignatureText') {\n                        this.pdfViewerBase.signatureModule.modifySignatureCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase);\n                    }\n                    else if (pdfAnnotationBase.shapeAnnotationType === 'Ink') {\n                        this.inkAnnotationModule.modifySignatureInkCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase);\n                    }\n                    else if (pdfAnnotationBase.shapeAnnotationType === 'Stamp' || pdfAnnotationBase.shapeAnnotationType === 'Image') {\n                        this.stampAnnotationModule.modifyInCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase, isToolMoved);\n                    }\n                    else {\n                        this.pdfViewer.annotation.shapeAnnotationModule.modifyInCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase, isToolMoved);\n                    }\n                }\n                else if (pdfAnnotationBase.measureType === 'Distance' || pdfAnnotationBase.measureType === 'Perimeter' || pdfAnnotationBase.measureType === 'Radius' || pdfAnnotationBase.measureType === 'Area' || pdfAnnotationBase.measureType === 'Volume') {\n                    this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase);\n                }\n                if (this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.ResizeTool) {\n                    if (!pdfAnnotationBase.formFieldAnnotationType) {\n                        this.triggerAnnotationResize(pdfAnnotationBase);\n                    }\n                }\n                if (this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.MoveTool) {\n                    if (this.pdfViewerBase.action !== 'Select') {\n                        if (!pdfAnnotationBase.formFieldAnnotationType) {\n                            this.triggerAnnotationMove(pdfAnnotationBase);\n                        }\n                    }\n                }\n            }\n            else if (this.pdfViewerBase.tool instanceof _drawing_tools__WEBPACK_IMPORTED_MODULE_7__.ConnectTool) {\n                if (isToolMoved) {\n                    this.pdfViewerBase.updateDocumentEditedProperty(true);\n                }\n                if (pdfAnnotationBase.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(pdfAnnotationBase.measureType)) {\n                    if ((pdfAnnotationBase.shapeAnnotationType === 'Line' || pdfAnnotationBase.shapeAnnotationType === 'LineWidthArrowHead' || pdfAnnotationBase.shapeAnnotationType === 'Polygon')) {\n                        this.pdfViewer.annotation.shapeAnnotationModule.modifyInCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase, isToolMoved);\n                    }\n                }\n                else if (pdfAnnotationBase.measureType === 'Distance' || pdfAnnotationBase.measureType === 'Perimeter' || pdfAnnotationBase.measureType === 'Area' || pdfAnnotationBase.measureType === 'Volume') {\n                    if (pdfAnnotationBase.measureType === 'Distance') {\n                        this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('leaderLength', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase);\n                    }\n                    this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('bounds', this.pdfViewer.annotation.getEventPageNumber(event), pdfAnnotationBase);\n                }\n                this.triggerAnnotationResize(pdfAnnotationBase);\n            }\n            if (this.pdfViewerBase.navigationPane && this.pdfViewerBase.navigationPane.annotationMenuObj && this.pdfViewer.isSignatureEditable && (pdfAnnotationBase.shapeAnnotationType === 'HandWrittenSignature' || pdfAnnotationBase.shapeAnnotationType === 'SignatureText' || pdfAnnotationBase.shapeAnnotationType === 'SignatureImage')) {\n                this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export Annotations')], true);\n                this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export XFDF')], true);\n            }\n            if (this.pdfViewer.toolbarModule) {\n                if (this.pdfViewer.toolbarModule.annotationToolbarModule && this.pdfViewer.enableAnnotationToolbar) {\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.clearTextMarkupMode();\n                    if (pdfAnnotationBase.measureType === '' || (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(pdfAnnotationBase.measureType)) {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.clearMeasureMode();\n                    }\n                    else if (pdfAnnotationBase.measureType === 'Distance' || pdfAnnotationBase.measureType === 'Perimeter' || pdfAnnotationBase.measureType === 'Area' || pdfAnnotationBase.measureType === 'Volume' || pdfAnnotationBase.measureType === 'Radius') {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.clearShapeMode();\n                    }\n                    if (this.pdfViewer.selectedItems.annotations.length === 1 &&\n                        this.pdfViewer.selectedItems.annotations[0].formFieldAnnotationType === null) {\n                        this.pdfViewer.toolbarModule.annotationToolbarModule.enableAnnotationPropertiesTools(true);\n                    }\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                        if (this.pdfViewer.selectedItems.annotations.length === 1 && !this.pdfViewer.designerMode) {\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.selectAnnotationDeleteItem(true);\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.setCurrentColorInPicker();\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.isToolbarHidden = true;\n                            // eslint-disable-next-line\n                            if (!this.pdfViewer.formDesignerModule && pdfAnnotationBase.id != '' && pdfAnnotationBase.id != null && pdfAnnotationBase.id.slice(0, 4) != 'sign') {\n                                var id = document.getElementById(pdfAnnotationBase.id);\n                                var isFieldReadOnly = id && id.disabled;\n                                if (!isFieldReadOnly) {\n                                    this.pdfViewer.toolbarModule.annotationToolbarModule.\n                                        showAnnotationToolbar(this.pdfViewer.toolbarModule.annotationItem);\n                                }\n                                else if (this.pdfViewer.annotation && isFieldReadOnly) {\n                                    this.pdfViewer.annotation.clearSelection();\n                                }\n                            }\n                            else {\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.\n                                    showAnnotationToolbar(this.pdfViewer.toolbarModule.annotationItem);\n                            }\n                            if (this.pdfViewer.isAnnotationToolbarVisible && this.pdfViewer.isFormDesignerToolbarVisible) {\n                                var formDesignerMainDiv = document.getElementById(this.pdfViewer.element.id + '_formdesigner_toolbar');\n                                formDesignerMainDiv.style.display = 'none';\n                                if (this.pdfViewer.toolbarModule) {\n                                    this.pdfViewer.toolbarModule.formDesignerToolbarModule.isToolbarHidden = false;\n                                    this.pdfViewer.toolbarModule.formDesignerToolbarModule.\n                                        showFormDesignerToolbar(this.pdfViewer.toolbarModule.formDesignerItem);\n                                    this.pdfViewer.toolbarModule.annotationToolbarModule.adjustViewer(true);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} pdfAnnotationBase - pdfAnnotationBase\n     * @param {boolean} isNewlyAdded - isNewlyAdded\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.updateCalibrateValues = function (pdfAnnotationBase, isNewlyAdded) {\n        if (pdfAnnotationBase.measureType === 'Distance') {\n            pdfAnnotationBase.notes = (0,_drawing_connector_util__WEBPACK_IMPORTED_MODULE_8__.updateDistanceLabel)(pdfAnnotationBase, pdfAnnotationBase.vertexPoints, this.measureAnnotationModule);\n            if (pdfAnnotationBase.enableShapeLabel === true) {\n                pdfAnnotationBase.labelContent = pdfAnnotationBase.notes;\n            }\n            this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('notes', pdfAnnotationBase.pageIndex, pdfAnnotationBase, isNewlyAdded);\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.addTextToComments(pdfAnnotationBase.annotName, pdfAnnotationBase.notes);\n            this.renderAnnotations(pdfAnnotationBase.pageIndex, null, null, null, null);\n        }\n        else if (pdfAnnotationBase.measureType === 'Radius') {\n            pdfAnnotationBase.notes = (0,_drawing_connector_util__WEBPACK_IMPORTED_MODULE_8__.updateRadiusLabel)(pdfAnnotationBase, this.measureAnnotationModule);\n            if (pdfAnnotationBase.enableShapeLabel === true) {\n                pdfAnnotationBase.labelContent = pdfAnnotationBase.notes;\n            }\n            this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('notes', pdfAnnotationBase.pageIndex, pdfAnnotationBase, isNewlyAdded);\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.addTextToComments(pdfAnnotationBase.annotName, pdfAnnotationBase.notes);\n            this.renderAnnotations(pdfAnnotationBase.pageIndex, null, null, null, null);\n        }\n        else if (pdfAnnotationBase.measureType === 'Perimeter') {\n            pdfAnnotationBase.notes = (0,_drawing_connector_util__WEBPACK_IMPORTED_MODULE_8__.updatePerimeterLabel)(pdfAnnotationBase, pdfAnnotationBase.vertexPoints, this.measureAnnotationModule);\n            if (pdfAnnotationBase.enableShapeLabel === true) {\n                pdfAnnotationBase.labelContent = pdfAnnotationBase.notes;\n            }\n            this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('notes', pdfAnnotationBase.pageIndex, pdfAnnotationBase, isNewlyAdded);\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.addTextToComments(pdfAnnotationBase.annotName, pdfAnnotationBase.notes);\n            this.renderAnnotations(pdfAnnotationBase.pageIndex, null, null, null, null);\n        }\n        else if (pdfAnnotationBase.measureType === 'Area') {\n            pdfAnnotationBase.notes = this.measureAnnotationModule.\n                calculateArea(pdfAnnotationBase.vertexPoints, pdfAnnotationBase.id, pdfAnnotationBase.pageIndex);\n            if (pdfAnnotationBase.enableShapeLabel === true) {\n                pdfAnnotationBase.labelContent = pdfAnnotationBase.notes;\n                (0,_drawing_connector_util__WEBPACK_IMPORTED_MODULE_8__.updateCalibrateLabel)(pdfAnnotationBase);\n            }\n            this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('notes', pdfAnnotationBase.pageIndex, pdfAnnotationBase, isNewlyAdded);\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.addTextToComments(pdfAnnotationBase.annotName, pdfAnnotationBase.notes);\n            this.renderAnnotations(pdfAnnotationBase.pageIndex, null, null, null, null);\n        }\n        else if (pdfAnnotationBase.measureType === 'Volume') {\n            pdfAnnotationBase.notes = this.measureAnnotationModule.\n                calculateVolume(pdfAnnotationBase.vertexPoints, pdfAnnotationBase.id, pdfAnnotationBase.pageIndex);\n            if (pdfAnnotationBase.enableShapeLabel === true) {\n                pdfAnnotationBase.labelContent = pdfAnnotationBase.notes;\n                (0,_drawing_connector_util__WEBPACK_IMPORTED_MODULE_8__.updateCalibrateLabel)(pdfAnnotationBase);\n            }\n            this.pdfViewer.annotation.measureAnnotationModule.modifyInCollection('notes', pdfAnnotationBase.pageIndex, pdfAnnotationBase, isNewlyAdded);\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.addTextToComments(pdfAnnotationBase.annotName, pdfAnnotationBase.notes);\n            this.renderAnnotations(pdfAnnotationBase.pageIndex, null, null, null, null);\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.onAnnotationMouseDown = function () {\n        if (this.pdfViewer.selectedItems.annotations.length === 1 &&\n            this.pdfViewer.selectedItems.annotations[0].formFieldAnnotationType === null) {\n            if (this.pdfViewer.toolbar && this.pdfViewer.toolbar.annotationToolbarModule) {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)() && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode) {\n                    var commentPanel = document.getElementById(this.pdfViewer.element.id + '_commantPanel');\n                    if (commentPanel.style.display === 'none') {\n                        if (this.pdfViewer.enableToolbar && this.pdfViewer.enableAnnotationToolbar &&\n                            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.textMarkupAnnotationModule) &&\n                                this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation)) {\n                            this.pdfViewer.toolbarModule.annotationToolbarModule.createPropertyTools('');\n                        }\n                        else {\n                            if (this.pdfViewer.enableToolbar && this.pdfViewer.enableAnnotationToolbar &&\n                                !this.pdfViewerBase.isAddComment) {\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.createAnnotationToolbarForMobile();\n                                this.pdfViewer.toolbarModule.annotationToolbarModule.\n                                    createPropertyTools(this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType);\n                                var editIcon = document.getElementById(this.pdfViewer.element.id + '_annotationIcon');\n                                if (editIcon && !editIcon.parentElement.classList.contains('e-pv-select')) {\n                                    editIcon.parentElement.classList.add('e-pv-select');\n                                }\n                            }\n                        }\n                    }\n                }\n                this.enableBasedOnType();\n                this.pdfViewer.toolbar.annotationToolbarModule.selectAnnotationDeleteItem(true);\n            }\n        }\n    };\n    Annotation.prototype.enableBasedOnType = function () {\n        var isLock = false;\n        var annotation = this.pdfViewer.selectedItems.annotations[0];\n        if (annotation && annotation.annotationSettings) {\n            isLock = annotation.annotationSettings.isLock;\n            if (isLock && this.checkAllowedInteractions('PropertyChange', annotation)) {\n                isLock = false;\n            }\n        }\n        if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice || this.pdfViewer.enableDesktopMode) {\n            if (!isLock) {\n                if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Stamp' ||\n                    this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Image') {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableStampAnnotationPropertiesTools(true);\n                }\n                else if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'StickyNotes') {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableStampAnnotationPropertiesTools(true);\n                }\n                else if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Path' ||\n                    this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'SignatureImage' ||\n                    this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'SignatureText') {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableAnnotationPropertiesTools(false);\n                }\n                else if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'FreeText') {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableFreeTextAnnotationPropertiesTools(true);\n                }\n                else if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'HandWrittenSignature') {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableSignaturePropertiesTools(true);\n                }\n                else if (this.pdfViewer.selectedItems.annotations[0].shapeAnnotationType === 'Ink') {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableSignaturePropertiesTools(true);\n                }\n                else {\n                    if (this.pdfViewer.selectedItems.annotations.length === 1 &&\n                        this.pdfViewer.selectedItems.annotations[0].formFieldAnnotationType === null) {\n                        this.pdfViewer.toolbar.annotationToolbarModule.enableAnnotationPropertiesTools(true);\n                    }\n                }\n            }\n        }\n        else if ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.textMarkupAnnotationModule) && !this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation) && !(this.pdfViewer.selectedItems.annotations[0].propName === 'annotations') && (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && !this.pdfViewer.enableDesktopMode)) {\n            this.pdfViewer.toolbarModule.annotationToolbarModule.createMobileAnnotationToolbar(true, true);\n        }\n    };\n    Annotation.prototype.getProperDate = function (date) {\n        var dateObject = new Date(date.toString());\n        if (isNaN(dateObject.getFullYear())) {\n            var dateString = date.slice(2, 16);\n            dateString = dateString.slice(0, 4) + '/' + dateString.slice(4, 6) + '/' + dateString.slice(6, 8) + ' ' + dateString.slice(8, 10) + ':' + dateString.slice(10, 12) + ':' + dateString.slice(12, 14);\n            dateObject = new Date(dateString);\n        }\n        return (dateObject.getMonth() + 1) + '/' + dateObject.getDate() + '/' + dateObject.getFullYear() + ' ' + dateObject.getHours() + ':' + dateObject.getMinutes() + ':' + dateObject.getSeconds();\n    };\n    /**\n     * @param {IPageAnnotations} pageAnnotations - pageAnnotations\n     * @param {number} pageNumber - pageNumber\n     * @private\n     * @returns {number} - number\n     */\n    Annotation.prototype.getPageCollection = function (pageAnnotations, pageNumber) {\n        var index = null;\n        for (var i = 0; i < pageAnnotations.length; i++) {\n            if (pageAnnotations[parseInt(i.toString(), 10)].pageIndex === pageNumber) {\n                index = i;\n                break;\n            }\n        }\n        return index;\n    };\n    /**\n     * @param {any} annotations - annotations\n     * @param {string} id - id\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.getAnnotationWithId = function (annotations, id) {\n        var annotation;\n        for (var i = 0; i < annotations.length; i++) {\n            if (id === annotations[parseInt(i.toString(), 10)].id) {\n                annotation = annotations[parseInt(i.toString(), 10)];\n            }\n        }\n        return annotation;\n    };\n    /**\n     * @param {any} event - event\n     * @private\n     * @returns {number} - number\n     */\n    Annotation.prototype.getEventPageNumber = function (event) {\n        var eventTarget = event.target;\n        var eventParentElement = event.target.parentElement;\n        if (eventTarget.classList.contains('e-pv-hyperlink')) {\n            eventTarget = eventParentElement;\n        }\n        else if (eventParentElement && eventParentElement.classList.contains('foreign-object') && eventParentElement.parentElement && eventParentElement.parentElement.parentElement && eventParentElement.parentElement.parentElement.parentElement) {\n            eventTarget = eventParentElement.parentElement.parentElement.parentElement;\n        }\n        else if (eventTarget.classList.contains('e-pdfviewer-formFields')) {\n            eventTarget = eventParentElement;\n        }\n        var pageString;\n        if (eventTarget) {\n            pageString = eventTarget.id.split('_text_')[1] || eventTarget.id.split('_textLayer_')[1] || eventTarget.id.split('_annotationCanvas_')[1] || eventTarget.id.split('_pageDiv_')[1];\n        }\n        if (isNaN(parseInt(pageString, 10))) {\n            event = this.pdfViewerBase.annotationEvent && this.pdfViewerBase.annotationEvent.target.id === eventTarget.id ?\n                this.pdfViewerBase.annotationEvent : event;\n            eventTarget = event.target;\n            if (eventTarget && eventTarget.id) {\n                pageString = eventTarget.id.split('_text_')[1] || eventTarget.id.split('_textLayer_')[1] || eventTarget.id.split('_annotationCanvas_')[1] || eventTarget.id.split('_pageDiv_')[1];\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.annotationEvent) &&\n                (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewerBase.annotationEvent.target)) && ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(pageString))) {\n                // eslint-disable-next-line\n                pageString = this.pdfViewerBase.annotationEvent.target.id.split('_textLayer_')[1];\n            }\n        }\n        return parseInt(pageString, 10);\n    };\n    /**\n     * @param {any} commentsAnnotations - commentsAnnotations\n     * @param {any} parentAnnotation - parentAnnotation\n     * @param {string} author - author\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.getAnnotationComments = function (commentsAnnotations, parentAnnotation, author) {\n        var newArray = [];\n        var annotationObject = null;\n        if (commentsAnnotations) {\n            if (commentsAnnotations.length > 0) {\n                for (var i = 0; i < commentsAnnotations.length; i++) {\n                    var annotation = commentsAnnotations[parseInt(i.toString(), 10)];\n                    annotationObject = {\n                        shapeAnnotationType: 'sticky', author: annotation.Author, modifiedDate: annotation.ModifiedDate, note: annotation.Note, state: annotation.state, stateModel: annotation.stateModel,\n                        comments: [], review: { state: annotation.State, stateModel: annotation.StateModel,\n                            modifiedDate: annotation.ModifiedDate, author: annotation.Author },\n                        annotName: annotation.AnnotName, parentId: parentAnnotation.AnnotName, subject: annotation.Subject,\n                        isLock: annotation.IsLock\n                    };\n                    newArray[newArray.length] = annotationObject;\n                }\n            }\n        }\n        return newArray;\n    };\n    Annotation.prototype.getRandomNumber = function () {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var random = Math.random() * 16 | 0;\n            var v = c === 'x' ? random : (random & 0x3 | 0x8);\n            return random.toString(16);\n        });\n    };\n    /**\n     * @private\n     * @returns {string} - string\n     */\n    Annotation.prototype.createGUID = function () {\n        return this.getRandomNumber();\n    };\n    /**\n     * Generates a canvas element with mix-blend mode to highlight annotations.\n     * @param {HTMLElement} pageDiv - pageDiv\n     * @param {number} pageWidth - pageWidth\n     * @param {number} pageHeight - pageHeight\n     * @param {number} pageNumber - pageNumber\n     * @param {string} displayMode - displayMode\n     * @private\n     * @returns {HTMLElement} - htmlelement\n     */\n    Annotation.prototype.createBlendAnnotationsIntoCanvas = function (pageDiv, pageWidth, pageHeight, pageNumber, displayMode) {\n        var canvas = this.pdfViewerBase.getElement('_blendAnnotationsIntoCanvas_' + pageNumber);\n        if (canvas) {\n            this.pdfViewerBase.updateCanvas(canvas, pageWidth, pageHeight, pageNumber);\n            return canvas;\n        }\n        else {\n            var annotationCanvas = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.createElement)('canvas', { id: this.pdfViewer.element.id + '_blendAnnotationsIntoCanvas_' + pageNumber, className: 'e-pv-annotation-canvas' });\n            this.pdfViewerBase.updateCanvas(annotationCanvas, pageWidth, pageHeight, pageNumber);\n            annotationCanvas.style['mixBlendMode'] = 'multiply';\n            pageDiv.appendChild(annotationCanvas);\n            return annotationCanvas;\n        }\n    };\n    /**\n     * @param {number} width - width\n     * @param {number} height - height\n     * @param {number} pageNumber - pageNumber\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.resizeAnnotations = function (width, height, pageNumber) {\n        var _this = this;\n        // Styles need to be applied to both canvases. The 'blendAnnotationsIntoCanvas' is used for highlight annotations.\n        ['_annotationCanvas_', '_blendAnnotationsIntoCanvas_'].forEach(function (id) {\n            var canvas = _this.pdfViewerBase.getElement(id + pageNumber);\n            if (canvas) {\n                canvas.style.width = width + 'px';\n                canvas.style.height = height + 'px';\n                _this.pdfViewerBase.applyElementStyles(canvas, pageNumber);\n            }\n        });\n    };\n    /**\n     * @param {number} pageNumber - pageNumber\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.clearAnnotationCanvas = function (pageNumber) {\n        var _this = this;\n        var zoom = this.pdfViewerBase.getZoomFactor();\n        var ratio = this.pdfViewerBase.getZoomRatio(zoom);\n        // Styles need to be applied to both canvases. The 'blendAnnotationsIntoCanvas' is used for highlight annotations.\n        var canvasIds = ['_annotationCanvas_', '_blendAnnotationsIntoCanvas_'];\n        canvasIds.forEach(function (id) {\n            var canvas = _this.pdfViewerBase.getElement(id + pageNumber);\n            if (canvas) {\n                var width = _this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].width;\n                var height = _this.pdfViewerBase.pageSize[parseInt(pageNumber.toString(), 10)].height;\n                canvas.width = width * ratio;\n                canvas.height = height * ratio;\n                canvas.style.width = width * zoom + 'px';\n                canvas.style.height = height * zoom + 'px';\n            }\n        });\n    };\n    /**\n     * @param {number} pageNumber - pageNumber\n     * @param {any} shapeAnnotation - shapeAnnotation\n     * @param {any} measureShapeAnnotation - measureShapeAnnotation\n     * @param {any} textMarkupAnnotation - textMarkupAnnotation\n     * @param {any} canvas - canvas\n     * @param {boolean} isImportAnnotations - isImportAnnotations\n     * @param {boolean} isAnnotOrderAction - isAnnotOrderAction\n     * @param {any} freeTextAnnotation - freeTextAnnotation\n     * @param {any} inkAnnotation - inkAnnotation\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.renderAnnotations = function (pageNumber, shapeAnnotation, measureShapeAnnotation, textMarkupAnnotation, canvas, isImportAnnotations, isAnnotOrderAction, freeTextAnnotation, inkAnnotation) {\n        this.clearAnnotationCanvas(pageNumber);\n        if (this.shapeAnnotationModule) {\n            if (isImportAnnotations) {\n                this.shapeAnnotationModule.renderShapeAnnotations(shapeAnnotation, pageNumber, true);\n            }\n            else {\n                this.shapeAnnotationModule.renderShapeAnnotations(shapeAnnotation, pageNumber, null, isAnnotOrderAction);\n            }\n        }\n        if (this.measureAnnotationModule) {\n            if (isImportAnnotations) {\n                this.measureAnnotationModule.renderMeasureShapeAnnotations(measureShapeAnnotation, pageNumber, true);\n            }\n            else {\n                this.measureAnnotationModule.renderMeasureShapeAnnotations(measureShapeAnnotation, pageNumber, null, isAnnotOrderAction);\n            }\n        }\n        if (this.freeTextAnnotationModule) {\n            if (isImportAnnotations) {\n                this.freeTextAnnotationModule.renderFreeTextAnnotations(freeTextAnnotation, pageNumber, true);\n            }\n            else {\n                this.freeTextAnnotationModule.renderFreeTextAnnotations(freeTextAnnotation, pageNumber, null, isAnnotOrderAction);\n            }\n        }\n        if (this.inkAnnotationModule) {\n            if (isImportAnnotations) {\n                this.inkAnnotationModule.renderExistingInkSignature(inkAnnotation, pageNumber, true);\n            }\n            else {\n                this.inkAnnotationModule.renderExistingInkSignature(inkAnnotation, pageNumber, null, isAnnotOrderAction);\n            }\n        }\n        this.pdfViewer.drawing.refreshCanvasDiagramLayer(canvas, pageNumber);\n        var highlighCanvas = this.pdfViewerBase.getElement('_blendAnnotationsIntoCanvas_' + pageNumber);\n        if (highlighCanvas) {\n            this.pdfViewer.drawing.refreshCanvasDiagramLayer(canvas, pageNumber);\n        }\n        if (!this.pdfViewerBase.isInkAdded && this.pdfViewer.tool === 'Ink' && this.pdfViewer.currentPageNumber - 1 === pageNumber) {\n            var currentcanvas = this.pdfViewerBase.getAnnotationCanvas('_annotationCanvas_', (this.pdfViewer.currentPageNumber - 1));\n            var zoom = this.pdfViewerBase.getZoomFactor();\n            var ratio = this.pdfViewerBase.getWindowDevicePixelRatio();\n            var context = currentcanvas.getContext('2d');\n            var thickness = this.pdfViewer.inkAnnotationSettings.thickness ? this.pdfViewer.inkAnnotationSettings.thickness : 1;\n            var opacity = this.pdfViewer.inkAnnotationSettings.opacity ? this.pdfViewer.inkAnnotationSettings.opacity : 1;\n            var strokeColor = this.pdfViewer.inkAnnotationSettings.strokeColor ? this.pdfViewer.inkAnnotationSettings.strokeColor : '#ff0000';\n            if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice || (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.Browser.isDevice && zoom <= 0.7)) {\n                context.setTransform(ratio, 0, 0, ratio, 0, 0);\n            }\n            context.beginPath();\n            context.lineJoin = 'round';\n            context.lineCap = 'round';\n            context.lineWidth = thickness * zoom > 1 ? thickness * zoom : thickness;\n            context.strokeStyle = strokeColor;\n            context.globalAlpha = opacity;\n            var collectionData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__.processPathData)(this.pdfViewer.annotationModule.inkAnnotationModule.updateInkDataWithZoom());\n            var csData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_5__.splitArrayCollection)(collectionData);\n            for (var j = 0; j < csData.length; j++) {\n                var pathValue = csData[parseInt(j.toString(), 10)];\n                switch (pathValue.command) {\n                    case 'M':\n                        context.moveTo(pathValue.x, pathValue.y);\n                        break;\n                    case 'L':\n                        context.lineTo(pathValue.x, pathValue.y);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            context.stroke();\n            context.closePath();\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.toolbarModule) &&\n                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.toolbarModule.annotationToolbarModule)) {\n                this.pdfViewer.toolbar.annotationToolbarModule.inkAnnotationSelected = true;\n            }\n        }\n        if (this.textMarkupAnnotationModule) {\n            if (isImportAnnotations) {\n                this.textMarkupAnnotationModule.renderTextMarkupAnnotationsInPage(textMarkupAnnotation, pageNumber, true);\n            }\n            else {\n                this.textMarkupAnnotationModule.renderTextMarkupAnnotationsInPage(textMarkupAnnotation, pageNumber);\n            }\n        }\n    };\n    /**\n     * @param {number} pageNumber - pageNumber\n     * @param {any} annotation - annotation\n     * @param {string} annotationId - annotationId\n     * @private\n     * @returns {number} - number\n     */\n    Annotation.prototype.storeAnnotations = function (pageNumber, annotation, annotationId) {\n        // let annotationId: string = '_annotations_textMarkup';\n        // if (annotation is ITextMarkupAnnotation) {\n        //     annotationId = '_annotations_textMarkup';\n        // } else if (annotation as IShapeAnnotation) {\n        //     annotationId = '_annotations_shape';\n        // } else {\n        //     annotationId = '_annotations_stamp';\n        // }\n        var sessionSize = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getWindowSessionStorageSize();\n        if (sessionSize > 4500) {\n            this.clearAnnotationStorage();\n            this.pdfViewerBase.isStorageExceed = true;\n            if (!(this.pdfViewerBase.isFormStorageExceed)) {\n                if (this.pdfViewer.formFieldsModule) {\n                    this.pdfViewer.formFieldsModule.clearFormFieldStorage();\n                }\n            }\n        }\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + annotationId);\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + annotationId];\n        }\n        var index = 0;\n        if (!storeObject) {\n            this.storeAnnotationCollections(annotation, pageNumber);\n            var pageAnnotation = { pageIndex: pageNumber, annotations: [] };\n            pageAnnotation.annotations.push(annotation);\n            index = pageAnnotation.annotations.indexOf(annotation);\n            var annotationCollection = [];\n            annotationCollection.push(pageAnnotation);\n            var annotationStringified = JSON.stringify(annotationCollection);\n            if (this.pdfViewerBase.isStorageExceed) {\n                this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + annotationId] = annotationStringified;\n            }\n            else {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + annotationId, annotationStringified);\n            }\n        }\n        else {\n            this.storeAnnotationCollections(annotation, pageNumber);\n            var annotObject_1 = JSON.parse(storeObject);\n            if (!this.pdfViewerBase.isStorageExceed) {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + annotationId);\n            }\n            var pageIndex_1 = this.pdfViewer.annotationModule.getPageCollection(annotObject_1, pageNumber);\n            if (pageIndex_1 != null && annotObject_1[parseInt(pageIndex_1.toString(), 10)]) {\n                annotObject_1[parseInt(pageIndex_1.toString(), 10)].\n                    annotations.filter(function (item, index) {\n                    if (item.annotName === annotation.annotName) {\n                        annotObject_1[parseInt(pageIndex_1.toString(), 10)].annotations.splice(index, 1);\n                    }\n                });\n                annotObject_1[parseInt(pageIndex_1.toString(), 10)].annotations.push(annotation);\n                index = annotObject_1[parseInt(pageIndex_1.toString(), 10)].annotations.indexOf(annotation);\n            }\n            else {\n                var markupAnnotation = { pageIndex: pageNumber, annotations: [] };\n                markupAnnotation.annotations.push(annotation);\n                index = markupAnnotation.annotations.indexOf(annotation);\n                annotObject_1.push(markupAnnotation);\n            }\n            var annotationStringified = JSON.stringify(annotObject_1);\n            if (this.pdfViewerBase.isStorageExceed) {\n                this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + annotationId] = annotationStringified;\n            }\n            else {\n                _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + annotationId, annotationStringified);\n            }\n        }\n        return index;\n    };\n    /**\n     * @param {string} type - type\n     * @private\n     * @returns {DecoratorShapes}- decorateshapes\n     */\n    Annotation.prototype.getArrowType = function (type) {\n        var decoratorShapes = 'None';\n        switch (type) {\n            case 'ClosedArrow':\n            case 'Closed':\n                decoratorShapes = 'Arrow';\n                break;\n            case 'OpenArrow':\n            case 'Open':\n                decoratorShapes = 'OpenArrow';\n                break;\n            case 'Square':\n                decoratorShapes = 'Square';\n                break;\n            case 'Circle':\n            case 'Round':\n                decoratorShapes = 'Circle';\n                break;\n            case 'Diamond':\n                decoratorShapes = 'Diamond';\n                break;\n            case 'Butt':\n                decoratorShapes = 'Butt';\n                break;\n            case 'Slash':\n                // decoratorShapes = 'Slash';\n                break;\n        }\n        return decoratorShapes;\n    };\n    /**\n     * @param {DecoratorShapes} arrow - arrow\n     * @private\n     * @returns {string}- string\n     */\n    Annotation.prototype.getArrowTypeForCollection = function (arrow) {\n        var arrowType;\n        switch (arrow) {\n            case 'Arrow':\n                arrowType = 'ClosedArrow';\n                break;\n            case 'OpenArrow':\n            case 'Square':\n            case 'Circle':\n            case 'Diamond':\n            case 'None':\n                arrowType = arrow.toString();\n                break;\n            case 'Butt':\n                arrowType = 'Butt';\n                break;\n        }\n        return arrowType;\n    };\n    /**\n     * @param {any} bound - bound\n     * @param {number} pageIndex - pageIndex\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.getBounds = function (bound, pageIndex) {\n        var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)];\n        if (pageDetails) {\n            if (pageDetails.rotation === 1) {\n                return { left: bound.top, top: pageDetails.width - (bound.left + bound.width), width: bound.height, height: bound.width };\n            }\n            else if (pageDetails.rotation === 2) {\n                return { left: pageDetails.width - bound.left - bound.width, top: pageDetails.height - bound.top - bound.height,\n                    width: bound.width, height: bound.height };\n            }\n            else if (pageDetails.rotation === 3) {\n                return { left: pageDetails.height - bound.top - bound.height, top: bound.left, width: bound.height, height: bound.width };\n            }\n            else {\n                return bound;\n            }\n        }\n        else {\n            return bound;\n        }\n    };\n    /**\n     * @param {any} bound - bound\n     * @param {number} pageIndex - pageIndex\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.getInkBounds = function (bound, pageIndex) {\n        var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)];\n        if (pageDetails) {\n            if (pageDetails.rotation === 1) {\n                return { x: bound.y, y: pageDetails.width - (bound.x + bound.width), width: bound.height, height: bound.width };\n            }\n            else if (pageDetails.rotation === 2) {\n                return { x: pageDetails.width - bound.x - bound.width, y: pageDetails.height - bound.y - bound.height,\n                    width: bound.width, height: bound.height };\n            }\n            else if (pageDetails.rotation === 3) {\n                return { x: pageDetails.height - bound.y - bound.height, y: bound.x, width: bound.height, height: bound.width };\n            }\n            else {\n                return bound;\n            }\n        }\n        else {\n            return bound;\n        }\n    };\n    /**\n     * @param {any} points - points\n     * @param {number} pageIndex - pageIndex\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.getVertexPoints = function (points, pageIndex) {\n        if (points) {\n            var pageDetails = this.pdfViewerBase.pageSize[parseInt(pageIndex.toString(), 10)];\n            if (pageDetails.rotation === 1) {\n                var points1 = [];\n                for (var i = 0; i < points.length; i++) {\n                    var point = { x: points[parseInt(i.toString(), 10)].y,\n                        y: pageDetails.width - points[parseInt(i.toString(), 10)].x };\n                    points1.push(point);\n                }\n                return points1;\n            }\n            else if (pageDetails.rotation === 2) {\n                var points2 = [];\n                for (var i = 0; i < points.length; i++) {\n                    var point = { x: pageDetails.width - points[parseInt(i.toString(), 10)].x,\n                        y: pageDetails.height - points[parseInt(i.toString(), 10)].y };\n                    points2.push(point);\n                }\n                return points2;\n            }\n            else if (pageDetails.rotation === 3) {\n                var points3 = [];\n                for (var i = 0; i < points.length; i++) {\n                    var point = { x: pageDetails.height - points[parseInt(i.toString(), 10)].y,\n                        y: points[parseInt(i.toString(), 10)].x };\n                    points3.push(point);\n                }\n                return points3;\n            }\n            else {\n                return points;\n            }\n        }\n    };\n    /**\n     * @param {number} pageIndex - pageIndex\n     * @param {any} shapeAnnotations - shapeAnnotations\n     * @param {string} idString - idString\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.getStoredAnnotations = function (pageIndex, shapeAnnotations, idString) {\n        var annotationCollection;\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + idString);\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + idString];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageIndex);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotationCollection = annotObject[parseInt(index.toString(), 10)].annotations;\n            }\n            else {\n                annotationCollection = null;\n            }\n        }\n        else {\n            annotationCollection = null;\n        }\n        return annotationCollection;\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} pdfAnnotationBase - pdfAnnotationBase\n     * @param {boolean} isColor - isColor\n     * @param {boolean} isStroke - isStroke\n     * @param {boolean} isThickness - isThickness\n     * @param {boolean} isOpacity - isOpacity\n     * @param {boolean} isLineStart - isLineStart\n     * @param {boolean} isLineEnd - isLineEnd\n     * @param {boolean} isDashArray - isDashArray\n     * @param {boolean} isFreeText - isFreeText\n     * @param {string} previousText - previousText\n     * @param {string} currentText - currentText\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.triggerAnnotationPropChange = function (pdfAnnotationBase, isColor, isStroke, isThickness, isOpacity, isLineStart, isLineEnd, isDashArray, isFreeText, previousText, currentText) {\n        var index = this.getAnnotationIndex(pdfAnnotationBase.pageIndex, pdfAnnotationBase.id);\n        var type = this.getAnnotationType(pdfAnnotationBase.shapeAnnotationType, pdfAnnotationBase.measureType);\n        var eventArgs = { name: 'annotationPropertiesChange', pageIndex: pdfAnnotationBase.pageIndex, annotationId: pdfAnnotationBase.annotName, annotationType: type, isColorChanged: isColor, isOpacityChanged: isOpacity, isThicknessChanged: isThickness, isStrokeColorChanged: isStroke };\n        if (isFreeText) {\n            eventArgs.isFreeTextChanged = isFreeText;\n            eventArgs.previousText = previousText;\n            eventArgs.currentText = currentText;\n        }\n        if (isLineStart) {\n            eventArgs.isLineHeadStartStyleChanged = isLineStart;\n        }\n        if (isLineEnd) {\n            eventArgs.isLineHeadEndStyleChanged = isLineEnd;\n        }\n        if (isDashArray) {\n            eventArgs.isBorderDashArrayChanged = isDashArray;\n        }\n        this.pdfViewer.trigger('annotationPropertiesChange', eventArgs);\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} pdfAnnotationBase - It describes about the pdf annotation base\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.triggerAnnotationAdd = function (pdfAnnotationBase) {\n        var setting = {\n            opacity: pdfAnnotationBase.opacity, fillColor: pdfAnnotationBase.fillColor, strokeColor: pdfAnnotationBase.strokeColor,\n            thickness: pdfAnnotationBase.thickness, author: pdfAnnotationBase.author, subject: pdfAnnotationBase.subject,\n            modifiedDate: pdfAnnotationBase.modifiedDate\n        };\n        var bounds = { left: pdfAnnotationBase.wrapper.bounds.x, top: pdfAnnotationBase.wrapper.bounds.y,\n            width: pdfAnnotationBase.wrapper.bounds.width, height: pdfAnnotationBase.wrapper.bounds.height };\n        var type = this.getAnnotationType(pdfAnnotationBase.shapeAnnotationType, pdfAnnotationBase.measureType);\n        if (type === 'Line' || type === 'Arrow' || type === 'Distance' || type === 'Perimeter') {\n            setting.lineHeadStartStyle = this.getArrowString(pdfAnnotationBase.sourceDecoraterShapes);\n            setting.lineHeadEndStyle = this.getArrowString(pdfAnnotationBase.taregetDecoraterShapes);\n            setting.borderDashArray = pdfAnnotationBase.borderDashArray;\n        }\n        var labelSettings;\n        if (this.pdfViewer.enableShapeLabel) {\n            labelSettings = {\n                fontColor: pdfAnnotationBase.fontColor, fontSize: pdfAnnotationBase.fontSize, fontFamily: pdfAnnotationBase.fontFamily,\n                opacity: pdfAnnotationBase.labelOpacity, labelContent: pdfAnnotationBase.labelContent,\n                fillColor: pdfAnnotationBase.labelFillColor\n            };\n            this.pdfViewer.fireAnnotationAdd(pdfAnnotationBase.pageIndex, pdfAnnotationBase.annotName, type, bounds, setting, null, null, null, labelSettings);\n        }\n        else {\n            this.pdfViewer.fireAnnotationAdd(pdfAnnotationBase.pageIndex, pdfAnnotationBase.annotName, type, bounds, setting);\n        }\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} pdfAnnotationBase - pdfAnnotationBase\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.triggerAnnotationResize = function (pdfAnnotationBase) {\n        var setting = {\n            opacity: pdfAnnotationBase.opacity, fillColor: pdfAnnotationBase.fillColor, strokeColor: pdfAnnotationBase.strokeColor,\n            thickness: pdfAnnotationBase.thickness, author: pdfAnnotationBase.author, subject: pdfAnnotationBase.subject,\n            modifiedDate: pdfAnnotationBase.modifiedDate\n        };\n        var annotationBounds = pdfAnnotationBase.bounds;\n        var currentPosition = { left: annotationBounds.x, top: annotationBounds.y, x: annotationBounds.x,\n            y: annotationBounds.y, width: annotationBounds.width, height: annotationBounds.height };\n        var previousPosition = { left: annotationBounds.oldProperties.x, top: annotationBounds.oldProperties.y,\n            width: annotationBounds.oldProperties.width, height: annotationBounds.oldProperties.height };\n        var type = this.getAnnotationType(pdfAnnotationBase.shapeAnnotationType, pdfAnnotationBase.measureType);\n        if (type === 'Line' || type === 'Arrow' || type === 'Distance' || type === 'Perimeter') {\n            setting.lineHeadStartStyle = this.getArrowString(pdfAnnotationBase.sourceDecoraterShapes);\n            setting.lineHeadEndStyle = this.getArrowString(pdfAnnotationBase.taregetDecoraterShapes);\n            setting.borderDashArray = pdfAnnotationBase.borderDashArray;\n        }\n        var labelSettings;\n        if (this.pdfViewer.enableShapeLabel && (pdfAnnotationBase.shapeAnnotationType !== 'HandWrittenSignature')) {\n            labelSettings = {\n                fontColor: pdfAnnotationBase.fontColor, fontSize: pdfAnnotationBase.fontSize, fontFamily: pdfAnnotationBase.fontFamily,\n                opacity: pdfAnnotationBase.labelOpacity, labelContent: pdfAnnotationBase.labelContent,\n                fillColor: pdfAnnotationBase.labelFillColor, notes: pdfAnnotationBase.notes\n            };\n            this.pdfViewer.fireAnnotationResize(pdfAnnotationBase.pageIndex, pdfAnnotationBase.annotName, type, currentPosition, setting, null, null, null, labelSettings);\n        }\n        else {\n            if (pdfAnnotationBase.shapeAnnotationType === 'HandWrittenSignature' || pdfAnnotationBase.shapeAnnotationType === 'SignatureText' || pdfAnnotationBase.shapeAnnotationType === 'SignatureImage') {\n                this.pdfViewer.fireSignatureResize(pdfAnnotationBase.pageIndex, pdfAnnotationBase.signatureName, pdfAnnotationBase.shapeAnnotationType, pdfAnnotationBase.opacity, pdfAnnotationBase.strokeColor, pdfAnnotationBase.thickness, currentPosition, previousPosition);\n            }\n            else {\n                this.pdfViewer.fireAnnotationResize(pdfAnnotationBase.pageIndex, pdfAnnotationBase.annotName, type, currentPosition, setting);\n            }\n        }\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} pdfAnnotationBase - pdfAnnotationBase\n     * @param {boolean} isMoving - isMoving\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.triggerAnnotationMove = function (pdfAnnotationBase, isMoving) {\n        var setting = {\n            opacity: pdfAnnotationBase.opacity, fillColor: pdfAnnotationBase.fillColor, strokeColor: pdfAnnotationBase.strokeColor,\n            thickness: pdfAnnotationBase.thickness, author: pdfAnnotationBase.author, subject: pdfAnnotationBase.subject,\n            modifiedDate: pdfAnnotationBase.modifiedDate\n        };\n        var annotationBounds = pdfAnnotationBase.bounds;\n        var currentPosition = { left: annotationBounds.x, top: annotationBounds.y,\n            x: annotationBounds.x, y: annotationBounds.y, width: annotationBounds.width, height: annotationBounds.height };\n        var previousPosition = { left: annotationBounds.oldProperties.x ?\n                annotationBounds.oldProperties.x : annotationBounds.x, top: annotationBounds.oldProperties.y ?\n                annotationBounds.oldProperties.y : annotationBounds.y, width: annotationBounds.width, height: annotationBounds.height };\n        var type = this.getAnnotationType(pdfAnnotationBase.shapeAnnotationType, pdfAnnotationBase.measureType);\n        if (type === 'Line' || type === 'Arrow' || type === 'Distance' || type === 'Perimeter') {\n            setting.lineHeadStartStyle = this.getArrowString(pdfAnnotationBase.sourceDecoraterShapes);\n            setting.lineHeadEndStyle = this.getArrowString(pdfAnnotationBase.taregetDecoraterShapes);\n            setting.borderDashArray = pdfAnnotationBase.borderDashArray;\n        }\n        if (pdfAnnotationBase.shapeAnnotationType === 'HandWrittenSignature' || pdfAnnotationBase.shapeAnnotationType === 'SignatureText' || pdfAnnotationBase.shapeAnnotationType === 'SignatureImage') {\n            this.pdfViewer.fireSignatureMove(pdfAnnotationBase.pageIndex, pdfAnnotationBase.signatureName, pdfAnnotationBase.shapeAnnotationType, pdfAnnotationBase.opacity, pdfAnnotationBase.strokeColor, pdfAnnotationBase.thickness, previousPosition, currentPosition);\n        }\n        else {\n            if (isMoving) {\n                this.pdfViewer.fireAnnotationMoving(pdfAnnotationBase.pageIndex, pdfAnnotationBase.annotName, type, setting, previousPosition, currentPosition);\n            }\n            else {\n                this.pdfViewer.fireAnnotationMove(pdfAnnotationBase.pageIndex, pdfAnnotationBase.annotName, type, setting, previousPosition, currentPosition);\n            }\n        }\n    };\n    /**\n     * @param {any} annotationId - annotationId\n     * @param {number} pageNumber - pageNumber\n     * @param {any} annotation - annotation\n     * @param {any} annotationCollection - annotationCollection\n     * @param {boolean} isDblClick - isDblClick\n     * @param {boolean} isSelected - isSelected\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.annotationSelect = function (annotationId, pageNumber, annotation, annotationCollection, isDblClick, isSelected) {\n        var annotSettings;\n        if (annotation.shapeAnnotationType === 'textMarkup') {\n            annotSettings = { type: 'TextMarkup', subType: annotation.subject, opacity: annotation.opacity, color: annotation.color, textMarkupContent: annotation.textMarkupContent, textMarkupStartIndex: annotation.textMarkupStartIndex, textMarkupEndIndex: annotation.textMarkupEndIndex, customData: annotation.customData };\n        }\n        else if (annotation.shapeAnnotationType === 'StickyNotes') {\n            annotSettings = { type: 'StickyNotes', opacity: annotation.opacity, customData: annotation.customData };\n        }\n        else if (annotation.shapeAnnotationType === 'Stamp' || annotation.shapeAnnotationType === 'Image') {\n            annotSettings = { type: 'Stamp', opacity: annotation.opacity, customData: annotation.customData };\n        }\n        else if (annotation.shapeAnnotationType === 'Ink') {\n            annotSettings = {\n                type: 'Ink', opacity: annotation.opacity, strokeColor: annotation.strokeColor, thickness: annotation.thickness, modifiedDate: annotation.modifiedDate,\n                width: annotation.bounds.width, height: annotation.bounds.height, left: annotation.bounds.x,\n                top: annotation.bounds.y, data: annotation.data, customData: annotation.customData\n            };\n        }\n        else if (annotation.shapeAnnotationType === 'FreeText') {\n            annotSettings = {\n                type: 'FreeText', opacity: annotation.opacity, fillColor: annotation.fillColor,\n                strokeColor: annotation.strokeColor, thickness: annotation.thickness, content: annotation.dynamicText,\n                fontFamily: annotation.fontFamily, fontSize: annotation.fontSize, fontColor: annotation.fontColor,\n                textAlign: annotation.textAlign, fontStyle: this.updateFreeTextFontStyle(annotation.font),\n                customData: annotation.customData\n            };\n        }\n        else if (annotation.measureType === '') {\n            if (annotation.shapeAnnotationType === 'Line') {\n                annotSettings = { type: 'Shape', subType: 'Line', opacity: annotation.opacity, fillColor: annotation.fillColor, strokeColor: annotation.strokeColor, thickness: annotation.thickness, borderDashArray: annotation.borderDashArray, lineHeadStartStyle: annotation.sourceDecoraterShapes, lineHeadEndStyle: annotation.taregetDecoraterShapes, customData: annotation.customData };\n            }\n            else if (annotation.shapeAnnotationType === 'Arrow' || annotation.shapeAnnotationType === 'LineWidthArrowHead') {\n                annotSettings = { type: 'Shape', subType: 'Arrow', opacity: annotation.opacity, fillColor: annotation.fillColor, strokeColor: annotation.strokeColor, thickness: annotation.thickness, borderDashArray: annotation.borderDashArray, lineHeadStartStyle: annotation.sourceDecoraterShapes, lineHeadEndStyle: annotation.taregetDecoraterShapes, customData: annotation.customData };\n            }\n            else if (annotation.shapeAnnotationType === 'Rectangle') {\n                annotSettings = {\n                    type: 'Shape', subType: 'Rectangle', opacity: annotation.opacity, fillColor: annotation.fillColor,\n                    strokeColor: annotation.strokeColor, thickness: annotation.thickness, customData: annotation.customData\n                };\n            }\n            else if (annotation.shapeAnnotationType === 'Circle' || annotation.shapeAnnotationType === 'Ellipse') {\n                annotSettings = {\n                    type: 'Shape', subType: 'Circle', opacity: annotation.opacity, fillColor: annotation.fillColor,\n                    strokeColor: annotation.strokeColor, thickness: annotation.thickness, customData: annotation.customData\n                };\n            }\n            else if (annotation.shapeAnnotationType === 'Polygon') {\n                annotSettings = {\n                    type: 'Shape', subType: 'Polygon', opacity: annotation.opacity, fillColor: annotation.fillColor,\n                    strokeColor: annotation.strokeColor, thickness: annotation.thickness, customData: annotation.customData\n                };\n            }\n        }\n        else if (annotation.measureType !== '') {\n            if (annotation.measureType === 'Distance') {\n                annotSettings = { type: 'Measure', subType: 'Distance', opacity: annotation.opacity, fillColor: annotation.fillColor, strokeColor: annotation.strokeColor, thickness: annotation.thickness, borderDashArray: annotation.borderDashArray, lineHeadStartStyle: annotation.sourceDecoraterShapes, lineHeadEndStyle: annotation.taregetDecoraterShapes, customData: annotation.customData };\n            }\n            else if (annotation.measureType === 'Perimeter') {\n                annotSettings = { type: 'Measure', subType: 'Perimeter', opacity: annotation.opacity, fillColor: annotation.fillColor, strokeColor: annotation.strokeColor, thickness: annotation.thickness, borderDashArray: annotation.borderDashArray, lineHeadStartStyle: annotation.sourceDecoraterShapes, lineHeadEndStyle: annotation.taregetDecoraterShapes, customData: annotation.customData };\n            }\n            else if (annotation.measureType === 'Area') {\n                annotSettings = {\n                    type: 'Measure', subType: 'Area', opacity: annotation.opacity, fillColor: annotation.fillColor,\n                    strokeColor: annotation.strokeColor, thickness: annotation.thickness, customData: annotation.customData\n                };\n            }\n            else if (annotation.measureType === 'Radius') {\n                annotSettings = {\n                    type: 'Measure', subType: 'Radius', opacity: annotation.opacity, fillColor: annotation.fillColor,\n                    strokeColor: annotation.strokeColor, thickness: annotation.thickness, customData: annotation.customData\n                };\n            }\n            else if (annotation.measureType === 'Volume') {\n                annotSettings = {\n                    type: 'Measure', subType: 'Volume', opacity: annotation.opacity, fillColor: annotation.fillColor,\n                    strokeColor: annotation.strokeColor, thickness: annotation.thickness, calibrate: annotation.calibrate,\n                    annotationId: annotation.annotName, customData: annotation.customData\n                };\n            }\n        }\n        var overlappedCollection = [];\n        var overlappedAnnotations = this.getOverlappedAnnotations(annotation, pageNumber);\n        if (overlappedAnnotations && this.overlappedCollections) {\n            var overlappedCollections = [];\n            for (var i = 0; i < overlappedAnnotations.length; i++) {\n                if (overlappedAnnotations[parseInt(i.toString(), 10)].shapeAnnotationType !== 'textMarkup' && this.overlappedCollections || isSelected) {\n                    for (var j = 0; j < this.overlappedCollections.length; j++) {\n                        if (overlappedAnnotations[parseInt(i.toString(), 10)].annotName ===\n                            this.overlappedCollections[parseInt(j.toString(), 10)].annotName) {\n                            overlappedCollections.push(overlappedAnnotations[parseInt(i.toString(), 10)]);\n                            break;\n                        }\n                    }\n                }\n                else {\n                    overlappedCollections.push(overlappedAnnotations[parseInt(i.toString(), 10)]);\n                }\n            }\n            overlappedAnnotations = overlappedCollections;\n        }\n        if (this.pdfViewer.enableMultiLineOverlap) {\n            for (var i = 0; i < overlappedAnnotations.length; i++) {\n                if (overlappedAnnotations[parseInt(i.toString(), 10)].shapeAnnotationType === 'textMarkup') {\n                    var isOverlapped = false;\n                    for (var j = 0; j < overlappedAnnotations[parseInt(i.toString(), 10)].bounds.length; j++) {\n                        var bounds = this.orderTextMarkupBounds(overlappedAnnotations[parseInt(i.toString(), 10)].bounds[parseInt(j.toString(), 10)]);\n                        var clickedPosition = this.textMarkupAnnotationModule.annotationClickPosition;\n                        if (clickedPosition && (clickedPosition.x || clickedPosition.y)) {\n                            if (bounds.left <= clickedPosition.x && (bounds.left + bounds.width) >= clickedPosition.x) {\n                                if (bounds.top <= clickedPosition.y && (bounds.top + bounds.height) >= clickedPosition.y) {\n                                    isOverlapped = true;\n                                }\n                            }\n                        }\n                        else {\n                            isOverlapped = true;\n                        }\n                    }\n                    if (!isOverlapped) {\n                        overlappedAnnotations.splice(i, 1);\n                    }\n                }\n            }\n        }\n        if (overlappedAnnotations && overlappedAnnotations.length > 0) {\n            annotationCollection = overlappedAnnotations;\n            for (var i = 0; i < annotationCollection.length; i++) {\n                var overlappedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(annotationCollection[parseInt(i.toString(), 10)]);\n                overlappedObject.annotationId = annotationCollection[parseInt(i.toString(), 10)].annotName;\n                if (annotationId === annotationCollection[parseInt(i.toString(), 10)].annotName && annotation.measureType && annotation.measureType === 'Volume') {\n                    annotSettings.calibrate = annotationCollection[parseInt(i.toString(), 10)].calibrate;\n                }\n                delete overlappedObject.annotName;\n                overlappedCollection.push(overlappedObject);\n            }\n        }\n        else {\n            overlappedCollection = null;\n        }\n        this.addFreeTextProperties(annotation, annotSettings);\n        var annotationAddMode = annotation.annotationAddMode;\n        if (!isDblClick) {\n            if (annotation.shapeAnnotationType === 'Stamp' || annotation.shapeAnnotationType === 'Image') {\n                if (!this.pdfViewerBase.isNewStamp && this.annotationSelected) {\n                    if (overlappedCollection) {\n                        this.pdfViewer.fireAnnotationSelect(annotationId, pageNumber, annotSettings, overlappedCollection, null, null, annotationAddMode);\n                    }\n                    else {\n                        this.pdfViewer.fireAnnotationSelect(annotationId, pageNumber, annotSettings, null, null, null, annotationAddMode);\n                    }\n                }\n            }\n            else {\n                var module = this.textMarkupAnnotationModule;\n                var multiPageCollection = module && module.multiPageCollectionList(annotation);\n                if (multiPageCollection && multiPageCollection.length === 0) {\n                    multiPageCollection = null;\n                }\n                if (this.annotationSelected) {\n                    if (overlappedCollection) {\n                        isSelected = false;\n                        this.pdfViewer.fireAnnotationSelect(annotationId, pageNumber, annotSettings, overlappedCollection, multiPageCollection, isSelected, annotationAddMode);\n                    }\n                    else {\n                        isSelected = true;\n                        this.pdfViewer.fireAnnotationSelect(annotationId, pageNumber, annotSettings, null, multiPageCollection, isSelected, annotationAddMode);\n                    }\n                }\n            }\n        }\n        else {\n            if (annotation.shapeAnnotationType === 'Stamp' || annotation.shapeAnnotationType === 'Image') {\n                if (!this.pdfViewerBase.isNewStamp) {\n                    this.pdfViewer.fireAnnotationDoubleClick(annotationId, pageNumber, annotSettings);\n                }\n            }\n            else {\n                this.pdfViewer.fireAnnotationDoubleClick(annotationId, pageNumber, annotSettings);\n            }\n        }\n        this.annotationSelected = true;\n    };\n    Annotation.prototype.selectSignature = function (signatureId, pageNumber, signatureModule) {\n        var annotBounds = signatureModule.bounds;\n        var bounds = { height: annotBounds.height, width: annotBounds.width, x: annotBounds.x, y: annotBounds.y };\n        if (!this.pdfViewerBase.signatureAdded && signatureModule.signatureName !== 'ink') {\n            var signature = { bounds: bounds, opacity: signatureModule.opacity, thickness: signatureModule.thickness,\n                strokeColor: signatureModule.strokeColor };\n            this.pdfViewer.fireSignatureSelect(signatureId, pageNumber, signature);\n        }\n    };\n    /**\n     *\n     * @param {string} signatureId - Gets the id of the signature\n     * @param {number} pageNumber - Gets the page number value\n     * @param {any} signatureModule - It describes about the signature module\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.unselectSignature = function (signatureId, pageNumber, signatureModule) {\n        var annotBounds = signatureModule.bounds;\n        var bounds = { height: annotBounds.height, width: annotBounds.width, x: annotBounds.x, y: annotBounds.y };\n        if (!this.pdfViewerBase.signatureAdded) {\n            var signature = { bounds: bounds, opacity: signatureModule.opacity, thickness: signatureModule.thickness,\n                strokeColor: signatureModule.strokeColor };\n            this.pdfViewer.fireSignatureUnselect(signatureId, pageNumber, signature);\n        }\n    };\n    Annotation.prototype.editSignature = function (signature) {\n        var currentAnnotation;\n        if (signature.uniqueKey) {\n            currentAnnotation = this.pdfViewer.nameTable[signature.uniqueKey];\n        }\n        else {\n            currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n        }\n        var pageNumber = currentAnnotation.pageIndex;\n        if (currentAnnotation.shapeAnnotationType === 'HandWrittenSignature' || currentAnnotation.shapeAnnotationType === 'SignatureText' || currentAnnotation.shapeAnnotationType === 'SignatureImage') {\n            var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(signature.opacity)) || currentAnnotation.opacity !== signature.opacity) {\n                redoClonedObject.opacity = signature.opacity;\n                this.pdfViewer.nodePropertyChange(currentAnnotation, { opacity: signature.opacity });\n                this.pdfViewer.fireSignaturePropertiesChange(currentAnnotation.pageIndex, currentAnnotation.signatureName, currentAnnotation.shapeAnnotationType, false, true, false, clonedObject.opacity, redoClonedObject.opacity);\n                this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Opacity', '', clonedObject, redoClonedObject);\n            }\n            if (currentAnnotation.strokeColor !== signature.strokeColor) {\n                redoClonedObject.strokeColor = signature.strokeColor;\n                this.pdfViewer.nodePropertyChange(currentAnnotation, { strokeColor: signature.strokeColor });\n                this.pdfViewer.fireSignaturePropertiesChange(currentAnnotation.pageIndex, currentAnnotation.signatureName, currentAnnotation.shapeAnnotationType, true, false, false, clonedObject.strokeColor, redoClonedObject.strokeColor);\n                this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Stroke', '', clonedObject, redoClonedObject);\n            }\n            if (currentAnnotation.thickness !== signature.thickness) {\n                redoClonedObject.thickness = signature.thickness;\n                this.pdfViewer.nodePropertyChange(currentAnnotation, { thickness: signature.thickness });\n                this.pdfViewer.fireSignaturePropertiesChange(currentAnnotation.pageIndex, currentAnnotation.signatureName, currentAnnotation.shapeAnnotationType, false, false, true, clonedObject.thickness, redoClonedObject.thickness);\n                this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Thickness', '', clonedObject, redoClonedObject);\n            }\n            currentAnnotation.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n            this.pdfViewer.renderDrawing();\n            this.pdfViewerBase.signatureModule.modifySignatureCollection(null, pageNumber, currentAnnotation, true);\n        }\n    };\n    Annotation.prototype.deletComment = function (commentDiv) {\n        if (commentDiv.parentElement.firstChild === commentDiv) {\n            this.deleteAnnotation();\n        }\n        else {\n            this.pdfViewer.annotationModule.stickyNotesAnnotationModule.modifyCommentDeleteProperty(commentDiv.parentElement, commentDiv);\n        }\n    };\n    Annotation.prototype.addReplyComments = function (currentAnnotation, replyComment, commentType) {\n        if (commentType === 'add') {\n            var commentsMainDiv = document.getElementById(currentAnnotation.annotName);\n            this.pdfViewer.annotationModule.stickyNotesAnnotationModule.createCommentDiv(commentsMainDiv);\n            for (var j = 0; j < replyComment.length; j++) {\n                this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                    saveCommentDiv(commentsMainDiv, replyComment[parseInt(j.toString(), 10)]);\n            }\n        }\n        else if (commentType === 'next') {\n            var commentsMainDiv = document.getElementById(currentAnnotation.annotationId);\n            this.selectAnnotation(currentAnnotation);\n            this.pdfViewer.annotationModule.stickyNotesAnnotationModule.saveCommentDiv(commentsMainDiv, replyComment);\n        }\n    };\n    Annotation.prototype.editComments = function (commentId, editComment) {\n        var commentDiv = document.getElementById(commentId);\n        commentDiv.childNodes[1].ej2_instances[0].value = editComment;\n    };\n    /**\n     * Updates the existing properties of the specified annotation object.\n     *\n     * @param {any} annotation - The annotation object that contains the properties to be updated.\n     * The object should include valid annotation properties such as type, bounds, color, opacity, etc.\n     * Modifying these properties will update the annotation in the PDF Viewer accordingly.\n     *\n     * @remarks\n     * This method will apply the changes to the annotation and refresh the viewer to reflect the updated properties.\n     */\n    Annotation.prototype.editAnnotation = function (annotation) {\n        var currentAnnotation;\n        var annotationId;\n        var annotationType;\n        var pageNumber;\n        var isTextMarkupUpdate = false;\n        var textMarkupAnnotation;\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.textMarkupAnnotationModule) &&\n            !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation)) {\n            textMarkupAnnotation = this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n        }\n        if ((textMarkupAnnotation && (!annotation.annotationId || !annotation.uniqueKey) &&\n            (annotation.annotationId === textMarkupAnnotation.annotName))) {\n            currentAnnotation = this.pdfViewer.annotationModule.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n            annotationId = currentAnnotation.annotName;\n            pageNumber = this.pdfViewer.annotationModule.textMarkupAnnotationModule.selectTextMarkupCurrentPage;\n        }\n        else {\n            if (this.pdfViewer.selectedItems.annotations[0]) {\n                currentAnnotation = this.pdfViewer.selectedItems.annotations[0];\n                annotationId = currentAnnotation.annotName;\n                pageNumber = currentAnnotation.pageIndex;\n            }\n        }\n        if (annotation.uniqueKey !== undefined) {\n            currentAnnotation = this.pdfViewer.nameTable[annotation.uniqueKey];\n            if (currentAnnotation && currentAnnotation.annotationSettings &&\n                !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(currentAnnotation.annotationSettings.isLock)) {\n                currentAnnotation.annotationSettings.isLock = annotation.annotationSettings.isLock;\n            }\n            annotationId = currentAnnotation.annotName;\n            pageNumber = currentAnnotation.pageIndex;\n            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isBlazor)()) {\n                if (annotation.allowedInteractions) {\n                    var allowedInteractionsCount = annotation.allowedInteractions.length;\n                    for (var i = 0; i < allowedInteractionsCount; i++) {\n                        if (annotation.allowedInteractions[parseInt(i.toString(), 10)] === 0) {\n                            annotation.allowedInteractions[parseInt(i.toString(), 10)] = _index__WEBPACK_IMPORTED_MODULE_0__.AllowedInteraction.Select;\n                        }\n                        if (annotation.allowedInteractions[parseInt(i.toString(), 10)] === 1) {\n                            annotation.allowedInteractions[parseInt(i.toString(), 10)] = _index__WEBPACK_IMPORTED_MODULE_0__.AllowedInteraction.Move;\n                        }\n                        if (annotation.allowedInteractions[parseInt(i.toString(), 10)] === 2) {\n                            annotation.allowedInteractions[parseInt(i.toString(), 10)] = _index__WEBPACK_IMPORTED_MODULE_0__.AllowedInteraction.Resize;\n                        }\n                        if (annotation.allowedInteractions[parseInt(i.toString(), 10)] === 3) {\n                            annotation.allowedInteractions[parseInt(i.toString(), 10)] = _index__WEBPACK_IMPORTED_MODULE_0__.AllowedInteraction.Delete;\n                        }\n                        if (annotation.allowedInteractions[parseInt(i.toString(), 10)] === 4) {\n                            annotation.allowedInteractions[parseInt(i.toString(), 10)] = _index__WEBPACK_IMPORTED_MODULE_0__.AllowedInteraction.PropertyChange;\n                        }\n                        if (annotation.allowedInteractions[parseInt(i.toString(), 10)] === 5) {\n                            annotation.allowedInteractions[parseInt(i.toString(), 10)] = _index__WEBPACK_IMPORTED_MODULE_0__.AllowedInteraction.None;\n                        }\n                    }\n                }\n            }\n            currentAnnotation.allowedInteractions = annotation.allowedInteractions ?\n                annotation.allowedInteractions : this.updateAnnotationAllowedInteractions(annotation);\n        }\n        if (!currentAnnotation) {\n            if (annotation.shapeAnnotationType === 'sticky' && annotation.annotationId !== undefined) {\n                currentAnnotation = this.pdfViewer.nameTable[annotation.annotationId];\n                if (currentAnnotation) {\n                    currentAnnotation.annotationSettings.isLock = annotation.annotationSettings.isLock;\n                    annotationId = currentAnnotation.annotName;\n                    pageNumber = currentAnnotation.pageIndex;\n                }\n            }\n        }\n        if (annotation.shapeAnnotationType === 'textMarkup') {\n            currentAnnotation = this.pdfViewer.annotationModule.textMarkupAnnotationModule.\n                getAnnotations(annotation.pageNumber, annotation);\n            for (var i = 0; i < currentAnnotation.length; i++) {\n                if (annotation.annotationId === currentAnnotation[parseInt(i.toString(), 10)].annotName) {\n                    isTextMarkupUpdate = true;\n                    currentAnnotation = currentAnnotation[parseInt(i.toString(), 10)];\n                    currentAnnotation.isPrint = annotation.isPrint;\n                    this.textMarkupAnnotationModule.currentTextMarkupAnnotation = currentAnnotation;\n                    this.textMarkupAnnotationModule.selectTextMarkupCurrentPage = currentAnnotation.pageNumber;\n                    currentAnnotation.allowedInteractions = annotation.allowedInteractions;\n                    pageNumber = currentAnnotation.pageNumber;\n                    annotationId = annotation.annotationId;\n                    break;\n                }\n            }\n        }\n        if (currentAnnotation) {\n            var clonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            var redoClonedObject = (0,_drawing_drawing_util__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(currentAnnotation);\n            if (annotation.shapeAnnotationType === 'textMarkup') {\n                annotationType = 'textMarkup';\n            }\n            if (annotation && annotation.isCommentLock === true) {\n                currentAnnotation.isCommentLock = annotation.isCommentLock;\n            }\n            if (annotation && JSON.stringify(currentAnnotation.annotationSelectorSettings) !== JSON.stringify(annotation.annotationSelectorSettings) && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.type) && annotation.type !== 'TextMarkup') || (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.shapeAnnotationType) && annotation.shapeAnnotationType !== 'textMarkup'))) {\n                currentAnnotation.annotationSelectorSettings = annotation.annotationSelectorSettings;\n                redoClonedObject.annotationSelectorSettings = annotation.annotationSelectorSettings;\n                this.pdfViewer.nodePropertyChange(currentAnnotation, { annotationSelectorSettings: annotation.annotationSelectorSettings });\n                this.triggerAnnotationPropChange(currentAnnotation, false, true, false, false);\n            }\n            if (annotation.comments) {\n                for (var j = 0; j < annotation.comments.length; j++) {\n                    if (annotation.comments[parseInt(j.toString(), 10)].isLock === true) {\n                        if (annotationType) {\n                            currentAnnotation.comments = annotation.comments;\n                            currentAnnotation.comments[parseInt(j.toString(), 10)].isLock =\n                                annotation.comments[parseInt(j.toString(), 10)].isLock;\n                        }\n                        else {\n                            currentAnnotation.properties.comments = annotation.comments;\n                            currentAnnotation.properties.comments[parseInt(j.toString(), 10)].isLock =\n                                annotation.comments[parseInt(j.toString(), 10)].isLock;\n                        }\n                    }\n                }\n            }\n            if (annotation && annotation.note !== '' && annotation.note !== undefined) {\n                if (annotationType) {\n                    currentAnnotation.note = annotation.note;\n                    this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        addTextToComments(currentAnnotation.annotName, currentAnnotation.note);\n                }\n                else {\n                    currentAnnotation.notes = annotation.note;\n                    this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                        addTextToComments(currentAnnotation.annotName, currentAnnotation.notes);\n                }\n            }\n            else {\n                if (annotation && annotation.isCommentLock && ((annotation.type && annotation.type !== 'FreeText') || annotation.shapeAnnotationType !== 'FreeText')) {\n                    this.pdfViewer.annotationModule.stickyNotesAnnotationModule.addTextToComments(currentAnnotation.annotName, '  ');\n                }\n            }\n            if (annotation.commentId && annotation.editComment && annotation.commentType === 'edit') {\n                this.editComments(annotation.commentId, annotation.editComment);\n            }\n            if (annotation.replyComment && annotation.commentType === 'add') {\n                this.addReplyComments(currentAnnotation, annotation.replyComment, annotation.commentType);\n                this.pdfViewer.annotationCollection[0].note = annotation.note;\n            }\n            if (annotation.nextComment && annotation.commentType === 'next') {\n                this.addReplyComments(annotation, annotation.nextComment, annotation.commentType);\n            }\n            if (annotation.note === '' && annotation.commentType === 'delete') {\n                var commentDiv = document.getElementById(annotation.annotationId);\n                this.deletComment(commentDiv);\n            }\n            if (annotation.comments && annotation.commentType === 'delete' && annotation.note !== '') {\n                var repliesDiv = document.querySelectorAll('.e-pv-more-options-button');\n                if (repliesDiv) {\n                    for (var i = 0; i < repliesDiv.length; i++) {\n                        if (repliesDiv[parseInt(i.toString(), 10)].style.visibility === 'visible') {\n                            var activeReplyDiv = repliesDiv[parseInt(i.toString(), 10)].parentElement.nextSibling;\n                            var isLocked = this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                                checkIslockProperty(activeReplyDiv);\n                            if (activeReplyDiv && !isLocked) {\n                                this.deletComment(activeReplyDiv.parentElement);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            if (annotation.type === 'TextMarkup' || annotation.shapeAnnotationType === 'textMarkup') {\n                if (currentAnnotation.annotationSettings && annotation.annotationSettings) {\n                    if (currentAnnotation.annotationSettings.isLock !== annotation.annotationSettings.isLock) {\n                        var pageAnnotations = this.textMarkupAnnotationModule.modifyAnnotationProperty('AnnotationSettings', annotation.annotationSettings.isLock, null);\n                        this.textMarkupAnnotationModule.manageAnnotations(pageAnnotations, this.textMarkupAnnotationModule.selectTextMarkupCurrentPage);\n                    }\n                }\n                if (annotation && JSON.stringify(currentAnnotation.annotationSelectorSettings) !==\n                    JSON.stringify(annotation.annotationSelectorSettings)) {\n                    var pageAnnotations = this.textMarkupAnnotationModule.modifyAnnotationProperty('AnnotationSelectorSettings', annotation.annotationSelectorSettings, null);\n                    this.textMarkupAnnotationModule.manageAnnotations(pageAnnotations, this.textMarkupAnnotationModule.selectTextMarkupCurrentPage);\n                }\n                if (currentAnnotation.opacity !== annotation.opacity) {\n                    this.pdfViewer.annotationModule.textMarkupAnnotationModule.modifyOpacityProperty(null, annotation.opacity);\n                }\n                if (currentAnnotation.color !== annotation.color) {\n                    this.pdfViewer.annotationModule.textMarkupAnnotationModule.modifyColorProperty(annotation.color);\n                }\n                if (JSON.stringify(currentAnnotation.bounds) !== JSON.stringify(annotation.bounds)) {\n                    this.pdfViewer.annotationModule.textMarkupAnnotationModule.modifyBoundsProperty(annotation.bounds);\n                }\n                annotationType = 'textMarkup';\n                if (isTextMarkupUpdate) {\n                    this.textMarkupAnnotationModule.selectTextMarkupCurrentPage = null;\n                }\n            }\n            else if (annotation && annotation.stampAnnotationType === 'image' && annotation.shapeAnnotationType === 'stamp' && annotation.stampAnnotationPath) {\n                annotationType = 'stamp';\n                if (currentAnnotation.data !== annotation.stampAnnotationPath) {\n                    currentAnnotation.data = annotation.stampAnnotationPath;\n                    currentAnnotation.wrapper.children[0].imageSource = annotation.stampAnnotationPath;\n                    this.pdfViewer.renderDrawing(null, pageNumber);\n                }\n                if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.opacity)) && currentAnnotation.opacity !== annotation.opacity) {\n                    redoClonedObject.opacity = annotation.opacity;\n                    this.annotationPropertyChange(currentAnnotation, annotation.opacity, 'Shape Opacity', clonedObject, redoClonedObject);\n                }\n                this.calculateAnnotationBounds(currentAnnotation, annotation);\n            }\n            else if (annotation.type === 'StickyNotes' || annotation.type === 'Stamp' || annotation.shapeAnnotationType === 'sticky' || annotation.shapeAnnotationType === 'stamp') {\n                if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.opacity)) && currentAnnotation.opacity !== annotation.opacity) {\n                    redoClonedObject.opacity = annotation.opacity;\n                    this.annotationPropertyChange(currentAnnotation, annotation.opacity, 'Shape Opacity', clonedObject, redoClonedObject);\n                }\n                this.calculateAnnotationBounds(currentAnnotation, annotation);\n                if (annotation.type === 'StickyNotes' || annotation.shapeAnnotationType === 'sticky') {\n                    annotationType = 'sticky';\n                }\n                else {\n                    annotationType = 'stamp';\n                }\n            }\n            else if (annotation.type === 'Ink' || annotation.type === 'Shape' || annotation.type === 'Measure' || annotation.shapeAnnotationType === 'Line' || annotation.shapeAnnotationType === 'Square' || annotation.shapeAnnotationType === 'Circle' || annotation.shapeAnnotationType === 'Polygon' || annotation.shapeAnnotationType === 'Polyline' || annotation.shapeAnnotationType === 'Ink') {\n                if (annotation.shapeAnnotationType === 'Square' || annotation.shapeAnnotationType === 'Circle' || annotation.shapeAnnotationType === 'Radius' || annotation.shapeAnnotationType === 'Ink') {\n                    this.calculateAnnotationBounds(currentAnnotation, annotation);\n                }\n                if (!((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.opacity)) && currentAnnotation.opacity !== annotation.opacity) {\n                    redoClonedObject.opacity = annotation.opacity;\n                    this.annotationPropertyChange(currentAnnotation, annotation.opacity, 'Shape Opacity', clonedObject, redoClonedObject);\n                }\n                if (annotation.fillColor && currentAnnotation.fillColor !== annotation.fillColor) {\n                    redoClonedObject.fillColor = annotation.fillColor;\n                    if (annotation.labelSettings && annotation.labelSettings.fillColor) {\n                        annotation.labelSettings.fillColor = annotation.fillColor;\n                    }\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { fillColor: annotation.fillColor });\n                    this.triggerAnnotationPropChange(currentAnnotation, true, false, false, false);\n                    this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Fill', '', clonedObject, redoClonedObject);\n                }\n                if (annotation.strokeColor && currentAnnotation.strokeColor !== annotation.strokeColor) {\n                    redoClonedObject.strokeColor = annotation.strokeColor;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { strokeColor: annotation.strokeColor });\n                    this.triggerAnnotationPropChange(currentAnnotation, false, true, false, false);\n                    this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Stroke', '', clonedObject, redoClonedObject);\n                }\n                if (annotation.leaderLength && currentAnnotation.leaderHeight !== annotation.leaderLength) {\n                    redoClonedObject.leaderHeight = annotation.leaderLength;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { leaderHeight: annotation.leaderLength });\n                }\n                if (annotation.thickness && currentAnnotation.thickness !== annotation.thickness) {\n                    redoClonedObject.thickness = annotation.thickness;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { thickness: annotation.thickness });\n                    this.triggerAnnotationPropChange(currentAnnotation, false, false, true, false);\n                    this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Thickness', '', clonedObject, redoClonedObject);\n                }\n                if (currentAnnotation.author !== annotation.author) {\n                    redoClonedObject.author = annotation.author;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { author: annotation.author });\n                    this.triggerAnnotationPropChange(currentAnnotation, false, true, false, false);\n                }\n                if (currentAnnotation.subject !== annotation.subject) {\n                    redoClonedObject.subject = annotation.subject;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { subject: annotation.subject });\n                    this.triggerAnnotationPropChange(currentAnnotation, false, true, false, false);\n                }\n                if (currentAnnotation.modifiedDate !== annotation.modifiedDate) {\n                    redoClonedObject.modifiedDate = annotation.modifiedDate;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { modifiedDate: annotation.modifiedDate });\n                }\n                if (currentAnnotation.subject !== annotation.subject) {\n                    redoClonedObject.subject = annotation.subject;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { subject: annotation.subject });\n                    this.triggerAnnotationPropChange(currentAnnotation, false, true, false, false);\n                    this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Stroke', '', clonedObject, redoClonedObject);\n                }\n                if (this.pdfViewer.enableShapeLabel && currentAnnotation.fontColor !== annotation.fontColor) {\n                    redoClonedObject.fontColor = annotation.fontColor;\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { fontColor: annotation.fontColor });\n                }\n                if (this.pdfViewer.enableShapeLabel && annotation.labelSettings && annotation.labelSettings.fillColor) {\n                    if (currentAnnotation.labelFillColor !== annotation.labelSettings.fillColor) {\n                        redoClonedObject.labelFillColor = annotation.labelSettings.fillColor;\n                        this.pdfViewer.nodePropertyChange(currentAnnotation, { labelFillColor: annotation.labelSettings.fillColor });\n                    }\n                }\n                if (annotation.shapeAnnotationType === 'Line' || annotation.shapeAnnotationType === 'Polyline' || annotation.shapeAnnotationType === 'Polygon') {\n                    if (JSON.stringify(currentAnnotation.vertexPoints) !== JSON.stringify(annotation.vertexPoints)) {\n                        currentAnnotation.vertexPoints = annotation.vertexPoints;\n                        this.pdfViewer.nodePropertyChange(currentAnnotation, { vertexPoints: annotation.vertexPoints });\n                    }\n                }\n                if (annotation.subType === 'Line' || annotation.subType === 'Arrow' || annotation.subType === 'Distance' || annotation.subType === 'Perimeter') {\n                    var isSourceDecoraterShapesChanged = false;\n                    var isTargetDecoraterShapesChanged = false;\n                    var isBorderDashArrayChanged = false;\n                    clonedObject.lineHeadStart = currentAnnotation.sourceDecoraterShapes;\n                    clonedObject.lineHeadEnd = currentAnnotation.taregetDecoraterShapes;\n                    redoClonedObject.lineHeadStart = annotation.lineHeadStartStyle;\n                    redoClonedObject.lineHeadEnd = annotation.lineHeadEndStyle;\n                    redoClonedObject.borderDashArray = annotation.borderDashArray;\n                    if (currentAnnotation.taregetDecoraterShapes !== annotation.lineHeadEndStyle) {\n                        isTargetDecoraterShapesChanged = true;\n                    }\n                    if (currentAnnotation.sourceDecoraterShapes !== annotation.lineHeadStartStyle) {\n                        isSourceDecoraterShapesChanged = true;\n                    }\n                    if (currentAnnotation.borderDashArray !== annotation.borderDashArray) {\n                        isBorderDashArrayChanged = true;\n                    }\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, { sourceDecoraterShapes: annotation.lineHeadStartStyle,\n                        taregetDecoraterShapes: annotation.lineHeadEndStyle, borderDashArray: annotation.borderDashArray });\n                    this.triggerAnnotationPropChange(currentAnnotation, false, false, false, false, isSourceDecoraterShapesChanged, isTargetDecoraterShapesChanged, isBorderDashArrayChanged);\n                    this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Line properties change', '', clonedObject, redoClonedObject);\n                }\n                if (annotation.type === 'Shape' || annotation.shapeAnnotationType === 'Line' || annotation.shapeAnnotationType === 'Square' || annotation.shapeAnnotationType === 'Circle' || annotation.shapeAnnotationType === 'Polygon') {\n                    annotationType = 'shape';\n                }\n                if (annotation.type === 'Ink' || annotation.shapeAnnotationType === 'Ink') {\n                    annotationType = 'ink';\n                }\n                if (annotation.type === 'Measure' || annotation.indent === 'LineDimension' || annotation.indent === 'PolyLineDimension' || annotation.indent === 'PolygonDimension' || annotation.indent === 'PolygonRadius' || annotation.indent === 'PolygonVolume') {\n                    annotationType = 'shape_measure';\n                }\n                if (annotation.labelSettings && this.pdfViewer.enableShapeLabel) {\n                    this.updateFreeTextProperties(currentAnnotation);\n                    this.pdfViewer.nodePropertyChange(currentAnnotation, {\n                        labelOpacity: annotation.labelSettings.opacity, fontColor: annotation.labelSettings.fontColor,\n                        fontSize: annotation.labelSettings.fontSize, fontFamily: annotation.labelSettings.fontFamily,\n                        labelContent: currentAnnotation.notes, labelFillColor: annotation.labelSettings.fillColor\n                    });\n                }\n                if (this.pdfViewer.enableShapeLabel && annotation.calibrate && annotation.calibrate.depth) {\n                    if (this.pdfViewer.annotationModule.measureAnnotationModule.volumeDepth !== annotation.calibrate.depth) {\n                        this.pdfViewer.annotationModule.measureAnnotationModule.volumeDepth = annotation.calibrate.depth;\n                        currentAnnotation.notes = this.pdfViewer.annotationModule.measureAnnotationModule.\n                            calculateVolume(currentAnnotation.vertexPoints, currentAnnotation.id, currentAnnotation.pageIndex);\n                        currentAnnotation.labelContent = currentAnnotation.notes;\n                        if (annotation.labelSettings && annotation.labelSettings.labelContent) {\n                            annotation.labelSettings.labelContent = currentAnnotation.notes;\n                        }\n                        this.pdfViewer.nodePropertyChange(currentAnnotation, { labelContent: currentAnnotation.labelContent });\n                        this.pdfViewer.annotationModule.stickyNotesAnnotationModule.\n                            addTextToComments(currentAnnotation.annotName, currentAnnotation.notes);\n                    }\n                }\n            }\n            else if (annotation.type === 'FreeText' || annotation.shapeAnnotationType === 'FreeText') {\n                annotationType = 'freetext';\n                if (this.pdfViewer.freeTextSettings.enableAutoFit && currentAnnotation.dynamicText !== annotation.content) {\n                    var canvas = this.pdfViewerBase.getAnnotationCanvas('_annotationCanvas_', currentAnnotation.pageIndex);\n                    var context = canvas.getContext('2d');\n                    var fontSize = annotation.fontSize;\n                    var font = void 0;\n                    var fontFamily = annotation.fontFamily;\n                    var zoomFactor = this.pdfViewerBase.getZoomFactor();\n                    if (annotation.font.isBold) {\n                        font = 'bold' + ' ' + fontSize + 'px' + ' ' + fontFamily;\n                    }\n                    else {\n                        font = fontSize + 'px' + ' ' + fontFamily;\n                    }\n                    context.font = font;\n                    var characterLength = 8;\n                    var highestTextNode = '';\n                    var textNodes = [];\n                    var textboxValue = annotation.content ? annotation.content : annotation.dynamicText;\n                    if (textboxValue.indexOf('\\n') > -1) {\n                        textNodes = textboxValue.split('\\n');\n                        for (var j = 0; j < textNodes.length; j++) {\n                            var textNodeData = context.measureText(textNodes[parseInt(j.toString(), 10)]);\n                            var highestTextNodeData = context.measureText(highestTextNode);\n                            if (textNodeData.width > highestTextNodeData.width) {\n                                highestTextNode = textNodes[parseInt(j.toString(), 10)];\n                            }\n                        }\n                    }\n                    else {\n                        highestTextNode = textboxValue;\n                    }\n                    var textwidth = context.measureText(highestTextNode);\n                    annotation.bounds.width = Math.ceil(textwidth.width + ((characterLength + 1) * 2));\n                    var pageDiv = this.pdfViewerBase.getElement('_pageDiv_' + (annotation.pageIndex));\n                    var maxWidth = pageDiv.clientWidth - (annotation.bounds.left * zoomFactor);\n                    if (annotation.bounds.width > maxWidth) {\n                        annotation.bounds.width = maxWidth / zoomFactor;\n                    }\n                    var height = annotation.bounds.height;\n                    annotation.bounds.height = height >= currentAnnotation.bounds.height ? height : currentAnnotation.bounds.height;\n                }\n                this.calculateAnnotationBounds(currentAnnotation, annotation);\n                if (annotation.opacity && currentAnnotation.opacity !== annotation.opacity) {\n                    this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n                }\n                if (annotation.fillColor && currentAnnotation.fillColor !== annotation.fillColor) {\n                    redoClonedObject.fillColor = annotation.fillColor;\n                    this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'Shape Fill', '', clonedObject, redoClonedObject);\n                    this.triggerAnnotationPropChange(currentAnnotation, true, false, false, false);\n                }\n                if (annotation.fontColor && currentAnnotation.fontColor !== annotation.fontColor) {\n                    redoClonedObject.fontColor = annotation.fontColor;\n                    this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, 'fontColor', '', clonedObject, redoClonedObject);\n                    this.triggerAnnotationPropChange(currentAnnotation, false, false, false, false);\n                }\n                if (annotation.strokeColor && currentAnnotation.strokeColor !== annotation.strokeColor) {\n                    this.triggerAnnotationPropChange(currentAnnotation, false, true, false, false);\n                }\n                if (annotation.thickness && currentAnnotation.thickness !== annotation.thickness) {\n                    this.triggerAnnotationPropChange(currentAnnotation, false, false, true, false);\n                }\n                var isCurrentAnnotationLock = currentAnnotation.isLock;\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.isLock)) {\n                    isCurrentAnnotationLock = annotation.isLock;\n                }\n                else if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.annotationSettings.isLock)) {\n                    isCurrentAnnotationLock = annotation.annotationSettings.isLock;\n                }\n                currentAnnotation.annotationSettings.isLock = isCurrentAnnotationLock;\n                currentAnnotation.isLock = isCurrentAnnotationLock;\n                annotation.content = (annotation.content && annotation.content === annotation.dynamicText) ?\n                    annotation.content : annotation.dynamicText;\n                if (annotation.content && currentAnnotation.dynamicText !== annotation.content) {\n                    this.triggerAnnotationPropChange(currentAnnotation, false, false, false, false, false, false, false, true, currentAnnotation.dynamicText, annotation.content);\n                }\n                this.pdfViewer.nodePropertyChange(currentAnnotation, {\n                    opacity: annotation.opacity, fontColor: annotation.fontColor, fontSize: annotation.fontSize,\n                    fontFamily: annotation.fontFamily,\n                    dynamicText: annotation.content, fillColor: annotation.fillColor, textAlign: annotation.textAlign,\n                    strokeColor: annotation.strokeColor, thickness: annotation.thickness,\n                    font: annotation.fontStyle ? this.setFreeTextFontStyle(annotation.fontStyle) :\n                        this.setFreeTextFontStyle(annotation.font),\n                    isReadonly: annotation.isReadonly\n                });\n                if (annotation.content && currentAnnotation) {\n                    this.updateAnnotationComments(currentAnnotation.annotName, annotation.content);\n                }\n                var newCommentDiv = document.getElementById(this.pdfViewer.element.id + '_commenttextbox_editor');\n                var commentObj = new _syncfusion_ej2_inplace_editor__WEBPACK_IMPORTED_MODULE_11__.InPlaceEditor({\n                    value: annotation.content\n                });\n                commentObj.appendTo(newCommentDiv);\n            }\n            currentAnnotation.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n            if (currentAnnotation.customData !== annotation.customData) {\n                currentAnnotation.customData = annotation.customData;\n            }\n            currentAnnotation.isPrint = annotation.isPrint;\n            if (annotation.type !== 'TextMarkup' && annotation.shapeAnnotationType !== 'textMarkup') {\n                this.pdfViewer.renderDrawing();\n            }\n            this.updateCollection(annotationId, pageNumber, annotation, annotationType);\n        }\n    };\n    Annotation.prototype.annotationPropertyChange = function (currentAnnotation, opacity, actionString, clonedObject, redoClonedObject) {\n        this.pdfViewer.nodePropertyChange(currentAnnotation, { opacity: opacity });\n        this.triggerAnnotationPropChange(currentAnnotation, false, false, false, true);\n        this.pdfViewer.annotation.addAction(currentAnnotation.pageIndex, null, currentAnnotation, actionString, '', clonedObject, redoClonedObject);\n    };\n    Annotation.prototype.calculateAnnotationBounds = function (currentAnnotation, annotation) {\n        var bounds = this.pdfViewerBase.convertBounds(currentAnnotation.wrapper.bounds);\n        var annotBounds = this.pdfViewerBase.convertBounds(annotation.bounds);\n        if (bounds && annotBounds) {\n            if (JSON.stringify(bounds) !== JSON.stringify(annotBounds) && (Math.abs(bounds.Y -\n                annotBounds.Y) > 2) ||\n                (Math.abs(bounds.X - annotBounds.X) > 2) ||\n                (Math.abs(bounds.Width - annotBounds.Width) > 2) ||\n                (Math.abs(bounds.Height - annotBounds.Height) > 2)) {\n                var annotationBounds = { x: annotBounds.X + (annotBounds.Width / 2),\n                    y: annotBounds.Y + (annotBounds.Height / 2),\n                    width: annotBounds.Width, height: annotBounds.Height };\n                this.pdfViewer.nodePropertyChange(currentAnnotation, { bounds: annotationBounds });\n                this.triggerAnnotationPropChange(currentAnnotation, false, false, false, false);\n                this.pdfViewer.renderSelector(currentAnnotation.pageIndex, this.pdfViewer.annotationSelectorSettings);\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.updateFreeTextProperties = function (annotation) {\n        if (annotation.labelSettings) {\n            if (annotation.labelSettings.fillColor) {\n                annotation.labelFillColor = annotation.labelSettings.fillColor;\n            }\n            if (annotation.labelSettings.fontColor) {\n                annotation.fontColor = annotation.labelSettings.fontColor;\n            }\n            if (annotation.labelSettings.fontSize) {\n                annotation.fontSize = annotation.labelSettings.fontSize;\n            }\n            if (annotation.labelSettings.fontFamily) {\n                annotation.fontFamily = annotation.labelSettings.fontFamily;\n            }\n            if (annotation.labelSettings.opacity) {\n                annotation.labelOpacity = annotation.labelSettings.opacity;\n            }\n            if (annotation.labelSettings.labelContent) {\n                annotation.labelContent = annotation.labelSettings.labelContent;\n            }\n        }\n    };\n    Annotation.prototype.updateAnnotationComments = function (annotationId, noteContent) {\n        var commentsDiv = document.getElementById(annotationId);\n        if (commentsDiv && commentsDiv.childNodes) {\n            if (commentsDiv.childNodes[0].ej2_instances) {\n                commentsDiv.childNodes[0].ej2_instances[0].value = noteContent;\n            }\n            else if (commentsDiv.childNodes[0].childNodes && commentsDiv.childNodes[0].childNodes[1].ej2_instances) {\n                commentsDiv.childNodes[0].childNodes[1].ej2_instances[0].value = noteContent;\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @param {any} currentAnnotation - currentAnnotation\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.addFreeTextProperties = function (annotation, currentAnnotation) {\n        if (this.pdfViewer.enableShapeLabel && annotation && currentAnnotation) {\n            currentAnnotation.labelSettings = {\n                fontColor: annotation.fontColor, fontSize: annotation.fontSize, fontFamily: annotation.fontFamily,\n                opacity: annotation.labelOpacity, labelContent: annotation.labelContent, fillColor: annotation.labelFillColor\n            };\n        }\n    };\n    Annotation.prototype.updateMeasurementSettings = function () {\n        if (this.pdfViewer.enableAnnotation && this.pdfViewer.enableMeasureAnnotation) {\n            var ratioString = '1 ' + this.pdfViewer.measurementSettings.conversionUnit + ' = ' + this.pdfViewer.measurementSettings.scaleRatio + ' ' + this.pdfViewer.measurementSettings.displayUnit;\n            this.measureAnnotationModule.updateMeasureValues(ratioString, this.pdfViewer.measurementSettings.displayUnit, this.pdfViewer.measurementSettings.conversionUnit, this.pdfViewer.measurementSettings.depth);\n        }\n    };\n    Annotation.prototype.updateCollection = function (annotationId, pageNumber, annotation, annotationType) {\n        var annotationCollection;\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_' + annotationType);\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_' + annotationType];\n        }\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            var index = this.getPageCollection(annotObject, pageNumber);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotationCollection = annotObject[parseInt(index.toString(), 10)].annotations;\n                if (annotationCollection !== null) {\n                    for (var i = 0; i < annotationCollection.length; i++) {\n                        if (annotationCollection[parseInt(i.toString(), 10)].annotName === annotationId) {\n                            var newAnnot = this.modifyAnnotationProperties(annotationCollection[parseInt(i.toString(), 10)], annotation, annotationType);\n                            annotationCollection[parseInt(i.toString(), 10)] = newAnnot;\n                            this.storeAnnotationCollections(newAnnot, pageNumber);\n                        }\n                    }\n                    if (!this.pdfViewerBase.isStorageExceed) {\n                        _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_' + annotationType);\n                    }\n                    if (annotObject[parseInt(index.toString(), 10)]) {\n                        annotObject[parseInt(index.toString(), 10)].annotations = annotationCollection;\n                    }\n                    var annotationStringified = JSON.stringify(annotObject);\n                    if (this.pdfViewerBase.isStorageExceed) {\n                        this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_' + annotationType] = annotationStringified;\n                    }\n                    else {\n                        _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_' + annotationType, annotationStringified);\n                    }\n                }\n            }\n        }\n    };\n    Annotation.prototype.modifyAnnotationProperties = function (newAnnotation, annotation, annotationType) {\n        var isModifyStatus = false;\n        if (annotation && annotation.isCommentLock === true) {\n            newAnnotation.isCommentLock = annotation.isCommentLock;\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.annotationSettings) &&\n            annotation.annotationSettings.isLock === true && annotation.isCommentLock === true) {\n            isModifyStatus = true;\n        }\n        if (annotation.comments) {\n            for (var j = 0; j < annotation.comments.length; j++) {\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.comments[parseInt(j.toString(), 10)].isLock) &&\n                    !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(newAnnotation.comments[parseInt(j.toString(), 10)])) {\n                    newAnnotation.comments[parseInt(j.toString(), 10)].isLock = annotation.comments[parseInt(j.toString(), 10)].isLock;\n                }\n            }\n        }\n        if (annotation && annotation.note !== '' && annotation.note !== undefined) {\n            newAnnotation.note = annotation.note;\n        }\n        if (annotation.commentId && annotation.editComment && annotation.commentType === 'edit') {\n            var commentDiv = document.getElementById(annotation.commentId);\n            if (annotation.annotationId === annotation.commentId) {\n                newAnnotation.note = commentDiv.childNodes[1].ej2_instances[0].value;\n            }\n            for (var j = 0; j < annotation.comments.length; j++) {\n                if (annotation.comments[parseInt(j.toString(), 10)].annotName === annotation.commentId) {\n                    newAnnotation.comments[parseInt(j.toString(), 10)].note = commentDiv.childNodes[1].ej2_instances[0].value;\n                }\n            }\n        }\n        if (annotationType === 'textMarkup') {\n            newAnnotation.opacity = annotation.opacity;\n            newAnnotation.color = annotation.color;\n            newAnnotation.allowedInteractions = annotation.allowedInteractions;\n            newAnnotation.annotationSettings = annotation.annotationSettings;\n        }\n        else if (annotationType === 'sticky' || annotationType === 'stamp') {\n            if (annotation.bounds) {\n                newAnnotation.bounds = annotation.bounds;\n            }\n            newAnnotation.opacity = annotation.opacity;\n            newAnnotation.annotationSettings = annotation.annotationSettings;\n            newAnnotation.allowedInteractions = annotation.allowedInteractions;\n            if (annotation.stampAnnotationPath) {\n                newAnnotation.stampAnnotationPath = annotation.stampAnnotationPath;\n            }\n        }\n        else if (annotationType === 'ink') {\n            if (annotation.bounds) {\n                newAnnotation.bounds = annotation.bounds;\n            }\n            newAnnotation.opacity = annotation.opacity;\n            newAnnotation.strokeColor = annotation.strokeColor;\n            newAnnotation.thickness = annotation.thickness;\n            newAnnotation.annotationSettings = annotation.annotationSettings;\n            newAnnotation.allowedInteractions = annotation.allowedInteractions;\n        }\n        else if (annotationType === 'shape' || annotationType === 'shape_measure') {\n            if (annotation.subType === 'Line' || annotation.subType === 'Arrow' || annotation.subType === 'Distance' ||\n                annotation.subType === 'Perimeter') {\n                if (annotation.bounds) {\n                    newAnnotation.bounds = annotation.bounds;\n                }\n                if (annotation.vertexPoints) {\n                    newAnnotation.vertexPoints = annotation.vertexPoints;\n                }\n                newAnnotation.opacity = annotation.opacity;\n                newAnnotation.fillColor = annotation.fillColor;\n                newAnnotation.strokeColor = annotation.strokeColor;\n                newAnnotation.thickness = annotation.thickness;\n                newAnnotation.borderDashArray = annotation.borderDashArray;\n                newAnnotation.lineHeadStart = this.getArrowTypeForCollection(annotation.lineHeadStartStyle);\n                newAnnotation.lineHeadEnd = this.getArrowTypeForCollection(annotation.lineHeadEndStyle);\n                newAnnotation.annotationSettings = annotation.annotationSettings;\n                newAnnotation.allowedInteractions = annotation.allowedInteractions;\n            }\n            else {\n                if (annotation.bounds) {\n                    newAnnotation.bounds = annotation.bounds;\n                }\n                if (annotation.vertexPoints) {\n                    newAnnotation.vertexPoints = annotation.vertexPoints;\n                }\n                newAnnotation.opacity = annotation.opacity;\n                newAnnotation.fillColor = annotation.fillColor;\n                newAnnotation.strokeColor = annotation.strokeColor;\n                newAnnotation.thickness = annotation.thickness;\n                newAnnotation.annotationSettings = annotation.annotationSettings;\n                newAnnotation.allowedInteractions = annotation.allowedInteractions;\n                if (annotation.calibrate) {\n                    if (newAnnotation.annotName === annotation.annotationId) {\n                        if (newAnnotation.calibrate.depth !== annotation.calibrate.depth) {\n                            newAnnotation.calibrate.depth = annotation.calibrate.depth;\n                            this.pdfViewer.annotationModule.measureAnnotationModule.volumeDepth = annotation.calibrate.depth;\n                            newAnnotation.note = this.pdfViewer.annotationModule.measureAnnotationModule.\n                                calculateVolume(newAnnotation.vertexPoints);\n                        }\n                    }\n                }\n            }\n            if (this.pdfViewer.enableShapeLabel && annotation.labelSettings) {\n                var text = annotation.labelSettings.labelContent;\n                newAnnotation.note = text;\n                newAnnotation.fontSize = annotation.labelSettings.fontSize;\n                newAnnotation.labelFillColor = annotation.labelSettings.fillColor;\n                if (newAnnotation.labelContent) {\n                    newAnnotation.labelContent = text;\n                }\n                if (newAnnotation.labelSettings) {\n                    newAnnotation.labelSettings = annotation.labelSettings;\n                }\n                this.updateAnnotationComments(newAnnotation.annotName, text);\n            }\n        }\n        else if (annotationType === 'freetext') {\n            if (annotation.bounds) {\n                newAnnotation.bounds = annotation.bounds;\n            }\n            newAnnotation.opacity = annotation.opacity;\n            newAnnotation.strokeColor = annotation.strokeColor;\n            newAnnotation.thickness = annotation.thickness;\n            if (annotation.content) {\n                newAnnotation.dynamicText = annotation.content;\n            }\n            newAnnotation.fontFamily = annotation.fontFamily;\n            newAnnotation.fontSize = annotation.fontSize;\n            newAnnotation.fontColor = annotation.fontColor;\n            newAnnotation.fillColor = annotation.fillColor;\n            newAnnotation.font = annotation.font ? annotation.font : annotation.fontStyle;\n            newAnnotation.textAlign = annotation.textAlign;\n            newAnnotation.annotationSettings = annotation.annotationSettings;\n            newAnnotation.allowedInteractions = annotation.allowedInteractions;\n            newAnnotation.isReadonly = annotation.isReadonly;\n        }\n        newAnnotation.author = annotation.author;\n        newAnnotation.customData = annotation.customData;\n        newAnnotation.subject = annotation.subject;\n        if (isModifyStatus) {\n            newAnnotation.modifiedDate = annotation.modifiedDate;\n        }\n        else {\n            newAnnotation.modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n        }\n        newAnnotation.isPrint = annotation.isPrint;\n        if (annotation.annotationSettings && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.annotationSettings.isLock)) {\n            newAnnotation.isLocked = annotation.annotationSettings.isLock;\n        }\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(annotation.annotationSelectorSettings) && (newAnnotation.annotationSelectorSettings !==\n            annotation.annotationSelectorSettings)) {\n            newAnnotation.annotationSelectorSettings = annotation.annotationSelectorSettings;\n        }\n        return newAnnotation;\n    };\n    /**\n     * @param {string} annotationType - annotationType\n     * @param {string} annotationSubType - annotationSubType\n     * @private\n     * @returns {string} - string\n     */\n    Annotation.prototype.updateAnnotationAuthor = function (annotationType, annotationSubType) {\n        var annotationAuthor;\n        if (annotationType === 'sticky') {\n            annotationAuthor = (this.pdfViewer.stickyNotesSettings.author !== 'Guest') ? this.pdfViewer.stickyNotesSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n            if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n            }\n        }\n        else if (annotationType === 'stamp') {\n            annotationAuthor = (this.pdfViewer.stampSettings.author !== 'Guest') ? this.pdfViewer.stampSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n            if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n            }\n        }\n        else if (annotationType === 'shape') {\n            if (annotationSubType === 'Line') {\n                annotationAuthor = (this.pdfViewer.lineSettings.author !== 'Guest') ? this.pdfViewer.lineSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'LineWidthArrowHead' || annotationSubType === 'Arrow') {\n                annotationAuthor = (this.pdfViewer.arrowSettings.author !== 'Guest') ? this.pdfViewer.arrowSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Circle' || annotationSubType === 'Ellipse' || annotationSubType === 'Oval') {\n                annotationAuthor = (this.pdfViewer.circleSettings.author !== 'Guest') ? this.pdfViewer.circleSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Rectangle' || annotationSubType === 'Square') {\n                annotationAuthor = (this.pdfViewer.rectangleSettings.author !== 'Guest') ? this.pdfViewer.rectangleSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Polygon') {\n                annotationAuthor = (this.pdfViewer.polygonSettings.author !== 'Guest') ? this.pdfViewer.polygonSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n        }\n        else if (annotationType === 'measure') {\n            if (annotationSubType === 'Distance' || annotationSubType === 'Distance calculation') {\n                annotationAuthor = (this.pdfViewer.distanceSettings.author !== 'Guest') ? this.pdfViewer.distanceSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Perimeter' || annotationSubType === 'Perimeter calculation') {\n                annotationAuthor = (this.pdfViewer.perimeterSettings.author !== 'Guest') ? this.pdfViewer.perimeterSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Radius' || annotationSubType === 'Radius calculation') {\n                annotationAuthor = (this.pdfViewer.radiusSettings.author !== 'Guest') ? this.pdfViewer.radiusSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Area' || annotationSubType === 'Area calculation') {\n                annotationAuthor = (this.pdfViewer.areaSettings.author !== 'Guest') ? this.pdfViewer.areaSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Volume' || annotationSubType === 'Volume calculation') {\n                annotationAuthor = (this.pdfViewer.volumeSettings.author !== 'Guest') ? this.pdfViewer.volumeSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n        }\n        else if (annotationType === 'textMarkup') {\n            if (annotationSubType === 'Highlight') {\n                annotationAuthor = (this.pdfViewer.highlightSettings.author !== 'Guest') ? this.pdfViewer.highlightSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Underline') {\n                annotationAuthor = (this.pdfViewer.underlineSettings.author !== 'Guest') ? this.pdfViewer.underlineSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else if (annotationSubType === 'Strikethrough') {\n                annotationAuthor = (this.pdfViewer.strikethroughSettings.author !== 'Guest') ? this.pdfViewer.strikethroughSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n                if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                    annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n                }\n            }\n            else {\n                annotationAuthor = this.pdfViewer.annotationSettings.author;\n            }\n        }\n        else if (annotationType === 'freeText') {\n            annotationAuthor = (this.pdfViewer.freeTextSettings.author !== 'Guest') ? this.pdfViewer.freeTextSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n            if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n            }\n        }\n        else if (annotationType === 'ink') {\n            annotationAuthor = (this.pdfViewer.inkAnnotationSettings.author !== 'Guest') ? this.pdfViewer.inkAnnotationSettings.author : this.pdfViewer.annotationSettings.author ? this.pdfViewer.annotationSettings.author : 'Guest';\n            if (annotationAuthor !== 'Guest' && this.pdfViewer.enableHtmlSanitizer) {\n                annotationAuthor = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.SanitizeHtmlHelper.sanitize(annotationAuthor);\n            }\n        }\n        if (!annotationAuthor) {\n            annotationAuthor = this.pdfViewer.annotationSettings.author;\n        }\n        return annotationAuthor;\n    };\n    /**\n     * @param {string} colour - colour\n     * @private\n     * @returns {string} - string\n     */\n    Annotation.prototype.nameToHash = function (colour) {\n        var colours = {\n            'aliceblue': '#f0f8ff', 'antiquewhite': '#faebd7', 'aqua': '#00ffff', 'aquamarine': '#7fffd4', 'azure': '#f0ffff',\n            'beige': '#f5f5dc', 'bisque': '#ffe4c4', 'black': '#000000', 'blanchedalmond': '#ffebcd', 'blue': '#0000ff',\n            'blueviolet': '#8a2be2', 'brown': '#a52a2a', 'burlywood': '#deb887', 'yellow': '#ffff00', 'yellowgreen': '#9acd32',\n            'cadetblue': '#5f9ea0', 'chartreuse': '#7fff00', 'chocolate': '#d2691e', 'coral': '#ff7f50',\n            'cornflowerblue': '#6495ed', 'cornsilk': '#fff8dc', 'crimson': '#dc143c',\n            'cyan': '#00ffff', 'darkblue': '#00008b', 'darkcyan': '#008b8b', 'darkgoldenrod': '#b8860b', 'darkgray': '#a9a9a9',\n            'darkred': '#8b0000', 'darksalmon': '#e9967a', 'darkgreen': '#006400', 'darkkhaki': '#bdb76b',\n            'darkmagenta': '#8b008b', 'darkolivegreen': '#556b2f', 'darkorange': '#ff8c00', 'darkorchid': '#9932cc',\n            'darkseagreen': '#8fbc8f', 'darkslateblue': '#483d8b', 'darkslategray': '#2f4f4f', 'darkturquoise': '#00ced1',\n            'darkviolet': '#9400d3', 'deeppink': '#ff1493', 'deepskyblue': '#00bfff', 'dimgray': '#696969',\n            'dodgerblue': '#1e90ff', 'firebrick': '#b22222', 'floralwhite': '#fffaf0',\n            'forestgreen': '#228b22', 'fuchsia': '#ff00ff', 'gainsboro': '#dcdcdc', 'ghostwhite': '#f8f8ff',\n            'gold': '#ffd700', 'goldenrod': '#daa520', 'gray': '#808080', 'green': '#008000',\n            'greenyellow': '#adff2f', 'honeydew': '#f0fff0', 'hotpink': '#ff69b4', 'indianred ': '#cd5c5c',\n            'mediumorchid': '#ba55d3', 'mediumpurple': '#9370d8', 'indigo': '#4b0082', 'ivory': '#fffff0',\n            'navy': '#000080', 'oldlace': '#fdf5e6', 'olive': '#808000', 'khaki': '#f0e68c',\n            'lavender': '#e6e6fa', 'lavenderblush': '#fff0f5', 'lawngreen': '#7cfc00', 'lemonchiffon': '#fffacd',\n            'lightblue': '#add8e6', 'lightcoral': '#f08080', 'lightcyan': '#e0ffff',\n            'lightgoldenrodyellow': '#fafad2', 'lightgrey': '#d3d3d3', 'lightgreen': '#90ee90',\n            'lightpink': '#ffb6c1', 'lightsalmon': '#ffa07a', 'lightseagreen': '#20b2aa',\n            'lightskyblue': '#87cefa', 'lightslategray': '#778899', 'lightsteelblue': '#b0c4de',\n            'lightyellow': '#ffffe0', 'lime': '#00ff00', 'limegreen': '#32cd32', 'linen': '#faf0e6',\n            'magenta': '#ff00ff', 'maroon': '#800000', 'mediumaquamarine': '#66cdaa', 'mediumblue': '#0000cd',\n            'mediumseagreen': '#3cb371', 'mediumslateblue': '#7b68ee', 'mediumspringgreen': '#00fa9a',\n            'mediumturquoise': '#48d1cc', 'mediumvioletred': '#c71585', 'midnightblue': '#191970',\n            'mintcream': '#f5fffa', 'mistyrose': '#ffe4e1', 'moccasin': '#ffe4b5', 'navajowhite': '#ffdead',\n            'rebeccapurple': '#663399', 'red': '#ff0000', 'rosybrown': '#bc8f8f', 'royalblue': '#4169e1',\n            'olivedrab': '#6b8e23', 'orange': '#ffa500', 'orangered': '#ff4500', 'orchid': '#da70d6',\n            'palegoldenrod': '#eee8aa', 'palegreen': '#98fb98', 'paleturquoise': '#afeeee',\n            'palevioletred': '#d87093', 'papayawhip': '#ffefd5', 'peachpuff': '#ffdab9', 'peru': '#cd853f',\n            'wheat': '#f5deb3', 'white': '#ffffff', 'whitesmoke': '#f5f5f5', 'pink': '#ffc0cb', 'plum': '#dda0dd',\n            'steelblue': '#4682b4', 'violet': '#ee82ee', 'powderblue': '#b0e0e6', 'purple': '#800080',\n            'saddlebrown': '#8b4513', 'salmon': '#fa8072', 'sandybrown': '#f4a460', 'seagreen': '#2e8b57',\n            'seashell': '#fff5ee', 'sienna': '#a0522d', 'silver': '#c0c0c0', 'skyblue': '#87ceeb',\n            'slateblue': '#6a5acd', 'slategray': '#708090', 'snow': '#fffafa', 'springgreen': '#00ff7f',\n            'tan': '#d2b48c', 'teal': '#008080', 'thistle': '#d8bfd8', 'tomato': '#ff6347', 'turquoise': '#40e0d0'\n        };\n        if (typeof colours[colour.toLowerCase()] !== 'undefined') {\n            return colours[colour.toLowerCase()];\n        }\n        return '';\n    };\n    Annotation.prototype.updateFreeTextFontStyle = function (font) {\n        var fontStyle = 0;\n        if (font.isBold === 1) {\n            fontStyle = 1;\n        }\n        else if (font.isItalic === 2) {\n            fontStyle = 2;\n        }\n        else if (font.isUnderline === 4) {\n            fontStyle = 4;\n        }\n        else if (font.isStrikeout === 8) {\n            fontStyle = 8;\n        }\n        else {\n            fontStyle = { isBold: font.isBold, isItalic: font.isItalic, isUnderline: font.isUnderline, isStrikeout: font.isStrikeout };\n        }\n        return fontStyle;\n    };\n    Annotation.prototype.setFreeTextFontStyle = function (fontStyle) {\n        if (fontStyle === 1) {\n            return { isBold: true };\n        }\n        else if (fontStyle === 2) {\n            return { isItalic: true };\n        }\n        else if (fontStyle === 4) {\n            return { isUnderline: true };\n        }\n        else if (fontStyle === 8) {\n            return { isStrikeout: true };\n        }\n        else {\n            return { isBold: fontStyle.isBold, isItalic: fontStyle.isItalic, isUnderline: fontStyle.isUnderline,\n                isStrikeout: fontStyle.isStrikeout };\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @param {boolean} isSettings - isSettings\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.findAnnotationSettings = function (annotation, isSettings) {\n        var annotSettings = this.pdfViewer.annotationSettings;\n        if (annotation) {\n            var shapeType = annotation.shapeAnnotationType;\n            if (shapeType === 'StickyNotes' && this.pdfViewer.stickyNotesSettings) {\n                annotSettings = this.pdfViewer.stickyNotesSettings;\n            }\n            else if (shapeType === 'Stamp' || shapeType === 'Image') {\n                annotSettings = this.pdfViewer.stampSettings;\n                if ((shapeType === 'Image')) {\n                    annotSettings = this.pdfViewer.customStampSettings;\n                }\n            }\n            else if (shapeType === 'FreeText') {\n                annotSettings = this.pdfViewer.freeTextSettings;\n            }\n            else if (annotation.measureType === '') {\n                if (shapeType === 'Line') {\n                    annotSettings = this.pdfViewer.lineSettings;\n                }\n                else if ((shapeType === 'Arrow' || shapeType === 'LineWidthArrowHead')) {\n                    annotSettings = this.pdfViewer.arrowSettings;\n                }\n                else if (shapeType === 'Rectangle') {\n                    annotSettings = this.pdfViewer.rectangleSettings;\n                }\n                else if ((shapeType === 'Circle' || shapeType === 'Ellipse')) {\n                    annotSettings = this.pdfViewer.circleSettings;\n                }\n                else if (shapeType === 'Polygon' && this.pdfViewer.polygonSettings) {\n                    annotSettings = this.pdfViewer.polygonSettings;\n                }\n            }\n            else if (annotation.measureType !== '') {\n                if (annotation.measureType === 'Distance') {\n                    annotSettings = this.pdfViewer.distanceSettings;\n                }\n                else if (annotation.measureType === 'Perimeter') {\n                    annotSettings = this.pdfViewer.perimeterSettings;\n                }\n                else if (annotation.measureType === 'Area') {\n                    annotSettings = this.pdfViewer.areaSettings;\n                }\n                else if (annotation.measureType === 'Radius') {\n                    annotSettings = this.pdfViewer.radiusSettings;\n                }\n                else if (annotation.measureType === 'Volume') {\n                    annotSettings = this.pdfViewer.volumeSettings;\n                }\n            }\n        }\n        var settings = annotation ? annotation.annotationSettings : {};\n        if (settings && (settings.minWidth || settings.maxWidth || settings.minHeight || settings.maxHeight)) {\n            return this.updateSettings(settings);\n        }\n        else if (isSettings) {\n            return this.updateSettings(annotSettings);\n        }\n        else {\n            return annotSettings;\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.updateAnnotationSettings = function (annotation) {\n        var annotSettings = this.pdfViewer.annotationSettings;\n        if (annotation.AnnotType === 'sticky') {\n            annotSettings = this.pdfViewer.stickyNotesSettings;\n        }\n        else if (annotation.AnnotType === 'stamp' || annotation.AnnotType === 'image' || annotation.AnnotType === 'Image') {\n            annotSettings = this.pdfViewer.stampSettings;\n            if ((annotation.Subject === 'image' || annotation.Subject === 'Image')) {\n                annotSettings = this.pdfViewer.customStampSettings;\n            }\n        }\n        else if (annotation.AnnotType === 'freeText') {\n            annotSettings = this.pdfViewer.freeTextSettings;\n        }\n        else if (annotation.AnnotType === 'ink' || annotation.AnnotationType === 'Ink') {\n            annotSettings = this.pdfViewer.inkAnnotationSettings;\n        }\n        else if (annotation.AnnotType === 'shape') {\n            if (annotation.Subject === 'Line') {\n                annotSettings = this.pdfViewer.lineSettings;\n            }\n            else if ((annotation.Subject === 'Arrow' || annotation.Subject === 'LineWidthArrowHead')) {\n                annotSettings = this.pdfViewer.arrowSettings;\n            }\n            else if ((annotation.Subject === 'Rectangle' || annotation.Subject === 'Square')) {\n                annotSettings = this.pdfViewer.rectangleSettings;\n            }\n            else if ((annotation.Subject === 'Circle' || annotation.Subject === 'Ellipse' || annotation.Subject === 'Oval')) {\n                annotSettings = this.pdfViewer.circleSettings;\n            }\n            else if (annotation.Subject === 'Polygon') {\n                annotSettings = this.pdfViewer.polygonSettings;\n            }\n        }\n        else if (annotation.AnnotType === 'shape_measure') {\n            if ((annotation.Subject === 'Distance' || annotation.Subject === 'Distance calculation')) {\n                annotSettings = this.pdfViewer.distanceSettings;\n            }\n            else if ((annotation.Subject === 'Perimeter' || annotation.Subject === 'Perimeter calculation')) {\n                annotSettings = this.pdfViewer.perimeterSettings;\n            }\n            else if ((annotation.Subject === 'Area' || annotation.Subject === 'Area calculation')) {\n                annotSettings = this.pdfViewer.areaSettings;\n            }\n            else if ((annotation.Subject === 'Radius' || annotation.Subject === 'Radius calculation')) {\n                annotSettings = this.pdfViewer.radiusSettings;\n            }\n            else if ((annotation.Subject === 'Volume' || annotation.Subject === 'Volume calculation')) {\n                annotSettings = this.pdfViewer.volumeSettings;\n            }\n        }\n        else if (annotation.shapeAnnotationType === 'textMarkup') {\n            if (annotation.subject === 'Highlight') {\n                annotSettings = this.pdfViewer.highlightSettings;\n            }\n            else if (annotation.subject === 'Underline') {\n                annotSettings = this.pdfViewer.underlineSettings;\n            }\n            else if (annotation.subject === 'Strikethrough') {\n                annotSettings = this.pdfViewer.strikethroughSettings;\n            }\n        }\n        return this.updateSettings(annotSettings);\n    };\n    /**\n     * @param {any} annotationSettings - annotationSettings\n     * @private\n     * @returns {any} - any\n     */\n    Annotation.prototype.updateSettings = function (annotationSettings) {\n        var maxHeight = 0;\n        var maxWidth = 0;\n        var minHeight = 0;\n        var minWidth = 0;\n        var isLock = false;\n        var isPrint = true;\n        var settings = this.pdfViewer.annotationSettings;\n        if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {\n            maxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;\n            maxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;\n            minHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;\n            minWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;\n        }\n        else if (settings.minWidth || settings.maxWidth || settings.minHeight || settings.maxHeight) {\n            maxHeight = settings.maxHeight ? settings.maxHeight : 2000;\n            maxWidth = settings.maxWidth ? settings.maxWidth : 2000;\n            minHeight = settings.minHeight ? settings.minHeight : 0;\n            minWidth = settings.minWidth ? settings.minWidth : 0;\n        }\n        isLock = annotationSettings.isLock ? annotationSettings.isLock : settings.isLock ? settings.isLock : false;\n        isPrint = annotationSettings.isPrint;\n        return { minWidth: minWidth, maxWidth: maxWidth, minHeight: minHeight, maxHeight: maxHeight, isLock: isLock, isPrint: isPrint };\n    };\n    Annotation.prototype.getOverlappedAnnotations = function (annotation, pageNumber) {\n        var pageCollections = this.getPageShapeAnnotations(pageNumber);\n        var selectedAnnotation;\n        for (var i = 0; i < pageCollections.length; i++) {\n            if (annotation.annotName === pageCollections[parseInt(i.toString(), 10)].annotName) {\n                selectedAnnotation = pageCollections[parseInt(i.toString(), 10)];\n                break;\n            }\n        }\n        var annotationCollection = this.findOverlappedAnnotations(selectedAnnotation, pageCollections);\n        return annotationCollection;\n    };\n    Annotation.prototype.getPageShapeAnnotations = function (pageNumber) {\n        var pageCollections = [];\n        var inkObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_ink');\n        if (inkObject) {\n            var inkAnnotObject = JSON.parse(inkObject);\n            if (inkAnnotObject) {\n                var index = this.getPageCollection(inkAnnotObject, pageNumber);\n                if (index != null && inkAnnotObject[parseInt(index.toString(), 10)]) {\n                    var inkAnnotations = inkAnnotObject[parseInt(index.toString(), 10)].annotations;\n                    if (inkAnnotations && inkAnnotations.length > 0) {\n                        for (var i = 0; i < inkAnnotations.length; i++) {\n                            pageCollections.push(inkAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n        }\n        var shapeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_shape');\n        if (shapeObject) {\n            var shapeAnnotObject = JSON.parse(shapeObject);\n            if (shapeAnnotObject) {\n                var index = this.getPageCollection(shapeAnnotObject, pageNumber);\n                if (index != null && shapeAnnotObject[parseInt(index.toString(), 10)]) {\n                    var shapeAnnotations = shapeAnnotObject[parseInt(index.toString(), 10)].annotations;\n                    if (shapeAnnotations && shapeAnnotations.length > 0) {\n                        for (var i = 0; i < shapeAnnotations.length; i++) {\n                            pageCollections.push(shapeAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n        }\n        var measureObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_shape_measure');\n        if (measureObject) {\n            var measureAnnotationObject = JSON.parse(measureObject);\n            if (measureAnnotationObject) {\n                var index = this.getPageCollection(measureAnnotationObject, pageNumber);\n                if (index != null && measureAnnotationObject[parseInt(index.toString(), 10)]) {\n                    var measureAnnotations = measureAnnotationObject[parseInt(index.toString(), 10)].annotations;\n                    if (measureAnnotations && measureAnnotations.length > 0) {\n                        for (var i = 0; i < measureAnnotations.length; i++) {\n                            pageCollections.push(measureAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n        }\n        var stampObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_stamp');\n        if (stampObject) {\n            var stampAnnotationObject = JSON.parse(stampObject);\n            if (stampAnnotationObject) {\n                var index = this.getPageCollection(stampAnnotationObject, pageNumber);\n                if (index != null && stampAnnotationObject[parseInt(index.toString(), 10)]) {\n                    var stampAnnotations = stampAnnotationObject[parseInt(index.toString(), 10)].annotations;\n                    if (stampAnnotations && stampAnnotations.length > 0) {\n                        for (var i = 0; i < stampAnnotations.length; i++) {\n                            pageCollections.push(stampAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n        }\n        var freeTextObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_freetext');\n        if (freeTextObject) {\n            var freeTextAnnotationObject = JSON.parse(freeTextObject);\n            if (freeTextAnnotationObject) {\n                var index = this.getPageCollection(freeTextAnnotationObject, pageNumber);\n                if (index != null && freeTextAnnotationObject[parseInt(index.toString(), 10)]) {\n                    var freeTextAnnotations = freeTextAnnotationObject[parseInt(index.toString(), 10)].annotations;\n                    if (freeTextAnnotations && freeTextAnnotations.length > 0) {\n                        for (var i = 0; i < freeTextAnnotations.length; i++) {\n                            pageCollections.push(freeTextAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n        }\n        var stickyObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_sticky');\n        if (stickyObject) {\n            var stickyNotesAnnotationObject = JSON.parse(stickyObject);\n            if (stickyNotesAnnotationObject) {\n                var index = this.getPageCollection(stickyNotesAnnotationObject, pageNumber);\n                if (index != null && stickyNotesAnnotationObject[parseInt(index.toString(), 10)]) {\n                    var stickyNotesAnnotations = stickyNotesAnnotationObject[parseInt(index.toString(), 10)].annotations;\n                    if (stickyNotesAnnotations && stickyNotesAnnotations.length > 0) {\n                        for (var i = 0; i < stickyNotesAnnotations.length; i++) {\n                            pageCollections.push(stickyNotesAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n        }\n        var textMarkupObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_textMarkup');\n        if (textMarkupObject) {\n            var textMarkupAnnotationObject = JSON.parse(textMarkupObject);\n            if (textMarkupAnnotationObject) {\n                var index = this.getPageCollection(textMarkupAnnotationObject, pageNumber);\n                if (index != null && textMarkupAnnotationObject[parseInt(index.toString(), 10)]) {\n                    var textMarkupAnnotations = textMarkupAnnotationObject[parseInt(index.toString(), 10)].annotations;\n                    if (textMarkupAnnotations && textMarkupAnnotations.length > 0) {\n                        for (var i = 0; i < textMarkupAnnotations.length; i++) {\n                            pageCollections.push(textMarkupAnnotations[parseInt(i.toString(), 10)]);\n                        }\n                    }\n                }\n            }\n        }\n        return pageCollections;\n    };\n    Annotation.prototype.findOverlappedAnnotations = function (annotation, pageCollections) {\n        this.overlappedAnnotations = [];\n        if (annotation && annotation.bounds) {\n            if (annotation.shapeAnnotationType === 'textMarkup') {\n                for (var i = 0; i < annotation.bounds.length; i++) {\n                    var bounds = this.orderTextMarkupBounds(annotation.bounds[parseInt(i.toString(), 10)]);\n                    this.calculateOverlappedAnnotationBounds(annotation, bounds, pageCollections);\n                }\n            }\n            else {\n                this.calculateOverlappedAnnotationBounds(annotation, annotation.bounds, pageCollections);\n            }\n        }\n        return this.overlappedAnnotations;\n    };\n    Annotation.prototype.calculateOverlappedAnnotationBounds = function (annotation, bounds, pageCollections) {\n        var selectBounds = bounds;\n        if (annotation.shapeAnnotationType === 'Ink') {\n            selectBounds = { left: bounds.x, top: bounds.y, height: bounds.height, width: bounds.width };\n        }\n        var left = parseInt(selectBounds.left, 10);\n        var top = parseInt(selectBounds.top, 10);\n        var totalHeight = parseInt(selectBounds.top + selectBounds.height, 10);\n        var totalWidth = parseInt(selectBounds.left + selectBounds.width, 10);\n        for (var i = 0; i < pageCollections.length; i++) {\n            if (annotation.annotName === pageCollections[parseInt(i.toString(), 10)].annotName) {\n                this.checkOverlappedCollections(pageCollections[parseInt(i.toString(), 10)], this.overlappedAnnotations);\n            }\n            else {\n                var boundsCount = 1;\n                if (pageCollections[parseInt(i.toString(), 10)].shapeAnnotationType === 'textMarkup') {\n                    boundsCount = pageCollections[parseInt(i.toString(), 10)].bounds.length;\n                }\n                for (var j = 0; j < boundsCount; j++) {\n                    var annotationBounds = void 0;\n                    var annotationBoundsCollection = pageCollections[parseInt(i.toString(), 10)].bounds;\n                    if (pageCollections[parseInt(i.toString(), 10)].shapeAnnotationType === 'Ink') {\n                        annotationBoundsCollection = { left: annotationBoundsCollection.x, top: annotationBoundsCollection.y,\n                            height: annotationBoundsCollection.height, width: annotationBoundsCollection.width };\n                    }\n                    if (pageCollections[parseInt(i.toString(), 10)].shapeAnnotationType !== 'textMarkup' && boundsCount === 1) {\n                        annotationBounds = annotationBoundsCollection;\n                    }\n                    else {\n                        annotationBounds = this.orderTextMarkupBounds(annotationBoundsCollection[parseInt(j.toString(), 10)]);\n                    }\n                    if (annotationBounds) {\n                        var isOverlapped = false;\n                        if (((left <= parseInt(annotationBounds.left, 10)) && (totalWidth >= parseInt(annotationBounds.left, 10))) ||\n                            ((left <= parseInt(annotationBounds.left + annotationBounds.width, 10)) &&\n                                (totalWidth >= parseInt(annotationBounds.left + annotationBounds.width, 10)))) {\n                            isOverlapped = true;\n                        }\n                        if (isOverlapped) {\n                            if (((top <= parseInt(annotationBounds.top, 10)) && (totalHeight >= parseInt(annotationBounds.top, 10))) ||\n                                ((top <= parseInt(annotationBounds.top + annotationBounds.height, 10)) &&\n                                    (totalHeight >= parseInt(annotationBounds.top + annotationBounds.height, 10)))) {\n                                isOverlapped = true;\n                            }\n                            else {\n                                isOverlapped = false;\n                            }\n                        }\n                        if (isOverlapped) {\n                            this.checkOverlappedCollections(pageCollections[parseInt(i.toString(), 10)], this.overlappedAnnotations);\n                        }\n                        else {\n                            if (((parseInt(annotationBounds.left, 10) <= left) &&\n                                (parseInt(annotationBounds.left + annotationBounds.width, 10) >= left)) ||\n                                ((totalWidth >= parseInt(annotationBounds.left, 10)) &&\n                                    (totalWidth <= parseInt(annotationBounds.left + annotationBounds.width, 10)))) {\n                                isOverlapped = true;\n                            }\n                            if (isOverlapped) {\n                                if (((parseInt(annotationBounds.top, 10) <= top) &&\n                                    parseInt(annotationBounds.top + annotationBounds.height, 10) >= top) ||\n                                    ((totalHeight >= parseInt(annotationBounds.top, 10)) &&\n                                        (totalHeight <= parseInt(annotationBounds.top + annotationBounds.height, 10)))) {\n                                    isOverlapped = true;\n                                }\n                                else {\n                                    isOverlapped = false;\n                                }\n                            }\n                            if (isOverlapped) {\n                                this.checkOverlappedCollections(pageCollections[parseInt(i.toString(), 10)], this.overlappedAnnotations);\n                            }\n                            else {\n                                if (((left <= parseInt(annotationBounds.left, 10)) &&\n                                    (totalWidth >= parseInt(annotationBounds.left, 10))) ||\n                                    ((left <= parseInt(annotationBounds.left + annotationBounds.width, 10)) &&\n                                        (totalWidth >= parseInt(annotationBounds.left + annotationBounds.width, 10)))) {\n                                    isOverlapped = true;\n                                }\n                                if (isOverlapped) {\n                                    if (((parseInt(annotationBounds.top, 10) <= top) &&\n                                        parseInt(annotationBounds.top + annotationBounds.height, 10) >= top) ||\n                                        ((totalHeight >= parseInt(annotationBounds.top, 10)) &&\n                                            (totalHeight <= parseInt(annotationBounds.top + annotationBounds.height, 10)))) {\n                                        isOverlapped = true;\n                                    }\n                                    else {\n                                        isOverlapped = false;\n                                    }\n                                }\n                                if (isOverlapped) {\n                                    this.checkOverlappedCollections(pageCollections[parseInt(i.toString(), 10)], this.overlappedAnnotations);\n                                }\n                                else {\n                                    if (((parseInt(annotationBounds.left, 10) <= left) &&\n                                        (parseInt(annotationBounds.left + annotationBounds.width, 10) >= left)) ||\n                                        ((totalWidth >= parseInt(annotationBounds.left, 10)) &&\n                                            (totalWidth <= parseInt(annotationBounds.left + annotationBounds.width, 10)))) {\n                                        isOverlapped = true;\n                                    }\n                                    if (isOverlapped) {\n                                        if (((top <= parseInt(annotationBounds.top, 10)) &&\n                                            (totalHeight >= parseInt(annotationBounds.top, 10))) ||\n                                            ((top <= parseInt(annotationBounds.top + annotationBounds.height, 10)) &&\n                                                (totalHeight >= parseInt(annotationBounds.top + annotationBounds.height, 10)))) {\n                                            isOverlapped = true;\n                                        }\n                                        else {\n                                            isOverlapped = false;\n                                        }\n                                    }\n                                    if (isOverlapped) {\n                                        this.checkOverlappedCollections(pageCollections[parseInt(i.toString(), 10)], this.overlappedAnnotations);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @param {number} pageNumber - pageNumber\n     * @param {string} type - type\n     * @private\n     * @returns {string} - string\n     */\n    Annotation.prototype.findAnnotationMode = function (annotation, pageNumber, type) {\n        var importCollection = this.pdfViewer.viewerBase.importedAnnotation[parseInt(pageNumber.toString(), 10)];\n        if (importCollection) {\n            var collection = void 0;\n            if (type === 'shape') {\n                collection = importCollection.shapeAnnotation;\n            }\n            else if (type === 'shape_measure') {\n                collection = importCollection.measureShapeAnnotation;\n            }\n            else if (type === 'freeText') {\n                collection = importCollection.freeTextAnnotation;\n            }\n            else if (type === 'stamp') {\n                collection = importCollection.stampAnnotations;\n            }\n            else if (type === 'sticky') {\n                collection = importCollection.stickyNotesAnnotation;\n            }\n            else if (type === 'textMarkup') {\n                collection = importCollection.textMarkupAnnotation;\n            }\n            if (collection) {\n                for (var i = 0; i < collection.length; i++) {\n                    if (collection[parseInt(i.toString(), 10)].AnnotName === annotation.AnnotName) {\n                        return 'Imported Annotation';\n                    }\n                }\n            }\n        }\n        return 'Existing Annotation';\n    };\n    Annotation.prototype.checkOverlappedCollections = function (annotation, overlappedCollections) {\n        if (overlappedCollections.length > 0) {\n            var isAdded = false;\n            for (var i = 0; i < overlappedCollections.length; i++) {\n                if (annotation.annotName === overlappedCollections[parseInt(i.toString(), 10)].annotName &&\n                    annotation.bounds === overlappedCollections[parseInt(i.toString(), 10)].bounds) {\n                    isAdded = true;\n                    break;\n                }\n            }\n            if (!isAdded) {\n                overlappedCollections.push(annotation);\n            }\n        }\n        else {\n            overlappedCollections.push(annotation);\n        }\n    };\n    Annotation.prototype.orderTextMarkupBounds = function (bounds) {\n        if (bounds.Left || bounds.Width) {\n            return { left: bounds.Left, top: bounds.Top, height: bounds.Height, width: bounds.Width };\n        }\n        else {\n            return { left: bounds.left, top: bounds.top, height: bounds.height, width: bounds.width };\n        }\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.updateModifiedDate = function (annotation) {\n        if (annotation.modifiedDate) {\n            annotation.modifiedDate = this.setAnnotationModifiedDate(annotation.modifiedDate);\n        }\n        if (annotation.comments && annotation.comments.length > 0) {\n            for (var i = 0; i < annotation.comments.length; i++) {\n                if (annotation.comments[parseInt(i.toString(), 10)].modifiedDate) {\n                    annotation.comments[parseInt(i.toString(), 10)].modifiedDate =\n                        this.setAnnotationModifiedDate(annotation.comments[parseInt(i.toString(), 10)].modifiedDate);\n                    if (annotation.comments[parseInt(i.toString(), 10)].review &&\n                        annotation.comments[parseInt(i.toString(), 10)].review.modifiedDate) {\n                        annotation.comments[parseInt(i.toString(), 10)].review.modifiedDate =\n                            this.setAnnotationModifiedDate(annotation.comments[parseInt(i.toString(), 10)].review.modifiedDate);\n                    }\n                }\n            }\n        }\n        if (annotation.review && annotation.review.modifiedDate) {\n            annotation.review.modifiedDate = this.setAnnotationModifiedDate(annotation.review.modifiedDate);\n        }\n    };\n    Annotation.prototype.setAnnotationModifiedDate = function (date) {\n        var modifiedTime;\n        var modifiedDateTime;\n        if (date !== '') {\n            var time = parseInt(date.split(' ')[1].split(':')[0], 10);\n            if (date.split(' ').length === 3) {\n                modifiedTime = time + ':' + date.split(' ')[1].split(':')[1] + ':' + date.split(' ')[1].split(':')[2] + ' ' + date.split(' ')[2];\n            }\n            else {\n                if (time >= 12) {\n                    if (time === 12) {\n                        modifiedTime = time + ':' + date.split(' ')[1].split(':')[1] + ':' + date.split(' ')[1].split(':')[2] + ' PM';\n                    }\n                    else {\n                        modifiedTime = (time - 12) + ':' + date.split(' ')[1].split(':')[1] + ':' + date.split(' ')[1].split(':')[2] + ' PM';\n                    }\n                }\n                else {\n                    modifiedTime = time + ':' + date.split(' ')[1].split(':')[1] + ':' + date.split(' ')[1].split(':')[2] + ' AM';\n                }\n            }\n            var dateString = date.split(' ')[0];\n            var dateStringSpilt = date.split(',');\n            if (dateStringSpilt.length > 1) {\n                modifiedDateTime = dateString + (' ') + modifiedTime;\n            }\n            else {\n                modifiedDateTime = dateString + (', ') + modifiedTime;\n            }\n        }\n        else {\n            return date;\n        }\n        var isTwelveHourFormat = /\\u0041\\u004D|\\u0050\\u004D/i.test(modifiedDateTime);\n        if (isTwelveHourFormat) {\n            var modifiedDateToUTC = new Date(modifiedDateTime);\n            modifiedDateTime = modifiedDateToUTC.toISOString();\n        }\n        return modifiedDateTime;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.clear = function () {\n        if (this.shapeAnnotationModule) {\n            this.shapeAnnotationModule.shapeCount = 0;\n        }\n        if (this.measureAnnotationModule) {\n            this.measureAnnotationModule.measureShapeCount = 0;\n        }\n        if (this.textMarkupAnnotationModule) {\n            this.textMarkupAnnotationModule.clear();\n        }\n        if (this.stickyNotesAnnotationModule) {\n            this.stickyNotesAnnotationModule.clear();\n        }\n        this.pdfViewer.refresh();\n        this.undoCommentsElement = [];\n        this.redoCommentsElement = [];\n        this.overlappedAnnotations = [];\n        this.previousIndex = null;\n        if (this.pdfViewer.annotation && this.pdfViewer.annotation.stampAnnotationModule) {\n            this.pdfViewer.annotation.stampAnnotationModule.stampPageNumber = [];\n        }\n        if (this.pdfViewer.annotation && this.pdfViewer.annotation.freeTextAnnotationModule) {\n            this.pdfViewer.annotation.freeTextAnnotationModule.freeTextPageNumbers = [];\n            this.freeTextAnnotationModule.previousText = 'Type Here';\n        }\n        if (this.pdfViewer.annotation && this.pdfViewer.annotation.inkAnnotationModule) {\n            this.pdfViewer.annotation.inkAnnotationModule.inkAnnotationindex = [];\n        }\n        _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_shape');\n        _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_shape_measure');\n        _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_stamp');\n        _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_sticky');\n    };\n    Annotation.prototype.retrieveAnnotationCollection = function () {\n        return this.pdfViewer.annotationCollection;\n    };\n    /**\n     * @param {string} interaction - interaction\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {boolean} - boolean\n     */\n    Annotation.prototype.checkAllowedInteractions = function (interaction, annotation) {\n        var annotationInteraction = this.updateAnnotationAllowedInteractions(annotation);\n        if (annotationInteraction && annotationInteraction.length > 0) {\n            for (var i = 0; i < annotationInteraction.length; i++) {\n                if (interaction === 'Select') {\n                    if (annotationInteraction[parseInt(i.toString(), 10)] === 'Move' || annotationInteraction[parseInt(i.toString(), 10)] === 'Resize' || annotationInteraction[parseInt(i.toString(), 10)] === 'Delete' || annotationInteraction[parseInt(i.toString(), 10)] === 'PropertyChange' || annotationInteraction[parseInt(i.toString(), 10)] === 'Select') {\n                        return true;\n                    }\n                }\n                else {\n                    if (annotationInteraction[parseInt(i.toString(), 10)] === interaction) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {any} menuObj - menuObj\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.checkContextMenuDeleteItem = function (menuObj) {\n        var annotation = this.findCurrentAnnotation();\n        if (annotation && annotation.annotationSettings) {\n            if (annotation.annotationSettings.isLock) {\n                if (this.checkAllowedInteractions('Delete', annotation)) {\n                    menuObj.enableItems([this.pdfViewer.localeObj.getConstant('Delete Context')], true);\n                }\n                else {\n                    menuObj.enableItems([this.pdfViewer.localeObj.getConstant('Delete Context')], false);\n                }\n            }\n            else {\n                menuObj.enableItems([this.pdfViewer.localeObj.getConstant('Delete Context')], true);\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {boolean} - boolean\n     */\n    Annotation.prototype.isEnableDelete = function () {\n        var annotation = this.findCurrentAnnotation();\n        if (annotation && annotation.annotationSettings) {\n            if (annotation.annotationSettings.isLock) {\n                if (this.checkAllowedInteractions('Delete', annotation)) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @private\n     * @returns {ITextMarkupAnnotation | PdfAnnotationBaseModel} - ITextMarkupAnnotation | PdfAnnotationBaseModel\n     */\n    Annotation.prototype.findCurrentAnnotation = function () {\n        if (this.textMarkupAnnotationModule && this.textMarkupAnnotationModule.currentTextMarkupAnnotation) {\n            return this.textMarkupAnnotationModule.currentTextMarkupAnnotation;\n        }\n        if (this.pdfViewer.selectedItems.annotations && this.pdfViewer.selectedItems.annotations[0]) {\n            return this.pdfViewer.selectedItems.annotations[0];\n        }\n        return null;\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {string[]} - return string array\n     */\n    Annotation.prototype.updateAnnotationAllowedInteractions = function (annotation) {\n        var annotationInteraction = ['None'];\n        if (annotation) {\n            if (annotation.shapeAnnotationType === 'FreeText' && this.pdfViewer.freeTextSettings.allowedInteractions) {\n                annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.freeTextSettings.allowedInteractions, annotation.allowedInteractions);\n            }\n            else if (annotation.shapeAnnotationType === 'Ink' && this.pdfViewer.inkAnnotationSettings.allowedInteractions) {\n                annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.inkAnnotationSettings.allowedInteractions, annotation.allowedInteractions);\n            }\n            else if (annotation.shapeAnnotationType === 'StickyNotes' && this.pdfViewer.stickyNotesSettings.allowedInteractions) {\n                annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.stickyNotesSettings.allowedInteractions, annotation.allowedInteractions);\n            }\n            else if (annotation.shapeAnnotationType === 'Stamp' && this.pdfViewer.stampSettings.allowedInteractions) {\n                annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.stampSettings.allowedInteractions, annotation.allowedInteractions);\n            }\n            else if (annotation.shapeAnnotationType === 'Image' && this.pdfViewer.customStampSettings.allowedInteractions) {\n                annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.customStampSettings.allowedInteractions, annotation.allowedInteractions);\n            }\n            else if (annotation.shapeAnnotationType === 'textMarkup') {\n                if (annotation.textMarkupAnnotationType === 'Highlight' && this.pdfViewer.highlightSettings.allowedInteractions) {\n                    annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.highlightSettings.allowedInteractions, annotation.allowedInteractions);\n                }\n                else if (annotation.textMarkupAnnotationType === 'Underline' && this.pdfViewer.underlineSettings.allowedInteractions) {\n                    annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.underlineSettings.allowedInteractions, annotation.allowedInteractions);\n                }\n                else if (annotation.textMarkupAnnotationType === 'Strikethrough' && this.pdfViewer.strikethroughSettings.allowedInteractions) {\n                    annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.strikethroughSettings.allowedInteractions, annotation.allowedInteractions);\n                }\n            }\n            else {\n                if (annotation.measureType !== '') {\n                    if (annotation.measureType === 'Distance' && this.pdfViewer.distanceSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.distanceSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if (annotation.measureType === 'Perimeter' && this.pdfViewer.perimeterSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.perimeterSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if (annotation.measureType === 'Radius' && this.pdfViewer.radiusSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.radiusSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if (annotation.measureType === 'Area' && this.pdfViewer.areaSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.areaSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if (annotation.measureType === 'Volume' && this.pdfViewer.volumeSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.volumeSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                }\n                else {\n                    if (annotation.shapeAnnotationType === 'Line' && this.pdfViewer.lineSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.lineSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if ((annotation.shapeAnnotationType === 'Arrow' || annotation.shapeAnnotationType === 'LineWidthArrowHead') && this.pdfViewer.arrowSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.arrowSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if ((annotation.shapeAnnotationType === 'Circle' || annotation.shapeAnnotationType === 'Ellipse' || annotation.shapeAnnotationType === 'Oval') && this.pdfViewer.circleSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.circleSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if ((annotation.shapeAnnotationType === 'Rectangle' || annotation.shapeAnnotationType === 'Square') && this.pdfViewer.rectangleSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.rectangleSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                    else if (annotation.shapeAnnotationType === 'Polygon' && this.pdfViewer.polygonSettings.allowedInteractions) {\n                        annotationInteraction = this.checkAllowedInteractionSettings(this.pdfViewer.polygonSettings.\n                            allowedInteractions, annotation.allowedInteractions);\n                    }\n                }\n            }\n        }\n        return annotationInteraction;\n    };\n    /**\n     * @param {any} annotation - annotation\n     * @private\n     * @returns {boolean} -boolean\n     */\n    Annotation.prototype.checkIsLockSettings = function (annotation) {\n        var isLocked = false;\n        if (annotation) {\n            if (annotation.shapeAnnotationType === 'FreeText') {\n                isLocked = this.checkLockSettings(this.pdfViewer.freeTextSettings.isLock);\n            }\n            else if (annotation.shapeAnnotationType === 'Ink') {\n                isLocked = this.checkLockSettings(this.pdfViewer.inkAnnotationSettings.isLock);\n            }\n            else if (annotation.shapeAnnotationType === 'StickyNotes') {\n                isLocked = this.checkLockSettings(this.pdfViewer.stickyNotesSettings.isLock);\n            }\n            else if (annotation.shapeAnnotationType === 'Stamp') {\n                isLocked = this.checkLockSettings(this.pdfViewer.stampSettings.isLock);\n            }\n            else if (annotation.shapeAnnotationType === 'Image') {\n                isLocked = this.checkLockSettings(this.pdfViewer.customStampSettings.isLock);\n            }\n            else if (annotation.shapeAnnotationType === 'textMarkup') {\n                if (annotation.textMarkupAnnotationType === 'Highlight') {\n                    isLocked = this.checkLockSettings(this.pdfViewer.highlightSettings.isLock);\n                }\n                else if (annotation.textMarkupAnnotationType === 'Underline') {\n                    isLocked = this.checkLockSettings(this.pdfViewer.underlineSettings.isLock);\n                }\n                else if (annotation.textMarkupAnnotationType === 'Strikethrough') {\n                    isLocked = this.checkLockSettings(this.pdfViewer.strikethroughSettings.isLock);\n                }\n            }\n            else {\n                if (annotation.measureType !== '') {\n                    if (annotation.measureType === 'Distance') {\n                        isLocked = this.checkLockSettings(this.pdfViewer.distanceSettings.isLock);\n                    }\n                    else if (annotation.measureType === 'Perimeter') {\n                        isLocked = this.checkLockSettings(this.pdfViewer.perimeterSettings.isLock);\n                    }\n                    else if (annotation.measureType === 'Radius') {\n                        isLocked = this.checkLockSettings(this.pdfViewer.radiusSettings.isLock);\n                    }\n                    else if (annotation.measureType === 'Area') {\n                        isLocked = this.checkLockSettings(this.pdfViewer.areaSettings.isLock);\n                    }\n                    else if (annotation.measureType === 'Volume') {\n                        isLocked = this.checkLockSettings(this.pdfViewer.volumeSettings.isLock);\n                    }\n                }\n                else {\n                    if (annotation.shapeAnnotationType === 'Line') {\n                        isLocked = this.checkLockSettings(this.pdfViewer.lineSettings.isLock);\n                    }\n                    else if ((annotation.shapeAnnotationType === 'Arrow' || annotation.shapeAnnotationType === 'LineWidthArrowHead')) {\n                        isLocked = this.checkLockSettings(this.pdfViewer.arrowSettings.isLock);\n                    }\n                    else if ((annotation.shapeAnnotationType === 'Circle' || annotation.shapeAnnotationType === 'Ellipse' || annotation.shapeAnnotationType === 'Oval')) {\n                        isLocked = this.checkLockSettings(this.pdfViewer.circleSettings.isLock);\n                    }\n                    else if ((annotation.shapeAnnotationType === 'Rectangle' || annotation.shapeAnnotationType === 'Square')) {\n                        isLocked = this.checkLockSettings(this.pdfViewer.rectangleSettings.isLock);\n                    }\n                    else if (annotation.shapeAnnotationType === 'Polygon') {\n                        isLocked = this.checkLockSettings(this.pdfViewer.polygonSettings.isLock);\n                    }\n                }\n            }\n        }\n        return isLocked;\n    };\n    Annotation.prototype.checkLockSettings = function (locked) {\n        var islock = false;\n        if (locked || this.pdfViewer.annotationSettings.isLock) {\n            islock = true;\n        }\n        return islock;\n    };\n    /**\n     * @private\n     * @returns {boolean} - boolean\n     */\n    Annotation.prototype.restrictContextMenu = function () {\n        var isRestrict = false;\n        var annotation = this.findCurrentAnnotation();\n        if (annotation && this.checkIsLockSettings(annotation) && this.checkAllowedInteractions('Select', annotation)) {\n            isRestrict = true;\n        }\n        return isRestrict;\n    };\n    Annotation.prototype.checkAllowedInteractionSettings = function (annotationInteraction, annotationAllowedInteraction) {\n        if (annotationAllowedInteraction) {\n            if (annotationAllowedInteraction.length === 1) {\n                if (annotationAllowedInteraction[0] !== 'None') {\n                    return annotationAllowedInteraction;\n                }\n            }\n            else {\n                return annotationAllowedInteraction;\n            }\n        }\n        if (annotationInteraction) {\n            if (annotationInteraction.length === 1) {\n                if (annotationInteraction[0] !== 'None') {\n                    return annotationInteraction;\n                }\n            }\n            else {\n                return annotationInteraction;\n            }\n        }\n        if (this.pdfViewer.annotationSettings.allowedInteractions) {\n            return this.pdfViewer.annotationSettings.allowedInteractions;\n        }\n        return ['None'];\n    };\n    /**\n     * @param {string} value - value\n     * @param {string} type - type\n     * @private\n     * @returns {string} - string\n     */\n    Annotation.prototype.getValue = function (value, type) {\n        type = !type ? 'hex' : type.toLowerCase();\n        if (value[0] === 'r') {\n            var cValue = this.convertRgbToNumberArray(value);\n            if (type === 'hex' || type === 'hexa') {\n                var hex = this.rgbToHex(cValue);\n                return type === 'hex' ? hex.slice(0, 7) : hex;\n            }\n            else {\n                if (type === 'hsv') {\n                    // eslint-disable-next-line\n                    return this.convertToHsvString(this.rgbToHsv.apply(this, cValue.slice(0, 3)));\n                }\n                else {\n                    if (type === 'hsva') {\n                        // eslint-disable-next-line\n                        return this.convertToHsvString(this.rgbToHsv.apply(this, cValue));\n                    }\n                    else {\n                        return 'null';\n                    }\n                }\n            }\n        }\n        else {\n            if (value[0] === 'h') {\n                // eslint-disable-next-line\n                var cValue = this.hsvToRgb.apply(this, this.convertRgbToNumberArray(value));\n                if (type === 'rgba') {\n                    return this.convertToRgbString(cValue);\n                }\n                else {\n                    if (type === 'hex' || type === 'hexa') {\n                        var hex = this.rgbToHex(cValue);\n                        return type === 'hex' ? hex.slice(0, 7) : hex;\n                    }\n                    else {\n                        if (type === 'rgb') {\n                            return this.convertToRgbString(cValue.slice(0, 3));\n                        }\n                        else {\n                            return 'null';\n                        }\n                    }\n                }\n            }\n            else {\n                value = this.roundValue(value);\n                var rgb = this.hexToRgb(value);\n                if (type === 'rgb' || type === 'hsv') {\n                    rgb = rgb.slice(0, 3);\n                }\n                if (type === 'rgba' || type === 'rgb') {\n                    return this.convertToRgbString(rgb);\n                }\n                else {\n                    if (type === 'hsva' || type === 'hsv') {\n                        // eslint-disable-next-line\n                        return this.convertToHsvString(this.rgbToHsv.apply(this, rgb));\n                    }\n                    else {\n                        if (type === 'hex') {\n                            return value.slice(0, 7);\n                        }\n                        else {\n                            if (type === 'a') {\n                                return rgb[3].toString();\n                            }\n                            else {\n                                return 'null';\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    Annotation.prototype.convertRgbToNumberArray = function (value) {\n        return (value.slice(value.indexOf('(') + 1, value.indexOf(')'))).split(',').map(function (n, i) {\n            return (i !== 3) ? parseInt(n, 10) : parseFloat(n);\n        });\n    };\n    Annotation.prototype.convertToRgbString = function (rgb) {\n        return rgb.length ? rgb.length === 4 ? 'rgba(' + rgb.join() + ')' : 'rgb(' + rgb.join() + ')' : '';\n    };\n    Annotation.prototype.convertToHsvString = function (hsv) {\n        return hsv.length === 4 ? 'hsva(' + hsv.join() + ')' : 'hsv(' + hsv.join() + ')';\n    };\n    Annotation.prototype.roundValue = function (value) {\n        if (!value) {\n            return '';\n        }\n        if (value[0] !== '#') {\n            value = '#' + value;\n        }\n        var len = value.length;\n        if (len === 4) {\n            value += 'f';\n            len = 5;\n        }\n        if (len === 5) {\n            var tempValue = '';\n            for (var i = 1, len_1 = value.length; i < len_1; i++) {\n                tempValue += (value.charAt(i) + value.charAt(i));\n            }\n            value = '#' + tempValue;\n            len = 9;\n        }\n        if (len === 7) {\n            value += 'ff';\n        }\n        return value;\n    };\n    Annotation.prototype.hexToRgb = function (hex) {\n        if (!hex) {\n            return [];\n        }\n        hex = hex.trim();\n        if (hex.length !== 9) {\n            hex = this.roundValue(hex);\n        }\n        var opacity = Number((parseInt(hex.slice(-2), 16) / 255).toFixed(2));\n        hex = hex.slice(1, 7);\n        var bigInt = parseInt(hex, 16);\n        var h = [];\n        h.push((bigInt >> 16) & 255);\n        h.push((bigInt >> 8) & 255);\n        h.push(bigInt & 255);\n        h.push(opacity);\n        return h;\n    };\n    Annotation.prototype.rgbToHsv = function (r, g, b, opacity) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h;\n        var v = max;\n        var d = max - min;\n        var s = max === 0 ? 0 : d / max;\n        if (max === min) {\n            h = 0;\n        }\n        else {\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        var hsv = [Math.round(h * 360), Math.round(s * 1000) / 10, Math.round(v * 1000) / 10];\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(opacity)) {\n            hsv.push(opacity);\n        }\n        return hsv;\n    };\n    Annotation.prototype.hsvToRgb = function (h, s, v, opacity) {\n        var r;\n        var g;\n        var b;\n        s /= 100;\n        v /= 100;\n        if (s === 0) {\n            r = g = b = v;\n            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), opacity];\n        }\n        h /= 60;\n        var i = Math.floor(h);\n        var f = h - i;\n        var p = v * (1 - s);\n        var q = v * (1 - s * f);\n        var t = v * (1 - s * (1 - f));\n        switch (i) {\n            case 0:\n                r = v;\n                g = t;\n                b = p;\n                break;\n            case 1:\n                r = q;\n                g = v;\n                b = p;\n                break;\n            case 2:\n                r = p;\n                g = v;\n                b = t;\n                break;\n            case 3:\n                r = p;\n                g = q;\n                b = v;\n                break;\n            case 4:\n                r = t;\n                g = p;\n                b = v;\n                break;\n            default:\n                r = v;\n                g = p;\n                b = q;\n        }\n        var rgb = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(opacity)) {\n            rgb.push(opacity);\n        }\n        return rgb;\n    };\n    Annotation.prototype.rgbToHex = function (rgb) {\n        return rgb.length ? ('#' + this.hex(rgb[0]) + this.hex(rgb[1]) + this.hex(rgb[2]) +\n            (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(rgb[3]) ? (rgb[3] !== 0 ? (Math.round(rgb[3] * 255) + 0x10000).toString(16).substr(-2) : '00') : '')) : '';\n    };\n    /**\n     * @param {AnnotationDataFormat} dataFormat - dataFormat\n     * @private\n     * @returns {Promise} - promise\n     */\n    Annotation.prototype.exportAnnotationsAsStream = function (dataFormat) {\n        var _this = this;\n        if (this.pdfViewer.annotationModule) {\n            var isAnnotations = this.pdfViewer.viewerBase.updateExportItem();\n            if (isAnnotations) {\n                return new Promise(function (resolve, reject) {\n                    _this.pdfViewer.viewerBase.createRequestForExportAnnotations(true, dataFormat, true).then(function (value) {\n                        resolve(value);\n                    });\n                });\n            }\n        }\n        return null;\n    };\n    Annotation.prototype.hex = function (x) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(x)) {\n            return ('0' + x.toString(16)).slice(-2);\n        }\n        else {\n            return '0';\n        }\n    };\n    /**\n     * @param {any} obj - obj\n     * @private\n     * @returns {Object} - Object\n     */\n    Annotation.prototype.cloneObject = function (obj) {\n        return JSON.parse(JSON.stringify(obj));\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.destroy = function () {\n        this.destroyPropertiesWindow();\n        if (this.textMarkupAnnotationModule) {\n            this.textMarkupAnnotationModule.clear();\n        }\n    };\n    /**\n     * @private\n     * @returns {string} - string\n     */\n    Annotation.prototype.getModuleName = function () {\n        return 'Annotation';\n    };\n    /**\n     * Get vertex points properties\n     *\n     * @param {IPoint[]} points - points\n     * @private\n     * @returns {IPointBase[]} - IPointBase[]\n     */\n    Annotation.prototype.getVertexPointsXY = function (points) {\n        var vertexPoints = [];\n        //Converting points model into vertex property\n        for (var j = 0; j < points.length; j++) {\n            vertexPoints[parseInt(j.toString(), 10)] = { X: points[parseInt(j.toString(), 10)].x, Y: points[parseInt(j.toString(), 10)].y };\n        }\n        return vertexPoints;\n    };\n    /**\n     * Method used to add annotations using program.\n     *\n     * @param {AnnotationType} annotationType - It describes type of annotation object.\n     * @param {FreeTextSettings} options -  It describes about the annotation objects and it's property.\n     * @param {DynamicStampItem} dynamicStampItem - It describe which type of dynamic stamp.\n     * @param {SignStampItem} signStampItem - It describe which type of sign stamp.\n     * @param {StandardBusinessStampItem} standardBusinessStampItem - It describe which type of standard business stamp.\n     * @returns {void}\n     */\n    Annotation.prototype.addAnnotation = function (annotationType, options, dynamicStampItem, signStampItem, standardBusinessStampItem) {\n        //Initialize the bounds and pageNumber\n        var offset = { x: 1, y: 1 };\n        var pageNumber = 0;\n        if (options) {\n            if (options.pageNumber && options.pageNumber > 0) {\n                pageNumber = options.pageNumber ? options.pageNumber - 1 : 0;\n            }\n        }\n        //Initialize the pdf annotation object array\n        var annotationObject = null;\n        var pdfAnnotation = [];\n        this.pdfViewer.annotation.triggerAnnotationUnselectEvent();\n        //Seperate the annotation type with it's method\n        if (annotationType === 'FreeText') {\n            pdfAnnotation[parseInt(pageNumber.toString(), 10)] =\n                this.pdfViewer.annotation.freeTextAnnotationModule.updateAddAnnotationDetails(options, offset);\n            this.pdfViewer.annotation.freeTextAnnotationModule.isAddAnnotationProgramatically = true;\n        }\n        else if (annotationType === 'StickyNotes') {\n            pdfAnnotation[parseInt(pageNumber.toString(), 10)] =\n                this.pdfViewer.annotation.stickyNotesAnnotationModule.updateAddAnnotationDetails(options, offset);\n            this.pdfViewer.annotation.stickyNotesAnnotationModule.isAddAnnotationProgramatically = true;\n        }\n        else if (annotationType === 'Highlight' || annotationType === 'Underline' || annotationType === 'Strikethrough') {\n            if (annotationType === 'Highlight') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Underline') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Strikethrough') {\n                annotationObject = options;\n            }\n            pdfAnnotation[parseInt(pageNumber.toString(), 10)] =\n                this.pdfViewer.annotation.textMarkupAnnotationModule.updateAddAnnotationDetails(annotationType, annotationObject);\n            this.pdfViewer.annotation.textMarkupAnnotationModule.isAddAnnotationProgramatically = true;\n        }\n        else if (annotationType === 'Line' || annotationType === 'Arrow' || annotationType === 'Rectangle' || annotationType === 'Circle' || annotationType === 'Polygon') {\n            if (annotationType === 'Line') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Arrow') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Rectangle') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Circle') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Polygon') {\n                annotationObject = options;\n            }\n            pdfAnnotation[parseInt(pageNumber.toString(), 10)] =\n                this.pdfViewer.annotation.shapeAnnotationModule.updateAddAnnotationDetails(annotationType, annotationObject, offset);\n            this.pdfViewer.annotation.shapeAnnotationModule.isAddAnnotationProgramatically = true;\n        }\n        else if (annotationType === 'Distance' || annotationType === 'Perimeter' || annotationType === 'Area' || annotationType === 'Radius' || annotationType === 'Volume') {\n            if (annotationType === 'Distance') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Perimeter') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Area') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Radius') {\n                annotationObject = options;\n            }\n            else if (annotationType === 'Volume') {\n                annotationObject = options;\n            }\n            pdfAnnotation[parseInt(pageNumber.toString(), 10)] =\n                this.pdfViewer.annotation.measureAnnotationModule.updateAddAnnotationDetails(annotationType, annotationObject, offset);\n            this.pdfViewer.annotation.measureAnnotationModule.isAddAnnotationProgramatically = true;\n        }\n        else if (annotationType === 'Stamp') {\n            if (options && options.customStamps) {\n                pdfAnnotation[parseInt(pageNumber.toString(), 10)] =\n                    this.pdfViewer.annotation.stampAnnotationModule.updateAddAnnotationDetails(options, offset, pageNumber, dynamicStampItem, signStampItem, standardBusinessStampItem);\n            }\n            else {\n                pdfAnnotation[parseInt(pageNumber.toString(), 10)] = this.pdfViewer.annotation.\n                    stampAnnotationModule.updateAddAnnotationDetails(options, offset, pageNumber, dynamicStampItem, signStampItem, standardBusinessStampItem);\n            }\n            this.pdfViewer.annotation.stampAnnotationModule.isAddAnnotationProgramatically = true;\n        }\n        else if (annotationType === 'Ink') {\n            pdfAnnotation[parseInt(pageNumber.toString(), 10)] = this.pdfViewer.annotation.inkAnnotationModule.\n                updateAddAnnotationDetails(options, offset, pageNumber);\n            this.pdfViewer.annotation.inkAnnotationModule.isAddAnnotationProgramatically = true;\n        }\n        else if (annotationType === 'HandWrittenSignature' || annotationType === 'Initial') {\n            pdfAnnotation[parseInt(pageNumber.toString(), 10)] = this.pdfViewerBase.signatureModule.\n                updateSignatureDetails(options, offset, pageNumber);\n            this.pdfViewerBase.signatureModule.isAddAnnotationProgramatically = true;\n        }\n        //Annotation rendering can be done with the import annotation method.\n        var pdf = { pdfAnnotation: pdfAnnotation };\n        this.pdfViewerBase.isAddAnnotation = true;\n        this.pdfViewerBase.importAnnotations(pdf);\n        this.pdfViewerBase.isAddAnnotation = false;\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} annotation - annotation\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.triggerAnnotationAddEvent = function (annotation) {\n        var annotationType = annotation.shapeAnnotationType;\n        if (annotationType === 'Stamp' || annotationType === 'Image' || annotationType === 'Path' || annotationType === 'FreeText' || annotationType === 'StickyNotes' || annotationType === 'Ink') {\n            var settings = void 0;\n            if (annotationType === 'FreeText') {\n                settings = {\n                    opacity: annotation.opacity, borderColor: annotation.strokeColor, borderWidth: annotation.thickness,\n                    author: annotation.author, subject: annotation.subject, modifiedDate: annotation.modifiedDate,\n                    fillColor: annotation.fillColor, fontSize: annotation.fontSize, width: annotation.bounds.width,\n                    height: annotation.bounds.height, fontColor: annotation.fontColor, fontFamily: annotation.fontFamily,\n                    defaultText: annotation.dynamicText, fontStyle: annotation.font, textAlignment: annotation.textAlign\n                };\n            }\n            else {\n                settings = {\n                    opacity: annotation.opacity, fillColor: annotation.fillColor, strokeColor: annotation.strokeColor,\n                    thickness: annotation.thickness, author: annotation.author, subject: annotation.subject,\n                    modifiedDate: annotation.modifiedDate, data: annotation.data\n                };\n            }\n            var bounds = { left: annotation.bounds.x, top: annotation.bounds.y, width: annotation.bounds.width,\n                height: annotation.bounds.height };\n            var type = this.getAnnotationType(annotation.shapeAnnotationType, annotation.measureType);\n            this.pdfViewer.fireAnnotationAdd(annotation.pageIndex, annotation.annotName, type, bounds, settings);\n        }\n        else if (annotationType === 'SignatureText' || annotationType === 'SignatureImage' || annotationType === 'HandWrittenSignature') {\n            var bounds = { left: annotation.bounds.x, top: annotation.bounds.y, width: annotation.bounds.width,\n                height: annotation.bounds.height };\n            this.pdfViewer.fireSignatureAdd(annotation.pageIndex, annotation.signatureName, annotation.shapeAnnotationType, bounds, annotation.opacity, annotation.strokeColor, annotation.thickness, annotation.data);\n        }\n        else {\n            var setting = {\n                opacity: annotation.opacity, fillColor: annotation.fillColor, strokeColor: annotation.strokeColor,\n                thickness: annotation.thickness, author: annotation.author, subject: annotation.subject,\n                modifiedDate: annotation.modifiedDate\n            };\n            var bounds = { left: annotation.bounds.x, top: annotation.bounds.y, width: annotation.bounds.width,\n                height: annotation.bounds.height };\n            var type = this.getAnnotationType(annotation.shapeAnnotationType, annotation.measureType);\n            if (type === 'Line' || type === 'Arrow' || type === 'Distance' || type === 'Perimeter') {\n                setting.lineHeadStartStyle = this.getArrowString(annotation.sourceDecoraterShapes);\n                setting.lineHeadEndStyle = this.getArrowString(annotation.taregetDecoraterShapes);\n                setting.borderDashArray = annotation.borderDashArray;\n            }\n            var labelSettings = void 0;\n            if (this.pdfViewer.enableShapeLabel) {\n                labelSettings = {\n                    fontColor: annotation.fontColor, fontSize: annotation.fontSize, fontFamily: annotation.fontFamily,\n                    opacity: annotation.labelOpacity, labelContent: annotation.labelContent, fillColor: annotation.labelFillColor\n                };\n                this.pdfViewer.fireAnnotationAdd(annotation.pageIndex, annotation.annotName, type, bounds, setting, null, null, null, labelSettings);\n            }\n            else {\n                this.pdfViewer.fireAnnotationAdd(annotation.pageIndex, annotation.annotName, type, bounds, setting);\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.triggerAnnotationUnselectEvent = function () {\n        if (this.pdfViewer.selectedItems.annotations && this.pdfViewer.selectedItems.annotations[0]) {\n            var annotation = this.pdfViewer.selectedItems.annotations[0];\n            if (annotation.shapeAnnotationType !== 'HandWrittenSignature' && annotation.shapeAnnotationType !== 'SignatureText' && annotation.shapeAnnotationType !== 'SignatureImage' && annotation.shapeAnnotationType !== 'Path') {\n                this.pdfViewer.fireAnnotationUnSelect(annotation.annotName, annotation.pageIndex, annotation);\n                this.pdfViewer.clearSelection(annotation.pageIndex);\n            }\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.triggerSignatureUnselectEvent = function () {\n        if (this.pdfViewer.selectedItems.annotations && this.pdfViewer.selectedItems.annotations[0]) {\n            var selectorModel = this.pdfViewer.selectedItems;\n            if (selectorModel.annotations.length) {\n                for (var j = 0; j < selectorModel.annotations.length; j++) {\n                    var node = selectorModel.annotations[parseInt(j.toString(), 10)];\n                    this.pdfViewer.annotationModule.unselectSignature(node.signatureName, node.pageIndex, node);\n                    this.pdfViewer.clearSelection(node.pageIndex);\n                }\n            }\n        }\n    };\n    /**\n     * @param {PdfAnnotationBaseModel} currentAnnotation - currentAnnotation\n     * @param {any} currentValue - currentValue\n     * @private\n     * @returns {void}\n     */\n    Annotation.prototype.updateFontFamilyRenderSize = function (currentAnnotation, currentValue) {\n        var freeTextAnnotation = this.freeTextAnnotationModule;\n        freeTextAnnotation.inputBoxElement.style.fontFamily = currentValue;\n        freeTextAnnotation.autoFitFreeText();\n        var zoomFactor = this.pdfViewerBase.getZoomFactor();\n        var padding = parseFloat(freeTextAnnotation.inputBoxElement.style.paddingLeft);\n        var inputEleHeight = currentAnnotation.bounds.height * zoomFactor;\n        var characterLength = 8;\n        var inputEleWidth = parseFloat(freeTextAnnotation.inputBoxElement.style.width) - characterLength;\n        inputEleWidth = ((inputEleWidth) / zoomFactor);\n        inputEleHeight = ((inputEleHeight) / zoomFactor);\n        var heightDiff = (inputEleHeight - currentAnnotation.bounds.height);\n        var y = undefined;\n        if (heightDiff > 0) {\n            y = currentAnnotation.wrapper.offsetY + (heightDiff / 2);\n            y = y > 0 ? y : undefined;\n        }\n        else {\n            heightDiff = Math.abs(heightDiff);\n            y = currentAnnotation.wrapper.offsetY - (heightDiff / 2);\n            y = y > 0 ? y : undefined;\n        }\n        var widthDiff = (inputEleWidth - currentAnnotation.bounds.width);\n        var x = undefined;\n        if (widthDiff > 0) {\n            x = currentAnnotation.wrapper.offsetX + (widthDiff / 2);\n            x = x > 0 ? x : undefined;\n        }\n        else {\n            widthDiff = Math.abs(widthDiff);\n            x = currentAnnotation.wrapper.offsetX - (widthDiff / 2);\n        }\n        currentAnnotation.bounds.width = inputEleWidth;\n        currentAnnotation.bounds.height = inputEleHeight;\n        this.pdfViewer.nodePropertyChange(currentAnnotation, { fontFamily: currentValue,\n            bounds: { width: currentAnnotation.bounds.width, height: currentAnnotation.bounds.height, y: y, x: x } });\n        this.pdfViewer.renderSelector(currentAnnotation.pageIndex, this.pdfViewer.annotationSelectorSettings);\n        this.modifyInCollections(currentAnnotation, 'bounds');\n    };\n    /**\n     * @param {string} text - text\n     * @param {number} rectangle - rectangle\n     * @param {number} width - width\n     * @private\n     * @returns {number} - fontSize\n     */\n    Annotation.prototype.calculateFontSize = function (text, rectangle) {\n        var canvasElement = document.createElement('canvas');\n        var context = canvasElement.getContext('2d');\n        var fontSize = 10;\n        var contextWidth = 0;\n        while (rectangle.width > contextWidth) {\n            context.font = fontSize + 'px' + ' ' + 'Helvetica';\n            contextWidth = context.measureText(text).width;\n            fontSize++;\n        }\n        return fontSize;\n    };\n    return Annotation;\n}());\n\n/**\n *\n * @hidden\n */\nvar AnnotationBaseSettings = /** @class */ (function () {\n    function AnnotationBaseSettings() {\n    }\n    return AnnotationBaseSettings;\n}());\n\n/**\n *\n * @hidden\n */\nvar AnnotBoundsRect = /** @class */ (function () {\n    function AnnotBoundsRect() {\n    }\n    return AnnotBoundsRect;\n}());\n\n/**\n *\n * @hidden\n */\nvar AnnotBoundsBase = /** @class */ (function () {\n    function AnnotBoundsBase() {\n    }\n    return AnnotBoundsBase;\n}());\n\n/**\n *\n * @hidden\n */\nvar AnnotRectBase = /** @class */ (function () {\n    function AnnotRectBase() {\n    }\n    return AnnotRectBase;\n}());\n\n/**\n *\n * @hidden\n */\nvar AnnotFontBase = /** @class */ (function () {\n    function AnnotFontBase() {\n    }\n    return AnnotFontBase;\n}());\n\n/**\n *\n * @hidden\n */\nvar IBounds = /** @class */ (function () {\n    function IBounds() {\n    }\n    return IBounds;\n}());\n\n/**\n *\n * @hidden\n */\nvar AnnotationsInternal = /** @class */ (function () {\n    function AnnotationsInternal() {\n    }\n    return AnnotationsInternal;\n}());\n\n/**\n *\n * @hidden\n */\nvar AnnotationsBase = /** @class */ (function () {\n    function AnnotationsBase() {\n    }\n    return AnnotationsBase;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/annotation.js?");

/***/ })

}]);