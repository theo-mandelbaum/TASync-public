"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_event-handlers_js-9383ea4-5ee15f91"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/event-handlers.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/event-handlers.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiagramEventHandler: () => (/* binding */ DiagramEventHandler)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _core_containers_container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/containers/container */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/container.js\");\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tool */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/tool.js\");\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _connector_editing__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./connector-editing */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/connector-editing.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./actions */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/actions.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utility/constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n/* harmony import */ var _objects_tooltip__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../objects/tooltip */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/tooltip.js\");\n/* harmony import */ var _utility_dom_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utility/dom-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/dom-util.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _primitives_matrix__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./../primitives/matrix */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js\");\n/* harmony import */ var _ruler_ruler__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../ruler/ruler */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/ruler/ruler.js\");\n/* harmony import */ var _objects_annotation__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../objects/annotation */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/annotation.js\");\n/* harmony import */ var _container_interaction__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./container-interaction */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js\");\n/* harmony import */ var _utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../utility/swim-lane-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js\");\n/* harmony import */ var _core_elements_html_element__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../core/elements/html-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/html-element.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/index.js\");\n/* harmony import */ var _objects_port__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../objects/port */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/port.js\");\n/* harmony import */ var _overview_overview__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../overview/overview */ \"./node_modules/@syncfusion/ej2-diagrams/src/overview/overview.js\");\n/* harmony import */ var _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../objects/fixed-user-handle */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/fixed-user-handle.js\");\n/* harmony import */ var _interaction_selector__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../interaction/selector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/selector.js\");\n/* eslint-disable jsdoc/require-returns */\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable no-case-declarations */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This module handles the mouse and touch events\n */\nvar DiagramEventHandler = /** @class */ (function () {\n    /** @private */\n    function DiagramEventHandler(diagram, commandHandler) {\n        this.currentAction = 'None';\n        this.previousAction = 'None';\n        this.previousTarget = null;\n        /** @private */\n        this.touchArgs = undefined;\n        /**   @private  */\n        this.focus = false;\n        this.isBlocked = false;\n        this.isMouseDown = false;\n        this.inAction = false;\n        this.doingAutoScroll = false;\n        this.diagram = null;\n        this.objectFinder = null;\n        this.tool = null;\n        this.eventArgs = null;\n        this.previousElement = null;\n        this.isKeyUp = true;\n        this.keyCount = 0;\n        this.isNudgeKey = false;\n        this.commandObj = {};\n        this.keyArgs = {};\n        this.diagram = diagram;\n        this.objectFinder = new ObjectFinder();\n        this.commandHandler = commandHandler;\n    }\n    Object.defineProperty(DiagramEventHandler.prototype, \"action\", {\n        get: function () {\n            return this.currentAction;\n        },\n        set: function (action) {\n            if (action !== this.currentAction) {\n                if (this.currentAction === 'PortDraw') {\n                    this.diagram.tool &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramTools.DrawOnce;\n                    //EJ2-70550 - Connector disconnected from source and target while dragging mutliple selected element\n                    if (this.diagram.currentDrawingObject) {\n                        this.diagram.currentDrawingObject = null;\n                    }\n                    if (this.tool) {\n                        this.tool.mouseUp({ position: this.currentPosition });\n                    }\n                    this.tool = null;\n                }\n                if (action === 'Rotate' || action === 'LabelRotate') {\n                    this.diagram.diagramCanvas.classList.add('e-diagram-rotate');\n                }\n                else if (this.currentAction === 'Rotate' || this.currentAction === 'LabelRotate') {\n                    this.diagram.diagramCanvas.classList.remove('e-diagram-rotate');\n                }\n                this.currentAction = action;\n                //Ej2-26204 - Exception occurs when remove method called without mouse Interaction\n                if (this.currentAction !== 'None' && this.currentAction !== 'Select' &&\n                    !(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.TextEdit) &&\n                    !(this.currentPosition && this.commandHandler.isUserHandle(this.currentPosition)) && !(this.currentAction === 'FixedUserHandle')) {\n                    this.diagram.diagramActions = this.diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.ToolAction;\n                }\n                else {\n                    this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.ToolAction;\n                }\n                this.diagram.setCursor(this.diagram.getCursor(action, this.inAction));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiagramEventHandler.prototype, \"blocked\", {\n        get: function () {\n            return this.isBlocked;\n        },\n        set: function (blocked) {\n            this.isBlocked = blocked;\n            if (this.blocked) {\n                this.diagram.setCursor('not-allowed');\n            }\n            else {\n                this.diagram.setCursor(this.diagram.getCursor(this.action, this.inAction));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @private */\n    DiagramEventHandler.prototype.getMousePosition = function (e) {\n        var touchArg;\n        var offsetX;\n        var offsetY;\n        if (e.type.indexOf('touch') !== -1) {\n            touchArg = e;\n            offsetX = touchArg.changedTouches[0].clientX;\n            offsetY = touchArg.changedTouches[0].clientY;\n        }\n        else {\n            offsetX = e.clientX;\n            offsetY = e.clientY;\n        }\n        offsetX = this.diagram.modifyClientOffset(offsetX);\n        offsetY = this.diagram.modifyClientOffset(offsetY);\n        var position = new _primitives_size__WEBPACK_IMPORTED_MODULE_14__.Size();\n        position = (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_18__.getRulerSize)(this.diagram);\n        var boundingRect = this.diagram.element.getBoundingClientRect();\n        this.diagram.modifyBounds(boundingRect);\n        offsetX = offsetX + this.diagram.diagramCanvas.scrollLeft - boundingRect.left - position.width;\n        offsetY = offsetY + this.diagram.diagramCanvas.scrollTop - boundingRect.top - position.height;\n        offsetX /= this.diagram.scroller.transform.scale;\n        offsetY /= this.diagram.scroller.transform.scale;\n        offsetX -= this.diagram.scroller.transform.tx;\n        offsetY -= this.diagram.scroller.transform.ty;\n        return { x: offsetX, y: offsetY };\n    };\n    /**\n     * @private\n     */\n    DiagramEventHandler.prototype.windowResize = function (evt) {\n        var _this = this;\n        if (this.resizeTo) {\n            clearTimeout(this.resizeTo);\n        }\n        this.resizeTo = setTimeout(function () {\n            _this.updateViewPortSize(_this.diagram.element);\n        }, 300);\n        return false;\n    };\n    /**\n     * @private\n     */\n    DiagramEventHandler.prototype.updateViewPortSize = function (element) {\n        var container = document.getElementById(element.id);\n        if (container) {\n            var bounds = container.getBoundingClientRect();\n            this.diagram.modifyBounds(bounds);\n            this.diagram.scroller.setViewPortSize(bounds.width, bounds.height);\n            var position = new _primitives_size__WEBPACK_IMPORTED_MODULE_14__.Size();\n            position = (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_18__.getRulerSize)(this.diagram);\n            var width = this.diagram.getSizeValue(this.diagram.width, position.width);\n            var height = this.diagram.getSizeValue(this.diagram.height, position.height);\n            this.diagram.diagramCanvas.style.width = width;\n            this.diagram.diagramCanvas.style.height = height;\n            this.diagram.scroller.setSize();\n            this.diagram.transformLayers();\n            if (this.diagram.rulerSettings.showRulers) {\n                (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_18__.updateRuler)(this.diagram);\n            }\n            if (this.diagram.views.length > 1) {\n                //884316 - updating overview after window resize\n                for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n                    var temp = _a[_i];\n                    var view = this.diagram.views[\"\" + temp];\n                    if ((view instanceof _overview_overview__WEBPACK_IMPORTED_MODULE_25__.Overview)) {\n                        //Calling onproperty change method to update overview.\n                        view.onPropertyChanged({ sourceID: view.sourceID }, {});\n                    }\n                }\n            }\n        }\n    };\n    /** @private */\n    DiagramEventHandler.prototype.canHideResizers = function () {\n        return ((this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.RotateTool) && this.isMouseDown);\n    };\n    /** @private */\n    DiagramEventHandler.prototype.updateCursor = function () {\n        if ((this.diagram.selectedItems.nodes.length === 1 || this.diagram.selectedItems.connectors.length === 1)) {\n            var list = [];\n            list = list.concat(this.diagram.selectedItems.nodes, this.diagram.selectedItems.connectors);\n            // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node\n            this.blocked = (this.eventArgs && this.eventArgs.source && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canMove)(this.eventArgs.source)) ? false :\n                (this.isMouseDown && list.length === 1 && this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.SelectTool && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canMove)(list[0]));\n        }\n    };\n    DiagramEventHandler.prototype.isForeignObject = function (target, isTextBox) {\n        var foreignobject = target;\n        if (foreignobject) {\n            while (foreignobject.parentNode !== null) {\n                if (typeof foreignobject.className === 'string' &&\n                    ((!isTextBox && foreignobject.className.indexOf('foreign-object') !== -1) ||\n                        (isTextBox && foreignobject.className.indexOf('e-diagram-text-edit') !== -1))) {\n                    return foreignobject;\n                }\n                else {\n                    foreignobject = foreignobject.parentNode;\n                }\n            }\n        }\n        return null;\n    };\n    DiagramEventHandler.prototype.isMetaKey = function (evt) {\n        //EJ2-55887 - added the beow code to perform pinch zoom in mac os and windows while pinch zoom all browser return ctrl key as true.\n        if (evt.type === 'mousewheel') {\n            return evt.ctrlKey;\n        }\n        else {\n            return navigator.platform.match('Mac') ? evt.metaKey : evt.ctrlKey;\n        }\n    };\n    DiagramEventHandler.prototype.renderUmlHighLighter = function (args) {\n        this.diagram.commandHandler.removeStackHighlighter();\n        var node = this.diagram.selectedItems.nodes[0];\n        if (node && node.container && node.container.type === 'Stack' && node.shape.type === 'UmlClassifier') {\n            var bound = node.wrapper.bounds;\n            if (!bound.containsPoint(this.currentPosition)) {\n                // eslint-disable-next-line max-len\n                var objects = this.diagram.findObjectsUnderMouse({ x: this.currentPosition.x - 20, y: this.currentPosition.y });\n                var target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n                if (target && target.parentId && (target.parentId === node.id)) {\n                    // eslint-disable-next-line max-len\n                    var isVertical = this.diagram.nameTable[target.parentId].container.orientation === 'Vertical';\n                    (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.renderStackHighlighter)(target.wrapper, isVertical, args.position, this.diagram, true);\n                }\n            }\n        }\n    };\n    DiagramEventHandler.prototype.isDeleteKey = function (key, value) {\n        return (navigator.platform.match('Mac') && key === 'Backspace' && value === 'delete');\n    };\n    DiagramEventHandler.prototype.isMouseOnScrollBar = function (evt) {\n        var x = evt.offsetX;\n        var y = evt.offsetY;\n        var diagramCanvas = this.diagram.diagramCanvas;\n        var height = diagramCanvas.offsetHeight;\n        var width = diagramCanvas.offsetWidth;\n        var topLeft;\n        var topRight;\n        var bottomLeft;\n        var bottomRight;\n        var bounds;\n        if (height < diagramCanvas.scrollHeight) {\n            //default scrollbar width in browser is '17pixels'.\n            topLeft = { x: (width - 17), y: 0 };\n            topRight = { x: width, y: 0 };\n            bottomLeft = { x: (width - 17), y: height };\n            bottomRight = { x: width, y: height };\n            bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_16__.Rect.toBounds([topLeft, topRight, bottomLeft, bottomRight]);\n            // EJ2-64563-Added below code to calculate the bounds x and y value if vertical offset != 0\n            if (this.diagram.scroller.verticalOffset !== 0) {\n                bounds.x = bounds.x - this.diagram.scroller.horizontalOffset;\n                bounds.y = bounds.y - this.diagram.scroller.verticalOffset;\n            }\n            if (bounds.containsPoint({ x: x, y: y })) {\n                return true;\n            }\n        }\n        if (width < diagramCanvas.scrollWidth) {\n            topLeft = { x: 0, y: (height - 17) };\n            topRight = { x: width, y: (height - 17) };\n            bottomLeft = { x: 0, y: height };\n            bottomRight = { x: width, y: height };\n            bounds = _primitives_rect__WEBPACK_IMPORTED_MODULE_16__.Rect.toBounds([topLeft, topRight, bottomLeft, bottomRight]);\n            // EJ2-64563-Added below code to calculate the bounds x and y value if horizontal offset != 0\n            if (this.diagram.scroller.horizontalOffset !== 0) {\n                bounds.x = bounds.x - this.diagram.scroller.horizontalOffset;\n                bounds.y = bounds.y - this.diagram.scroller.verticalOffset;\n            }\n            if (bounds.containsPoint({ x: x, y: y })) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**   @private  */\n    DiagramEventHandler.prototype.updateVirtualization = function () {\n        var _this = this;\n        var delay = 50;\n        //let removeObjectInterval: Object;\n        var removeObjectInterval = setInterval(function (args) {\n            _this.diagram.removeVirtualObjects(removeObjectInterval);\n        }, delay);\n        setTimeout(function () {\n            _this.diagram.deleteVirtualObject = true;\n        }, delay);\n    };\n    DiagramEventHandler.prototype.checkPreviousAction = function () {\n        if (this.action !== this.previousAction && this.diagram.selectedItems.userHandles.length) {\n            for (var i = 0; i < this.diagram.selectedItems.userHandles.length; i++) {\n                if (this.previousAction && this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)]) {\n                    this.checkUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseLeave);\n                    this.previousAction = 'None';\n                }\n            }\n        }\n        if (this.action !== this.previousAction) {\n            // If the mouse leaves the fixed user handle, the tooltip is closed\n            this.checkFixedUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseLeave, this.targetItem, this.previousTarget);\n            this.previousTarget = null;\n            this.targetItem = null;\n        }\n    };\n    DiagramEventHandler.prototype.checkUserHandleEvent = function (eventName) {\n        if (this.diagram.selectedItems && this.diagram.selectedItems.userHandles.length > 0) {\n            var currentAction = (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseLeave) ? this.previousAction : this.action;\n            var arg = { element: undefined };\n            for (var i = 0; i < this.diagram.selectedItems.userHandles.length; i++) {\n                if ((currentAction === this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name) ||\n                    (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseUp && currentAction === 'Select')) {\n                    arg.element = this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)];\n                    this.userHandle(eventName, i, arg, null);\n                }\n            }\n        }\n    };\n    DiagramEventHandler.prototype.userHandle = function (eventName, i, arg, targetItem) {\n        if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseEnter || eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseEnter) {\n            this.previousAction = this.action;\n            // EJ2-32213- Added the below code to check whether the userhandle has tooltip content.\n            // If userhandle has tooltip content then we open the tooltip based on the userhandle shape\n            if (arg.element.tooltip && arg.element.tooltip.openOn === 'Auto' && arg.element.tooltip.content !== '') {\n                (0,_objects_tooltip__WEBPACK_IMPORTED_MODULE_11__.updateTooltip)(this.diagram, arg.element);\n                var targetEle = void 0;\n                if (arg.element.pathData) {\n                    if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseEnter) {\n                        targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_userhandle');\n                    }\n                    else if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseEnter) {\n                        targetEle = document.getElementById(targetItem.id + '_' + targetItem.fixedUserHandles[parseInt(i.toString(), 10)].id + '_groupElement');\n                    }\n                }\n                else if (arg.element.source) {\n                    targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_image');\n                }\n                else if (arg.element.content) {\n                    targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_shape_native_element');\n                }\n                else {\n                    targetEle = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_shape_html_element');\n                }\n                //892828: Flickering of tooltip while hovering userhandle\n                if (arg.element.tooltip.openOn === 'Auto' && (arg.element !== this.isUserHandleHover)) {\n                    this.isUserHandleHover = arg.element;\n                    this.diagram.tooltipObject.open(targetEle);\n                }\n            }\n            this.diagram.triggerEvent(eventName, arg);\n        }\n        if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseDown) {\n            this.userHandleObject = this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name;\n            this.diagram.triggerEvent(eventName, arg);\n        }\n        else if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseDown) {\n            this.diagram.triggerEvent(eventName, arg);\n        }\n        if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseUp) {\n            var element = document.getElementById(this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)].name + '_userhandle');\n            if (this.commandHandler.isUserHandle(this.currentPosition)\n                && element && element.id === this.userHandleObject + '_userhandle') {\n                //EJ2-838423 -onUserHandleMouseUp event triggers multiple times\n                this.diagram.triggerEvent(eventName, arg);\n            }\n        }\n        else if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseUp) {\n            this.diagram.triggerEvent(eventName, arg);\n        }\n        if (eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseLeave || eventName === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseLeave) {\n            if (this.diagram.tooltipObject && this.diagram.tooltipObject.openOn !== 'Custom') {\n                this.isUserHandleHover = null;\n                this.diagram.tooltipObject.close();\n            }\n            this.diagram.triggerEvent(eventName, arg);\n        }\n    };\n    // In the method, verify the fixed user handle and manage the opening and closing of the tooltip according to mouse events\n    DiagramEventHandler.prototype.checkFixedUserHandleEvent = function (eventName, targetItem, wrapper) {\n        if (targetItem && targetItem.fixedUserHandles.length > 0) {\n            var arg = { element: undefined };\n            var userid = void 0;\n            var currentAction = void 0;\n            for (var i = 0; i < targetItem.fixedUserHandles.length; i++) {\n                userid = targetItem.fixedUserHandles[parseInt(i.toString(), 10)].id;\n                if (wrapper && wrapper.id && (wrapper.id.indexOf(userid) > -1)) {\n                    currentAction = userid;\n                    this.previousTarget = wrapper;\n                    this.targetItem = targetItem;\n                }\n                if (currentAction === targetItem.fixedUserHandles[parseInt(i.toString(), 10)].id) {\n                    arg.element = targetItem.fixedUserHandles[parseInt(i.toString(), 10)];\n                    this.userHandle(eventName, i, arg, targetItem);\n                }\n            }\n        }\n    };\n    DiagramEventHandler.prototype.mouseDown = function (evt) {\n        var _this = this;\n        //Bug 913785: Tooltip for node is not showing when touch and hold on node in mobile device.\n        if (evt.type === 'touchstart') {\n            this.timeOutTapHold = setTimeout(function () {\n                if (_this.action === 'Select' || _this.action === 'Drag') {\n                    _this.mouseMove(evt, undefined);\n                }\n            }, 500);\n        }\n        // EJ2-57541 - Added the below code to check whether diagram tool is instance of node drawing tool or connector drawing tool.\n        // If node or connector drawing tool means then we have returned without perform any operation.\n        // 923532: Event 'Completed' state not triggered with multiple button click Action\n        if ((this.inAction === true && ((this.tool) instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.NodeDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectorDrawingTool)) ||\n            (this.inAction === true && (evt.buttons && (evt.buttons & (evt.buttons - 1)) !== 0))) {\n            return;\n        }\n        this.focus = true;\n        //let touches: TouchList;\n        var touches = evt.touches;\n        var isSymblDragging = document.getElementsByClassName('e-dragclone')[0] ? true : false;\n        if (this.isMouseOnScrollBar(evt) && !isSymblDragging) {\n            this.isScrolling = true;\n            evt.preventDefault();\n            return;\n        }\n        // commanded by gowtham- unwanted cloning of selectedItems\n        // if (isBlazor()) {\n        //     this.commandHandler.oldSelectedObjects = cloneObject(this.diagram.selectedItems);\n        // }\n        this.checkFixedUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseDown, this.targetItem, this.previousTarget);\n        this.checkUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseDown);\n        if (!this.checkEditBoxAsTarget(evt) && ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canUserInteract)(this.diagram)) ||\n            ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canZoomPan)(this.diagram) && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.defaultTool)(this.diagram))) {\n            if (this.action === 'Select' || this.action === 'Drag') {\n                this.diagram.updatePortVisibility(this.hoverElement, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, true);\n            }\n            if (((this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool)\n                && (evt.button === 2 || evt.buttons === 2))) {\n                // eslint-disable-next-line\n                var arg = {\n                    element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.diagram), position: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.currentPosition),\n                    count: evt.buttons, actualObject: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.eventArgs.actualObject),\n                    button: (evt.button === 0) ? 'Left' : (evt.button === 1) ? 'Middle' : 'Right'\n                };\n                this.inAction = false;\n                this.tool.mouseUp(this.eventArgs);\n            }\n            else if (((this.inAction === true) && this.isMouseDown === true &&\n                (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool))) {\n                this.isMouseDown = true;\n                this.eventArgs = {};\n                this.getMouseEventArgs(this.currentPosition, this.eventArgs);\n                this.eventArgs.position = this.currentPosition;\n                this.tool.mouseDown(this.eventArgs);\n            }\n            else {\n                this.isMouseDown = true;\n                this.currentPosition = this.prevPosition = this.getMousePosition(evt);\n                this.eventArgs = {};\n                if (this.diagram.textEditing && !this.isMouseOnScrollBar(evt)) {\n                    this.diagram.endEdit();\n                    this.diagram.textEditing = false;\n                    // EJ2-57743 - Added below code to refresh the diagram layer after the annotation gets edited in canvas mode.\n                    if (this.diagram.mode === 'Canvas' && this.diagram.scroller.currentZoom !== 1) {\n                        this.diagram.refreshDiagramLayer();\n                    }\n                }\n                var targetObject = this.getTargetElement();\n                this.action = this.diagram.findActionToBeDone(targetObject.obj, targetObject.sourceElement, this.currentPosition, targetObject.target);\n                //work around - correct it\n                var ctrlKey = this.isMetaKey(evt);\n                if (ctrlKey && evt.shiftKey && this.diagram.connectorEditingToolModule) {\n                    this.action = 'SegmentEnd';\n                    //Bug 892496: Unable to unselect selected node using CTRL+Click when zoompan is enabled.\n                    //Added this condition whether single select or multi select is enabled in diagram tool.\n                }\n                else if ((ctrlKey || evt.shiftKey) && ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canSingleSelect)(this.diagram) || (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canMultiSelect)(this.diagram))) {\n                    this.action = 'Select';\n                }\n                this.tool = this.diagram.getTool(this.action);\n                if (!this.tool) {\n                    this.action = 'Select';\n                    this.tool = this.diagram.getTool(this.action);\n                }\n                this.getMouseEventArgs(this.currentPosition, this.eventArgs);\n                if (ctrlKey || evt.shiftKey) {\n                    var info = (ctrlKey && evt.shiftKey) ? { ctrlKey: ctrlKey, shiftKey: evt.shiftKey } : { ctrlKey: true };\n                    this.eventArgs.info = info;\n                }\n                this.eventArgs.position = this.currentPosition;\n                //834641 -  Support to unselect the diagram element that is already selected\n                var prevSelectedNode = this.diagram.selectedItems.nodes;\n                this.tool.mouseDown(this.eventArgs);\n                if (this.diagram.selectedItems.canToggleSelection && prevSelectedNode\n                    && this.diagram.selectedItems.nodes && this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool) {\n                    for (var i = 0; i < prevSelectedNode.length; i++) {\n                        if (prevSelectedNode[parseInt(i.toString(), 10)].id\n                            !== this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].id) {\n                            this.isSwimlaneSelected = true;\n                        }\n                    }\n                }\n                this.initialEventArgs = { source: this.eventArgs.source, sourceWrapper: this.eventArgs.sourceWrapper };\n                this.initialEventArgs.position = this.currentPosition;\n                this.initialEventArgs.info = this.eventArgs.info;\n                this.inAction = false;\n                if (evt.type === 'touchstart') {\n                    if (touches && touches.length >= 2) {\n                        this.touchStartList = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.addTouchPointer)(this.touchStartList, evt, touches);\n                    }\n                    if (!touches) {\n                        evt.preventDefault();\n                    }\n                }\n            }\n        }\n        if (!this.isForeignObject(evt.target) && !this.isForeignObject(evt.target, true) && (!touches)) {\n            evt.preventDefault();\n        }\n    };\n    /**   @private  */\n    DiagramEventHandler.prototype.mouseMoveExtend = function (e, obj) {\n        if (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool) {\n            this.tool.mouseMove(this.eventArgs);\n        }\n        if (this.diagram.scrollSettings.canAutoScroll) {\n            this.checkAutoScroll(e);\n        }\n        else {\n            if (!this.blocked) {\n                (this.tool.mouseMove(this.eventArgs));\n            }\n        }\n        if (this.eventArgs.target) {\n            this.hoverElement = this.eventArgs.target;\n        }\n        var isNode = (this.eventArgs.target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || this.eventArgs.target instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector)\n            && (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) ? false : true;\n        if (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectTool) {\n            this.diagram.updatePortVisibility((this.hoverElement instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || this.hoverElement instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector)\n                ? this.hoverElement : this.hoverNode, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Connect | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, isNode);\n        }\n        if (this.hoverElement instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node\n            && this.hoverNode instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node && this.hoverNode && this.hoverNode.id !== this.hoverElement.id) {\n            this.diagram.updatePortVisibility(this.hoverNode, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Connect | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, true);\n        }\n        if (this.hoverElement instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector && (this.hoverElement.ports.length > 0)) {\n            this.diagram.updatePortVisibility(this.hoverElement, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Connect | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, true);\n        }\n        // 890089: Unintended Port Visibility Issue Fix\n        // Updating port visibility based on the previous hoverElement\n        if (this.previousElement instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node && this.hoverElement && (this.previousElement.id !== this.hoverElement.id)) {\n            this.diagram.updatePortVisibility(this.previousElement, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Connect | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, true);\n        }\n        this.previousElement = this.hoverElement;\n        // Updating tooltip content on mouse relative mode\n        if (this.diagram.tooltip.content !== '') {\n            this.hoverElement = null;\n        }\n        this.hoverNode = isNode ? null : obj;\n    };\n    /** @private */\n    DiagramEventHandler.prototype.checkAction = function (obj) {\n        if (this.action === 'LabelSelect' && this.eventArgs.sourceWrapper &&\n            (this.eventArgs.sourceWrapper instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_13__.TextElement || this.eventArgs.sourceWrapper instanceof _core_elements_html_element__WEBPACK_IMPORTED_MODULE_22__.DiagramHtmlElement)) {\n            var annotation = this.commandHandler.findTarget(this.eventArgs.sourceWrapper, this.eventArgs.source);\n            if (!(0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(this.diagram, annotation, false, this.eventArgs.sourceWrapper) && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canMove)(annotation)) {\n                this.action = 'LabelDrag';\n                this.tool = this.getTool(this.action);\n                this.tool.mouseDown(this.initialEventArgs);\n            }\n        }\n        else if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canMove)(obj) && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canSelect)(obj) && this.initialEventArgs &&\n            this.initialEventArgs.source && this.action === 'Select') {\n            if (!(0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(this.diagram, this.eventArgs.source, false) &&\n                this.eventArgs.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector) {\n                this.getMouseEventArgs(this.currentPosition, this.eventArgs);\n            }\n            if (!(obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) || (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector &&\n                !((0,_actions__WEBPACK_IMPORTED_MODULE_7__.contains)(this.currentPosition, obj.sourcePoint, obj.hitPadding) ||\n                    (0,_actions__WEBPACK_IMPORTED_MODULE_7__.contains)(this.currentPosition, obj.targetPoint, obj.hitPadding)))) {\n                this.action = 'Drag';\n            }\n            this.tool = this.getTool(this.action);\n            this.tool.mouseDown(this.initialEventArgs);\n        }\n    };\n    DiagramEventHandler.prototype.isSwimlaneElements = function (obj) {\n        if (obj && (obj.isLane || obj.isPhase || obj.isHeader)) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    //To decide whether to show tooltip on touch long press\n    DiagramEventHandler.prototype.canShowTouchTooltip = function (evt) {\n        if (evt.type === 'touchstart') {\n            if ((this.diagram.tool & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramTools.SingleSelect) && (this.diagram.tool & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramTools.ZoomPan)) {\n                this.isMouseDown = false;\n                return true;\n            }\n        }\n        return false;\n    };\n    /* tslint:disable */\n    /** @private */\n    DiagramEventHandler.prototype.mouseMove = function (e, touches) {\n        this.focus = true;\n        //Bug 914365: Node is not resizable using touch interaction\n        if (e.type === 'touchmove') {\n            this.touchArgs = { target: e.target, type: 'touchmove' };\n        }\n        if (this.isScrolling) {\n            e.preventDefault();\n            return;\n        }\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canUserInteract)(this.diagram) || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canZoomPan)(this.diagram) && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.defaultTool)(this.diagram))) {\n            this.currentPosition = this.getMousePosition(e);\n            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n            (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_18__.drawRulerMarkers)(this.diagram, this.currentPosition);\n            var force = false;\n            var target = void 0;\n            if (e.type === 'touchmove') {\n                touches = e.touches;\n                if (touches && touches.length > 1) {\n                    this.touchMoveList = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.addTouchPointer)(this.touchMoveList, e, touches);\n                    if (this.action !== 'PinchZoom') {\n                        force = true;\n                    }\n                }\n            }\n            if (_primitives_point__WEBPACK_IMPORTED_MODULE_1__.Point.equals(this.currentPosition, this.prevPosition) === false || this.inAction || this.canShowTouchTooltip(e)) {\n                if (this.isMouseDown === false || force) {\n                    this.eventArgs = {};\n                    var sourceElement = null;\n                    var tooltipTarget = void 0;\n                    if (obj !== null) {\n                        sourceElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);\n                        //834842-Exception/error occurs when hovering on the connector\n                        //tooltiptarget to be found only if the source element is not null\n                        if (sourceElement) {\n                            tooltipTarget = this.commandHandler.findTarget(sourceElement, obj);\n                        }\n                        //908569: Node Tooltip Flickers when hovering on Annotation\n                        //If the annotation does not have tooltip content, set the tooltip target as an object\n                        if (tooltipTarget instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.ShapeAnnotation || tooltipTarget instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation) {\n                            if (!(tooltipTarget.tooltip && tooltipTarget.tooltip.content !== '')) {\n                                tooltipTarget = obj;\n                            }\n                        }\n                        if (tooltipTarget !== this.hoverElement) {\n                            var content_1 = this.getContent();\n                            if (this.hoverElement && this.hoverElement.tooltip.openOn === 'Auto' && content_1 !== '') {\n                                this.elementLeave();\n                            }\n                            this.diagram.updatePortVisibility(this.hoverElement, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, true);\n                            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node) {\n                                this.hoverNode = obj;\n                            }\n                            var canResetElement = true;\n                            if (!this.isSwimlaneElements(obj)\n                                && (this.hoverElement && this.isSwimlaneElements(this.hoverElement))) {\n                                canResetElement = false;\n                            }\n                            this.hoverElement = canResetElement ? obj : this.hoverElement;\n                            //EJ2-62120 - Provide tooltip support for ports - to set hoverelement as PathElement if hovered on ports in Node\n                            var portElement = null;\n                            var portTarget = void 0;\n                            portElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);\n                            if (portElement instanceof _index__WEBPACK_IMPORTED_MODULE_23__.PathElement) {\n                                portTarget = this.commandHandler.findTarget(portElement, obj);\n                                if ((portTarget instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PointPort || portTarget instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PathPort)\n                                    && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortConstraints.ToolTip) {\n                                    this.hoverElement = portTarget;\n                                }\n                            }\n                            //839511: Tooltip support for annotation - to set hoverelement as TextElement if hovered on annotation in Node/Connector\n                            var annotationTarget = void 0;\n                            if (portElement instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_13__.TextElement) {\n                                annotationTarget = this.commandHandler.findTarget(portElement, obj);\n                                if ((annotationTarget instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.ShapeAnnotation || annotationTarget instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation)\n                                    && annotationTarget.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.AnnotationConstraints.Tooltip) {\n                                    this.hoverElement = annotationTarget;\n                                }\n                            }\n                            if (canResetElement) {\n                                this.elementEnter(this.currentPosition, false);\n                            }\n                            else {\n                                this.hoverElement = obj;\n                            }\n                        }\n                        // EJ2-66418 - set tooltip relativeMode as mouse\n                        // Updating the tooltip position based on Mouse move\n                        else if (this.hoverElement) {\n                            if (this.hoverElement === tooltipTarget && this.hoverElement.tooltip.content && this.diagram.tooltipObject !== undefined && this.hoverElement.tooltip.relativeMode === 'Mouse') {\n                                this.setTooltipOffset(this.currentPosition);\n                            }\n                        }\n                        if (sourceElement) {\n                            target = this.commandHandler.findTarget(sourceElement, obj);\n                        }\n                    }\n                    this.action = this.diagram.findActionToBeDone(obj, sourceElement, this.currentPosition, target);\n                    this.checkFixedUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseEnter, obj, sourceElement);\n                    this.checkUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseEnter);\n                    this.checkPreviousAction();\n                    this.getMouseEventArgs(this.currentPosition, this.eventArgs);\n                    this.tool = this.getTool(this.action);\n                    this.mouseEvents();\n                    if (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectorDrawingTool ||\n                        this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool ||\n                        this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool) {\n                        this.tool.mouseMove(this.eventArgs);\n                    }\n                    else if (touches && this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ZoomPanTool) {\n                        this.tool.mouseDown(this.eventArgs);\n                    }\n                    this.updateCursor();\n                    this.renderUmlHighLighter(this.eventArgs);\n                    var isNode = false;\n                    if (!(this.hoverElement && (!(this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ZoomPanTool))\n                        && (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node && this.isSwimlaneElements(obj)) &&\n                        (this.diagram.selectedItems.nodes.length === 0 || !(0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(this.diagram, this.hoverElement)))\n                        && (!(this.hoverElement instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector))) {\n                        isNode = true;\n                    }\n                    if (!(this.hoverElement && (!(this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ZoomPanTool))\n                        && (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) &&\n                        (this.diagram.selectedItems.connectors.length === 0 || !(0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(this.diagram, this.hoverElement)))\n                        && (!(this.hoverElement instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node))) {\n                        isNode = true;\n                    }\n                    this.diagram.updatePortVisibility(this.hoverElement, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, isNode);\n                    var content = this.getContent();\n                    if (obj === null && this.hoverElement && this.hoverElement.tooltip.openOn === 'Auto' && content) {\n                        this.hoverElement = null;\n                        this.elementLeave();\n                    }\n                    force = false;\n                }\n                else {\n                    this.eventArgs.position = this.currentPosition;\n                    if (this.action === 'Drag' && !(0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(this.diagram, this.eventArgs.source, false) &&\n                        this.eventArgs.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector) {\n                        this.getMouseEventArgs(this.currentPosition, this.eventArgs);\n                    }\n                    this.mouseEvents();\n                    if (e.ctrlKey || e.shiftKey) {\n                        var info = (e.ctrlKey && e.shiftKey) ? { ctrlKey: e.ctrlKey, shiftKey: e.shiftKey } : { ctrlKey: true };\n                        this.eventArgs.info = info;\n                    }\n                    this.checkAction(obj);\n                    var padding = this.getConnectorPadding(this.eventArgs);\n                    this.getMouseEventArgs(this.currentPosition, this.eventArgs, this.eventArgs.source, padding);\n                    this.updateCursor();\n                    this.inAction = true;\n                    this.initialEventArgs = null;\n                    if (this.action === 'Drag' || this.action === 'Rotate') {\n                        this.diagram.diagramActions = this.diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.Interactions;\n                    }\n                    //Bug 863516: Overview is not synced with diagram content while zoom-out the diagram.\n                    //Checking page bounds before and after dragging node, and updating the overview rect if the page bounds modified after the drag.\n                    var preDragBounds = this.diagram.scroller.getPageBounds();\n                    this.mouseMoveExtend(e, obj);\n                    var postDragBounds = this.diagram.scroller.getPageBounds();\n                    if (obj && (preDragBounds.width !== postDragBounds.width ||\n                        preDragBounds.height !== postDragBounds.height ||\n                        preDragBounds.x !== postDragBounds.x ||\n                        preDragBounds.y !== postDragBounds.y)) {\n                        if (this.diagram.views && this.diagram.views.overview) {\n                            var overview = this.diagram.views.overview;\n                            overview.updateView(overview);\n                        }\n                    }\n                }\n                this.prevPosition = this.currentPosition;\n                if (!this.isForeignObject(e.target, true)) {\n                    e.preventDefault();\n                }\n            }\n        }\n    };\n    /* tslint:enable */\n    DiagramEventHandler.prototype.getContent = function () {\n        var isPrivateTooltip = ((this.hoverElement instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node)\n            && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.Tooltip) ||\n            ((this.hoverElement instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.Tooltip)\n            || ((this.hoverElement instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PointPort || this.hoverElement instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PathPort)\n                && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortConstraints.ToolTip) ||\n            ((this.hoverElement instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.ShapeAnnotation || this.hoverElement instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation)\n                && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.AnnotationConstraints.Tooltip);\n        var node = this.hoverElement;\n        var childNode;\n        if (node instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node && node.children && node.children.length > 0) {\n            childNode = this.findIntersectChild(node);\n        }\n        var content = isPrivateTooltip ? this.hoverElement.tooltip.content :\n            this.diagram.tooltip.content;\n        content = childNode ? childNode.tooltip.content : content;\n        return content;\n    };\n    DiagramEventHandler.prototype.findIntersectChild = function (node) {\n        var childNode;\n        var rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_16__.Rect(this.currentPosition.x, this.currentPosition.y, 8, 8);\n        for (var i = 0; i < node.children.length; i++) {\n            childNode = this.diagram.getObject(node.children[parseInt(i.toString(), 10)]);\n            if (childNode.wrapper.outerBounds.intersects(rect)) {\n                return childNode;\n            }\n        }\n        return null;\n    };\n    DiagramEventHandler.prototype.checkAutoScroll = function (e) {\n        var autoScrollPosition = this.startAutoScroll(e);\n        if (!autoScrollPosition && this.doingAutoScroll) {\n            this.doingAutoScroll = false;\n            clearInterval(this.timeOutValue);\n        }\n        else if (autoScrollPosition) {\n            if ((this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.NodeDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectorDrawingTool\n                || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ResizeTool\n                || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.SelectTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectTool) && this.inAction) {\n                // eslint-disable-next-line @typescript-eslint/no-this-alias\n                var diagram_1 = this;\n                var delay_1 = this.diagram.scrollSettings.autoScrollFrequency;\n                if (delay_1 < 10 || isNaN(delay_1)) {\n                    delay_1 = 100;\n                }\n                if (this.diagram.scrollSettings.canAutoScroll && autoScrollPosition && !this.doingAutoScroll) {\n                    this.doingAutoScroll = true;\n                    this.timeOutValue = setInterval(function (args) {\n                        diagram_1.doAutoScroll(autoScrollPosition, e, delay_1);\n                    }, delay_1);\n                }\n            }\n        }\n        else {\n            this.blocked = !(this.tool.mouseMove(this.eventArgs));\n        }\n    };\n    /* tslint:disable */\n    /** @private */\n    DiagramEventHandler.prototype.mouseUp = function (evt) {\n        clearTimeout(this.timeOutTapHold);\n        //Bug 914365: Node is not resizable using touch interaction\n        this.touchArgs = undefined;\n        this.diagram.diagramRenderer.touchMove = undefined;\n        //EJ2-849817-Dropping nodes in swimlane does not consider as child in angular\n        if (this.eventArgs && this.eventArgs.target && this.eventArgs.target !== this.hoverNode\n            && this.eventArgs.target !== this.lastObjectUnderMouse) {\n            this.hoverNode = this.eventArgs.target;\n            this.lastObjectUnderMouse = this.eventArgs.target;\n        }\n        //Bug 881512: Wrapping of the connector annotation at run time not working properly.\n        //To wrap the connector annotation text after the node rotated or dragged.\n        var updateAnnotation = false;\n        if (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.RotateTool) {\n            updateAnnotation = true;\n        }\n        this.checkFixedUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onFixedUserHandleMouseUp, this.targetItem, this.previousTarget);\n        this.checkUserHandleEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.onUserHandleMouseUp);\n        if (this.diagram.mode === 'SVG' && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canVitualize)(this.diagram)) {\n            this.updateVirtualization();\n        }\n        var prevSelectedNodes = this.diagram.selectedItems.nodes;\n        var prevSelectedConnectors = this.diagram.selectedItems.connectors;\n        var unSelectLaneObj;\n        this.diagram.previousSelectedObject = null;\n        this.diagram.diagramRenderer.rendererActions =\n            this.diagram.removeConstraints(this.diagram.diagramRenderer.rendererActions, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.RendererAction.DrawSelectorBorder);\n        var touches = evt.touches;\n        if (this.isScrolling) {\n            this.isScrolling = false;\n            evt.preventDefault();\n            return;\n        }\n        if (!this.checkEditBoxAsTarget(evt) && ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canUserInteract)(this.diagram))\n            || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canZoomPan)(this.diagram) && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.defaultTool)(this.diagram))) {\n            if (this.tool && (!(this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool) ||\n                ((this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool)\n                    && evt.detail === 2))) {\n                if (!this.isForeignObject(evt.target) && this.isMouseDown) {\n                    document.getElementById(this.diagram.element.id + 'content').focus();\n                }\n                if (!this.inAction && evt.which !== 3) {\n                    if (this.action === 'Drag') {\n                        this.action = 'Select';\n                        var oldSelectedValue = (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));\n                        var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n                        var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n                        var isMultipleSelect = true;\n                        if ((!evt.ctrlKey && this.isMouseDown\n                            && (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length) > 1)\n                            && evt.which === 1 && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canPreventClearSelection)(this.diagram.diagramActions)) {\n                            isMultipleSelect = false;\n                            this.commandHandler.clearSelection();\n                        }\n                        if (!(0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(this.diagram, obj) || (!isMultipleSelect)) {\n                            this.commandHandler.selectObjects([obj], undefined, oldSelectedValue);\n                            //834641 - Support to unselect the diagram element that is already selected\n                            if (this.diagram.selectedItems.canToggleSelection) {\n                                var selectedObj = this.diagram.selectedItems.nodes;\n                                if (selectedObj) {\n                                    if (selectedObj[0].parentObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Lane) {\n                                        unSelectLaneObj = true;\n                                    }\n                                }\n                                else if (this.diagram.selectedItems.connectors.length > 0) {\n                                    unSelectLaneObj = true;\n                                }\n                            }\n                        }\n                    }\n                }\n                var avoidDropChildren = false;\n                var history_1 = this.updateContainerProperties();\n                var isGroupAction = void 0;\n                this.addUmlNode();\n                this.inAction = false;\n                this.isMouseDown = false;\n                //912163- Restricting node selection\n                if (this.diagram.selectedObject.helperObject) {\n                    isGroupAction = this.updateContainerBounds();\n                }\n                if (this.tool && (this.tool.prevPosition || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.LabelTool)) {\n                    this.eventArgs.position = this.currentPosition;\n                    var padding = this.getConnectorPadding(this.eventArgs);\n                    this.getMouseEventArgs(this.currentPosition, this.eventArgs, this.eventArgs.source, padding);\n                    var ctrlKey = this.isMetaKey(evt);\n                    if (ctrlKey || evt.shiftKey) {\n                        var info = (ctrlKey && evt.shiftKey) ? { ctrlKey: ctrlKey, shiftKey: evt.shiftKey } :\n                            { ctrlKey: true };\n                        this.eventArgs.info = info;\n                    }\n                    if (this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.Interactions) {\n                        this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.Interactions;\n                    }\n                    this.eventArgs.clickCount = evt.detail;\n                    if (this.diagram.selectedObject.helperObject && (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ResizeTool)) {\n                        if (this.diagram.selectedObject.actualObject &&\n                            this.diagram.selectedObject.actualObject.parentId !== '') {\n                            var parentNode = this.diagram.getObject(this.diagram.selectedObject.actualObject.parentId);\n                            if (parentNode && parentNode.isLane) {\n                                this.commandHandler.isContainer = true;\n                            }\n                        }\n                        avoidDropChildren = this.diagram.lineRoutingModule\n                            && this.diagram.nameTable['helper'] && this.eventArgs.target && this.eventArgs.target.isLane\n                            && ((this.eventArgs.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector && this.eventArgs.source.nodes.length > 0\n                                && this.eventArgs.source.nodes[0].parentId === '') || (this.eventArgs.source.parentId === ''));\n                        if (avoidDropChildren) {\n                            this.diagram.diagramActions = this.diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.PreventLaneContainerUpdate;\n                        }\n                        this.tool.mouseUp(this.eventArgs, history_1.isPreventHistory);\n                    }\n                    else {\n                        //834641 - Support to unselect the diagram element that is already selected\n                        if (this.diagram.selectedItems.canToggleSelection) {\n                            var isGroupObj = void 0;\n                            var isMultiSelect = void 0;\n                            if (this.diagram.selectedItems.nodes.length > 0) {\n                                for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {\n                                    var swimlane = (this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].isLane\n                                        || this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].isPhase);\n                                    if (!swimlane) {\n                                        if ((!(this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].parentObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Lane\n                                            || this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].parentObj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Phase))) {\n                                            isGroupObj = this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].parentId !== '' ? true : false;\n                                        }\n                                    }\n                                }\n                            }\n                            var currSelectedNodes = this.diagram.selectedItems.nodes;\n                            for (var i = 0; i < prevSelectedNodes.length; i++) {\n                                if ((prevSelectedNodes.length > 1 && currSelectedNodes[0].id\n                                    === prevSelectedNodes[parseInt(i.toString(), 10)].id) || prevSelectedConnectors.length > 0) {\n                                    isMultiSelect = true;\n                                }\n                            }\n                            if (!this.isSwimlaneSelected && !unSelectLaneObj && !isMultiSelect && this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool &&\n                                this.currentAction === 'Select' && (!isGroupObj || this.diagram.selectedItems.connectors.length > 0)) {\n                                this.commandHandler.clearSelection(true);\n                            }\n                        }\n                        this.isSwimlaneSelected = false;\n                        this.tool.mouseUp(this.eventArgs);\n                        if (this.diagram.checkMenu && (window.navigator.userAgent.indexOf('Linux') !== -1 || window.navigator.userAgent.indexOf('X11') !== -1)) {\n                            if (!evt.pageY && (evt instanceof TouchEvent) && evt.changedTouches) {\n                                window.getSelection().removeAllRanges();\n                                this.diagram.contextMenuModule.contextMenu.open(evt.changedTouches[0].pageY, evt.changedTouches[0].pageX, this.diagram.element);\n                                evt.preventDefault();\n                            }\n                            else {\n                                this.diagram.contextMenuModule.contextMenu.open(evt.pageY, evt.pageX, this.diagram.element);\n                            }\n                            this.diagram.checkMenu = false;\n                        }\n                    }\n                    if (history_1.hasStack) {\n                        this.diagram.endGroupAction();\n                    }\n                }\n                if (isGroupAction) {\n                    this.diagram.endGroupAction();\n                }\n                this.updateContainerBounds(true);\n                if (this.eventArgs.clickCount !== 2) {\n                    this.commandHandler.updateSelectedNodeProperties(this.eventArgs.source);\n                    if (avoidDropChildren) {\n                        this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.PreventLaneContainerUpdate;\n                        var nodes = this.eventArgs.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector\n                            ? this.eventArgs.source.nodes : [this.eventArgs.source];\n                        if (nodes) {\n                            for (var i = 0; i < nodes.length; i++) {\n                                if (!nodes[parseInt(i.toString(), 10)].container) {\n                                    this.commandHandler.dropChildToContainer(this.eventArgs.target, nodes[parseInt(i.toString(), 10)]);\n                                    this.commandHandler.renderContainerHelper(nodes[parseInt(i.toString(), 10)]);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this.diagram.selectedObject && this.diagram.selectedObject.helperObject) {\n                    //Bug 884946: Undo redo not working for swimlane child node's label edit.\n                    //committed to remove the diagram actions public method when actual object is inside swimlane.\n                    var isInsideLane = this.isSwimlaneChild(this.diagram.selectedObject.actualObject);\n                    //isSwimlaneChildHelper is used to check whether the helper object is child's helper of lane's helper. if it is lane's helper then we should not remove the DiagramAction.PublicMethod from diagram actions.\n                    //If we remove the DiagramAction.PublicMethod from diagram actions then undo redo will not work properly after dropping child from diagram to swimlane.\n                    var isSwimlaneChildHelper = this.diagram.selectedObject.actualObject &&\n                        this.diagram.selectedObject.actualObject.width === this.diagram.selectedObject.helperObject.width &&\n                        this.diagram.selectedObject.actualObject.height === this.diagram.selectedObject.helperObject.height;\n                    this.diagram.remove(this.diagram.selectedObject.helperObject);\n                    if (this.commandHandler.isTargetSubProcess(this.diagram.selectedObject.actualObject) && this.diagram.selectedObject.actualObject.parentId === '') {\n                        this.swapProcessChildInDom(this.diagram.element.id + '_diagramLayer', this.diagram.selectedObject.actualObject);\n                    }\n                    this.diagram.selectedObject = { helperObject: undefined, actualObject: undefined };\n                    // EJ2-42605 - Annotation undo redo not working properly if the line routing is enabled committed by sivakumar sekar\n                    // committed to remove the diagram actions public method when line routing is enabled\n                    // eslint-disable-next-line\n                    if ((this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.PublicMethod) && (this.diagram.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramConstraints.LineRouting) || (isInsideLane && isSwimlaneChildHelper)) {\n                        this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.PublicMethod;\n                    }\n                }\n                this.blocked = false;\n                if (this.hoverElement) {\n                    var portVisibility = _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Connect;\n                    if ((0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(this.diagram, this.hoverElement)) {\n                        portVisibility |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover;\n                    }\n                    this.diagram.updatePortVisibility(this.hoverElement, portVisibility, true);\n                    this.hoverElement = null;\n                }\n                this.touchStartList = null;\n                this.touchMoveList = null;\n                if (!(this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.TextDrawingTool)) {\n                    this.tool = null;\n                }\n            }\n            if (!touches) {\n                evt.preventDefault();\n            }\n            this.diagram.currentDrawingObject = undefined;\n            var selector = this.diagram.selectedItems;\n            var disbleRenderSelector = false;\n            if (this.commandHandler.isUserHandle(this.currentPosition)) {\n                if (this.isForeignObject(evt.target)) {\n                    disbleRenderSelector = true;\n                }\n            }\n            if (!this.inAction && selector.wrapper && selector.userHandles.length > 0 && !disbleRenderSelector) {\n                this.diagram.renderSelector(true);\n            }\n            if (!this.inAction && !this.diagram.currentSymbol && this.eventArgs) {\n                /**\n                 *\n                 * EJ2-45543 Provide Event support to notify the port click\n                 */\n                var targetObject = this.getTargetElement();\n                //909624: click event for fixed user handle notifies node as its element.\n                var arg = {\n                    element: (targetObject.target instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PointPort || targetObject.target instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PathPort ||\n                        targetObject.target instanceof _interaction_selector__WEBPACK_IMPORTED_MODULE_27__.UserHandle || targetObject.target instanceof _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_26__.NodeFixedUserHandle ||\n                        targetObject.target instanceof _objects_fixed_user_handle__WEBPACK_IMPORTED_MODULE_26__.ConnectorFixedUserHandle)\n                        ? targetObject.target : (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.eventArgs.source) || (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.diagram),\n                    position: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.eventArgs.position), count: evt.detail,\n                    actualObject: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.eventArgs.actualObject),\n                    button: (evt.button === 0) ? 'Left' : (evt.button === 1) ? 'Middle' : 'Right'\n                };\n                //Removed isBlazor code\n                if (this.diagram.tool !== _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramTools.ZoomPan) {\n                    this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.click, arg);\n                }\n            }\n            this.eventArgs = {};\n        }\n        this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.PreventLaneContainerUpdate;\n        if (updateAnnotation) {\n            this.updateAnnotation(this.diagram.selectedItems);\n        }\n        // 920132: Node Interactions Cause Previously Deleted Nodes to Reappear\n        this.previousElement = null;\n        this.eventArgs = {};\n        this.diagram.commandHandler.removeStackHighlighter(); // end the corresponding tool\n    };\n    //To check whether the node is child of swimlane or not.\n    DiagramEventHandler.prototype.isSwimlaneChild = function (node) {\n        if (node.shape && node.shape.type !== 'SwimLane') {\n            var parent_1 = this.diagram.nameTable[node.parentId];\n            if (!parent_1) {\n                return false;\n            }\n            var swimlane = parent_1.parentId ? this.diagram.nameTable[parent_1.parentId] : parent_1;\n            return swimlane && swimlane.shape && swimlane.shape.type === 'SwimLane';\n        }\n        else {\n            return false;\n        }\n    };\n    // To wrap connector annotation text based on the connector length.\n    DiagramEventHandler.prototype.updateAnnotation = function (selectedItems) {\n        var nodes = selectedItems.nodes;\n        if (nodes.length > 0) {\n            for (var i = 0; i < nodes.length; i++) {\n                var node = nodes[parseInt(i.toString(), 10)];\n                this.diagram.updateConnectorEdges(node);\n            }\n        }\n    };\n    // Adding child node of sub process in the diagram layer after the subprocess dropped out from swimlane to diagram.\n    DiagramEventHandler.prototype.swapProcessChildInDom = function (diagramLayerId, node) {\n        var diagramLayer = document.getElementById(diagramLayerId);\n        if (node.shape.activity.subProcess.processes) {\n            for (var i = 0; i < node.shape.activity.subProcess.processes.length; i++) {\n                var child = document.getElementById(node.shape.activity.subProcess.processes[parseInt(i.toString(), 10)] + '_groupElement');\n                if (child) {\n                    diagramLayer.appendChild(child);\n                }\n            }\n        }\n    };\n    /**\n     * return the clicked element such as node/connector/port/diagram\n     */\n    DiagramEventHandler.prototype.getTargetElement = function () {\n        var target;\n        var objects = this.objectFinder.findObjectsUnderMouse(this.currentPosition, this.diagram, this.eventArgs, null, this.action);\n        var obj = this.objectFinder.findObjectUnderMouse(this.diagram, objects, this.action, this.inAction, this.eventArgs, this.currentPosition);\n        //909623: click the user handle of a node, click event triggered. the element is diagram instead of fixed user handle.\n        if (this.previousAction !== 'None' && this.diagram.selectedItems.userHandles) {\n            for (var i = 0; i < this.diagram.selectedItems.userHandles.length; i++) {\n                var userHandle = this.diagram.selectedItems.userHandles[parseInt(i.toString(), 10)];\n                if (this.previousAction === userHandle.name) {\n                    target = userHandle;\n                }\n            }\n        }\n        var sourceElement = null;\n        if (obj !== null) {\n            sourceElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);\n            if (sourceElement) {\n                target = this.commandHandler.findTarget(sourceElement, obj);\n            }\n        }\n        var targetObject = {\n            'obj': obj,\n            'sourceElement': sourceElement,\n            'target': target\n        };\n        return targetObject;\n    };\n    /* tslint:enable */\n    DiagramEventHandler.prototype.getConnectorPadding = function (eventArgs) {\n        var padding;\n        var targetObject = eventArgs.source;\n        if (targetObject && (targetObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector) && targetObject.connectors.length) {\n            var selectedConnector = targetObject.connectors[0];\n            padding = (selectedConnector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.ConnectToNearByPort) ? selectedConnector.connectionPadding : 0;\n        }\n        else if (targetObject && (targetObject instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && this.action === 'PortDraw' && (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectorDrawingTool)) {\n            if (targetObject.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.ConnectToNearByPort) {\n                padding = targetObject.connectionPadding;\n            }\n        }\n        return padding || 0;\n    };\n    DiagramEventHandler.prototype.addSwimLaneObject = function (selectedNode) {\n        var swimlaneNode;\n        var targetNode;\n        var shape;\n        var value;\n        var canInsert;\n        var index = 0;\n        var offset;\n        var actualShape = selectedNode.shape;\n        var objects = this.objectFinder.findObjectsUnderMouse(this.currentPosition, this.diagram, this.eventArgs, null, this.action);\n        if (!targetNode) {\n            targetNode = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n        }\n        this.diagram.clearSelectorLayer();\n        if (targetNode && !(targetNode.isLane || targetNode.isPhase || targetNode.isHeader)) {\n            for (var i = 0; i < objects.length; i++) {\n                var laneNode = this.diagram.nameTable[objects[parseInt(i.toString(), 10)].id];\n                if (laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {\n                    targetNode = laneNode;\n                }\n            }\n        }\n        if (targetNode && (actualShape.isPhase || (actualShape.isLane && targetNode.isLane))) {\n            var id = targetNode.parentId;\n            swimlaneNode = this.diagram.nameTable[\"\" + id];\n        }\n        var orientationSwap = null;\n        if (swimlaneNode) {\n            shape = swimlaneNode.shape;\n            canInsert = (actualShape.isLane) ? actualShape.orientation === shape.orientation :\n                actualShape.orientation !== shape.orientation;\n            if (actualShape.isLane && actualShape.orientation !== shape.orientation) {\n                canInsert = true;\n                orientationSwap = actualShape.orientation === 'Horizontal' ? 'height' : 'width';\n            }\n        }\n        if (canInsert && targetNode) {\n            if (shape && shape.header && shape.hasHeader && shape.orientation === 'Horizontal') {\n                index = 1;\n            }\n            if (shape.phases.length > 0) {\n                index += 1;\n            }\n            if (actualShape.isPhase) {\n                if (shape.orientation === 'Horizontal') {\n                    offset = this.currentPosition.x - swimlaneNode.wrapper.bounds.x;\n                }\n                else {\n                    offset = this.currentPosition.y - (swimlaneNode.wrapper.bounds.y +\n                        (shape.hasHeader ? shape.header.height : 0));\n                }\n                var phases = { id: (0,_index__WEBPACK_IMPORTED_MODULE_23__.randomId)(), offset: offset, header: { annotation: {\n                            content: actualShape.phases[0].header === undefined ? 'Phase' : actualShape.phases[0].header.annotation.content,\n                            style: actualShape.phases[0].header === undefined ? {} : actualShape.phases[0].header.annotation.style\n                        } },\n                    //882239 - Fill color not applied properly while adding phase at runtime\n                    style: actualShape.phases[0] === undefined ? {} : actualShape.phases[0].style };\n                this.diagram.addPhases(swimlaneNode, [phases]);\n            }\n            else {\n                //const laneHeight: number = actualShape.lanes[0].header.height;\n                var lane = {\n                    id: (0,_index__WEBPACK_IMPORTED_MODULE_23__.randomId)(), style: actualShape.lanes[0].style,\n                    //Bug 912452: Disable canMove for lane symbol won't work when its tried to swap after its addition to swimlane\n                    //Added canMove property to lane symbol which is dropped from symbol palette.\n                    canMove: actualShape.lanes[0].canMove,\n                    header: {\n                        annotation: {\n                            content: actualShape.lanes[0].header.annotation.content,\n                            style: actualShape.lanes[0].header.annotation.style\n                        },\n                        style: actualShape.lanes[0].header.style\n                    }\n                };\n                var orientation_1 = (actualShape.orientation === 'Horizontal') ? true : false;\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                orientation_1 ? lane.height = actualShape.lanes[0].height : lane.width = actualShape.lanes[0].width;\n                if (shape.orientation === 'Horizontal') {\n                    value = targetNode.rowIndex ? targetNode.rowIndex :\n                        this.diagram.nameTable[targetNode.parentId].rowIndex;\n                    if (targetNode.wrapper.offsetY < this.currentPosition.y) {\n                        value += 1;\n                    }\n                }\n                else {\n                    value = targetNode.columnIndex ? targetNode.columnIndex :\n                        this.diagram.nameTable[targetNode.parentId].columnIndex;\n                    if (this.currentPosition.x < targetNode.wrapper.bounds.center.x) {\n                        value -= 1;\n                    }\n                }\n                if (shape.lanes.length > (value)) {\n                    lane.header.width = shape.lanes[parseInt(value.toString(), 10)].header.width;\n                    lane.header.height = shape.lanes[parseInt(value.toString(), 10)].header.height;\n                }\n                else {\n                    //EJ2-64457 - Not able to add lane in the existing vertical swimlane.\n                    var ind = void 0;\n                    if (shape.orientation === 'Horizontal') {\n                        ind = targetNode.rowIndex < 3 ? 0 : value - index - 1;\n                    }\n                    else {\n                        ind = value - 1;\n                    }\n                    lane.header.width = shape.lanes[parseInt(ind.toString(), 10)].header.width;\n                    lane.header.height = shape.lanes[parseInt(ind.toString(), 10)].header.height;\n                }\n                //Bug 879093: Incorrect helperguide for vertical and horizontal swim lanes.\n                //With below code, we swap the height and width property of lane based on orientationSwap value.\n                if (orientationSwap) {\n                    if (orientationSwap === 'height') {\n                        lane.width = lane.height;\n                        delete lane.height;\n                    }\n                    else {\n                        lane.height = lane.width;\n                        delete lane.width;\n                    }\n                }\n                this.diagram.addLanes(swimlaneNode, [lane], shape.orientation === 'Horizontal' ? value - index : value);\n            }\n            this.commandHandler.select(swimlaneNode);\n        }\n        else if (actualShape.isLane) {\n            var swimLaneobj = {\n                id: (0,_index__WEBPACK_IMPORTED_MODULE_23__.randomId)(), width: selectedNode.width, height: selectedNode.height, addInfo: selectedNode.addInfo,\n                shape: {\n                    type: 'SwimLane',\n                    header: {\n                        //864525-Issue in updating swimlane header properties dynamically\n                        annotation: {\n                            content: actualShape.header === undefined ? 'Header' : actualShape.header.annotation.content,\n                            style: actualShape.header === undefined ? {} : actualShape.header.annotation.style\n                        },\n                        height: 50,\n                        style: actualShape.header ? actualShape.header.style : actualShape.lanes[0].header.style\n                    },\n                    phases: [{\n                            id: (0,_index__WEBPACK_IMPORTED_MODULE_23__.randomId)(),\n                            //864555-Issue in updating swimlane phase properties dynamically\n                            header: {\n                                annotation: {\n                                    content: actualShape.phases === undefined ? 'Phase' : actualShape.phases[0].header === undefined\n                                        ? 'Phase' : actualShape.phases[0].header.annotation.content,\n                                    style: actualShape.phases === undefined ? {} : actualShape.phases[0].header === undefined\n                                        ? {} : actualShape.phases[0].header.annotation.style\n                                },\n                                style: actualShape.phases === undefined ? {} : actualShape.phases[0].header === undefined\n                                    ? {} : actualShape.phases[0].header.style\n                            },\n                            style: actualShape.phases === undefined ? {} : actualShape.phases[0].style\n                        }],\n                    lanes: [{\n                            id: (0,_index__WEBPACK_IMPORTED_MODULE_23__.randomId)(), height: selectedNode.height, width: selectedNode.width, style: actualShape.lanes[0].style,\n                            //Bug 912452: Disable canMove for lane symbol won't work when its tried to swap after its addition to swimlane\n                            //Added canMove property to lane symbol which is dropped from symbol palette.\n                            canMove: actualShape.lanes[0].canMove,\n                            header: {\n                                annotation: {\n                                    content: actualShape.lanes[0].header.annotation.content,\n                                    style: actualShape.lanes[0].header.annotation.style\n                                },\n                                style: actualShape.lanes[0].header.style\n                            }\n                        }], orientation: actualShape.orientation\n                }\n            };\n            if (actualShape.orientation === 'Vertical') {\n                swimLaneobj.width += 20;\n            }\n            swimLaneobj.offsetX = this.currentPosition.x + (swimLaneobj.width / 2);\n            swimLaneobj.offsetY = this.currentPosition.y + (swimLaneobj.height / 2);\n            //Bug 853721: Grid lines remain hidden when lane fill is set to transparent.\n            // Added below code to set swimlane style for dropped swimlane.\n            swimLaneobj.style = selectedNode.style;\n            this.diagram.add(swimLaneobj);\n        }\n    };\n    /** @private */\n    DiagramEventHandler.prototype.mouseLeave = function (evt) {\n        //Define what has to happen on mouse leave\n        if (this.tool && this.inAction) {\n            this.tool.mouseLeave(this.eventArgs);\n        }\n        if (this.diagram.selectedObject.helperObject) {\n            this.updateContainerProperties();\n            var isGroupAction = this.updateContainerBounds();\n            if (isGroupAction) {\n                this.diagram.endGroupAction();\n            }\n        }\n        if (this.eventArgs && this.eventArgs.source) {\n            this.diagram.updatePortVisibility(this.eventArgs.source, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover, true);\n            this.hoverElement = null;\n        }\n        if (this.eventArgs && !this.eventArgs.source && this.hoverElement) {\n            this.hoverElement = null;\n        }\n        if (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectTool && this.eventArgs && this.eventArgs.target && this.eventArgs.target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node) {\n            this.diagram.updatePortVisibility(this.eventArgs.target, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Hover | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortVisibility.Connect, true);\n            this.hoverElement = null;\n        }\n        var selector = this.diagram.selectedItems;\n        if (selector && selector.wrapper) {\n            if (!((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.selectionHasConnector)(this.diagram, selector))) {\n                this.diagram.renderSelector(true);\n            }\n        }\n        if (this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.Interactions || this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.ToolAction) {\n            this.diagram.diagramActions = this.diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.ToolAction;\n        }\n        this.isMouseDown = false;\n        this.focus = false;\n        this.touchStartList = null;\n        this.touchMoveList = null;\n        this.elementLeave();\n        this.commandHandler.removeSnap();\n        this.inAction = false;\n        this.eventArgs = {};\n        if (this.diagram.selectedObject && this.diagram.selectedObject.helperObject) {\n            this.diagram.remove(this.diagram.selectedObject.helperObject);\n            this.diagram.selectedObject = { helperObject: undefined, actualObject: undefined };\n        }\n        this.tool = null;\n        (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_18__.removeRulerMarkers)();\n        if (this.action === 'Rotate') {\n            this.diagram.diagramCanvas.classList.remove('e-diagram-rotate');\n        }\n        evt.preventDefault();\n    };\n    /** @private */\n    DiagramEventHandler.prototype.mouseWheel = function (evt) {\n        this.diagram.blazorActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.BlazorAction.interaction;\n        // EJ2-64831 - Need to provide support to override the mousewheel event\n        var arg = {\n            event: evt,\n            cancel: false\n        };\n        this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.mouseWheel, arg);\n        if (!arg.cancel) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var up = (evt.wheelDelta > 0 || -40 * evt.detail > 0) ? true : false;\n            var mousePosition = this.getMousePosition(evt);\n            this.diagram.tooltipObject.close();\n            var ctrlKey = this.isMetaKey(evt);\n            if (ctrlKey) {\n                // SF-362356 - Command below line to implement smooth scroll in diagram.\n                // this.diagram.zoom(up ? (1.2) : 1 / (1.2), mousePosition);\n                // EJ2-59803 - Added the below code to get the zoom factor value from scroll settings and\n                // set it to zoomFactor args in zoomTo method.\n                var zoomFactor = this.diagram.scrollSettings.zoomFactor;\n                if (up) {\n                    this.diagram.zoomTo({ type: 'ZoomIn', zoomFactor: zoomFactor, focusPoint: mousePosition });\n                }\n                else {\n                    this.diagram.zoomTo({ type: 'ZoomOut', zoomFactor: zoomFactor, focusPoint: mousePosition });\n                }\n                evt.preventDefault();\n            }\n            else {\n                var horizontalOffset = this.diagram.scroller.horizontalOffset;\n                var verticalOffset = this.diagram.scroller.verticalOffset;\n                var change = up ? 10 : -10;\n                if (this.tool && (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool)) {\n                    this.eventArgs = {};\n                    this.getMouseEventArgs(mousePosition, this.eventArgs);\n                    this.eventArgs.position = mousePosition;\n                    this.tool.mouseWheel(this.eventArgs);\n                }\n                this.diagram.scrollActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ScrollActions.Interaction;\n                var canMouseWheel = true;\n                if (evt.isTrusted) {\n                    // Bug 829925: Scroll bar flickers on scrolling the diagram using touchpad.\n                    // Added the below condition to check whether the mouse wheel is from trackpad or not.\n                    var isTrackpadScroll = false;\n                    // 878719: Resolve ESLint errors\n                    // eslint-disable-next-line no-compare-neg-zero\n                    if ((Math.abs(evt.deltaY) < 100 && Math.abs(evt.deltaX) === -0) ||\n                        // 878719: Resolve ESLint errors\n                        // eslint-disable-next-line no-compare-neg-zero\n                        (Math.abs(evt.deltaX) < 100 && Math.abs(evt.deltaY) === -0)) {\n                        isTrackpadScroll = true;\n                    }\n                    //Bug 892441: Infinite scroll not working in vertical axis of diagram.\n                    //Due to the prevention of zoom method trigger in vertical scroll, the infinite scroll is not working in vertical axis.\n                    //So added the below condition to check macOS and allowed the zoom method trigger in vertical scroll for non-MacOs.\n                    var isMacOS = false;\n                    if (evt.deltaX !== 0 || evt.deltaY !== 0) {\n                        // Perform macOS detection\n                        isMacOS = navigator.userAgent.includes('Macintosh');\n                    }\n                    //898867: Diagram scrolling is not smooth while scrolling with Track Pad in Mac.\n                    if (isMacOS) {\n                        var isHorizontalScroll = Math.abs(evt.deltaX) > Math.abs(evt.deltaY);\n                        if (isHorizontalScroll) {\n                            // eslint-disable-next-line no-compare-neg-zero\n                            if (evt.shiftKey || (evt.deltaX && evt.deltaX !== -0 && (isTrackpadScroll || !isMacOS))) {\n                                this.diagram.scroller.zoom(1, change, 0, mousePosition, canMouseWheel, undefined, isTrackpadScroll);\n                            }\n                        }\n                        else {\n                            // eslint-disable-next-line no-compare-neg-zero\n                            if ((evt.deltaY && evt.deltaY !== -0 && (isTrackpadScroll || !isMacOS))) {\n                                this.diagram.scroller.zoom(1, 0, change, mousePosition, canMouseWheel, undefined, isTrackpadScroll);\n                            }\n                        }\n                    }\n                    //Bug 837940: In mac, scrollbar flickers on horizontal and vertical scroll using trackpad.\n                    else {\n                        // 878719: Resolve ESLint errors\n                        // eslint-disable-next-line no-compare-neg-zero\n                        if (evt.shiftKey || (evt.deltaX && evt.deltaX !== -0 && (isTrackpadScroll || !isMacOS))) {\n                            this.diagram.scroller.zoom(1, change, 0, mousePosition, canMouseWheel, undefined, isTrackpadScroll);\n                        }\n                        // eslint-disable-next-line no-compare-neg-zero\n                        else if ((evt.deltaY && evt.deltaY !== -0 && (isTrackpadScroll || !isMacOS))) {\n                            this.diagram.scroller.zoom(1, 0, change, mousePosition, canMouseWheel, undefined, isTrackpadScroll);\n                        }\n                    }\n                }\n                else {\n                    // 878719: Resolve ESLint errors\n                    // eslint-disable-next-line no-compare-neg-zero\n                    if (evt.shiftKey || (evt.deltaX && evt.deltaX !== -0)) {\n                        this.diagram.scroller.zoom(1, change, 0, mousePosition, canMouseWheel);\n                    }\n                    else {\n                        this.diagram.scroller.zoom(1, 0, change, mousePosition, canMouseWheel);\n                    }\n                }\n                this.diagram.scrollActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.ScrollActions.Interaction;\n                if (horizontalOffset !== this.diagram.scroller.horizontalOffset\n                    || verticalOffset !== this.diagram.scroller.verticalOffset) {\n                    evt.preventDefault();\n                }\n            }\n            if (this.diagram.textEditing) {\n                this.diagram.isTriggerEvent = true;\n                if (this.diagram.activeLabel.parentId) {\n                    var node = this.diagram.getObject(this.diagram.activeLabel.parentId);\n                    this.diagram.startTextEdit(node, this.diagram.activeLabel.id);\n                }\n                this.diagram.isTriggerEvent = false;\n            }\n            this.diagram.blazorActions = this.diagram.blazorActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.BlazorAction.interaction;\n        }\n    };\n    /** @private */\n    DiagramEventHandler.prototype.keyDown = function (evt) {\n        if (evt.fromMouseEvents) {\n            if (evt.ctrlKey) {\n                this.keyArgs.keyModifiers = 1;\n            }\n            if (evt.shiftKey) {\n                this.keyArgs.keyModifiers = 4;\n            }\n            if (evt.shiftKey && evt.ctrlKey) {\n                this.keyArgs.keyModifiers = 5;\n            }\n        }\n        if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.TextEdit) &&\n            !(this.checkEditBoxAsTarget(evt)) || (evt.key === 'Escape' || evt.keyCode === 27)) {\n            var i = void 0;\n            var inAction = 'inAction';\n            var command = void 0;\n            var keycode = evt.keyCode ? evt.keyCode : evt.which;\n            var key = evt.key;\n            if (key === 'ArrowDown' || key === 'ArrowUp' || key === 'ArrowLeft' || key === 'ArrowRight') {\n                this.isNudgeKey = true;\n            }\n            var ctrlKey = this.isMetaKey(evt);\n            if (this.diagram.commandManager && this.diagram.commands) {\n                var commands = this.diagram.commands;\n                for (var _i = 0, _a = Object.keys(commands); _i < _a.length; _i++) {\n                    var i_1 = _a[_i];\n                    command = this.diagram.commands[\"\" + i_1];\n                    if (command && (command.gesture.keyModifiers || command.gesture.key)) {\n                        //Added the split method to split the Number string from the enum while clicking the number keys\n                        if ((keycode === command.gesture.key || (_enum_enum__WEBPACK_IMPORTED_MODULE_8__.Keys[command.gesture.key] && key === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.Keys[command.gesture.key] || key === _enum_enum__WEBPACK_IMPORTED_MODULE_8__.Keys[command.gesture.key].split('Number')[1])\n                            || this.isDeleteKey(key, i_1))\n                            && (((!command.gesture.keyModifiers) && (!evt.altKey) && (!evt.shiftKey) && (!ctrlKey)) ||\n                                (command.gesture.keyModifiers && (ctrlKey || evt.altKey || evt.shiftKey) &&\n                                    (this.altKeyPressed(command.gesture.keyModifiers) && evt.altKey) ||\n                                    (this.shiftKeyPressed(command.gesture.keyModifiers) && evt.shiftKey) ||\n                                    //added the comparision condition of keyargs to execute the condition onclicking the Ctrl + Shift key\n                                    (this.ctrlKeyPressed(command.gesture.keyModifiers) && ctrlKey)\n                                        && (this.keyArgs.keyModifiers === command.gesture.keyModifiers)))) {\n                            var canExecute = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.getFunction)(command.canExecute);\n                            if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)() || (canExecute &&\n                                canExecute({\n                                    'keyDownEventArgs': KeyboardEvent,\n                                    parameter: command.parameter\n                                }))) {\n                                evt.preventDefault();\n                                if (evt.key === 'Escape') {\n                                    if (this.checkEditBoxAsTarget(evt)) {\n                                        document.getElementById(this.diagram.diagramCanvas.id).focus();\n                                    }\n                                    else if (this.diagram.currentSymbol) {\n                                        var selectedSymbols = 'selectedSymbols';\n                                        var source = 'sourceElement';\n                                        var intDestroy = 'intDestroy';\n                                        this.diagram.removeFromAQuad(this.diagram.currentSymbol);\n                                        this.diagram.removeObjectsFromLayer(this.diagram.nameTable[this.diagram.currentSymbol.id]);\n                                        this.diagram.removeElements(this.diagram.currentSymbol);\n                                        var currentObj = this.diagram.currentSymbol;\n                                        if (((currentObj) instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node\n                                            && (currentObj.shape.type === 'Bpmn')\n                                            && currentObj.shape.shape === 'TextAnnotation')) {\n                                            this.diagram.removeDependentConnector(currentObj);\n                                        }\n                                        (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.removeChildNodes)(this.diagram.currentSymbol, this.diagram);\n                                        delete this.diagram.nameTable[this.diagram.currentSymbol.id];\n                                        var sourceElement = this.diagram.droppable[\"\" + source];\n                                        sourceElement.draggable[\"\" + intDestroy]();\n                                        var element_1 = this.diagram.droppable[\"\" + selectedSymbols];\n                                        element_1.parentNode.removeChild(element_1);\n                                        var diagramActions = this.diagram.diagramActions;\n                                        this.diagram.diagramActions =\n                                            this.diagram.addConstraints(diagramActions, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.PreventClearSelection);\n                                        this.tool.mouseUp(this.eventArgs);\n                                        this.diagram.diagramRenderer.rendererActions = this.diagram.removeConstraints(this.diagram.diagramRenderer.rendererActions, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.RendererAction.DrawSelectorBorder);\n                                        if (this.diagram.previousSelectedObject) {\n                                            this.diagram.select(this.diagram.previousSelectedObject);\n                                        }\n                                        this.action = 'Select';\n                                        this.diagram.previousSelectedObject = null;\n                                        this.diagram.currentSymbol = null;\n                                        this.diagram.diagramActions =\n                                            this.diagram.removeConstraints(diagramActions, _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.PreventClearSelection);\n                                        this.isMouseDown = false;\n                                    }\n                                    else if (this.inAction && this.diagram.drawingObject && this.tool && this.tool[\"\" + inAction]) {\n                                        this.tool.mouseUp(this.eventArgs);\n                                        this.tool = null;\n                                        this.isMouseDown = false;\n                                    }\n                                }\n                                if (command.execute) {\n                                    this.commandObj = command;\n                                    if (this.diagram.tool !== _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramTools.ZoomPan) {\n                                        // if (i === 'nudgeUp' || i === 'nudgeRight' || i === 'nudgeDown' || i === 'nudgeLeft') {\n                                        //     command.execute()\n                                        // } else {\n                                        var execute = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.getFunction)(command.execute);\n                                        // Bug 832880: Need to improve performance while nudging multiple nodes.\n                                        if (this.isNudgeKey) {\n                                            if (!this.isKeyUp) {\n                                                this.keyArgs.oldValue = { offsetX: this.diagram.selectedItems.offsetX,\n                                                    offsetY: this.diagram.selectedItems.offsetY };\n                                                this.keyCount++;\n                                                if (this.keyCount > 4) {\n                                                    // 914747: Position change event not triggered for Keyboard nudge commands\n                                                    execute({ 'keyDownEventArgs': KeyboardEvent, parameter: command.parameter, type: 'KEYDOWN' });\n                                                    this.keyCount = 0;\n                                                    this.keyArgs.newValue = { offsetX: this.diagram.selectedItems.offsetX,\n                                                        offsetY: this.diagram.selectedItems.offsetY };\n                                                    this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.positionChange, this.keyArgs);\n                                                }\n                                            }\n                                            this.isKeyUp = false;\n                                        }\n                                        else {\n                                            execute({ 'keyDownEventArgs': KeyboardEvent, parameter: command.parameter });\n                                        }\n                                    }\n                                    // }\n                                }\n                                //Removed isBlazor code\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // eslint-disable-next-line\n        var selectedObject = (this.diagram.selectedItems.nodes.length) ?\n            this.diagram.selectedItems.nodes : this.diagram.selectedItems.connectors;\n        var element = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.diagram.selectedItems);\n        this.keyArgs = {\n            element: element,\n            key: evt.key, keyCode: evt.keyCode ? evt.keyCode : evt.which\n        };\n        this.getKeyModifier(this.keyArgs, evt);\n        if ((this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.TextEdit)) {\n            this.getlabel(this.keyArgs, evt);\n        }\n        this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.keyDown, this.keyArgs);\n    };\n    DiagramEventHandler.prototype.getlabel = function (args, evt) {\n        var label = this.diagram.activeLabel;\n        args.target = this.diagram.element.id + '_editBox';\n        var node = this.diagram.nameTable[label.parentId];\n        if (document.getElementById(this.diagram.element.id + '_editBox')) {\n            args.text = document.getElementById(this.diagram.element.id + '_editBox').value;\n            for (var i = 0; i < node.annotations.length; i++) {\n                if (node.annotations[parseInt(i.toString(), 10)].id === label.id) {\n                    args.label = node.annotations[parseInt(i.toString(), 10)];\n                    break;\n                }\n            }\n        }\n    };\n    DiagramEventHandler.prototype.getKeyModifier = function (args, evt) {\n        args.keyModifiers = _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.None;\n        if (evt.ctrlKey) {\n            args.keyModifiers |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.Control;\n        }\n        if (evt.shiftKey) {\n            args.keyModifiers |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.Shift;\n        }\n        if (evt.altKey) {\n            args.keyModifiers |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.Alt;\n        }\n        if (this.isMetaKey(evt)) {\n            args.keyModifiers |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.Meta;\n        }\n    };\n    DiagramEventHandler.prototype.keyUp = function (evt) {\n        var element = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.diagram.selectedItems);\n        this.keyArgs = {\n            element: element, key: evt.key, keyCode: evt.keyCode ? evt.keyCode : evt.which,\n            oldValue: { offsetX: element.offsetX, offsetY: element.offsetY },\n            newValue: { offsetX: element.offsetX, offsetY: element.offsetY }\n        };\n        var selectedObject = (this.diagram.selectedItems.nodes.length) ?\n            this.diagram.selectedItems.nodes : this.diagram.selectedItems.connectors;\n        this.getKeyModifier(this.keyArgs, evt);\n        if ((this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.TextEdit)) {\n            this.getlabel(this.keyArgs, evt);\n        }\n        this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.keyUp, this.keyArgs);\n        // this.isKeyUp = true;\n        // Bug 832880: Need to improve performance while nudging multiple nodes.\n        if (!this.isKeyUp && this.isNudgeKey) {\n            //Bug 860080: Navigation not working in keyboard interaction SB sample.\n            //To execute the command manager execute method below as we restricted keydown for arrow keys.\n            var execute = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.getFunction)(this.commandObj.execute);\n            execute({ 'keyDownEventArgs': KeyboardEvent, parameter: this.commandObj.parameter, type: 'KEYUP' });\n            // 914747: Position change event not triggered for Keyboard nudge commands\n            this.keyArgs.newValue = { offsetX: this.diagram.selectedItems.offsetX, offsetY: this.diagram.selectedItems.offsetY };\n            this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.positionChange, this.keyArgs);\n            this.isNudgeKey = false;\n            this.keyCount = 0;\n        }\n    };\n    DiagramEventHandler.prototype.startAutoScroll = function (e) {\n        var position = this.getMousePosition(e);\n        position.x *= this.diagram.scroller.currentZoom;\n        position.y *= this.diagram.scroller.currentZoom;\n        var rulerSize = (0,_ruler_ruler__WEBPACK_IMPORTED_MODULE_18__.getRulerSize)(this.diagram);\n        var movingPosition;\n        var autoScrollBorder = this.diagram.scrollSettings.autoScrollBorder;\n        if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.info.name === 'mozilla') {\n            if (this.diagram.scroller.viewPortWidth === 0) {\n                var bounds = document.getElementById(this.diagram.element.id).getBoundingClientRect();\n                if (bounds.width !== this.diagram.scroller.viewPortWidth) {\n                    this.diagram.scroller.setViewPortSize(bounds.width, bounds.height);\n                }\n            }\n        }\n        if (this.diagram.scrollSettings.canAutoScroll) {\n            if (position.x + this.diagram.scroller.horizontalOffset + autoScrollBorder.right + rulerSize.width >=\n                this.diagram.scroller.viewPortWidth - 18) {\n                movingPosition = 'right';\n            }\n            else if (position.x + this.diagram.scroller.horizontalOffset < autoScrollBorder.left) {\n                movingPosition = 'left';\n            }\n            else if (position.y + this.diagram.scroller.verticalOffset + autoScrollBorder.bottom + rulerSize.height >\n                this.diagram.scroller.viewPortHeight - 18) {\n                movingPosition = 'bottom';\n            }\n            else if (position.y + this.diagram.scroller.verticalOffset < autoScrollBorder.top) {\n                movingPosition = 'top';\n            }\n        }\n        return movingPosition;\n    };\n    DiagramEventHandler.prototype.doAutoScroll = function (option, e, delay, autoScroll) {\n        var position = option;\n        var canAutoScroll = true;\n        if ((this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.NodeDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectorDrawingTool\n            || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ResizeTool\n            || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.SelectTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectTool) && this.inAction) {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            var diagram = this;\n            var pos = this.getMousePosition(e);\n            var autoScrollBorder = this.diagram.scrollSettings.autoScrollBorder;\n            var newDelay = delay ? delay : 100;\n            var left = 0;\n            var top_1 = 0;\n            var canUpdate = false;\n            var corner = '';\n            var point = { x: pos.x, y: pos.y };\n            // EJ2-61979 - Added below code to check whether we resize the node around four corners\n            if (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ResizeTool && (this.tool.corner === 'ResizeSouthEast' || this.tool.corner === 'ResizeSouthWest' ||\n                this.tool.corner === 'ResizeNorthWest' || this.tool.corner === 'ResizeNorthEast')) {\n                canUpdate = true;\n                corner = this.tool.corner;\n            }\n            switch (position) {\n                case 'right':\n                    point.x = pos.x + 10;\n                    left = 10;\n                    // EJ2-61979 - If node gets resized on southeast or northeast corner means then update the y position along with x position\n                    if (canUpdate) {\n                        if (corner === 'ResizeSouthEast') {\n                            point.y = pos.y + 10;\n                            top_1 = 10;\n                        }\n                        else {\n                            point.y = pos.y - 10;\n                            top_1 = -10;\n                        }\n                    }\n                    break;\n                case 'left':\n                    point.x = pos.x - 10;\n                    left = -10;\n                    // EJ2-61979 - If node gets resized on northwest or southwest corner means then update the y position along with x position\n                    if (canUpdate) {\n                        if (corner === 'ResizeNorthWest') {\n                            point.y = pos.y - 10;\n                            top_1 = -10;\n                        }\n                        else {\n                            point.y = pos.y + 10;\n                            top_1 = 10;\n                        }\n                    }\n                    break;\n                case 'bottom':\n                    point.y = pos.y + 10;\n                    top_1 = 10;\n                    // EJ2-61979 - If node gets resized on southeast or southwest corner means then update the x position along with y position\n                    if (canUpdate) {\n                        if (corner === 'ResizeSouthEast') {\n                            point.x = pos.x + 10;\n                            left = 10;\n                        }\n                        else {\n                            point.x = pos.x - 10;\n                            left = -10;\n                        }\n                    }\n                    break;\n                case 'top':\n                    point.y = pos.y - 10;\n                    top_1 = -10;\n                    // EJ2-61979 - If node gets resized on northeast or northwest corner means then update the x position along with y position\n                    if (canUpdate) {\n                        if (corner === 'ResizeNorthEast') {\n                            point.x = pos.x + 10;\n                            left = 10;\n                        }\n                        else {\n                            point.x = pos.x - 10;\n                            left = -10;\n                        }\n                    }\n                    break;\n            }\n            this.eventArgs.position = { x: point.x, y: point.y };\n            this.currentPosition = this.eventArgs.position;\n            var objects = this.objectFinder.findObjectsUnderMouse(this.currentPosition, this.diagram, this.eventArgs, null, this.action);\n            this.eventArgs.target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n            this.tool.mouseMove(this.eventArgs);\n            this.diagram.scrollActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ScrollActions.Interaction;\n            this.diagram.scroller.zoom(1, -left, -top_1, pos, canAutoScroll);\n            this.diagram.scrollActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.ScrollActions.Interaction;\n        }\n    };\n    DiagramEventHandler.prototype.mouseEvents = function () {\n        var target = this.diagram.findObjectsUnderMouse(this.currentPosition);\n        for (var i = 0; i < target.length; i++) {\n            if (this.eventArgs.actualObject === target[parseInt(i.toString(), 10)]) {\n                target.splice(i, 1);\n            }\n        }\n        var arg = {\n            targets: {}\n        };\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isBlazor)()) {\n            arg = {\n                targets: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(target),\n                element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)((this.eventArgs.source === this.eventArgs.actualObject) ? undefined : this.eventArgs.source),\n                actualObject: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.eventArgs.actualObject)\n            };\n        }\n        //Removed isBlazor code\n        if (this.lastObjectUnderMouse && this.diagram.mouseLeave\n            && (!this.eventArgs.actualObject || (this.lastObjectUnderMouse !== this.eventArgs.actualObject))) {\n            var arg_1 = {\n                targets: undefined, element: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.lastObjectUnderMouse), actualObject: undefined\n            };\n            //Removed isBlazor code\n            this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.mouseLeave, arg_1);\n            this.lastObjectUnderMouse = null;\n        }\n        if (!this.lastObjectUnderMouse && this.eventArgs.source || (this.lastObjectUnderMouse !== this.eventArgs.actualObject)) {\n            this.lastObjectUnderMouse = this.eventArgs.actualObject;\n            if (this.eventArgs.actualObject !== undefined) {\n                this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.mouseEnter, arg);\n            }\n        }\n        if (this.eventArgs.actualObject) {\n            this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.mouseOver, arg);\n        }\n    };\n    DiagramEventHandler.prototype.elementEnter = function (mousePosition, elementOver) {\n        if (!elementOver) {\n            var isPrivateTooltip = ((this.hoverElement instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node)\n                && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.Tooltip)\n                || ((this.hoverElement instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector)\n                    && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.Tooltip)\n                || ((this.hoverElement instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PointPort || this.hoverElement instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PathPort)\n                    && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.PortConstraints.ToolTip)\n                || ((this.hoverElement instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.ShapeAnnotation || this.hoverElement instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation)\n                    && this.hoverElement.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.AnnotationConstraints.Tooltip);\n            var content = this.getContent();\n            var children = void 0;\n            if (this.hoverElement && this.hoverElement.children && this.hoverElement.children.length > 0) {\n                // EJ2-56981 - Below method is used to check if the mouse pointer position and group children node gets intersect or not\n                children = this.findIntersectChild(this.hoverElement);\n            }\n            if (this.hoverElement.tooltip.openOn === 'Auto' && content !== '') {\n                // EJ2-56981 - If children returned means then update tooltip for child node else update tooltip for group node.\n                if (children) {\n                    (0,_objects_tooltip__WEBPACK_IMPORTED_MODULE_11__.updateTooltip)(this.diagram, children);\n                }\n                else {\n                    (0,_objects_tooltip__WEBPACK_IMPORTED_MODULE_11__.updateTooltip)(this.diagram, isPrivateTooltip ? this.hoverElement : undefined);\n                }\n            }\n            // EJ2-66418 - set tooltip relativeMode as mouse\n            // Calculating offset position for relativeMode Mouse\n            if (this.hoverElement.tooltip.content) {\n                if (this.hoverElement.tooltip.relativeMode === 'Mouse') {\n                    this.setTooltipOffset(mousePosition);\n                }\n                else {\n                    this.diagram.tooltipObject.offsetX = 0;\n                    this.diagram.tooltipObject.offsetY = 0;\n                }\n            }\n            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n            //848980 - Null exception occurs while hovering the ports\n            if (obj !== null) {\n                var targetEle = void 0;\n                //840454 - support to provide isSticky property for tooltip in diagram control\n                if (this.hoverElement.tooltip.isSticky) {\n                    this.diagram.tooltipObject.isSticky = true;\n                }\n                if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node && obj.children && obj.children.length > 0) {\n                    // EJ2-56981 - If children returned means then update tooltip for child node else update tooltip for group node.\n                    obj = children ? children : obj;\n                }\n                //EJ2-62120 - check if the Node has Ports and hoverElement is Port as mousepointer hovered over Port\n                if (obj.ports && (this.hoverElement instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PointPort || this.hoverElement instanceof _objects_port__WEBPACK_IMPORTED_MODULE_24__.PathPort)) {\n                    //executed to set target as port\n                    targetEle = document.getElementById(obj.id + '_' + this.hoverElement.id);\n                }\n                else if (obj.annotations\n                    && (this.hoverElement instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.ShapeAnnotation || this.hoverElement instanceof _objects_annotation__WEBPACK_IMPORTED_MODULE_19__.PathAnnotation)) {\n                    //executed to set target as annotation\n                    targetEle = document.getElementById(obj.id + '_' + this.hoverElement.id);\n                }\n                else {\n                    //executed to set target as Node or Connector\n                    var idName = (obj.shape && ((obj.shape) instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Native)) ? '_content_native_element' : '_groupElement';\n                    targetEle = document.getElementById(obj.id + idName);\n                }\n                if (this.hoverElement.tooltip.openOn === 'Auto' && content !== '') {\n                    this.diagram.tooltipObject.close();\n                    this.diagram.tooltipObject.openOn = this.hoverElement.tooltip.openOn;\n                    //Removed isBlazor code\n                    this.diagram.tooltipObject.dataBind();\n                }\n                if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canEnableToolTip)(this.hoverElement, this.diagram) && this.hoverElement.tooltip.openOn === 'Auto') {\n                    this.diagram.tooltipObject.target = this.hoverElement.id;\n                    if (this.hoverElement.tooltip.relativeMode === 'Mouse') {\n                        this.diagram.tooltipObject.open(this.diagram.element);\n                    }\n                    else {\n                        this.diagram.tooltipObject.open(targetEle);\n                    }\n                }\n            }\n        }\n    };\n    DiagramEventHandler.prototype.elementLeave = function () {\n        if (this.diagram.tooltipObject && !this.diagram.tooltipObject.isSticky && this.diagram.tooltipObject.openOn !== 'Custom') {\n            this.diagram.tooltipObject.close();\n        }\n    };\n    // EJ2-66418 - set tooltip relativeMode as mouse\n    // Calculating offset position for relativeMode Mouse\n    DiagramEventHandler.prototype.setTooltipOffset = function (mousePosition) {\n        var point = this.updatePointBasedOnScale(mousePosition);\n        var offset = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.getTooltipOffset)(this.diagram, point, this.hoverElement);\n        this.diagram.tooltipObject.offsetX = offset.x;\n        this.diagram.tooltipObject.offsetY = offset.y;\n    };\n    DiagramEventHandler.prototype.updatePointBasedOnScale = function (mousePosition) {\n        var scale = this.diagram.scaleValue;\n        var point = { x: mousePosition.x * scale, y: mousePosition.y * scale };\n        return point;\n    };\n    DiagramEventHandler.prototype.altKeyPressed = function (keyModifier) {\n        if (keyModifier & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.Alt) {\n            return true;\n        }\n        return false;\n    };\n    DiagramEventHandler.prototype.ctrlKeyPressed = function (keyModifier) {\n        if (keyModifier & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.Control) {\n            return true;\n        }\n        return false;\n    };\n    DiagramEventHandler.prototype.shiftKeyPressed = function (keyModifier) {\n        if (keyModifier & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.KeyModifiers.Shift) {\n            return true;\n        }\n        return false;\n    };\n    /** @private */\n    DiagramEventHandler.prototype.scrolled = function (evt) {\n        this.diagram.updateScrollOffset();\n        //Removed isBlazor code\n    };\n    DiagramEventHandler.prototype.isMobileOrIPadDevice = function () {\n        var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n        //Bug 931502: Unable to complete polyline drawing on ipad safari browser.\n        // Check for iPads on iOS 13+ (Safari reports as Mac desktop)\n        if (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) {\n            return 'iOS (iPad)';\n        }\n        // Check for iOS devices (iPhone, iPad, iPod)\n        if (/iPhone|iPad|iPod/.test(userAgent) && !window.MSStream) {\n            return 'iOS';\n        }\n        // Check for Android devices\n        if (/android/i.test(userAgent)) {\n            return 'Android';\n        }\n        // Check for other mobile devices (general fallback)\n        if (/Mobile|Tablet/.test(userAgent)) {\n            return 'Mobile';\n        }\n        return 'Desktop';\n    };\n    /** @private */\n    DiagramEventHandler.prototype.doubleClick = function (evt) {\n        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canUserInteract)(this.diagram)) {\n            //Bug 916653: Issue with drawing Polyline in iPad.\n            //Added below code to check for mobile and ipad device.\n            var isMobileOrIPad = this.isMobileOrIPadDevice();\n            var curTool = this.diagram.tool;\n            if ((isMobileOrIPad !== 'Desktop') && (this.tool && (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool))) {\n                this.diagram.tool = 0;\n            }\n            var annotation = void 0;\n            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n            if (obj !== null && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canUserInteract)(this.diagram)) {\n                var node = obj;\n                annotation = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);\n                if (this.tool && (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool || this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool)) {\n                    var arg_2 = {\n                        source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(obj),\n                        position: this.currentPosition, count: evt.detail\n                    };\n                    this.diagram.tool = curTool;\n                    this.tool.mouseUp(this.eventArgs);\n                    this.isMouseDown = false;\n                    this.eventArgs = {};\n                    this.tool = null;\n                    evt.preventDefault();\n                }\n                else {\n                    var layer = this.diagram.commandHandler.getObjectLayer(obj.id);\n                    if (layer && !layer.lock && layer.visible) {\n                        if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.TextEdit)) {\n                            var id = '';\n                            this.diagram.startTextEdit(obj, id || (annotation instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_13__.TextElement ?\n                                (annotation.id).split(obj.id + '_')[1] : undefined));\n                        }\n                    }\n                }\n            }\n            var arg = {\n                source: (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(obj) || (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.cloneBlazorObject)(this.diagram),\n                position: this.currentPosition, count: evt.detail\n            };\n            //Removed isBlazor code\n            this.diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramEvent.doubleClick, arg);\n        }\n    };\n    /**\n     * @private\n     */\n    DiagramEventHandler.prototype.itemClick = function (actualTarget, diagram) {\n        var obj = actualTarget;\n        if ((0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, obj, true)) {\n            return obj;\n        }\n        return null;\n    };\n    /**\n     * @private\n     */\n    DiagramEventHandler.prototype.inputChange = function (evt) {\n        var minWidth = 90;\n        var maxWidth;\n        var minHeight = 12;\n        var fontsize;\n        var textWrapper;\n        var node;\n        var height;\n        var width;\n        var textBounds;\n        var textBoxWidth;\n        var transforms;\n        var scale;\n        var editTextBox = document.getElementById(this.diagram.element.id + '_editBox');\n        var editTextBoxDiv = document.getElementById(this.diagram.element.id + '_editTextBoxDiv');\n        var text = (editTextBox.value);\n        var line = text.split('\\n');\n        node = (this.diagram.selectedItems.nodes[0]) ? this.diagram.selectedItems.nodes[0] : this.diagram.selectedItems.connectors[0];\n        if ((!node && this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.TextDrawingTool) || (node && node.shape.type === 'SwimLane')) {\n            node = this.diagram.nameTable[this.diagram.activeLabel.parentId];\n        }\n        if (node && ((node.shape.type !== 'Text' && node.annotations.length > 0) || (node.shape.type === 'Text'))) {\n            textWrapper = this.diagram.getWrapper(node.wrapper, this.diagram.activeLabel.id);\n            maxWidth = node.wrapper.bounds.width < textWrapper.bounds.width ? node.wrapper.bounds.width : textWrapper.bounds.width;\n            maxWidth = maxWidth > minWidth ? maxWidth : minWidth;\n            textBounds = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.measureHtmlText)(textWrapper.style, text, undefined, undefined, maxWidth);\n            fontsize = Number((editTextBox.style.fontSize).split('px')[0]);\n            if (line.length > 1 && line[line.length - 1] === '') {\n                textBounds.height = textBounds.height + fontsize;\n            }\n            transforms = this.diagram.scroller.transform;\n            scale = (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canZoomTextEdit)(this.diagram) ? transforms.scale : 1;\n            width = textBounds.width;\n            width = ((minWidth > width) ? minWidth : width) * scale;\n            height = ((minHeight > textBounds.height) ? minHeight : textBounds.height) * scale;\n            editTextBoxDiv.style.left = ((((textWrapper.bounds.center.x + transforms.tx) * transforms.scale) - width / 2) - 2.5) + 'px';\n            editTextBoxDiv.style.top = ((((textWrapper.bounds.center.y + transforms.ty) * transforms.scale) - height / 2) - 3) + 'px';\n            editTextBoxDiv.style.width = width + 'px';\n            editTextBoxDiv.style.height = height + 'px';\n            editTextBox.style.minHeight = minHeight + 'px';\n            editTextBox.style.minWidth = minWidth + 'px';\n            editTextBox.style.width = width + 'px';\n            editTextBox.style.height = height + 'px';\n        }\n    };\n    /**\n     * @private\n     */\n    DiagramEventHandler.prototype.isAddTextNode = function (node, focusOut) {\n        if (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.TextDrawingTool || focusOut) {\n            this.tool = null;\n            if (node && (!((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canContinuousDraw)(this.diagram)))) {\n                this.diagram.drawingObject = undefined;\n                this.diagram.currentDrawingObject = undefined;\n            }\n            if ((0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.getObjectFromCollection)(this.diagram.nodes, node.id) ||\n                (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.getObjectFromCollection)(this.diagram.connectors, node.id)) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    };\n    DiagramEventHandler.prototype.checkEditBoxAsTarget = function (evt) {\n        if ((evt.target && evt.target.id === this.diagram.element.id + '_editBox')) {\n            return true;\n        }\n        return false;\n    };\n    DiagramEventHandler.prototype.getMouseEventArgs = function (position, args, source, padding) {\n        args.position = position;\n        var obj;\n        var objects;\n        if (!source) {\n            if (this.action === 'Drag' || this.action === 'ConnectorSourceEnd' || this.action === 'SegmentEnd' ||\n                this.action === 'OrthoThumb' || this.action === 'BezierSourceThumb' || this.action === 'BezierTargetThumb' ||\n                this.action === 'ConnectorTargetEnd' || this.action.indexOf('Rotate') !== -1 || this.action.indexOf('Resize') !== -1) {\n                obj = this.diagram.selectedItems;\n                if (!this.diagram.currentSymbol && this.action === 'Drag' && obj && this.diagram.selectedItems.nodes.length > 0 &&\n                    this.diagram.selectedItems.nodes[0].shape.type === 'SwimLane') {\n                    objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n                    obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n                }\n            }\n            else {\n                objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n                obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n            }\n        }\n        else {\n            objects = this.diagram.findObjectsUnderMouse(this.currentPosition, source);\n            obj = this.diagram.findTargetObjectUnderMouse(objects, this.action, this.inAction, args.position, source);\n        }\n        if (obj && obj.isHeader) {\n            obj = this.diagram.nameTable[obj.parentId];\n            this.eventArgs.actualObject = obj;\n        }\n        var wrapper;\n        if (obj) {\n            wrapper = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram, padding);\n            var currentConnector = void 0;\n            var nearNode = void 0;\n            var i = void 0;\n            if ((wrapper && obj.ports && obj.ports.length\n                && !(0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.checkPort)(obj, wrapper) || !wrapper || !obj) && objects && objects.length\n                && (source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector)) {\n                currentConnector = source.connectors[0];\n                for (i = objects.length - 1; i >= 0; i--) {\n                    nearNode = objects[parseInt(i.toString(), 10)];\n                    if ((nearNode instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || nearNode instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && currentConnector\n                        && currentConnector.connectionPadding) {\n                        obj = nearNode;\n                        wrapper = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram, padding);\n                        if (((currentConnector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.ConnectToNearByPort) && obj &&\n                            obj.ports && obj.ports.length && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.checkPort)(obj, wrapper))) {\n                            break;\n                        }\n                        if ((nearNode instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || nearNode instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && currentConnector\n                            && currentConnector.connectionPadding && nearNode.wrapper.outerBounds.containsPoint(this.currentPosition)\n                            && (currentConnector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.ConnectToNearByNode)\n                            && !(currentConnector.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.ConnectToNearByPort)) {\n                            obj = nearNode;\n                            wrapper = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram, 0);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (!source) {\n            args.source = obj;\n            args.sourceWrapper = wrapper;\n        }\n        else {\n            args.target = obj;\n            args.targetWrapper = wrapper;\n        }\n        args.actualObject = this.eventArgs.actualObject;\n        if (args.source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector && args.actualObject === undefined &&\n            (args.source.nodes.length > 0 || args.source.connectors.length > 0)) {\n            args.actualObject = args.source.nodes.length > 0 ? this.diagram.nameTable[args.source.nodes[0].id]\n                : this.diagram.nameTable[args.source.connectors[0].id];\n        }\n        args.startTouches = this.touchStartList;\n        args.moveTouches = this.touchMoveList;\n        return args;\n    };\n    /** @private */\n    DiagramEventHandler.prototype.resetTool = function () {\n        this.action = 'Select';\n        this.hoverElement = null;\n        this.hoverNode = null;\n        this.tool = this.diagram.getTool(this.action);\n        this.updateCursor();\n    };\n    /** @private */\n    DiagramEventHandler.prototype.updateTool = function () {\n        // 912436: Update Tool at runtime\n        if (!this.currentPosition) {\n            this.action = 'Select';\n        }\n        else {\n            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n            var obj = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n            var sourceElement = null;\n            var target = void 0;\n            if (obj !== null) {\n                sourceElement = this.diagram.findElementUnderMouse(obj, this.currentPosition, this.diagram);\n            }\n            if (sourceElement) {\n                target = this.commandHandler.findTarget(sourceElement, obj);\n            }\n            this.action = this.diagram.findActionToBeDone(obj, sourceElement, this.currentPosition, target);\n        }\n    };\n    /** @private */\n    DiagramEventHandler.prototype.getTool = function (action) {\n        switch (action) {\n            case 'Select':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.SelectTool(this.commandHandler, true);\n            case 'Drag':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool(this.commandHandler);\n            case 'Rotate':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.RotateTool(this.commandHandler);\n            case 'LayoutAnimation':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.ExpandTool(this.commandHandler);\n            case 'FixedUserHandle':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.FixedUserHandleTool(this.commandHandler, true);\n            case 'Hyperlink':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.LabelTool(this.commandHandler);\n            case 'ResizeSouthEast':\n            case 'ResizeSouthWest':\n            case 'ResizeNorthEast':\n            case 'ResizeNorthWest':\n            case 'ResizeSouth':\n            case 'ResizeNorth':\n            case 'ResizeWest':\n            case 'ResizeEast':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.ResizeTool(this.commandHandler, action);\n            case 'ConnectorSourceEnd':\n            case 'ConnectorTargetEnd':\n            case 'BezierSourceThumb':\n            case 'BezierTargetThumb':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectTool(this.commandHandler, action);\n            case 'SegmentEnd':\n            case 'OrthoThumb':\n                return new _connector_editing__WEBPACK_IMPORTED_MODULE_6__.ConnectorEditing(this.commandHandler, action);\n            case 'Draw':\n                var shape = 'shape';\n                var basicShape = 'basicShape';\n                var type = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.findObjectType)(this.diagram.drawingObject);\n                if (type === 'Node' && this.diagram.drawingObject.shape.type === 'Text') {\n                    return new _tool__WEBPACK_IMPORTED_MODULE_4__.TextDrawingTool(this.commandHandler);\n                }\n                else if (type === 'Connector' && this.diagram.drawingObject.type === 'Freehand') {\n                    return new _tool__WEBPACK_IMPORTED_MODULE_4__.FreeHandTool(this.commandHandler);\n                }\n                else if (type === 'Node' && (this.diagram.drawingObject.shape[\"\" + shape] === 'Polygon') &&\n                    !(this.diagram.drawingObject.shape.points)) {\n                    return new _tool__WEBPACK_IMPORTED_MODULE_4__.PolygonDrawingTool(this.commandHandler);\n                }\n                else if (type === 'Node' ||\n                    (type === 'Node' && this.diagram.drawingObject.shape[\"\" + shape] === 'Polygon' &&\n                        (this.diagram.drawingObject.shape.points))) {\n                    return new _tool__WEBPACK_IMPORTED_MODULE_4__.NodeDrawingTool(this.commandHandler, this.diagram.drawingObject);\n                }\n                else if (type === 'Connector' && this.diagram.drawingObject.type === 'Polyline') {\n                    return new _tool__WEBPACK_IMPORTED_MODULE_4__.PolyLineDrawingTool(this.commandHandler);\n                }\n                else if (type === 'Connector') {\n                    return new _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectorDrawingTool(this.commandHandler, 'ConnectorSourceEnd', this.diagram.drawingObject);\n                }\n                break;\n            case 'Pan':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.ZoomPanTool(this.commandHandler, false);\n            case 'PinchZoom':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.ZoomPanTool(this.commandHandler, true);\n            case 'PortDrag':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool(this.commandHandler, 'Port');\n            case 'PortDraw':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectorDrawingTool(this.commandHandler, 'ConnectorSourceEnd', this.diagram.drawingObject);\n            case 'LabelSelect':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.SelectTool(this.commandHandler, true, 'LabelSelect');\n            case 'LabelDrag':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.LabelDragTool(this.commandHandler);\n            case 'LabelResizeSouthEast':\n            case 'LabelResizeSouthWest':\n            case 'LabelResizeNorthEast':\n            case 'LabelResizeNorthWest':\n            case 'LabelResizeSouth':\n            case 'LabelResizeNorth':\n            case 'LabelResizeWest':\n            case 'LabelResizeEast':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.LabelResizeTool(this.commandHandler, action);\n            case 'LabelRotate':\n                return new _tool__WEBPACK_IMPORTED_MODULE_4__.LabelRotateTool(this.commandHandler);\n            //for coverage\n            // case 'Custom':\n            //     return this.diagram.getTool(action);\n        }\n        return null;\n    };\n    /** @private */\n    DiagramEventHandler.prototype.getCursor = function (action) {\n        var object = (this.diagram.selectedItems.annotation) ?\n            this.diagram.selectedItems.wrapper.children[0] : this.diagram.selectedItems;\n        var rotateAngle = (this.diagram.selectedItems.annotation) ?\n            (object.rotateAngle + object.parentTransform) : object.rotateAngle;\n        return (0,_actions__WEBPACK_IMPORTED_MODULE_7__.getCursor)(action, rotateAngle);\n    };\n    //start region - interface betweend diagram and interaction\n    /** @private */\n    DiagramEventHandler.prototype.findElementUnderMouse = function (obj, position, diagram, padding) {\n        return this.objectFinder.findElementUnderSelectedItem(obj, position, diagram, padding);\n    };\n    /** @private */\n    DiagramEventHandler.prototype.findObjectsUnderMouse = function (position, source) {\n        return this.objectFinder.findObjectsUnderMouse(position, this.diagram, this.eventArgs, source);\n    };\n    /** @private */\n    DiagramEventHandler.prototype.findObjectUnderMouse = function (objects, action, inAction) {\n        return this.objectFinder.findObjectUnderMouse(this.diagram, objects, action, inAction, this.eventArgs, this.currentPosition);\n    };\n    /** @private */\n    DiagramEventHandler.prototype.findTargetUnderMouse = function (objects, action, inAction, position, source) {\n        return this.objectFinder.findObjectUnderMouse(this.diagram, objects, action, inAction, this.eventArgs, position, source);\n    };\n    /** @private */\n    DiagramEventHandler.prototype.findActionToBeDone = function (obj, wrapper, position, target) {\n        return (0,_actions__WEBPACK_IMPORTED_MODULE_7__.findToolToActivate)(obj, wrapper, this.currentPosition, this.diagram, this.touchStartList, this.touchMoveList, target);\n    };\n    DiagramEventHandler.prototype.updateContainerBounds = function (isAfterMouseUp) {\n        var isGroupAction = false;\n        if (this.diagram.selectedObject.helperObject && this.diagram.selectedObject.actualObject) {\n            var obj = this.diagram.selectedObject.actualObject;\n            var nodes = this.diagram.selectedObject.actualObject instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector ? obj.nodes : [obj];\n            for (var i = 0; i < nodes.length; i++) {\n                var node = nodes[parseInt(i.toString(), 10)];\n                var boundsUpdate = (this.tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ResizeTool) ? true : false;\n                var parentNode = this.diagram.nameTable[node.parentId];\n                if (isAfterMouseUp) {\n                    (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.removeChildInContainer)(this.diagram, node, this.currentPosition, boundsUpdate);\n                }\n                else {\n                    if (!parentNode || (parentNode && parentNode.shape.type !== 'SwimLane')) {\n                        this.diagram.updateDiagramObject(node);\n                    }\n                    isGroupAction = (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.updateCanvasBounds)(this.diagram, node, this.currentPosition, boundsUpdate);\n                    this.diagram.updateSelector();\n                    if (node.isLane || node.isPhase) {\n                        this.diagram.clearSelection();\n                        this.commandHandler.selectObjects([node]);\n                    }\n                }\n            }\n        }\n        return isGroupAction;\n    };\n    // tslint:disable-next-line:max-func-body-length\n    DiagramEventHandler.prototype.updateContainerProperties = function () {\n        var helperObject;\n        var isChangeProperties = false;\n        var hasStack;\n        var connectors;\n        var hasGroup = false;\n        var obj;\n        var history = { hasStack: false, isPreventHistory: false };\n        if (this.diagram.selectedObject.helperObject) {\n            var objects = this.diagram.findObjectsUnderMouse(this.currentPosition);\n            var target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n            helperObject = this.diagram.selectedObject.helperObject;\n            obj = this.diagram.selectedObject.actualObject;\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node) {\n                if (obj.shape.type === 'SwimLane') {\n                    connectors = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.getConnectors)(this.diagram, obj.wrapper.children[0], 0, true);\n                }\n                if (obj.shape.type !== 'SwimLane' && obj.parentId &&\n                    this.diagram.getObject(obj.parentId).shape.type === 'SwimLane') {\n                    if (target instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node && this.diagram.getObject(target.parentId) &&\n                        this.diagram.getObject(target.parentId).shape.type !== 'SwimLane') {\n                        target = this.diagram.getObject(target.parentId);\n                    }\n                }\n                if (this.currentAction === 'Drag' && obj.container && obj.container.type === 'Canvas' && obj.parentId &&\n                    this.diagram.getObject(obj.parentId).shape.type === 'SwimLane' && target &&\n                    target.container && target.container.type === 'Canvas' && target.isLane &&\n                    obj.isLane && target.parentId === obj.parentId) {\n                    if (target !== obj) {\n                        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.laneInterChanged)(this.diagram, obj, target, this.currentPosition);\n                    }\n                    history.isPreventHistory = true;\n                }\n                else {\n                    var parentNode = this.diagram.nameTable[obj.parentId];\n                    if (!parentNode || (parentNode && parentNode.shape.type !== 'SwimLane')) {\n                        if (parentNode && parentNode.isLane && (obj.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.AllowMovingOutsideLane)) {\n                            // 915151: Node Becomes Unmovable After Deleting the First Phase\n                            var swimlane = this.diagram.getObject(parentNode.parentId);\n                            var x = void 0;\n                            var y = void 0;\n                            if (swimlane.shape.orientation === 'Vertical') {\n                                x = swimlane.wrapper.bounds.x + swimlane.shape.phaseSize;\n                                y = swimlane.wrapper.bounds.y + swimlane.shape.header.height;\n                            }\n                            else {\n                                var header = swimlane.shape.header.height +\n                                    swimlane.shape.phaseSize;\n                                x = swimlane.wrapper.bounds.x;\n                                y = swimlane.wrapper.bounds.y + header;\n                            }\n                            var width = swimlane.wrapper.bounds.bottomRight.x - x;\n                            var height = swimlane.wrapper.bounds.bottomRight.y - y;\n                            var swimlaneBounds = new _primitives_rect__WEBPACK_IMPORTED_MODULE_16__.Rect(x, y, width, height);\n                            if (swimlaneBounds.containsPoint(this.currentPosition)) {\n                                obj.offsetX = helperObject.offsetX;\n                                obj.offsetY = helperObject.offsetY;\n                                obj.width = helperObject.width;\n                                obj.height = helperObject.height;\n                                obj.rotateAngle = helperObject.rotateAngle;\n                            }\n                        }\n                        else {\n                            // 902192: Diagram node resized wrongly while dragging with multiple selection Inside a swimlane Issue Fix\n                            if (this.diagram.selectedItems.nodes.length === 1) {\n                                // Single node move with helper\n                                obj.offsetX = helperObject.offsetX;\n                                obj.offsetY = helperObject.offsetY;\n                                if (obj && obj.shape && obj.shape.type !== 'UmlClassifier') {\n                                    obj.width = helperObject.width;\n                                    obj.height = helperObject.height;\n                                }\n                                obj.rotateAngle = helperObject.rotateAngle;\n                            }\n                            else if (this.diagram.selectedItems.nodes.length > 1) {\n                                // Multi selected node move with helper\n                                var offsetX = (helperObject.offsetX - this.diagram.selectedItems.offsetX);\n                                var offsetY = (helperObject.offsetY - this.diagram.selectedItems.offsetY);\n                                var rotateAngle = (helperObject.rotateAngle - this.diagram.selectedItems.rotateAngle);\n                                for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {\n                                    this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].offsetX += offsetX;\n                                    this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].offsetY += offsetY;\n                                    this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)].rotateAngle += rotateAngle;\n                                }\n                            }\n                        }\n                    }\n                    var undoElement = void 0;\n                    if (parentNode && parentNode.container && parentNode.container.type === 'Stack') {\n                        this.diagram.startGroupAction();\n                        hasGroup = true;\n                    }\n                    if (!target && parentNode && parentNode.container && parentNode.container.type === 'Stack' && this.action === 'Drag') {\n                        var index = parentNode.wrapper.children.indexOf(obj.wrapper);\n                        undoElement = { targetIndex: undefined, target: undefined, sourceIndex: index, source: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.cloneObject)(obj) };\n                        if (index > -1) {\n                            var children = parentNode.children;\n                            children.splice(children.indexOf(obj.id), 1);\n                            this.diagram.nameTable[obj.id].parentId = '';\n                            hasStack = true;\n                            parentNode.wrapper.children.splice(index, 1);\n                        }\n                    }\n                    (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.moveChildInStack)(obj, target, this.diagram, this.action);\n                    parentNode = (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, obj) ? this.diagram.nameTable[obj.parentId] :\n                        (this.diagram.nameTable[obj.parentId] || obj);\n                    if (parentNode && parentNode.container && parentNode.container.type === 'Canvas') {\n                        parentNode.wrapper.maxWidth = parentNode.maxWidth = parentNode.wrapper.actualSize.width;\n                        parentNode.wrapper.maxHeight = parentNode.maxHeight = parentNode.wrapper.actualSize.height;\n                        isChangeProperties = true;\n                    }\n                    if ((0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, obj, true) && parentNode && parentNode.container.type === 'Canvas') {\n                        if (this.diagram.selectedItems.nodes.length > 1) {\n                            // 902192: Diagram node resized wrongly while dragging with multiple selection Inside a swimlane Issue Fix\n                            for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {\n                                (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkChildNodeInContainer)(this.diagram, this.diagram.selectedItems.nodes[parseInt(i.toString(), 10)]);\n                            }\n                        }\n                        else {\n                            (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkChildNodeInContainer)(this.diagram, obj);\n                        }\n                    }\n                    else {\n                        history = this.updateContainerPropertiesExtend(parentNode, obj, connectors, helperObject, history);\n                    }\n                    if ((this.diagram.lineRoutingModule && (this.diagram.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramConstraints.LineRouting))\n                        && (!(0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, obj, true))) {\n                        if (obj.children) {\n                            this.diagram.realActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_8__.RealAction.EnableGroupAction;\n                        }\n                        this.diagram.nodePropertyChange(obj, {}, {\n                            width: obj.width, height: obj.height,\n                            offsetX: obj.offsetX, offsetY: obj.offsetY\n                        });\n                        if (obj.children) {\n                            this.diagram.realActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_8__.RealAction.EnableGroupAction;\n                        }\n                    }\n                    if (obj.shape.lanes) {\n                        this.updateLaneChildNode(obj);\n                    }\n                    if (isChangeProperties) {\n                        parentNode.maxWidth = parentNode.wrapper.maxWidth = undefined;\n                        parentNode.maxHeight = parentNode.wrapper.maxHeight = undefined;\n                    }\n                    if (hasStack) {\n                        this.diagram.nodePropertyChange(parentNode, {}, {\n                            offsetX: parentNode.offsetX, offsetY: parentNode.offsetY, width: parentNode.width, height: parentNode.height,\n                            rotateAngle: parentNode.rotateAngle\n                        });\n                        var entry = {\n                            redoObject: { sourceIndex: undefined, source: undoElement.source },\n                            type: 'StackChildPositionChanged', undoObject: undoElement, category: 'Internal'\n                        };\n                        if (!(this.diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.DiagramAction.UndoRedo)) {\n                            this.diagram.addHistoryEntry(entry);\n                        }\n                    }\n                    if (obj && obj.container && (obj.container.type === 'Stack' ||\n                        (obj.container.type === 'Canvas' && obj.parentId === ''))) {\n                        if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n                            obj.wrapper.measureChildren = true;\n                        }\n                        this.diagram.nodePropertyChange(obj, {}, {\n                            offsetX: obj.offsetX, offsetY: obj.offsetY, width: obj.width, height: obj.height, rotateAngle: obj.rotateAngle\n                        });\n                        if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n                            obj.wrapper.measureChildren = false;\n                        }\n                    }\n                }\n                (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.updateConnectorsProperties)(connectors, this.diagram);\n                history.hasStack = hasGroup;\n            }\n            // Bug:914714 Drag Drop Multi selected nodes between lanes.\n            else if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector) {\n                var offsetX = (helperObject.offsetX - obj.offsetX);\n                var offsetY = (helperObject.offsetY - obj.offsetY);\n                var rotateAngle = (helperObject.rotateAngle - obj.rotateAngle);\n                var width = (helperObject.width - obj.width);\n                var height = (helperObject.height - obj.height);\n                var scaleWidth = helperObject.width / obj.width;\n                var scaleHeight = helperObject.height / obj.height;\n                //929543: To resize the multiselected child nodes.\n                if (this.tool.corner) {\n                    var pivot = this.tool.getPivot(this.tool.corner);\n                    for (var i = 0; i < obj.nodes.length; i++) {\n                        var node = obj.nodes[parseInt(i.toString(), 10)];\n                        var element = node.wrapper;\n                        var refWrapper = obj.wrapper;\n                        var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;\n                        var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;\n                        var refPoint = (0,_index__WEBPACK_IMPORTED_MODULE_23__.getPoint)(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);\n                        this.diagram.commandHandler.scaleObject(scaleWidth, scaleHeight, refPoint, node, element, obj);\n                    }\n                }\n                else {\n                    for (var i = 0; i < obj.nodes.length; i++) {\n                        var node = obj.nodes[parseInt(i.toString(), 10)];\n                        var parentNode = this.diagram.nameTable[node.parentId];\n                        if (parentNode && parentNode.shape.type !== 'SwimLane' && (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkParentAsContainer)(this.diagram, node, true)\n                            && parentNode.container.type === 'Canvas') {\n                            node.offsetX += offsetX;\n                            node.offsetY += offsetY;\n                            if (node && node.shape && node.shape.type !== 'UmlClassifier') {\n                                node.width += width;\n                                node.height += height;\n                            }\n                            node.rotateAngle += rotateAngle;\n                            (0,_container_interaction__WEBPACK_IMPORTED_MODULE_20__.checkChildNodeInContainer)(this.diagram, node);\n                        }\n                    }\n                }\n            }\n        }\n        if (obj && (obj.isPhase || obj.isLane ||\n            (obj.shape && obj.shape.type === 'SwimLane'))) {\n            this.diagram.updateDiagramElementQuad();\n        }\n        return history;\n    };\n    DiagramEventHandler.prototype.updateLaneChildNode = function (obj) {\n        for (var i = 0; i < (obj.shape.lanes.length); i++) {\n            if (obj.shape.lanes[parseInt(i.toString(), 10)].children\n                && obj.shape.lanes[parseInt(i.toString(), 10)].children.length > 0) {\n                for (var j = 0; j < obj.shape.lanes[parseInt(i.toString(), 10)].children.length; j++) {\n                    var id = obj.shape.lanes[parseInt(i.toString(), 10)].children[parseInt(j.toString(), 10)].id;\n                    var childNode = this.diagram.nameTable[\"\" + id];\n                    //828489 - Exception occurs while dragging swimlane after adding shape & undo action is performed\n                    if (childNode) {\n                        childNode.offsetX = childNode.wrapper.offsetX;\n                        childNode.offsetY = childNode.wrapper.offsetY;\n                    }\n                }\n            }\n        }\n    };\n    DiagramEventHandler.prototype.updateContainerPropertiesExtend = function (parentNode, obj, connectors, helperObject, history) {\n        if (this.currentAction === 'ResizeEast' || this.currentAction === 'ResizeSouth' || obj.shape.type === 'SwimLane') {\n            var undoObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.cloneObject)(obj);\n            var isUpdateRow = false;\n            if (parentNode && parentNode.container && parentNode.container.type === 'Grid') {\n                var shape = parentNode.shape.type === 'SwimLane' ? true : false;\n                var container = (shape ? parentNode.wrapper.children[0] : parentNode.wrapper);\n                var padding = shape ? parentNode.shape.padding : undefined;\n                var x = parentNode.wrapper.bounds.x;\n                var y = parentNode.wrapper.bounds.y;\n                if (obj.columnIndex !== undefined && (parentNode.container.orientation === 'Horizontal' &&\n                    ((shape && obj.isPhase) || (!shape && obj.rowIndex === 1))) ||\n                    (parentNode.container.orientation === 'Vertical' &&\n                        ((!shape && obj.rowIndex > 0 && obj.columnIndex > 0) || (shape && obj.isLane)))) {\n                    if (parentNode.container.orientation === 'Horizontal' && obj.isPhase && obj.wrapper.width > obj.maxWidth) {\n                        obj.maxWidth = obj.wrapper.width;\n                        obj.wrapper.maxWidth = obj.wrapper.width;\n                    }\n                    var colWidthDiff = helperObject.wrapper.actualSize.width - obj.wrapper.actualSize.width;\n                    // 910832 - Lane height updating to negative values wrongly during resizing\n                    container.updateColumnWidth(obj.columnIndex, helperObject.width, true, padding);\n                    (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.updateSwimLaneObject)(this.diagram, obj, parentNode, helperObject, colWidthDiff);\n                    if (obj.isPhase) {\n                        var id = parentNode.shape.phases[obj.columnIndex].header.id;\n                        var node = this.diagram.nameTable[\"\" + id];\n                        if (node.maxWidth < helperObject.width) {\n                            node.maxWidth = helperObject.width;\n                            node.wrapper.maxWidth = helperObject.width;\n                        }\n                    }\n                    if (parentNode.shape.type === 'SwimLane') {\n                        parentNode.width = (parentNode.width) ? container.width : parentNode.width;\n                        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.updateHeaderMaxWidth)(this.diagram, parentNode);\n                        parentNode.wrapper.width = parentNode.width;\n                        connectors = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.getConnectors)(this.diagram, container, obj.rowIndex, false);\n                    }\n                }\n                else if (obj.rowIndex !== undefined) {\n                    isUpdateRow = true;\n                    var rowHeightDiff = helperObject.wrapper.actualSize.height - obj.wrapper.actualSize.height;\n                    // 910832 - Lane height updating to negative values wrongly during resizing\n                    container.updateRowHeight(obj.rowIndex, helperObject.height, true, padding);\n                    (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.updateSwimLaneObject)(this.diagram, obj, parentNode, helperObject, undefined, rowHeightDiff);\n                    if (parentNode.shape.type === 'SwimLane') {\n                        parentNode.height = (parentNode.height) ? container.height : parentNode.height;\n                        parentNode.wrapper.height = parentNode.height;\n                        connectors = (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.getConnectors)(this.diagram, container, obj.rowIndex, true);\n                    }\n                }\n                if (parentNode.shape.type === 'SwimLane') {\n                    history.isPreventHistory = true;\n                }\n                this.diagram.nodePropertyChange(parentNode, {}, {\n                    offsetX: parentNode.offsetX, offsetY: parentNode.offsetY,\n                    rotateAngle: parentNode.rotateAngle\n                });\n                this.diagram.drag(parentNode, x - parentNode.wrapper.bounds.x, y - parentNode.wrapper.bounds.y);\n            }\n            else {\n                if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n                    obj.wrapper.measureChildren = true;\n                }\n                this.diagram.nodePropertyChange(obj, {}, {\n                    offsetX: obj.offsetX, offsetY: obj.offsetY, width: obj.width, height: obj.height, rotateAngle: obj.rotateAngle\n                });\n                obj.wrapper.measureChildren = false;\n            }\n            obj.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_14__.Size(obj.wrapper.width, obj.wrapper.height));\n            obj.wrapper.arrange(obj.wrapper.desiredSize);\n            if (this.currentAction === 'ResizeEast' || this.currentAction === 'ResizeSouth') {\n                var redoObject = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.cloneObject)(obj);\n                var entry = {\n                    category: 'Internal',\n                    type: (isUpdateRow) ? 'RowHeightChanged' : 'ColumnWidthChanged',\n                    undoObject: undoObj, redoObject: redoObject\n                };\n                this.diagram.addHistoryEntry(entry);\n            }\n        }\n        (0,_utility_swim_lane_util__WEBPACK_IMPORTED_MODULE_21__.updateConnectorsProperties)(connectors, this.diagram);\n        return history;\n    };\n    DiagramEventHandler.prototype.addUmlNode = function () {\n        var node = this.diagram.selectedItems.nodes[0];\n        var objects = this.diagram.findObjectsUnderMouse({ x: this.currentPosition.x + 20, y: this.currentPosition.y });\n        var target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n        var attribute;\n        var method;\n        if (!target) {\n            objects = this.diagram.findObjectsUnderMouse({ x: this.currentPosition.x - 20, y: this.currentPosition.y });\n            target = this.diagram.findObjectUnderMouse(objects, this.action, this.inAction);\n        }\n        if (node && node.container && node.container.type === 'Stack' && target && target.parentId\n            && target.parentId === node.id) {\n            var innerNode = target;\n            var adornerSvg = (0,_utility_dom_util__WEBPACK_IMPORTED_MODULE_12__.getAdornerLayerSvg)(this.diagram.element.id);\n            var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');\n            if (highlighter) {\n                var index = node.wrapper.children.indexOf(target.wrapper) + 1;\n                this.diagram.enableServerDataBinding(false);\n                var temp = new _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node(this.diagram, 'nodes', {\n                    style: {\n                        fill: node.style.fill,\n                        strokeColor: (node.style.strokeColor === 'black') ? '#ffffff00' : node.style.strokeColor\n                    },\n                    annotations: target.annotations, verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',\n                    constraints: (_enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.Default | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.HideThumbs) & ~(_enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.Rotate | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.Drag | _enum_enum__WEBPACK_IMPORTED_MODULE_8__.NodeConstraints.Resize),\n                    minHeight: 25\n                }, true);\n                temp.annotations[0].content = ' + Name : Type';\n                var id = innerNode.id.split('_');\n                temp.id = (0,_index__WEBPACK_IMPORTED_MODULE_23__.randomId)() + temp.id;\n                temp.parentId = node.id;\n                temp.zIndex = -1;\n                temp.umlIndex = index;\n                this.diagram.startGroupAction();\n                var child = { name: 'Name', type: 'Type' };\n                //While dynamically adding nodes at runtime using the isSeparator highlighter, make sure to include the newly added nodes in the existing arrays of the UML node for the respective child types.\n                if (node.shape.classifier === 'Class') {\n                    if (target.id.includes('_umlProperty') && node.shape.classShape.attributes.length > 0) {\n                        attribute = new _objects_node__WEBPACK_IMPORTED_MODULE_5__.UmlClassAttribute(node, '', child);\n                        node.shape.classShape.attributes.push(attribute);\n                    }\n                    else if (target.id.includes('_umlMethods') && node.shape.classShape.methods.length > 0) {\n                        method = new _objects_node__WEBPACK_IMPORTED_MODULE_5__.UmlClassMethod(node, '', child);\n                        node.shape.classShape.methods.push(method);\n                    }\n                }\n                if (node.shape.classifier === 'Interface') {\n                    if (target.id.includes('_umlProperty') && node.shape.interfaceShape.attributes.length > 0) {\n                        attribute = new _objects_node__WEBPACK_IMPORTED_MODULE_5__.UmlClassAttribute(node, '', child);\n                        node.shape.classShape.attributes.push(attribute);\n                    }\n                    else if (target.id.includes('_umlMethods') && node.shape.interfaceShape.methods.length > 0) {\n                        method = new _objects_node__WEBPACK_IMPORTED_MODULE_5__.UmlClassMethod(node, '', child);\n                        node.shape.interfaceShape.methods.push(method);\n                    }\n                }\n                if (node.shape.classifier === 'Enumeration') {\n                    if (target.id.includes('_umlMember') && node.shape.enumerationShape.members.length > 0) {\n                        var member = new _objects_node__WEBPACK_IMPORTED_MODULE_5__.UmlEnumerationMember(node, '', child);\n                        node.shape.enumerationShape.members.push(member);\n                    }\n                }\n                var redoElement = {\n                    sourceIndex: node.wrapper.children.indexOf(temp.wrapper), source: temp,\n                    target: undefined, targetIndex: undefined\n                };\n                this.diagram.enableServerDataBinding(true);\n                this.diagram.add(temp);\n                this.diagram.updateConnectorEdges(node);\n                this.diagram.clearSelection();\n                this.diagram.select([this.diagram.nameTable[temp.id]]);\n                this.diagram.endGroupAction();\n                this.diagram.startTextEdit();\n            }\n        }\n    };\n    return DiagramEventHandler;\n}());\n\n/** @private */\nvar ObjectFinder = /** @class */ (function () {\n    function ObjectFinder() {\n    }\n    /** @private */\n    ObjectFinder.prototype.findObjectsUnderMouse = function (pt, diagram, eventArgs, source, actions) {\n        // finds the collection of the object that is under the mouse;\n        var actualTarget = [];\n        if (source && source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector) {\n            if (source.nodes.length + source.connectors.length === 1) {\n                source = (source.nodes[0] || source.connectors[0]);\n                if (source.children && source.children.length === 0) {\n                    eventArgs.actualObject = source;\n                }\n            }\n        }\n        var container;\n        var bounds;\n        var child;\n        var matrix;\n        var endPadding = (source && (source instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) &&\n            ((source.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.ConnectToNearByNode) ||\n                (source.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_8__.ConnectorConstraints.ConnectToNearByPort)) && source.connectionPadding) || 0;\n        var objArray = diagram.spatialSearch.findObjects(new _primitives_rect__WEBPACK_IMPORTED_MODULE_16__.Rect(pt.x - 50 - endPadding, pt.y - 50 - endPadding, 100 + endPadding, 100 + endPadding));\n        var layerObjTable = {};\n        var layerTarger;\n        for (var _i = 0, objArray_1 = objArray; _i < objArray_1.length; _i++) {\n            var obj = objArray_1[_i];\n            var point = pt;\n            bounds = obj.wrapper.outerBounds;\n            var pointInBounds = (obj.rotateAngle) ? false : bounds.containsPoint(point, endPadding);\n            if ((obj !== source || diagram.currentDrawingObject instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) &&\n                (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) ? obj !== diagram.currentDrawingObject :  true && obj.wrapper.visible) {\n                var layer = diagram.commandHandler.getObjectLayer(obj.id);\n                if (layer && !layer.lock && layer.visible) {\n                    layerTarger = layerObjTable[layer.zIndex] = layerObjTable[layer.zIndex] || [];\n                    if (obj.rotateAngle) {\n                        container = obj.wrapper;\n                        bounds = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.cornersPointsBeforeRotation)(container);\n                        for (var _a = 0, _b = container.children; _a < _b.length; _a++) {\n                            child = _b[_a];\n                            matrix = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_17__.identityMatrix)();\n                            (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_17__.rotateMatrix)(matrix, -(child.rotateAngle + child.parentTransform), child.offsetX, child.offsetY);\n                            point = (0,_primitives_matrix__WEBPACK_IMPORTED_MODULE_17__.transformPointByMatrix)(matrix, pt);\n                            if ((0,_utility_base_util__WEBPACK_IMPORTED_MODULE_15__.cornersPointsBeforeRotation)(child).containsPoint(point, endPadding)) {\n                                pointInBounds = true;\n                            }\n                        }\n                    }\n                    if (!source || ((0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(diagram, obj) === false)) {\n                        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canEnablePointerEvents)(obj, diagram)) {\n                            if ((obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) ? (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.isPointOverConnector)(obj, pt) : pointInBounds) {\n                                var padding = (obj instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) ? obj.hitPadding || 0 : 0; //let element: DiagramElement;\n                                var element = this.findElementUnderMouse(obj, pt, diagram, endPadding || padding);\n                                if (element && obj.id !== 'helper') {\n                                    (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.insertObject)(obj, 'zIndex', layerTarger);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (var _c = 0, _d = diagram.layers; _c < _d.length; _c++) {\n            var layer = _d[_c];\n            actualTarget = actualTarget.concat(layerObjTable[layer.zIndex] || []);\n            for (var _e = 0, actualTarget_1 = actualTarget; _e < actualTarget_1.length; _e++) {\n                var obj = actualTarget_1[_e];\n                var eventHandler = 'eventHandler';\n                if (obj.shape.type === 'Bpmn' && obj.processId && (!(diagram[\"\" + eventHandler].tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool) ||\n                    (diagram[\"\" + eventHandler].tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool) && (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canAllowDrop)(obj))) {\n                    var index = actualTarget.indexOf(diagram.nameTable[obj.processId]);\n                    if (index > -1) {\n                        actualTarget.splice(index, 1);\n                    }\n                }\n                if (obj.shape.type === 'UmlClassifier' && obj.container && obj.container.type === 'Stack') {\n                    var index = actualTarget.indexOf(diagram.nameTable[diagram.nameTable[obj.id].wrapper.children[0].id]);\n                    if (index > -1) {\n                        actualTarget.splice(index, 1);\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < actualTarget.length; i++) {\n            var parentObj = diagram.nameTable[actualTarget[parseInt(i.toString(), 10)].parentId];\n            if (parentObj) {\n                var portElement = this.findElementUnderMouse(parentObj, pt, diagram);\n                for (var j = 0; j < parentObj.ports.length; j++) {\n                    if (portElement && portElement.id.match('_' + parentObj.ports[parseInt(j.toString(), 10)].id + '$')) {\n                        var port = parentObj.ports[parseInt(j.toString(), 10)];\n                        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canDrag)(port, diagram) || (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canDraw)(port, diagram)) {\n                            return actualTarget;\n                        }\n                    }\n                }\n            }\n            while (parentObj) {\n                var index = actualTarget.indexOf(parentObj);\n                if (index !== -1) {\n                    actualTarget.splice(index, 1);\n                }\n                else {\n                    break;\n                }\n                parentObj = diagram.nameTable[parentObj.parentId];\n            }\n        }\n        this.checkSwimlane(actualTarget, diagram);\n        if (eventArgs && !eventArgs.source) {\n            for (var i = 0; i < actualTarget.length; i++) {\n                var parentNode = diagram.nameTable[actualTarget[parseInt(i.toString(), 10)].parentId];\n                if (parentNode && parentNode.shape.type === 'SwimLane') {\n                    for (var j = 0; j < actualTarget.length; j++) {\n                        var connector = actualTarget[parseInt(j.toString(), 10)];\n                        if (connector instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) {\n                            actualTarget.splice(i, 1);\n                        }\n                    }\n                }\n            }\n        }\n        return actualTarget;\n    };\n    /** @private */\n    ObjectFinder.prototype.checkSwimlane = function (actualTarget, diagram) {\n        var isNode;\n        for (var m = 0; m < actualTarget.length; m++) {\n            var obj = actualTarget[parseInt(m.toString(), 10)];\n            var parentNode = void 0;\n            var node = void 0;\n            if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node) {\n                parentNode = actualTarget[parseInt(m.toString(), 10)].parentId;\n                node = obj;\n            }\n            if (parentNode === '') {\n                if (node.shape.type !== 'SwimLane') {\n                    isNode = true;\n                }\n                else {\n                    isNode = false;\n                }\n            }\n            var parent_2 = diagram.nameTable[\"\" + parentNode];\n            if (parent_2 && parent_2.isLane && diagram.nameTable[parent_2.parentId].zIndex > obj.zIndex) {\n                actualTarget[parseInt(m.toString(), 10)] = parent_2;\n            }\n            if (m > 0 && isNode && node && (node.isLane || node.isPhase || node.isHeader)) {\n                if (actualTarget[parseInt(m.toString(), 10)].zIndex < actualTarget[m - 1].zIndex) {\n                    var swap = actualTarget[parseInt(m.toString(), 10)];\n                    actualTarget[parseInt(m.toString(), 10)] = actualTarget[m - 1];\n                    actualTarget[m - 1] = swap;\n                }\n            }\n        }\n        if (actualTarget.length >= 2) {\n            var parent_3 = '';\n            for (var i = actualTarget.length - 1; i >= 0; i--) {\n                if (actualTarget[parseInt(i.toString(), 10)].parentId) {\n                    var parent1 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.findParentInSwimlane)(actualTarget[parseInt(i.toString(), 10)], diagram, parent_3);\n                    var parent2 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.findParentInSwimlane)(actualTarget[i - 1], diagram, parent_3);\n                    var parentNode1 = diagram.nameTable[\"\" + parent1];\n                    var parentNode2 = diagram.nameTable[\"\" + parent2];\n                    if (parentNode2 && parent1 !== parent2 && parentNode1.zIndex < parentNode2.zIndex) {\n                        actualTarget.splice(i, 1);\n                    }\n                }\n            }\n        }\n    };\n    /** @private */\n    ObjectFinder.prototype.isTarget = function (actualTarget, diagram, action) {\n        var connector = diagram.selectedItems.connectors[0];\n        var node;\n        node = action === 'ConnectorSourceEnd' ? diagram.nameTable[connector.targetID] :\n            node = diagram.nameTable[connector.sourceID];\n        if (node && !(node.processId && !actualTarget.processId\n            || node.processId !== actualTarget.processId)) {\n            if (node.processId !== actualTarget.processId) {\n                actualTarget = null;\n            }\n            if (actualTarget && actualTarget.parentId &&\n                diagram.nameTable[actualTarget.parentId].shape.type === 'UmlClassifier') {\n                actualTarget = diagram.nameTable[actualTarget.parentId];\n            }\n        }\n        if (action === 'ConnectorSourceEnd' && connector.targetID) {\n            var targetNode = diagram.nameTable[connector.targetID];\n            if (targetNode && targetNode.shape && (targetNode.shape.shape === 'TextAnnotation')) {\n                var id = connector.id.split('_');\n                if (((targetNode.shape.type === 'Bpmn') && actualTarget.shape.type !== 'Bpmn') || (id[0] === actualTarget.id) ||\n                    actualTarget.shape.shape === 'TextAnnotation') {\n                    actualTarget = null;\n                }\n                if (actualTarget && actualTarget.parentId &&\n                    diagram.nameTable[actualTarget.parentId].shape.type === 'UmlClassifier') {\n                    actualTarget = diagram.nameTable[actualTarget.parentId];\n                }\n            }\n        }\n        //908151: The connector automatically connects to the subprocess\n        //909560: prevent child connector connecting to its own parent group\n        //937174: Drag and drop subprocess and add children try to connect with connector throw exception\n        if (actualTarget && ((node && actualTarget.id === node.processId) ||\n            ((action === 'ConnectorSourceEnd' || action === 'ConnectorTargetEnd') && actualTarget.id === connector.parentId))) {\n            actualTarget = null;\n        }\n        return actualTarget;\n    };\n    /* tslint:disable */\n    /** @private */\n    ObjectFinder.prototype.findObjectUnderMouse = function (diagram, objects, action, inAction, eventArg, position, source) {\n        //we will get the wrapper object here\n        //we have to choose the object to be interacted with from the given wrapper\n        //Find the object that is under mouse\n        var eventHandler = 'eventHandler';\n        var endPoint = 'endPoint';\n        var inPort;\n        var outPort;\n        var actualTarget = null;\n        if (objects.length !== 0) {\n            if (source && source instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector) {\n                if (source.nodes.length + source.connectors.length === 1) {\n                    source = (source.nodes[0] || source.connectors[0]);\n                }\n            }\n            if ((action === 'ConnectorSourceEnd' && source || action === 'PortDraw') ||\n                (((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canDrawOnce)(diagram) || (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canContinuousDraw)(diagram)) && (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.getObjectType)(diagram.drawingObject) === _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector)) {\n                var connector = diagram.selectedItems.connectors[0];\n                for (var i = objects.length - 1; i >= 0; i--) {\n                    outPort = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.getInOutConnectPorts)(objects[parseInt(i.toString(), 10)], false);\n                    inPort = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.getInOutConnectPorts)(objects[parseInt(i.toString(), 10)], true);\n                    var tool = diagram[\"\" + eventHandler].tool;\n                    var portElement = this.findTargetElement(objects[parseInt(i.toString(), 10)].wrapper, position, diagram, undefined);\n                    if (action === 'Draw' && portElement && (objects[parseInt(i.toString(), 10)] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || objects[parseInt(i.toString(), 10)] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && !(0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.checkPort)(objects[parseInt(i.toString(), 10)], portElement)) {\n                        if (((tool && tool[\"\" + endPoint] === 'ConnectorSourceEnd') && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canOutConnect)(objects[parseInt(i.toString(), 10)])) ||\n                            ((tool && tool[\"\" + endPoint] === 'ConnectorTargetEnd') && !(0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canInConnect)(objects[parseInt(i.toString(), 10)]))) {\n                            return actualTarget;\n                        }\n                    }\n                    // eslint-disable-next-line max-len\n                    if ((objects[parseInt(i.toString(), 10)] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node) || (objects[parseInt(i.toString(), 10)] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) && (((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canOutConnect)(objects[parseInt(i.toString(), 10)]) || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canPortOutConnect)(outPort)) || (0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canInConnect)(objects[parseInt(i.toString(), 10)]) || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canPortInConnect)(inPort))) ||\n                        (action === 'PortDraw' && (tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.ConnectTool) && tool[\"\" + endPoint] === 'ConnectorTargetEnd' &&\n                            ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canInConnect)(objects[parseInt(i.toString(), 10)]) || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canPortInConnect)(inPort)))))) {\n                        actualTarget = objects[parseInt(i.toString(), 10)];\n                        if (connector) {\n                            actualTarget = this.isTarget(actualTarget, diagram, action);\n                        }\n                        eventArg.actualObject = actualTarget;\n                        return actualTarget;\n                    }\n                }\n            }\n            else if (action === 'ConnectorTargetEnd' && source) {\n                for (var i = objects.length - 1; i >= 0; i--) {\n                    inPort = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.getInOutConnectPorts)(objects[parseInt(i.toString(), 10)], true);\n                    if ((objects[parseInt(i.toString(), 10)] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || objects[parseInt(i.toString(), 10)] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector)\n                        && ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canInConnect)(objects[parseInt(i.toString(), 10)]) || ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canPortInConnect)(inPort)))) {\n                        actualTarget = objects[parseInt(i.toString(), 10)];\n                        actualTarget = this.isTarget(actualTarget, diagram, action);\n                        eventArg.actualObject = actualTarget;\n                        return actualTarget;\n                    }\n                }\n            }\n            else if (source && (action === 'Drag' || (diagram[\"\" + eventHandler].tool instanceof _tool__WEBPACK_IMPORTED_MODULE_4__.MoveTool))) {\n                var index = 0;\n                for (var i = 0; i < objects.length; i++) {\n                    var temp = objects[parseInt(i.toString(), 10)];\n                    if (source !== temp && (temp instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector ||\n                        !position || temp.wrapper.bounds.containsPoint(position))) {\n                        if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canAllowDrop)(temp)) {\n                            if (!actualTarget) {\n                                actualTarget = temp;\n                                index = actualTarget.zIndex;\n                            }\n                            else {\n                                actualTarget = index >= temp.zIndex ? actualTarget : temp;\n                                index = Math.max(index, temp.zIndex);\n                            }\n                        }\n                    }\n                }\n                if (actualTarget && actualTarget.shape.type === 'Bpmn') {\n                    if (diagram.selectedItems.nodes.length > 0 && diagram.selectedItems.nodes[0].shape.type === 'Bpmn') {\n                        // eslint-disable-next-line no-self-assign\n                        actualTarget = actualTarget;\n                    }\n                    else {\n                        actualTarget = null;\n                    }\n                }\n                if (actualTarget) {\n                    eventArg.actualObject = actualTarget;\n                }\n                return actualTarget;\n            }\n            else if ((action === 'Select' || action === 'Pan') && diagram[\"\" + eventHandler].tool) {\n                for (var i = objects.length - 1; i >= 0; i--) {\n                    if (objects[parseInt(i.toString(), 10)] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) {\n                        var objj1 = objects[i - 1];\n                        if (objects[i - 1] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node && objj1.ports) {\n                            var portElement = this.findTargetElement(objj1.wrapper, position, diagram, undefined);\n                            if ((portElement && (portElement.id.match('_icon_content_shape$') || portElement.id.match('_icon_content_rect$')))) {\n                                return objj1;\n                            }\n                            for (var j = 0; j < objj1.ports.length; j++) {\n                                if (portElement && portElement.id.match('_' + objj1.ports[parseInt(j.toString(), 10)].id + '$')) {\n                                    if ((0,_utility_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canDraw)(objj1.ports[parseInt(j.toString(), 10)], diagram)) {\n                                        return objj1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                actualTarget = objects[objects.length - 1];\n                eventArg.actualObject = actualTarget;\n                if (!diagram[\"\" + eventHandler].itemClick(actualTarget, true)) {\n                    if (actualTarget.parentId) {\n                        var obj = actualTarget;\n                        var selected = (0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(diagram, obj);\n                        while (obj) {\n                            if ((0,_actions__WEBPACK_IMPORTED_MODULE_7__.isSelected)(diagram, obj) && !selected) {\n                                break;\n                            }\n                            actualTarget = obj;\n                            // 912178-Tooltip for node is not shown when grouped at runtime\n                            if (obj.tooltip.content !== '') {\n                                break;\n                            }\n                            obj = diagram.nameTable[obj.parentId];\n                        }\n                    }\n                }\n            }\n            else if (action === 'Pan' || action === 'LayoutAnimation') {\n                for (var i = objects.length - 1; i >= 0; i--) {\n                    if (objects[parseInt(i.toString(), 10)] instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Node || objects[parseInt(i.toString(), 10)] instanceof _objects_connector__WEBPACK_IMPORTED_MODULE_3__.Connector) {\n                        var portElement = this.findTargetElement(objects[parseInt(i.toString(), 10)].wrapper, position, diagram, undefined);\n                        if ((action === 'Pan') || ((portElement && (portElement.id.match('_icon_content_shape$') || portElement.id.match('_icon_content_rect$'))))) {\n                            return objects[parseInt(i.toString(), 10)];\n                        }\n                    }\n                }\n            }\n            else {\n                actualTarget = objects[objects.length - 1];\n                if (eventArg && actualTarget) {\n                    eventArg.actualObject = actualTarget;\n                }\n            }\n        }\n        return actualTarget;\n    };\n    /* tslint:enable */\n    /** @private */\n    ObjectFinder.prototype.findElementUnderSelectedItem = function (obj, position, diagram, padding) {\n        //rewrite this for multiple selection\n        if (obj instanceof _objects_node__WEBPACK_IMPORTED_MODULE_5__.Selector) {\n            if (obj.nodes.length === 1 && (!obj.connectors || !obj.connectors.length)) {\n                return this.findElementUnderMouse(obj.nodes[0], position, diagram);\n            }\n            else if ((!obj.nodes || obj.nodes.length) && obj.connectors.length === 1) {\n                return this.findElementUnderMouse(obj.connectors[0], position, diagram);\n            }\n        }\n        else {\n            return this.findElementUnderMouse(obj, position, diagram, padding);\n        }\n        return null;\n    };\n    ObjectFinder.prototype.findElementUnderMouse = function (obj, position, diagram, padding) {\n        return this.findTargetElement(obj.wrapper, position, diagram, padding);\n    };\n    /** @private */\n    ObjectFinder.prototype.findTargetElement = function (container, position, diagram, padding) {\n        for (var i = container.children.length - 1; i >= 0; i--) {\n            var element = container.children[parseInt(i.toString(), 10)];\n            //Checking whether the annotation is visible or not\n            if (element && element.outerBounds.containsPoint(position, padding || 0)) {\n                if (element.visible) {\n                    if (element instanceof _core_containers_container__WEBPACK_IMPORTED_MODULE_2__.Container) {\n                        var target = this.findTargetElement(element, position, diagram);\n                        if (target) {\n                            return target;\n                        }\n                    }\n                    //EJ2-69047 - Node selection is improper while adding annotation for multiple nodes\n                    //Checked textOverflow property to avoid the selection of text element with clip and ellipsis;\n                    var textOverflow = (element.style.textOverflow === 'Clip' || element.style.textOverflow === 'Ellipsis');\n                    if (element.bounds.containsPoint(position, padding || 0) && !textOverflow) {\n                        return element;\n                    }\n                    else if (container.bounds.containsPoint(position, padding || 0) && textOverflow) {\n                        // 913240 - Tooltip for annotation not visible while text overflow sets to Clip or Ellipsis\n                        return element;\n                    }\n                }\n                //(EJ2-840331)Double click on node annotation will open the edit of invisible annotation\n                else if (element instanceof _index__WEBPACK_IMPORTED_MODULE_23__.PathElement && container && container.id) {\n                    var getNode = void 0;\n                    if (container.id.includes('group_container')) {\n                        var getId = container.id.slice(0, -15);\n                        getNode = diagram.getObject(getId);\n                    }\n                    else {\n                        getNode = diagram.getObject(container.id);\n                    }\n                    var port = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_9__.findPort)(getNode, element.id);\n                    // 913000: Connector not connected to port when visibility hidden\n                    if (port) {\n                        return element;\n                    }\n                }\n            }\n        }\n        if (container.bounds.containsPoint(position, padding) && container.style.fill !== 'none') {\n            return container;\n        }\n        return null;\n    };\n    return ObjectFinder;\n}());\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/event-handlers.js?");

/***/ })

}]);