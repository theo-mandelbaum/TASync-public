"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_annotation_ink-annotation_js-55f4f-6c776844"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/ink-annotation.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/ink-annotation.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InkAnnotation: () => (/* binding */ InkAnnotation)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/index.js\");\n/* harmony import */ var _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-drawings */ \"./node_modules/@syncfusion/ej2-drawings/index.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\nvar InkAnnotation = /** @class */ (function () {\n    function InkAnnotation(pdfViewer, pdfViewerBase) {\n        this.newObject = [];\n        /**\n         * @private\n         */\n        this.outputString = '';\n        /**\n         * @private\n         */\n        this.inkAnnotationindex = [];\n        /**\n         * @private\n         */\n        this.isAddAnnotationProgramatically = false;\n        /**\n         * @private\n         */\n        this.currentPageNumber = '';\n        /**\n         * @private\n         */\n        this.inkAnnotationInitialZoom = 1;\n        /**\n         * @private\n         */\n        this.inkPathDataCollection = [];\n        this.pdfViewer = pdfViewer;\n        this.pdfViewerBase = pdfViewerBase;\n    }\n    /**\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.drawInk = function () {\n        this.pdfViewerBase.disableTextSelectionMode();\n        this.pdfViewer.tool = 'Ink';\n    };\n    InkAnnotation.prototype.drawInkAnnotation = function (pageNumber) {\n        if (this.pdfViewerBase.isToolbarInkClicked) {\n            this.pdfViewerBase.isInkAdded = true;\n            this.pdfViewer.annotationModule.isFormFieldShape = false;\n            var pageIndex = !isNaN(pageNumber) ? pageNumber : this.pdfViewerBase.currentPageNumber - 1;\n            if ((this.outputString && this.outputString !== '') || this.inkPathDataCollection.length > 0) {\n                var currentAnnot = this.addInk(pageIndex);\n                this.pdfViewer.renderDrawing(undefined, pageIndex);\n                this.pdfViewer.clearSelection(pageIndex);\n                this.pdfViewer.select([currentAnnot.id], currentAnnot.annotationSelectorSettings);\n                if (this.pdfViewer.toolbar && this.pdfViewer.toolbar.annotationToolbarModule) {\n                    this.pdfViewer.toolbar.annotationToolbarModule.enableSignaturePropertiesTools(true);\n                }\n                if (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.Browser.isDevice && !this.pdfViewer.enableDesktopMode &&\n                    this.pdfViewer.enableToolbar && this.pdfViewer.enableAnnotationToolbar) {\n                    this.pdfViewer.toolbarModule.annotationToolbarModule.createPropertyTools('Ink');\n                }\n            }\n            else {\n                this.outputString = '';\n                this.newObject = [];\n                this.pdfViewerBase.isToolbarInkClicked = false;\n                this.pdfViewer.tool = '';\n                this.inkPathDataCollection = [];\n            }\n            this.pdfViewerBase.isInkAdded = false;\n        }\n    };\n    /**\n     * @private\n     * @returns {any} - any\n     */\n    InkAnnotation.prototype.updateInkDataWithZoom = function () {\n        var updatedPathData = '';\n        if (this.outputString !== '') {\n            this.inkPathDataCollection.push({ pathData: this.outputString, zoomFactor: this.inkAnnotationInitialZoom });\n        }\n        if (this.inkPathDataCollection.length > 0) {\n            //for loop to get the path data from the collection with path zoom factor\n            for (var i = 0; i < this.inkPathDataCollection.length; i++) {\n                updatedPathData += this.updatePathDataWithZoom(this.inkPathDataCollection[parseInt(i.toString(), 10)].pathData, this.inkPathDataCollection[parseInt(i.toString(), 10)].zoomFactor);\n            }\n        }\n        else {\n            updatedPathData += this.updatePathDataWithZoom(this.outputString, this.inkAnnotationInitialZoom);\n        }\n        return updatedPathData;\n    };\n    InkAnnotation.prototype.updatePathDataWithZoom = function (pathData, pathZoomFactor) {\n        var pathString = '';\n        var zoom = this.pdfViewerBase.getZoomFactor();\n        var collectionData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.processPathData)(pathData);\n        var csData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.splitArrayCollection)(collectionData);\n        for (var j = 0; j < csData.length; j++) {\n            var pathValue = csData[parseInt(j.toString(), 10)];\n            pathString += pathValue.command + pathValue.x * (zoom / pathZoomFactor) + ',' + pathValue.y * (zoom / pathZoomFactor) + ' ';\n        }\n        return pathString;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.storePathData = function () {\n        this.convertToPath(this.newObject);\n        this.newObject = [];\n    };\n    /**\n     * @param {any} position - It describes about the position of the annotation\n     * @param {number} pageIndex - It describes about the page index value\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.drawInkInCanvas = function (position, pageIndex) {\n        if (this.currentPageNumber !== '' && parseInt(this.currentPageNumber, 10) !== pageIndex) {\n            this.drawInkAnnotation(parseInt(this.currentPageNumber, 10));\n            this.pdfViewerBase.isToolbarInkClicked = true;\n            this.pdfViewer.tool = 'Ink';\n        }\n        var zoom = this.pdfViewerBase.getZoomFactor();\n        this.inkAnnotationInitialZoom = zoom;\n        var ratio = this.pdfViewerBase.getWindowDevicePixelRatio();\n        var canvas = this.pdfViewerBase.getAnnotationCanvas('_annotationCanvas_', pageIndex);\n        var context = canvas.getContext('2d');\n        var thickness = this.pdfViewer.inkAnnotationSettings.thickness ? this.pdfViewer.inkAnnotationSettings.thickness : 1;\n        var opacity = this.pdfViewer.inkAnnotationSettings.opacity ? this.pdfViewer.inkAnnotationSettings.opacity : 1;\n        var strokeColor = this.pdfViewer.inkAnnotationSettings.strokeColor ? this.pdfViewer.inkAnnotationSettings.strokeColor : '#ff0000';\n        if (!_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.Browser.isDevice || (_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.Browser.isDevice && zoom <= 0.7)) {\n            context.setTransform(ratio, 0, 0, ratio, 0, 0);\n        }\n        context.beginPath();\n        context.lineJoin = 'round';\n        context.lineCap = 'round';\n        context.moveTo(position.prevPosition.x, position.prevPosition.y);\n        context.lineTo(position.currentPosition.x, position.currentPosition.y);\n        context.lineWidth = thickness * zoom > 1 ? thickness * zoom : thickness;\n        context.strokeStyle = strokeColor;\n        context.globalAlpha = opacity;\n        // After the addition of a TextMarkup annotation, a LineDash value was introduced. To eliminate it, the value was cleared.\n        context.setLineDash([]);\n        context.stroke();\n        // context.lineWidth = 2;\n        context.arc(position.prevPosition.x, position.prevPosition.y, 2 / 2, 0, Math.PI * 2, true);\n        context.closePath();\n        this.pdfViewerBase.prevPosition = position.currentPosition;\n        this.newObject.push(position.currentPosition.x, position.currentPosition.y);\n        this.currentPageNumber = pageIndex.toString();\n    };\n    InkAnnotation.prototype.convertToPath = function (newObject) {\n        this.movePath(newObject[0], newObject[1]);\n        this.linePath(newObject[0], newObject[1]);\n        for (var n = 2; n < newObject.length; n = n + 2) {\n            this.linePath(newObject[parseInt(n.toString(), 10)], newObject[n + 1]);\n        }\n    };\n    InkAnnotation.prototype.linePath = function (x, y) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(x) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(y)) {\n            this.outputString += 'L' + x + ',' + y + ' ';\n        }\n    };\n    InkAnnotation.prototype.movePath = function (x, y) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(x) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(y)) {\n            this.outputString += 'M' + x + ',' + y + ' ';\n        }\n    };\n    /**\n     * @param {number} pageNumber - It describes about the page number\n     * @private\n     * @returns {any} - any\n     */\n    InkAnnotation.prototype.addInk = function (pageNumber) {\n        this.outputString = this.updateInkDataWithZoom();\n        var currentBounds = this.calculateInkSize(this.outputString);\n        var annot;\n        if (this.pdfViewerBase.isToolbarInkClicked) {\n            var annotationName = this.pdfViewer.annotation.createGUID();\n            var modifiedDate = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n            var pageIndex = !isNaN(pageNumber) ? pageNumber : this.pdfViewerBase.currentPageNumber - 1;\n            var thickness = this.pdfViewer.inkAnnotationSettings.thickness ? this.pdfViewer.inkAnnotationSettings.thickness : 1;\n            var opacity = this.pdfViewer.inkAnnotationSettings.opacity ? this.pdfViewer.inkAnnotationSettings.opacity : 1;\n            var strokeColor = this.pdfViewer.inkAnnotationSettings.strokeColor ? this.pdfViewer.inkAnnotationSettings.strokeColor : '#ff0000';\n            var isLock = this.pdfViewer.inkAnnotationSettings.isLock ?\n                this.pdfViewer.inkAnnotationSettings.isLock : this.pdfViewer.annotationSettings.isLock;\n            var author = (this.pdfViewer.annotationSettings.author !== 'Guest') ? this.pdfViewer.annotationSettings.author : this.pdfViewer.inkAnnotationSettings.author ? this.pdfViewer.inkAnnotationSettings.author : 'Guest';\n            var subject = (this.pdfViewer.annotationSettings.subject !== '' && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.subject)) ? this.pdfViewer.annotationSettings.subject : this.pdfViewer.inkAnnotationSettings.subject ? this.pdfViewer.inkAnnotationSettings.subject : 'Ink';\n            var customData = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(this.pdfViewer.annotationSettings.customData) ?\n                this.pdfViewer.annotationSettings.customData : this.pdfViewer.inkAnnotationSettings.customData ?\n                this.pdfViewer.inkAnnotationSettings.customData : null;\n            var isPrint = this.pdfViewer.inkAnnotationSettings.isPrint;\n            var allowedInteractions = this.pdfViewer.inkAnnotationSettings.allowedInteractions ?\n                this.pdfViewer.inkAnnotationSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n            var annotationSettings = this.pdfViewer.annotationSettings ? this.pdfViewer.annotationSettings :\n                this.pdfViewer.annotationModule.updateAnnotationSettings(this.pdfViewer.inkAnnotationSettings);\n            annot = {\n                id: 'ink' + this.pdfViewerBase.inkCount, bounds: { x: currentBounds.x, y: currentBounds.y, width: currentBounds.width, height: currentBounds.height }, pageIndex: pageIndex, data: this.outputString, customData: customData,\n                shapeAnnotationType: 'Ink', opacity: opacity, strokeColor: strokeColor, thickness: thickness, annotName: annotationName, comments: [],\n                author: author, subject: subject, notes: '',\n                review: { state: '', stateModel: '', modifiedDate: modifiedDate, author: author },\n                annotationSelectorSettings: this.getSelector('Ink', ''), modifiedDate: modifiedDate, annotationSettings: annotationSettings,\n                isPrint: isPrint, allowedInteractions: allowedInteractions, isCommentLock: false, isLocked: isLock\n            };\n            var annotation = this.pdfViewer.add(annot);\n            var bounds = { left: annot.bounds.x, top: annot.bounds.y, width: annot.bounds.width, height: annot.bounds.height };\n            var settings = {\n                opacity: annot.opacity, strokeColor: annot.strokeColor, thickness: annot.thickness, modifiedDate: annot.modifiedDate,\n                width: annot.bounds.width, height: annot.bounds.height, data: this.outputString\n            };\n            this.pdfViewerBase.inkCount++;\n            var commentsDivid = this.pdfViewer.annotation.stickyNotesAnnotationModule.addComments('ink', (annot.pageIndex + 1), annot.shapeAnnotationType);\n            if (commentsDivid) {\n                document.getElementById(commentsDivid).id = annotationName;\n            }\n            annot.annotName = annotationName;\n            this.pdfViewer.annotation.addAction(pageIndex, null, annotation, 'Addition', '', annotation, annotation);\n            this.pdfViewer.annotationModule.storeAnnotations(pageIndex, annot, '_annotations_ink');\n            this.pdfViewer.fireAnnotationAdd(annot.pageIndex, annot.annotName, 'Ink', bounds, settings);\n            if (this.pdfViewerBase.isInkAdded) {\n                this.outputString = '';\n                this.newObject = [];\n                this.inkPathDataCollection = [];\n            }\n            this.pdfViewerBase.isToolbarInkClicked = false;\n            this.pdfViewer.tool = '';\n        }\n        return annot;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.setAnnotationMode = function () {\n        if (this.pdfViewerBase.isToolbarInkClicked) {\n            this.drawInkAnnotation();\n        }\n        else {\n            this.pdfViewerBase.isToolbarInkClicked = true;\n            this.drawInk();\n        }\n    };\n    InkAnnotation.prototype.saveInkSignature = function () {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_ink');\n        if (this.pdfViewerBase.isStorageExceed) {\n            storeObject = this.pdfViewerBase.annotationStorage[this.pdfViewerBase.documentId + '_annotations_ink'];\n        }\n        var annotations = [];\n        for (var j = 0; j < this.pdfViewerBase.pageCount; j++) {\n            annotations[parseInt(j.toString(), 10)] = [];\n        }\n        if (storeObject && !this.pdfViewer.annotationSettings.skipDownload) {\n            var annotationCollection = JSON.parse(storeObject);\n            for (var i = 0; i < annotationCollection.length; i++) {\n                var newArray = [];\n                var pageAnnotationObject = annotationCollection[parseInt(i.toString(), 10)];\n                if (pageAnnotationObject) {\n                    for (var z = 0; pageAnnotationObject.annotations.length > z; z++) {\n                        this.pdfViewer.annotationModule.updateModifiedDate(pageAnnotationObject.annotations[parseInt(z.toString(), 10)]);\n                        var strokeColorString = pageAnnotationObject.annotations[parseInt(z.toString(), 10)].strokeColor;\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].strokeColor =\n                            JSON.stringify(this.pdfViewerBase.signatureModule.getRgbCode(strokeColorString));\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds =\n                            JSON.stringify(this.pdfViewer.annotation.\n                                getInkBounds(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].bounds, pageAnnotationObject.pageIndex));\n                        var collectionData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.processPathData)(pageAnnotationObject.annotations[parseInt(z.toString(), 10)].data);\n                        var csData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.splitArrayCollection)(collectionData);\n                        pageAnnotationObject.annotations[parseInt(z.toString(), 10)].data = JSON.stringify(csData);\n                    }\n                    newArray = pageAnnotationObject.annotations;\n                }\n                annotations[pageAnnotationObject.pageIndex] = newArray;\n            }\n        }\n        return JSON.stringify(annotations);\n    };\n    /**\n     * @param {number} pageNumber - It describes about the page number value\n     * @param {any} annotationBase - It describes about the annotation base\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.addInCollection = function (pageNumber, annotationBase) {\n        if (annotationBase) {\n            var pageAnnotations = this.getAnnotations(pageNumber, null);\n            if (pageAnnotations) {\n                pageAnnotations.push(annotationBase);\n            }\n            this.manageInkAnnotations(pageAnnotations, pageNumber);\n        }\n    };\n    /**\n     * @private\n     * @param {string} data - data\n     * @returns {any} - points\n     */\n    InkAnnotation.prototype.calculateInkSize = function (data) {\n        var minimumX = -1;\n        var minimumY = -1;\n        var maximumX = -1;\n        var maximumY = -1;\n        var collectionData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.processPathData)(data);\n        var zoomvalue = this.pdfViewerBase.getZoomFactor();\n        for (var k = 0; k < collectionData.length; k++) {\n            var val = collectionData[parseInt(k.toString(), 10)];\n            if (minimumX === -1) {\n                minimumX = (val['x']);\n                maximumX = (val['x']);\n                minimumY = (val['y']);\n                maximumY = (val['y']);\n            }\n            else {\n                var point1 = (val['x']);\n                var point2 = (val['y']);\n                if (minimumX >= point1) {\n                    minimumX = point1;\n                }\n                if (minimumY >= point2) {\n                    minimumY = point2;\n                }\n                if (maximumX <= point1) {\n                    maximumX = point1;\n                }\n                if (maximumY <= point2) {\n                    maximumY = point2;\n                }\n            }\n        }\n        var newdifferenceX = maximumX - minimumX;\n        var newdifferenceY = maximumY - minimumY;\n        return { x: (minimumX / zoomvalue), y: (minimumY / zoomvalue),\n            width: (newdifferenceX / zoomvalue), height: (newdifferenceY / zoomvalue) };\n    };\n    /**\n     * @param {any} annotationCollection - It describes about the annotation collection\n     * @param {number} pageIndex - page index value\n     * @param {boolean} isImport - It ensures whether the isImport is true or not\n     * @param {boolean} isAnnotOrderAction - It ensures whether the isAnnotOrderAction is true or not\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.renderExistingInkSignature = function (annotationCollection, pageIndex, isImport, isAnnotOrderAction) {\n        var annot;\n        var isinkAnnotationAdded = false;\n        if (!isImport) {\n            for (var p = 0; p < this.inkAnnotationindex.length; p++) {\n                if (this.inkAnnotationindex[parseInt(p.toString(), 10)] === pageIndex) {\n                    isinkAnnotationAdded = true;\n                    break;\n                }\n            }\n        }\n        if (annotationCollection && (!isinkAnnotationAdded || isAnnotOrderAction)) {\n            if (annotationCollection.length > 0 && this.inkAnnotationindex.indexOf(pageIndex) === -1) {\n                this.inkAnnotationindex.push(pageIndex);\n            }\n            for (var n = 0; n < annotationCollection.length; n++) {\n                var currentAnnotation = annotationCollection[parseInt(n.toString(), 10)];\n                if (currentAnnotation) {\n                    var data = currentAnnotation.PathData;\n                    if (isImport && data) {\n                        if (typeof (data) === 'object' && data.length > 1) {\n                            data = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.getPathString)(data);\n                        }\n                        else {\n                            if (!(currentAnnotation.IsPathData || (data.split('command').length <= 1))) {\n                                data = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.getPathString)(JSON.parse(data));\n                            }\n                        }\n                    }\n                    this.outputString = data;\n                    var calculateInkPosition = this.calculateInkSize(this.outputString);\n                    this.outputString = '';\n                    var rectDiff = 0;\n                    var rectDifference = 1;\n                    var bounds = currentAnnotation.Bounds;\n                    if (calculateInkPosition) {\n                        if (calculateInkPosition.height < 1) {\n                            rectDiff = bounds.Height ? bounds.Height : bounds.height;\n                            rectDifference = bounds.Height ? bounds.Height : bounds.height;\n                        }\n                        else if (calculateInkPosition.width < 1) {\n                            rectDiff = bounds.Width ? bounds.Width : bounds.width;\n                            rectDifference = bounds.Width ? bounds.Width : bounds.width;\n                        }\n                    }\n                    var currentLeft = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(bounds.X) ? bounds.X + (rectDiff / 2) : bounds.x + (rectDiff / 2);\n                    var currentTop = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(bounds.Y) ? bounds.Y + (rectDiff / 2) : bounds.y + (rectDiff / 2);\n                    var currentWidth = bounds.Width ? bounds.Width - (rectDifference - 1) : bounds.width - (rectDifference - 1);\n                    var currentHeight = bounds.Height ? bounds.Height - (rectDifference - 1) :\n                        bounds.height - (rectDifference - 1);\n                    var isLock = currentAnnotation.AnnotationSettings ? currentAnnotation.AnnotationSettings.isLock : false;\n                    var selectorSettings = currentAnnotation.AnnotationSelectorSettings ? typeof (currentAnnotation.AnnotationSelectorSettings) === 'string' ? JSON.parse(currentAnnotation.AnnotationSelectorSettings) : currentAnnotation.AnnotationSelectorSettings : this.getSelector(currentAnnotation, 'Ink');\n                    var customData = this.pdfViewer.annotation.getCustomData(currentAnnotation);\n                    var isPrint = true;\n                    if (currentAnnotation.AnnotationSettings) {\n                        isPrint = currentAnnotation.AnnotationSettings.isPrint;\n                    }\n                    else {\n                        isPrint = this.pdfViewer.inkAnnotationSettings.isPrint;\n                    }\n                    isPrint = !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(currentAnnotation.IsPrint) ? currentAnnotation.IsPrint : true;\n                    if (currentAnnotation.IsLocked) {\n                        isLock = currentAnnotation.IsLocked;\n                    }\n                    if (currentAnnotation.Subject === 'Highlight' && currentAnnotation.Opacity === 1) {\n                        currentAnnotation.Opacity = currentAnnotation.Opacity / 2;\n                    }\n                    currentAnnotation.allowedInteractions = currentAnnotation.AllowedInteractions ?\n                        currentAnnotation.AllowedInteractions : this.pdfViewer.annotationModule.\n                        updateAnnotationAllowedInteractions(currentAnnotation);\n                    currentAnnotation.AnnotationSettings = currentAnnotation.AnnotationSettings ?\n                        currentAnnotation.AnnotationSettings : this.pdfViewer.annotationModule.updateAnnotationSettings(currentAnnotation);\n                    annot = {\n                        id: 'ink' + this.pdfViewerBase.inkCount, bounds: { x: currentLeft, y: currentTop, width: currentWidth, height: currentHeight }, pageIndex: pageIndex, data: data,\n                        shapeAnnotationType: 'Ink', opacity: currentAnnotation.Opacity, strokeColor: currentAnnotation.StrokeColor, thickness: currentAnnotation.Thickness, annotName: currentAnnotation.AnnotName,\n                        comments: this.pdfViewer.annotationModule.\n                            getAnnotationComments(currentAnnotation.Comments, currentAnnotation, currentAnnotation.Author),\n                        author: currentAnnotation.Author, allowedInteractions: currentAnnotation.allowedInteractions,\n                        subject: currentAnnotation.Subject, modifiedDate: currentAnnotation.ModifiedDate,\n                        review: { state: '', stateModel: '', modifiedDate: currentAnnotation.ModifiedDate, author: currentAnnotation.Author }, notes: currentAnnotation.Note, annotationSettings: currentAnnotation.AnnotationSettings,\n                        annotationSelectorSettings: selectorSettings, customData: customData, isPrint: isPrint,\n                        isCommentLock: currentAnnotation.IsCommentLock\n                    };\n                    this.pdfViewer.add(annot);\n                    var canvasPageIndex = currentAnnotation.pageIndex ? currentAnnotation.pageIndex : currentAnnotation.PageNumber;\n                    var canvass = this.pdfViewerBase.getAnnotationCanvas('_annotationCanvas_', canvasPageIndex);\n                    this.pdfViewer.renderDrawing(canvass, annot.pageIndex);\n                    this.pdfViewer.annotationModule.storeAnnotations(annot.pageIndex, annot, '_annotations_ink');\n                    if (this.isAddAnnotationProgramatically) {\n                        var settings = {\n                            opacity: annot.opacity, strokeColor: annot.strokeColor, thickness: annot.thickness,\n                            modifiedDate: annot.modifiedDate,\n                            width: annot.bounds.width, height: annot.bounds.height, data: this.outputString\n                        };\n                        this.pdfViewer.fireAnnotationAdd(annot.pageIndex, annot.annotName, 'Ink', bounds, settings);\n                    }\n                    this.pdfViewerBase.currentSignatureAnnot = null;\n                    this.pdfViewerBase.signatureCount++;\n                    this.pdfViewerBase.inkCount++;\n                    if (this.pdfViewerBase.navigationPane && this.pdfViewerBase.navigationPane.annotationMenuObj &&\n                        this.pdfViewer.isSignatureEditable) {\n                        this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export Annotations')], true);\n                        this.pdfViewerBase.navigationPane.annotationMenuObj.enableItems([this.pdfViewer.localeObj.getConstant('Export XFDF')], true);\n                    }\n                }\n            }\n        }\n    };\n    // To save the imported annotations while downloading or exporting for the page above 10 without a scroll (EJ2-63924)\n    /**\n     * @param {any} annotation - This is annotation\n     * @param {number} pageNumber - This is page number\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.saveImportedInkAnnotation = function (annotation, pageNumber) {\n        var annotationObject = null;\n        var currentBounds = annotation.Bounds;\n        var bounds = { x: currentBounds.X, y: currentBounds.Y, width: currentBounds.Width, height: currentBounds.Height };\n        var allowedInteractions = this.pdfViewer.annotationModule.updateAnnotationAllowedInteractions(annotation);\n        var customData = this.pdfViewer.annotation.getCustomData(annotation);\n        var comments = this.pdfViewer.annotationModule.getAnnotationComments(annotation.Comments, annotation, annotation.Author);\n        var review = { state: annotation.State, stateModel: annotation.StateModel,\n            modifiedDate: annotation.ModifiedDate, author: annotation.Author };\n        var annotationSettings = annotation.AnnotationSettings ? annotation.AnnotationSettings :\n            this.pdfViewer.annotationModule.updateAnnotationSettings(annotation);\n        var annotationSelectorSettings = this.getSettings(annotation);\n        var data = annotation.PathData;\n        if (typeof (data) === 'object' && data.length > 1) {\n            data = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.getPathString)(data);\n        }\n        else {\n            if (!annotation.IsPathData && data.split('command').length > 1) {\n                data = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.getPathString)(JSON.parse(data));\n            }\n        }\n        annotationObject = {\n            allowedInteractions: allowedInteractions, annotName: annotation.AnnotName,\n            annotationSelectorSettings: annotationSelectorSettings,\n            annotationSettings: annotationSettings, author: annotation.Author, bounds: bounds,\n            customData: customData, comments: comments, data: data,\n            id: 'Ink', isCommentLock: annotation.IsCommentLock, isLocked: annotation.IsLocked, isPrint: annotation.IsPrint, modifiedDate: annotation.ModifiedDate,\n            note: annotation.Note, opacity: annotation.Opacity, pageIndex: pageNumber, review: review,\n            shapeAnnotationType: annotation.AnnotationType,\n            strokeColor: annotation.StrokeColor, subject: annotation.Subject, thickness: annotation.Thickness\n        };\n        this.pdfViewer.annotationModule.storeAnnotations(pageNumber, annotationObject, '_annotations_ink');\n    };\n    // To get the annotation selector settings\n    InkAnnotation.prototype.getSettings = function (annotation) {\n        var selector = this.pdfViewer.annotationSelectorSettings;\n        if (annotation.AnnotationSelectorSettings) {\n            selector = annotation.AnnotationSelectorSettings;\n        }\n        else {\n            selector = this.getSelector(annotation.ShapeAnnotationType, annotation.Subject);\n        }\n        return selector;\n    };\n    /**\n     * @param {number} pageNumber - It describes about the page number value\n     * @param {any} annotations - It describes about the annotations\n     * @private\n     * @returns {void}\n     */\n    InkAnnotation.prototype.storeInkSignatureData = function (pageNumber, annotations) {\n        this.pdfViewer.annotation.addAction(annotations.pageIndex, null, annotations, 'Addition', '', annotations, annotations);\n        var annotation = null;\n        var left = annotations.bounds.left ? annotations.bounds.left : annotations.bounds.x;\n        var top = annotations.bounds.top ? annotations.bounds.top : annotations.bounds.y;\n        if (annotations.wrapper && annotations.wrapper.bounds) {\n            left = annotations.wrapper.bounds.left;\n            top = annotations.wrapper.bounds.top;\n        }\n        annotation = {\n            id: annotations.id, bounds: { x: left, y: top, width: annotations.bounds.width, height: annotations.bounds.height },\n            shapeAnnotationType: 'Ink', opacity: annotations.opacity, thickness: annotations.thickness, strokeColor: annotations.strokeColor, pageIndex: annotations.pageIndex, data: annotations.data,\n            annotName: annotations.annotName,\n            comments: annotations.comments, author: annotations.author, subject: annotations.subject,\n            modifiedDate: annotations.modifiedDate,\n            review: { state: '', stateModel: '', modifiedDate: annotations.modifiedDate, author: annotations.author }, notes: annotations.notes,\n            annotationSelectorSettings: this.getSelector(annotations, 'Ink'), isCommentLock: annotations.isCommentLock\n        };\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_ink');\n        var index = 0;\n        if (!storeObject) {\n            var shapeAnnotation = { pageIndex: pageNumber, annotations: [] };\n            shapeAnnotation.annotations.push(annotation);\n            index = shapeAnnotation.annotations.indexOf(annotation);\n            var annotationCollection = [];\n            annotationCollection.push(shapeAnnotation);\n            var annotationStringified = JSON.stringify(annotationCollection);\n            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_ink', annotationStringified);\n        }\n        else {\n            var annotObject = JSON.parse(storeObject);\n            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_ink');\n            var pageIndex = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageNumber);\n            if (pageIndex != null && annotObject[parseInt(pageIndex.toString(), 10)]) {\n                annotObject[parseInt(pageIndex.toString(), 10)].annotations.push(annotation);\n                index = annotObject[parseInt(pageIndex.toString(), 10)].annotations.indexOf(annotation);\n            }\n            else {\n                var markupAnnotation = { pageIndex: pageNumber, annotations: [] };\n                markupAnnotation.annotations.push(annotation);\n                index = markupAnnotation.annotations.indexOf(annotation);\n                annotObject.push(markupAnnotation);\n            }\n            var annotationStringified = JSON.stringify(annotObject);\n            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_ink', annotationStringified);\n        }\n    };\n    InkAnnotation.prototype.getSelector = function (type, subject) {\n        var selector = this.pdfViewer.annotationSelectorSettings;\n        if ((type === 'Ink' || subject === 'Ink') && this.pdfViewer.inkAnnotationSettings.annotationSelectorSettings) {\n            selector = this.pdfViewer.inkAnnotationSettings.annotationSelectorSettings;\n            this.pdfViewerBase.updateSelectorSettings(selector);\n        }\n        return selector;\n    };\n    InkAnnotation.prototype.getAnnotations = function (pageIndex, shapeAnnotations) {\n        var annotationCollection;\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_ink');\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageIndex);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotationCollection = annotObject[parseInt(index.toString(), 10)].annotations;\n            }\n            else {\n                annotationCollection = shapeAnnotations;\n            }\n        }\n        else {\n            annotationCollection = shapeAnnotations;\n        }\n        return annotationCollection;\n    };\n    /**\n     * @param {string} property - It describes about the property\n     * @param {number} pageNumber - It describes about the page number\n     * @param {any} annotationBase - It is about the annotation base\n     * @private\n     * @returns {any} - any\n     */\n    InkAnnotation.prototype.modifySignatureInkCollection = function (property, pageNumber, annotationBase) {\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(annotationBase.formFieldAnnotationType) && annotationBase.formFieldAnnotationType !== '') {\n            this.pdfViewer.annotationModule.isFormFieldShape = true;\n        }\n        else {\n            this.pdfViewer.annotationModule.isFormFieldShape = false;\n        }\n        this.pdfViewerBase.updateDocumentEditedProperty(true);\n        var currentAnnotObject = null;\n        var pageAnnotations = this.getAnnotations(pageNumber, null);\n        if (pageAnnotations != null && annotationBase) {\n            for (var i = 0; i < pageAnnotations.length; i++) {\n                if (annotationBase.id === pageAnnotations[parseInt(i.toString(), 10)].id) {\n                    if (property === 'bounds') {\n                        this.pdfViewerBase.isBounds =\n                            this.pdfViewerBase.boundsCalculation(pageAnnotations[parseInt(i.toString(), 10)].bounds, annotationBase.wrapper.bounds);\n                        if (this.pdfViewerBase.isBounds) {\n                            pageAnnotations[parseInt(i.toString(), 10)].bounds = {\n                                x: annotationBase.wrapper.bounds.left,\n                                y: annotationBase.wrapper.bounds.top, width: annotationBase.bounds.width,\n                                height: annotationBase.bounds.height\n                            };\n                        }\n                    }\n                    else if (property === 'stroke') {\n                        pageAnnotations[parseInt(i.toString(), 10)].strokeColor = annotationBase.wrapper.children[0].style.strokeColor;\n                    }\n                    else if (property === 'opacity') {\n                        pageAnnotations[parseInt(i.toString(), 10)].opacity = annotationBase.wrapper.children[0].style.opacity;\n                    }\n                    else if (property === 'thickness') {\n                        pageAnnotations[parseInt(i.toString(), 10)].thickness = annotationBase.wrapper.children[0].style.strokeWidth;\n                    }\n                    else if (property === 'notes') {\n                        pageAnnotations[parseInt(i.toString(), 10)].notes = annotationBase.notes;\n                    }\n                    else if (property === 'delete') {\n                        currentAnnotObject = pageAnnotations.splice(i, 1)[0];\n                        break;\n                    }\n                    if (this.pdfViewerBase.isBounds) {\n                        pageAnnotations[parseInt(i.toString(), 10)].modifiedDate =\n                            this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n                    }\n                    this.pdfViewer.annotationModule.storeAnnotationCollections(pageAnnotations[parseInt(i.toString(), 10)], pageNumber);\n                }\n            }\n            this.manageInkAnnotations(pageAnnotations, pageNumber);\n        }\n        return currentAnnotObject;\n    };\n    InkAnnotation.prototype.manageInkAnnotations = function (pageAnnotations, pageNumber) {\n        var storeObject = _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.getItem(this.pdfViewerBase.documentId + '_annotations_ink');\n        if (storeObject) {\n            var annotObject = JSON.parse(storeObject);\n            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.removeItem(this.pdfViewerBase.documentId + '_annotations_ink');\n            var index = this.pdfViewer.annotationModule.getPageCollection(annotObject, pageNumber);\n            if (index != null && annotObject[parseInt(index.toString(), 10)]) {\n                annotObject[parseInt(index.toString(), 10)].annotations = pageAnnotations;\n            }\n            var annotationStringified = JSON.stringify(annotObject);\n            _index__WEBPACK_IMPORTED_MODULE_0__.PdfViewerBase.sessionStorageManager.setItem(this.pdfViewerBase.documentId + '_annotations_ink', annotationStringified);\n        }\n    };\n    /**\n     * @param {any} currentAnnotation - It describes about the current annotation\n     * @param {number} pageIndex - It describes about the page index value\n     * @param {boolean} isImport - It ensures whether the isImport is true or not\n     * @private\n     * @returns {any} - any\n     */\n    InkAnnotation.prototype.updateInkCollections = function (currentAnnotation, pageIndex, isImport) {\n        var annot;\n        if (currentAnnotation) {\n            var bounds = currentAnnotation.Bounds;\n            var currentLeft = (bounds.X);\n            var currentTop = (bounds.Y);\n            var currentWidth = (bounds.Width);\n            var currentHeight = (bounds.Height);\n            var customData = currentAnnotation.customData;\n            var isPrint = currentAnnotation.isPrint;\n            currentAnnotation.AllowedInteractions = currentAnnotation.AllowedInteractions ?\n                currentAnnotation.AllowedInteractions : this.pdfViewer.annotationModule.\n                updateAnnotationAllowedInteractions(currentAnnotation);\n            currentAnnotation.AnnotationSettings = currentAnnotation.AnnotationSettings ?\n                currentAnnotation.AnnotationSettings : this.pdfViewer.inkAnnotationSettings ?\n                this.pdfViewer.inkAnnotationSettings : this.pdfViewer.annotationSettings;\n            if (currentAnnotation.IsLocked) {\n                currentAnnotation.AnnotationSettings.isLock = currentAnnotation.IsLocked;\n            }\n            var data = currentAnnotation.PathData;\n            if (isImport) {\n                data = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.getPathString)(JSON.parse(currentAnnotation.PathData));\n            }\n            annot = {\n                id: 'ink' + this.pdfViewerBase.signatureCount, bounds: { x: currentLeft, y: currentTop, width: currentWidth, height: currentHeight }, pageIndex: pageIndex, data: data,\n                shapeAnnotationType: 'Ink', opacity: currentAnnotation.Opacity, strokeColor: currentAnnotation.StrokeColor, thickness: currentAnnotation.Thickness, annotationId: currentAnnotation.AnnotName,\n                customData: customData, comments: this.pdfViewer.annotationModule.\n                    getAnnotationComments(currentAnnotation.Comments, currentAnnotation, currentAnnotation.Author),\n                author: currentAnnotation.Author, allowedInteractions: currentAnnotation.AllowedInteractions,\n                subject: currentAnnotation.Subject, modifiedDate: currentAnnotation.ModifiedDate,\n                review: { state: '', stateModel: '', modifiedDate: currentAnnotation.ModifiedDate, author: currentAnnotation.Author }, notes: currentAnnotation.Note, isPrint: isPrint, isCommentLock: currentAnnotation.IsCommentLock, annotationSettings: currentAnnotation.AnnotationSettings, isLocked: currentAnnotation.AnnotationSettings.isLock\n            };\n            return annot;\n        }\n    };\n    /**\n     * This method used to add annotations with using program.\n     *\n     * @param {InkAnnotationSettings} annotationObject - It describes type of annotation object\n     * @param {IPoint} offset - It describes about the annotation bounds or location\n     * @param {number} pageNumber - It describes about the annotation page number\n     * @returns {object} - onject\n     * @private\n     */\n    InkAnnotation.prototype.updateAddAnnotationDetails = function (annotationObject, offset, pageNumber) {\n        //Creating new object if annotationObject is null\n        if (!annotationObject) {\n            annotationObject = { offset: { x: 10, y: 10 }, pageNumber: 0, width: undefined, height: undefined };\n            offset = annotationObject.offset;\n        }\n        else if (!annotationObject.offset) {\n            offset = { x: 10, y: 10 };\n        }\n        else {\n            offset = annotationObject.offset;\n        }\n        //Creating the CurrentDate and Annotation name\n        var currentDateString = this.pdfViewer.annotation.stickyNotesAnnotationModule.getDateAndTime();\n        var annotationName = this.pdfViewer.annotation.createGUID();\n        //Creating annotation settings\n        var annotationSelectorSettings = this.pdfViewer.inkAnnotationSettings.annotationSelectorSettings;\n        this.pdfViewerBase.updateSelectorSettings(annotationSelectorSettings);\n        var annotationSettings = this.pdfViewer.annotationModule.updateSettings(this.pdfViewer.inkAnnotationSettings);\n        annotationObject.author = annotationObject.author ? annotationObject.author : this.pdfViewer.annotationModule.updateAnnotationAuthor('ink', annotationSettings.AnnotationType);\n        var allowedInteractions = this.pdfViewer.inkAnnotationSettings.allowedInteractions ?\n            this.pdfViewer.inkAnnotationSettings.allowedInteractions : this.pdfViewer.annotationSettings.allowedInteractions;\n        annotationSettings.isLock = annotationObject.isLock ? annotationObject.isLock : annotationSettings.isLock;\n        annotationObject.width = annotationObject.width ? annotationObject.width : 150;\n        annotationObject.height = annotationObject.height ? annotationObject.height : 60;\n        var pathData = annotationObject.path ? annotationObject.path : '';\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(pathData)) {\n            // Check whether the given path of the ink annotation is starts with Move path or Line path.\n            if (pathData[0] === 'M' || pathData[0] === 'L') {\n                var collectionData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.processPathData)(pathData);\n                var csData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.splitArrayCollection)(collectionData);\n                pathData = JSON.stringify(csData);\n            }\n            else {\n                pathData = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_1__.getPathString)(JSON.parse(pathData));\n            }\n        }\n        annotationObject.path = pathData;\n        //Creating Annotation objects with it's proper properties\n        var signatureInkAnnotation = [];\n        var ink = {\n            AllowedInteractions: annotationObject.allowedInteractions ? annotationObject.allowedInteractions : allowedInteractions,\n            AnnotName: annotationName,\n            AnnotType: 'ink',\n            AnnotationFlags: null,\n            AnnotationSelectorSettings: annotationObject.annotationSelectorSettings ?\n                annotationObject.annotationSelectorSettings : annotationSelectorSettings,\n            AnnotationSettings: annotationSettings,\n            AnnotationType: 'Ink',\n            Author: annotationObject.author ? annotationObject.author : 'Guest',\n            Bounds: { X: offset.x, Y: offset.y, Width: annotationObject.width, Height: annotationObject.height,\n                Left: offset.x, Top: offset.y, Location: { X: offset.x, Y: offset.y },\n                Size: { Height: annotationObject.height, IsEmpty: false, Width: annotationObject.width } },\n            Comments: null,\n            CreatedDate: currentDateString,\n            CustomData: annotationObject.customData ? annotationObject.customData : null,\n            ExistingCustomData: null,\n            IsCommentLock: false,\n            IsLock: annotationObject.isLock ? annotationObject.isLock : false,\n            IsPrint: !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(annotationObject.isPrint) ? annotationObject.isPrint : true,\n            ModifiedDate: '',\n            Note: '',\n            Opacity: annotationObject.opacity ? annotationObject.opacity : 1,\n            PathData: annotationObject.path,\n            PageNumber: pageNumber,\n            State: '',\n            StateModel: '',\n            StrokeColor: annotationObject.strokeColor ? annotationObject.strokeColor : 'rgba(255,0,0,1)',\n            SubType: null,\n            Subject: annotationObject.subject ? annotationObject.subject : 'Ink',\n            Type: null,\n            Thickness: annotationObject.thickness ? annotationObject.thickness : 1\n        };\n        //Adding the annotation object to an array and return it\n        signatureInkAnnotation[0] = ink;\n        return { signatureInkAnnotation: signatureInkAnnotation };\n    };\n    return InkAnnotation;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/annotation/ink-annotation.js?");

/***/ })

}]);