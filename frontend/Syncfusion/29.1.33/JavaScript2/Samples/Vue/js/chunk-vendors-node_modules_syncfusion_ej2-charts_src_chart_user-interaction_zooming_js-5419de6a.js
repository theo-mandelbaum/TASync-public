"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_user-interaction_zooming_js-5419de6a"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/zooming.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/zooming.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Zoom: () => (/* binding */ Zoom)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _zooming_toolkit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zooming-toolkit */ \"./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/zooming-toolkit.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\n\n\n\n\n\n\n/**\n * The `Zooming` module handles zooming functionality for charts.\n */\nvar Zoom = /** @class */ (function () {\n    /**\n     * Constructor for Zooming module.\n     *\n     * @private\n     */\n    function Zoom(chart) {\n        this.zoomCompleteEvtCollection = [];\n        /** @private */\n        this.startPanning = false;\n        this.chart = chart;\n        this.isPointer = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isPointer;\n        this.browserName = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.info.name;\n        this.wheelEvent = this.browserName === 'mozilla' ? (this.isPointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';\n        this.cancelEvent = this.isPointer ? 'pointerleave' : 'mouseleave';\n        this.addEventListener();\n        this.isDevice = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isDevice;\n        var zooming = chart.zoomSettings;\n        this.toolkit = new _zooming_toolkit__WEBPACK_IMPORTED_MODULE_3__.Toolkit(chart);\n        this.zooming = zooming;\n        this.elementId = chart.element.id;\n        this.zoomingRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, 0, 0);\n        this.zoomAxes = [];\n        this.zoomkitOpacity = 1;\n        this.isIOS = _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIos || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIos7;\n        this.isZoomed = this.performedUI = this.zooming.enablePan ||\n            ((this.chart.primaryXAxis.zoomFactor < 1 && this.chart.primaryXAxis.zoomPosition > 0) ||\n                (this.chart.primaryYAxis.zoomFactor < 1 && this.chart.primaryYAxis.zoomPosition > 0) || this.isAxisZoomed(this.chart.axes));\n        if (zooming.enableScrollbar) {\n            chart.scrollElement = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', { id: chart.element.id + '_scrollElement' });\n        }\n    }\n    /**\n     * Renders the zooming functionality for the chart.\n     *\n     * @param {PointerEvent | TouchEvent} e - The pointer or touch event.\n     * @param {Chart} chart - The chart instance.\n     * @param {boolean} isTouch - Indicates whether the event is a touch event.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.renderZooming = function (e, chart, isTouch) {\n        this.calculateZoomAxesRange(chart);\n        if (this.zooming.enableSelectionZooming && (!isTouch\n            || (chart.isDoubleTap && this.touchStartList.length === 1)) && (!this.isPanning || chart.isDoubleTap)) {\n            this.isPanning = this.isDevice ? true : this.isPanning;\n            this.performedUI = true;\n            this.drawZoomingRectangle(chart);\n        }\n        else if (this.isPanning && chart.isChartDrag) {\n            if (!isTouch || (isTouch && this.touchStartList.length === 1)) {\n                this.pinchTarget = isTouch ? e.target : null;\n                this.doPan(chart, chart.axisCollections);\n            }\n        }\n    };\n    // Zooming rectangle drawn here\n    Zoom.prototype.drawZoomingRectangle = function (chart) {\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var startLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(chart.previousMouseMoveX, chart.previousMouseMoveY);\n        var endLocation = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.ChartLocation(chart.mouseX, chart.mouseY);\n        var rect = this.zoomingRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getRectLocation)(startLocation, endLocation, areaBounds);\n        if (rect.width > 0 && rect.height > 0) {\n            this.isZoomed = true;\n            chart.disableTrackTooltip = true;\n            chart.svgObject.setAttribute('cursor', 'crosshair');\n            if (this.zooming.mode === 'X') {\n                rect.height = areaBounds.height;\n                rect.y = areaBounds.y;\n            }\n            else if (this.zooming.mode === 'Y') {\n                rect.width = areaBounds.width;\n                rect.x = areaBounds.x;\n            }\n            if (chart.tooltipModule) {\n                chart.tooltipModule.removeTooltip(0);\n                for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n                    var series = _a[_i];\n                    if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series) && (series.marker.visible || chart.tooltip.shared)) {\n                        chart.markerRender.removeHighlightedMarker(series, null, true);\n                    }\n                }\n            }\n            if (chart.crosshairModule) {\n                chart.crosshairModule.removeCrosshair(0);\n            }\n            var svg = chart.svgObject;\n            if (this.chart.enableCanvas) {\n                var secondaryElement = document.getElementById(this.chart.element.id + '_Secondary_Element');\n                svg = this.chart.svgRenderer.createSvg({\n                    id: this.chart.element.id + '_zoomRect_svg',\n                    width: this.chart.availableSize.width,\n                    height: this.chart.availableSize.height\n                });\n                svg.style.cssText = 'position: absolute; display:block; pointer-events: none';\n                secondaryElement.appendChild(svg);\n            }\n            svg.appendChild(chart.svgRenderer.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.RectOption(this.elementId + '_ZoomArea', chart.themeStyle.selectionRectFill, { color: chart.themeStyle.selectionRectStroke, width: 1 }, 1, rect, 0, 0, '', '3')));\n        }\n    };\n    // Panning performed here\n    Zoom.prototype.doPan = function (chart, axes, xDifference, yDifference) {\n        var _this = this;\n        if (xDifference === void 0) { xDifference = 0; }\n        if (yDifference === void 0) { yDifference = 0; }\n        if (chart.startMove && chart.crosshair.enable) {\n            return null;\n        }\n        var currentScale;\n        var offset;\n        this.isZoomed = true;\n        this.startPanning = true;\n        this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;\n        chart.delayRedraw = true;\n        this.zoomCompleteEvtCollection = [];\n        chart.disableTrackTooltip = true;\n        var argsData;\n        var zoomedAxisCollection = [];\n        for (var _i = 0, _a = axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            argsData = {\n                cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,\n                previousZoomPosition: axis.zoomPosition, currentZoomFactor: axis.zoomFactor,\n                currentZoomPosition: axis.zoomPosition, previousVisibleRange: axis.visibleRange,\n                currentVisibleRange: null\n            };\n            currentScale = Math.max(1 / (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minMax)(axis.zoomFactor, 0, 1), 1);\n            if (axis.orientation === 'Horizontal') {\n                offset = (xDifference !== 0 ? xDifference : (chart.previousMouseMoveX - chart.mouseX)) / axis.rect.width / currentScale;\n                argsData.currentZoomPosition = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minMax)(axis.zoomPosition + offset, 0, (1 - axis.zoomFactor));\n            }\n            else {\n                offset = (yDifference !== 0 ? yDifference : (chart.previousMouseMoveY - chart.mouseY)) / axis.rect.height / currentScale;\n                argsData.currentZoomPosition = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minMax)(axis.zoomPosition - offset, 0, (1 - axis.zoomFactor));\n            }\n            if (!argsData.cancel) {\n                axis.zoomFactor = argsData.currentZoomFactor;\n                axis.zoomPosition = argsData.currentZoomPosition;\n                this.zoomCompleteEvtCollection.push(argsData);\n            }\n            zoomedAxisCollection.push({\n                zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,\n                axisRange: axis.visibleRange\n            });\n        }\n        if (chart.tooltipModule) {\n            var tooltipElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.element.id + '_tooltip');\n            if (tooltipElement) {\n                tooltipElement.remove();\n            }\n            for (var _b = 0, _c = chart.visibleSeries; _b < _c.length; _b++) {\n                var series = _c[_b];\n                if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series) && (series.marker.visible || chart.tooltip.shared || series.type === 'Scatter' || series.type === 'Bubble')) {\n                    chart.markerRender.removeHighlightedMarker(series, null, true);\n                }\n            }\n        }\n        var zoomingEventArgs = { cancel: false, axisCollection: zoomedAxisCollection, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming };\n        if (!zoomingEventArgs.cancel && this.chart.isBlazor) {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming, zoomingEventArgs, function () {\n                if (zoomingEventArgs.cancel) {\n                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);\n                }\n                else {\n                    _this.performDefferedZoom(chart);\n                }\n            });\n        }\n        else {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming, zoomingEventArgs, function () {\n                if (zoomingEventArgs.cancel) {\n                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);\n                }\n                else {\n                    _this.performDefferedZoom(chart);\n                    _this.redrawOnZooming(chart, false);\n                }\n            });\n        }\n    };\n    Zoom.prototype.performDefferedZoom = function (chart) {\n        var translateX;\n        var translateY;\n        if (this.zooming.enableDeferredZooming) {\n            translateX = chart.mouseX - chart.mouseDownX;\n            translateY = chart.mouseY - chart.mouseDownY;\n            switch (this.zooming.mode) {\n                case 'X':\n                    translateY = 0;\n                    break;\n                case 'Y':\n                    translateX = 0;\n                    break;\n            }\n            this.setTransform(translateX, translateY, null, null, chart, false);\n            this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);\n            if (chart.enableCanvas) {\n                this.performZoomRedraw(chart);\n            }\n        }\n        else {\n            this.performZoomRedraw(chart);\n        }\n        chart.previousMouseMoveX = chart.mouseX;\n        chart.previousMouseMoveY = chart.mouseY;\n    };\n    /**\n     * Redraw the chart on zooming.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.performZoomRedraw = function (chart) {\n        var rect = this.zoomingRect;\n        chart.animateSeries = false;\n        if (this.isZoomed) {\n            if (rect.width > 0 && rect.height > 0) {\n                this.performedUI = true;\n                chart.svgObject.setAttribute('cursor', 'auto');\n                this.doZoom(chart, chart.axisCollections, chart.chartAxisLayoutPanel.seriesClipRect);\n                chart.isDoubleTap = false;\n            }\n            else if (chart.disableTrackTooltip) {\n                chart.disableTrackTooltip = false;\n                chart.delayRedraw = false;\n                if (chart.enableCanvas) {\n                    chart.createChartSvg();\n                }\n                else {\n                    var zoomArea = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.element.id + '_ZoomArea');\n                    if (zoomArea) {\n                        zoomArea.remove();\n                    }\n                    var zoomToolBar = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.element.id + '_Zooming_KitCollection');\n                    if (zoomToolBar) {\n                        zoomToolBar.remove();\n                    }\n                    if (chart.tooltipModule) {\n                        if ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.element.id + '_tooltip')) {\n                            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.element.id + '_tooltip').remove();\n                        }\n                        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n                            var series = _a[_i];\n                            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(series) && (series.marker.visible || chart.tooltip.shared || series.type === 'Scatter' || series.type === 'Bubble')) {\n                                chart.markerRender.removeHighlightedMarker(series, null, true);\n                            }\n                        }\n                    }\n                }\n                var chartDuration = chart.duration;\n                if (!(this.isPanning && (chart.isChartDrag || this.startPanning)) && !chart.enableCanvas) {\n                    chart.duration = 600;\n                    chart.redraw = this.zooming.enableAnimation;\n                    chart.zoomRedraw = this.zooming.enableAnimation;\n                }\n                var highlightDataIndexes = [];\n                if (chart.highlightModule && (chart.legendSettings.enableHighlight || chart.highlightMode !== 'None') && chart.highlightModule.highlightDataIndexes) {\n                    highlightDataIndexes = chart.highlightModule.highlightDataIndexes;\n                }\n                // chart.enableCanvas ? chart.createChartSvg() : chart.removeSvg();\n                chart.refreshAxis();\n                chart.refreshBound();\n                if (chart.highlightModule && (chart.legendSettings.enableHighlight || chart.highlightMode !== 'None') && highlightDataIndexes) {\n                    chart.highlightModule.highlightDataIndexes = highlightDataIndexes;\n                }\n                if (!this.isZoomed) {\n                    chart.zoomRedraw = this.zooming.enableAnimation;\n                }\n                this.startPanning = false;\n                chart.redraw = false;\n                chart.duration = chartDuration;\n                if (this.toolkit.isZoomed) {\n                    chart.zoomRedraw = false;\n                    this.toolkit.isZoomed = false;\n                }\n            }\n        }\n    };\n    Zoom.prototype.refreshAxis = function (layout, chart, axes) {\n        var mode = chart.zoomSettings.mode;\n        layout.measureAxis(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(chart.initialClipRect.x, chart.initialClipRect.y, chart.initialClipRect.width, chart.initialClipRect.height));\n        axes.map(function (axis, index) {\n            if (axis.orientation === 'Horizontal' && mode !== 'Y') {\n                layout.drawXAxisLabels(axis, index, null, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n            }\n            if (axis.orientation === 'Vertical' && mode !== 'X') {\n                layout.drawYAxisLabels(axis, index, null, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\n            }\n        });\n    };\n    // Rectangular zoom calculated here performed here\n    Zoom.prototype.doZoom = function (chart, axes, bounds) {\n        var _this = this;\n        var zoomRect = this.zoomingRect;\n        var mode = this.zooming.mode;\n        var argsData;\n        this.isPanning = chart.zoomSettings.enablePan || this.isPanning;\n        var zoomedAxisCollections = [];\n        this.zoomCompleteEvtCollection = [];\n        for (var _i = 0, _a = axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            argsData = {\n                cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.zoomComplete, axis: axis,\n                previousZoomFactor: axis.zoomFactor,\n                previousZoomPosition: axis.zoomPosition,\n                currentZoomFactor: axis.zoomFactor,\n                currentZoomPosition: axis.zoomPosition,\n                previousVisibleRange: axis.visibleRange, currentVisibleRange: null\n            };\n            if (axis.orientation === 'Horizontal') {\n                if (mode !== 'Y') {\n                    argsData.currentZoomPosition += Math.abs((zoomRect.x - bounds.x) / (bounds.width)) * axis.zoomFactor;\n                    argsData.currentZoomFactor *= (zoomRect.width / bounds.width);\n                }\n            }\n            else {\n                if (mode !== 'X') {\n                    argsData.currentZoomPosition += (1 - Math.abs((zoomRect.height + (zoomRect.y - bounds.y)) / (bounds.height)))\n                        * axis.zoomFactor;\n                    argsData.currentZoomFactor *= (zoomRect.height / bounds.height);\n                }\n            }\n            if (parseFloat(argsData.currentZoomFactor.toFixed(3)) <= 0.001) {\n                argsData.currentZoomFactor = argsData.previousZoomFactor;\n                argsData.currentZoomPosition = argsData.previousZoomPosition;\n            }\n            if (!argsData.cancel) {\n                axis.zoomFactor = argsData.currentZoomFactor;\n                axis.zoomPosition = argsData.currentZoomPosition;\n                chart.zoomRedraw = this.zooming.enableAnimation;\n                this.zoomCompleteEvtCollection.push(argsData);\n            }\n            zoomedAxisCollections.push({\n                zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,\n                axisRange: axis.visibleRange\n            });\n        }\n        var onZoomingEventArg = { cancel: false, axisCollection: zoomedAxisCollections, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming };\n        if (!onZoomingEventArg.cancel && this.chart.isBlazor) {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming, onZoomingEventArg, function () {\n                if (onZoomingEventArg.cancel) {\n                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);\n                }\n                else {\n                    _this.zoomingRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, 0, 0);\n                    _this.performZoomRedraw(chart);\n                }\n            });\n        }\n        else {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming, onZoomingEventArg, function () {\n                if (onZoomingEventArg.cancel) {\n                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);\n                }\n                else {\n                    _this.zoomingRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, 0, 0);\n                    _this.redrawOnZooming(chart);\n                }\n            });\n        }\n    };\n    /**\n     * Redraws the chart on zooming.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {boolean} [isRedraw=true] - Indicates whether to redraw the chart.\n     * @param {boolean} [isMouseUp=false] - Indicates whether the mouse button is released.\n     * @returns {void}\n     */\n    Zoom.prototype.redrawOnZooming = function (chart, isRedraw, isMouseUp) {\n        if (isRedraw === void 0) { isRedraw = true; }\n        if (isMouseUp === void 0) { isMouseUp = false; }\n        var zoomCompleteCollection = isMouseUp ? this.toolkit.zoomCompleteEvtCollection :\n            this.zoomCompleteEvtCollection;\n        if (isRedraw) {\n            this.performZoomRedraw(chart);\n        }\n        var argsData;\n        for (var i = 0; i < zoomCompleteCollection.length; i++) {\n            if (!zoomCompleteCollection[i].cancel) {\n                argsData = {\n                    cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.zoomComplete,\n                    axis: chart.axisCollections[i],\n                    previousZoomFactor: zoomCompleteCollection[i].previousZoomFactor,\n                    previousZoomPosition: zoomCompleteCollection[i].previousZoomPosition,\n                    currentZoomFactor: chart.axisCollections[i].zoomFactor,\n                    currentZoomPosition: chart.axisCollections[i].zoomPosition,\n                    currentVisibleRange: chart.axisCollections[i].visibleRange,\n                    previousVisibleRange: zoomCompleteCollection[i].previousVisibleRange\n                };\n                chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.zoomComplete, argsData);\n            }\n        }\n    };\n    /**\n     * Performs mouse wheel zooming on the chart.\n     *\n     * @param {WheelEvent} e - The wheel event.\n     * @param {number} mouseX - The X-coordinate of the mouse pointer.\n     * @param {number} mouseY - The Y-coordinate of the mouse pointer.\n     * @param {Chart} chart - The chart instance.\n     * @param {AxisModel[]} axes - The axes in the chart.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.performMouseWheelZooming = function (e, mouseX, mouseY, chart, axes) {\n        var _this = this;\n        var direction = (this.browserName === 'mozilla' && !this.isPointer) ?\n            -(e.detail) / 3 > 0 ? 1 : -1 : (e['wheelDelta'] > 0 ? 1 : -1);\n        var mode = this.zooming.mode;\n        var origin = 0.5;\n        var cumulative;\n        var zoomFactor;\n        var zoomPosition;\n        this.isZoomed = true;\n        this.calculateZoomAxesRange(chart);\n        chart.disableTrackTooltip = true;\n        this.performedUI = true;\n        this.isPanning = chart.zoomSettings.enablePan || this.isPanning;\n        this.zoomCompleteEvtCollection = [];\n        var argsData;\n        var zoomedAxisCollection = [];\n        for (var _i = 0, _a = axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            argsData = {\n                cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,\n                previousZoomPosition: axis.zoomPosition,\n                currentZoomFactor: axis.zoomFactor,\n                currentZoomPosition: axis.zoomPosition, currentVisibleRange: null,\n                previousVisibleRange: axis.visibleRange\n            };\n            if ((axis.orientation === 'Vertical' && mode !== 'X') ||\n                (axis.orientation === 'Horizontal' && mode !== 'Y')) {\n                cumulative = Math.max(Math.max(1 / (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minMax)(axis.zoomFactor, 0, 1), 1) + (0.25 * direction), 1);\n                cumulative = (cumulative > 50000000000) ? 50000000000 : cumulative;\n                if (cumulative >= 1) {\n                    origin = axis.orientation === 'Horizontal' ? mouseX / axis.rect.width : 1 - (mouseY / axis.rect.height);\n                    origin = origin > 1 ? 1 : origin < 0 ? 0 : origin;\n                    zoomFactor = (cumulative === 1) ? 1 : (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.minMax)((direction > 0 ? 0.9 : 1.1) / cumulative, 0, 1);\n                    zoomPosition = (cumulative === 1) ? 0 : axis.zoomPosition + ((axis.zoomFactor - zoomFactor) * origin);\n                    if (axis.zoomPosition !== zoomPosition || axis.zoomFactor !== zoomFactor) {\n                        zoomFactor = (zoomPosition + zoomFactor) > 1 ? (1 - zoomPosition) : zoomFactor;\n                    }\n                    if (parseFloat(argsData.currentZoomFactor.toFixed(3)) <= 0.001) {\n                        argsData.currentZoomFactor = argsData.previousZoomFactor;\n                        argsData.currentZoomPosition = argsData.previousZoomPosition;\n                    }\n                    else {\n                        argsData.currentZoomFactor = zoomFactor;\n                        argsData.currentZoomPosition = zoomPosition;\n                    }\n                }\n                if (argsData.currentZoomFactor === argsData.previousZoomFactor &&\n                    argsData.currentZoomPosition === argsData.previousZoomPosition) {\n                    chart.disableTrackTooltip = false;\n                }\n                if (!argsData.cancel) {\n                    axis.zoomFactor = argsData.currentZoomFactor;\n                    axis.zoomPosition = argsData.currentZoomPosition;\n                    chart.zoomRedraw = this.zooming.enableAnimation;\n                    this.zoomCompleteEvtCollection.push(argsData);\n                }\n            }\n            zoomedAxisCollection.push({\n                zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,\n                axisRange: axis.visibleRange\n            });\n        }\n        var onZoomingEventArgs = { cancel: false, axisCollection: zoomedAxisCollection, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming };\n        if (!onZoomingEventArgs.cancel && this.chart.isBlazor) {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming, onZoomingEventArgs, function () {\n                if (onZoomingEventArgs.cancel) {\n                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);\n                }\n                else {\n                    _this.performZoomRedraw(chart);\n                }\n            });\n        }\n        else {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming, onZoomingEventArgs, function () {\n                if (onZoomingEventArgs.cancel) {\n                    _this.zoomCancel(axes, _this.zoomCompleteEvtCollection);\n                }\n                else {\n                    _this.redrawOnZooming(chart);\n                }\n            });\n        }\n    };\n    /**\n     * Performs pinch zooming on the chart.\n     *\n     * @param {TouchEvent} e - The touch event.\n     * @param {Chart} chart - The chart instance.\n     * @returns {boolean} - Indicates whether pinch zooming is performed.\n     * @private\n     */\n    Zoom.prototype.performPinchZooming = function (e, chart) {\n        if ((this.zoomingRect.width > 0 && this.zoomingRect.height > 0) || (chart.startMove && chart.crosshair.enable)) {\n            return false;\n        }\n        this.calculateZoomAxesRange(chart);\n        this.isZoomed = true;\n        this.isPanning = true;\n        this.performedUI = true;\n        this.offset = !chart.delayRedraw ? chart.chartAxisLayoutPanel.seriesClipRect : this.offset;\n        chart.delayRedraw = true;\n        chart.disableTrackTooltip = true;\n        var elementOffset = chart.element.getBoundingClientRect();\n        var touchDown = this.touchStartList;\n        var touchMove = this.touchMoveList;\n        var touch0StartX = touchDown[0].pageX - elementOffset.left;\n        var touch0StartY = touchDown[0].pageY - elementOffset.top;\n        var touch0EndX = touchMove[0].pageX - elementOffset.left;\n        var touch0EndY = touchMove[0].pageY - elementOffset.top;\n        var touch1StartX = touchDown[1].pageX - elementOffset.left;\n        var touch1StartY = touchDown[1].pageY - elementOffset.top;\n        var touch1EndX = touchMove[1].pageX - elementOffset.left;\n        var touch1EndY = touchMove[1].pageY - elementOffset.top;\n        var scaleX = Math.abs(touch0EndX - touch1EndX) / Math.abs(touch0StartX - touch1StartX);\n        var scaleY = Math.abs(touch0EndY - touch1EndY) / Math.abs(touch0StartY - touch1StartY);\n        var clipX = ((this.offset.x - touch0EndX) / scaleX) + touch0StartX;\n        var clipY = ((this.offset.y - touch0EndY) / scaleY) + touch0StartY;\n        var pinchRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(clipX, clipY, this.offset.width / scaleX, this.offset.height / scaleY);\n        var translateXValue = (touch0EndX - (scaleX * touch0StartX));\n        var translateYValue = (touch0EndY - (scaleY * touch0StartY));\n        if (!isNaN(scaleX - scaleX) && !isNaN(scaleY - scaleY)) {\n            switch (this.zooming.mode) {\n                case 'XY':\n                    this.setTransform(translateXValue, translateYValue, scaleX, scaleY, chart, true);\n                    break;\n                case 'X':\n                    this.setTransform(translateXValue, 0, scaleX, 1, chart, true);\n                    break;\n                case 'Y':\n                    this.setTransform(0, translateYValue, 1, scaleY, chart, true);\n                    break;\n            }\n        }\n        if (!this.calculatePinchZoomFactor(chart, pinchRect)) {\n            this.refreshAxis(chart.chartAxisLayoutPanel, chart, chart.axisCollections);\n            this.redrawOnZooming(chart, false);\n        }\n        return true;\n    };\n    Zoom.prototype.calculatePinchZoomFactor = function (chart, pinchRect) {\n        var mode = this.zooming.mode;\n        var selectionMin;\n        var selectionMax;\n        var rangeMin;\n        var rangeMax;\n        var value;\n        var axisTrans;\n        var argsData;\n        var currentZF;\n        var currentZP;\n        var zoomedAxisCollection = [];\n        this.zoomCompleteEvtCollection = [];\n        for (var index = 0; index < chart.axisCollections.length; index++) {\n            var axis = chart.axisCollections[index];\n            if ((axis.orientation === 'Horizontal' && mode !== 'Y') ||\n                (axis.orientation === 'Vertical' && mode !== 'X')) {\n                currentZF = axis.zoomFactor;\n                currentZP = axis.zoomPosition;\n                argsData = {\n                    cancel: false, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.zoomComplete, axis: axis, previousZoomFactor: axis.zoomFactor,\n                    previousZoomPosition: axis.zoomPosition, currentZoomFactor: currentZF,\n                    currentZoomPosition: currentZP, previousVisibleRange: axis.visibleRange,\n                    currentVisibleRange: null\n                };\n                if (axis.orientation === 'Horizontal') {\n                    value = pinchRect.x - this.offset.x;\n                    axisTrans = axis.rect.width / this.zoomAxes[index].delta;\n                    rangeMin = value / axisTrans + this.zoomAxes[index].min;\n                    value = pinchRect.x + pinchRect.width - this.offset.x;\n                    rangeMax = value / axisTrans + this.zoomAxes[index].min;\n                }\n                else {\n                    value = pinchRect.y - this.offset.y;\n                    axisTrans = axis.rect.height / this.zoomAxes[index].delta;\n                    rangeMin = (value * -1 + axis.rect.height) / axisTrans + this.zoomAxes[index].min;\n                    value = pinchRect.y + pinchRect.height - this.offset.y;\n                    rangeMax = (value * -1 + axis.rect.height) / axisTrans + this.zoomAxes[index].min;\n                }\n                selectionMin = Math.min(rangeMin, rangeMax);\n                selectionMax = Math.max(rangeMin, rangeMax);\n                currentZP = (selectionMin - this.zoomAxes[index].actualMin) / this.zoomAxes[index].actualDelta;\n                currentZF = (selectionMax - selectionMin) / this.zoomAxes[index].actualDelta;\n                argsData.currentZoomPosition = currentZP < 0 ? 0 : currentZP;\n                argsData.currentZoomFactor = currentZF > 1 ? 1 : (currentZF < 0.03) ? 0.03 : currentZF;\n                if (!argsData.cancel) {\n                    axis.zoomFactor = argsData.currentZoomFactor;\n                    axis.zoomPosition = argsData.currentZoomPosition;\n                    chart.zoomRedraw = this.zooming.enableAnimation;\n                    this.zoomCompleteEvtCollection.push(argsData);\n                }\n                zoomedAxisCollection.push({\n                    zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomFactor, axisName: axis.name,\n                    axisRange: axis.visibleRange\n                });\n            }\n        }\n        var onZoomingEventArgs = { cancel: false, axisCollection: zoomedAxisCollection, name: _common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming };\n        if (!onZoomingEventArgs.cancel) {\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_4__.onZooming, onZoomingEventArgs);\n            if (onZoomingEventArgs.cancel) {\n                this.zoomCancel(chart.axisCollections, this.zoomCompleteEvtCollection);\n                return true;\n            }\n        }\n        return false;\n    };\n    // Series transformation style applied here.\n    Zoom.prototype.setTransform = function (transX, transY, scaleX, scaleY, chart, isPinch) {\n        if (!chart.enableCanvas) {\n            chart.seriesElements.setAttribute('clip-path', 'url(#' + this.elementId + '_ChartAreaClipRect_)');\n        }\n        if (chart.indicatorElements) {\n            chart.indicatorElements.setAttribute('clip-path', 'url(#' + this.elementId + '_ChartAreaClipRect_)');\n        }\n        var translate;\n        var xAxisLoc;\n        var yAxisLoc;\n        var element;\n        if (transX !== null && transY !== null) {\n            for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n                var value = _a[_i];\n                xAxisLoc = chart.requireInvertedAxis ? value.yAxis.rect.x : value.xAxis.rect.x;\n                yAxisLoc = chart.requireInvertedAxis ? value.xAxis.rect.y : value.yAxis.rect.y;\n                translate = 'translate(' + (transX + (isPinch ? (scaleX * xAxisLoc) : xAxisLoc)) +\n                    ',' + (transY + (isPinch ? (scaleY * yAxisLoc) : yAxisLoc)) + ')';\n                translate = (scaleX || scaleY) ? translate + ' scale(' + scaleX + ' ' + scaleY + ')' : translate;\n                if (value.visible) {\n                    if (value.category === 'Indicator') {\n                        value.seriesElement.parentNode.setAttribute('transform', translate);\n                    }\n                    else {\n                        if (!chart.enableCanvas) {\n                            value.seriesElement.setAttribute('transform', translate);\n                        }\n                    }\n                    element = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.element.id + '_Series_' + value.index + '_DataLabelCollections');\n                    if (value.errorBarElement) {\n                        value.errorBarElement.setAttribute('transform', translate);\n                    }\n                    if (value.symbolElement) {\n                        value.symbolElement.setAttribute('transform', translate);\n                    }\n                    if (value.textElement) {\n                        value.textElement.setAttribute('visibility', 'hidden');\n                        value.shapeElement.setAttribute('visibility', 'hidden');\n                    }\n                    if (element) {\n                        element.style.visibility = 'hidden';\n                    }\n                }\n            }\n        }\n    };\n    Zoom.prototype.calculateZoomAxesRange = function (chart) {\n        var range;\n        var axisRange;\n        for (var index = 0; index < chart.axisCollections.length; index++) {\n            var axis = chart.axisCollections[index];\n            axisRange = axis.visibleRange;\n            if (this.zoomAxes[index]) {\n                if (!chart.delayRedraw) {\n                    this.zoomAxes[index].min = axisRange.min;\n                    this.zoomAxes[index].delta = axisRange.delta;\n                }\n            }\n            else {\n                range = {\n                    actualMin: axis.actualRange.min,\n                    actualDelta: axis.actualRange.delta,\n                    min: axisRange.min,\n                    delta: axisRange.delta\n                };\n                this.zoomAxes[index] = range;\n            }\n        }\n    };\n    // Zooming Toolkit created here\n    Zoom.prototype.showZoomingToolkit = function (chart) {\n        var toolboxItems = this.zooming.toolbarItems;\n        var areaBounds = chart.chartAxisLayoutPanel.seriesClipRect;\n        var spacing = 10;\n        var render = chart.svgRenderer;\n        var length = this.isDevice ? (toolboxItems.length === 0 ? 0 : 1) : toolboxItems.length;\n        var iconSize = this.isDevice ? (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)('Reset Zoom', { size: '12px' }, { size: '12px', fontStyle: 'Normal', fontWeight: '400', fontFamily: 'Segoe UI' }).width : 16;\n        var height = this.isDevice ? (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.measureText)('Reset Zoom', { size: '12px' }, { size: '12px', fontStyle: 'Normal', fontWeight: '400', fontFamily: 'Segoe UI' }).height : chart.theme.indexOf('Fluent2') > -1 || chart.theme.indexOf('Bootstrap5') > -1 ? 18 : 22;\n        var width = (length * iconSize) + ((length + 1) * spacing) + ((length - 1) * spacing);\n        var toolbarPosition = this.zooming.toolbarPosition;\n        var transX;\n        var transY;\n        switch (toolbarPosition.horizontalAlignment) {\n            case 'Far':\n                transX = areaBounds.x + areaBounds.width - width - spacing;\n                break;\n            case 'Near':\n                transX = areaBounds.x + spacing;\n                break;\n            case 'Center':\n                transX = (areaBounds.width / 2) - (width / 2) + areaBounds.x;\n                break;\n        }\n        transX += toolbarPosition.x;\n        switch (toolbarPosition.verticalAlignment) {\n            case 'Bottom':\n                transY = areaBounds.height - areaBounds.y + height + spacing;\n                break;\n            case 'Top':\n                transY = areaBounds.y + spacing;\n                break;\n            case 'Middle':\n                transY = (areaBounds.height / 2) - (height / 2) + areaBounds.y;\n                break;\n        }\n        var toolkitShadowPadding = 2;\n        transY += toolbarPosition.y;\n        transX = this.toolkit.dragHorizontalRatio != null ? Math.min(Math.max(this.chart.border.width + toolkitShadowPadding, this.toolkit.dragHorizontalRatio * this.chart.availableSize.width), this.chart.availableSize.width - width - this.chart.border.width - toolkitShadowPadding) : transX;\n        transY = this.toolkit.dragVerticalRatio != null ? Math.min(Math.max(this.chart.border.width + toolkitShadowPadding, this.toolkit.dragVerticalRatio * this.chart.availableSize.height), this.chart.availableSize.height - height - this.chart.border.width - toolkitShadowPadding) : transY;\n        var xPosition = spacing;\n        var toolkit = this.toolkit;\n        var element;\n        var shadowElement = '<filter id=\"chart_shadow\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"5\"/>';\n        shadowElement += '<feOffset dx=\"-3\" dy=\"4\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"1\"/>';\n        shadowElement += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n        if (length === 0 || (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.elementId + '_Zooming_KitCollection')) {\n            return false;\n        }\n        var defElement = render.createDefs();\n        toolboxItems = this.isDevice ? ['Reset'] : toolboxItems;\n        defElement.innerHTML = shadowElement;\n        this.toolkitElements = render.createGroup({\n            id: this.elementId + '_Zooming_KitCollection',\n            transform: 'translate(' + transX + ',' + transY + ')'\n        });\n        this.toolkitElements.appendChild(defElement);\n        var zoomFillColor = this.chart.theme === 'Tailwind3' ? '#F9FAFB' : this.chart.theme === 'Fluent' ? '#F3F2F1' :\n            (this.chart.theme === 'Material3' ? '#FFFFFF' : this.chart.theme === 'Material3Dark' ? '#1C1B1F' : this.chart.theme === 'Fluent2' ? '#F5F5F5' : this.chart.theme === 'Fluent2Dark' ? '#141414' : chart.theme === 'Fluent2HighContrast' ? '#000000' : chart.theme === 'Bootstrap5' ? '#E9ECEF' : chart.theme === 'Bootstrap5Dark' ? '#343A40' : (chart.theme === 'Tailwind3Dark' && !this.isDevice) ? '#1D2432' : this.chart.theme === 'Tailwind' ? '#F3F4F6' : '#fafafa');\n        this.toolkitElements.appendChild(render.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.RectOption(this.elementId + '_Zooming_Rect', zoomFillColor, { color: 'transparent', width: 1 }, 1, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, width, (height + (spacing * 2))), this.chart.theme.indexOf('Bootstrap5') > -1 ? 1 : 4, this.chart.theme.indexOf('Bootstrap5') > -1 ? 1 : 4)));\n        var outerElement = render.drawRectangle(new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.RectOption(this.elementId + '_Zooming_Rect', zoomFillColor, { color: 'transparent', width: 1 }, 0.1, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, width, (height + (spacing * 2))), 4, 4));\n        if (this.chart.theme === 'Tailwind' || this.chart.theme === 'TailwindDark') {\n            outerElement.setAttribute('box-shadow', '0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)');\n        }\n        else if (this.chart.theme === 'Tailwind3Dark') {\n            outerElement.setAttribute('box-shadow', '0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)');\n        }\n        else if (this.chart.theme === 'Material3' || this.chart.theme === 'Material3Dark' || this.chart.theme === 'Fluent2' || this.chart.theme === 'Fluent2Dark' || this.chart.theme.indexOf('Bootstrap5') > -1) {\n            outerElement.setAttribute('filter', 'drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.15)) drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3))');\n            outerElement.setAttribute('fill', this.chart.theme === 'Material3' ? '#FFFFFF' : this.chart.theme === 'Fluent2' ? '#F5F5F5' : this.chart.theme === 'Bootstrap5' ? '#E9ECEF' : this.chart.theme === 'Bootstrap5Dark' ? '#343A40' : '#1C1B1F');\n            outerElement.setAttribute('rx', this.chart.theme.indexOf('Bootstrap5') > -1 ? '1px' : '4px');\n            outerElement.setAttribute('ry', this.chart.theme.indexOf('Bootstrap5') > -1 ? '1px' : '4px');\n            outerElement.setAttribute('opacity', '1');\n        }\n        else {\n            if (chart.theme === 'Tailwind3') {\n                outerElement.setAttribute('fill', '#F9FAFB');\n            }\n            outerElement.setAttribute('filter', 'url(#chart_shadow)');\n        }\n        this.toolkitElements.appendChild(outerElement);\n        var currentItem;\n        var panIcon = false;\n        for (var i = 1; i <= length; i++) {\n            currentItem = toolboxItems[i - 1];\n            element = render.createGroup({\n                transform: 'translate(' + xPosition + ',' + (this.isDevice ? spacing : chart.theme.indexOf('Fluent2') > -1 || chart.theme.indexOf('Bootstrap5') > -1 ? (spacing + 1) : (spacing + 3)) + ')'\n            });\n            // for desktop toolkit hight is 32 and top padding is 8 icon size 16\n            switch (currentItem) {\n                case 'Pan':\n                    toolkit.createPanButton(element, this.toolkitElements);\n                    panIcon = true;\n                    break;\n                case 'Zoom':\n                    toolkit.createZoomButton(element, this.toolkitElements);\n                    break;\n                case 'ZoomIn':\n                    toolkit.createZoomInButton(element, this.toolkitElements, chart);\n                    break;\n                case 'ZoomOut':\n                    toolkit.createZoomOutButton(element, this.toolkitElements, chart);\n                    break;\n                case 'Reset':\n                    toolkit.createResetButton(element, this.toolkitElements, chart, this.isDevice);\n                    break;\n            }\n            xPosition += iconSize + (spacing * 2);\n        }\n        this.toolkitElements.setAttribute('opacity', this.isDevice ? '1' : '' + this.zoomkitOpacity);\n        this.toolkitElements.setAttribute('cursor', 'auto');\n        if (chart.enableCanvas) {\n            var zoomDiv = document.createElement('div');\n            zoomDiv.id = chart.element.id + '_zoom';\n            zoomDiv.style.cssText = 'position:absolute; z-index:1';\n            var zoomheight = chart.availableSize.height / 2;\n            var svg = chart.svgRenderer.createSvg({\n                id: chart.element.id + '_zoomkit_svg',\n                width: chart.availableSize.width,\n                height: zoomheight\n            });\n            svg.style.position = 'absolute';\n            svg.appendChild(this.toolkitElements);\n            zoomDiv.appendChild(svg);\n            document.getElementById(this.elementId + '_Secondary_Element').appendChild(zoomDiv);\n        }\n        else {\n            chart.svgObject.appendChild(this.toolkitElements);\n        }\n        if (!this.isDevice) {\n            _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.toolkitElements, 'mousemove touchstart', this.zoomToolkitMove, this);\n            _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.toolkitElements, 'mouseleave touchend', this.zoomToolkitLeave, this);\n            if (this.isPanning && panIcon) {\n                toolkit.pan();\n            }\n        }\n        return true;\n    };\n    /**\n     * Applies the zoom toolkit on the chart.\n     *\n     * @param {Chart} chart - The chart instance.\n     * @param {AxisModel[]} axes - The axis models.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.applyZoomToolkit = function (chart, axes) {\n        var showToolkit = this.isAxisZoomed(axes);\n        if (showToolkit) {\n            this.showZoomingToolkit(chart);\n            this.isZoomed = true;\n        }\n        else if (chart.zoomSettings.showToolbar) {\n            this.isZoomed = showToolkit;\n            this.showZoomingToolkit(chart);\n        }\n        else {\n            this.toolkit.removeTooltip();\n            this.isPanning = false;\n            this.isZoomed = false;\n            chart.isZoomed = false;\n            chart.svgObject.setAttribute('cursor', 'auto');\n        }\n    };\n    /**\n     * Cancels the zoom action.\n     *\n     * @param {AxisModel[]} axes - The axis models.\n     * @param {IZoomCompleteEventArgs[]} zoomCompleteEventCollection - The collection of zoom complete events.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.zoomCancel = function (axes, zoomCompleteEventCollection) {\n        for (var _i = 0, _a = zoomCompleteEventCollection; _i < _a.length; _i++) {\n            var zoomCompleteEvent = _a[_i];\n            for (var _b = 0, _c = axes; _b < _c.length; _b++) {\n                var axis = _c[_b];\n                if (axis.name === zoomCompleteEvent.axis.name) {\n                    axis.zoomFactor = zoomCompleteEvent.previousZoomFactor;\n                    axis.zoomPosition = zoomCompleteEvent.previousZoomPosition;\n                    axis.visibleRange = zoomCompleteEvent.previousVisibleRange;\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * Checks if any of the axes is zoomed.\n     *\n     * @param {AxisModel[]} axes - The axis models.\n     * @returns {boolean} - True if any axis is zoomed; otherwise, false.\n     * @private\n     */\n    Zoom.prototype.isAxisZoomed = function (axes) {\n        var showToolkit = false;\n        for (var _i = 0, _a = axes; _i < _a.length; _i++) {\n            var axis = _a[_i];\n            showToolkit = (showToolkit || (axis.zoomFactor !== 1 || axis.zoomPosition !== 0));\n        }\n        return showToolkit;\n    };\n    Zoom.prototype.zoomToolkitMove = function () {\n        var element = this.toolkitElements;\n        this.zoomkitOpacity = 1;\n        element.setAttribute('opacity', '' + this.zoomkitOpacity);\n        return false;\n    };\n    Zoom.prototype.zoomToolkitLeave = function () {\n        var element = this.toolkitElements;\n        this.zoomkitOpacity = 1;\n        element.setAttribute('opacity', '' + this.zoomkitOpacity);\n        return false;\n    };\n    /**\n     * Adds event listeners for the chart.\n     *\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.addEventListener = function () {\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.add(this.chart.element, this.wheelEvent, this.chartMouseWheel, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMoveHandler, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.mouseDownHandler, this);\n        this.chart.on(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseUpHandler, this);\n        this.chart.on(this.cancelEvent, this.mouseCancelHandler, this);\n    };\n    /**\n     * Remove event listeners for the chart.\n     *\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.removeEventListener = function () {\n        _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.EventHandler.remove(this.chart.element, this.wheelEvent, this.chartMouseWheel);\n        if (this.chart.isDestroyed) {\n            return;\n        }\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchMoveEvent, this.mouseMoveHandler);\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchStartEvent, this.mouseDownHandler);\n        this.chart.off(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.touchEndEvent, this.mouseUpHandler);\n        this.chart.off(this.cancelEvent, this.mouseCancelHandler);\n    };\n    /**\n     * Handles the mouse wheel event on the chart.\n     *\n     * @param {WheelEvent} e - The wheel event.\n     * @returns {boolean} - Returns false.\n     * @private\n     */\n    Zoom.prototype.chartMouseWheel = function (e) {\n        var chart = this.chart;\n        var offset = chart.element.getBoundingClientRect();\n        var svgRect = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(chart.svgId).getBoundingClientRect();\n        var mouseX = (e.clientX - offset.left) - Math.max(svgRect.left - offset.left, 0);\n        var mouseY = (e.clientY - offset.top) - Math.max(svgRect.top - offset.top, 0);\n        if (this.zooming.enableMouseWheelZooming &&\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(mouseX, mouseY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n            e.preventDefault();\n            this.performMouseWheelZooming(e, mouseX, mouseY, chart, chart.axisCollections);\n        }\n        return false;\n    };\n    /**\n     * Handles the mouse move event on the chart.\n     *\n     * @param {PointerEvent | TouchEvent} e - The mouse move event or touch event.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mouseMoveHandler = function (e) {\n        //Zooming for chart\n        var chart = this.chart;\n        var touches = null;\n        if (e.type === 'touchmove') {\n            if (e.preventDefault && this.isIOS &&\n                (this.isPanning || (chart.isDoubleTap)\n                    || (this.zooming.enablePinchZooming && this.touchStartList.length > 1))) {\n                e.preventDefault();\n            }\n            touches = e.touches;\n        }\n        if (chart.isChartDrag) {\n            if (chart.isTouch) {\n                this.touchMoveList = this.addTouchPointer(this.touchMoveList, e, touches);\n                if (this.zooming.enablePinchZooming && this.touchMoveList.length > 1\n                    && this.touchStartList.length > 1) {\n                    this.performPinchZooming(e, chart);\n                }\n            }\n            this.renderZooming(e, chart, chart.isTouch);\n        }\n    };\n    /**\n     * Handles the mouse down event on the chart.\n     *\n     * @param {PointerEvent} e - The mouse down event.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mouseDownHandler = function (e) {\n        //Zooming for chart\n        var chart = this.chart;\n        var touches = null;\n        var target;\n        if (e.type === 'touchstart') {\n            touches = e.touches;\n            target = e.target;\n        }\n        else {\n            target = e.target;\n        }\n        if (target.id.indexOf(chart.element.id + '_Zooming_') === -1 &&\n            (chart.zoomSettings.enablePinchZooming || chart.zoomSettings.enableSelectionZooming || this.chart.zoomModule.isPanning) &&\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(chart.previousMouseMoveX, chart.previousMouseMoveY, chart.chartAxisLayoutPanel.seriesClipRect)) {\n            chart.isChartDrag = true;\n        }\n        if (chart.isTouch) {\n            this.touchStartList = this.addTouchPointer(this.touchStartList, e, touches);\n        }\n    };\n    /**\n     * Handles the mouse up event on the chart.\n     *\n     * @param {PointerEvent} e - The mouse up event.\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mouseUpHandler = function (e) {\n        var chart = this.chart;\n        var performZoomRedraw = e.target.id.indexOf(chart.element.id + '_ZoomOut_') === -1 ||\n            e.target.id.indexOf(chart.element.id + '_ZoomIn_') === -1;\n        if (chart.isChartDrag || performZoomRedraw) {\n            this.redrawOnZooming(chart, true, true);\n        }\n        if (chart.isTouch) {\n            if (chart.isDoubleTap && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.withInBounds)(chart.mouseX, chart.mouseY, chart.chartAxisLayoutPanel.seriesClipRect)\n                && this.touchStartList.length === 1 && this.isZoomed) {\n                this.toolkit.reset(e);\n            }\n            this.touchStartList = [];\n            chart.isDoubleTap = false;\n        }\n    };\n    /**\n     * Handles the mouse cancel event on the chart.\n     *\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.mouseCancelHandler = function () {\n        if (this.isZoomed) {\n            this.performZoomRedraw(this.chart);\n        }\n        this.pinchTarget = null;\n        this.touchStartList = [];\n        this.touchMoveList = [];\n    };\n    /**\n     * Adds touch pointer to the touch list.\n     *\n     * @param {ITouches[]} touchList - The touch list.\n     * @param {PointerEvent} e - The pointer event.\n     * @param {TouchList} touches - The touch list.\n     * @returns {ITouches[]} - The updated touch list.\n     * @private\n     */\n    Zoom.prototype.addTouchPointer = function (touchList, e, touches) {\n        if (touches) {\n            touchList = [];\n            for (var i = 0, length_1 = touches.length; i < length_1; i++) {\n                touchList.push({ pageX: touches[i].clientX, pageY: touches[i].clientY, pointerId: null });\n            }\n        }\n        else {\n            touchList = touchList ? touchList : [];\n            if (touchList.length === 0) {\n                touchList.push({ pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId });\n            }\n            else {\n                for (var i = 0, length_2 = touchList.length; i < length_2; i++) {\n                    if (touchList[i].pointerId === e.pointerId) {\n                        touchList[i] = { pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId };\n                    }\n                    else {\n                        touchList.push({ pageX: e.clientX, pageY: e.clientY, pointerId: e.pointerId });\n                    }\n                }\n            }\n        }\n        return touchList;\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    Zoom.prototype.getModuleName = function () {\n        // Returns te module name\n        return 'Zoom';\n    };\n    /**\n     * To destroy the zooming.\n     *\n     * @returns {void}\n     * @private\n     */\n    Zoom.prototype.destroy = function () {\n        // Destroy method performed here.\n        this.removeEventListener();\n    };\n    return Zoom;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/user-interaction/zooming.js?");

/***/ })

}]);