"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_load-utility_nodeProperties_js-dde1b2-c6004bff"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/load-utility/nodeProperties.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/load-utility/nodeProperties.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodeProperties: () => (/* binding */ NodeProperties)\n/* harmony export */ });\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n\nvar NodeProperties = /** @class */ (function () {\n    function NodeProperties(labelProperties, portProperties) {\n        this.labelProperties = labelProperties;\n        this.portProperties = portProperties;\n    }\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Convert and render the node collection from EJ1 to EJ2\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    NodeProperties.prototype.renderNodesCollection = function (convertedData, data) {\n        convertedData.nodes = [];\n        var nodes = [];\n        for (var i = 0; i < data.nodes.length; i++) {\n            var node = data.nodes[parseInt(i.toString(), 10)];\n            var processCollection = [];\n            var newNode = this.convertToNode(node);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            // eslint-disable-next-line max-len\n            if (newNode.shape && newNode.shape.activity && newNode.shape.activity.subProcess && newNode.shape.activity.subProcess.processes && newNode.shape.activity.subProcess.processes.length > 0) {\n                var processName = [];\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                for (var k = 0; k < newNode.shape.activity.subProcess.processes.length; k++) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    var processes = newNode.shape.activity.subProcess.processes[parseInt(k.toString(), 10)];\n                    processes.margin.right = 0;\n                    processes.margin.bottom = 0;\n                    processes.processId = newNode.id;\n                    processName.push(processes.id);\n                    processCollection.push(processes);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                newNode.shape.activity.subProcess.processes = processName;\n            }\n            if (node.type === 'group' && !node.isSwimlane) {\n                var childCollection = [];\n                if (newNode.children && newNode.children.length > 0) {\n                    for (var j = 0; j < newNode.children.length; j++) {\n                        var child = newNode.children[parseInt(j.toString(), 10)];\n                        nodes.push(child);\n                        childCollection.push(child.id);\n                    }\n                    newNode.children = childCollection;\n                }\n            }\n            nodes.push(newNode);\n            if (processCollection && processCollection.length > 0) {\n                nodes = nodes.concat(processCollection);\n            }\n        }\n        convertedData.nodes = nodes;\n        return convertedData.nodes;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Convert the node from EJ1 to EJ2 and assign all the properties\n    NodeProperties.prototype.convertToNode = function (node) {\n        var newNode = {};\n        newNode.style = {};\n        newNode.margin = {};\n        if (node.name) {\n            newNode.id = node.name;\n        }\n        if (node.fillColor) {\n            newNode.style.fill = node.fillColor;\n        }\n        if (node.borderColor) {\n            newNode.style.strokeColor = node.borderColor;\n        }\n        if (node.borderWidth) {\n            newNode.style.strokeWidth = node.borderWidth;\n        }\n        if (node.borderDashArray) {\n            newNode.style.strokeDashArray = node.borderDashArray;\n        }\n        if (node.opacity) {\n            newNode.style.opacity = node.opacity;\n        }\n        if (node.gradient) {\n            newNode.style.gradient = this.setGradient(node.gradient);\n        }\n        if (node.isExpanded) {\n            newNode.isExpanded = node.isExpanded;\n        }\n        if (node.width) {\n            newNode.width = node.width;\n        }\n        if (node.height) {\n            newNode.height = node.height;\n        }\n        if (node.offsetX) {\n            newNode.offsetX = node.offsetX;\n        }\n        if (node.offsetY) {\n            newNode.offsetY = node.offsetY;\n        }\n        if (node.visible) {\n            newNode.visible = node.visible;\n        }\n        newNode.zIndex = node.zOrder === -1 ? -1 : node.zOrder;\n        if (node.excludeFromLayout) {\n            newNode.excludeFromLayout = node.excludeFromLayout;\n        }\n        if (node.rotateAngle) {\n            newNode.rotateAngle = node.rotateAngle;\n        }\n        if (node.pivot) {\n            newNode.pivot = node.pivot;\n        }\n        if (node.addInfo) {\n            newNode.addInfo = node.addInfo;\n        }\n        if (node.marginLeft) {\n            newNode.margin.left = node.marginLeft;\n        }\n        if (node.marginRight) {\n            newNode.margin.right = node.marginRight;\n        }\n        if (node.marginTop) {\n            newNode.margin.top = node.marginTop;\n        }\n        if (node.marginBottom) {\n            newNode.margin.bottom = node.marginBottom;\n        }\n        if (node.horizontalAlign) {\n            newNode.horizontalAlignment = node.horizontalAlign;\n        }\n        if (node.verticalAlign) {\n            newNode.verticalAlignment = node.verticalAlign;\n        }\n        if (node.constraints) {\n            newNode.constraints = this.setNodeConstraints(node.constraints);\n        }\n        if (node.labels) {\n            newNode.annotations = this.labelProperties.setLabelProperties(node.labels, undefined);\n        }\n        if (node.shadow) {\n            newNode.shadow = {\n                angle: node.shadow.angle, opacity: node.shadow.opacity, distance: node.shadow.distance\n            };\n        }\n        if (node.tooltip) {\n            newNode.tooltip = {\n                // content: this.getTemplateContent(node.tooltip.templateId),\n                relativeMode: node.tooltip.relativeMode\n            };\n        }\n        if (node.expandIcon) {\n            newNode.expandIcon = {\n                shape: node.expandIcon.shape.charAt(0).toUpperCase() + (node.expandIcon.shape).slice(1),\n                width: node.expandIcon.width, height: node.expandIcon.height,\n                margin: {\n                    left: node.expandIcon.margin.left,\n                    right: node.expandIcon.margin.right,\n                    top: node.expandIcon.margin.top,\n                    bottom: node.expandIcon.margin.bottom\n                },\n                offset: {\n                    x: node.expandIcon.offset.x,\n                    y: node.expandIcon.offset.y\n                },\n                borderColor: node.expandIcon.borderColor, borderWidth: node.expandIcon.borderWidth,\n                cornerRadius: node.expandIcon.cornerRadius,\n                //fill: (node.expandIcon as any).fillColor,\n                pathData: node.expandIcon.pathData\n                // content: getTemplateContent(node.expandIcon.templateId)\n            };\n            if (newNode.expandIcon.shape === 'Arrowup') {\n                newNode.expandIcon.shape = 'ArrowUp';\n            }\n            else if (newNode.expandIcon.shape === 'Arrowdown') {\n                newNode.expandIcon.shape = 'ArrowDown';\n            }\n        }\n        if (node.collapseIcon) {\n            newNode.collapseIcon = {\n                shape: node.collapseIcon.shape.charAt(0).toUpperCase() + (node.collapseIcon.shape).slice(1),\n                width: node.collapseIcon.width, height: node.collapseIcon.height,\n                margin: {\n                    left: node.collapseIcon.margin.left,\n                    right: node.collapseIcon.margin.right,\n                    top: node.collapseIcon.margin.top,\n                    bottom: node.collapseIcon.margin.bottom\n                },\n                offset: {\n                    x: node.collapseIcon.offset.x,\n                    y: node.collapseIcon.offset.y\n                },\n                borderColor: node.collapseIcon.borderColor, borderWidth: node.collapseIcon.borderWidth,\n                cornerRadius: node.collapseIcon.cornerRadius,\n                // fill: (node.collapseIcon as any).fillColor,\n                pathData: node.collapseIcon.pathData\n                //  content: getTemplateContent(node.collapseIcon.templateId)\n            };\n            if (newNode.collapseIcon.shape === 'Arrowup') {\n                newNode.collapseIcon.shape = 'ArrowUp';\n            }\n            else if (newNode.collapseIcon.shape === 'Arrowdown') {\n                newNode.collapseIcon.shape = 'ArrowDown';\n            }\n        }\n        if (node.ports) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            newNode.ports = this.portProperties.setPortProperties(node.ports);\n        }\n        if (node.children) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (node.type !== 'bpmn' && !node.isSwimlane) {\n                newNode.children = this.getChildren(newNode, node);\n            }\n        }\n        if (!(node.children && node.children.length > 0)) {\n            newNode.maxWidth = node.maxWidth;\n            newNode.maxHeight = node.maxHeight;\n            newNode.minWidth = node.minWidth;\n            newNode.minHeight = node.minHeight;\n        }\n        if (node.shape || node.type) {\n            newNode = this.setShape(newNode, node);\n        }\n        return newNode;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Iterate the swimlane child nodes and assign all the node properties from the EJ1 to EJ2\n    NodeProperties.prototype.getChildren = function (newNode, node) {\n        if (node.children && node.children.length > 0) {\n            var newChild = [];\n            for (var i = 0; i < node.children.length; i++) {\n                var child = this.convertToNode(node.children[parseInt(i.toString(), 10)]);\n                if (child.children) {\n                    this.getChildren(newNode, child);\n                }\n                newChild.push(child);\n            }\n            newNode.children = newChild;\n        }\n        return newNode.children;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Sets the shapes for all the node from conversion\n    NodeProperties.prototype.setShape = function (newNode, node) {\n        switch (node.type) {\n            case 'basic': {\n                var basicShape = (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1);\n                if (node.shape === 'path') {\n                    newNode.shape = { type: 'Path', data: node.pathData };\n                }\n                else {\n                    newNode.shape = {\n                        type: 'Basic', shape: basicShape, cornerRadius: node.cornerRadius, points: node.points\n                    };\n                }\n                break;\n            }\n            case 'flow': {\n                var flowShape = (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1);\n                newNode.shape = {\n                    type: 'Flow', shape: flowShape\n                };\n                break;\n            }\n            case 'umlactivity':\n                newNode.shape = {\n                    type: 'UmlActivity', shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1)\n                };\n                break;\n            case 'image':\n                newNode.shape = {\n                    type: 'Image', source: node.source, align: this.getImageContentAlignment(node.contentAlignment),\n                    scale: (node.scale).charAt(0).toUpperCase() + (node.scale).slice(1)\n                };\n                break;\n            case 'html':\n                newNode.shape = { type: 'HTML' };\n                break;\n            case 'native':\n                newNode.shape = { type: 'Native' };\n                break;\n            case 'text':\n                newNode.shape = { type: 'Text', content: node.textBlock.text };\n                break;\n            case 'bpmn':\n                newNode.shape = this.renderBpmnShape(newNode, node);\n                break;\n            case 'group':\n                if (node.isSwimlane) {\n                    newNode.shape = this.renderSwimlaneShape(newNode, node);\n                }\n        }\n        return newNode;\n    };\n    NodeProperties.prototype.getImageContentAlignment = function (option) {\n        if (option) {\n            switch (option) {\n                case 'xminymin':\n                    return 'XMinYMin';\n                case 'xminymid':\n                    return 'XMinYMid';\n                case 'xminymax':\n                    return 'XMinYMax';\n                case 'xmidymin':\n                    return 'XMidYMin';\n                case 'xmidymid':\n                    return 'XMidYMid';\n                case 'xmidymax':\n                    return 'XMidYMax';\n                case 'xmaxymin':\n                    return 'XMaxYMin';\n                case 'xmaxymid':\n                    return 'XMaxYMid';\n                case 'xmaxymax':\n                    return 'XMaxYMax';\n                case 'none':\n                    return 'None';\n            }\n        }\n        return 'None';\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    // Sets the node constraints from EJ1 to EJ2\n    NodeProperties.prototype.setNodeConstraints = function (constraints) {\n        var nodeConstraints = _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.None;\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Select) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Select;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Delete) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Delete;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Drag) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Drag;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Rotate) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Rotate;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeNorthEast) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeNorthEast;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeEast) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeEast;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.OutConnect) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeSouthEast;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Expandable) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeSouth;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.AllowDrop) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeSouthWest;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeNorthEast) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeWest;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeEast) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeNorthWest;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeNorth) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.ResizeNorth;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Resize) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Resize;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Shadow) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Shadow;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.AspectRatio) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.AspectRatio;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.AllowDrop) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.AllowDrop;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.InheritTooltip) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.InheritTooltip;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.PointerEvents) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.PointerEvents;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Inherit) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Inherit;\n        }\n        if (constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Default) {\n            nodeConstraints = nodeConstraints | _enum_enum__WEBPACK_IMPORTED_MODULE_0__.NodeConstraints.Default;\n        }\n        return nodeConstraints;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Sets the gradient for the nodes\n    NodeProperties.prototype.setGradient = function (gradient) {\n        var newGradient = {};\n        if (gradient) {\n            if (gradient.type === 'linear') {\n                newGradient = {\n                    type: 'Linear',\n                    x1: gradient.x1, x2: gradient.x2, y1: gradient.y1, y2: gradient.y2,\n                    stops: this.getGradientStops(gradient.stops)\n                };\n            }\n            else if (gradient.type === 'radial') {\n                newGradient = {\n                    type: 'Radial',\n                    cx: gradient.cx, cy: gradient.cy, fx: gradient.fx, fy: gradient.fy,\n                    stops: this.getGradientStops(gradient.stops)\n                };\n            }\n        }\n        return newGradient;\n    };\n    NodeProperties.prototype.getGradientStops = function (gradientStops) {\n        var stopsCollection = [];\n        for (var i = 0; i < gradientStops.length; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var newStop = {};\n            var stop_1 = gradientStops[parseInt(i.toString(), 10)];\n            newStop.color = stop_1.color;\n            newStop.offset = stop_1.offset;\n            stopsCollection.push(newStop);\n        }\n        return stopsCollection;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Assign the BPMN shape values from the EJ1\n    NodeProperties.prototype.renderBpmnShape = function (newNode, node) {\n        if (node.shape === 'event') {\n            newNode.shape = {\n                type: 'Bpmn',\n                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1),\n                event: {\n                    event: (node.event).charAt(0).toUpperCase() + (node.event).slice(1),\n                    trigger: (node.trigger).charAt(0).toUpperCase() + (node.trigger).slice(1)\n                }\n            };\n        }\n        else if (node.shape === 'gateway') {\n            newNode.shape = {\n                type: 'Bpmn',\n                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1),\n                gateway: {\n                    type: (node.gateway).charAt(0).toUpperCase() + (node.gateway).slice(1)\n                }\n            };\n        }\n        else if (node.shape === 'activity') {\n            newNode.shape = {\n                type: 'Bpmn',\n                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1),\n                activity: {\n                    activity: (node.activity).charAt(0).toUpperCase() + (node.activity).slice(1)\n                }\n            };\n            newNode.shape.activity.activity = newNode.shape.activity.activity === 'Subprocess' ? 'SubProcess' : newNode.shape.activity.activity;\n            if (node.activity === 'task') {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                newNode.shape.activity.task = {\n                    type: (node.task.type).charAt(0).toUpperCase() + (node.task.type).slice(1),\n                    loop: (node.task.loop).charAt(0).toUpperCase() + (node.task.loop).slice(1),\n                    compensation: node.task.compensation,\n                    call: node.task.call\n                };\n            }\n            if (node.activity === 'subprocess') {\n                if (node.subProcess.type === 'event') {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    newNode.shape.activity.subProcess = {\n                        collapsed: node.subProcess.collapsed,\n                        compensation: node.subProcess.compensation,\n                        adhoc: node.subProcess.adhoc,\n                        loop: (node.subProcess.loop).charAt(0).toUpperCase() + (node.subProcess.loop).slice(1),\n                        boundary: (node.subProcess.boundary).charAt(0).toUpperCase() + (node.subProcess.boundary).slice(1),\n                        type: (node.subProcess.type).charAt(0).toUpperCase() + (node.subProcess.type).slice(1),\n                        event: {\n                            event: (node.subProcess.event).charAt(0).toUpperCase() + (node.subProcess.event).slice(1),\n                            trigger: (node.subProcess.trigger).charAt(0).toUpperCase() + (node.subProcess.trigger).slice(1)\n                        }\n                    };\n                }\n                else if (node.subProcess.type === 'transaction') {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    newNode.shape.activity.subProcess = {\n                        collapsed: node.subProcess.collapsed,\n                        compensation: node.subProcess.compensation,\n                        adhoc: node.subProcess.adhoc,\n                        loop: (node.subProcess.loop).charAt(0).toUpperCase() + (node.subProcess.loop).slice(1),\n                        boundary: (node.subProcess.boundary).charAt(0).toUpperCase() + (node.subProcess.boundary).slice(1),\n                        type: (node.subProcess.type).charAt(0).toUpperCase() + (node.subProcess.type).slice(1),\n                        events: this.renderEventsCollection(node.subProcess.events),\n                        processes: this.renderProcessesCollection(node)\n                    };\n                }\n            }\n        }\n        else if (node.shape === 'dataobject') {\n            newNode.shape = {\n                type: 'Bpmn',\n                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1)\n                // data: {\n                //     type: this.getKeyByValue(node.data.type),\n                //     collection: true\n                // }\n            };\n            if (node.annotation) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                newNode.shape.annotation = {\n                    text: node.annotation.text,\n                    angle: node.annotation.angle,\n                    width: node.annotation.width,\n                    height: node.annotation.height,\n                    length: node.annotation.length\n                };\n            }\n        }\n        else {\n            newNode.shape = {\n                type: 'Bpmn',\n                shape: (node.shape).charAt(0).toUpperCase() + (node.shape).slice(1)\n            };\n        }\n        return newNode.shape;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Renders the swimlane from the conversion\n    NodeProperties.prototype.renderSwimlaneShape = function (newNode, node) {\n        newNode.shape = {\n            type: 'SwimLane', orientation: (node.orientation).charAt(0).toUpperCase() + (node.orientation).slice(1),\n            header: {\n                annotation: { content: node.header.text },\n                height: 50, style: { fontSize: node.header.fontSize, color: node.header.fontColor, fill: node.header.fillColor }\n            }\n        };\n        var lanes = [];\n        var phases = [];\n        for (var i = 0; i < node.lanes.length; i++) {\n            lanes[parseInt(i.toString(), 10)] = {\n                header: {\n                    annotation: {\n                        content: node.lanes[parseInt(i.toString(), 10)].header.text,\n                        width: node.lanes[parseInt(i.toString(), 10)].header.width,\n                        style: {\n                            fontSize: node.lanes[parseInt(i.toString(), 10)].header.fontSize,\n                            color: node.lanes[parseInt(i.toString(), 10)].header.fontColor\n                        }\n                    }\n                },\n                style: { fill: node.lanes[parseInt(i.toString(), 10)].fillColor },\n                children: []\n            };\n            for (var j = 0; j < node.lanes[parseInt(i.toString(), 10)].children.length; j++) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var childNode = this.convertToNode(node.lanes[parseInt(i.toString(), 10)].children[parseInt(j.toString(), 10)]);\n                if (childNode.wrapper == null) {\n                    childNode.wrapper = {\n                        actualSize: { width: childNode.width, height: childNode.height },\n                        offsetX: childNode.offsetX, offsetY: childNode.offsetY\n                    };\n                }\n                lanes[parseInt(i.toString(), 10)].children.push(childNode);\n            }\n        }\n        for (var i = 0; i < node.phases.length; i++) {\n            phases[parseInt(i.toString(), 10)] = {\n                header: {\n                    annotation: {\n                        content: node.phases[parseInt(i.toString(), 10)].label.text,\n                        // eslint-disable-next-line max-len\n                        style: { fill: node.phases[parseInt(i.toString(), 10)].label.fillColor, fontSize: node.phases[parseInt(i.toString(), 10)].label.fontSize, color: node.phases[parseInt(i.toString(), 10)].label.fontColor }\n                    }\n                },\n                offset: node.phases[parseInt(i.toString(), 10)].offset,\n                // eslint-disable-next-line max-len\n                style: { fill: node.phases[parseInt(i.toString(), 10)].fillColor, strokeColor: node.phases[parseInt(i.toString(), 10)].lineColor, strokeDashArray: node.phases[parseInt(i.toString(), 10)].lineDashArray }\n            };\n        }\n        newNode.shape.lanes = lanes;\n        newNode.shape.phases = phases;\n        return newNode.shape;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Rendered the event collections for the node properties\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    NodeProperties.prototype.renderEventsCollection = function (subProcessEvents) {\n        var eventsCollection = [];\n        if (subProcessEvents.length > 0) {\n            for (var i = 0; i < subProcessEvents.length; i++) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                var newEvent = {};\n                var eventObject = subProcessEvents[parseInt(i.toString(), 10)];\n                newEvent.event = (eventObject.event).charAt(0).toUpperCase() + (eventObject.event).slice(1);\n                newEvent.trigger = (eventObject.trigger).charAt(0).toUpperCase() + (eventObject.trigger).slice(1);\n                newEvent.offset = { x: eventObject.offset.x, y: eventObject.offset.y };\n                eventsCollection.push(newEvent);\n            }\n        }\n        return eventsCollection;\n    };\n    //(EJ2-272287) Provide support to convert the EJ1 diagram to EJ2 diagram\n    //Rendered the process collections for the node properties\n    NodeProperties.prototype.renderProcessesCollection = function (node) {\n        var processesCollection = [];\n        if (node.subProcess && node.subProcess.processes.length > 0) {\n            for (var i = 0; i < node.subProcess.processes.length; i++) {\n                var processObject = node.subProcess.processes[parseInt(i.toString(), 10)];\n                var data = this.convertToNode(processObject);\n                processesCollection.push(data);\n            }\n        }\n        return processesCollection;\n    };\n    /**\n     * Get module name.\n     * @returns {string} Returns the module name\n     */\n    NodeProperties.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'NodeProperties';\n    };\n    return NodeProperties;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/load-utility/nodeProperties.js?");

/***/ })

}]);