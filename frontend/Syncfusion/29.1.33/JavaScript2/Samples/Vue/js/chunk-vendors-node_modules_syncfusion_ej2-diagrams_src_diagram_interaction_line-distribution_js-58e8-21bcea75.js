"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_interaction_line-distribution_js-58e8-21bcea75"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-distribution.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-distribution.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineDistribution: () => (/* binding */ LineDistribution)\n/* harmony export */ });\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _primitives_point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/point */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/point.js\");\n/* harmony import */ var _objects_port__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../objects/port */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/port.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n\n\n\n\n\n\n/**\n * Line Distribution\n * @private\n */\nvar LineDistribution = /** @class */ (function () {\n    ///** @private */\n    //public edgeMapper: EdgeMapperObject[];\n    /**\n     * Constructor for the line distribution module\n     * @private\n     */\n    function LineDistribution() {\n        //constructs the line distribution module\n    }\n    /**\n     * To destroy the line distribution module\n     * @returns {void}\n     * @private\n     */\n    LineDistribution.prototype.destroy = function () {\n        /**\n         * Destroys the line distribution module\n         */\n    };\n    ///**\n    // * Get the diagram instance.\n    // */\n    //private diagram: Diagram;\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    LineDistribution.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'LineDistribution';\n    };\n    /** @private */\n    LineDistribution.prototype.initLineDistribution = function (graph, diagram) {\n        var srcDirection = 'Bottom';\n        //this.diagram = diagram;\n        if (diagram.layout.connectionPointOrigin === 'DifferentPoint' || diagram.layout.enableRouting) {\n            var tarDirection = 'Top';\n            if (graph.orientation === 'BottomToTop') {\n                srcDirection = 'Top';\n                tarDirection = 'Bottom';\n            }\n            else if (graph.orientation === 'RightToLeft') {\n                srcDirection = 'Left';\n                tarDirection = 'Right';\n            }\n            else if (graph.orientation === 'LeftToRight') {\n                srcDirection = 'Right';\n                tarDirection = 'Left';\n            }\n            var graphnodes = diagram.nodes;\n            if (graphnodes.length > 0) {\n                for (var i = 0; i < graphnodes.length; i++) {\n                    var node = diagram.nameTable[graphnodes[parseInt(i.toString(), 10)].id];\n                    this.addDynamicPortandDistrrbuteLine(graph, node, srcDirection, tarDirection, diagram);\n                }\n            }\n        }\n    };\n    LineDistribution.prototype.ObstacleSegment = function (options) {\n        options.direction = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_1__.getConnectorDirection)(options.startpt, options.endpt);\n        options.distance = _primitives_point__WEBPACK_IMPORTED_MODULE_3__.Point.findLength(options.startpt, options.endpt);\n        options.orientation = options.direction === 'Left' || options.direction === 'Right' ? 'horizontal' : 'vertical';\n        // eslint-disable-next-line no-self-assign\n        options.id = options.id;\n        if (options.orientation === 'horizontal') {\n            options.coord = options.startpt.y;\n            if (options.direction === 'Left') {\n                options.start = options.endpt.x;\n                options.end = options.startpt.x;\n            }\n            else {\n                options.start = options.startpt.x;\n                options.end = options.endpt.x;\n            }\n        }\n        else {\n            options.coord = options.startpt.x;\n            if (options.direction === 'Top') {\n                options.start = options.endpt.y;\n                options.end = options.startpt.y;\n            }\n            else {\n                options.start = options.startpt.y;\n                options.end = options.endpt.y;\n            }\n        }\n        return options;\n    };\n    /** @private */\n    LineDistribution.prototype.distributeLines = function (layout, diagram) {\n        var isHorizontal = layout.orientation === 'LeftToRight'\n            || layout.orientation === 'RightToLeft';\n        var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;\n        var srcdecoratorSize = 8.0;\n        var obstacleCollection = 'obstaclePointCollection';\n        var tardecoratorSize = 10.0;\n        var avaibaleSpace = inversespacing - srcdecoratorSize - tardecoratorSize;\n        var graph = [];\n        var connectorObstacles = [];\n        var globalConnectors = diagram.connectors;\n        for (var i = 0; i < globalConnectors.length; i++) {\n            var connector = globalConnectors[parseInt(i.toString(), 10)];\n            var pts = [];\n            for (var key = 0; key < connector.segments.length; key++) {\n                var seg = connector.segments[parseInt(key.toString(), 10)];\n                for (var k = 0; k < seg.points.length; k++) {\n                    var pt = seg.points[parseInt(k.toString(), 10)];\n                    if (pts.length === 0 || !(_primitives_point__WEBPACK_IMPORTED_MODULE_3__.Point.equals(pt, pts[pts.length - 1]))) {\n                        pts.push(pt);\n                    }\n                }\n            }\n            var obssegments = [];\n            for (var j = 1; j < pts.length; j++) {\n                var obstacle = this.ObstacleSegment({\n                    startpt: pts[j - 1], endpt: pts[parseInt(j.toString(), 10)], id: connector.id\n                });\n                obssegments.push(obstacle);\n            }\n            var connectorObstacle = { wrapper: connector, segments: obssegments };\n            var segments = [];\n            if (!isHorizontal) {\n                for (var key = 0; key < connectorObstacle.segments.length; key++) {\n                    var obstacle = connectorObstacle.segments[parseInt(key.toString(), 10)];\n                    if (obstacle.orientation === 'horizontal') {\n                        segments.push(obstacle);\n                    }\n                }\n            }\n            else {\n                for (var key = 0; key < connectorObstacle.segments.length; key++) {\n                    var obstacle = connectorObstacle.segments[parseInt(key.toString(), 10)];\n                    if (obstacle.orientation === 'vertical') {\n                        segments.push(obstacle);\n                    }\n                }\n            }\n            for (var j = 0; j < segments.length; j++) {\n                var obstacleSegment = segments[parseInt(j.toString(), 10)];\n                if (!this.containsValue(graph, obstacleSegment.coord)) {\n                    graph.push({ key: obstacleSegment.coord, value: [] });\n                }\n                var index = void 0;\n                for (var k = 0; k < graph.length; k++) {\n                    var key = graph[parseInt(k.toString(), 10)].key;\n                    if (Number(key) === obstacleSegment.coord) {\n                        index = k;\n                        break;\n                    }\n                }\n                graph[parseInt(index.toString(), 10)].value.push(obstacleSegment);\n            }\n            connectorObstacles.push(connectorObstacle);\n        }\n        this.sortConnectors(graph, diagram);\n        var modifiedgrap = [];\n        for (var m = 0; m < graph.length; m++) {\n            var row = graph[parseInt(m.toString(), 10)];\n            var sortedrow = row.value;\n            sortedrow.sort();\n            var groupby = void 0;\n            groupby = [];\n            var index = 0;\n            var maxEnd = Number.MIN_VALUE;\n            groupby.push([]);\n            for (var n = 0; n < sortedrow.length; n++) {\n                var obstacleSegment = sortedrow[parseInt(n.toString(), 10)];\n                if (!(groupby[parseInt(index.toString(), 10)].length > 0) || maxEnd >= obstacleSegment.start) {\n                    groupby[parseInt(index.toString(), 10)].push(obstacleSegment);\n                    maxEnd = Math.max(maxEnd, groupby[parseInt(index.toString(), 10)][groupby[parseInt(index.toString(), 10)].length - 1].end);\n                }\n                else {\n                    index++;\n                    groupby.push([]);\n                    groupby[parseInt(index.toString(), 10)].push(obstacleSegment);\n                    maxEnd = groupby[parseInt(index.toString(), 10)][groupby[parseInt(index.toString(), 10)].length - 1].end;\n                }\n            }\n            for (var n = 0; n < groupby.length; n++) {\n                var group = groupby[parseInt(n.toString(), 10)];\n                var sortedGroup = [];\n                for (var j = 0; j < group.length; j++) {\n                    var e = group[parseInt(j.toString(), 10)];\n                    if (e.start) {\n                        sortedGroup.push(e);\n                    }\n                }\n                var comparingDir = isHorizontal ? 'Bottom' : 'Right';\n                var directed = [];\n                for (var j = 0; j < sortedGroup.length; j++) {\n                    var e = sortedGroup[parseInt(j.toString(), 10)];\n                    if (e.direction === comparingDir) {\n                        directed.push(e);\n                    }\n                }\n                var reversedirected = [];\n                for (var j = 0; j < sortedGroup.length; j++) {\n                    var e = sortedGroup[parseInt(j.toString(), 10)];\n                    if (e.direction !== comparingDir) {\n                        reversedirected.push(e);\n                    }\n                }\n                var mutual = [];\n                if (directed.length > 0) {\n                    var temp = directed[0].start;\n                    var j = 0;\n                    while (j < reversedirected.length) {\n                        if (reversedirected[parseInt(j.toString(), 10)].end > temp) {\n                            mutual.push(reversedirected[parseInt(j.toString(), 10)]);\n                            reversedirected.splice(j, 1);\n                        }\n                        else {\n                            j++;\n                        }\n                    }\n                }\n                var mutualRow = [];\n                mutualRow = this.updateSegmentRow(mutual, mutualRow);\n                var directedRow = [];\n                directedRow = [];\n                directedRow = this.updateSegmentRow(reversedirected, directedRow);\n                directed.reverse();\n                directedRow = this.updateSegmentRow(directed, directedRow);\n                if (!(mutualRow[mutualRow.length - 1].length > 0)) {\n                    mutualRow.splice(mutualRow.length - 1, 1);\n                }\n                if (!(directedRow[directedRow.length - 1].length > 0)) {\n                    directedRow.splice(directedRow.length - 1, 1);\n                }\n                var subrow = [];\n                var descAdding = mutual.length > 0 && (sortedGroup[sortedGroup.length - 1].direction\n                    === mutual[mutual.length - 1].direction\n                    || sortedGroup[0].direction === mutual[0].direction);\n                if (descAdding) {\n                    subrow = directedRow;\n                    for (var p = 0; p < mutualRow.length; p++) {\n                        var obj = mutualRow[parseInt(p.toString(), 10)];\n                        subrow[subrow.length] = obj;\n                    }\n                }\n                else {\n                    subrow = mutualRow;\n                    for (var p = 0; p < directedRow.length; p++) {\n                        var obj = directedRow[parseInt(p.toString(), 10)];\n                        subrow[subrow.length] = obj;\n                    }\n                }\n                if (subrow.length > 1) {\n                    var directionModifier = 1;\n                    if (layout.orientation === 'BottomToTop'\n                        || layout.orientation === 'RightToLeft') {\n                        directionModifier = -1;\n                    }\n                    var startCoord = row.key - (directionModifier * avaibaleSpace / 2.0);\n                    var diff = avaibaleSpace / subrow.length;\n                    for (var i = 0; i < subrow.length; i++) {\n                        var newcoord = startCoord + (i * diff * directionModifier);\n                        for (var p = 0; p < subrow[parseInt(i.toString(), 10)].length; p++) {\n                            var obstacleSegment = subrow[parseInt(i.toString(), 10)][parseInt(p.toString(), 10)];\n                            obstacleSegment.coord = newcoord;\n                            if (!this.containsValue(modifiedgrap, obstacleSegment.coord)) {\n                                modifiedgrap.push({ key: obstacleSegment.coord, value: [] });\n                            }\n                            var index_1 = void 0;\n                            for (var k = 0; k < modifiedgrap.length; k++) {\n                                var keyCheck = modifiedgrap[parseInt(k.toString(), 10)].key;\n                                if (keyCheck === obstacleSegment.coord) {\n                                    index_1 = k;\n                                    break;\n                                }\n                            }\n                            modifiedgrap[parseInt(index_1.toString(), 10)].value.push(obstacleSegment);\n                        }\n                    }\n                }\n            }\n        }\n        for (var m = 0; m < connectorObstacles.length; m++) {\n            var connectorObstacle = connectorObstacles[parseInt(m.toString(), 10)];\n            var pts = [];\n            for (var i = 0; i < connectorObstacle.segments.length; i++) {\n                if (i === 0) {\n                    pts.push(this.getObstacleStartPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]));\n                }\n                else if (isHorizontal) {\n                    if (connectorObstacle.segments[parseInt(i.toString(), 10)].orientation === 'vertical') {\n                        pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]);\n                    }\n                }\n                else if (!isHorizontal) {\n                    if (connectorObstacle.segments[parseInt(i.toString(), 10)].orientation === 'horizontal') {\n                        pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]);\n                    }\n                }\n                pts.push(this.getObstacleEndPoint(connectorObstacle.segments[parseInt(i.toString(), 10)]));\n            }\n            /* tslint:disable */\n            connectorObstacle.wrapper[\"\" + obstacleCollection] = [];\n            for (var j = 0; j < pts.length; j++) {\n                var point = pts[parseInt(j.toString(), 10)];\n                if (j === 0 || (j > 0 && !(_primitives_point__WEBPACK_IMPORTED_MODULE_3__.Point.equals(point, pts[j - 1])))) {\n                    connectorObstacle.wrapper[\"\" + obstacleCollection].push(this.getPointvalue(point.x, point.y));\n                }\n            }\n            /* tslint:enable */\n            //EJ2-70198 - The layout ConnectionPointOrigin DifferentPoint property is not working for bezier connector\n            //Bug 851920: Connector overlaps the node in complex hierarchical tree layout. Here the below condition is modified to check connector type.\n            if (connectorObstacle.wrapper.type === 'Orthogonal') {\n                this.resetConnectorPoints(connectorObstacle.wrapper, diagram);\n            }\n        }\n    };\n    //Bug 862601: Connectors are not rendered properly with lineRouting and lineDistribution enables during doLayout process.\n    //To sort the connectors order in graph based on its target point and orientation to avoid connector segments path in same line.\n    LineDistribution.prototype.sortConnectors = function (graph, diagram) {\n        for (var i = 0; i < graph.length; i++) {\n            for (var j = 0; j < graph[parseInt(i.toString(), 10)].value.length; j++) {\n                if (graph[parseInt(i.toString(), 10)].value.length > 1) {\n                    if (diagram.layout.orientation === 'LeftToRight' || diagram.layout.orientation === 'RightToLeft') {\n                        graph[parseInt(i.toString(), 10)].value.sort(function (a, b) {\n                            var connectorA = diagram.nameTable[\"\" + a.id];\n                            var connectorB = diagram.nameTable[\"\" + b.id];\n                            return connectorA.targetPoint.y - connectorB.targetPoint.y;\n                        });\n                    }\n                    else if (diagram.layout.orientation === 'TopToBottom' || diagram.layout.orientation === 'BottomToTop') {\n                        graph[parseInt(i.toString(), 10)].value.sort(function (a, b) {\n                            var connectorA = diagram.nameTable[\"\" + a.id];\n                            var connectorB = diagram.nameTable[\"\" + b.id];\n                            return connectorA.targetPoint.x - connectorB.targetPoint.x;\n                        });\n                    }\n                }\n            }\n        }\n    };\n    //private inflate(rect: Rect, x: number, y: number): Rect {\n    //    rect.x -= x;\n    //    rect.y -= y;\n    //    rect.width += 2 * x;\n    //    rect.height += 2 * y;\n    //    return rect;\n    //}\n    //private updateConnectorPoints(\n    //    connectorPoints: Point[], startSegmentSize: number, intermediatePoint: Point, bounds: object, orientation: string):\n    //    Point[] {\n    //    const layoutBounds: Rect = bounds as Rect;\n    //    const isHorizontal: boolean = orientation === 'LeftToRight' || orientation === 'RightToLeft';\n    //    const pts: Point[] = connectorPoints;\n    //    if (pts.length > 2) {\n    //        const newPt: Point = Point.transform(pts[0], Point.findAngle(pts[0], pts[1]), startSegmentSize) as Point;\n    //        const nextPt: Point = Point.transform(newPt, Point.findAngle(pts[1], pts[2]), Point.findLength(pts[1], pts[2])) as Point;\n    //        pts.splice(1, 2, newPt, nextPt);\n    //        if (intermediatePoint != null) {\n    //            const index: number = 2;\n    //            const ptsCount: number = pts.length;\n    //            const newPt1: Point = Point.transform(\n    //                pts[ptsCount - 1],\n    //                Point.findAngle(pts[ptsCount - 1], pts[ptsCount - 2]),\n    //                startSegmentSize) as Point;\n    //            pts.splice(ptsCount - 1, 0, newPt1);\n    //            while (index < (pts.length - 2)) {\n    //                pts.splice(index, 1);\n    //            }\n    //            const edgePt: Point = intermediatePoint;\n    //            this.inflate((layoutBounds as Rect), (layoutBounds as Rect).width, layoutBounds.height);\n    //            const line1: Point[] = [];\n    //            line1[0] = this.getPointvalue(edgePt.x, layoutBounds.y) as Point;\n    //            line1[1] = this.getPointvalue(edgePt.x, layoutBounds.y + layoutBounds.height) as Point;\n    //            const line2: Point[] = [];\n    //            line2[0] = this.getPointvalue(layoutBounds.x, pts[1].y) as Point;\n    //            line2[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, pts[1].y) as Point;\n    //            const line3: Point[] = [];\n    //            line3[0] = this.getPointvalue(layoutBounds.x, newPt1.y) as Point;\n    //            line3[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, newPt1.y) as Point;\n    //            if (isHorizontal) {\n    //                line1[0] = this.getPointvalue(layoutBounds.x, edgePt.y) as Point;\n    //                line1[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, edgePt.y) as Point;\n    //                line2[0] = this.getPointvalue(pts[1].x, layoutBounds.y) as Point;\n    //                line2[1] = this.getPointvalue(pts[1].x, layoutBounds.y + layoutBounds.height) as Point;\n    //                line3[0] = this.getPointvalue(newPt1.x, layoutBounds.y) as Point;\n    //                line2[1] = this.getPointvalue(newPt1.x, layoutBounds.y + layoutBounds.height) as Point;\n    //            }\n    //            const intercepts1: Point[] = [intersect2(\n    //                line1[0] as Point,\n    //                line1[1] as Point, line2[0] as Point, line2[1] as Point)] as Point[];\n    //            const intercepts2: Point[] = [intersect2(\n    //                line1[0] as Point, line1[1] as Point,\n    //                line3[0] as Point, line3[1] as Point)] as Point[];\n    //            if (intercepts2.length > 0) {\n    //                pts.splice(2, 0, intercepts2[0]);\n    //            }\n    //            if (intercepts1.length > 0) {\n    //                pts.splice(2, 0, intercepts1[0]);\n    //            }\n    //        }\n    //    }\n    //    let i: number = 1;\n    //    while (i < pts.length - 1) {\n    //        if (Point.equals(pts[i - 1], pts[parseInt(i.toString(), 10)])) {\n    //            pts.splice(i, 1);\n    //        } else if (Point.findAngle(pts[i - 1], pts[parseInt(i.toString(), 10)])\n    //            === Point.findAngle(pts[parseInt(i.toString(), 10)], pts[i + 1])) {\n    //            pts.splice(i, 1);\n    //        } else {\n    //            i++;\n    //        }\n    //    }\n    //    return pts;\n    //}\n    /* tslint:disable */\n    LineDistribution.prototype.resetConnectorPoints = function (edge, diagram) {\n        var obstacleCollection = 'obstaclePointCollection';\n        if (edge.segments[0].points\n            && edge.segments[0].points.length > 0 && edge[\"\" + obstacleCollection]) {\n            var connector = edge;\n            connector.sourcePoint = edge[\"\" + obstacleCollection][0];\n            connector.targetPoint = edge[\"\" + obstacleCollection][edge[\"\" + obstacleCollection].length - 1];\n            var segments = void 0;\n            segments = [];\n            for (var i = 0; i < edge[\"\" + obstacleCollection].length - 1; i++) {\n                var point1 = edge[\"\" + obstacleCollection][parseInt(i.toString(), 10)];\n                var point2 = edge[\"\" + obstacleCollection][i + 1];\n                var length_1 = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_1__.findDistance)(point1, point2);\n                var direction = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_1__.getConnectorDirection)(point1, point2);\n                if (i === edge[\"\" + obstacleCollection].length - 2) {\n                    if ((diagram.layout.orientation === 'RightToLeft' && direction === 'Left')\n                        || (diagram.layout.orientation === 'LeftToRight' && direction === 'Right')\n                        || (diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')\n                        || (diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {\n                        length_1 = length_1 / 2;\n                    }\n                }\n                /* tslint:enable */\n                var tempSegment = new _objects_connector__WEBPACK_IMPORTED_MODULE_0__.OrthogonalSegment(edge, 'segments', { type: 'Orthogonal' }, true);\n                tempSegment.length = length_1;\n                tempSegment.direction = direction;\n                segments.push(tempSegment);\n            }\n            connector.segments = segments;\n            connector.type = 'Orthogonal';\n            diagram.connectorPropertyChange(connector, {}, {\n                type: 'Orthogonal',\n                segments: connector.segments\n            });\n        }\n    };\n    LineDistribution.prototype.getObstacleEndPoint = function (segment) {\n        if (segment.orientation === 'horizontal') {\n            if (segment.direction === 'Left') {\n                return this.getPointvalue(segment.start, segment.coord);\n            }\n            return this.getPointvalue(segment.end, segment.coord);\n        }\n        if (segment.direction === 'Top') {\n            return this.getPointvalue(segment.coord, segment.start);\n        }\n        return this.getPointvalue(segment.coord, segment.end);\n    };\n    LineDistribution.prototype.getObstacleStartPoint = function (segment) {\n        if (segment.orientation === 'horizontal') {\n            if (segment.direction === 'Left') {\n                return this.getPointvalue(segment.end, segment.coord);\n            }\n            return this.getPointvalue(segment.start, segment.coord);\n        }\n        if (segment.direction === 'Top') {\n            return this.getPointvalue(segment.coord, segment.end);\n        }\n        return this.getPointvalue(segment.coord, segment.start);\n    };\n    LineDistribution.prototype.updateSegmentRow = function (obstacleSegments, segmentRow) {\n        var k = 0;\n        if (!(segmentRow.length > 0)) {\n            segmentRow[0] = [];\n        }\n        for (var i = 0; i < obstacleSegments.length; i++) {\n            var obstacleSegment = obstacleSegments[parseInt(i.toString(), 10)];\n            while (k < segmentRow.length) {\n                if (k === segmentRow.length - 1) {\n                    segmentRow[k + 1] = [];\n                }\n                if (!(segmentRow[parseInt(k.toString(), 10)].length > 0)\n                    || segmentRow[parseInt(k.toString(), 10)][segmentRow[parseInt(k.toString(), 10)].length - 1].end\n                        < obstacleSegment.start) {\n                    segmentRow[parseInt(k.toString(), 10)].push(obstacleSegment);\n                    break;\n                }\n                k++;\n            }\n        }\n        return segmentRow;\n    };\n    LineDistribution.prototype.portOffsetCalculation = function (port, length, direction, i) {\n        if (direction === 'Top') {\n            port.offset = { x: (i + 1) * (1.0 / (length + 1)), y: 0 };\n        }\n        if (direction === 'Bottom') {\n            port.offset = { x: (i + 1) * (1.0 / (length + 1)), y: 1 };\n        }\n        if (direction === 'Left') {\n            port.offset = { x: 0, y: (i + 1) * (1.0 / (length + 1)) };\n        }\n        if (direction === 'Right') {\n            port.offset = { x: 1, y: (i + 1) * (1.0 / (length + 1)) };\n        }\n    };\n    LineDistribution.prototype.addDynamicPortandDistrrbuteLine = function (layout, node, sourceDirection, targetDirection, diagram) {\n        if ((node.ports && node.ports.length > 0)) {\n            var port = node.ports;\n            diagram.removePorts(node, port);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var existingPorts = node.ports;\n        var outConnectors = node.outEdges;\n        var inConnectors = node.inEdges;\n        this.initPort(outConnectors, diagram, node, sourceDirection, false);\n        this.initPort(inConnectors, diagram, node, targetDirection, true);\n    };\n    /* tslint:disable */\n    LineDistribution.prototype.initPort = function (connectors, diagram, node, targetDirection, inConnectors) {\n        var obstacleCollection = 'obstaclePointCollection';\n        var objects = connectors;\n        // EJ2-61463 - Added below code to sort the objects based on the source node offset position\n        if (connectors.length > 1 && inConnectors) {\n            connectors = this.sortObjects(objects, inConnectors, diagram);\n        }\n        for (var i = 0; i <= connectors.length - 1; i++) {\n            var internalConnector = diagram.nameTable[connectors[parseInt(i.toString(), 10)]];\n            internalConnector[\"\" + obstacleCollection] = [];\n            var newPort = (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_1__.findPort)(node, inConnectors ? internalConnector.targetPortID : internalConnector.sourcePortID);\n            var direction = targetDirection;\n            if (newPort === undefined) {\n                newPort = new _objects_port__WEBPACK_IMPORTED_MODULE_4__.PointPort(node, 'ports', '', true);\n                newPort.id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_2__.randomId)() + '_LineDistribution';\n                if (inConnectors) {\n                    internalConnector.targetPortID = newPort.id;\n                }\n                else {\n                    internalConnector.sourcePortID = newPort.id;\n                }\n            }\n            this.portOffsetCalculation(newPort, connectors.length, direction, i);\n            node.ports.push(newPort);\n            var portWrapper = node.initPortWrapper(node.ports[node.ports.length - 1]);\n            node.wrapper.children.push(portWrapper);\n            // EJ2-66867 -  Exception occurs on calling doLayout while injecting Linerouting module\n            // nodes portWrapper bouds is updated below\n            node.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_5__.Size(node.width, node.height), node.id);\n            node.wrapper.arrange(node.wrapper.desiredSize);\n            diagram.connectorPropertyChange(internalConnector, inConnectors ? { targetPortID: '' } : { sourcePortID: '' }, \n            // eslint-disable-next-line\n            inConnectors ? { targetPortID: newPort.id } : { sourcePortID: newPort.id });\n        }\n    };\n    /* tslint:enable */\n    //EJ2-61463 - Method used to sort the connectors based on the source node offset position\n    LineDistribution.prototype.sortObjects = function (objects, inConnectors, diagram) {\n        var temp;\n        for (var i = 0; i < objects.length; i++) {\n            for (var j = i + 1; j < objects.length; j++) {\n                var internalConnector = diagram.nameTable[objects[parseInt(i.toString(), 10)]];\n                var internalConnector2 = diagram.nameTable[objects[parseInt(j.toString(), 10)]];\n                if (inConnectors) {\n                    var childNode = diagram.nameTable[internalConnector.sourceID];\n                    var childNode2 = diagram.nameTable[internalConnector2.sourceID];\n                    // For LeftToRight and RightToLeft we want to consider source node offsetY position\n                    if (diagram.layout.orientation === 'LeftToRight' || diagram.layout.orientation === 'RightToLeft') {\n                        if (childNode.offsetY > childNode2.offsetY) {\n                            temp = objects[parseInt(i.toString(), 10)];\n                            objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];\n                            objects[parseInt(j.toString(), 10)] = temp;\n                        }\n                    }\n                    else {\n                        // For TopToBottom or BottomToTop means we want to consider source node offsetX position\n                        if (childNode.offsetX > childNode2.offsetX) {\n                            temp = objects[parseInt(i.toString(), 10)];\n                            objects[parseInt(i.toString(), 10)] = objects[parseInt(j.toString(), 10)];\n                            objects[parseInt(j.toString(), 10)] = temp;\n                        }\n                    }\n                }\n            }\n        }\n        return objects;\n    };\n    //private shiftMatrixCells(\n    //    value: number, startingCell: MatrixCellGroupObject, shiftChildren: boolean,\n    //    parentCell: MatrixCellGroupObject, matrixModel: MatrixModelObject):\n    //    void {\n    //    if (!(value === 0)) {\n    //        const matrix: MatrixObject[] = matrixModel.matrix;\n    //        const matrixRow: MatrixCellGroupObject[] = matrix[startingCell.level].value;\n    //        const index: number = matrixRow.indexOf(startingCell);\n    //        for (let i: number = index; i < matrixRow.length; i++) {\n    //            matrixRow[parseInt(i.toString(), 10)].offset += value;\n    //        }\n    //        if (shiftChildren) {\n    //            if (startingCell.visitedChildren.length > 0) {\n    //                this.shiftMatrixCells(\n    //                    value,\n    //                    startingCell.visitedChildren[0],\n    //                    true,\n    //                    startingCell,\n    //                    matrixModel);\n    //            } else {\n    //                let i: number = 1;\n    //                let nextSibilingwithChild: MatrixCellGroupObject = null;\n    //                while (index + i < matrixRow.length) {\n    //                    const nextCell: MatrixCellGroupObject = matrixRow[index + i];\n    //                    if (parentCell != null && this.containsValue(nextCell.visitedParents, parentCell)) {\n    //                        if (nextCell.visitedChildren.length > 0) {\n    //                            nextSibilingwithChild = nextCell;\n    //                        } else {\n    //                            i++;\n    //                            continue;\n    //                        }\n    //                    }\n    //                    break;\n    //                }\n    //                if (nextSibilingwithChild != null) {\n    //                    this.shiftMatrixCells(\n    //                        value,\n    //                        nextSibilingwithChild.visitedChildren[0],\n    //                        true,\n    //                        nextSibilingwithChild,\n    //                        matrixModel);\n    //                }\n    //            }\n    //        }\n    //    }\n    //}\n    //private arrangeMatrix(cell: MatrixCellGroupObject, parent: MatrixCellGroupObject, matrixModel: MatrixModelObject): void {\n    //    const layoutSettings: LayoutProp = matrixModel.model.layout;\n    //    const isHorizontal: boolean = layoutSettings.orientation === 'LeftToRight'\n    //        || layoutSettings.orientation === 'RightToLeft';\n    //    const spacing: number = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    //    const matrix: MatrixObject[] = matrixModel.matrix;\n    //    const matrixRow: MatrixCellGroupObject[] = matrix[cell.level].value;\n    //    const matrixIndex: number = matrixRow.indexOf(cell);\n    //    if (cell.visitedParents.length > 0) {\n    //        if (cell.visitedParents.length === 1) {\n    //            cell.initialOffset = cell.offset;\n    //        }\n    //        if (matrixIndex + 1 < matrixRow.length) {\n    //            const nextCell: MatrixCellGroupObject = matrixRow[matrixIndex + 1];\n    //            if (nextCell.visitedParents.length > 0) {\n    //                if (!this.containsValue(cell.visitedParents, parent)) {\n    //                    cell.visitedParents.push(parent);\n    //                    parent.ignoredChildren.push(cell);\n    //                    return;\n    //                }\n    //            }\n    //        }\n    //    }\n    //    if (!(cell.children.length > 0)) {\n    //        let validOffset: number = cell.offset;\n    //        if (matrixIndex > 0) {\n    //            const prevCell: MatrixCellGroupObject = matrixRow[matrixIndex - 1];\n    //            validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n    //        }\n    //        this.shiftMatrixCells(validOffset - cell.offset, cell, false, null, matrixModel);\n    //    } else {\n    //        for (let i: number = 0; i < cell.children.length; i++) {\n    //            const matrixCellChild: MatrixCellGroupObject = cell.children[parseInt(i.toString(), 10)];\n    //            if (!this.containsValue(cell.visitedChildren, matrixCellChild)) {\n    //                this.arrangeMatrix(matrixCellChild, cell, matrixModel);\n    //                cell.visitedChildren.push(matrixCellChild);\n    //            }\n    //        }\n    //        if (cell.visitedChildren.length > 0) {\n    //            const children: MatrixCellGroupObject[] = cell.visitedChildren.slice();\n    //            for (let i: number = 0; i < cell.ignoredChildren.length; i++) {\n    //                //let cellIgnoredChild: MatrixCellGroupObject = cell.ignoredChildren[i];\n    //                children.splice(0, 1);\n    //                cell.visitedChildren.splice(0, 1);\n    //            }\n    //            if (children.length > 0) {\n    //                const firstChild: MatrixCellGroupObject = cell.visitedChildren[0];\n    //                const lastChild: MatrixCellGroupObject = cell.visitedChildren[cell.visitedChildren.length - 1];\n    //                const x1: number = firstChild.offset - (firstChild.size / 2);\n    //                const x2: number = lastChild.offset + (lastChild.size / 2);\n    //                const newoffset: number = (x1 + x2) / 2;\n    //                if (newoffset < cell.offset) {\n    //                    this.shiftMatrixCells(cell.offset - newoffset, firstChild, true, cell, matrixModel);\n    //                } else if (newoffset > cell.offset) {\n    //                    this.shiftMatrixCells(newoffset - cell.offset, cell, false, null, matrixModel);\n    //                }\n    //            }\n    //        }\n    //    }\n    //    if (!this.containsValue(cell.visitedParents, parent)) {\n    //        cell.visitedParents.push(parent);\n    //    }\n    //}\n    /** @private */\n    LineDistribution.prototype.resetConnectorSegments = function (connector) {\n        var segements = connector.segments;\n        for (var i = segements.length; i > 0; i--) {\n            segements.splice(i - 1, 1);\n        }\n    };\n    /* tslint:disable */\n    /** @private */\n    LineDistribution.prototype.resetRoutingSegments = function (connector, diagram, points) {\n        if (connector['levelSkip']) {\n            //Bug 877799: Optimize the routing segment distance while using enableRouting in layout.\n            var sourceLevel = void 0;\n            var targetLevel = void 0;\n            var collection = diagram.layout.ranks.reverse();\n            //To find the source level and target level of the level skip connector\n            for (var i = 0; i < collection.length; i++) {\n                for (var j = 0; j < collection[parseInt(i.toString(), 10)].length; j++) {\n                    if (connector.sourceID === collection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].id) {\n                        sourceLevel = i;\n                    }\n                    if (connector.targetID === collection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].id) {\n                        targetLevel = i;\n                    }\n                }\n            }\n            // To find the overlapping collection between the source and target level\n            var overlappCollection = [];\n            if (sourceLevel < targetLevel) {\n                for (var i = 0; i < collection.length; i++) {\n                    if (i > sourceLevel && i < targetLevel) {\n                        overlappCollection.push(collection[parseInt(i.toString(), 10)]);\n                    }\n                }\n            }\n            else {\n                for (var i = 0; i < collection.length; i++) {\n                    if (i < sourceLevel && i > targetLevel) {\n                        overlappCollection.push(collection[parseInt(i.toString(), 10)]);\n                    }\n                }\n            }\n            // To find the overlapping nodes between the source and target level\n            var overLapNodesCollection = [];\n            for (var i = 0; i < overlappCollection.length; i++) {\n                for (var j = 0; j < overlappCollection[parseInt(i.toString(), 10)].length; j++) {\n                    if (overlappCollection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].edges === undefined) {\n                        var node = diagram.nameTable[overlappCollection[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].id];\n                        overLapNodesCollection.push(node);\n                    }\n                }\n            }\n            var isInsideBounds = false;\n            if (!diagram.routingConnectors) {\n                diagram.routingConnectors = [];\n            }\n            //To find whether the connector is overlapping with the nodes in the overlapping collection.\n            // eslint-disable-next-line no-labels\n            overlapping: for (var count = 0; count < overLapNodesCollection.length; count++) {\n                var bounds = overLapNodesCollection[parseInt(count.toString(), 10)].wrapper.bounds;\n                for (var i = 0; i < connector.segments.length; i++) {\n                    var points_1 = connector.segments[parseInt(i.toString(), 10)].points;\n                    for (var j = 0; j < points_1.length; j++) {\n                        var lineStart = points_1[parseInt(j.toString(), 10)];\n                        var lineEnd = points_1[j + 1];\n                        if (lineEnd) {\n                            var connectorPoints = this.pointsAlongLine(lineStart, lineEnd);\n                            isInsideBounds = this.pointInsideBounds(connectorPoints, bounds);\n                            if (isInsideBounds) {\n                                diagram.routingConnectors.push(connector);\n                                // eslint-disable-next-line no-labels\n                                break overlapping;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Calculates points along a line between two given points.\n     *  @param start The starting point of the line.\n     *  @param end The ending point of the line.\n     *  @return An array of points along the line.\n     */\n    LineDistribution.prototype.pointsAlongLine = function (start, end) {\n        var granularity = 1;\n        var dx = end.x - start.x;\n        var dy = end.y - start.y;\n        var length = Math.sqrt(dx * dx + dy * dy);\n        var stepX = (dx / length) * granularity;\n        var stepY = (dy / length) * granularity;\n        var points = [];\n        for (var i = 0; i <= length; i += granularity) {\n            points.push({ x: start.x + stepX * i, y: start.y + stepY * i });\n        }\n        return points;\n    };\n    /**\n     *\n     * Checks if any of the given points fall inside the specified bounding rectangle.\n     *  @param points An array of points to be checked.\n     *  @param bounds The bounding rectangle to check against.\n     *  @return True if any point is inside the bounds, false otherwise.\n     */\n    LineDistribution.prototype.pointInsideBounds = function (points, bounds) {\n        var padding = 10;\n        for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {\n            var point = points_2[_i];\n            if (bounds.right > point.x &&\n                bounds.left < point.x &&\n                bounds.top < point.y &&\n                bounds.bottom > point.y) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /* tslint:enable */\n    /** @private */\n    //public arrangeElements(matrixModel: MatrixModelObject, layout: Layout): void {\n    //    const layoutSettings: LayoutProp = matrixModel.model.layout;\n    //    let isHorizontal: boolean;\n    //    if (layout.orientation === 'LeftToRight' || layout.orientation === 'RightToLeft') {\n    //        isHorizontal = true;\n    //    } else {\n    //        isHorizontal = false;\n    //    }\n    //    const spacing: number = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    //    //let spacingInverse: number = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    //    // Need to group element before\n    //    this.groupLayoutCells(matrixModel);\n    //    this.createMatrixCells(matrixModel);\n    //    for (let j: number = 0; j < matrixModel.matrix.length; j++) {\n    //        const matrixKey: number = matrixModel.matrix[parseInt(j.toString(), 10)].key;\n    //        const matrixrow: MatrixCellGroupObject[] = matrixModel.matrix[parseInt(matrixKey.toString(), 10)].value;\n    //        for (let i: number = 1; i < matrixrow.length; i++) {\n    //            const cell: MatrixCellGroupObject = matrixrow[parseInt(i.toString(), 10)];\n    //            const prevCell: MatrixCellGroupObject = matrixrow[i - 1];\n    //            cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n    //        }\n    //    }\n    //    for (let j: number = 0; j < matrixModel.matrix[0].value.length; j++) {\n    //        const root: MatrixCellGroupObject = matrixModel.matrix[0].value[parseInt(j.toString(), 10)];\n    //        this.arrangeMatrix(root, null, matrixModel);\n    //    }\n    //    for (let k: number = 0; k < matrixModel.matrix.length; k++) {\n    //        const row: MatrixCellGroupObject[] = matrixModel.matrix[parseInt(k.toString(), 10)].value;\n    //        for (let i: number = 0; i < row.length; i++) {\n    //            const cell: MatrixCellGroupObject = row[parseInt(i.toString(), 10)];\n    //            if (cell.visitedParents.length > 1) {\n    //                let firstParent: MatrixCellGroupObject = cell.visitedParents[0];\n    //                let lastParent: MatrixCellGroupObject = cell.visitedParents[cell.visitedParents.length - 1];\n    //                const firstVertexParent: MatrixCellGroupObject = this.findParentVertexCellGroup(firstParent);\n    //                const lastVertexParent: MatrixCellGroupObject = this.findParentVertexCellGroup(lastParent);\n    //                if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {\n    //                    firstParent = firstVertexParent;\n    //                }\n    //                if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {\n    //                    lastParent = firstVertexParent;\n    //                }\n    //                const newoffset: number = (firstParent.offset + lastParent.offset) / 2;\n    //                const availOffsetMin: number = cell.initialOffset;\n    //                const availOffsetMax: number = cell.offset;\n    //                if (!(availOffsetMax === availOffsetMin)) {\n    //                    if (newoffset >= availOffsetMin && newoffset <= availOffsetMax) {\n    //                        this.translateMatrixCells(newoffset - cell.offset, cell);\n    //                    } else if (newoffset < availOffsetMin) {\n    //                        this.translateMatrixCells(availOffsetMin - cell.offset, cell);\n    //                    }\n    //                }\n    //            }\n    //        }\n    //    }\n    //    this.setXYforMatrixCell(matrixModel);\n    //}\n    //private findParentVertexCellGroup(cell: MatrixCellGroupObject): MatrixCellGroupObject {\n    //    if (cell.cells[0]) {\n    //        return cell;\n    //    }\n    //    if (cell.parents.length > 0) {\n    //        return this.findParentVertexCellGroup(cell.parents[0]);\n    //    }\n    //    return cell;\n    //}\n    //private setXYforMatrixCell(matrixModel: MatrixModelObject): void {\n    //    const layoutSettings: LayoutProp = matrixModel.model.layout;\n    //    const isHorizontal: boolean = layoutSettings.orientation === 'LeftToRight'\n    //        || layoutSettings.orientation === 'RightToLeft';\n    //    const spacing: number = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    //    for (let i: number = 0; i < matrixModel.matrix.length; i++) {\n    //        const matrixrow1: MatrixCellGroupObject[] = matrixModel.matrix[parseInt(i.toString(), 10)].value;\n    //        for (let j: number = 0; j < matrixrow1.length; j++) {\n    //            const matrixCell: MatrixCellGroupObject = matrixrow1[parseInt(j.toString(), 10)];\n    //            let start: number = matrixCell.offset - (matrixCell.size / 2);\n    //            for (let k: number = 0; k < (matrixCell.cells as CellObject[]).length; k++) {\n    //                const cell: CellObject = matrixCell.cells[parseInt(k.toString(), 10)];\n    //                const type: string = this.getType(cell.type);\n    //                if (type === 'internalVertex') {\n    //                    const internalVertex: CellObject = cell;\n    //                    const width: number = internalVertex.cell.geometry.width;\n    //                    const height: number = internalVertex.cell.geometry.height;\n    //                    if (isHorizontal) {\n    //                        internalVertex.cell.geometry = new Rect(\n    //                            matrixModel.rowOffset[matrixCell.level] - (width / 2),\n    //                            start,\n    //                            width,\n    //                            height) as Rect;\n    //                    } else {\n    //                        internalVertex.cell.geometry = new Rect(\n    //                            start,\n    //                            matrixModel.rowOffset[matrixCell.level] - (height / 2),\n    //                            width,\n    //                            height) as Rect;\n    //                    }\n    //                    start += (isHorizontal ? height : width) + spacing;\n    //                } else if (type === 'internalEdge') {\n    //                    const internalEdges: CellObject = cell;\n    //                    const parent: MatrixCellGroupObject = matrixCell.visitedParents[0];\n    //                    let isContainSibilingVertex: boolean = false;\n    //                    if (parent) {\n    //                        for (let l: number = 0; l < parent.visitedChildren.length; l++) {\n    //                            const children: MatrixCellGroupObject = parent.visitedChildren[parseInt(l.toString(), 10)];\n    //                            const cells: CellObject[] = [];\n    //                            for (let m: number = 0; m < (children.cells as CellObject[]).length; m++) {\n    //                                const cell: CellObject = children.cells[parseInt(m.toString(), 10)];\n    //                                const type: string = this.getType(cell.type);\n    //                                if (type === 'internalVertex') {\n    //                                    cells.push(cell);\n    //                                }\n    //                            }\n    //                            if (cells.length > 0) {\n    //                                isContainSibilingVertex = true;\n    //                                break;\n    //                            }\n    //                        }\n    //                    }\n    //                    // Need to updated line width\n    //                    const lineWidth: number = 1;\n    //                    const edgeSpacing: number = 5;\n    //                    for (let m: number = 0; m < internalEdges.edges.length; m++) {\n    //                        const internalConnector: Connector = internalEdges.edges[parseInt(m.toString(), 10)];\n    //                        let pt: Point = this.getPointvalue(start + (lineWidth / 2.0), matrixModel.rowOffset[matrixCell.level]) as Point;\n    //                        if (isHorizontal) {\n    //                            pt = this.getPointvalue(matrixModel.rowOffset[matrixCell.level], start + (lineWidth / 2.0)) as Point;\n    //                        }\n    //                        if (this.containsValue((this.getEdgeMapper() as EdgeMapperObject[]), internalConnector)) {\n    //                            let key: number;\n    //                            for (let l: number = 0; l < this.getEdgeMapper().length; l++) {\n    //                                if ((this.getEdgeMapper())[parseInt(l.toString(), 10)].key === internalConnector) {\n    //                                    key = l;\n    //                                    break;\n    //                                }\n    //                            }\n    //                            (this.getEdgeMapper())[parseInt(key.toString(), 10)].value.push(pt as Point);\n    //                        }\n    //                        start += lineWidth + edgeSpacing;\n    //                    }\n    //                    start += spacing;\n    //                }\n    //            }\n    //        }\n    //    }\n    //}\n    //private getEdgeMapper(): EdgeMapperObject[] {\n    //    return this.edgeMapper;\n    //}\n    ///** @private */\n    //public setEdgeMapper(value: EdgeMapperObject): void {\n    //    this.edgeMapper.push(value);\n    //}\n    //private translateMatrixCells(value: number, cell: MatrixCellGroupObject): void {\n    //    if (!(value === 0)) {\n    //        cell.offset += value;\n    //        if (cell.visitedChildren.length > 0) {\n    //            for (let i: number = 0; i < cell.visitedChildren.length; i++) {\n    //                let cellVisitedChild: MatrixCellGroupObject = cell.visitedChildren[parseInt(i.toString(), 10)];\n    //                this.translateMatrixCells(value, cellVisitedChild);\n    //            }\n    //        }\n    //    }\n    //}\n    //private groupLayoutCells(matrixModel: MatrixModelObject): void {\n    //    let ranks: IVertex[][] = matrixModel.model.ranks;\n    //    for (let j: number = ranks.length - 1; j >= 0; j--) {\n    //        let vertices: IVertex[] = [];\n    //        for (let v: number = 0; v < ranks[parseInt(j.toString(), 10)].length; v++) {\n    //            let rank: IVertex = ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)];\n    //            let type: string = this.getType(rank.type);\n    //            if (type === 'internalVertex') {\n    //                vertices.push(ranks[parseInt(j.toString(), 10)][parseInt(v.toString(), 10)]);\n    //            }\n    //        }\n    //        let edges: IVertex[] = [];\n    //        for (let e: number = 0; e < ranks[parseInt(j.toString(), 10)].length; e++) {\n    //            let rank: IVertex = ranks[parseInt(j.toString(), 10)][parseInt(e.toString(), 10)];\n    //            let type: string = this.getType(rank.type);\n    //            if (type === 'internalEdge') {\n    //                edges.push(rank);\n    //            }\n    //        }\n    //        while (vertices.length > 1) {\n    //            const vertex1: IVertex = vertices[0];\n    //            const parentset1: string[] = this.selectIds(vertex1.connectsAsTarget, true);\n    //            const childset1: string[] = this.selectIds(vertex1.connectsAsSource, false);\n    //            while (vertices.length > 1) {\n    //                const vertex2: IVertex = vertices[1];\n    //                const parentset2: string[] = this.selectIds(vertex2.connectsAsTarget, true);\n    //                const childset2: string[] = this.selectIds(vertex2.connectsAsSource, false);\n    //                const parentequals: boolean = this.compareLists(parentset1, parentset2);\n    //                const childequals: boolean = this.compareLists(childset1, childset2);\n    //                if (parentequals && childequals) {\n    //                    this.updateMutualSharing(vertices[0], vertex2.id);\n    //                    this.updateMutualSharing(vertices[1], vertex1.id);\n    //                    vertices.splice(1, 1);\n    //                    continue;\n    //                }\n    //                break;\n    //            }\n    //            vertices.splice(0, 1);\n    //        }\n    //        while (edges.length > 1) {\n    //            const internalEdge: IVertex = edges[0];\n    //            const parentset: IVertex = internalEdge.source;\n    //            const childset: IVertex = internalEdge.target;\n    //            if (parentset.identicalSibiling != null) {\n    //                const groupedges: IVertex[] = [];\n    //                for (let i: number = 0; i < edges.length; i++) {\n    //                    const edge: IVertex = edges[parseInt(i.toString(), 10)];\n    //                    if (edge.target === childset) {\n    //                        groupedges.push(edge);\n    //                    }\n    //                }\n    //                for (let i: number = 0; i < groupedges.length; i++) {\n    //                    const internalEdgese: IVertex = groupedges[parseInt(i.toString(), 10)];\n    //                    if (this.containsValue(parentset.identicalSibiling, internalEdgese.source.id)) {\n    //                        internalEdgese.source.identicalSibiling = null;\n    //                    }\n    //                }\n    //                internalEdge.source.identicalSibiling = null;\n    //            }\n    //            edges.splice(0, 1);\n    //        }\n    //    }\n    //}\n    //private getType(type: string): string {\n    //    if (type === 'internalVertex') {\n    //        return 'internalVertex';\n    //    } else {\n    //        return 'internalEdge';\n    //    }\n    //}\n    //private selectIds(node: IEdge[], source: boolean): string[] {\n    //    const returnIds: string[] = [];\n    //    for (let i: number = 0; i < node.length; i++) {\n    //        const connector: IEdge = node[parseInt(i.toString(), 10)];\n    //        if (source) {\n    //            {\n    //                returnIds.push(connector.source.id);\n    //            }\n    //        } else {\n    //            returnIds.push(connector.target.id);\n    //        }\n    //    }\n    //    return returnIds;\n    //}\n    //private compareLists(list1: string[], list2: string[]): boolean {\n    //    const newList1: string[] = list1.slice();\n    //    const newList2: string[] = list2.slice();\n    //    if (newList1.length === newList2.length) {\n    //        if (newList1.length === 0) {\n    //            return true;\n    //        } else {\n    //            let isSame: boolean = true;\n    //            for (let i: number = 0; i < newList2.length; i++) {\n    //                const o: string = newList2[parseInt(i.toString(), 10)];\n    //                // EJ2-63944 - Nodes overlapping in Complex hierarchical tree layout in linear arrangement.\n    //                if (newList1.indexOf(o) === -1)\n    //                {\n    //                    isSame = false;\n    //                    break;\n    //                }\n    //            }\n    //            return isSame;\n    //        }\n    //    }\n    //    return false;\n    //}\n    //private updateMutualSharing(cell: IVertex, id: string): void {\n    //    if (cell.identicalSibiling != null) {\n    //        cell.identicalSibiling.push(id);\n    //    } else {\n    //        cell.identicalSibiling = [];\n    //        cell.identicalSibiling.push(id);\n    //    }\n    //}\n    //private matrixCellGroup(options: MatrixCellGroupObject): MatrixCellGroupObject {\n    //    options.level = options.level;\n    //    options.parents = options.parents;\n    //    options.children = options.children;\n    //    options.visitedChildren = options.visitedChildren;\n    //    options.visitedParents = options.visitedParents;\n    //    options.ignoredChildren = options.ignoredChildren;\n    //    options.cells = options.cells;\n    //    options.offset = options.offset;\n    //    options.initialOffset = options.initialOffset;\n    //    return options;\n    //}\n    LineDistribution.prototype.getPointvalue = function (x, y) {\n        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };\n    };\n    LineDistribution.prototype.containsValue = function (list, keyValue) {\n        for (var i = 0; i < list.length; i++) {\n            if (list[parseInt(i.toString(), 10)] === keyValue) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return LineDistribution;\n}());\n\n///** @private */\n//interface ConnectsAsSourceObject {\n//    id: string[];\n//    source: ConnectsAsSourceObject;\n//    target: ConnectsAsSourceObject;\n//    temp: number[];\n//    x: number[];\n//    y: number[];\n//}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-distribution.js?");

/***/ })

}]);