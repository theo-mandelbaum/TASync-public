"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_data-binding_data-binding_js-4318ad04"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/data-binding/data-binding.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/data-binding/data-binding.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataBinding: () => (/* binding */ DataBinding)\n/* harmony export */ });\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _objects_connector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../objects/connector */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _utility_diagram_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utility/diagram-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/diagram-util.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n\n\n\n\n\n\n\n/**\n * data source defines the basic unit of diagram\n */\nvar DataBinding = /** @class */ (function () {\n    /**\n     * Constructor for the data binding module.\n     * @private\n     */\n    function DataBinding() {\n        /**   @private  */\n        this.dataTable = {};\n        //constructs the data binding module\n    }\n    /**\n     * To destroy the data binding module\n     *\n     * @returns {void}\n     * @private\n     */\n    DataBinding.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    DataBinding.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'DataBinding';\n    };\n    /**\n     * Initialize nodes and connectors when we have a data as JSON\n     *\n     * @param {DataSourceModel} data\n     * @param {Diagram} diagram\n     * @private\n     */\n    DataBinding.prototype.initData = function (data, diagram) {\n        var dataSource;\n        var dataProp = 'data';\n        var jsonProp = 'json';\n        var dataManager = data.dataManager || data.dataSource || {};\n        dataSource = dataManager[\"\" + dataProp] || dataManager[\"\" + jsonProp] ||\n            (dataManager.dataSource ? dataManager.dataSource.json : undefined);\n        if (dataSource && dataSource.length === 0 && dataManager.dataSource.data) {\n            dataSource = dataManager.dataSource.data;\n        }\n        if (dataSource && dataSource.length) {\n            this.applyDataSource(data, dataSource, diagram);\n            diagram.trigger('dataLoaded', { diagram: ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_5__.isBlazor)()) ? null : (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_4__.cloneBlazorObject)(diagram) });\n        }\n    };\n    /**\n     * Initialize nodes and connector when we have a data as remote url\n     *\n     * @param {DataSourceModel} data\n     * @param {Diagram} diagram\n     * @private\n     */\n    DataBinding.prototype.initSource = function (data, diagram) {\n        var _this = this;\n        var dataSource = data;\n        var result;\n        var mapper = data;\n        if (dataSource.dataManager instanceof _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_2__.DataManager || dataSource.dataSource instanceof _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_2__.DataManager) {\n            var tempObj = mapper.dataManager || mapper.dataSource;\n            var query = tempObj.defaultQuery || new _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_2__.Query();\n            var dataManager = data.dataManager || data.dataSource;\n            dataManager.executeQuery(query).then(function (e) {\n                var prop = 'result';\n                result = e[\"\" + prop];\n                if (!diagram.isDestroyed) {\n                    diagram.protectPropertyChange(true);\n                    _this.applyDataSource(data, result, diagram);\n                    diagram.refreshDiagram();\n                    diagram.protectPropertyChange(false);\n                    diagram.trigger('dataLoaded', { diagram: ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_5__.isBlazor)()) ? null : (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_4__.cloneBlazorObject)(diagram) });\n                }\n            });\n        }\n    };\n    DataBinding.prototype.applyDataSource = function (mapper, data, diagram) {\n        this.dataTable = {};\n        var obj;\n        var firstNode;\n        var node;\n        var rootNodes = [];\n        var firstLevel = [];\n        var item;\n        var nextLevel;\n        if (data !== undefined) {\n            for (var r = 0; r < data.length; r++) {\n                obj = data[parseInt(r.toString(), 10)];\n                //832886 - Rendering layout without case sensitivity\n                if (obj[mapper.parentId] === undefined || obj[mapper.parentId] === null ||\n                    typeof obj[mapper.parentId] !== 'object') {\n                    if (isNaN(obj[mapper.parentId]) && obj[mapper.parentId] !== undefined) {\n                        if (rootNodes[obj[mapper.parentId] ? obj[mapper.parentId].toLowerCase() : obj[mapper.parentId]] !== undefined) {\n                            rootNodes[obj[mapper.parentId].toLowerCase()].items.push(obj);\n                        }\n                        else {\n                            rootNodes[obj[mapper.parentId] ? obj[mapper.parentId].toLowerCase() : obj[mapper.parentId]] = { items: [obj] };\n                        }\n                    }\n                    else {\n                        if (rootNodes[obj[mapper.parentId]] !== undefined) {\n                            rootNodes[obj[mapper.parentId]].items.push(obj);\n                        }\n                        else {\n                            rootNodes[obj[mapper.parentId]] = { items: [obj] };\n                        }\n                    }\n                }\n                else {\n                    rootNodes = this.updateMultipleRootNodes(obj, rootNodes, mapper, data);\n                }\n                if (mapper.root && isNaN(mapper.root) && obj[mapper.id] && isNaN(obj[mapper.id])) {\n                    if ((mapper.root).toLowerCase() === obj[mapper.id].toLowerCase()) {\n                        firstNode = { items: [obj] };\n                    }\n                }\n                else {\n                    if (mapper.root === obj[mapper.id]) {\n                        firstNode = { items: [obj] };\n                    }\n                }\n            }\n            if (firstNode) {\n                firstLevel.push(firstNode);\n            }\n            else {\n                for (var _i = 0, _a = Object.keys(rootNodes); _i < _a.length; _i++) {\n                    var n = _a[_i];\n                    if (!n || n === 'undefined' || n === '\\'\\'' || n === 'null') {\n                        firstLevel.push(rootNodes[\"\" + n]);\n                    }\n                }\n            }\n            for (var i = 0; i < firstLevel.length; i++) {\n                for (var j = 0; j < firstLevel[parseInt(i.toString(), 10)].items.length; j++) {\n                    item = firstLevel[parseInt(i.toString(), 10)].items[parseInt(j.toString(), 10)];\n                    node = this.applyNodeTemplate(mapper, item, diagram);\n                    diagram.nodes.push(node);\n                    if (isNaN(item[mapper.id]) && item[mapper.id] !== undefined) {\n                        this.dataTable[item[mapper.id].toLowerCase()] = node;\n                    }\n                    else {\n                        this.dataTable[item[mapper.id]] = node;\n                    }\n                    if (isNaN(node.data[mapper.id]) && node.data[mapper.id] !== undefined) {\n                        nextLevel = rootNodes[node.data[mapper.id].toLowerCase()];\n                    }\n                    else {\n                        nextLevel = rootNodes[node.data[mapper.id]];\n                    }\n                    if (nextLevel !== undefined) {\n                        this.renderChildNodes(mapper, nextLevel, node.id, rootNodes, diagram);\n                    }\n                }\n            }\n        }\n        this.dataTable = null;\n    };\n    /**\n     * updateMultipleRootNodes method is used  to update the multiple Root Nodes\n     *\n     * @param {Object} object\n     * @param {Object[]} rootnodes\n     * @param {DataSourceModel} mapper\n     * @param {Object[]} data\n     */\n    DataBinding.prototype.updateMultipleRootNodes = function (obj, rootNodes, mapper, data) {\n        var parents = obj[mapper.parentId];\n        var parent;\n        for (var i = 0; i < parents.length; i++) {\n            if (parents[parseInt(i.toString(), 10)]) {\n                if (isNaN(parents[parseInt(i.toString(), 10)])) {\n                    parent = (parents[parseInt(i.toString(), 10)]).toLowerCase();\n                }\n                else {\n                    parent = (parents[parseInt(i.toString(), 10)]);\n                }\n                if (rootNodes[\"\" + parent]) {\n                    rootNodes[\"\" + parent].items.push(obj);\n                }\n                else {\n                    rootNodes[\"\" + parent] = { items: [obj] };\n                }\n            }\n            else {\n                parent = parents[parseInt(i.toString(), 10)];\n                if (rootNodes[\"\" + parent]) {\n                    rootNodes[\"\" + parent].items.push(obj);\n                }\n                else {\n                    rootNodes[\"\" + parent] = { items: [obj] };\n                }\n            }\n        }\n        return rootNodes;\n    };\n    /**\n     *  Get the node values\\\n     *\n     * @returns { Node }    Get the node values.\\\n     * @param {DataSourceModel} mapper - provide the id value.\n     * @param {Object} item - provide the id value.\n     * @param {Diagram} diagram - provide the id value.\n     *\n     * @private\n     */\n    DataBinding.prototype.applyNodeTemplate = function (mapper, item, diagram) {\n        //const root: Object = item;\n        var id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)();\n        //const blazor: string = 'Blazor';\n        var nodeModel = { id: id, data: item };\n        //Task 895538: Flow-chart layout support for EJ2 diagram.\n        //Added below code to set node shape and style based on the data.\n        if (diagram.layout.type === 'Flowchart') {\n            var shape = this.getFlowChartNodeShape(item);\n            var style = { fill: item.color ? item.color : 'white',\n                strokeColor: item.stroke ? item.stroke : 'black',\n                strokeWidth: item.strokeWidth ? item.strokeWidth : 1\n            };\n            nodeModel.shape = shape;\n            nodeModel.style = style;\n            nodeModel.annotations = [{ content: item.name ? item.name : '' }];\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        var doBinding = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.getFunction)(mapper.doBinding);\n        if (doBinding) {\n            doBinding(nodeModel, item, diagram);\n        }\n        var obj = new _objects_node__WEBPACK_IMPORTED_MODULE_0__.Node(diagram, 'nodes', nodeModel, true);\n        (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_4__.updateDefaultValues)(obj, nodeModel, diagram.nodeDefaults);\n        if (mapper.dataMapSettings) {\n            var index = void 0;\n            var arrayProperty = [];\n            var innerProperty = [];\n            for (var i = 0; i < mapper.dataMapSettings.length; i++) {\n                if (mapper.dataMapSettings[parseInt(i.toString(), 10)].property.indexOf('.') !== -1) {\n                    innerProperty = this.splitString(mapper.dataMapSettings[parseInt(i.toString(), 10)].property);\n                    for (var p = 0; p < innerProperty.length; p++) {\n                        if (innerProperty[parseInt(p.toString(), 10)].indexOf('[') !== -1) {\n                            index = innerProperty[parseInt(p.toString(), 10)].indexOf('[');\n                            arrayProperty = innerProperty[parseInt(p.toString(), 10)].split('[');\n                        }\n                    }\n                    if (index) {\n                        if (innerProperty[2]) {\n                            obj[arrayProperty[0]][innerProperty[0].charAt(index + 1)][innerProperty[1]][innerProperty[2]] =\n                                item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];\n                        }\n                        else {\n                            var value = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];\n                            obj[arrayProperty[0]][innerProperty[0].charAt(index + 1)][innerProperty[1]] = value;\n                        }\n                    }\n                    else {\n                        if (innerProperty[2]) {\n                            obj[innerProperty[0]][innerProperty[1]][innerProperty[2]]\n                                = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];\n                        }\n                        else {\n                            obj[innerProperty[0]][innerProperty[1]] = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];\n                        }\n                    }\n                }\n                else {\n                    var property = mapper.dataMapSettings[parseInt(i.toString(), 10)].property;\n                    property = property.charAt(0).toLowerCase() + property.slice(1);\n                    obj[\"\" + property] = item[mapper.dataMapSettings[parseInt(i.toString(), 10)].field];\n                }\n                index = 0;\n                arrayProperty = [];\n                innerProperty = [];\n            }\n        }\n        if (!this.collectionContains(obj, diagram, mapper.id, mapper.parentId)) {\n            return obj;\n        }\n        else {\n            if (item[mapper.id] && isNaN(item[mapper.id])) {\n                return this.dataTable[item[mapper.id].toLowerCase()];\n            }\n            else {\n                return this.dataTable[item[mapper.id]];\n            }\n        }\n    };\n    DataBinding.prototype.getFlowChartNodeShape = function (data) {\n        if (data.shape !== '') {\n            switch (data.shape) {\n                case 'Rectangle':\n                    return { type: 'Basic', shape: 'Rectangle' };\n                case 'Decision':\n                    return { type: 'Flow', shape: 'Decision' };\n                case 'Hexagon':\n                    return { type: 'Path', data: 'M 0 0 L 2 -2 L 11 -2 L 13 0 L 11 2 L 2 2 L 0 0' };\n                case 'Ellipse':\n                    return { type: 'Basic', shape: 'Ellipse' };\n                case 'Terminator':\n                    return { type: 'Flow', shape: 'Terminator' };\n                case 'PredefinedProcess':\n                    return { type: 'Flow', shape: 'PreDefinedProcess' };\n                case 'Parallelogram':\n                    return { type: 'Basic', shape: 'Parallelogram' };\n                case 'ParallelogramAlt':\n                    return { type: 'Path', data: 'M 0 0 L 12 0 L 14 2 L 2 2 L 0 0' };\n                case 'Trapezoid':\n                    return { type: 'Path', data: 'M 0 0 L 1 -1 L 5 -1 L 6 0 L 0 0' };\n                case 'TrapezoidAlt':\n                    return { type: 'Path', data: 'M 0 0 L 5 0 L 4 1 L 1 1 L 0 0' };\n                case 'DataSource':\n                    return { type: 'Path', data: 'M 0 1 L 0 6 C 2 7 4 7 6 6 L 6 1 C 5 0 1 0 0 1 C 1 2 5 2 6 1' };\n                case 'Asymmetric':\n                    return { type: 'Path', data: 'M 0 0 L 8 0 L 8 2 L 0 2 L 2 1 L 0 0' };\n                case 'DoubleCircle':\n                    return { type: 'Path', data: 'M 0 0 A 1 1 0 0 0 7 0 A 1 1 0 0 0 0 0 M -1 0 A 1 1 0 0 0 8 0 A 1 1 0 0 0 -1 0' };\n                case 'Document':\n                    return { type: 'Flow', shape: 'Document' };\n                case 'PaperTap':\n                    return { type: 'Flow', shape: 'PaperTap' };\n                case 'DirectData':\n                    return { type: 'Flow', shape: 'DirectData' };\n                case 'SequentialData':\n                    return { type: 'Flow', shape: 'SequentialData' };\n                case 'Sort':\n                    return { type: 'Flow', shape: 'Sort' };\n                case 'MultiDocument':\n                    return { type: 'Flow', shape: 'MultiDocument' };\n                case 'Collate':\n                    return { type: 'Flow', shape: 'Collate' };\n                case 'SummingJunction':\n                    return { type: 'Flow', shape: 'SummingJunction' };\n                case 'Or':\n                    return { type: 'Flow', shape: 'Or' };\n                case 'InternalStorage':\n                    return { type: 'Flow', shape: 'InternalStorage' };\n                case 'Extract':\n                    return { type: 'Flow', shape: 'Extract' };\n                case 'ManualOperation':\n                    return { type: 'Flow', shape: 'ManualOperation' };\n                case 'Merge':\n                    return { type: 'Flow', shape: 'Merge' };\n                case 'OffPageReference':\n                    return { type: 'Flow', shape: 'OffPageReference' };\n                case 'SequentialAccessStorage':\n                    return { type: 'Flow', shape: 'SequentialAccessStorage' };\n                case 'Data':\n                    return { type: 'Flow', shape: 'Data' };\n                case 'Card':\n                    return { type: 'Flow', shape: 'Card' };\n                case 'Delay':\n                    return { type: 'Flow', shape: 'Delay' };\n                case 'Preparation':\n                    return { type: 'Flow', shape: 'Preparation' };\n                case 'Display':\n                    return { type: 'Flow', shape: 'Display' };\n                case 'ManualInput':\n                    return { type: 'Flow', shape: 'ManualInput' };\n                case 'LoopLimit':\n                    return { type: 'Flow', shape: 'LoopLimit' };\n                case 'StoredData':\n                    return { type: 'Flow', shape: 'StoredData' };\n                case 'Annotation':\n                    return { type: 'Flow', shape: 'Annotation' };\n                case 'Annotation2':\n                    return { type: 'Flow', shape: 'Annotation2' };\n                default:\n                    return { type: 'Flow', shape: 'Process' };\n            }\n        }\n        return { type: 'Flow', shape: 'Process' };\n    };\n    DataBinding.prototype.splitString = function (property) {\n        var temp = [];\n        temp = property.split('.');\n        for (var i = 0; i < temp.length; i++) {\n            temp[parseInt(i.toString(), 10)] = temp[parseInt(i.toString(), 10)].charAt(0).toLowerCase()\n                + temp[parseInt(i.toString(), 10)].slice(1);\n        }\n        return temp;\n    };\n    DataBinding.prototype.renderChildNodes = function (mapper, parent, value, rtNodes, diagram) {\n        var child;\n        var nextLevel;\n        var node;\n        for (var j = 0; j < parent.items.length; j++) {\n            child = parent.items[parseInt(j.toString(), 10)];\n            if (!child[mapper.id]) {\n                continue;\n            }\n            node = this.applyNodeTemplate(mapper, child, diagram);\n            var canBreak = false;\n            if (!this.collectionContains(node, diagram, mapper.id, mapper.parentId)) {\n                if (child[mapper.id] && isNaN(child[mapper.id])) {\n                    this.dataTable[child[mapper.id].toLowerCase()] = node;\n                }\n                else {\n                    this.dataTable[child[mapper.id]] = node;\n                }\n                diagram.nodes.push(node);\n            }\n            else {\n                canBreak = true;\n            }\n            if (!this.containsConnector(diagram, value, node.id)) {\n                diagram.connectors.push(this.applyConnectorTemplate(value, node.id, diagram));\n            }\n            if (!canBreak) {\n                if (node.data[mapper.id] && isNaN(node.data[mapper.id])) {\n                    nextLevel = rtNodes[node.data[mapper.id].toLowerCase()];\n                }\n                else {\n                    nextLevel = rtNodes[node.data[mapper.id]];\n                }\n                if (nextLevel !== undefined) {\n                    this.renderChildNodes(mapper, nextLevel, node.id, rtNodes, diagram);\n                }\n            }\n        }\n    };\n    // Bug 832897: Need to improve performance while rendering layout with large number of nodes.\n    // Replaced for loop with some() method to improve performance.\n    DataBinding.prototype.containsConnector = function (diagram, sourceNode, targetNode) {\n        if (sourceNode === '' || targetNode === '') {\n            return false;\n        }\n        return diagram.connectors.some(function (connector) {\n            return connector !== undefined && connector.sourceID === sourceNode && connector.targetID === targetNode;\n        });\n    };\n    /**\n     *  collectionContains method is used to  check wthear the node is already present in collection or not\n     *\n     * @param {Node} node\n     * @param {Diagram} diagram\n     * @param {string} id\n     * @param {string} parentId\n     */\n    DataBinding.prototype.collectionContains = function (node, diagram, id, parentId) {\n        var obj;\n        if (isNaN(node.data[\"\" + id]) && node.data[\"\" + id]) {\n            obj = this.dataTable[node.data[\"\" + id].toLowerCase()];\n        }\n        else {\n            obj = this.dataTable[node.data[\"\" + id]];\n        }\n        if (obj !== undefined && obj.data[\"\" + id] === node.data[\"\" + id] && obj.data[\"\" + parentId] === node.data[\"\" + parentId]) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Get the Connector values\n     *\n     * @param {string} sNode\n     * @param {string} tNode\n     * @param {Diagram} diagram\n     */\n    DataBinding.prototype.applyConnectorTemplate = function (sNode, tNode, diagram) {\n        var connModel = {\n            id: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)(), sourceID: sNode, targetID: tNode\n        };\n        var arrowType;\n        //Task 895538: Flow-chart layout support for EJ2 diagram.\n        //Added below code to set connector annotation and style based on the data.\n        if (diagram.layout.type === 'Flowchart') {\n            var targetNode = diagram.nodes.find(function (node) { return node.id === tNode; });\n            if (typeof targetNode.data.label === 'string') {\n                connModel.annotations = [{ content: targetNode.data.label }];\n            }\n            else if (Array.isArray(targetNode.data.label)) {\n                var inConnectors = diagram.connectors.filter(function (connector) { return connector.targetID === tNode; });\n                var index = 0;\n                if (inConnectors.length > 0) {\n                    index = inConnectors.length;\n                }\n                connModel.annotations = [{ content: targetNode.data.label[parseInt(index.toString(), 10)] }];\n            }\n            arrowType = this.getConnectorArrowType(targetNode.data);\n        }\n        var obj = new _objects_connector__WEBPACK_IMPORTED_MODULE_1__.Connector(diagram, 'connectors', connModel, true);\n        if (arrowType) {\n            obj.style.strokeWidth = arrowType.strokeWidth;\n            obj.targetDecorator.shape = arrowType.targetDecorator;\n        }\n        (0,_utility_diagram_util__WEBPACK_IMPORTED_MODULE_4__.updateDefaultValues)(obj, connModel, diagram.connectorDefaults);\n        return obj;\n    };\n    DataBinding.prototype.getConnectorArrowType = function (data) {\n        if (data.arrowType !== '') {\n            switch (data.arrowType) {\n                case 'None':\n                    return { targetDecorator: 'None', strokeWidth: 1 };\n                case 'Arrow':\n                    return { targetDecorator: 'Arrow', strokeWidth: 1 };\n                case 'Diamond':\n                    return { targetDecorator: 'Diamond', strokeWidth: 1 };\n                case 'Circle':\n                    return { targetDecorator: 'Circle', strokeWidth: 1 };\n                case 'OpenArrow':\n                    return { targetDecorator: 'OpenArrow', strokeWidth: 1 };\n                case 'Square':\n                    return { targetDecorator: 'Square', strokeWidth: 1 };\n                case 'Fletch':\n                    return { targetDecorator: 'Fletch', strokeWidth: 1 };\n                case 'OpenFetch':\n                    return { targetDecorator: 'OpenFetch', strokeWidth: 1 };\n                case 'IndentedArrow':\n                    return { targetDecorator: 'IndentedArrow', strokeWidth: 1 };\n                case 'OutdentedArrow':\n                    return { targetDecorator: 'OutdentedArrow', strokeWidth: 1 };\n                case 'DoubleArrow':\n                    return { targetDecorator: 'DoubleArrow', strokeWidth: 1 };\n                default:\n                    return { targetDecorator: 'Arrow', strokeWidth: 1 };\n            }\n        }\n        else {\n            return { targetDecorator: 'Arrow', strokeWidth: 1 };\n        }\n    };\n    return DataBinding;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/data-binding/data-binding.js?");

/***/ })

}]);