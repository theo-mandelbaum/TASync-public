"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_chart-series_js-68aaaa4b"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/chart-series.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/chart-series.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChartSegment: () => (/* binding */ ChartSegment),\n/* harmony export */   DataLabelSettings: () => (/* binding */ DataLabelSettings),\n/* harmony export */   ErrorBarCapSettings: () => (/* binding */ ErrorBarCapSettings),\n/* harmony export */   ErrorBarSettings: () => (/* binding */ ErrorBarSettings),\n/* harmony export */   MarkerSettings: () => (/* binding */ MarkerSettings),\n/* harmony export */   ParetoOptions: () => (/* binding */ ParetoOptions),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   SeriesBase: () => (/* binding */ SeriesBase),\n/* harmony export */   Trendline: () => (/* binding */ Trendline)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _common_model_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/model/base */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/base.js\");\n/* harmony import */ var _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-data */ \"./node_modules/@syncfusion/ej2-data/index.js\");\n/* harmony import */ var _common_model_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/model/constants */ \"./node_modules/@syncfusion/ej2-charts/src/common/model/constants.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This class provides options to customize the appearance and behavior of data labels within a series.\n */\nvar DataLabelSettings = /** @class */ (function (_super) {\n    __extends(DataLabelSettings, _super);\n    function DataLabelSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], DataLabelSettings.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], DataLabelSettings.prototype, \"showZero\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], DataLabelSettings.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('transparent')\n    ], DataLabelSettings.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], DataLabelSettings.prototype, \"format\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], DataLabelSettings.prototype, \"opacity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], DataLabelSettings.prototype, \"angle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], DataLabelSettings.prototype, \"enableRotation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Auto')\n    ], DataLabelSettings.prototype, \"position\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(5)\n    ], DataLabelSettings.prototype, \"rx\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(5)\n    ], DataLabelSettings.prototype, \"ry\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Center')\n    ], DataLabelSettings.prototype, \"alignment\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ width: null, color: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Border)\n    ], DataLabelSettings.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ left: 5, right: 5, top: 5, bottom: 5 }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Margin)\n    ], DataLabelSettings.prototype, \"margin\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ size: null, color: null, fontStyle: null, fontWeight: null, fontFamily: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Font)\n    ], DataLabelSettings.prototype, \"font\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], DataLabelSettings.prototype, \"template\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Hide')\n    ], DataLabelSettings.prototype, \"labelIntersectAction\", void 0);\n    return DataLabelSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * This class is used to define the appearance and behavior of the series markers.\n */\nvar MarkerSettings = /** @class */ (function (_super) {\n    __extends(MarkerSettings, _super);\n    function MarkerSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], MarkerSettings.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], MarkerSettings.prototype, \"shape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], MarkerSettings.prototype, \"imageUrl\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(5)\n    ], MarkerSettings.prototype, \"height\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], MarkerSettings.prototype, \"isFilled\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(5)\n    ], MarkerSettings.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ width: 2, color: null }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Border)\n    ], MarkerSettings.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ x: 0, y: 0 }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Offset)\n    ], MarkerSettings.prototype, \"offset\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], MarkerSettings.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], MarkerSettings.prototype, \"allowHighlight\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], MarkerSettings.prototype, \"opacity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, DataLabelSettings)\n    ], MarkerSettings.prototype, \"dataLabel\", void 0);\n    return MarkerSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `ParetoOptions` class provides a set of properties for configuring the Pareto series.\n */\nvar ParetoOptions = /** @class */ (function (_super) {\n    __extends(ParetoOptions, _super);\n    function ParetoOptions() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], ParetoOptions.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ParetoOptions.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('0')\n    ], ParetoOptions.prototype, \"dashArray\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, MarkerSettings)\n    ], ParetoOptions.prototype, \"marker\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], ParetoOptions.prototype, \"showAxis\", void 0);\n    return ParetoOptions;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The model that represents how the points in a series are configured and displayed.\n *\n * @public\n */\nvar Points = /** @class */ (function () {\n    function Points() {\n        /** Specifies the locations of symbols associated with the point. */\n        this.symbolLocations = null;\n        /** Specifies the regions associated with the point. */\n        this.regions = null;\n        /** Specifies the percentage value of the point. */\n        this.percentage = null;\n        /** Specifies the region data of the point. */\n        this.regionData = null;\n        /** Indicates whether the point is selected. */\n        this.isSelect = false;\n        /** Specifies the marker settings for the point. */\n        this.marker = {\n            visible: false\n        };\n        /**\n         * Indicates whether the point is within the specified range.\n         *\n         * @private\n         */\n        this.isPointInRange = true;\n        /** Specifies the vertical error value for the point. */\n        this.verticalError = null;\n        /** Specifies the vertical negative error value for the point. */\n        this.verticalNegativeError = null;\n        /** Specifies the horizontal error value for the point. */\n        this.horizontalError = null;\n        /** Specifies the horizontal negative error value for the point. */\n        this.horizontalNegativeError = null;\n        /** Specifies the vertical positive error value for the point. */\n        this.verticalPositiveError = null;\n        /** Specifies the horizontal positive error value for the point. */\n        this.horizontalPositiveError = null;\n    }\n    return Points;\n}());\n\n/**\n * Configures the behavior and appearance of trendlines in a chart series.\n * Trendlines indicate trends and the rate of price changes over a period.\n */\nvar Trendline = /** @class */ (function (_super) {\n    __extends(Trendline, _super);\n    function Trendline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** @private */\n        _this.clipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, 0, 0);\n        return _this;\n    }\n    /**\n     * Sets the data source for the specified series in the provided chart.\n     *\n     * @private\n     * @param {Series} series - The series for which the data source is set.\n     * @param {Chart} chart - The chart in which the data source is set.\n     * @returns {void}\n     */\n    Trendline.prototype.setDataSource = function (series, chart) {\n        if (series) {\n            this.points = series.points;\n        }\n        chart.trendLineModule.initDataSource(this);\n        chart.visibleSeriesCount++;\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Trendline.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Trendline.prototype, \"dashArray\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Trendline.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Linear')\n    ], Trendline.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(2)\n    ], Trendline.prototype, \"period\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(2)\n    ], Trendline.prototype, \"polynomialOrder\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Trendline.prototype, \"backwardForecast\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Trendline.prototype, \"forwardForecast\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Animation)\n    ], Trendline.prototype, \"animation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, MarkerSettings)\n    ], Trendline.prototype, \"marker\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Trendline.prototype, \"enableTooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Trendline.prototype, \"intercept\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Trendline.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], Trendline.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('SeriesType')\n    ], Trendline.prototype, \"legendShape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Accessibility)\n    ], Trendline.prototype, \"accessibility\", void 0);\n    return Trendline;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `ErrorBarCapSettings` class provides options to customize the appearance and behavior of error bars in a series.\n */\nvar ErrorBarCapSettings = /** @class */ (function (_super) {\n    __extends(ErrorBarCapSettings, _super);\n    function ErrorBarCapSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ErrorBarCapSettings.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(10)\n    ], ErrorBarCapSettings.prototype, \"length\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], ErrorBarCapSettings.prototype, \"color\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ErrorBarCapSettings.prototype, \"opacity\", void 0);\n    return ErrorBarCapSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\nvar ChartSegment = /** @class */ (function (_super) {\n    __extends(ChartSegment, _super);\n    function ChartSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], ChartSegment.prototype, \"value\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], ChartSegment.prototype, \"color\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('0')\n    ], ChartSegment.prototype, \"dashArray\", void 0);\n    return ChartSegment;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `ErrorBarSettings` class provides options to customize the appearance and behavior of error bars in a series.\n *\n * @public\n */\nvar ErrorBarSettings = /** @class */ (function (_super) {\n    __extends(ErrorBarSettings, _super);\n    function ErrorBarSettings() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], ErrorBarSettings.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Fixed')\n    ], ErrorBarSettings.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Both')\n    ], ErrorBarSettings.prototype, \"direction\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Vertical')\n    ], ErrorBarSettings.prototype, \"mode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], ErrorBarSettings.prototype, \"color\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ErrorBarSettings.prototype, \"verticalError\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ErrorBarSettings.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ErrorBarSettings.prototype, \"horizontalError\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(3)\n    ], ErrorBarSettings.prototype, \"verticalPositiveError\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(3)\n    ], ErrorBarSettings.prototype, \"verticalNegativeError\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ErrorBarSettings.prototype, \"horizontalPositiveError\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], ErrorBarSettings.prototype, \"horizontalNegativeError\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, ErrorBarCapSettings)\n    ], ErrorBarSettings.prototype, \"errorBarCap\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], ErrorBarSettings.prototype, \"errorBarColorMapping\", void 0);\n    return ErrorBarSettings;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * Defines the common behavior for series and technical indicators.\n */\nvar SeriesBase = /** @class */ (function (_super) {\n    __extends(SeriesBase, _super);\n    function SeriesBase() {\n        /**\n         * The data source field that contains the x value.\n         * It is applicable to both series and technical indicators.\n         *\n         * @default ''\n         */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rangeColorPoints = [];\n        _this.isAdvancedColor = undefined;\n        /** @private */\n        _this.currentViewData = [];\n        /** @private */\n        _this.clipRect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Rect(0, 0, 0, 0);\n        /** @private */\n        _this.seriesType = 'XY';\n        _this.isRectTypeSeries = false;\n        _this.removedPointIndex = null;\n        /** @private */\n        _this.isLegendClicked = false;\n        return _this;\n    }\n    /**\n     * Process data for the series.\n     *\n     * @hidden\n     * @returns {void}\n     */\n    SeriesBase.prototype.processJsonData = function () {\n        var i = 0;\n        var point = new Points();\n        var xName = (this instanceof Series && this.type === 'Histogram') ? 'x' : this.xName;\n        var textMappingName = this instanceof Series && this.marker.dataLabel.name ?\n            this.marker.dataLabel.name : '';\n        if (this instanceof Series) {\n            if ((this.type === 'Waterfall' || this.type === 'Histogram')) {\n                this.currentViewData = this.chart[(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(this.type) + 'SeriesModule'].\n                    processInternalData((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.currentViewData, null, true), this);\n            }\n            if (this.category === 'Pareto') {\n                this.currentViewData = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.currentViewData, null, true);\n                if (this.type === 'Line') {\n                    this.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(this.currentViewData, this);\n                }\n            }\n            this.isRectTypeSeries = this.type.indexOf('Column') > -1 || this.type.indexOf('Bar') > -1\n                || this.type.indexOf('Histogram') > -1;\n        }\n        var len = (this.currentViewData || []).length;\n        this.points = [];\n        this.xMin = Infinity;\n        this.xMax = -Infinity;\n        this.yMin = Infinity;\n        this.yMax = -Infinity;\n        this.sizeMax = -Infinity;\n        this.getSeriesType();\n        if (this.xAxis.valueType === 'Category') {\n            while (i < len) {\n                this.pushCategoryPoint(point, i, textMappingName, xName);\n                i++;\n            }\n        }\n        else if (this.xAxis.valueType.indexOf('DateTime') > -1) {\n            var option = {\n                skeleton: 'full',\n                type: 'dateTime'\n            };\n            var dateParser = this.chart.intl.getDateParser(option);\n            var dateFormatter = this.chart.intl.getDateFormat(option);\n            while (i < len) {\n                this.pushDateTimePoint(point, i, textMappingName, xName, dateParser, dateFormatter);\n                i++;\n            }\n        }\n        else {\n            while (i < len) {\n                this.pushDoublePoint(point, i, textMappingName, xName);\n                i++;\n            }\n        }\n        this.updateSplineValue();\n        this.updateYAxisForErrorBars();\n        if (this instanceof Series && this.type === 'Waterfall' && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.yAxis.minimum)) {\n            this.yMin = Math.min.apply(Math, this.chart.waterfallSeriesModule.cumulativeSums);\n        }\n    };\n    /**\n     * Calculates the errorbar and adds a range to axis if errorbar exeeds to the actual range.\n     *\n     * @returns {void}\n     * @private\n     */\n    SeriesBase.prototype.updateYAxisForErrorBars = function () {\n        if (this instanceof Series) {\n            if (this.chart.errorBarModule) {\n                var maxVerticalError = void 0;\n                var minVerticalError = void 0;\n                if (this.errorBar.verticalError) {\n                    for (var i = 0; i < this.points.length; i++) {\n                        var verticalErrors = [];\n                        var minVerticalErrorValue = [];\n                        for (var i_1 = 0; i_1 < this.points.length; i_1++) {\n                            var point = this.points[i_1];\n                            if (point.verticalError) {\n                                verticalErrors.push(point.verticalError);\n                                minVerticalErrorValue.push(point.yValue - point.verticalError);\n                            }\n                        }\n                        maxVerticalError = verticalErrors && verticalErrors.length > 0 ? Math.max.apply(Math, verticalErrors) : 0;\n                        minVerticalError = verticalErrors && verticalErrors.length > 0 ? Math.min.apply(Math, minVerticalErrorValue) : 0;\n                    }\n                }\n                this.yMax += !isNaN(maxVerticalError) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.yAxis.maximum) ? maxVerticalError : 0;\n                this.yMin = !isNaN(minVerticalError) && minVerticalError < this.yMin && minVerticalError < 0 &&\n                    (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.yAxis.minimum) ? minVerticalError : this.yMin;\n            }\n        }\n    };\n    /**\n     * Pushes a category point to the data collection.\n     *\n     * @param {Points} point -The point to be pushed.\n     * @param {number} index -The index of the point.\n     * @param {string} textMappingName -The name of the text mapping.\n     * @param {string} xName -The name of the x-coordinate.\n     * @returns {void}\n     * @private\n     */\n    SeriesBase.prototype.pushCategoryPoint = function (point, index, textMappingName, xName) {\n        point = this.dataPoint(index, textMappingName, xName);\n        this.pushCategoryData(point, index, point.x);\n        this.pushData(point, index);\n        this.setEmptyPoint(point, index);\n        this.rangeColorsInterior(point);\n    };\n    /**\n     * Pushes a double point to the data collection.\n     *\n     * @param {Points} point -The point to be pushed.\n     * @param {number} index -The index of the point.\n     * @param {string} textMappingName -The name of the text mapping.\n     * @param {string} xName -The name of the x-coordinate.\n     * @returns {void}\n     * @private\n     */\n    SeriesBase.prototype.pushDoublePoint = function (point, index, textMappingName, xName) {\n        point = this.dataPoint(index, textMappingName, xName);\n        point.xValue = point.x;\n        this.pushData(point, index);\n        this.setEmptyPoint(point, index);\n    };\n    /**\n     * Pushes a DateTime point to the data collection.\n     *\n     * @param {Points} point -The point to be pushed.\n     * @param {number} index -The index of the point.\n     * @param {string} textMappingName -The name of the text mapping.\n     * @param {string} xName -The name of the x-coordinate.\n     * @param {Function} dateParser -The date parser function.\n     * @param {Function} dateFormatter -The date formatter function.\n     * @returns {void}\n     * @private\n     */\n    SeriesBase.prototype.pushDateTimePoint = function (point, index, textMappingName, xName, dateParser, dateFormatter) {\n        point = this.dataPoint(index, textMappingName, xName);\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x) && point.x !== '') {\n            point.x = new Date(_syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.DataUtil.parse.parseJson({ val: point.x }).val);\n            if (this.xAxis.valueType === 'DateTime') {\n                point.xValue = Date.parse(point.x.toString());\n            }\n            else {\n                if (this.chart.isBlazor) {\n                    this.pushCategoryData(point, index, Date.parse(point.x.toString()).toString());\n                }\n                else {\n                    this.pushCategoryData(point, index, Date.parse(dateParser(dateFormatter(point.x))).toString());\n                }\n            }\n            this.pushData(point, index);\n            this.setEmptyPoint(point, index);\n        }\n        else {\n            point.visible = false;\n        }\n    };\n    SeriesBase.prototype.updateSplineValue = function () {\n        if (this instanceof Series && !(this.chart.stockChart && this.xAxis.valueType === 'DateTimeCategory')) {\n            if (this.type.indexOf('Spline') > -1 || (this.drawType.indexOf('Spline') > -1 && this.chart.chartAreaType === 'PolarRadar')) {\n                var isArea = (this.type.indexOf('Area') > -1 || this.drawType.indexOf('Area') > -1);\n                var isRange = this.type.indexOf('Range') > -1;\n                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(this);\n            }\n            else if (this.type.indexOf('Histogram') > -1 && (this.xAxis.maximum || this.xAxis.minimum)) {\n                this.chart['histogramSeriesModule'].calculateBinValues(this);\n            }\n            if (this.type.indexOf('Histogram') > -1 && this.points.length === 1) {\n                this.xMin = this.xMin - this.histogramValues.binWidth;\n                this.xMax = this.xMax + this.histogramValues.binWidth;\n            }\n        }\n    };\n    SeriesBase.prototype.rangeColorsInterior = function (point) {\n        if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 && this.chart.visibleSeries.length === 1 &&\n            (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||\n                this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble')) {\n            if (!this.rangeColorPoints[point.interior]) {\n                this.rangeColorPoints[point.interior] = [];\n            }\n            else if (this.rangeColorPoints[point.interior] !== undefined) {\n                this.rangeColorPoints[point.interior].push(point);\n            }\n        }\n    };\n    /**\n     * Sets the empty point values.\n     *\n     * @param {Points} point - The point to be set.\n     * @param {number} i - The index of the point.\n     * @private\n     * @returns {void}\n     */\n    SeriesBase.prototype.pushData = function (point, i) {\n        point.index = i;\n        point.yValue = point.y;\n        point.series = this;\n        // To find the min, max for the axis range.\n        this.xMin = Math.min(this.xMin, point.xValue);\n        this.xMax = Math.max(this.xMax, point.xValue);\n        this.xData.push(point.xValue);\n    };\n    /**\n     * Retrieves the data point at the specified index with the given text mapping name and x-name.\n     *\n     * @param {number} i - The index of the data point to retrieve.\n     * @param {string} textMappingName - The name used to map text data.\n     * @param {string} xName - The name used for the x-axis.\n     * @returns {Points} - The data point at the specified index.\n     * @private\n     */\n    SeriesBase.prototype.dataPoint = function (i, textMappingName, xName) {\n        this.points[i] = new Points();\n        var point = this.points[i];\n        var currentViewData = this.currentViewData[i];\n        var getObjectValueByMappingString = this.enableComplexProperty ? _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue : this.getObjectValue;\n        point.x = getObjectValueByMappingString(xName, currentViewData);\n        point.high = getObjectValueByMappingString(this.high, currentViewData);\n        point.low = getObjectValueByMappingString(this.low, currentViewData);\n        point.open = getObjectValueByMappingString(this.open, currentViewData);\n        point.close = getObjectValueByMappingString(this.close, currentViewData);\n        point.volume = getObjectValueByMappingString(this.volume, currentViewData);\n        point.interior = getObjectValueByMappingString(this.pointColorMapping, currentViewData);\n        if (this instanceof Series) {\n            if (this.errorBar.visible) {\n                point.errorBarColor = getObjectValueByMappingString(this.errorBar.errorBarColorMapping, currentViewData);\n                point.verticalError = typeof this.errorBar.verticalError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalError, currentViewData) : this.errorBar.verticalError;\n                point.horizontalError = typeof this.errorBar.horizontalError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalError, currentViewData) : this.errorBar.horizontalError;\n                point.verticalNegativeError = typeof this.errorBar.verticalNegativeError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalNegativeError, currentViewData) : this.errorBar.verticalNegativeError;\n                point.verticalPositiveError = typeof this.errorBar.verticalPositiveError == 'string' ? getObjectValueByMappingString(this.errorBar.verticalPositiveError, currentViewData) : this.errorBar.verticalPositiveError;\n                point.horizontalNegativeError = typeof this.errorBar.horizontalNegativeError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalNegativeError, currentViewData) : this.errorBar.horizontalNegativeError;\n                point.horizontalPositiveError = typeof this.errorBar.horizontalPositiveError == 'string' ? getObjectValueByMappingString(this.errorBar.horizontalPositiveError, currentViewData) : this.errorBar.horizontalPositiveError;\n            }\n            point.y = getObjectValueByMappingString(this.yName, currentViewData);\n            point.size = getObjectValueByMappingString(this.size, currentViewData);\n            point.text = getObjectValueByMappingString(textMappingName, currentViewData);\n            point.tooltip = getObjectValueByMappingString(this.tooltipMappingName, currentViewData);\n            if (this.isAdvancedColorSupported()) {\n                this.rangeColorName = this.colorName.length > 0 ? this.colorName : this.yName;\n                point.colorValue = getObjectValueByMappingString(this.rangeColorName, currentViewData);\n                point.interior = this.getPointFillColor(point.interior, point.colorValue);\n            }\n        }\n        return point;\n    };\n    SeriesBase.prototype.isAdvancedColorSupported = function () {\n        if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.isAdvancedColor)) {\n            if (this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0 &&\n                (this.chart.series[0].type === 'Column' || this.chart.series[0].type === 'Bar' ||\n                    this.chart.series[0].type === 'Scatter' || this.chart.series[0].type === 'Bubble')) {\n                this.isAdvancedColor = true;\n            }\n            else {\n                this.isAdvancedColor = false;\n            }\n        }\n        return this.isAdvancedColor;\n    };\n    SeriesBase.prototype.getPointFillColor = function (pointFill, value) {\n        var color = pointFill;\n        if (value && this.chart.rangeColorSettings && this.chart.rangeColorSettings.length > 0) {\n            for (var _i = 0, _a = this.chart.rangeColorSettings; _i < _a.length; _i++) {\n                var rangeMap = _a[_i];\n                if (value >= rangeMap.start && value <= rangeMap.end) {\n                    if (rangeMap.colors.length > 1) {\n                        color = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getColorByValue)(rangeMap, value);\n                    }\n                    else {\n                        color = rangeMap.colors[0];\n                    }\n                }\n            }\n        }\n        return color;\n    };\n    /**\n     * Pushes a category point to the data collection.\n     *\n     * @param {string} mappingName - The name of the mapping.\n     * @param {Object} data - The data to be pushed.\n     * @returns {Object} - The data point at the specified index.\n     * @private\n     */\n    SeriesBase.prototype.getObjectValue = function (mappingName, data) {\n        return data[mappingName];\n    };\n    /**\n     * Sets the specified data point as an empty point at the given index.\n     *\n     * @private\n     * @param {Points} point - The data point to set as empty.\n     * @param {number} i - The index of the data point.\n     * @returns {void}\n     */\n    SeriesBase.prototype.setEmptyPoint = function (point, i) {\n        if (!this.findVisibility(point)) {\n            point.visible = true;\n            return null;\n        }\n        point.isEmpty = true;\n        var mode = this instanceof Series && point.isPointInRange ? this.emptyPointSettings.mode : 'Drop';\n        switch (mode) {\n            case 'Zero':\n                point.visible = true;\n                if (this instanceof Series && this.seriesType.indexOf('HighLow') > -1) {\n                    point.high = point.low = 0;\n                    if (this.seriesType.indexOf('HighLowOpenClose') > -1) {\n                        point.open = point.close = 0;\n                    }\n                }\n                else {\n                    point.y = point.yValue = this.yData[i] = 0;\n                }\n                break;\n            case 'Average':\n                if (this instanceof Series) {\n                    if (this.seriesType.indexOf('HighLow') > -1) {\n                        point.high = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.high) || isNaN(+point.high)) ? this.getAverage(this.high, i) : point.high;\n                        point.low = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.low) || isNaN(+point.low)) ? this.getAverage(this.low, i) : point.low;\n                        if (this.seriesType.indexOf('HighLowOpenClose') > -1) {\n                            point.open = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.open) || isNaN(+point.open)) ? this.getAverage(this.open, i) : point.open;\n                            point.close = ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.close) || isNaN(+point.close)) ? this.getAverage(this.close, i) :\n                                point.close;\n                        }\n                    }\n                    else {\n                        point.y = point.yValue = this.yData[i] = this.getAverage(this.yName, i);\n                    }\n                }\n                point.visible = true;\n                break;\n            case 'Drop':\n            case 'Gap':\n                this.yData[i] = null;\n                point.visible = false;\n                break;\n        }\n    };\n    SeriesBase.prototype.findVisibility = function (point) {\n        var type = this instanceof Series ? this.seriesType : 'HighLowOpenClose';\n        var yValues;\n        var yAxisMin = this.yAxis.minimum;\n        var yAxisMax = this.yAxis.maximum;\n        switch (type) {\n            case 'XY':\n                if (this.chart.chartAreaType === 'PolarRadar' && ((!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(yAxisMin) && point.yValue < yAxisMin) ||\n                    (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(yAxisMax) && point.yValue > yAxisMax))) {\n                    point.isPointInRange = false;\n                    return true;\n                }\n                this.setXYMinMax(point.yValue);\n                this.yData.push(point.yValue);\n                if (this instanceof Series && this.type === 'Bubble') {\n                    this.sizeMax = Math.max(this.sizeMax, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.size) || isNaN(+point.size)) ? this.sizeMax\n                        : point.size);\n                }\n                return (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x) || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.y) || isNaN(+point.y));\n            case 'HighLow':\n                this.setHiloMinMax(point.high, point.low);\n                return (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x) || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.low) || isNaN(+point.low)) ||\n                    ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.high) || isNaN(+point.high));\n            case 'HighLowOpenClose':\n                this.setHiloMinMax(point.high, point.low);\n                return (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.x) || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.low) || isNaN(+point.low)) ||\n                    ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.open) || isNaN(+point.open)) || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.close) || isNaN(+point.close))\n                    || ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(point.high) || isNaN(+point.high));\n            case 'BoxPlot':\n                yValues = (point.y || [null]).filter(function (value) {\n                    return !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value) && !isNaN(value);\n                }).sort(function (a, b) {\n                    return a - b;\n                });\n                point.y = yValues;\n                this.yMin = Math.min(this.yMin, Math.min.apply(Math, yValues));\n                this.yMax = Math.max(this.yMax, Math.max.apply(Math, yValues));\n                return !yValues.length;\n        }\n    };\n    /**\n     * To get Y min max for the provided point seriesType XY.\n     *\n     * @param {number} yValue - The y value used to determine the minimum and maximum values for the x and y coordinates.\n     * @returns {void}\n     */\n    SeriesBase.prototype.setXYMinMax = function (yValue) {\n        var isLogAxis = (this.yAxis.valueType === 'Logarithmic' || this.xAxis.valueType === 'Logarithmic');\n        var isNegativeValue = yValue < 0 || this.yAxis.rangePadding === 'None';\n        var seriesMinY;\n        if (this.isRectTypeSeries && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.yAxis)) {\n            seriesMinY = ((isLogAxis ? (yValue) : isNegativeValue ? yValue : 0));\n        }\n        else {\n            seriesMinY = yValue;\n        }\n        this.yMin = isLogAxis ?\n            Math.min(this.yMin, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(seriesMinY) || isNaN(seriesMinY) || (seriesMinY === 0) ||\n                (seriesMinY.toString() === '0') || (seriesMinY.toString() === '')) ? this.yMin : seriesMinY) :\n            Math.min(this.yMin, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(seriesMinY) || isNaN(seriesMinY)) ? this.yMin : seriesMinY);\n        this.yMax = Math.max(this.yMax, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(yValue) || isNaN(yValue)) ? this.yMax : yValue);\n    };\n    /**\n     * Sets the minimum and maximum values for the high and low values.\n     *\n     * @private\n     * @param {number} high - The high value used to determine the maximum value.\n     * @param {number} low - The low value used to determine the minimum value.\n     * @returns {void}\n     */\n    SeriesBase.prototype.setHiloMinMax = function (high, low) {\n        this.yMin = Math.min(this.yMin, Math.min(((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(low) || isNaN(low)) ? this.yMin : low, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(high) || isNaN(high)) ? this.yMin : high));\n        this.yMax = Math.max(this.yMax, Math.max(((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(low) || isNaN(low)) ? this.yMax : low, ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(high) || isNaN(high)) ? this.yMax : high));\n    };\n    /**\n     * Finds the type of the series.\n     *\n     * @private\n     * @returns {void}\n     */\n    SeriesBase.prototype.getSeriesType = function () {\n        var type;\n        if (this instanceof Series) {\n            var seriesType = this.chart.chartAreaType === 'PolarRadar' ? this.drawType : this.type;\n            if (seriesType) {\n                switch (seriesType) {\n                    case 'RangeColumn':\n                    case 'RangeArea':\n                    case 'RangeStepArea':\n                    case 'SplineRangeArea':\n                    case 'Hilo':\n                        type = 'HighLow';\n                        break;\n                    case 'HiloOpenClose':\n                    case 'Candle':\n                        type = 'HighLowOpenClose';\n                        break;\n                    case 'BoxAndWhisker':\n                        type = 'BoxPlot';\n                        break;\n                    default:\n                        type = 'XY';\n                }\n            }\n        }\n        this.seriesType = type;\n    };\n    /**\n     * Pushes category data into the series points.\n     *\n     * @param {Points} point - The point to which category data will be pushed.\n     * @param {number} index - The index of the data point.\n     * @param {string} pointX - The x-value of the point.\n     * @returns {void}\n     * @private\n     */\n    SeriesBase.prototype.pushCategoryData = function (point, index, pointX) {\n        if (!this.chart.tooltip.shared) {\n            if (!this.visible) {\n                return null;\n            }\n        }\n        if (!this.xAxis.isIndexed) {\n            if (this.xAxis.indexLabels[pointX] === undefined) {\n                this.xAxis.indexLabels[pointX] = this.xAxis.labels.length;\n                this.xAxis.labels.push(pointX);\n            }\n            point.xValue = this.xAxis.indexLabels[pointX];\n        }\n        else {\n            if (this.xAxis.labels[index]) {\n                this.xAxis.labels[index] += ', ' + pointX;\n            }\n            else {\n                this.xAxis.labels.push(pointX);\n            }\n            // this.xAxis.labels[index as number] ? this.xAxis.labels[index as number] += ', ' + pointX :\n            //     this.xAxis.labels.push(pointX);\n            point.xValue = index;\n        }\n    };\n    /**\n     * Gets the average value of a member in the specified data array or current view data.\n     *\n     * @param {string} member - The member whose average is to be calculated.\n     * @param {number} i - The index of the data point.\n     * @param {Object} data - The data array from which to calculate the average. Defaults to the current view data.\n     * @returns {number} - The average value of the specified member.\n     */\n    SeriesBase.prototype.getAverage = function (member, i, data) {\n        if (data === void 0) { data = this.currentViewData; }\n        var previous = data[i - 1] ? (data[i - 1][member] || 0) : 0;\n        var next = data[i + 1] ? (data[i + 1][member] || 0) : 0;\n        return (previous + next) / 2;\n    };\n    /**\n     * Refreshes the data manager for the provided chart.\n     *\n     * @param {Chart} chart - The chart whose data manager is to be refreshed.\n     * @returns {void}\n     * @private\n     */\n    SeriesBase.prototype.refreshDataManager = function (chart) {\n        var _this = this;\n        this.chart = chart;\n        var dataSource;\n        var isAngular = 'isAngular';\n        if (chart[isAngular]) {\n            dataSource = Object.keys(this.dataSource).length ? this.dataSource : chart.dataSource;\n        }\n        else {\n            dataSource = this.dataSource || chart.dataSource;\n        }\n        if (!(dataSource instanceof _syncfusion_ej2_data__WEBPACK_IMPORTED_MODULE_4__.DataManager) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.query)) {\n            this.dataManagerSuccess({ result: dataSource, count: dataSource.length }, false);\n            return;\n        }\n        var dataManager = this.dataModule.getData(this.dataModule.generateQuery().requiresCount());\n        dataManager.then(function (e) { return _this.dataManagerSuccess(e); });\n    };\n    SeriesBase.prototype.dataManagerSuccess = function (e, isRemoteData) {\n        if (isRemoteData === void 0) { isRemoteData = true; }\n        this.currentViewData = e.count ? e.result : [];\n        this.chart.allowServerDataBinding = false;\n        if (this instanceof Series) {\n            if (this.chart.stockChart) {\n                this.chart.stockChart.series[this.index].localData = this.currentViewData;\n            }\n            var argsData = {\n                name: _common_model_constants__WEBPACK_IMPORTED_MODULE_5__.seriesRender, series: this, data: this.currentViewData, fill: this.interior\n            };\n            this.chart.trigger(_common_model_constants__WEBPACK_IMPORTED_MODULE_5__.seriesRender, argsData);\n            this.interior = argsData.fill;\n            this.currentViewData = argsData.data;\n        }\n        if (this.chart.stockChart && !(this instanceof Series)) {\n            this.currentViewData = this.chart.stockChart.findCurrentData(this.chart.stockChart.series[0].localData, this.chart.stockChart.series[0].xName);\n        }\n        this.processJsonData();\n        this.recordsCount = e.count;\n        this.refreshChart(isRemoteData);\n        this.currentViewData = null;\n    };\n    SeriesBase.prototype.refreshChart = function (isRemoteData) {\n        var chart = this.chart;\n        if (this instanceof Series) {\n            chart.visibleSeriesCount += isRemoteData ? 1 : 0;\n        }\n        chart.refreshTechnicalIndicator(this);\n        if (this instanceof Series && this.category !== 'TrendLine') {\n            for (var _i = 0, _a = this.trendlines; _i < _a.length; _i++) {\n                var trendline = _a[_i];\n                trendline.setDataSource(this, chart);\n            }\n        }\n        //if (chart.visibleSeries.length === (chart.visibleSeriesCount - chart.indicators.length)) {\n        if (chart.visibleSeries.length === (chart.visibleSeriesCount)) {\n            chart.refreshBound();\n            chart.trigger('loaded', { chart: chart.isBlazor ? {} : chart });\n            if (this.chart.stockChart && this.chart.stockChart.initialRender) {\n                this.chart.stockChart.initialRender = false;\n                this.chart.stockChart.stockChartDataManagerSuccess();\n            }\n        }\n        if (this instanceof Series) {\n            chart.visibleSeriesCount += isRemoteData ? 0 : 1;\n        }\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"xName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"colorName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"high\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"low\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"open\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"close\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"volume\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"pointColorMapping\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], SeriesBase.prototype, \"visible\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], SeriesBase.prototype, \"xAxisName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], SeriesBase.prototype, \"yAxisName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Animation)\n    ], SeriesBase.prototype, \"animation\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], SeriesBase.prototype, \"fill\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], SeriesBase.prototype, \"width\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"dashArray\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], SeriesBase.prototype, \"dataSource\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], SeriesBase.prototype, \"query\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], ChartSegment)\n    ], SeriesBase.prototype, \"segments\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('X')\n    ], SeriesBase.prototype, \"segmentAxis\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], SeriesBase.prototype, \"enableComplexProperty\", void 0);\n    return SeriesBase;\n}(_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.ChildProperty));\n\n/**\n * The `Series` class is used to configure individual series in a chart.\n *\n * @public\n */\nvar Series = /** @class */ (function (_super) {\n    __extends(Series, _super);\n    function Series(parent, propName, defaultValue, isArray) {\n        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n        _this.visibleSeriesCount = 0;\n        /** @private */\n        _this.category = 'Series';\n        /** @private */\n        _this.isRectSeries = false;\n        /** @private */\n        _this.drawPoints = [];\n        /** @private */\n        _this.lowDrawPoints = [];\n        /** @private */\n        _this.delayedAnimation = false;\n        /** @private */\n        _this.rangeColorName = _this.colorName.length > 0 ? _this.colorName : _this.yName;\n        /** @private */\n        _this.currentData = [];\n        return _this;\n    }\n    /**\n     * Refresh the axis label.\n     *\n     * @returns {void}\n     * @private\n     */\n    Series.prototype.refreshAxisLabel = function () {\n        if (this.xAxis.valueType.indexOf('Category') === -1) {\n            return null;\n        }\n        this.xAxis.labels = [];\n        this.xAxis.indexLabels = {};\n        var option = {\n            skeleton: 'full',\n            type: 'dateTime'\n        };\n        var dateParser = this.chart.intl.getDateParser(option);\n        var dateFormatter = this.chart.intl.getDateFormat(option);\n        for (var _i = 0, _a = this.xAxis.series; _i < _a.length; _i++) {\n            var item = _a[_i];\n            if (item.visible && item.category !== 'TrendLine') {\n                item.xMin = Infinity;\n                item.xMax = -Infinity;\n                for (var _b = 0, _c = item.points; _b < _c.length; _b++) {\n                    var point = _c[_b];\n                    item.pushCategoryData(point, point.index, this.xAxis.valueType === 'DateTimeCategory' ? Date.parse(dateParser(dateFormatter(point.x))).toString() : point.x);\n                    item.xMin = Math.min(item.xMin, point.xValue);\n                    item.xMax = Math.max(item.xMax, point.xValue);\n                }\n            }\n        }\n    };\n    /**\n     * To get the series collection.\n     *\n     * @returns {void}\n     * @private\n     */\n    Series.prototype.findSeriesCollection = function (column, row, isStack) {\n        var seriesCollection = [];\n        for (var _i = 0, _a = row.axes; _i < _a.length; _i++) {\n            var rowAxis = _a[_i];\n            for (var _b = 0, _c = rowAxis.series; _b < _c.length; _b++) {\n                var rowSeries = _c[_b];\n                for (var _d = 0, _e = column.axes; _d < _e.length; _d++) {\n                    var axis = _e[_d];\n                    for (var _f = 0, _g = axis.series; _f < _g.length; _f++) {\n                        var series = _g[_f];\n                        if (series === rowSeries && series.visible && this.rectSeriesInChart(series, isStack)) {\n                            seriesCollection.push(series);\n                        }\n                    }\n                }\n            }\n        }\n        return seriesCollection;\n    };\n    /**\n     * Checks if the series in the chart are rectangular.\n     *\n     * @param {Series} series - The series to be checked.\n     * @param {boolean} isStack - Specifies whether the series are stacked.\n     * @returns {boolean} - Returns true if the series in the chart are rectangular, otherwise false.\n     */\n    Series.prototype.rectSeriesInChart = function (series, isStack) {\n        var type = (series.type).toLowerCase();\n        return (type.indexOf('column') !== -1 || type.indexOf('bar') !== -1 || type.indexOf('histogram') !== -1 ||\n            type.indexOf('hiloopenclose') !== -1 || type.indexOf('candle') !== -1 || type.indexOf('pareto') !== -1 ||\n            type.indexOf('hilo') !== -1 || series.drawType.indexOf('Column') !== -1 ||\n            type.indexOf('waterfall') !== -1 || type.indexOf('boxandwhisker') !== -1 || isStack);\n    };\n    /**\n     * Calculates the stacked value for the chart.\n     *\n     * @param {boolean} isStacking100 - Specifies whether the stacking is 100%.\n     * @param {Chart} chart - The chart for which the stacked value is calculated.\n     * @returns {void}\n     * @private\n     */\n    Series.prototype.calculateStackedValue = function (isStacking100, chart) {\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n            var columnItem = _a[_i];\n            for (var _b = 0, _c = chart.rows; _b < _c.length; _b++) {\n                var item = _c[_b];\n                this.calculateStackingValues(this.findSeriesCollection(columnItem, item, true), isStacking100);\n            }\n        }\n    };\n    Series.prototype.calculateStackingValues = function (seriesCollection, isStacking100) {\n        var startValues;\n        var endValues;\n        var yValues = [];\n        var lastPositive = [];\n        var lastNegative = [];\n        var stackingGroup;\n        var lastValue;\n        var value;\n        var frequencies = [];\n        if (isStacking100) {\n            frequencies = this.findFrequencies(seriesCollection);\n        }\n        var groupingValues = [];\n        var visiblePoints = [];\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var series = seriesCollection[i];\n            if (!groupingValues[series.stackingGroup]) {\n                groupingValues[series.stackingGroup] = [];\n                groupingValues[series.stackingGroup].push(series);\n            }\n            else if (groupingValues[series.stackingGroup] !== undefined) {\n                groupingValues[series.stackingGroup].push(series);\n            }\n        }\n        var keys = Object.keys(groupingValues);\n        for (var k = 0; k < keys.length; k++) {\n            var stackingSeies = [];\n            var stackedValues = [];\n            var seriesCollection_2 = groupingValues[keys[k]];\n            for (var _i = 0, seriesCollection_1 = seriesCollection_2; _i < seriesCollection_1.length; _i++) {\n                var series = seriesCollection_1[_i];\n                if (series.type.indexOf('Stacking') !== -1 || (series.drawType.indexOf('Stacking') !== -1 &&\n                    (series.chart.chartAreaType === 'PolarRadar'))) {\n                    stackingGroup = (series.type.indexOf('StackingArea') !== -1) ? 'StackingArea100' :\n                        (series.type.indexOf('StackingLine') !== -1) ? 'StackingLine100' : series.stackingGroup;\n                    if (!lastPositive[stackingGroup]) {\n                        lastPositive[stackingGroup] = [];\n                        lastNegative[stackingGroup] = [];\n                    }\n                    yValues = series.yData;\n                    startValues = [];\n                    endValues = [];\n                    stackingSeies.push(series);\n                    visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getVisiblePoints)(series);\n                    for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {\n                        lastValue = 0;\n                        value = +yValues[j]; // Fix for chart not rendering while y value is given as string issue\n                        if (lastPositive[stackingGroup][visiblePoints[j].xValue] === undefined) {\n                            lastPositive[stackingGroup][visiblePoints[j].xValue] = 0;\n                        }\n                        if (lastNegative[stackingGroup][visiblePoints[j].xValue] === undefined) {\n                            lastNegative[stackingGroup][visiblePoints[j].xValue] = 0;\n                        }\n                        if (isStacking100) {\n                            value = value / frequencies[stackingGroup][visiblePoints[j].xValue] * 100;\n                            value = !isNaN(value) ? value : 0;\n                            visiblePoints[j].percentage = +(value.toFixed(2));\n                        }\n                        else {\n                            stackedValues[j] = stackedValues[j] ?\n                                stackedValues[j] + Math.abs(value) : Math.abs(value);\n                        }\n                        if (value >= 0) {\n                            lastValue = lastPositive[stackingGroup][visiblePoints[j].xValue];\n                            lastPositive[stackingGroup][visiblePoints[j].xValue] += value;\n                        }\n                        else {\n                            lastValue = lastNegative[stackingGroup][visiblePoints[j].xValue];\n                            lastNegative[stackingGroup][visiblePoints[j].xValue] += value;\n                        }\n                        startValues.push(lastValue);\n                        endValues.push(value + lastValue);\n                        if (isStacking100 && (endValues[j] > 100)) {\n                            endValues[j] = 100;\n                        }\n                    }\n                    series.stackedValues = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.StackValues(startValues, endValues);\n                    var isLogAxis = series.yAxis.valueType === 'Logarithmic';\n                    var isColumnBarType = (series.type.indexOf('Column') !== -1 || series.type.indexOf('Bar') !== -1);\n                    series.yMin = isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : (series.yAxis.startFromZero && series.yAxis.rangePadding === 'Auto' && series.yMin >= 0) ? 0 : parseFloat((Math.min.apply(0, isStacking100 ? startValues : endValues)).toFixed(10));\n                    series.yMax = Math.max.apply(0, endValues);\n                    if (series.yMin > Math.min.apply(0, endValues)) {\n                        series.yMin = (isStacking100) ? -100 :\n                            isLogAxis && isColumnBarType && series.yMin < 1 ? series.yMin : Math.min.apply(0, endValues);\n                    }\n                    if (series.yMax < Math.max.apply(0, startValues)) {\n                        series.yMax = 0;\n                    }\n                }\n            }\n            this.findPercentageOfStacking(stackingSeies, stackedValues, isStacking100);\n        }\n    };\n    Series.prototype.findPercentageOfStacking = function (stackingSeies, values, isStacking100) {\n        for (var _i = 0, stackingSeies_1 = stackingSeies; _i < stackingSeies_1.length; _i++) {\n            var item = stackingSeies_1[_i];\n            if (isStacking100) {\n                return null;\n            }\n            for (var _a = 0, _b = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getVisiblePoints)(item); _a < _b.length; _a++) {\n                var point = _b[_a];\n                point.percentage = Math.abs(+(point.y / values[point.index] * 100).toFixed(2));\n            }\n        }\n    };\n    Series.prototype.findFrequencies = function (seriesCollection) {\n        var frequencies = [];\n        var stackingGroup;\n        var visiblePoints = [];\n        for (var _i = 0, seriesCollection_3 = seriesCollection; _i < seriesCollection_3.length; _i++) {\n            var series = seriesCollection_3[_i];\n            series.yAxis.isStack100 = series.type.indexOf('100') !== -1 ? true : false;\n            visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getVisiblePoints)(series);\n            if (series.type.indexOf('Stacking') !== -1) {\n                stackingGroup = (series.type.indexOf('StackingArea') !== -1) ? 'StackingArea100' :\n                    (series.type.indexOf('StackingLine') !== -1) ? 'StackingLine100' : series.stackingGroup;\n                if (!frequencies[stackingGroup]) {\n                    frequencies[stackingGroup] = [];\n                }\n                for (var j = 0, pointsLength = visiblePoints.length; j < pointsLength; j++) {\n                    if (frequencies[stackingGroup][visiblePoints[j].xValue] === undefined) {\n                        frequencies[stackingGroup][visiblePoints[j].xValue] = 0;\n                    }\n                    if (series.yData[j] > 0) {\n                        frequencies[stackingGroup][visiblePoints[j].xValue] += series.yData[j];\n                    }\n                    else {\n                        frequencies[stackingGroup][visiblePoints[j].xValue] -= series.yData[j];\n                    }\n                }\n            }\n        }\n        return frequencies;\n    };\n    /* private dataManagerFailure(e: { result: Object[] }): void {\n         this.currentViewData = [];\n         this.refreshChart();\n     }*/\n    /**\n     * Renders the series on the chart.\n     *\n     * @param {Chart} chart - The chart on which the series is rendered.\n     * @returns {void}\n     * @private\n     */\n    Series.prototype.renderSeries = function (chart) {\n        if (this.chart.stockChart && this.xAxis.valueType === 'DateTimeCategory') {\n            for (var i = 0; i < this.points.length; i++) {\n                var index = this.xAxis.labels.indexOf(Date.parse(this.points[i].x.toString()).toString());\n                this.points[i].xValue = index;\n                if (chart.series.length > 1) {\n                    this.xData[i] = index;\n                    this.xMin = (this.xMin > index) ? index : this.xMin;\n                    this.xMax = (this.xMax < index) ? index : this.xMax;\n                }\n            }\n            if (this instanceof Series && this.type.indexOf('Spline') > -1) {\n                var isArea = this.type.indexOf('Area') > -1;\n                var isRange = this.type.indexOf('Range') > -1;\n                this.chart['spline' + (isArea ? isRange ? 'RangeArea' : 'Area' : '') + 'SeriesModule'].findSplinePoint(this);\n            }\n        }\n        var seriesType = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(this.type);\n        seriesType = seriesType.replace('100', '');\n        if (chart[seriesType + 'SeriesModule']) {\n            if (this.category !== 'Indicator' && this.category !== 'TrendLine') {\n                this.createSeriesElements(chart);\n            }\n            this.visiblePoints = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getVisiblePoints)(this);\n            if (this.chart.enableCanvas) {\n                this.chart.canvasRender.ctx.save();\n                this.chart.canvasRender.ctx.beginPath();\n                if (chart.requireInvertedAxis) {\n                    this.chart.canvasRender.ctx.rect(this.yAxis.rect.x, this.xAxis.rect.y, this.yAxis.rect.width, this.xAxis.rect.height);\n                }\n                else {\n                    this.chart.canvasRender.ctx.rect(this.xAxis.rect.x, this.yAxis.rect.y, this.xAxis.rect.width, this.yAxis.rect.height);\n                }\n                this.chart.canvasRender.ctx.clip();\n                chart[seriesType + 'SeriesModule'].render(this, this.xAxis, this.yAxis, chart.requireInvertedAxis);\n                this.chart.canvasRender.ctx.restore();\n            }\n            else {\n                chart[seriesType + 'SeriesModule'].render(this, this.xAxis, this.yAxis, chart.requireInvertedAxis);\n            }\n            if (this.category !== 'Indicator') {\n                if (this.errorBar.visible) {\n                    this.chart.errorBarModule.render(this);\n                }\n                if (this.marker.dataLabel.visible) {\n                    if (this.chart.enableCanvas) {\n                        this.chart.canvasRender.ctx.save();\n                        this.chart.canvasRender.ctx.beginPath();\n                        if (chart.requireInvertedAxis) {\n                            this.chart.canvasRender.ctx.rect(this.yAxis.rect.x, this.xAxis.rect.y, this.yAxis.rect.width, this.xAxis.rect.height);\n                        }\n                        else {\n                            this.chart.canvasRender.ctx.rect(this.xAxis.rect.x, this.yAxis.rect.y, this.xAxis.rect.width, this.yAxis.rect.height);\n                        }\n                        this.chart.canvasRender.ctx.clip();\n                        chart.dataLabelModule.render(this, this.chart, this.marker.dataLabel);\n                        this.chart.canvasRender.ctx.restore();\n                    }\n                    else {\n                        chart.dataLabelModule.render(this, this.chart, this.marker.dataLabel);\n                    }\n                }\n                this.appendSeriesElement(chart.seriesElements, chart);\n            }\n            if (!this.chart.enableCanvas) {\n                this.performAnimation(chart, seriesType, this.errorBar, this.marker, this.marker.dataLabel);\n            }\n        }\n    };\n    /**\n     * Creates elements for the series on the chart.\n     *\n     * @param {Chart} chart - The chart for which series elements are created.\n     * @returns {void}\n     * @private\n     */\n    Series.prototype.createSeriesElements = function (chart) {\n        if (this.category !== 'Indicator') {\n            var elementId = chart.element.id;\n            // 8 for extend border value 5 for extend size value\n            var explodeValue = this.marker.border.width + 8 + 5;\n            var render = (this.type === 'Bubble') || (!this.marker.visible && chart.tooltip.shared && chart.enableCanvas) ?\n                chart.svgRenderer : chart.renderer;\n            var index = this.index === undefined ? this.category : this.index;\n            var markerHeight = void 0;\n            var markerWidth = void 0;\n            var options = void 0;\n            if (this.type === 'Scatter' || this.drawType === 'Scatter') {\n                markerHeight = (this.marker.height + explodeValue) / 2;\n                markerWidth = (this.marker.width + explodeValue) / 2;\n            }\n            else {\n                markerHeight = 0;\n                markerWidth = 0;\n            }\n            if (chart.chartAreaType === 'PolarRadar') {\n                var markerMaxValue = (this.drawType === 'Scatter') ? Math.max(this.marker.width, this.marker.height) : 0;\n                options = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.CircleOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, this.clipRect.width / 2 + this.clipRect.x, this.clipRect.height / 2 + this.clipRect.y, chart.radius + markerMaxValue);\n                this.clipRectElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendClipElement)(chart.redraw, options, render, 'drawCircularClipPath');\n            }\n            else {\n                options = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.RectOption(elementId + '_ChartSeriesClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                    x: (this.xAxis.columnIndex === 0) ? -markerWidth : 0, y: (this.yAxis.rowIndex === chart.rows.length - 1) ? -markerHeight : 0,\n                    width: this.clipRect.width + (this.xAxis.columnIndex === chart.columns.length - 1 ? markerWidth * 2 : markerWidth),\n                    height: this.clipRect.height + (this.yAxis.rowIndex === 0 ? markerHeight * 2 : markerHeight)\n                });\n                this.clipRectElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendClipElement)(chart.redraw, options, render);\n            }\n            var transform = chart.chartAreaType === 'Cartesian' ? 'translate(' + this.clipRect.x + ',' + (this.clipRect.y) + ')' : '';\n            this.symbolElement = null;\n            this.seriesElement = render.createGroup({\n                'id': elementId + 'SeriesGroup' + index,\n                'transform': transform,\n                'clip-path': 'url(#' + elementId + '_ChartSeriesClipRect_' + index + ')'\n            });\n            if (this.seriesElement) {\n                this.seriesElement.setAttribute('role', this.accessibility.accessibilityRole ? this.accessibility.accessibilityRole : 'region');\n                this.seriesElement.setAttribute('tabindex', this.accessibility.focusable ? String(this.accessibility.tabIndex) : '-1');\n                this.seriesElement.style.outline = 'none';\n                this.seriesElement.setAttribute('aria-label', this.accessibility.accessibilityDescription ? this.accessibility.accessibilityDescription : (this.name + ',' + this.type + ' series with ' + this.points.length + ' data points'));\n                this.seriesElement.setAttribute('aria-hidden', 'false');\n            }\n            if (!this.chart.enableCanvas || this.type === 'Bubble') {\n                this.seriesElement.setAttribute('tabindex', this.accessibility.focusable ? (index === 0 ? '0' : !this.checkTabindex(chart.visibleSeries, index) ? String(this.accessibility.tabIndex) : '') : '-1');\n                this.seriesElement.style.outline = 'none';\n                this.seriesElement.appendChild(this.clipRectElement);\n            }\n        }\n    };\n    Series.prototype.checkTabindex = function (visibleSeries, index) {\n        for (var i = 0; i < index; i++) {\n            if (visibleSeries[i].visible) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Appends a series element to the chart.\n     *\n     * @param {Element} element - The series element to append.\n     * @param {Chart} chart - The chart to which the series element will be appended.\n     * @returns {void}\n     * @private\n     */\n    Series.prototype.appendSeriesElement = function (element, chart) {\n        var marker = this.marker;\n        var dataLabel = marker.dataLabel;\n        var redraw = chart.redraw;\n        if (this.category !== 'TrendLine') {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);\n            var errorBar = this.errorBar;\n            if (errorBar.visible) {\n                if (chart.chartAreaType === 'PolarRadar') {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(chart.enableCanvas, chart.seriesElements, this.seriesElement, redraw);\n                }\n                else {\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(chart.enableCanvas, chart.seriesElements, this.errorBarElement, redraw);\n                }\n            }\n        }\n        if (marker.visible && (chart.chartAreaType === 'Cartesian' ||\n            ((this.drawType !== 'Scatter') && chart.chartAreaType === 'PolarRadar')) && this.type !== 'Scatter' &&\n            this.type !== 'Bubble' && this.type !== 'Candle' && this.type !== 'Hilo' && this.type !== 'HiloOpenClose' && this.symbolElement) {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(chart.enableCanvas, chart.seriesElements, this.symbolElement, redraw);\n        }\n        if (dataLabel.visible && this.textElement) {\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(chart.enableCanvas, chart.dataLabelElements, this.shapeElement, redraw);\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(chart.enableCanvas, chart.dataLabelElements, this.textElement, redraw);\n        }\n        if (!chart.enableCanvas && chart.dataLabelElements.hasChildNodes()) {\n            chart.seriesElements.appendChild(chart.dataLabelElements);\n        }\n    };\n    /**\n     * Performs animation for the specified chart elements.\n     *\n     * @param {Chart} chart - The chart for which animation is performed.\n     * @param {string} type - The type of animation to be performed.\n     * @param {ErrorBarSettingsModel} errorBar - The error bar settings for the animation.\n     * @param {MarkerSettingsModel} marker - The marker settings for the animation.\n     * @param {DataLabelSettingsModel} dataLabel - The data label settings for the animation.\n     * @returns {void}\n     * @private\n     */\n    Series.prototype.performAnimation = function (chart, type, errorBar, marker, dataLabel) {\n        if (((this.animation.enable && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode !== 'Disable') || _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.animationMode === 'Enable') && chart.animateSeries && (!chart.stockChart || !chart.stockChart.isStockChartRendered)) {\n            chart[type + 'SeriesModule'].doAnimation(this);\n            if (errorBar.visible) {\n                chart.errorBarModule.doErrorBarAnimation(this);\n            }\n            if (marker.visible && (this.isRectSeries || this.type === 'Line' || this.type === 'Polar' || this.type === 'Radar')) {\n                chart.markerRender.doMarkerAnimation(this);\n            }\n            //to datalabel animation disabled for edge and IE\n            if (dataLabel.visible && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.info.name !== 'edge' && !_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Browser.isIE) {\n                chart.dataLabelModule.doDataLabelAnimation(this);\n            }\n        }\n    };\n    /**\n     * Sets the color of a data point.\n     *\n     * @param {Points} point - The data point.\n     * @param {string} color - The color to set.\n     * @returns {string} - The updated color.\n     * @private\n     */\n    Series.prototype.setPointColor = function (point, color) {\n        color = point.interior || color;\n        return point.isEmpty ? (this.emptyPointSettings.fill || color) : color;\n    };\n    /**\n     * Sets the border color of a data point.\n     *\n     * @param {Points} point - The data point.\n     * @param {BorderModel} border - The border color to set.\n     * @returns {BorderModel} - The updated border color.\n     * @private\n     */\n    Series.prototype.setBorderColor = function (point, border) {\n        border.width = point.isEmpty ? (this.emptyPointSettings.border.width || border.width) : border.width;\n        border.color = point.isEmpty ? (this.emptyPointSettings.border.color || border.color) : border.color;\n        return border;\n    };\n    /**\n     * Adds a data point to the data source.\n     *\n     * @function addPoint\n     * @param {Object} dataPoint - The data point to be added.\n     * @param {number} duration - The duration for the animation.\n     * @returns {void}\n     */\n    Series.prototype.addPoint = function (dataPoint, duration) {\n        var yMin = this.yMin;\n        var yMax = this.yMax;\n        this.removeTrackballElements();\n        this.dataSource.push(dataPoint);\n        if (this.type === 'Radar' || this.type === 'Polar') {\n            return this.chart.refresh();\n        }\n        if (this.type === 'Histogram') {\n            this.currentViewData = this.chart[(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(this.type) + 'SeriesModule'].\n                processInternalData((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSource, null, true), this);\n            for (var i = 0; i < this.currentViewData.length; i++) {\n                this.updatePoint(i);\n            }\n        }\n        else {\n            this.currentViewData = this.dataSource;\n            var pointIndex = this.points.length === 0 ? 0 : this.points[this.points.length - 1].index + 1;\n            this.updatePoint(pointIndex);\n        }\n        if (this.category === 'Pareto') {\n            var dataSource = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSource, null, true);\n            var series = this.chart.visibleSeries[this.index + this.chart.series.length];\n            series.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(dataSource, this);\n            for (var i = 0; i < series.currentViewData.length; i++) {\n                if (!series.points[i]) {\n                    series.updatePoint(i);\n                }\n                series.points[i].y = series.points[i].yValue = series.currentViewData[i][series.yName];\n            }\n        }\n        this.updateSplineValue();\n        this.chart.calculateStackValues();\n        this.chart.redraw = this.chart.enableAnimation;\n        var chartDuration = this.chart.duration;\n        this.chart.duration = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(duration) ? 500 : duration;\n        this.chart.animateSeries = false;\n        this.chart.pointsAdded = true;\n        if (this.chart.enableAnimation && (!(this.isRectSeries || this.type === 'Bubble' || this.type === 'Scatter')) && (this.type.indexOf('step') === -1)) {\n            if (this.marker && this.marker.visible && this.visible) {\n                for (var i = this.points.length - 2; i >= 0; i--) {\n                    if (this.points[i] && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.points[this.points.length - 2].y) &&\n                        this.points[i].symbolLocations && this.points[i].symbolLocations[0] !== undefined) {\n                        this.chart.markerRender.renderMarker(this, this.points[this.points.length - 2], this.points[i].symbolLocations[0], null, true);\n                        break;\n                    }\n                }\n            }\n        }\n        if (this.yMin >= yMin && this.yMax <= yMax) {\n            if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.xAxis)) {\n                this.xAxis.baseModule.calculateRangeAndInterval(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);\n                this.xAxis.updateAxis();\n            }\n            this.chart.pointsAdded = false;\n            this.updateSeries(true, false);\n        }\n        if (this.yMin < yMin || this.yMax > yMax) {\n            this.updateChartAxis();\n            this.chart.pointsAdded = false;\n            this.updateSeries(true, true);\n        }\n        this.chart.redraw = false;\n        this.chart.duration = chartDuration;\n    };\n    /**\n     * Removes a data point from the series data source at the specified index.\n     *\n     * @function removePoint\n     * @param {number} index - The index of the data point to be removed.\n     * @param {number} duration - The duration for the animation.\n     * @returns {void}\n     */\n    Series.prototype.removePoint = function (index, duration) {\n        var dataSource = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSource, null, true);\n        var chartDuration = this.chart.duration;\n        if (dataSource.length > 0 && index >= 0 && index < dataSource.length) {\n            dataSource.splice(index, 1);\n            this.dataSource.splice(index, 1);\n            this.removeTrackballElements(index);\n            if (this.type === 'Radar' || this.type === 'Polar') {\n                return this.chart.refresh();\n            }\n            this.chart.redraw = this.chart.enableAnimation;\n            this.chart.animateSeries = false;\n            this.chart.pointsAdded = true;\n            this.chart.duration = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(duration) ? 500 : duration;\n            if (this.type === 'Histogram') {\n                var length_1 = this.points.length;\n                this.points = [];\n                this.visiblePoints = [];\n                this.currentViewData = this.chart[(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(this.type) + 'SeriesModule'].\n                    processInternalData((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSource, null, true), this);\n                for (var i = 0; i < this.currentViewData.length; i++) {\n                    this.updatePoint(i);\n                }\n                if (length_1 > this.points.length) {\n                    this.removedPointIndex = index;\n                }\n            }\n            else {\n                this.removedPointIndex = index;\n                this.points.splice(index, 1);\n                this.visiblePoints.splice(index, 1);\n            }\n            this.yData = [];\n            this.xData = [];\n            var yMin = this.yMin;\n            var yMax = this.yMax;\n            this.yMin = Infinity;\n            this.xMin = Infinity;\n            this.yMax = -Infinity;\n            this.xMax = -Infinity;\n            if (this.xAxis.valueType.indexOf('Category') > -1 && this.chart.series.length === 1) {\n                this.xAxis.labels = [];\n                this.xAxis.indexLabels = {};\n            }\n            if (index === 0) {\n                this.chart.pointsRemoved = this.chart.enableAnimation;\n            }\n            for (var i = 0; i < this.points.length; i++) {\n                this.updatePointsAfterRemoval(i);\n            }\n            if (this.category === 'Pareto') {\n                var series = this.chart.visibleSeries[this.index + this.chart.series.length];\n                series.yMin = Infinity;\n                series.xMin = Infinity;\n                series.yMax = -Infinity;\n                series.xMax = -Infinity;\n                series.points.splice(index, 1);\n                series.visiblePoints.splice(index, 1);\n                series.currentViewData = this.chart.paretoSeriesModule.performCumulativeCalculation(this.dataSource, this);\n                for (var i = 0; i < series.currentViewData.length; i++) {\n                    series.points[i].y = series.points[i].yValue = series.currentViewData[i][series.yName];\n                    series.updatePointsAfterRemoval(i);\n                }\n            }\n            this.updateSplineValue();\n            this.chart.calculateStackValues();\n            if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.xAxis) && yMax === this.yMax && yMin === this.yMin) {\n                this.xAxis.baseModule.calculateRangeAndInterval(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);\n                this.xAxis.updateAxis();\n                this.createSeriesElements(this.chart);\n                this.chart.pointsAdded = false;\n                this.updateSeries(true, false);\n            }\n            else if (yMax < this.yMax || yMin > this.yMin || yMax > this.yMax || yMin < this.yMin) {\n                this.updateChartAxis();\n                this.createSeriesElements(this.chart);\n                this.chart.pointsAdded = false;\n                this.updateSeries(true, true);\n            }\n        }\n        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(this.chart.enableCanvas, this.chart.seriesElements, this.seriesElement, true);\n        this.chart.redraw = false;\n        this.chart.duration = chartDuration;\n        this.chart.pointsRemoved = false;\n        this.removedPointIndex = null;\n    };\n    Series.prototype.updatePointsAfterRemoval = function (index) {\n        var point = this.points[index];\n        var option = {\n            skeleton: 'full',\n            type: 'dateTime'\n        };\n        var dateParser = this.chart.intl.getDateParser(option);\n        var dateFormatter = this.chart.intl.getDateFormat(option);\n        if (this.xAxis.valueType === 'Category' && this.chart.series.length === 1) {\n            this.pushCategoryData(point, index, point.x);\n        }\n        else if (this.xAxis.valueType === 'DateTimeCategory' && this.chart.series.length === 1) {\n            this.pushCategoryData(point, index, Date.parse(dateParser(dateFormatter(point.x))).toString());\n        }\n        this.pushData(point, index);\n        this.setEmptyPoint(this.points[index], index);\n    };\n    /**\n     * Removes trackball elements from the series.\n     *\n     * @param {number} index - The index of the data point.\n     * @returns {void}\n     */\n    Series.prototype.removeTrackballElements = function (index) {\n        if (this.marker.visible) {\n            if (index !== undefined) {\n                var baseId = this.chart.element.id + '_Series_' + this.index + '_Point_' + index + '_Trackball_';\n                var trackball0 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(baseId + '0');\n                if (trackball0) {\n                    trackball0.remove();\n                }\n                var trackball1 = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(baseId + '1');\n                if (trackball1) {\n                    trackball1.remove();\n                }\n                var symbolElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.chart.element.id + '_Series_' + this.index + '_Point_' + index + '_Symbol');\n                if (symbolElement) {\n                    symbolElement.setAttribute('visibility', 'visible');\n                }\n            }\n            else {\n                var baseClassPattern = this.chart.element.id + '_EJ2-Trackball_Series_' + this.index + '_Point_';\n                var elements = document.querySelectorAll(\"[class*=\\\"\" + baseClassPattern + \"\\\"]\");\n                if (elements[0]) {\n                    var pointIndexMatch = elements[0].id.match(/_Point_(\\d+)_/);\n                    var pointIndex = pointIndexMatch ? parseInt(pointIndexMatch[1], 10) : null;\n                    elements[0].remove();\n                    var symbolElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.chart.element.id + '_Series_' + this.index + '_Point_' + pointIndex + '_Symbol');\n                    if (symbolElement) {\n                        symbolElement.setAttribute('visibility', 'visible');\n                    }\n                }\n                if (elements[1]) {\n                    elements[1].remove();\n                }\n            }\n        }\n        if (this.chart.tooltip.enable) {\n            this.chart.tooltipModule.previousPoints = [];\n            var tooltipElement = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)(this.chart.element.id + '_tooltip');\n            if (tooltipElement) {\n                tooltipElement.remove();\n            }\n        }\n    };\n    /**\n     * Sets the data source with the provided data.\n     *\n     * @function setData\n     * @param {Object[]} data - An array of objects representing the data points.\n     * @param {number} duration - The duration for the animation.\n     * @returns {void}\n     */\n    Series.prototype.setData = function (data, duration) {\n        var _this = this;\n        if (!data) {\n            return null;\n        }\n        var updatedData = [];\n        if (this.dataSource.length === data.length) {\n            for (var i = 0; i < data.length; i++) {\n                if (data[i][this.xName] instanceof Date) {\n                    updatedData.push(data[i][this.xName].getTime());\n                }\n                else {\n                    updatedData.push(data[i][this.xName]);\n                }\n                if (this.currentData.length < this.dataSource.length) {\n                    var dataSource = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], this.dataSource, null, true);\n                    if (dataSource[i][this.xName] instanceof Date) {\n                        this.currentData.push(dataSource[i][this.xName].getTime());\n                    }\n                    else {\n                        this.currentData.push(dataSource[i][this.xName]);\n                    }\n                }\n            }\n        }\n        var isSameData = updatedData.every(function (element) { return _this.currentData.indexOf(element) !== -1; });\n        if (this.currentViewData) {\n            isSameData = true;\n        }\n        var isXAxisChanged = false;\n        var yMin = this.yMin;\n        var yMax = this.yMax;\n        this.yMin = Infinity;\n        this.yMax = -Infinity;\n        var points = [];\n        this.chart.dataLabelCollections = [];\n        this.chart.rotatedDataLabelCollections = [];\n        var samePoints = false;\n        var index = null;\n        if (this.dataSource.length === data.length && !(this.type === 'Radar' || this.type === 'Polar') && isSameData) {\n            samePoints = true;\n            this.yData = [];\n            if (this.type === 'Histogram' && this.dataSource.length === data.length) {\n                var newHistogramData = this.chart[(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(this.type) + 'SeriesModule'].\n                    processInternalData((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.extend)([], data, null, true), this);\n                this.currentViewData = newHistogramData;\n                for (var j = 0; j < newHistogramData.length; j++) {\n                    this.updatePoint(j);\n                }\n            }\n            else {\n                for (var i = 0; i < data.length; i++) {\n                    var newData = data[i][this.xName];\n                    var existingData = this.dataSource[i][this.xName];\n                    if (data[i][this.xName] instanceof Date) {\n                        newData = data[i][this.xName].getTime();\n                        existingData = this.dataSource[i][this.xName].getTime();\n                    }\n                    if (this.currentData[i] !== newData) {\n                        isXAxisChanged = true;\n                    }\n                    var point = this.points[i];\n                    var getObjectValueByMappingString = this.enableComplexProperty ? _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.getValue : this.getObjectValue;\n                    var existingPoint = this.dataSource[i];\n                    var newPoint = data[i];\n                    if ((this.seriesType === 'XY' || this.seriesType === 'BoxPlot')) {\n                        point.y = getObjectValueByMappingString(this.yName, newPoint);\n                        if (this.type === 'Bubble' && existingPoint[this.size] !== newPoint[this.size]) {\n                            point.size = getObjectValueByMappingString(this.size, newPoint);\n                        }\n                        points.push(i);\n                    }\n                    else if (existingPoint[this.high] !== newPoint[this.high] || existingPoint[this.low] !== newPoint[this.low] ||\n                        existingPoint[this.open] !== newPoint[this.open] || existingPoint[this.close] !== newPoint[this.close] ||\n                        existingPoint[this.volume] !== newPoint[this.volume]) {\n                        point.high = getObjectValueByMappingString(this.high, newPoint);\n                        point.low = getObjectValueByMappingString(this.low, newPoint);\n                        point.open = getObjectValueByMappingString(this.open, newPoint);\n                        point.close = getObjectValueByMappingString(this.close, newPoint);\n                        point.volume = getObjectValueByMappingString(this.volume, newPoint);\n                        points.push(i);\n                    }\n                    point.yValue = point.y;\n                    point.x = getObjectValueByMappingString(this.xName, newPoint);\n                    if (!this.currentViewData) {\n                        point.index = (this.xAxis.valueType === 'DateTime' && typeof (point.x) !== 'number') ? this.currentData.indexOf(point.x.getTime()) : this.currentData.indexOf(point.x);\n                    }\n                    if ((this.xAxis.valueType === 'Category' || this.xAxis.valueType === 'DateTimeCategory') && i < this.xAxis.visibleLabels.length) {\n                        this.xAxis.visibleLabels[i].value = updatedData.indexOf(this.currentData[i *\n                            this.xAxis.visibleRange.interval]);\n                        this.xAxis.labels[i] = String(updatedData[i]);\n                    }\n                    this.setEmptyPoint(point, i);\n                    this.dataSource[i] = data[i];\n                }\n            }\n        }\n        if (!samePoints) {\n            this.dataSource = data;\n        }\n        else {\n            this.chart.redraw = this.chart.enableAnimation;\n            this.chart.animateSeries = false;\n            this.chart.pointsAdded = true;\n            var chartDuration = this.chart.duration;\n            this.chart.duration = (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(duration) ? 500 : duration;\n            if (this.type.indexOf('Stacking') !== -1) {\n                this.chart.calculateStackValues();\n            }\n            this.updateSplineValue();\n            if (yMax === this.yMax && yMin === this.yMin && this.visible) {\n                this.chart.pointsAdded = false;\n                this.chart[(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)((this.category === 'Pareto' ? 'Column' : this.type.replace('100', ''))) + 'SeriesModule'].updateDirection(this, points, this.chart.requireInvertedAxis);\n                if (this.chart.annotationModule) {\n                    this.chart.annotationModule.renderAnnotations((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)((this.chart.element.id) + '_Secondary_Element'));\n                }\n                if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.xAxis) && (isXAxisChanged)) {\n                    this.xAxis.updateAxis();\n                }\n            }\n            else if ((yMax < this.yMax || yMin > this.yMin || yMax > this.yMax || yMin < this.yMin) && this.visible) {\n                var maximumLabelWidth = this.yAxis.maxLabelSize.width;\n                this.yAxis.baseModule.calculateRangeAndInterval(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Size(this.chart.availableSize.width, this.yAxis.rect.height), this.yAxis);\n                if (maximumLabelWidth < this.yAxis.maxLabelSize.width) {\n                    this.chart.calculateBounds();\n                    this.chart.axisCollections.forEach(function (axis) {\n                        if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(axis)) {\n                            axis.updateAxis();\n                        }\n                    });\n                    this.chart.chartAxisLayoutPanel.drawPaneLines(this.chart);\n                    this.chart.renderAreaBorder();\n                }\n                else {\n                    if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.yAxis)) {\n                        this.yAxis.updateAxis();\n                    }\n                    if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.xAxis) && (isXAxisChanged)) {\n                        this.xAxis.updateAxis();\n                    }\n                    if (this.type === 'Histogram' && !(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.xAxis)) {\n                        this.xAxis.baseModule.calculateRangeAndInterval(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);\n                        this.xAxis.updateAxis();\n                    }\n                }\n                this.chart.pointsAdded = false;\n                if (isXAxisChanged) {\n                    this.chart[(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)((this.category === 'Pareto' ? 'Column' : this.type.replace('100', ''))) + 'SeriesModule'].updateDirection(this, points, this.chart.requireInvertedAxis);\n                    index = this.index;\n                }\n                this.updateSeries(false, true, index);\n                if (this.chart.stripLineModule) {\n                    this.chart.stripLineModule.renderStripLine(this.chart, 'Behind', this.chart.axisCollections);\n                }\n            }\n            this.chart.redraw = false;\n            this.chart.pointsRemoved = false;\n            this.chart.duration = chartDuration;\n        }\n    };\n    /**\n     * Updates the chart axes based on current data and axis bounds.\n     *\n     * @returns {void}\n     */\n    Series.prototype.updateChartAxis = function () {\n        var maximumLabelWidth = this.yAxis.maxLabelSize.width;\n        this.yAxis.baseModule.calculateRangeAndInterval(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Size(this.chart.availableSize.width, this.yAxis.rect.height), this.yAxis);\n        if (maximumLabelWidth < this.yAxis.maxLabelSize.width) {\n            this.chart.calculateBounds();\n            this.chart.axisCollections.forEach(function (axis) {\n                if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(axis)) {\n                    axis.updateAxis();\n                }\n            });\n            this.chart.chartAxisLayoutPanel.drawPaneLines(this.chart);\n            this.chart.renderAreaBorder();\n        }\n        else {\n            if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.xAxis)) {\n                this.xAxis.baseModule.calculateRangeAndInterval(new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_2__.Size(this.xAxis.rect.width, this.chart.availableSize.height), this.xAxis);\n                this.xAxis.updateAxis();\n            }\n            if (!(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.setRange)(this.yAxis)) {\n                this.yAxis.updateAxis();\n            }\n        }\n        if (this.chart.stripLineModule) {\n            this.chart.stripLineModule.renderStripLine(this.chart, 'Behind', this.chart.axisCollections);\n        }\n    };\n    Series.prototype.updateSeries = function (xAxis, yAxis, index) {\n        var seriesCollection = [];\n        if (xAxis && yAxis) {\n            var set = new Set(this.xAxis.series.concat(this.yAxis.series));\n            set.forEach(function (series) {\n                seriesCollection.push(series);\n            });\n        }\n        else {\n            seriesCollection = xAxis ? this.xAxis.series.slice() : this.yAxis.series.slice();\n        }\n        for (var _i = 0, seriesCollection_4 = seriesCollection; _i < seriesCollection_4.length; _i++) {\n            var series = seriesCollection_4[_i];\n            if (series.visible && series.index !== index) {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.findClipRect)(series, this.chart.enableCanvas);\n                var transform = 'translate(' + this.clipRect.x + ',' + (this.clipRect.y) + ')';\n                series.seriesElement.setAttribute('transform', transform);\n                series.chart[(0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.firstToLowerCase)(series.type.replace('100', '')) + 'SeriesModule'].render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, series.chart.enableAnimation);\n                if (series.marker.visible && (series.chart.chartAreaType === 'Cartesian') && series.type !== 'Scatter' && series.type !== 'Bubble'\n                    && series.type !== 'Candle' && series.type !== 'Hilo' && series.type !== 'HiloOpenClose' && series.symbolElement) {\n                    series.symbolElement.setAttribute('transform', transform);\n                    (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(series.chart.enableCanvas, series.chart.seriesElements, series.symbolElement, true);\n                }\n                if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                    series.chart.dataLabelCollections = [];\n                    series.chart.dataLabelModule.render(series, series.chart, series.marker.dataLabel);\n                    if (series.textElement) {\n                        if (series.shapeElement) {\n                            series.shapeElement.setAttribute('transform', transform);\n                        }\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(series.chart.enableCanvas, series.chart.dataLabelElements, series.shapeElement, true);\n                        series.textElement.setAttribute('transform', transform);\n                        (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.appendChildElement)(series.chart.enableCanvas, series.chart.dataLabelElements, series.textElement, true);\n                    }\n                }\n                if (series.chart.annotationModule) {\n                    series.chart.annotationModule.renderAnnotations((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_1__.getElement)((series.chart.element.id) + '_Secondary_Element'));\n                }\n            }\n        }\n    };\n    Series.prototype.updatePoint = function (index) {\n        var point = new Points();\n        var textMappingName = this instanceof Series && this.marker.dataLabel.name ?\n            this.marker.dataLabel.name : '';\n        var xName = (this instanceof Series && this.type === 'Histogram') ? 'x' : this.xName;\n        if (this.xAxis.valueType === 'Category') {\n            this.pushCategoryPoint(point, index, textMappingName, xName);\n        }\n        else if (this.xAxis.valueType.indexOf('DateTime') > -1) {\n            var point_1 = this.points[index];\n            var option = {\n                skeleton: 'full',\n                type: 'dateTime'\n            };\n            var dateParser = this.chart.intl.getDateParser(option);\n            var dateFormatter = this.chart.intl.getDateFormat(option);\n            this.pushDateTimePoint(point_1, index, textMappingName, xName, dateParser, dateFormatter);\n        }\n        else {\n            this.pushDoublePoint(point, index, textMappingName, xName);\n        }\n    };\n    /**\n     * Formats the accessibility description for a chart series.\n     *\n     * @param {Points} point - Data point containing the values to be formatted.\n     * @param {Series} series - Series containing the values to be formatted.\n     * @param {string} format - String format with placeholders to be replaced with actual values.\n     * @returns {string} The formatted accessibility description string.\n     */\n    Series.prototype.formatAccessibilityDescription = function (point, series) {\n        var format = series.accessibility.accessibilityDescriptionFormat;\n        return format\n            .replace('${series.name}', series && series.name ? series.name : '')\n            .replace('${point.x}', point && point.x ? point.x.toString() : '')\n            .replace('${point.y}', point && point.y ? point.y.toString() : '')\n            .replace('${point.high}', point && point.high ? point.high.toString() : '')\n            .replace('${point.low}', point && point.low ? point.low.toString() : '')\n            .replace('${point.close}', point && point.close ? point.close.toString() : '')\n            .replace('${point.open}', point && point.open ? point.open.toString() : '')\n            .replace('${point.maximum}', point && point.maximum ? point.maximum.toString() : '')\n            .replace('${point.minimum}', point && point.minimum ? point.minimum.toString() : '')\n            .replace('${point.median}', point && point.median ? point.median.toString() : '')\n            .replace('${point.lowerQuartile}', point && point.lowerQuartile ? point.lowerQuartile.toString() : '')\n            .replace('${point.upperQuartile}', point && point.upperQuartile ? point.upperQuartile.toString() : '');\n    };\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"name\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"yName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Line')\n    ], Series.prototype, \"drawType\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Series.prototype, \"isClosed\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"bearFillColor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"bullFillColor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], Series.prototype, \"enableSolidCandles\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"size\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"binInterval\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], Series.prototype, \"showNormalDistribution\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"stackingGroup\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ color: null, width: 0 }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Border)\n    ], Series.prototype, \"border\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], Series.prototype, \"opacity\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Series.prototype, \"zOrder\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"groupName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Line')\n    ], Series.prototype, \"type\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, ErrorBarSettings)\n    ], Series.prototype, \"errorBar\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, MarkerSettings)\n    ], Series.prototype, \"marker\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, ParetoOptions)\n    ], Series.prototype, \"paretoOptions\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.DragSettings)\n    ], Series.prototype, \"dragSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Collection)([], Trendline)\n    ], Series.prototype, \"trendlines\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Series.prototype, \"enableTooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Series.prototype, \"showNearestTooltip\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"tooltipFormat\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"tooltipMappingName\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('SeriesType')\n    ], Series.prototype, \"legendShape\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('')\n    ], Series.prototype, \"legendImageUrl\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"selectionStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"unSelectedStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"nonHighlightStyle\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(1)\n    ], Series.prototype, \"minRadius\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(3)\n    ], Series.prototype, \"maxRadius\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Natural')\n    ], Series.prototype, \"splineType\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0.5)\n    ], Series.prototype, \"cardinalSplineTension\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.EmptyPointSettings)\n    ], Series.prototype, \"emptyPointSettings\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Series.prototype, \"showMean\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Normal')\n    ], Series.prototype, \"boxPlotMode\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(true)\n    ], Series.prototype, \"showOutliers\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"columnWidth\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(null)\n    ], Series.prototype, \"columnWidthInPixel\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Rectangle')\n    ], Series.prototype, \"columnFacet\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(0)\n    ], Series.prototype, \"columnSpacing\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('#C64E4A')\n    ], Series.prototype, \"negativeFillColor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('#4E81BC')\n    ], Series.prototype, \"summaryFillColor\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Series.prototype, \"intermediateSumIndexes\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)()\n    ], Series.prototype, \"sumIndexes\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)('Left')\n    ], Series.prototype, \"step\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Property)(false)\n    ], Series.prototype, \"noRisers\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({}, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.SeriesAccessibility)\n    ], Series.prototype, \"accessibility\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)({ color: 'black', width: 2 }, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.Connector)\n    ], Series.prototype, \"connector\", void 0);\n    __decorate([\n        (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_0__.Complex)(null, _common_model_base__WEBPACK_IMPORTED_MODULE_3__.CornerRadius)\n    ], Series.prototype, \"cornerRadius\", void 0);\n    return Series;\n}(SeriesBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/chart-series.js?");

/***/ })

}]);