"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_smithchart_axis_axisrender_js-98339764"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/smithchart/axis/axisrender.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/smithchart/axis/axisrender.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AxisRender: () => (/* binding */ AxisRender)\n/* harmony export */ });\n/* harmony import */ var _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../smithchart/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/smithchart/utils/helper.js\");\n/* harmony import */ var _smithchart_utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../smithchart/utils/utils */ \"./node_modules/@syncfusion/ej2-charts/src/smithchart/utils/utils.js\");\n/* harmony import */ var _model_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/constant */ \"./node_modules/@syncfusion/ej2-charts/src/smithchart/model/constant.js\");\n\n\n\n\n\nvar AxisRender = /** @class */ (function () {\n    function AxisRender() {\n        this.radialLabels = [-50, -20, -10, -5, -4, -3, -2, -1.5, -1, -0.8, -0.6, -0.4, -0.2,\n            0, 0.2, 0.4, 0.6, 0.8, 1, 1.5, 2, 3, 4, 5, 10, 20, 50];\n        this.radialLabelCollections = [];\n        this.horizontalLabelCollections = [];\n        this.labelCollections = [];\n        this.direction = new _smithchart_utils_utils__WEBPACK_IMPORTED_MODULE_1__.Direction();\n    }\n    AxisRender.prototype.renderArea = function (smithchart, bounds) {\n        this.calculateChartArea(smithchart, bounds);\n        this.calculateCircleMargin(smithchart, bounds);\n        this.calculateXAxisRange(smithchart);\n        this.calculateRAxisRange(smithchart);\n        this.measureHorizontalAxis(smithchart);\n        this.measureRadialAxis(smithchart);\n        if (smithchart.horizontalAxis.visible) {\n            this.updateHAxis(smithchart);\n        }\n        if (smithchart.radialAxis.visible) {\n            this.updateRAxis(smithchart);\n        }\n        if (smithchart.horizontalAxis.visible) {\n            this.drawHAxisLabels(smithchart);\n        }\n        if (smithchart.radialAxis.visible) {\n            this.drawRAxisLabels(smithchart);\n        }\n    };\n    AxisRender.prototype.updateHAxis = function (smithchart) {\n        var majorGridLines = smithchart.horizontalAxis.majorGridLines;\n        var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n        var axisLine = smithchart.horizontalAxis.axisLine;\n        if (majorGridLines.visible) {\n            this.updateHMajorGridLines(smithchart);\n        }\n        if (minorGridLines.visible) {\n            this.updateHMinorGridLines(smithchart);\n        }\n        if (axisLine.visible) {\n            this.updateHAxisLine(smithchart);\n        }\n    };\n    AxisRender.prototype.updateRAxis = function (smithchart) {\n        var majorGridLines = smithchart.radialAxis.majorGridLines;\n        var minorGridLines = smithchart.radialAxis.minorGridLines;\n        var axisLine = smithchart.radialAxis.axisLine;\n        if (majorGridLines.visible) {\n            this.updateRMajorGridLines(smithchart);\n        }\n        if (minorGridLines.visible) {\n            this.updateRMinorGridLines(smithchart);\n        }\n        if (axisLine.visible) {\n            this.updateRAxisLine(smithchart);\n        }\n    };\n    AxisRender.prototype.measureHorizontalAxis = function (smithchart) {\n        var minorGridLines = smithchart.horizontalAxis.minorGridLines;\n        this.measureHMajorGridLines(smithchart);\n        if (minorGridLines.visible) {\n            this.measureHMinorGridLines(smithchart);\n        }\n    };\n    AxisRender.prototype.measureRadialAxis = function (smithchart) {\n        var minorGridLines = smithchart.radialAxis.minorGridLines;\n        this.measureRMajorGridLines(smithchart);\n        if (minorGridLines.visible) {\n            this.measureRMinorGridLines(smithchart);\n        }\n    };\n    AxisRender.prototype.calculateChartArea = function (smithchart, bounds) {\n        var width = smithchart.availableSize.width;\n        var height = smithchart.availableSize.height;\n        width = bounds.width;\n        height = bounds.height;\n        var chartAreaWidth = Math.min(width, height);\n        var chartAreaHeight = Math.min(width, height);\n        var x = bounds.x + (bounds.width / 2 - chartAreaWidth / 2);\n        var y = bounds.y + ((height - chartAreaHeight) / 2 > 0 ? (height - chartAreaHeight) / 2 : 0);\n        smithchart.chartArea = { x: x, y: y, width: chartAreaWidth, height: chartAreaHeight };\n    };\n    AxisRender.prototype.calculateCircleMargin = function (smithchart, bounds) {\n        var padding = 10;\n        var maxLabelWidth = 0;\n        var width = smithchart.chartArea.width;\n        var radius = smithchart.radius;\n        maxLabelWidth = this.maximumLabelLength(smithchart);\n        var labelMargin = (smithchart.radialAxis.labelPosition === 'Outside') ? (maxLabelWidth + padding) : padding;\n        var diameter = width - labelMargin * 2 > 0 ? width - labelMargin * 2 : 0;\n        var actualRadius = diameter / 2;\n        var circleCoefficient = radius > 1 ? 1 : (radius < 0.1 ? 0.1 : radius);\n        this.areaRadius = actualRadius * circleCoefficient;\n        this.circleLeftX = smithchart.chartArea.x + labelMargin + (actualRadius * (1 - circleCoefficient));\n        this.circleTopY = smithchart.chartArea.y + labelMargin + (actualRadius * (1 - circleCoefficient));\n        this.circleCenterX = this.circleLeftX + this.areaRadius;\n        this.circleCenterY = bounds.y + bounds.height / 2;\n    };\n    AxisRender.prototype.maximumLabelLength = function (smithchart) {\n        var maximumLabelLength = 0;\n        var font = smithchart.horizontalAxis.labelStyle;\n        var label;\n        var textSize;\n        for (var i = 0; i < this.radialLabels.length; i++) {\n            label = this.radialLabels[i].toString();\n            textSize = (0,_smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.measureText)(label, font, smithchart.themeStyle.axisLabelFont);\n            if (maximumLabelLength < textSize.width) {\n                maximumLabelLength = textSize.width;\n            }\n        }\n        return maximumLabelLength;\n    };\n    AxisRender.prototype.calculateAxisLabels = function () {\n        var spacingBetweenGridLines = 30;\n        var previousR = 0;\n        var j = 0;\n        var labels = [];\n        var diameter = this.areaRadius * 2;\n        for (var i = 0; i < 2; i = i + 0.1) {\n            i = Math.round(i * 10) / 10;\n            var coeff = 1 / (i + 1);\n            var isOverlap1 = false;\n            var isOverlap2 = false;\n            var radius = ((diameter * coeff) / 2) * 2;\n            if (previousR === 0.0 || i === 1) {\n                previousR = radius;\n                labels[j] = i;\n                j++;\n                continue;\n            }\n            if (i < 1) {\n                isOverlap1 = this.isOverlap(1, diameter, radius, spacingBetweenGridLines);\n            }\n            if (i > 1) {\n                isOverlap2 = this.isOverlap(2, diameter, radius, spacingBetweenGridLines);\n            }\n            if (isOverlap1 || isOverlap2) {\n                continue;\n            }\n            if (previousR - radius >= spacingBetweenGridLines) {\n                labels[j] = i;\n                j++;\n                previousR = radius;\n            }\n        }\n        var staticlabels = [2, 3, 4, 5, 10, 20, 50];\n        for (var k = 0; k < staticlabels.length; k++) {\n            labels[j] = staticlabels[k];\n            j++;\n        }\n        return labels;\n    };\n    AxisRender.prototype.isOverlap = function (x, d, previousR, spacingBetweenGridLines) {\n        var coeff = 1 / (x + 1); // (1 / 1+r) find the radius for the x value\n        var radius = ((d * coeff) / 2) * 2;\n        return previousR - radius < spacingBetweenGridLines;\n    };\n    AxisRender.prototype.calculateXAxisRange = function (smithchart) {\n        var x;\n        var coeff;\n        var radius;\n        var cx;\n        var diameter = this.areaRadius * 2;\n        var horizontalAxisLabels = this.calculateAxisLabels();\n        var cy = this.circleCenterY;\n        var circleStartX = this.circleLeftX;\n        var leftX = this.circleLeftX;\n        for (var i = 0; i < horizontalAxisLabels.length; i++) {\n            x = horizontalAxisLabels[i];\n            coeff = 1 / (x + 1);\n            radius = (diameter * coeff) / 2;\n            if (smithchart.renderType === 'Impedance') {\n                leftX = circleStartX + diameter - (radius * 2);\n            }\n            cx = leftX + radius;\n            this.horizontalLabelCollections.push({\n                centerX: cx, centerY: cy, radius: radius, value: x, region: null\n            });\n        }\n    };\n    AxisRender.prototype.calculateRAxisRange = function (smithchart) {\n        var arcCy;\n        var arcRadius;\n        var diameter = this.areaRadius * 2;\n        var y;\n        var point = new _smithchart_utils_utils__WEBPACK_IMPORTED_MODULE_1__.Point();\n        if (smithchart.renderType === 'Impedance') {\n            point.x = this.circleLeftX + diameter;\n            point.y = this.circleTopY + this.areaRadius;\n        }\n        else {\n            point.x = this.circleLeftX;\n            point.y = this.circleTopY + this.areaRadius;\n        }\n        for (var i = 0; i < this.radialLabels.length; i++) {\n            y = this.radialLabels[i];\n            arcRadius = Math.abs(((1 / y) * diameter) / 2);\n            if (smithchart.renderType === 'Impedance') {\n                arcCy = y > 0 ? point.y - arcRadius : point.y + arcRadius;\n            }\n            else {\n                arcCy = y < 0 ? point.y - arcRadius : point.y + arcRadius;\n            }\n            this.radialLabelCollections.push({\n                centerX: point.x, centerY: arcCy, radius: arcRadius, value: y\n            });\n        }\n    };\n    AxisRender.prototype.measureHMajorGridLines = function (smithchart) {\n        var arcPoints = [];\n        var startPoint;\n        var endPoint;\n        var radialPoint1;\n        var radialPoint2;\n        var size;\n        this.majorHGridArcPoints = [];\n        for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n            var circlePoint = new _smithchart_utils_utils__WEBPACK_IMPORTED_MODULE_1__.HorizontalLabelCollection();\n            circlePoint = this.horizontalLabelCollections[i];\n            arcPoints = this.calculateHMajorArcStartEndPoints(circlePoint.value);\n            if (smithchart.renderType === 'Impedance') {\n                radialPoint1 = arcPoints[0];\n                radialPoint2 = arcPoints[1];\n            }\n            else {\n                radialPoint1 = arcPoints[1];\n                radialPoint2 = arcPoints[0];\n            }\n            size = { width: circlePoint.radius, height: circlePoint.radius };\n            if (circlePoint.value !== 0.0 && circlePoint.value !== 50.0) {\n                startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n                endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, circlePoint.centerX, circlePoint.centerY, circlePoint.radius, smithchart.renderType);\n                this.majorHGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: (smithchart.renderType === 'Impedance') ?\n                        this.direction['counterclockwise'] : this.direction['clockwise'],\n                    isLargeArc: true,\n                    size: size\n                });\n            }\n            else {\n                startPoint = { x: circlePoint.centerX + circlePoint.radius, y: circlePoint.centerY };\n                endPoint = { x: circlePoint.centerX + circlePoint.radius, y: circlePoint.centerY - 0.05 };\n                this.majorHGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: this.direction['clockwise'],\n                    isLargeArc: true,\n                    size: size\n                });\n            }\n        }\n    };\n    AxisRender.prototype.measureRMajorGridLines = function (smithchart) {\n        var radialPoint;\n        var y;\n        var arcPoints = [];\n        var innerInterSectPoint;\n        var outerInterSectPoint;\n        var outterInterSectRadian;\n        var outterInterSectAngle;\n        var startPoint;\n        var endPoint;\n        var size;\n        var sweepDirection;\n        this.majorRGridArcPoints = [];\n        this.labelCollections = [];\n        var epsilon = (0,_smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__._getEpsilonValue)();\n        for (var i = 0; i < this.radialLabelCollections.length; i++) {\n            radialPoint = this.radialLabelCollections[i];\n            if (radialPoint.radius <= epsilon) {\n                continue;\n            }\n            y = radialPoint.value;\n            arcPoints = this.calculateMajorArcStartEndPoints(radialPoint, Math.abs(y), smithchart);\n            innerInterSectPoint = arcPoints[0];\n            outerInterSectPoint = arcPoints[1];\n            outterInterSectRadian = this.circleXYRadianValue(this.circleCenterX, this.circleCenterY, outerInterSectPoint.x, outerInterSectPoint.y);\n            outterInterSectAngle = outterInterSectRadian * (180 / Math.PI);\n            if (y !== 0.0) {\n                startPoint = { x: innerInterSectPoint.x, y: innerInterSectPoint.y };\n                endPoint = { x: outerInterSectPoint.x, y: outerInterSectPoint.y };\n                size = { width: radialPoint.radius, height: radialPoint.radius };\n                sweepDirection = y > 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n                this.majorRGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    size: size,\n                    rotationAngle: 2 * Math.PI,\n                    isLargeArc: false,\n                    sweepDirection: sweepDirection\n                });\n                this.labelCollections.push({\n                    centerX: outerInterSectPoint.x,\n                    centerY: outerInterSectPoint.y,\n                    angle: outterInterSectAngle,\n                    value: y,\n                    radius: this.areaRadius,\n                    region: null\n                });\n            }\n            else {\n                startPoint = { x: this.circleLeftX, y: this.circleCenterY };\n                endPoint = { x: this.circleCenterX + this.areaRadius, y: this.circleCenterY };\n                this.majorRGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    size: null,\n                    rotationAngle: null,\n                    isLargeArc: null,\n                    sweepDirection: null\n                });\n                this.labelCollections.push({\n                    centerX: (smithchart.renderType === 'Impedance') ?\n                        (this.circleCenterX - this.areaRadius) : (this.circleCenterX + this.areaRadius),\n                    centerY: this.circleCenterY,\n                    angle: (smithchart.renderType === 'Impedance') ?\n                        180 : 360,\n                    value: y,\n                    radius: this.areaRadius,\n                    region: null\n                });\n            }\n        }\n    };\n    AxisRender.prototype.circleXYRadianValue = function (centerX, centerY, outterX, outterY) {\n        var radian;\n        radian = Math.atan2(outterY - centerY, outterX - centerX);\n        radian = radian < 0 ? (radian + (360 * Math.PI / 180)) : radian;\n        return radian;\n    };\n    AxisRender.prototype.calculateMajorArcStartEndPoints = function (radialPoint, value, smithchart) {\n        var arcPoints = [];\n        var circlePoint = [];\n        var cx = this.circleCenterX;\n        var cy = this.circleCenterY;\n        if (value >= 10) {\n            arcPoints[0] = (smithchart.renderType === 'Impedance') ?\n                { x: cx + this.areaRadius, y: cy } : { x: cx - this.areaRadius, y: cy };\n        }\n        else if (value >= 3) {\n            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 10; });\n        }\n        else if (value >= 1) {\n            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 5; });\n        }\n        else {\n            circlePoint = this.horizontalLabelCollections.filter(function (c) { return c.value === 3; });\n        }\n        if (circlePoint.length > 0) {\n            arcPoints[0] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n        }\n        arcPoints[1] = this.intersectingCirclePoints(radialPoint.centerX, radialPoint.centerY, radialPoint.radius, cx, cy, this.areaRadius, smithchart.renderType);\n        return arcPoints;\n    };\n    AxisRender.prototype.calculateHMajorArcStartEndPoints = function (value) {\n        var arcHPoints = [];\n        var calValue1;\n        var calValue2;\n        if (value <= 0.3) {\n            calValue1 = 2.0;\n            calValue2 = -2.0;\n        }\n        else if (value <= 1.0) {\n            calValue1 = 3.0;\n            calValue2 = -3.0;\n        }\n        else if (value <= 2.0) {\n            calValue1 = 5.0;\n            calValue2 = -5.0;\n        }\n        else if (value <= 5.0) {\n            calValue1 = 10.0;\n            calValue2 = -10.0;\n        }\n        else {\n            calValue1 = 50.0;\n            calValue2 = -50.0;\n        }\n        arcHPoints[0] = this.radialLabelCollections.filter(function (c) { return c.value === calValue1; });\n        arcHPoints[1] = this.radialLabelCollections.filter(function (c) { return c.value === calValue2; });\n        return arcHPoints;\n    };\n    AxisRender.prototype.calculateMinorArcStartEndPoints = function (value) {\n        var calValue1;\n        var calValue2;\n        var marcHPoints = [];\n        if (value <= 0.1) {\n            calValue1 = 1.0;\n            calValue2 = -1.0;\n        }\n        else if (value <= 0.2) {\n            calValue1 = 0.8;\n            calValue2 = -0.8;\n        }\n        else if (value <= 0.3) {\n            calValue1 = 0.4;\n            calValue2 = -0.4;\n        }\n        else if (value <= 0.6) {\n            calValue1 = 1.0;\n            calValue2 = -1.0;\n        }\n        else if (value <= 1.0) {\n            calValue1 = 1.5;\n            calValue2 = -1.5;\n        }\n        else if (value <= 1.5) {\n            calValue1 = 2.0;\n            calValue2 = -2.0;\n        }\n        else if (value <= 2.0) {\n            calValue1 = 1.0;\n            calValue2 = -1.0;\n        }\n        else if (value <= 5.0) {\n            calValue1 = 3.0;\n            calValue2 = -3.0;\n        }\n        else {\n            calValue1 = 10.0;\n            calValue2 = -10.0;\n        }\n        marcHPoints[0] = this.radialLabelCollections.filter(function (c) { return c['value'] === calValue1; });\n        marcHPoints[1] = this.radialLabelCollections.filter(function (c) { return c['value'] === calValue2; });\n        return marcHPoints;\n    };\n    AxisRender.prototype.intersectingCirclePoints = function (x1, y1, r1, x2, y2, r2, renderType) {\n        var point = { x: 0, y: 0 };\n        var cx = x1 - x2;\n        var cy = y1 - y2;\n        var midRadius = Math.sqrt(cx * cx + cy * cy);\n        var radiusSquare = midRadius * midRadius;\n        var a = (r1 * r1 - r2 * r2) / (2 * radiusSquare);\n        var radiusSquare2 = (r1 * r1 - r2 * r2);\n        var c = Math.sqrt(2 * (r1 * r1 + r2 * r2) / radiusSquare - (radiusSquare2 * radiusSquare2) / (radiusSquare * radiusSquare) - 1);\n        var fx = (x1 + x2) / 2 + a * (x2 - x1);\n        var gx = c * (y2 - y1) / 2;\n        var ix1 = fx + gx;\n        var ix2 = fx - gx;\n        var fy = (y1 + y2) / 2 + a * (y2 - y1);\n        var gy = c * (x1 - x2) / 2;\n        var iy1 = fy + gy;\n        var iy2 = fy - gy;\n        if (renderType === 'Impedance') {\n            if (ix2 < ix1) {\n                point.x = ix2;\n                point.y = iy2;\n            }\n            else {\n                point.x = ix1;\n                point.y = iy1;\n            }\n        }\n        else {\n            if (ix1 > ix2) {\n                point.x = ix1;\n                point.y = iy1;\n            }\n            else {\n                point.x = ix2;\n                point.y = iy2;\n            }\n        }\n        return { x: point.x, y: point.y };\n    };\n    AxisRender.prototype.updateHMajorGridLines = function (smithchart) {\n        var majorGridLine = smithchart.horizontalAxis.majorGridLines;\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_horizontalAxisMajorGridLines' });\n        groupElement.setAttribute('aria-hidden', 'true');\n        var path = this.calculateGridLinesPath(this.majorHGridArcPoints);\n        var haxismgoptions = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(smithchart.element.id + '_horizontalAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n        var element = smithchart.renderer.drawPath(haxismgoptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateRMajorGridLines = function (smithchart) {\n        var majorGridLine = smithchart.radialAxis.majorGridLines;\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_radialAxisMajorGridLines' });\n        groupElement.setAttribute('aria-hidden', 'true');\n        var path = this.calculateGridLinesPath(this.majorRGridArcPoints);\n        var raxismgoptions = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(smithchart.element.id + '_radialAxisMajorGridLines', 'none', majorGridLine['width'], majorGridLine.color ? majorGridLine.color : smithchart.themeStyle.majorGridLine, majorGridLine['opacity'], majorGridLine['dashArray'], path);\n        var element = smithchart.renderer.drawPath(raxismgoptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateHAxisLine = function (smithchart) {\n        var radius = this.areaRadius;\n        var axisLine = smithchart.horizontalAxis.axisLine;\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_hAxisLine' });\n        groupElement.setAttribute('aria-hidden', 'true');\n        var point1 = { x: this.circleCenterX + radius, y: this.circleCenterY };\n        var point2 = { x: this.circleCenterX + radius, y: (this.circleCenterY - 0.05) };\n        var size = { width: radius, height: radius };\n        var sweep = this.direction['clockwise'];\n        var isLargeArc = 1;\n        var angle = Math.PI * 2;\n        var direction = 'M' + '' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' + size.width +\n            ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' + point2.x + ' ' + point2.y + '';\n        var options = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(smithchart.element.id + '_horizontalAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n        var element = smithchart.renderer.drawPath(options);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateRAxisLine = function (smithchart) {\n        var radius = this.areaRadius;\n        var axisLine = smithchart.radialAxis.axisLine;\n        var point1 = { x: this.circleCenterX - radius, y: this.circleCenterY };\n        var point2 = { x: this.circleCenterX + radius, y: this.circleCenterY };\n        var size = { width: 0, height: 0 };\n        var sweep = this.direction['counterclockwise'];\n        var isLargeArc = 0;\n        var angle = 0;\n        var direction = 'M' + ' ' + point1.x + ' ' + point1.y + ' ' + 'A' + ' ' +\n            size.width + ' ' + size.height + ' ' + angle + ' ' + isLargeArc + ' ' + sweep + ' ' +\n            point2.x + ' ' + point2.y + '';\n        var options = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(smithchart.element.id + '_radialAxisLine', 'none', axisLine.width, axisLine.color ? axisLine.color : smithchart.themeStyle.axisLine, 1, axisLine.dashArray, direction);\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_rAxisLine' });\n        groupElement.setAttribute('aria-hidden', 'true');\n        var element = smithchart.renderer.drawPath(options);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.drawHAxisLabels = function (smithchart) {\n        var hAxis = smithchart.horizontalAxis;\n        smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n        var font = smithchart.horizontalAxis.labelStyle;\n        var circleAxis;\n        var label;\n        var x;\n        var y;\n        var textSize;\n        var curLabel;\n        var curLabelBounds;\n        var curWidth;\n        var curX;\n        var preLabel;\n        var preLabelBounds;\n        var preWidth;\n        var preX;\n        var groupEle = smithchart.renderer.createGroup({ id: smithchart.element.id + '_HAxisLabels' });\n        groupEle.setAttribute('aria-hidden', 'true');\n        var _loop_1 = function (i) {\n            circleAxis = this_1.horizontalLabelCollections[i];\n            label = this_1.horizontalLabelCollections[i].value.toString();\n            if (circleAxis.value !== 0.0) {\n                x = (smithchart.renderType === 'Impedance') ?\n                    circleAxis.centerX - circleAxis.radius : circleAxis.centerX + circleAxis.radius;\n                y = circleAxis.centerY;\n                textSize = (0,_smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.measureText)(label, font, smithchart.themeStyle.axisLabelFont);\n                x = (smithchart.renderType === 'Impedance') ? x - textSize.width : x;\n                if (hAxis.labelPosition === 'Outside') {\n                    y -= textSize.height / 4;\n                }\n                else {\n                    y += textSize.height;\n                }\n                this_1.horizontalLabelCollections[i].region = this_1.calculateRegion(label, textSize, x, y);\n                if (hAxis.labelIntersectAction === 'Hide') {\n                    curLabel = this_1.horizontalLabelCollections[i];\n                    curLabelBounds = curLabel.region.bounds;\n                    curWidth = curLabelBounds.width;\n                    curX = curLabelBounds.x;\n                    for (var j = 1; j < i; j++) {\n                        preLabel = this_1.horizontalLabelCollections[j];\n                        preLabelBounds = preLabel.region.bounds;\n                        preWidth = preLabelBounds.width;\n                        preX = preLabelBounds.x;\n                        if ((smithchart.renderType === 'Impedance') &&\n                            (preX + preWidth) > (curX)) {\n                            label = '';\n                        }\n                        if ((smithchart.renderType === 'Admittance') &&\n                            (preX) < curX + curWidth) {\n                            label = '';\n                        }\n                    }\n                }\n                var axisLabelRenderEventArgs_1 = {\n                    text: label.toString(),\n                    x: x,\n                    y: y,\n                    name: _model_constant__WEBPACK_IMPORTED_MODULE_2__.axisLabelRender,\n                    cancel: false\n                };\n                var axisLabelRenderSuccess = function (args) {\n                    if (!args.cancel) {\n                        var options = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.TextOption(smithchart.element.id + '_HLabel_' + i, axisLabelRenderEventArgs_1.x, axisLabelRenderEventArgs_1.y, 'none', axisLabelRenderEventArgs_1.text);\n                        var color = font.color ? font.color : smithchart.themeStyle.axisLabelFont.color;\n                        font.fontFamily = font.fontFamily || smithchart.themeStyle.labelFontFamily;\n                        var element = (0,_smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.renderTextElement)(options, font, color, groupEle, smithchart.themeStyle.axisLabelFont);\n                        groupEle.appendChild(element);\n                    }\n                };\n                axisLabelRenderSuccess.bind(this_1);\n                smithchart.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_2__.axisLabelRender, axisLabelRenderEventArgs_1, axisLabelRenderSuccess);\n            }\n        };\n        var this_1 = this;\n        for (var i = 0; i < this.horizontalLabelCollections.length; i++) {\n            _loop_1(i);\n        }\n        smithchart.svgObject.appendChild(groupEle);\n    };\n    AxisRender.prototype.drawRAxisLabels = function (smithchart) {\n        var paddingRadius = 2;\n        smithchart.radialAxis.labelStyle.fontFamily = smithchart.themeStyle.fontFamily || smithchart.radialAxis.labelStyle.fontFamily;\n        var font = smithchart.radialAxis.labelStyle;\n        var interSectPoint = new _smithchart_utils_utils__WEBPACK_IMPORTED_MODULE_1__.RadialLabelCollections();\n        var label;\n        var textSize;\n        var angle;\n        var position;\n        var textPosition;\n        var curX;\n        var curY;\n        var curWidth;\n        var curHeight;\n        var curLabel;\n        var curLabelBounds;\n        var preX;\n        var preY;\n        var preWidth;\n        var preHeight;\n        var preLabel;\n        var preLabelBounds;\n        var rAxis = smithchart.radialAxis;\n        var groupEle = smithchart.renderer.createGroup({ id: smithchart.element.id + '_RAxisLabels' });\n        groupEle.setAttribute('aria-hidden', 'true');\n        var _loop_2 = function (i) {\n            interSectPoint = this_2.labelCollections[i];\n            label = interSectPoint.value.toString();\n            textSize = (0,_smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.measureText)(label, font, smithchart.themeStyle.axisLabelFont);\n            angle = Math.round(interSectPoint.angle * 100) / 100;\n            if (rAxis.labelPosition === 'Outside') {\n                position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius + paddingRadius);\n                textPosition = this_2.setLabelsOutsidePosition(angle, position.x, position.y, textSize);\n            }\n            else {\n                position = this_2.circlePointPosition(this_2.circleCenterX, this_2.circleCenterY, interSectPoint['angle'], this_2.areaRadius - paddingRadius);\n                textPosition = this_2.setLabelsInsidePosition(angle, position.x, position.y, textSize);\n            }\n            this_2.labelCollections[i]['region'] = this_2.calculateRegion(label, textSize, textPosition.x, textPosition.y);\n            if (rAxis.labelIntersectAction === 'Hide') {\n                curLabel = this_2.labelCollections[i];\n                curLabelBounds = curLabel['region']['bounds'];\n                curWidth = curLabelBounds['width'];\n                curHeight = curLabelBounds['height'];\n                curX = curLabelBounds['x'];\n                curY = curLabelBounds['y'];\n                for (var j = 0; j < i; j++) {\n                    preLabel = this_2.labelCollections[j];\n                    preLabelBounds = preLabel['region']['bounds'];\n                    preWidth = preLabelBounds['width'];\n                    preHeight = preLabelBounds['height'];\n                    preX = preLabelBounds['x'];\n                    preY = preLabelBounds['y'];\n                    if ((preX <= curX + curWidth) && (curX <= preX + preWidth) && (preY <= curY + curHeight)\n                        && (curY <= preY + preHeight)) {\n                        label = ' ';\n                    }\n                }\n            }\n            var axisLabelRenderEventArgs = {\n                text: label.toString(),\n                x: textPosition.x,\n                y: textPosition.y,\n                name: _model_constant__WEBPACK_IMPORTED_MODULE_2__.axisLabelRender,\n                cancel: false\n            };\n            var axisLabelRenderSuccess = function (args) {\n                if (!args.cancel) {\n                    var options = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.TextOption(smithchart.element.id + '_RLabel_' + i, axisLabelRenderEventArgs.x, axisLabelRenderEventArgs.y, 'none', axisLabelRenderEventArgs.text);\n                    var color = font.color ? font.color : smithchart.themeStyle.axisLabelFont.color;\n                    font.fontFamily = smithchart.themeStyle.labelFontFamily ? smithchart.themeStyle.labelFontFamily : font.fontFamily;\n                    var element = (0,_smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.renderTextElement)(options, font, color, groupEle, smithchart.themeStyle.axisLabelFont);\n                    groupEle.appendChild(element);\n                }\n            };\n            axisLabelRenderSuccess.bind(this_2);\n            smithchart.trigger(_model_constant__WEBPACK_IMPORTED_MODULE_2__.axisLabelRender, axisLabelRenderEventArgs, axisLabelRenderSuccess);\n        };\n        var this_2 = this;\n        for (var i = 0; i < this.labelCollections.length; i++) {\n            _loop_2(i);\n        }\n        smithchart.svgObject.appendChild(groupEle);\n    };\n    AxisRender.prototype.calculateRegion = function (label, textSize, textPositionX, textPositionY) {\n        var xAxisLabelRegions = new _smithchart_utils_utils__WEBPACK_IMPORTED_MODULE_1__.LabelRegion();\n        var bounds = { x: textPositionX, y: textPositionY, width: textSize.width, height: textSize.height };\n        xAxisLabelRegions = { bounds: bounds, labelText: label };\n        return xAxisLabelRegions;\n    };\n    AxisRender.prototype.updateHMinorGridLines = function (smithchart) {\n        var minorGridLine = smithchart.horizontalAxis.minorGridLines;\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_horizontalAxisMinorGridLines' });\n        var path = this.calculateGridLinesPath(this.minorHGridArcPoints);\n        var haxismioptions = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(smithchart.element.id + '_horizontalAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n        var element = smithchart.renderer.drawPath(haxismioptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.updateRMinorGridLines = function (smithchart) {\n        var minorGridLine = smithchart.radialAxis.minorGridLines;\n        var groupElement = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg' + '_radialAxisMinorGridLines' });\n        var path = this.calculateGridLinesPath(this.minorGridArcPoints);\n        var raxismioptions = new _smithchart_utils_helper__WEBPACK_IMPORTED_MODULE_0__.PathOption(smithchart.element.id + '_radialAxisMinorGridLines', 'none', minorGridLine['width'], minorGridLine.color ? minorGridLine.color : smithchart.themeStyle.minorGridLine, minorGridLine['opacity'], minorGridLine['dashArray'], path);\n        var element = smithchart.renderer.drawPath(raxismioptions);\n        groupElement.appendChild(element);\n        smithchart.svgObject.appendChild(groupElement);\n    };\n    AxisRender.prototype.calculateGridLinesPath = function (points) {\n        var x1;\n        var y1;\n        var x2;\n        var y2;\n        var r1;\n        var r2;\n        var pathSegment = new _smithchart_utils_utils__WEBPACK_IMPORTED_MODULE_1__.GridArcPoints();\n        var angle;\n        var isLargeArc;\n        var sweep;\n        var sb = '';\n        for (var i = 0; i < points.length; i++) {\n            pathSegment = points[i];\n            x1 = pathSegment.startPoint.x;\n            y1 = pathSegment.startPoint.y;\n            x2 = pathSegment.endPoint.x;\n            y2 = pathSegment.endPoint.y;\n            r1 = pathSegment.size ? pathSegment.size.width : 0;\n            r2 = pathSegment.size ? pathSegment.size.height : 0;\n            angle = pathSegment.rotationAngle ? pathSegment.rotationAngle : 0;\n            isLargeArc = pathSegment.isLargeArc ? 1 : 0;\n            sweep = pathSegment.sweepDirection ? pathSegment.sweepDirection : 0;\n            sb = sb + ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + r1 + ' ' + r2 + ' ' +\n                angle + ' ' + isLargeArc + ' ' + sweep + ' ' + x2 + ' ' + y2 + ' ');\n        }\n        var path = sb.toString();\n        return path;\n    };\n    AxisRender.prototype.measureHMinorGridLines = function (smithchart) {\n        var radialPoint1;\n        var radialPoint2;\n        var arcPoints = [];\n        var isLargeArc;\n        var startPoint;\n        var endPoint;\n        var size;\n        var cx;\n        var maxCount = smithchart.horizontalAxis.minorGridLines.count;\n        var previous;\n        var next;\n        var space;\n        var count;\n        var interval;\n        var radius;\n        var leftX;\n        this.minorHGridArcPoints = [];\n        var diameter = this.areaRadius * 2;\n        for (var i = 0; i < this.horizontalLabelCollections.length - 3; i++) {\n            previous = this.horizontalLabelCollections[i];\n            next = this.horizontalLabelCollections[i + 1];\n            space = (previous['radius'] - next['radius']) * 2;\n            count = Math.floor((maxCount / 100) * space);\n            interval = space / count;\n            for (var j = 0; j < count; j++) {\n                radius = next['radius'] + (j * interval) / 2;\n                leftX = (smithchart.renderType === 'Impedance') ?\n                    (this.circleLeftX + diameter) - (radius * 2) : this.circleLeftX;\n                cx = leftX + radius;\n                isLargeArc = next['value'] > 5;\n                arcPoints = this.calculateMinorArcStartEndPoints(next['value']);\n                if (smithchart.renderType === 'Impedance') {\n                    radialPoint1 = arcPoints[0];\n                    radialPoint2 = arcPoints[1];\n                }\n                else {\n                    radialPoint1 = arcPoints[1];\n                    radialPoint2 = arcPoints[0];\n                }\n                startPoint = this.intersectingCirclePoints(radialPoint1[0].centerX, radialPoint1[0].centerY, radialPoint1[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n                endPoint = this.intersectingCirclePoints(radialPoint2[0].centerX, radialPoint2[0].centerY, radialPoint2[0].radius, cx, previous['centerY'], radius, smithchart.renderType);\n                size = { width: radius, height: radius };\n                this.minorHGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: (smithchart.renderType === 'Impedance') ?\n                        this.direction['counterclockwise'] : this.direction['clockwise'],\n                    isLargeArc: isLargeArc,\n                    size: size\n                });\n            }\n        }\n    };\n    AxisRender.prototype.measureRMinorGridLines = function (smithchart) {\n        var maxCount = smithchart.radialAxis.minorGridLines.count;\n        var arcCx;\n        var nextAngle;\n        // let k: number = 0;\n        var betweenAngle;\n        var circlePoint;\n        var previous;\n        var next;\n        var size;\n        var distance;\n        var count;\n        var interval;\n        var centerValue;\n        var circumference = Math.PI * (this.areaRadius * 2);\n        var arcStartX = arcCx = (smithchart.renderType === 'Impedance') ?\n            this.circleCenterX + this.areaRadius : this.circleCenterX - this.areaRadius;\n        var arcStartY = this.circleCenterY;\n        this.minorGridArcPoints = [];\n        var arcStartPoint = { x: arcStartX, y: arcStartY };\n        for (var i = 2; i < this.labelCollections.length - 3; i++) {\n            previous = this.labelCollections[i];\n            next = this.labelCollections[i + 1];\n            if (smithchart.renderType === 'Impedance') {\n                nextAngle = next['angle'] === 360 ? 0 : next['angle'];\n                betweenAngle = Math.abs(nextAngle - previous['angle']);\n            }\n            else {\n                nextAngle = previous['angle'] === 360 ? 0 : previous['angle'];\n                betweenAngle = Math.abs(nextAngle - next['angle']);\n            }\n            distance = (circumference / 360) * betweenAngle;\n            count = Math.floor((maxCount / 100) * distance);\n            interval = betweenAngle / count;\n            centerValue = next['value'] > 0 ? next['value'] : previous['value'];\n            circlePoint = this.minorGridLineArcIntersectCircle(Math.abs(centerValue));\n            for (var j = 1; j < count; j++) {\n                var outterInterSectAngle = (interval * j) + (previous['angle'] === 360 ? nextAngle : previous['angle']);\n                var outerInterSectPoint = this.circlePointPosition(this.circleCenterX, this.circleCenterY, outterInterSectAngle, this.areaRadius);\n                var radius = this.arcRadius(arcStartPoint, outerInterSectPoint, outterInterSectAngle);\n                var arcCy = outterInterSectAngle > 180 ? this.circleCenterY - radius : this.circleCenterY + radius;\n                var innerInterSectPoint = this.intersectingCirclePoints(arcCx, arcCy, radius, circlePoint[0].centerX, circlePoint[0].centerY, circlePoint[0].radius, smithchart.renderType);\n                var startPoint = { x: innerInterSectPoint.x, y: innerInterSectPoint.y };\n                var endPoint = { x: outerInterSectPoint.x, y: outerInterSectPoint.y };\n                size = { width: radius, height: radius };\n                var sweepDirection = previous['value'] >= 0 ? this.direction['clockwise'] : this.direction['counterclockwise'];\n                this.minorGridArcPoints.push({\n                    startPoint: startPoint,\n                    endPoint: endPoint,\n                    rotationAngle: 2 * Math.PI,\n                    sweepDirection: sweepDirection,\n                    isLargeArc: false,\n                    size: size\n                });\n                // k++;\n            }\n        }\n    };\n    AxisRender.prototype.minorGridLineArcIntersectCircle = function (centerValue) {\n        var calValue;\n        if (centerValue >= 3) {\n            calValue = 20;\n        }\n        else if (centerValue >= 1.5) {\n            calValue = 10;\n        }\n        else if (centerValue >= 0.6) {\n            calValue = 3;\n        }\n        else {\n            calValue = 2;\n        }\n        var circlePoint = this.horizontalLabelCollections.filter(function (c) { return c['value'] === calValue; });\n        return circlePoint;\n    };\n    AxisRender.prototype.circlePointPosition = function (cx, cy, angle, r) {\n        var radian = angle * (Math.PI / 180);\n        var pointX = cx + r * Math.cos(radian);\n        var pointY = cy + r * Math.sin(radian);\n        return { x: pointX, y: pointY };\n    };\n    AxisRender.prototype.setLabelsInsidePosition = function (angle, px, py, textSize) {\n        var x = px;\n        var y = py;\n        if (angle === 0 || angle === 360) {\n            x -= textSize.width;\n            y -= textSize.height / 2;\n        }\n        else if (angle === 90) {\n            x -= textSize.width;\n            y += textSize.height / 8;\n        }\n        else if (angle === 180) {\n            y += textSize.height;\n        }\n        else if (angle === 270) {\n            y += textSize.height / 2;\n        }\n        else if (angle > 0 && angle <= 20) {\n            x -= (textSize.width);\n        }\n        else if (angle > 20 && angle <= 60) {\n            x -= (textSize.width + textSize.width / 2);\n            y += textSize.height / 2;\n        }\n        else if (angle > 60 && angle < 90) {\n            x -= (textSize.width + textSize.width / 4);\n            y += textSize.height / 4;\n        }\n        else if (angle > 90 && angle <= 135) {\n            x -= (textSize.width / 2);\n            y += (textSize.height) / 16;\n        }\n        else if (angle > 135 && angle <= 150) {\n            x += (textSize.width / 2);\n            y += (textSize.height / 2);\n        }\n        else if (angle > 150 && angle < 180) {\n            x += (textSize.width / 2);\n            y += (textSize.height);\n        }\n        else if (angle > 180 && angle <= 210) {\n            x += (textSize.width / 6);\n            y += (textSize.height / 6);\n        }\n        else if (angle > 210 && angle < 240) {\n            y += (textSize.height / 4);\n        }\n        else if (angle > 225 && angle < 270) {\n            y += (textSize.height / 3);\n        }\n        else if (angle > 270 && angle <= 300) {\n            x -= (textSize.width + textSize.width / 4);\n            y += (textSize.height / 4);\n        }\n        else if (angle > 300 && angle <= 330) {\n            x -= (textSize.width + textSize.width / 3);\n            y += (textSize.height / 4);\n        }\n        else if (angle > 330 && angle <= 340) {\n            x -= (textSize.width + textSize.width / 2);\n            y += textSize.height / 4;\n        }\n        else if (angle > 340) {\n            x -= textSize.width;\n            y += textSize.height / 8;\n        }\n        return { x: x, y: y };\n    };\n    AxisRender.prototype.setLabelsOutsidePosition = function (angle, px, py, textSize) {\n        var x = px;\n        var y = py;\n        if (angle === 90) {\n            x -= textSize.width / 2;\n            y += textSize.height;\n        }\n        else if (angle === 180) {\n            x -= (textSize.width + 5);\n            y -= textSize.height / 4;\n        }\n        else if (angle === 270) {\n            x -= textSize.width / 2;\n            y -= textSize.height / 4;\n        }\n        else if (angle === 360) {\n            x += 5;\n            y -= textSize.height / 2;\n        }\n        else if (angle > 0 && angle <= 30) {\n            x += textSize.width / 4;\n            y += textSize.height / 8;\n        }\n        else if (angle > 30 && angle <= 60) {\n            x += textSize.width / 2;\n            y += textSize.height / 4;\n        }\n        else if (angle > 60 && angle <= 90) {\n            x -= textSize.width / 2;\n            y += textSize.height;\n        }\n        else if (angle > 90 && angle <= 135) {\n            x -= textSize.width;\n            y += textSize.height;\n        }\n        else if (angle > 135 && angle <= 180) {\n            x -= (textSize.width + textSize.width / 4);\n            y += textSize.height / 4;\n        }\n        else if (angle > 180 && angle <= 210) {\n            x -= textSize.width + textSize.width / 4;\n            y -= textSize.height / 4;\n        }\n        else if (angle > 210 && angle <= 270) {\n            x -= textSize.width;\n            y -= textSize.height / 4;\n        }\n        else if (angle > 270 && angle <= 340) {\n            y -= textSize.height / 4;\n        }\n        else if (angle > 340) {\n            y += textSize.height / 4;\n            x += textSize.width / 6;\n        }\n        return { x: x, y: y };\n    };\n    AxisRender.prototype.arcRadius = function (startPoint, endPoint, angle) {\n        var radian = angle > 180 ? (90 * Math.PI / 180) : (270 * Math.PI / 180); // Angle 90 and 270 used for calculating upper and lower circle\n        var mx = (endPoint.x - startPoint.x) / 2;\n        var my = (endPoint.y - startPoint.y) / 2;\n        var u = (Math.cos(radian) * my - Math.sin(radian) * mx) / (Math.cos(radian) * mx + Math.sin(radian) * my);\n        var t = (my - mx * u) / Math.sin(radian);\n        var cy = startPoint.y + Math.sin(radian) * t;\n        var radius = Math.abs(startPoint.y - cy);\n        return radius;\n    };\n    return AxisRender;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/smithchart/axis/axisrender.js?");

/***/ })

}]);