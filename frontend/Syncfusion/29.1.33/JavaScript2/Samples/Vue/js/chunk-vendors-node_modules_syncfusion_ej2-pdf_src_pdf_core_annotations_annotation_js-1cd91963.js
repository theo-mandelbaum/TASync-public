"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdf_src_pdf_core_annotations_annotation_js-1cd91963"],{

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/annotations/annotation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/annotations/annotation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pdf3DAnnotation: () => (/* binding */ Pdf3DAnnotation),\n/* harmony export */   PdfAngleMeasurementAnnotation: () => (/* binding */ PdfAngleMeasurementAnnotation),\n/* harmony export */   PdfAnnotation: () => (/* binding */ PdfAnnotation),\n/* harmony export */   PdfAnnotationBorder: () => (/* binding */ PdfAnnotationBorder),\n/* harmony export */   PdfAnnotationCaption: () => (/* binding */ PdfAnnotationCaption),\n/* harmony export */   PdfAnnotationLineEndingStyle: () => (/* binding */ PdfAnnotationLineEndingStyle),\n/* harmony export */   PdfAttachmentAnnotation: () => (/* binding */ PdfAttachmentAnnotation),\n/* harmony export */   PdfBorderEffect: () => (/* binding */ PdfBorderEffect),\n/* harmony export */   PdfCircleAnnotation: () => (/* binding */ PdfCircleAnnotation),\n/* harmony export */   PdfComment: () => (/* binding */ PdfComment),\n/* harmony export */   PdfDocumentLinkAnnotation: () => (/* binding */ PdfDocumentLinkAnnotation),\n/* harmony export */   PdfEllipseAnnotation: () => (/* binding */ PdfEllipseAnnotation),\n/* harmony export */   PdfFileLinkAnnotation: () => (/* binding */ PdfFileLinkAnnotation),\n/* harmony export */   PdfFreeTextAnnotation: () => (/* binding */ PdfFreeTextAnnotation),\n/* harmony export */   PdfInkAnnotation: () => (/* binding */ PdfInkAnnotation),\n/* harmony export */   PdfInteractiveBorder: () => (/* binding */ PdfInteractiveBorder),\n/* harmony export */   PdfLineAnnotation: () => (/* binding */ PdfLineAnnotation),\n/* harmony export */   PdfListFieldItem: () => (/* binding */ PdfListFieldItem),\n/* harmony export */   PdfPolyLineAnnotation: () => (/* binding */ PdfPolyLineAnnotation),\n/* harmony export */   PdfPolygonAnnotation: () => (/* binding */ PdfPolygonAnnotation),\n/* harmony export */   PdfPopupAnnotation: () => (/* binding */ PdfPopupAnnotation),\n/* harmony export */   PdfRadioButtonListItem: () => (/* binding */ PdfRadioButtonListItem),\n/* harmony export */   PdfRectangleAnnotation: () => (/* binding */ PdfRectangleAnnotation),\n/* harmony export */   PdfRedactionAnnotation: () => (/* binding */ PdfRedactionAnnotation),\n/* harmony export */   PdfRichMediaAnnotation: () => (/* binding */ PdfRichMediaAnnotation),\n/* harmony export */   PdfRubberStampAnnotation: () => (/* binding */ PdfRubberStampAnnotation),\n/* harmony export */   PdfSoundAnnotation: () => (/* binding */ PdfSoundAnnotation),\n/* harmony export */   PdfSquareAnnotation: () => (/* binding */ PdfSquareAnnotation),\n/* harmony export */   PdfStateItem: () => (/* binding */ PdfStateItem),\n/* harmony export */   PdfTextMarkupAnnotation: () => (/* binding */ PdfTextMarkupAnnotation),\n/* harmony export */   PdfTextWebLinkAnnotation: () => (/* binding */ PdfTextWebLinkAnnotation),\n/* harmony export */   PdfUriAnnotation: () => (/* binding */ PdfUriAnnotation),\n/* harmony export */   PdfWatermarkAnnotation: () => (/* binding */ PdfWatermarkAnnotation),\n/* harmony export */   PdfWidgetAnnotation: () => (/* binding */ PdfWidgetAnnotation),\n/* harmony export */   _PaintParameter: () => (/* binding */ _PaintParameter)\n/* harmony export */ });\n/* harmony import */ var _pdf_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../pdf-page */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-page.js\");\n/* harmony import */ var _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../pdf-primitives */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-primitives.js\");\n/* harmony import */ var _enumerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../enumerator */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/enumerator.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utils */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/utils.js\");\n/* harmony import */ var _form_field__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../form/field */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/form/field.js\");\n/* harmony import */ var _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../graphics/pdf-template */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-template.js\");\n/* harmony import */ var _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./../graphics/pdf-graphics */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-graphics.js\");\n/* harmony import */ var _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./../graphics/pdf-path */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/graphics/pdf-path.js\");\n/* harmony import */ var _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../fonts/pdf-standard-font */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/pdf-standard-font.js\");\n/* harmony import */ var _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./../fonts/pdf-string-format */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/fonts/pdf-string-format.js\");\n/* harmony import */ var _base_stream__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./../base-stream */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/base-stream.js\");\n/* harmony import */ var _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./pdf-appearance */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/annotations/pdf-appearance.js\");\n/* harmony import */ var _annotation_collection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./annotation-collection */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/annotations/annotation-collection.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Represents the base class for annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfAnnotation = page.annotations.at(0);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotation = /** @class */ (function () {\n    function PdfAnnotation() {\n        this._isImported = false;\n        this._isLoaded = false;\n        this._setAppearance = false;\n        this._isExport = false;\n        this._opacity = 1;\n        this._isAllRotation = true;\n        this._flatten = false;\n        this._hasData = false;\n        this._popUpFont = new _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfStandardFont(_fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontFamily.helvetica, 10.5);\n        this._authorBoldFont = new _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfStandardFont(_fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontFamily.helvetica, 10.5, _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.bold);\n        this._lineCaptionFont = new _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfStandardFont(_fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontFamily.helvetica, 10, _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular);\n        this._circleCaptionFont = new _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfStandardFont(_fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontFamily.helvetica, 8, _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular);\n        this._isTransparentColor = false;\n        this._isRotated = false;\n        this._isChanged = false;\n    }\n    Object.defineProperty(PdfAnnotation.prototype, \"author\", {\n        /**\n         * Gets the author of the annotation.\n         *\n         * @returns {string} Author.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the author of the annotation.\n         * let author: string = annotation.author;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._author === 'undefined' && this._dictionary.has('Author')) {\n                var author = this._dictionary.get('Author');\n                if (author) {\n                    this._author = author;\n                }\n            }\n            if (typeof this._author === 'undefined' && this._dictionary.has('T')) {\n                var author = this._dictionary.get('T');\n                if (author) {\n                    this._author = author;\n                }\n            }\n            return this._author;\n        },\n        /**\n         * Sets the author of the annotation.\n         *\n         * @param {string} value Author.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the author of the annotation.\n         * annotation.author = ‘Syncfusion’;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._isLoaded && typeof value === 'string' && value !== this.author) {\n                var hasKey = false;\n                if (this._dictionary && this._dictionary.has('T')) {\n                    this._dictionary.update('T', value);\n                    this._author = value;\n                    hasKey = true;\n                }\n                if (this._dictionary && this._dictionary.has('Author')) {\n                    this._dictionary.update('Author', value);\n                    this._author = value;\n                    hasKey = true;\n                }\n                if (!hasKey) {\n                    this._dictionary.update('T', value);\n                    this._author = value;\n                }\n            }\n            if (!this._isLoaded && typeof value === 'string') {\n                this._dictionary.update('T', value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"border\", {\n        /**\n         * Gets the border of the annotation.\n         *\n         * @returns {PdfAnnotationBorder} Annotation border.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the border of the annotation.\n         * let border: PdfAnnotationBorder = annotation.border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._border === 'undefined') {\n                var value = new PdfAnnotationBorder();\n                value._dictionary = this._dictionary;\n                if (this._dictionary && this._dictionary.has('Border')) {\n                    var border = this._dictionary.getArray('Border');\n                    if (border && border.length >= 3) {\n                        value._hRadius = border[0];\n                        value._vRadius = border[1];\n                        value._width = border[2];\n                    }\n                }\n                if (this._dictionary && this._dictionary.has('BS')) {\n                    var border = this._dictionary.get('BS');\n                    if (border) {\n                        if (border.has('W')) {\n                            var width = border.get('W');\n                            if (typeof width !== 'undefined' && !Number.isNaN(width)) {\n                                value._width = width;\n                            }\n                        }\n                        if (border.has('S')) {\n                            var style = border.get('S');\n                            if (style) {\n                                switch (style.name) {\n                                    case 'D':\n                                        value._style = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dashed;\n                                        break;\n                                    case 'B':\n                                        value._style = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.beveled;\n                                        break;\n                                    case 'I':\n                                        value._style = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.inset;\n                                        break;\n                                    case 'U':\n                                        value._style = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.underline;\n                                        break;\n                                    default:\n                                        value._style = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.solid;\n                                        break;\n                                }\n                            }\n                        }\n                        if (border.has('D')) {\n                            var dash = border.getArray('D');\n                            if (dash) {\n                                value._dash = dash;\n                            }\n                        }\n                    }\n                }\n                this._border = value;\n            }\n            return this._border;\n        },\n        /**\n         * Sets the border of the annotation.\n         *\n         * @param {PdfAnnotationBorder} value Border.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.\n         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();\n         * //Sets the width of the annotation border.\n         * border.width = 10;\n         * //Sets the style of the annotation border.\n         * border.style = PdfBorderStyle.dashed;\n         * //Sets the dash pattern of the annotation border.\n         * border.dash = [1, 2, 1];\n         * // Sets the border to the PDF annotation\n         * annotation.border = border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            var current = this.border;\n            var width;\n            if (!this._isLoaded || (typeof value.width !== 'undefined' && current.width !== value.width)) {\n                width = value.width;\n            }\n            var hRadius;\n            if (!this._isLoaded || (typeof value.hRadius !== 'undefined' && current.hRadius !== value.hRadius)) {\n                hRadius = value.hRadius;\n            }\n            var vRadius;\n            if (!this._isLoaded || (typeof value.vRadius !== 'undefined' && current.vRadius !== value.vRadius)) {\n                vRadius = value.vRadius;\n            }\n            var style;\n            if (!this._isLoaded || (typeof value.style !== 'undefined' && current.style !== value.style)) {\n                style = value.style;\n            }\n            var dash;\n            if (typeof value.dash !== 'undefined' && current.dash !== value.dash) {\n                dash = value.dash;\n            }\n            if (!this._isWidget && this._dictionary && this._dictionary.has('Border') || (width || vRadius || hRadius)) {\n                this._border._hRadius = typeof hRadius !== 'undefined' ? hRadius : current.hRadius;\n                this._border._vRadius = typeof vRadius !== 'undefined' ? vRadius : current.vRadius;\n                this._border._width = typeof width !== 'undefined' ? width : current.width;\n                this._dictionary.update('Border', [this._border.hRadius, this._border.vRadius, this._border.width]);\n            }\n            if (this._dictionary !== null && this._dictionary && this._dictionary.has('BS') || (width || style || dash)) {\n                this._border._width = typeof width !== 'undefined' ? width : current.width;\n                this._border._style = typeof style !== 'undefined' ? style : current.style;\n                this._border._dash = typeof dash !== 'undefined' ? dash : current.dash;\n                var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                bs.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n                bs.update('W', this._border.width);\n                bs.update('S', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderStyle)(this._border.style));\n                if (typeof this._border.dash !== 'undefined') {\n                    bs.update('D', this._border.dash);\n                }\n                this._dictionary.update('BS', bs);\n                this._dictionary._updated = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"flags\", {\n        /**\n         * Gets the flags of the annotation.\n         *\n         * @returns {PdfAnnotationFlag} Annotation flag.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the flags of the annotation.\n         * let flag: PdfAnnotationFlag = annotation.flags;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._annotFlags === 'undefined') {\n                this._annotFlags = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.default;\n                if (this._dictionary && this._dictionary.has('F')) {\n                    this._annotFlags = this._dictionary.get('F');\n                }\n            }\n            return this._annotFlags;\n        },\n        /**\n         * Sets the flags of the annotation.\n         *\n         * @param {PdfAnnotationFlag} value flag value.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the flags of the annotation.\n         * annotation.flags = PdfAnnotationFlag.print;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value !== this._annotFlags) {\n                this._annotFlags = value;\n                this._dictionary.update('F', value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"color\", {\n        /**\n         * Gets the fore color of the annotation.\n         *\n         * @returns {number[]} R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the color of the annotation.\n         * let color: number[] = annotation.color;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._color === 'undefined' && this._dictionary.has('C')) {\n                this._color = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(this._dictionary.getArray('C'));\n            }\n            return this._color;\n        },\n        /**\n         * Sets the fore color of the annotation.\n         *\n         * @param {number[]} value R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the color of the annotation.\n         * annotation.color = [255, 0, 0];\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value.length === 3) {\n                var extColor = this.color;\n                if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {\n                    this._color = value;\n                    this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(7)),\n                        Number.parseFloat((value[1] / 255).toFixed(7)),\n                        Number.parseFloat((value[2] / 255).toFixed(7))]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"innerColor\", {\n        /**\n         * Gets the inner color of the annotation.\n         *\n         * @returns {number[]} R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the inner color of the annotation.\n         * let innerColor: number[] = annotation.innerColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._innerColor === 'undefined' && this._dictionary.has('IC')) {\n                this._innerColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(this._dictionary.getArray('IC'));\n            }\n            return this._innerColor;\n        },\n        /**\n         * Sets the inner color of the annotation.\n         *\n         * @param {number[]} value R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the inner color of the annotation.\n         * annotation.innerColor = [255, 0, 0];\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value.length === 3) {\n                var extColor = this.innerColor;\n                if (!this._isLoaded ||\n                    typeof extColor === 'undefined' ||\n                    (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {\n                    this._innerColor = value;\n                    this._dictionary.update('IC', [Number.parseFloat((value[0] / 255).toFixed(7)),\n                        Number.parseFloat((value[1] / 255).toFixed(7)),\n                        Number.parseFloat((value[2] / 255).toFixed(7))]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"creationDate\", {\n        /**\n         * Gets the creation date of the annotation.\n         *\n         * @returns {Date} Creation date.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the creation date of the annotation.\n         * let creationDate: Date = annotation.creationDate;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if ((typeof this._creationDate === 'undefined' || this._creationDate === null) && this._dictionary.has('CreationDate')) {\n                var value = this._dictionary.get('CreationDate'); // eslint-disable-line\n                if (value !== null && typeof value === 'string') {\n                    this._creationDate = this._stringToDate(value);\n                }\n            }\n            return this._creationDate;\n        },\n        /**\n         * Sets the creation date of the annotation.\n         *\n         * @param {Date} value Creation date.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Set the creation date of the annotation.\n         * annotation.creationDate = new Date();\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._creationDate = value;\n            this._dictionary.update('CreationDate', this._dateToString(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"modifiedDate\", {\n        /**\n         * Gets the modification date of the annotation.\n         *\n         * @returns {Date} Modified date.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the modified date of the annotation.\n         * let modifiedDate: Date = annotation.modifiedDate;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if ((typeof this._modifiedDate === 'undefined' || this._modifiedDate === null)) {\n                var value = void 0; // eslint-disable-line\n                if (this._dictionary && this._dictionary.has('ModDate')) {\n                    value = this._dictionary.get('ModDate');\n                }\n                else if (this._dictionary.has('M')) {\n                    value = this._dictionary.get('M');\n                }\n                if (value !== null && typeof value === 'string') {\n                    this._modifiedDate = this._stringToDate(value);\n                }\n            }\n            return this._modifiedDate;\n        },\n        /**\n         * Sets the modification date of the annotation.\n         *\n         * @param {Date} value Modified date.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Set the modified date of the annotation.\n         * annotation.modifiedDate = new Date();\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._modifiedDate = value;\n            this._dictionary.update('M', this._dateToString(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"bounds\", {\n        /**\n         * Gets the bounds of the annotation.\n         *\n         * @returns {{x: number, y: number, width: number, height: number}} Bounds.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the bounds of the annotation.\n         * let bounds: {x: number, y: number, width: number, height: number} = annotation.bounds;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded) {\n                this._bounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._calculateBounds)(this._dictionary, this._page);\n            }\n            return this._bounds;\n        },\n        /**\n         * Sets the bounds of the annotation.\n         *\n         * @param {{x: number, y: number, width: number, height: number}} value bounds.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the bounds of the annotation.\n         * annotation.bounds = {x: 10, y: 10, width: 150, height: 5};\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value) {\n                this._isBounds = true;\n                if (this._isLoaded) {\n                    if ((value.x !== this.bounds.x) || (value.y !== this.bounds.y) ||\n                        (value.width !== this.bounds.width) || (value.height !== this.bounds.height)) {\n                        var size = this._page.size;\n                        if (size) {\n                            var y = size[1] - (value.y + value.height);\n                            var height = y + value.height;\n                            this._dictionary.update('Rect', [value.x, y, value.x + value.width, height]);\n                            this._bounds = value;\n                            this._isChanged = true;\n                        }\n                    }\n                }\n                else {\n                    this._bounds = value;\n                    this._isChanged = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"caption\", {\n        /**\n         * Gets the caption of the annotation.\n         *\n         * @returns {PdfAnnotationCaption} Annotation caption.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the caption of the annotation.\n         * let caption: PdfAnnotationCaption = annotation.caption;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._caption === 'undefined') {\n                var value = new PdfAnnotationCaption();\n                value._dictionary = this._dictionary;\n                if (this._dictionary && this._dictionary.has('Cap')) {\n                    value._cap = this._dictionary.get('Cap');\n                }\n                if (this._dictionary && this._dictionary.has('CP')) {\n                    var capType = this._dictionary.get('CP');\n                    if (capType) {\n                        value._type = capType.name === 'Top' ? _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.top : _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.inline;\n                    }\n                }\n                if (this._dictionary && this._dictionary.has('CO')) {\n                    value._offset = this._dictionary.getArray('CO');\n                }\n                this._caption = value;\n            }\n            return this._caption;\n        },\n        /**\n         * Sets the caption of the annotation.\n         *\n         * @param {PdfAnnotationCaption} value Annottion caption.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Create and set annotation caption values\n         * annotation.caption = new PdfAnnotationCaption(true, PdfLineCaptionType.inline, [10, 10]);\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            var current = this.caption;\n            if (value) {\n                if (!this._isLoaded || value.cap !== current.cap) {\n                    this._caption.cap = value.cap;\n                }\n                if (!this._isLoaded || value.type !== current.type) {\n                    this._caption.type = value.type;\n                }\n                if (!this._isLoaded || value.offset !== current.offset) {\n                    this._caption.offset = value.offset;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"opacity\", {\n        /**\n         * Gets the opacity of the annotation.\n         *\n         * @returns {number} Opacity in between 0 t0 1.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the opacity of the annotation.\n         * let opacity: number = annotation.opacity;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary && this._dictionary.has('CA')) {\n                var opacity = this._dictionary.get('CA');\n                if (typeof opacity !== 'undefined') {\n                    this._opacity = opacity;\n                }\n            }\n            return this._opacity;\n        },\n        /**\n         * Sets the opacity of the annotation.\n         *\n         * @param {number} value opacity in between 0 t0 1.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the opacity of the annotation.\n         * annotation.opacity = 0.5;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && !Number.isNaN(value)) {\n                if (value >= 0 && value <= 1) {\n                    this._dictionary.update('CA', value);\n                    this._opacity = value;\n                }\n                else if (value < 0) {\n                    this._dictionary.update('CA', 0);\n                }\n                else {\n                    this._dictionary.update('CA', 1);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"subject\", {\n        /**\n         * Gets the subject of the annotation.\n         *\n         * @returns {string} Subject.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the subject of the annotation.\n         * let subject: string = annotation.subject;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._subject === 'undefined') {\n                this._subject = this._dictionary.get('Subject', 'Subj');\n            }\n            return this._subject;\n        },\n        /**\n         * Sets the subject of the annotation.\n         *\n         * @param {string} value Subject.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the subject of the annotation.\n         * annotation.subject = 'Line Annotation';\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value === 'string' && this.subject !== value) {\n                this._dictionary.update('Subj', value);\n                this._subject = value;\n                if (this._dictionary.has('Subject')) {\n                    this._dictionary.update('Subject', value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"name\", {\n        /**\n         * Gets the name of the annotation.\n         *\n         * @returns {string} Name.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the name of the annotation.\n         * let name: string = annotation.name;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._name === 'undefined' && this._dictionary.has('NM')) {\n                this._name = this._dictionary.get('NM');\n            }\n            return this._name;\n        },\n        /**\n         * Sets the name of the annotation.\n         *\n         * @param {string} value Name.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the name of the annotation.\n         * annotation.name = 'LineAnnotation';\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value === 'string') {\n                this._dictionary.update('NM', value);\n                this._name = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"text\", {\n        /**\n         * Gets the text of the annotation.\n         *\n         * @returns {string} Text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the text of the annotation.\n         * let text: string = annotation.text;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._text === 'undefined' && this._dictionary.has('Contents')) {\n                this._text = this._dictionary.get('Contents');\n            }\n            return this._text;\n        },\n        /**\n         * Sets the text of the annotation.\n         *\n         * @param {string} value Text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the text of the annotation.\n         * annotation.text = ‘LineAnnotation’;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value === 'string') {\n                this._text = this._dictionary.get('Contents');\n                if (value !== this._text) {\n                    this._dictionary.update('Contents', value);\n                    this._text = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"rotationAngle\", {\n        /**\n         * Gets the rotation of the annotation.\n         *\n         * @returns {PdfRotationAngle} Rotation angle.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the rotation angle of the annotation.\n         * let rotationAngle: PdfRotationAngle = annotation.rotationAngle;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._rotate === 'undefined' && this._dictionary && this._dictionary.has('Rotate')) {\n                this._rotate = (this._dictionary.get('Rotate') / 90);\n            }\n            if (this._rotate === null || typeof this._rotate === 'undefined') {\n                this._rotate = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0;\n            }\n            return this._rotate;\n        },\n        /**\n         * Sets the rotation of the annotation.\n         *\n         * @param {PdfRotationAngle} value rotation angle.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the rotation angle of the annotation.\n         * annotation.rotationAngle = PdfRotationAngle.angle180;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            var prevRotate = this.rotationAngle;\n            if (typeof value !== 'undefined' && typeof prevRotate !== 'undefined') {\n                value = ((value + prevRotate) % 4);\n            }\n            this._dictionary.update('Rotate', value * 90);\n            this._isRotated = true;\n            this._rotate = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"rotate\", {\n        /**\n         * Gets the rotation angle of the annotation (Read only).\n         *\n         * @returns {number} Rotation angle.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * //Get the rotation angle of the annotation.\n         * let rotate: number = annotation.rotate;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            var angle = this._getRotationAngle();\n            if (angle < 0) {\n                angle = 360 + angle;\n            }\n            if (angle >= 360) {\n                angle = 360 - angle;\n            }\n            return angle;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"flattenPopups\", {\n        /**\n         * Gets the boolean flag indicating whether annotation's popup have been flattened or not.\n         *\n         * @returns {boolean} Flatten Popup.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the boolean flag indicating whether annotation's popup have been flattened or not.\n         * let flattenPopups: boolean = annotation.flattenPopups;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._isFlattenPopups;\n        },\n        /**\n         * Sets the boolean flag indicating whether the annotation’s popup have been flattened or not.\n         *\n         * @param {boolean} value Flatten Popup.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the boolean flag indicating whether the annotation’s popup have been flattened or not.\n         * annotation.flattenPopups = false;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._isFlattenPopups = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"flatten\", {\n        /**\n         * Gets the boolean flag indicating whether the annotation have been flattened or not.\n         *\n         * @returns {boolean} Flatten.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the boolean flag indicating whether the annotation have been flattened or not.\n         * let flatten: boolean = annotation.flatten;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._flatten;\n        },\n        /**\n         * Sets the boolean flag indicating whether the annotation have been flattened or not.\n         *\n         * @param {boolean} value Flatten.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the boolean flag indicating whether the annotation have been flattened or not.\n         * annotation.flatten = true;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._flatten = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"_hasFlags\", {\n        get: function () {\n            return this._dictionary.has('F');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"_degreeToRadian\", {\n        get: function () {\n            if (typeof this._ratio === 'undefined') {\n                this._ratio = Math.PI / 180;\n            }\n            return this._ratio;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotation.prototype, \"layer\", {\n        /**\n         * Gets the `PdfLayer` of the annotation.\n         *\n         * @returns {PdfLayer} PDF layer to the annotation.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Get the first page of the document\n         * let page: PdfPage = document.getPage(0);\n         * // Access the first annotation on the page\n         * let annotation: PdfAnnotation = page.annotations.at(0);\n         * // Get the layer of the annotation\n         * let layer: PdfLayer = annotation.layer;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (!this._layer) {\n                this._layer = this._getDocumentLayer();\n            }\n            return this._layer;\n        },\n        /**\n         * Set the `PdfLayer` to the annotation.\n         *\n         * @param {PdfLayer} value PDF layer to the annotation.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Get the first page of the document\n         * let page: PdfPage = document.getPage(0);\n         * // Access the collection of layers in the document\n         * let layers: PdfLayerCollection = document.layers;\n         * // Add a new layer to the document with the name 'Layer1'\n         * let layer: PdfLayer = layers.add('Layer1');\n         * // Access the first annotation on the page\n         * let annotation: PdfAnnotation = page.annotations.at(0);\n         * // Assign the layer to the annotation\n         * annotation.layer = layer;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!this._layer) {\n                this._layer = value;\n                if (this._layer) {\n                    this._dictionary.update('OC', this._layer._referenceHolder);\n                }\n                else {\n                    delete this._dictionary._map['OC'];\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Set the boolean flag to create a new appearance stream for annotations.\n     *\n     * @param {boolean} value Set appearance.\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Set the boolean flag to create a new appearance stream for annotations.\n     * document.getPage(0).annotations.at(0).setAppearance(true);\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfAnnotation.prototype.setAppearance = function (value) {\n        this._setAppearance = value;\n        if (value) {\n            this._dictionary._updated = true;\n        }\n    };\n    /**\n     * Gets the values associated with the specified key.\n     *\n     * @param {string} name Key.\n     * @returns {string[]} Values associated with the key.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Gets the values associated with the key 'Author'.\n     * let values: string[] = document.getPage(0).annotations.at(0).getValues('Author');\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfAnnotation.prototype.getValues = function (name) {\n        var values = [];\n        if (this._dictionary && this._dictionary.has(name)) {\n            var value = this._dictionary.get(name); // eslint-disable-line\n            if (Array.isArray(value)) {\n                value = this._dictionary.getArray(name);\n                for (var i = 0; i < value.length; i++) {\n                    var element = value[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n                    if (element instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName) {\n                        values.push(element.name);\n                    }\n                    else if (typeof element === 'string') {\n                        values.push(element);\n                    }\n                    else if (typeof element === 'number') {\n                        values.push(element.toString());\n                    }\n                }\n            }\n            else if (value instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName) {\n                values.push(value.name);\n            }\n            else if (typeof value === 'string') {\n                values.push(value);\n            }\n            else {\n                throw new Error('PdfException: ' + name + ' is not found');\n            }\n        }\n        else {\n            throw new Error('PdfException: ' + name + ' is not found');\n        }\n        return values;\n    };\n    /**\n     * Sets the values associated with the specified key.\n     *\n     * @param {string} name Key.\n     * @param {string} value Value associated with the key..\n     * @returns {void} Nothing.\n     *\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Access the annotation at index 0\n     * let annotation: PdfAnnotation = document.getPage(0).annotations.at(0);\n     * // Set Unknown state and model\n     * annotation.setValues('State', 'StateModel');\n     * annotation.setValues('StateModel', 'CustomState');\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfAnnotation.prototype.setValues = function (name, value) {\n        if (name && name !== '' && value && value !== '') {\n            this._dictionary.update(name, value);\n        }\n    };\n    //Implementation\n    PdfAnnotation.prototype._initialize = function (page, dictionary) {\n        this._page = page;\n        this._crossReference = page._crossReference;\n        if (dictionary) {\n            this._dictionary = dictionary;\n        }\n        if (!this._isLoaded) {\n            this._dictionary.set('P', this._page._ref);\n            this._dictionary.assignXref(this._crossReference);\n        }\n    };\n    PdfAnnotation.prototype._getRotationAngle = function () {\n        var angle = 0;\n        if (this._dictionary) {\n            if (this._dictionary.has('Rotate')) {\n                angle = this._dictionary.get('Rotate');\n            }\n            else if (this._dictionary.has('Rotation')) {\n                angle = this._dictionary.get('Rotation');\n            }\n        }\n        return angle;\n    };\n    PdfAnnotation.prototype._getMediaOrCropBox = function (page) {\n        var cropOrMediaBox;\n        if (page && page._pageDictionary && page._pageDictionary.has('MediaBox')) {\n            cropOrMediaBox = page._pageDictionary.get('MediaBox');\n        }\n        else if (page && page._pageDictionary && page._pageDictionary.has('CropBox')) {\n            cropOrMediaBox = page._pageDictionary.get('CropBox');\n        }\n        return cropOrMediaBox;\n    };\n    PdfAnnotation.prototype._getBoundsValue = function (linePoints) {\n        var count = 0;\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(linePoints)) {\n            count = linePoints.length;\n        }\n        var x = [];\n        var y = [];\n        if (count > 0) {\n            var points = [];\n            for (var i = 0; i < linePoints.length; i++) {\n                var value = linePoints[Number.parseInt(i.toString(), 10)];\n                points.push(value);\n            }\n            var x1 = 0;\n            var y1 = 0;\n            for (var i = 0; i < points.length; i++) {\n                if (i % 2 === 0) {\n                    x[Number.parseInt(x1.toString(), 10)] = points[Number.parseInt(i.toString(), 10)];\n                    x1++;\n                }\n                else {\n                    y[Number.parseInt(y1.toString(), 10)] = points[Number.parseInt(i.toString(), 10)];\n                    y1++;\n                }\n            }\n        }\n        x.sort(function (a, b) { return a > b ? 1 : -1; });\n        y.sort(function (a, b) { return a > b ? 1 : -1; });\n        return { x: x[0], y: y[0], width: x[x.length - 1] - x[0], height: y[y.length - 1] - y[0] };\n    };\n    PdfAnnotation.prototype._validateTemplateMatrix = function (dictionary, template) {\n        var isRotatedMatrix = false;\n        var isValidMatrix = true;\n        if (template === null || typeof template === 'undefined') {\n            if (dictionary && dictionary.has('Matrix')) {\n                var matrix = dictionary.getArray('Matrix');\n                if (matrix && matrix.length > 3) {\n                    if (typeof matrix[0] !== 'undefined' &&\n                        typeof matrix[1] !== 'undefined' &&\n                        typeof matrix[2] !== 'undefined' &&\n                        typeof matrix[3] !== 'undefined') {\n                        if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {\n                            isRotatedMatrix = true;\n                            var locationX = 0;\n                            var locationY = 0;\n                            var templateX = 0;\n                            var templateY = 0;\n                            if (matrix.length > 4) {\n                                templateX = -matrix[4];\n                                if (matrix.length > 5) {\n                                    templateY = -matrix[5];\n                                }\n                            }\n                            var annotationBounds = void 0;\n                            if (this._dictionary && this._dictionary.has('Rect')) {\n                                annotationBounds = this._dictionary.getArray('Rect');\n                                if (annotationBounds && annotationBounds.length > 1) {\n                                    locationX = annotationBounds[0];\n                                    locationY = annotationBounds[1];\n                                }\n                            }\n                            if (!(locationX === templateX && locationY === templateY) && templateX === 0 && templateY === 0) {\n                                this._locationDisplaced = true;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                isRotatedMatrix = true;\n            }\n            return isRotatedMatrix;\n        }\n        else {\n            var point = this.bounds;\n            if (dictionary && dictionary.has('Matrix')) {\n                var box = dictionary.getArray('BBox');\n                var matrix = dictionary.getArray('Matrix');\n                if (matrix && box && matrix.length > 3 && box.length > 2) {\n                    if (typeof matrix[0] !== 'undefined' &&\n                        typeof matrix[1] !== 'undefined' &&\n                        typeof matrix[2] !== 'undefined' &&\n                        typeof matrix[3] !== 'undefined') {\n                        if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {\n                            if (typeof box[0] !== 'undefined' &&\n                                typeof box[1] !== 'undefined' &&\n                                typeof box[2] !== 'undefined' &&\n                                typeof box[3] !== 'undefined') {\n                                if (this._page && box[0] !== -(matrix[4]) && box[1] !== -(matrix[5]) ||\n                                    (box[0] === 0 && -matrix[4] === 0)) {\n                                    var graphics = this._page.graphics;\n                                    var state = graphics.save();\n                                    if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                                        graphics.setTransparency(this._opacity);\n                                    }\n                                    point.x -= box[0];\n                                    point.y += box[1];\n                                    graphics.drawTemplate(template, point);\n                                    graphics.restore(state);\n                                    this._page.annotations.remove(this);\n                                    isValidMatrix = false;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return isValidMatrix;\n        }\n    };\n    PdfAnnotation.prototype._flattenAnnotationTemplate = function (template, isNormalMatrix) {\n        var graphics = this._page.graphics;\n        var currentBounds = this.bounds;\n        if (this instanceof PdfLineAnnotation && this._dictionary && !this._dictionary.has('AP')) {\n            if (this._isLoaded) {\n                currentBounds = this._bounds;\n            }\n            else {\n                if (this instanceof PdfLineAnnotation && !this.measure) {\n                    currentBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._toRectangle)([this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height]);\n                }\n                else {\n                    if (this._setAppearance && this.flatten && !this.measure) {\n                        currentBounds = this._bounds;\n                    }\n                    else {\n                        currentBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._toRectangle)([this.bounds.x, this.bounds.y,\n                            this.bounds.width, this.bounds.height]);\n                    }\n                }\n            }\n            if (this._page) {\n                var size = this._page.size;\n                var mBox = this._page.mediaBox;\n                var cropBox = this._page.cropBox;\n                if (cropBox && Array.isArray(cropBox) && cropBox.length === 4 && this._page._pageDictionary.has('CropBox') &&\n                    !this._isLoaded && !this._flatten) {\n                    if ((cropBox[0] !== 0 || cropBox[1] !== 0 || size[0] === cropBox[2] ||\n                        size[1] === cropBox[3]) && (currentBounds.x !== cropBox[0])) {\n                        currentBounds.x -= cropBox[0];\n                        currentBounds.y = cropBox[3] - (currentBounds.y + currentBounds.height);\n                    }\n                    else {\n                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);\n                    }\n                }\n                else if (mBox && Array.isArray(mBox) && mBox.length === 4 && this._page._pageDictionary.has('MediaBox') &&\n                    !this._isLoaded && !this._flatten) {\n                    if (mBox[0] > 0 || mBox[1] > 0 || size[0] === mBox[2] || size[1] === mBox[3]) {\n                        currentBounds.x -= mBox[0];\n                        currentBounds.y = mBox[3] - (currentBounds.y + currentBounds.height);\n                    }\n                    else {\n                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);\n                    }\n                }\n                else {\n                    if (this instanceof PdfLineAnnotation && !this.measure && !this._isLoaded) {\n                        currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);\n                    }\n                    else {\n                        if (this._setAppearance && this.flatten && !this.measure) {\n                            currentBounds = this.bounds;\n                        }\n                        else if (!this._isLoaded) {\n                            currentBounds.y = size[1] - (currentBounds.y + currentBounds.height);\n                        }\n                    }\n                }\n            }\n            else {\n                currentBounds.y = currentBounds.y + currentBounds.height;\n            }\n        }\n        if (typeof currentBounds !== 'undefined' && currentBounds !== null) {\n            var state = graphics.save();\n            this._page._needInitializeGraphics = true;\n            if (this._type === _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.rubberStampAnnotation) {\n                var needScale = true;\n                if (this._dictionary && this._dictionary.has('AP')) {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        if (this.rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270 && this._page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270\n                            && appearanceStream.dictionary.has('Matrix')) {\n                            var matrix = appearanceStream.dictionary.getArray('Matrix');\n                            if (matrix && matrix.length === 6 && matrix[4] === 0 && matrix[5] !== 0) {\n                                needScale = false;\n                            }\n                        }\n                    }\n                    if (!isNormalMatrix && this.rotate !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180 && needScale) {\n                        template._isAnnotationTemplate = true;\n                        template._needScale = true;\n                    }\n                }\n            }\n            if (!isNormalMatrix && this._type !== _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.rubberStampAnnotation) {\n                template._isAnnotationTemplate = true;\n                template._needScale = true;\n            }\n            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                graphics.setTransparency(this._opacity);\n            }\n            var bounds = this._calculateTemplateBounds(currentBounds, this._page, template, isNormalMatrix, graphics);\n            if (this._type === _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.rubberStampAnnotation) {\n                var size = void 0;\n                var location_1;\n                if (this.rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0) {\n                    size = [bounds.width, bounds.height];\n                    location_1 = [bounds.x, bounds.y];\n                }\n                else {\n                    size = template._size;\n                    location_1 = [bounds.x, bounds.y];\n                }\n                var isRotatedMatrix = false;\n                if (this.rotate !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0 && template._content) {\n                    if (template._content.dictionary.has('Matrix')) {\n                        var matrix = template._content.dictionary.getArray('Matrix');\n                        if (matrix && matrix.length === 6 && matrix[4] === 0 && matrix[5] !== 0) {\n                            isRotatedMatrix = true;\n                        }\n                    }\n                }\n                var scaleX = (template._size[0] > 0) ? bounds.width / template._size[0] : 1;\n                var scaleY = (template._size[1] > 0) ? bounds.height / template._size[1] : 1;\n                var needScale = !(Math.trunc(scaleX * 1000) / 1000 === 1 && Math.trunc(scaleY * 1000) / 1000 === 1);\n                if (this.rotate !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0 && isRotatedMatrix) {\n                    if (this.rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90) {\n                        if (this._page && this._page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270) {\n                            if (needScale && !(bounds.x === 0 && bounds.y === 0)) {\n                                location_1[0] += (size[0] - size[1]);\n                                location_1[1] += size[0];\n                            }\n                            else {\n                                location_1[0] += size[1];\n                                location_1[1] += (size[0] - size[1]) + (size[0] - size[1]);\n                            }\n                        }\n                        else if (!needScale) {\n                            location_1[0] += size[1];\n                        }\n                    }\n                    else if (this.rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270) {\n                        if (this._page && this._page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270) {\n                            if (needScale && template._isAnnotationTemplate) {\n                                location_1[1] = bounds.y - bounds.width;\n                            }\n                            else if (needScale) {\n                                location_1[1] += (size[0] - size[1]);\n                            }\n                        }\n                        else {\n                            if (!needScale && !(bounds.x === 0 && bounds.y === 0)) {\n                                location_1[1] += -(size[0]);\n                            }\n                            else {\n                                location_1[1] += -(size[0] - size[1]);\n                            }\n                        }\n                    }\n                    else if (this.rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180) {\n                        location_1[0] += size[0];\n                        location_1[1] += -(size[1]);\n                    }\n                }\n            }\n            if (!template._content.dictionary.has('Matrix') && template._content.dictionary.has('BBox')) {\n                var box = template._content.dictionary.getArray('BBox');\n                bounds.x -= box[0];\n                bounds.y += box[1];\n            }\n            if (this instanceof PdfAngleMeasurementAnnotation && !this._isLoaded) {\n                bounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._calculateBounds)(this._dictionary, this._page);\n            }\n            graphics.drawTemplate(template, bounds);\n            graphics.restore(state);\n        }\n        this._page.annotations.remove(this);\n    };\n    PdfAnnotation.prototype._calculateTemplateBounds = function (bounds, page, template, isNormalMatrix, graphics) {\n        var annotationBounds = bounds;\n        var x = bounds.x;\n        var y = bounds.y;\n        var width = bounds.width;\n        var height = bounds.height;\n        if (!isNormalMatrix) {\n            var rect = this._dictionary.getArray('Rect');\n            if (rect) {\n                annotationBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._toRectangle)(rect);\n            }\n        }\n        if (typeof page !== 'undefined') {\n            var graphicsRotation = this._obtainGraphicsRotation(graphics._matrix);\n            if (graphicsRotation === 90) {\n                graphics.translateTransform(template._size[1], 0);\n                graphics.rotateTransform(90);\n                if (isNormalMatrix || (typeof this._rotate !== 'undefined' && this._rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180)) {\n                    x = bounds.x;\n                    if (!this._locationDisplaced) {\n                        y = -(page.size[1] - bounds.y - bounds.height);\n                    }\n                    else if (page._origin && page._o[1] !== 0) {\n                        y = bounds.y + bounds.height;\n                    }\n                    else {\n                        y = -(page.size[1] - (bounds.height + bounds.y) + (bounds.height - template._size[1]));\n                    }\n                }\n                else {\n                    x = bounds.x;\n                    y = -(page.size[1] - (bounds.height + bounds.y) + (bounds.width - template._size[1]));\n                    width = bounds.height;\n                    height = bounds.width;\n                }\n            }\n            else if (graphicsRotation === 180) {\n                graphics.translateTransform(template._size[0], template._size[1]);\n                graphics.rotateTransform(180);\n                if (isNormalMatrix) {\n                    x = -(page.size[0] - (bounds.x + bounds.width));\n                    y = -(page.size[1] - bounds.y - bounds.height);\n                }\n                else {\n                    x = -(page.size[0] - (bounds.x + template._size[0]));\n                    y = -(page.size[1] - bounds.y - template._size[1]);\n                    if (typeof this.rotationAngle !== 'undefined' &&\n                        (this._rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90 ||\n                            this._rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270)) {\n                        y = (-(page.size[1] - bounds.y - template._size[1]) - (bounds.width - bounds.height));\n                        width = bounds.height;\n                        height = bounds.width;\n                    }\n                }\n            }\n            else if (graphicsRotation === 270) {\n                graphics.translateTransform(0, template._size[0]);\n                graphics.rotateTransform(270);\n                if (isNormalMatrix || (typeof this.rotationAngle !== 'undefined' && this._rotate === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180)) {\n                    x = -(page.size[0] - bounds.x - bounds.width);\n                    y = bounds.y;\n                }\n                else {\n                    x = -(page.size[0] - annotationBounds.x - template._size[0]);\n                    var matrix = template._content.dictionary.getArray('Matrix');\n                    var box = template._content.dictionary.getArray('BBox');\n                    if (matrix && box && matrix[5] !== box[2]) {\n                        y = bounds.y - (bounds.height - bounds.width);\n                    }\n                    else {\n                        y = (bounds.y + bounds.height) - bounds.width;\n                    }\n                    width = bounds.height;\n                    height = bounds.width;\n                }\n            }\n            else if (graphicsRotation === 0) {\n                if (!isNormalMatrix &&\n                    (typeof this.rotationAngle !== 'undefined' &&\n                        (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90 ||\n                            this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270))) {\n                    x = bounds.x;\n                    y = (bounds.y + bounds.height - bounds.width);\n                    width = bounds.height;\n                    height = bounds.width;\n                }\n            }\n        }\n        return { x: x, y: y, width: width, height: height };\n    };\n    PdfAnnotation.prototype._obtainGraphicsRotation = function (matrix) {\n        var radians = Math.atan2(matrix._matrix._elements[2], matrix._matrix._elements[0]);\n        var angle = Math.round(radians * 180 / Math.PI);\n        switch (angle) {\n            case -90:\n                angle = 90;\n                break;\n            case -180:\n                angle = 180;\n                break;\n            case 90:\n                angle = 270;\n                break;\n        }\n        return angle;\n    };\n    PdfAnnotation.prototype._removeAnnotation = function (page, annotation) {\n        if (page && annotation) {\n            page.annotations.remove(annotation);\n            page._pageDictionary._updated = true;\n        }\n    };\n    PdfAnnotation.prototype._drawCloudStyle = function (graphics, brush, pen, radius, overlap, points, isAppearance) {\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(points) && this._isClockWise(points)) {\n            var sortedPoints = [];\n            for (var i = points.length - 1; i >= 0; i--) {\n                sortedPoints.push(points[Number.parseInt(i.toString(), 10)]);\n            }\n            points = sortedPoints;\n        }\n        var circles = [];\n        var circleOverlap = 2 * radius * overlap;\n        var previousPoint;\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(points)) {\n            previousPoint = points[points.length - 1];\n        }\n        else {\n            points = [];\n        }\n        for (var i = 0; i < points.length; i++) {\n            var currentPoint = points[Number.parseInt(i.toString(), 10)];\n            var dx = currentPoint[0] - previousPoint[0];\n            var dy = currentPoint[1] - previousPoint[1];\n            var length_1 = Math.sqrt(dx * dx + dy * dy);\n            dx = dx / length_1;\n            dy = dy / length_1;\n            for (var a = 0; a + 0.1 * circleOverlap < length_1; a += circleOverlap) {\n                var cur = new _CloudStyleArc();\n                cur.point = [previousPoint[0] + a * dx, previousPoint[1] + a * dy];\n                circles.push(cur);\n            }\n            previousPoint = currentPoint;\n        }\n        var previousCurvedStyleArc = circles[circles.length - 1];\n        for (var i = 0; i < circles.length; i++) {\n            var currentCurvedStyleArc = circles[Number.parseInt(i.toString(), 10)];\n            var angle = this._getIntersectionDegrees(previousCurvedStyleArc.point, currentCurvedStyleArc.point, radius);\n            previousCurvedStyleArc.endAngle = angle[0];\n            currentCurvedStyleArc.startAngle = angle[1];\n            previousCurvedStyleArc = currentCurvedStyleArc;\n        }\n        var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        for (var i = 0; i < circles.length; i++) {\n            var current = circles[Number.parseInt(i.toString(), 10)];\n            var startAngle = current.startAngle % 360;\n            var endAngle = current.endAngle % 360;\n            var sweepAngel = 0;\n            if (startAngle > 0 && endAngle < 0) {\n                sweepAngel = (180 - startAngle) + (180 - (endAngle < 0 ? -endAngle : endAngle));\n            }\n            else if (startAngle < 0 && endAngle > 0) {\n                sweepAngel = -startAngle + endAngle;\n            }\n            else if (startAngle > 0 && endAngle > 0) {\n                var difference = 0;\n                if (startAngle > endAngle) {\n                    difference = startAngle - endAngle;\n                    sweepAngel = 360 - difference;\n                }\n                else {\n                    sweepAngel = endAngle - startAngle;\n                }\n            }\n            else if (startAngle < 0 && endAngle < 0) {\n                var difference = 0;\n                if (startAngle > endAngle) {\n                    difference = startAngle - endAngle;\n                    sweepAngel = 360 - difference;\n                }\n                else {\n                    sweepAngel = -(startAngle + (-endAngle));\n                }\n            }\n            if (sweepAngel < 0) {\n                sweepAngel = -sweepAngel;\n            }\n            current.endAngle = sweepAngel;\n            path.addArc(current.point[0] - radius, current.point[1] - radius, 2 * radius, 2 * radius, startAngle, sweepAngel);\n        }\n        path.closeFigure();\n        var tempPoints = [];\n        if (isAppearance) {\n            for (var i = 0; i < path._points.length; i++) {\n                tempPoints.push([path._points[Number.parseInt(i.toString(), 10)][0], -path._points[Number.parseInt(i.toString(), 10)][1]]);\n            }\n        }\n        var pdfpath;\n        if (isAppearance) {\n            pdfpath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            pdfpath._points = tempPoints;\n            pdfpath._pathTypes = path._pathTypes;\n        }\n        else {\n            pdfpath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            pdfpath._points = path._points;\n            pdfpath._pathTypes = path._pathTypes;\n        }\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(brush)) {\n            graphics.drawPath(pdfpath, brush);\n        }\n        var incise = 180 / (Math.PI * 3);\n        path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        for (var i = 0; i < circles.length; i++) {\n            var current = circles[Number.parseInt(i.toString(), 10)];\n            path.addArc(current.point[0] - radius, current.point[1] - radius, 2 * radius, 2 * radius, current.startAngle, current.endAngle + incise);\n        }\n        path.closeFigure();\n        tempPoints = [];\n        if (isAppearance) {\n            for (var i = 0; i < path._points.length; i++) {\n                tempPoints.push([path._points[Number.parseInt(i.toString(), 10)][0], -path._points[Number.parseInt(i.toString(), 10)][1]]);\n            }\n        }\n        if (isAppearance) {\n            pdfpath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            pdfpath._points = tempPoints;\n            pdfpath._pathTypes = path._pathTypes;\n        }\n        else {\n            pdfpath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            pdfpath._points = path._points;\n            pdfpath._pathTypes = path._pathTypes;\n        }\n        graphics.drawPath(pdfpath, pen);\n    };\n    PdfAnnotation.prototype._isClockWise = function (points) {\n        var sum = 0;\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(points)) {\n            for (var i = 0; i < points.length; i++) {\n                var first = points[Number.parseInt(i.toString(), 10)];\n                var second = points[(i + 1) % points.length];\n                sum += (second[0] - first[0]) * (second[1] + first[1]);\n            }\n        }\n        return sum > 0;\n    };\n    PdfAnnotation.prototype._getIntersectionDegrees = function (first, second, radius) {\n        var dx = second[0] - first[0];\n        var dy = second[1] - first[1];\n        var length = Math.sqrt(dx * dx + dy * dy);\n        var a = 0.5 * length / radius;\n        if (a < -1) {\n            a = -1;\n        }\n        else if (a > 1) {\n            a = 1;\n        }\n        var radian = Math.atan2(dy, dx);\n        var cosvalue = Math.acos(a);\n        return [(radian - cosvalue) * (180 / Math.PI), (Math.PI + radian + cosvalue) * (180 / Math.PI)];\n    };\n    PdfAnnotation.prototype._obtainStyle = function (borderPen, rectangle, borderWidth, parameter) {\n        var dash = this.border.dash;\n        if (dash && dash.length > 0) {\n            var dashPattern = [];\n            var isDash = false;\n            for (var i = 0; i < dash.length; i++) {\n                dashPattern[Number.parseInt(i.toString(), 10)] = dash[Number.parseInt(i.toString(), 10)];\n                if (dashPattern[Number.parseInt(i.toString(), 10)] > 0) {\n                    isDash = true;\n                }\n            }\n            if (isDash && this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dashed) {\n                borderPen._dashStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDashStyle.dash;\n                borderPen._dashPattern = dashPattern;\n            }\n        }\n        if (parameter) {\n            if (parameter instanceof _PaintParameter) {\n                if (!this._isBounds && this._dictionary.has('RD')) {\n                    var array = this._dictionary.getArray('RD');\n                    if (array) {\n                        rectangle[0] = rectangle[0] + array[0];\n                        rectangle[1] = rectangle[1] + borderWidth + array[1];\n                        rectangle[2] = rectangle[2] - (array[0] + array[2]);\n                        rectangle[3] = rectangle[3] - (array[1] + array[3]);\n                    }\n                }\n                else {\n                    rectangle[0] = rectangle[0] + borderWidth;\n                    rectangle[1] = rectangle[1] + borderWidth;\n                    rectangle[2] = rectangle[2] - this.border.width;\n                    rectangle[3] = rectangle[3] - this.border.width;\n                }\n                parameter.bounds = rectangle;\n            }\n            else {\n                if (parameter.intensity !== 0 && parameter.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                    var radius = parameter.intensity * 5;\n                    rectangle[0] = rectangle[0] + radius + borderWidth;\n                    rectangle[1] = rectangle[1] + radius + borderWidth;\n                    rectangle[2] = rectangle[2] - (2 * radius) - 2 * borderWidth;\n                    rectangle[3] = rectangle[3] - (2 * radius) - 2 * borderWidth;\n                }\n                else {\n                    rectangle[0] = rectangle[0] + borderWidth;\n                    rectangle[1] = rectangle[1] + borderWidth;\n                    rectangle[2] = rectangle[2] - this.border.width;\n                    rectangle[3] = this.bounds.height - this.border.width;\n                }\n            }\n        }\n        else {\n            if (!this._isBounds && this._dictionary && this._dictionary.has('RD')) {\n                var array = this._dictionary.getArray('RD');\n                if (array) {\n                    rectangle[0] = rectangle[0] + array[0];\n                    rectangle[1] = rectangle[1] + borderWidth + array[1];\n                    rectangle[2] = rectangle[2] - (2 * array[2]);\n                    rectangle[3] = rectangle[3] - this.border.width;\n                    rectangle[3] = rectangle[3] - (2 * array[3]);\n                }\n            }\n            else {\n                rectangle[1] = rectangle[1] + borderWidth;\n                rectangle[3] = this.bounds.height - this.border.width;\n            }\n        }\n        return rectangle;\n    };\n    PdfAnnotation.prototype._createRectangleAppearance = function (borderEffect) {\n        var width = this.border.width;\n        var rdArray = this._dictionary.getArray('RD');\n        if (!rdArray && borderEffect !== null && typeof borderEffect !== 'undefined' && borderEffect.intensity !== 0 && borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n            var cloudRectangle = { x: this.bounds.x - borderEffect.intensity * 5 - width / 2,\n                y: this.bounds.y - borderEffect.intensity * 5 - width / 2,\n                width: this.bounds.width + borderEffect.intensity * 10 + width,\n                height: this.bounds.height + borderEffect.intensity * 10 + width };\n            var radius = borderEffect.intensity * 5;\n            rdArray = [radius + width / 2, radius + width / 2, radius + width / 2, radius + width / 2];\n            this._dictionary.set('RD', rdArray);\n            this.bounds = cloudRectangle;\n        }\n        if (!this._isBounds && rdArray) {\n            var cloudRectangle = { x: this.bounds.x + rdArray[0],\n                y: this.bounds.y + rdArray[1],\n                width: this.bounds.width - rdArray[2] * 2,\n                height: this.bounds.height - rdArray[3] * 2 };\n            if (borderEffect.intensity !== 0 && borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                cloudRectangle.x = cloudRectangle.x - borderEffect.intensity * 5 - width / 2;\n                cloudRectangle.y = cloudRectangle.y - borderEffect.intensity * 5 - width / 2;\n                cloudRectangle.width = cloudRectangle.width + borderEffect.intensity * 10 + width;\n                cloudRectangle.height = cloudRectangle.height + borderEffect.intensity * 10 + width;\n                var radius = borderEffect.intensity * 5;\n                this._dictionary.set('RD', [radius + width / 2, radius + width / 2, radius + width / 2, radius + width / 2]);\n            }\n            else {\n                delete this._dictionary._map.RD;\n            }\n            this.bounds = cloudRectangle;\n        }\n        var borderWidth = width / 2;\n        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n        if (borderEffect.intensity !== 0 && borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n            template._writeTransformation = false;\n        }\n        var graphics = template.graphics;\n        var parameter = new _PaintParameter();\n        if (this.innerColor) {\n            parameter.backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n        }\n        if (width > 0 && this.color) {\n            parameter.borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this._color, width);\n        }\n        if (this.color) {\n            parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._color);\n        }\n        var rectangle = this._obtainStyle(parameter.borderPen, nativeRectangle, borderWidth, borderEffect);\n        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n            graphics.save();\n            graphics.setTransparency(this._opacity);\n        }\n        if (borderEffect.intensity !== 0 && borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n            this._drawRectangleAppearance(rectangle, graphics, parameter, borderEffect.intensity);\n        }\n        else {\n            graphics.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.backBrush);\n        }\n        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n            graphics.restore();\n        }\n        return template;\n    };\n    PdfAnnotation.prototype._drawRectangleAppearance = function (rectangle, graphics, parameter, intensity) {\n        var graphicsPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(rectangle) && rectangle.length === 4) {\n            graphicsPath.addRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3]);\n        }\n        var radius = 0;\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(intensity)) {\n            radius = intensity * 4.25;\n        }\n        if (radius > 0) {\n            var points = [];\n            for (var i = 0; i < graphicsPath._points.length; i++) {\n                var sublist = [graphicsPath._points[Number.parseInt(i.toString(), 10)][0],\n                    -graphicsPath._points[Number.parseInt(i.toString(), 10)][1]];\n                points.push(sublist);\n            }\n            graphicsPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            graphicsPath.addPolygon(points);\n            this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, false);\n        }\n        else {\n            graphics.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.backBrush);\n        }\n    };\n    PdfAnnotation.prototype._createCircleAppearance = function () {\n        var nativeBounds = [0, 0, this.bounds.width, this.bounds.height];\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeBounds, this._crossReference);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n        if (this._dictionary.has('BE')) {\n            template._writeTransformation = false;\n        }\n        if (typeof this.color === 'undefined') {\n            this._isTransparentColor = true;\n        }\n        var graphics = template.graphics;\n        var width = this.border.width;\n        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.color, width);\n        var parameter = new _PaintParameter();\n        if (this.innerColor) {\n            parameter.backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n        }\n        if (width > 0) {\n            parameter.borderPen = borderPen;\n        }\n        if (this.color) {\n            parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._color);\n        }\n        parameter.borderWidth = width;\n        var borderWidth = width / 2;\n        var rectangle = this._obtainStyle(borderPen, nativeBounds, borderWidth);\n        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n            graphics.save();\n            graphics.setTransparency(this._opacity);\n        }\n        if (this._dictionary.has('BE')) {\n            this._drawCircleAppearance(rectangle, borderWidth, graphics, parameter);\n        }\n        else {\n            graphics.drawEllipse(rectangle[0] + borderWidth, rectangle[1], rectangle[2] - width, rectangle[3], parameter.borderPen, parameter.backBrush);\n        }\n        if (typeof this._opacity !== 'undefined' && this._opacity < 1) {\n            graphics.restore();\n        }\n        return template;\n    };\n    PdfAnnotation.prototype._drawCircleAppearance = function (rectangle, borderWidth, graphics, parameter) {\n        var radius = 0;\n        if (this._dictionary.has('RD')) {\n            var array = this._dictionary.getArray('RD');\n            if (array && array.length > 0) {\n                radius = array[0];\n            }\n        }\n        if (radius > 0) {\n            var rect = [rectangle[0] + borderWidth,\n                -rectangle[1] - rectangle[3],\n                rectangle[2] - this.border.width,\n                rectangle[3]];\n            var left = rect[0];\n            var top_1 = rect[1];\n            var right = rect[0] + rect[2];\n            var bottom = rect[1] + rect[3];\n            var controlPointList = [];\n            controlPointList.push([right, bottom]);\n            controlPointList.push([left, bottom]);\n            controlPointList.push([left, top_1]);\n            controlPointList.push([right, top_1]);\n            var startPointList = [];\n            startPointList.push([right, top_1 + (rect[3] / 2)]);\n            startPointList.push([left + rect[2] / 2, bottom]);\n            startPointList.push([left, top_1 + (rect[3] / 2)]);\n            startPointList.push([left + (rect[2] / 2), top_1]);\n            var endPointList = [];\n            endPointList.push([left + rect[2] / 2, bottom]);\n            endPointList.push([left, top_1 + (rect[3] / 2)]);\n            endPointList.push([left + (rect[2] / 2), top_1]);\n            endPointList.push([right, top_1 + (rect[3] / 2)]);\n            var points = [];\n            for (var i = 0; i < controlPointList.length; i++) {\n                this._createBezier(startPointList[Number.parseInt(i.toString(), 10)], controlPointList[Number.parseInt(i.toString(), 10)], endPointList[Number.parseInt(i.toString(), 10)], points);\n            }\n            this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, points, false);\n        }\n        else {\n            graphics.drawEllipse(rectangle[0] + borderWidth, -rectangle[1], rectangle[2] - this.border.width, -rectangle[3], parameter.borderPen, parameter.backBrush);\n        }\n    };\n    PdfAnnotation.prototype._createBezier = function (first, second, third, bezierPoints) {\n        bezierPoints.push(first);\n        this._populateBezierPoints(first, second, third, 0, bezierPoints);\n        bezierPoints.push(third);\n    };\n    PdfAnnotation.prototype._populateBezierPoints = function (first, second, third, currentIteration, bezierPoints) {\n        if (currentIteration < 2) {\n            var midPoint1 = this._midPoint(first, second);\n            var midPoint2 = this._midPoint(second, third);\n            var midPoint3 = this._midPoint(midPoint1, midPoint2);\n            currentIteration++;\n            this._populateBezierPoints(first, midPoint1, midPoint3, currentIteration, bezierPoints);\n            bezierPoints.push(midPoint3);\n            this._populateBezierPoints(midPoint3, midPoint2, third, currentIteration, bezierPoints);\n        }\n    };\n    PdfAnnotation.prototype._midPoint = function (first, second) {\n        return [(first[0] + second[0]) / 2, (first[1] + second[1]) / 2];\n    };\n    PdfAnnotation.prototype._getAngle = function (linePoints) {\n        var x1 = linePoints[0];\n        var y1 = linePoints[1];\n        var x2 = linePoints[2];\n        var y2 = linePoints[3];\n        var angle = 0;\n        if (x2 - x1 === 0) {\n            angle = (y2 > y1) ? 90 : 270;\n        }\n        else {\n            var angleRatio = (y2 - y1) / (x2 - x1);\n            var radians = Math.atan(angleRatio);\n            angle = radians * (180 / Math.PI);\n            if ((x2 - x1) < 0 || (y2 - y1) < 0) {\n                angle += 180;\n            }\n            if ((x2 - x1) > 0 && (y2 - y1) < 0) {\n                angle -= 180;\n            }\n            if (angle < 0) {\n                angle += 360;\n            }\n        }\n        return angle;\n    };\n    PdfAnnotation.prototype._getAxisValue = function (value, angle, length) {\n        return [value[0] + Math.cos(angle * this._degreeToRadian) * length,\n            value[1] + Math.sin(angle * this._degreeToRadian) * length];\n    };\n    PdfAnnotation.prototype._drawLineEndStyle = function (axisPoint, graphics, angle, pen, brush, style, length, isBegin) {\n        var arraowAngle;\n        var count;\n        var startPoint;\n        var first;\n        var second;\n        var third;\n        var fourth;\n        var path;\n        switch (style) {\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.square:\n                graphics.drawRectangle(axisPoint[0] - (3 * length), -(axisPoint[1] + (3 * length)), (6 * length), (6 * length), pen, brush);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.circle:\n                graphics.drawEllipse(axisPoint[0] - (3 * length), -(axisPoint[1] + (3 * length)), (6 * length), (6 * length), pen, brush);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.openArrow:\n                arraowAngle = isBegin ? 30 : 150;\n                count = 9 * length;\n                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? length : (-length)));\n                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);\n                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);\n                path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                path._pen = pen;\n                path.addLine(startPoint[0], -startPoint[1], first[0], -first[1]);\n                path.addLine(startPoint[0], -startPoint[1], second[0], -second[1]);\n                graphics._stateControl(pen, null, null);\n                graphics._buildUpPath(path._points, path._pathTypes);\n                graphics._drawGraphicsPath(pen, null, path._fillMode, false);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.closedArrow:\n                arraowAngle = isBegin ? 30 : 150;\n                count = 9 * length;\n                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? length : (-length)));\n                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);\n                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);\n                graphics.drawPolygon([[startPoint[0], -startPoint[1]], [first[0], -first[1]], [second[0], -second[1]]], pen, brush);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.rOpenArrow:\n                arraowAngle = isBegin ? 150 : 30;\n                count = 9 * length;\n                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? (-length) : length));\n                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);\n                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);\n                path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                path._pen = pen;\n                path.addLine(startPoint[0], -startPoint[1], first[0], -first[1]);\n                path.addLine(startPoint[0], -startPoint[1], second[0], -second[1]);\n                graphics._stateControl(pen, null, null);\n                graphics._buildUpPath(path._points, path._pathTypes);\n                graphics._drawGraphicsPath(pen, null, path._fillMode, false);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.rClosedArrow:\n                arraowAngle = isBegin ? 150 : 30;\n                count = 9 * length;\n                startPoint = this._getAxisValue(axisPoint, angle, (isBegin ? (-length) : length));\n                first = this._getAxisValue(startPoint, (angle + arraowAngle), count);\n                second = this._getAxisValue(startPoint, (angle - arraowAngle), count);\n                graphics.drawPolygon([[startPoint[0], -startPoint[1]], [first[0], -first[1]], [second[0], -second[1]]], pen, brush);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.slash:\n                count = 9 * length;\n                first = this._getAxisValue(axisPoint, (angle + 60), count);\n                second = this._getAxisValue(axisPoint, (angle - 120), count);\n                graphics.drawLine(pen, axisPoint[0], -axisPoint[1], first[0], -first[1]);\n                graphics.drawLine(pen, axisPoint[0], -axisPoint[1], second[0], -second[1]);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.diamond:\n                count = 3 * length;\n                first = this._getAxisValue(axisPoint, 180, count);\n                second = this._getAxisValue(axisPoint, 90, count);\n                third = this._getAxisValue(axisPoint, 0, count);\n                fourth = this._getAxisValue(axisPoint, -90, count);\n                graphics.drawPolygon([[first[0], -first[1]], [second[0], -second[1]], [third[0], -third[1]], [fourth[0], -fourth[1]]], pen, brush);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.butt:\n                count = 3 * length;\n                first = this._getAxisValue(axisPoint, (angle + 90), count);\n                second = this._getAxisValue(axisPoint, (angle - 90), count);\n                graphics.drawLine(pen, first[0], -first[1], second[0], -second[1]);\n                break;\n        }\n    };\n    PdfAnnotation.prototype._drawLineStyle = function (start, end, graphics, angle, pen, brush, lineStyle, length) {\n        if (length === 0) {\n            length = 1;\n            pen = null;\n        }\n        this._drawLineEndStyle(start, graphics, angle, pen, brush, lineStyle.begin, length, true);\n        this._drawLineEndStyle(end, graphics, angle, pen, brush, lineStyle.end, length, false);\n    };\n    PdfAnnotation.prototype._obtainFontDetails = function () {\n        var fontFamily = '';\n        var fontSize;\n        var style = _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n        if (this._dictionary.has('DS') || this._dictionary.has('DA')) {\n            var fontStyle = void 0;\n            if (this._dictionary.has('DS')) {\n                var collection = this._dictionary.get('DS').split(';');\n                for (var i = 0; i < collection.length; i++) {\n                    var entry = collection[Number.parseInt(i.toString(), 10)].split(':');\n                    if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-family') !== -1) {\n                        fontFamily = entry[1];\n                    }\n                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-size') !== -1) {\n                        if (entry[1].endsWith('pt')) {\n                            fontSize = Number.parseFloat(entry[1].replace('pt', ''));\n                        }\n                    }\n                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font-style') !== -1 || collection[Number.parseInt(i.toString(), 10)].indexOf('style') !== -1) {\n                        fontStyle = entry[1];\n                    }\n                    else if (collection[Number.parseInt(i.toString(), 10)].indexOf('font') !== -1) {\n                        var name_1 = entry[1];\n                        var split = name_1.split(' ');\n                        for (var j = 0; j < split.length; j++) {\n                            if (split[Number.parseInt(j.toString(), 10)] !== '' && !split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {\n                                fontFamily += split[Number.parseInt(j.toString(), 10)] + ' ';\n                            }\n                            if (split[Number.parseInt(j.toString(), 10)].endsWith('pt')) {\n                                fontSize = Number.parseFloat(split[Number.parseInt(j.toString(), 10)].replace('pt', ''));\n                            }\n                        }\n                        while (fontFamily !== ' ' && fontFamily.endsWith(' ')) {\n                            fontFamily = fontFamily.substring(0, fontFamily.length - 1);\n                        }\n                        if (fontFamily.indexOf(',') !== -1) {\n                            fontFamily = fontFamily.split(',')[0];\n                        }\n                    }\n                }\n            }\n            else {\n                var value = this._dictionary.get('DA');\n                if (value && value !== '' && value.indexOf('Tf') !== -1) {\n                    var textCollection = value.split(' ');\n                    for (var i = 0; i < textCollection.length; i++) {\n                        if (textCollection[Number.parseInt(i.toString(), 10)].indexOf('Tf') !== -1) {\n                            fontFamily = textCollection[i - 2];\n                            while (fontFamily !== '' && fontFamily.length > 1 && fontFamily[0] === '/') {\n                                fontFamily = fontFamily.substring(1);\n                            }\n                            fontSize = Number.parseFloat(textCollection[i - 1]);\n                        }\n                    }\n                }\n            }\n            if (fontStyle && fontStyle !== '') {\n                var styleArray = [fontStyle];\n                if (fontStyle.includes(':')) {\n                    styleArray = fontStyle.split(':');\n                }\n                else if (fontStyle.includes(',')) {\n                    styleArray = fontStyle.split(',');\n                }\n                if (styleArray) {\n                    styleArray.forEach(function (entry) {\n                        entry = entry.trim();\n                        switch (entry.toLowerCase()) {\n                            case 'bold':\n                                style |= _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.bold;\n                                break;\n                            case 'italic':\n                                style |= _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.italic;\n                                break;\n                            case 'strikeout':\n                                style |= _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.strikeout;\n                                break;\n                            case 'underline':\n                                style |= _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.underline;\n                                break;\n                        }\n                    });\n                }\n            }\n            if (fontFamily) {\n                fontFamily = fontFamily.trim();\n            }\n        }\n        return { name: fontFamily, size: fontSize, style: style };\n    };\n    PdfAnnotation.prototype._obtainFont = function () {\n        var fontData = this._obtainFontDetails();\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapFont)(fontData.name, fontData.size, fontData.style, this);\n    };\n    PdfAnnotation.prototype._getEqualPdfGraphicsUnit = function (measurementUnit, unitString) {\n        var graphicsUnit;\n        switch (measurementUnit) {\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.inch:\n                graphicsUnit = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.inch;\n                unitString = 'in';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.centimeter:\n                graphicsUnit = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.centimeter;\n                unitString = 'cm';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.millimeter:\n                graphicsUnit = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.millimeter;\n                unitString = 'mm';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.pica:\n                graphicsUnit = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.pica;\n                unitString = 'p';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.point:\n                graphicsUnit = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.point;\n                unitString = 'pt';\n                break;\n            default:\n                graphicsUnit = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.inch;\n                unitString = 'in';\n                break;\n        }\n        return { graphicsUnit: graphicsUnit, unitString: unitString };\n    };\n    PdfAnnotation.prototype._createMeasureDictionary = function (unitString) {\n        var d = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        d.set('C', 1);\n        d.set('D', 100);\n        d.set('F', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('D'));\n        d.set('RD', '.');\n        d.set('RT', '');\n        d.set('SS', '');\n        d.set('U', unitString);\n        var a = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        a.set('C', 1);\n        a.set('D', 100);\n        a.set('F', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('D'));\n        a.set('RD', '.');\n        a.set('RT', '');\n        a.set('SS', '');\n        a.set('U', 'sq ' + unitString);\n        var x = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        if (unitString === 'in') {\n            x.set('C', 0.0138889);\n        }\n        else if (unitString === 'cm') {\n            x.set('C', 0.0352778);\n        }\n        else if (unitString === 'mm') {\n            x.set('C', 0.352778);\n        }\n        else if (unitString === 'pt') {\n            x.set('C', 1);\n        }\n        else if (unitString === 'p') {\n            x.set('C', 0.0833333);\n        }\n        x.set('D', 100);\n        x.set('F', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('D'));\n        x.set('RD', '.');\n        x.set('RT', '');\n        x.set('SS', '');\n        x.set('U', unitString);\n        var measureDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        measureDictionary.set('A', [a]);\n        measureDictionary.set('D', [d]);\n        measureDictionary.set('R', '1 ' + unitString + ' = 1 ' + unitString);\n        measureDictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Measure'));\n        measureDictionary.set('X', [x]);\n        return measureDictionary;\n    };\n    PdfAnnotation.prototype._colorToHex = function (col) {\n        if (col) {\n            return '#' + this._componentToHex(col[0]) + this._componentToHex(col[1]) + this._componentToHex(col[2]);\n        }\n        else {\n            return '#' + this._componentToHex(0) + this._componentToHex(0) + this._componentToHex(0);\n        }\n    };\n    PdfAnnotation.prototype._componentToHex = function (c) {\n        var hex = c.toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n    PdfAnnotation.prototype._getRotatedBounds = function (bounds, rotateAngle) {\n        if (bounds.width > 0 && bounds.height > 0) {\n            var matrix = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__._PdfTransformationMatrix();\n            matrix._rotate(rotateAngle);\n            var corners = [];\n            corners.push([bounds.x, bounds.y]);\n            corners.push([bounds.x + bounds.width, bounds.y]);\n            corners.push([bounds.x + bounds.width, bounds.y + bounds.height]);\n            corners.push([bounds.x, bounds.y + bounds.height]);\n            for (var i = 0; i < corners.length; i++) {\n                corners[Number.parseInt(i.toString(), 10)] = matrix._matrix._transform(corners[Number.parseInt(i.toString(), 10)]);\n            }\n            var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            path.addRectangle(bounds.x, bounds.y, bounds.width, bounds.height);\n            for (var i = 0; i < 4; i++) {\n                path._points[Number.parseInt(i.toString(), 10)] = corners[Number.parseInt(i.toString(), 10)];\n            }\n            var minX = corners[0][0];\n            var maxX = corners[3][0];\n            var minY = corners[0][1];\n            var maxY = corners[3][1];\n            for (var i = 0; i < 4; i++) {\n                if (corners[Number.parseInt(i.toString(), 10)][0] < minX) {\n                    minX = corners[Number.parseInt(i.toString(), 10)][0];\n                }\n                if (corners[Number.parseInt(i.toString(), 10)][0] > maxX) {\n                    maxX = corners[Number.parseInt(i.toString(), 10)][0];\n                }\n                if (corners[Number.parseInt(i.toString(), 10)][1] < minY) {\n                    minY = corners[Number.parseInt(i.toString(), 10)][1];\n                }\n                if (corners[Number.parseInt(i.toString(), 10)][1] > maxY) {\n                    maxY = corners[Number.parseInt(i.toString(), 10)][1];\n                }\n            }\n            return { x: bounds.x, y: bounds.y, width: Math.round(maxX - minX), height: Math.round(maxY - minY) };\n        }\n        return bounds;\n    };\n    PdfAnnotation.prototype._flattenPopUp = function () {\n        this._flattenPop(this._page, this.color, this.bounds, this.border, this.author, this.subject, this.text);\n    };\n    PdfAnnotation.prototype._flattenPop = function (_page, color, boundsValue, border, author, subject, text) {\n        var clientSize = [0, 0];\n        if (_page && _page.size) {\n            clientSize = _page.size;\n        }\n        var x = clientSize[0] - 180;\n        var annotBounds = boundsValue;\n        var y = (annotBounds.y + 142) < clientSize[1] ? annotBounds.y : clientSize[1] - 142;\n        var bounds = [x, y, 180, 142];\n        if (this._dictionary.has('Popup')) {\n            var dictionary = this._dictionary.get('Popup');\n            if (dictionary) {\n                var rectValue = this._dictionary.getArray('Rect');\n                if (rectValue && rectValue.length === 4) {\n                    var left = rectValue[0];\n                    var top_2 = rectValue[1];\n                    var width = rectValue[2];\n                    var height = rectValue[3];\n                    bounds = [left, top_2, width - left, height - top_2];\n                }\n            }\n        }\n        if (typeof color === 'undefined') {\n            color = [0, 0, 0];\n        }\n        var backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(color);\n        var borderWidth = border.width / 2;\n        var pen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen([0, 0, 0], 1);\n        var track = 0;\n        var aBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._getForeColor(color));\n        if (typeof author !== 'undefined' && author !== null && author !== '') {\n            track = this._drawAuthor(author, subject, bounds, backBrush, aBrush, _page, track, border);\n        }\n        else if (typeof subject !== 'undefined' && subject !== null && subject !== '') {\n            var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 40];\n            this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n            if (this._isTransparentColor) {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);\n            }\n            else {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);\n            }\n            _page.graphics.restore();\n            var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];\n            contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];\n            this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.normal);\n            this._drawSubject(subject, contentRect, _page);\n            _page.graphics.restore();\n            track = 40;\n        }\n        else {\n            this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n            var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 20];\n            if (this._isTransparentColor) {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);\n            }\n            else {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);\n            }\n            track = 20;\n            _page.graphics.restore();\n        }\n        var rect = [bounds[0] + borderWidth, bounds[1] + borderWidth + track,\n            bounds[2] - border.width, bounds[3] - (track + border.width)];\n        this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n        _page.graphics.drawRectangle(rect[0], rect[1], rect[2], rect[3], new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen([0, 0, 0], 1), new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush([255, 255, 255]));\n        rect[0] += 11;\n        rect[1] += 5;\n        rect[2] -= 22;\n        _page.graphics.restore();\n        this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.normal);\n        if (typeof text !== 'undefined' && text !== null && text !== '') {\n            _page.graphics.drawString(text, this._popUpFont, rect, null, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush([0, 0, 0]), null);\n        }\n        _page.graphics.restore();\n    };\n    PdfAnnotation.prototype._flattenLoadedPopUp = function () {\n        var content = '';\n        if (this._dictionary.has('Contents')) {\n            content = this._dictionary.get('Contents');\n        }\n        var author = this.author;\n        var subject = this.subject;\n        var pen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen([0, 0, 0], 1);\n        if (!this._dictionary.has('Popup')) {\n            this._flattenPop(this._page, this.color, this.bounds, this.border, author, subject, content);\n            this._page.annotations.remove(this);\n        }\n        else {\n            var bounds = this._getRectangleBoundsValue();\n            if (typeof this.color === 'undefined') {\n                this.color = [0, 0, 0];\n            }\n            var backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.color);\n            var borderWidth = this.border.width / 2;\n            var track = 0;\n            var aBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._getForeColor(this.color));\n            if (typeof this.author !== 'undefined' && this.author !== null && this.author !== '') {\n                track = this._drawAuthor(this.author, this.subject, bounds, backBrush, aBrush, this._page, track, this.border);\n            }\n            else if (typeof this.subject !== 'undefined' && this.subject !== null && this.subject !== '') {\n                var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - this.border.width, 40];\n                this._saveGraphics(this._page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n                this._page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);\n                this._page.graphics.restore();\n                var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];\n                contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];\n                this._saveGraphics(this._page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.normal);\n                this._drawSubject(this.subject, contentRect, this._page);\n                track = 40;\n                this._page.graphics.restore();\n            }\n            else {\n                this._saveGraphics(this._page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n                var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - this.border.width, 20];\n                this._page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);\n                track = 20;\n                this._page.graphics.restore();\n            }\n            this._saveGraphics(this._page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n            var rect = [bounds[0] + borderWidth, bounds[1] + borderWidth + track,\n                bounds[2] - this.border.width, bounds[3] - (track + this.border.width)];\n            this._page.graphics.drawRectangle(rect[0], rect[1], rect[2], rect[3], pen, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush([255, 255, 255]));\n            rect[0] += 11;\n            rect[1] += 5;\n            rect[2] -= 22;\n            this._page.graphics.restore();\n            this._saveGraphics(this._page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.normal);\n            this._page.graphics.restore();\n            //let xmlData: Array<any> = Array<any>();\n            // if (this._dictionary.has('RC')) {\n            //     //xmlData = this.parseXMLData();\n            // }\n            // if (xmlData !== null) {\n            //     // Need to add xml data code\n            // } else {\n            if (typeof content !== 'undefined' && content !== null && content !== '') {\n                this._page.graphics.drawString(content, this._popUpFont, rect, null, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush([0, 0, 0]), null);\n            }\n            // }\n            this._page.graphics.restore();\n            this._page.annotations.remove(this);\n        }\n    };\n    PdfAnnotation.prototype._getRectangleBoundsValue = function () {\n        if (this._dictionary.has('Popup')) {\n            var dic = this._dictionary.get('Popup');\n            var rect = dic.getArray('Rect');\n            if (rect !== null) {\n                if (this._page !== null) {\n                    if (rect[1] === 0 && rect[3] === 0) {\n                        rect[1] = rect[1] + rect[3];\n                    }\n                    else {\n                        rect[1] = this._page._size[1] - (rect[1] + rect[3]);\n                    }\n                }\n                else {\n                    rect[1] = (rect[1] - rect[3]);\n                }\n                return rect;\n            }\n            else {\n                return [0, 0, 0, 0];\n            }\n        }\n        else {\n            return [0, 0, 0, 0];\n        }\n    };\n    PdfAnnotation.prototype._getForeColor = function (color) {\n        var fore = (((color[0] + color[1] + color[2]) / 3) > 128) ? [0, 0, 0] : [255, 255, 255];\n        return fore;\n    };\n    PdfAnnotation.prototype._drawAuthor = function (author, subject, bounds, backBrush, aBrush, _page, trackingHeight, border) {\n        var borderWidth = this.border.width / 2;\n        var pen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen([0, 0, 0], 1);\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n        var titleRect = [bounds[0] + borderWidth, bounds[1] + borderWidth, bounds[2] - border.width, 20];\n        if (typeof subject !== 'undefined' && subject !== null && subject !== '') {\n            titleRect[3] += 20;\n            trackingHeight = titleRect[3];\n            this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n            if (this._isTransparentColor) {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);\n            }\n            else {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);\n            }\n            _page.graphics.restore();\n            var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3] / 2];\n            this._saveGraphics(this._page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.normal);\n            _page.graphics.drawString(author, this._authorBoldFont, contentRect, null, aBrush, format);\n            contentRect = [contentRect[0], (contentRect[1] + contentRect[3] - 2), contentRect[2], titleRect[3] / 2];\n            this._drawSubject(subject, contentRect, _page);\n            _page.graphics.restore();\n        }\n        else {\n            this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.hardLight);\n            if (this._isTransparentColor) {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen);\n            }\n            else {\n                _page.graphics.drawRectangle(titleRect[0], titleRect[1], titleRect[2], titleRect[3], pen, backBrush);\n            }\n            _page.graphics.restore();\n            var contentRect = [titleRect[0] + 11, titleRect[1], titleRect[2], titleRect[3]];\n            this._saveGraphics(_page, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.normal);\n            _page.graphics.drawString(author, this._popUpFont, contentRect, null, aBrush, format);\n            trackingHeight = titleRect[3];\n            _page.graphics.restore();\n        }\n        return trackingHeight;\n    };\n    PdfAnnotation.prototype._drawSubject = function (subject, contentRect, _page) {\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n        _page.graphics.drawString(subject, this._authorBoldFont, contentRect, null, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush([0, 0, 0]), format);\n    };\n    PdfAnnotation.prototype._saveGraphics = function (_page, blendMode) {\n        _page.graphics.save();\n        _page.graphics.setTransparency(0.8, 0.8, blendMode);\n    };\n    PdfAnnotation.prototype._getBorderColorString = function (color) {\n        return (color[0] / 255).toFixed(3) + ' ' + (color[1] / 255).toFixed(3) + ' ' + (color[2] / 255).toFixed(3) + ' rg ';\n    };\n    PdfAnnotation.prototype._stringToDate = function (date) {\n        var dateFormat = new Date();\n        if (date[0] === 'D' && date[1] === ':') {\n            var year = date.substring(2, 6);\n            var month = date.substring(6, 8);\n            var day = date.substring(8, 10);\n            var hour = date.substring(10, 12);\n            var minute = date.substring(12, 14);\n            var second = date.substring(14, 16);\n            var difference = 0;\n            if (date.length === 23) {\n                var timeZone = date.substring(16, 22);\n                if (timeZone !== '+05\\'30\\'') {\n                    var signature = timeZone[0];\n                    var timeZoneHour = timeZone.substring(1, 3);\n                    var timeZonMinute = timeZone.substring(4, 6);\n                    difference = 5.5 - (signature === '-' ? -1 : 1) * (parseInt(timeZoneHour, 10) + (parseInt(timeZonMinute, 10) / 60));\n                }\n            }\n            dateFormat = new Date(year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':' + second);\n            if (difference !== 0) {\n                dateFormat.setTime(dateFormat.getTime() + (difference * 60 * 60 * 1000));\n            }\n        }\n        else if (date.indexOf('/') !== -1) {\n            var list = date.split('/');\n            var year = list[2].split(' ')[0];\n            var month = list[0];\n            if (month !== '10' && month !== '11' && month !== '12') {\n                month = '0' + month;\n            }\n            var day = list[1];\n            var hour = list[2].split(' ')[1].split(':')[0];\n            var minute = list[2].split(' ')[1].split(':')[1];\n            var second = list[2].split(' ')[1].split(':')[2];\n            dateFormat = new Date(year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':' + second);\n        }\n        else {\n            dateFormat = new Date(date);\n        }\n        return dateFormat;\n    };\n    PdfAnnotation.prototype._dateToString = function (dateTime) {\n        var month = (dateTime.getMonth() + 1).toString();\n        if (month !== '10' && month !== '11' && month !== '12') {\n            month = '0' + month;\n        }\n        var date = (dateTime.getDate()).toString();\n        if (Number.parseInt(date) < 10) { // eslint-disable-line\n            date = '0' + date;\n        }\n        var hours = (dateTime.getHours()).toString();\n        if (Number.parseInt(hours) < 10) { // eslint-disable-line\n            hours = '0' + hours;\n        }\n        var minutes = (dateTime.getMinutes()).toString();\n        if (Number.parseInt(minutes) < 10) { // eslint-disable-line\n            minutes = '0' + minutes;\n        }\n        var seconds = (dateTime.getSeconds()).toString();\n        if (Number.parseInt(seconds) < 10) { // eslint-disable-line\n            seconds = '0' + seconds;\n        }\n        return 'D:' + dateTime.getFullYear().toString() + month + date + hours + minutes + seconds + '+05\\'30\\'';\n    };\n    PdfAnnotation.prototype._obtainNativeRectangle = function () {\n        var rect = [this._bounds.x, this._bounds.y, this.bounds.x + this._bounds.width, this.bounds.y + this._bounds.height];\n        var cropBoxOrMediaBox = this._getCropOrMediaBox();\n        if (this._page) {\n            var size = this._page.size;\n            rect[1] = size[1] - rect[3];\n            if (cropBoxOrMediaBox && cropBoxOrMediaBox.length > 2 && (cropBoxOrMediaBox[0] !== 0 || cropBoxOrMediaBox[1] !== 0)) {\n                rect[0] += cropBoxOrMediaBox[0];\n                rect[1] += cropBoxOrMediaBox[1];\n            }\n        }\n        return rect;\n    };\n    PdfAnnotation.prototype._getPoints = function (polygonPoints) {\n        var cropOrMediaBox = this._getCropOrMediaBox();\n        var points = polygonPoints;\n        if (cropOrMediaBox && cropOrMediaBox.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {\n            var modifiedPoints = [];\n            for (var i = 0; i < points.length; i++) {\n                modifiedPoints.push(points[Number.parseInt(i.toString(), 10)]);\n            }\n            for (var j = 0; j < modifiedPoints.length; j = j + 2) {\n                var x = modifiedPoints[Number.parseInt(j.toString(), 10)];\n                var y = modifiedPoints[j + 1];\n                if (cropOrMediaBox) {\n                    points[Number.parseInt(j.toString(), 10)] = x + cropOrMediaBox[0];\n                    if (this._page._pageDictionary.has('MediaBox') && !this._page._pageDictionary.has('CropBox') && cropOrMediaBox[3] === 0 && cropOrMediaBox[1] > 0) {\n                        points[j + 1] = y + cropOrMediaBox[3];\n                    }\n                    else {\n                        points[j + 1] = y + cropOrMediaBox[1];\n                    }\n                }\n            }\n        }\n        return points;\n    };\n    PdfAnnotation.prototype._getCropOrMediaBox = function () {\n        var cropOrMediaBox;\n        if (this._page) {\n            cropOrMediaBox = this._page.cropBox;\n            if (!cropOrMediaBox || cropOrMediaBox.length === 0) {\n                cropOrMediaBox = this._page.mediaBox;\n            }\n        }\n        if (cropOrMediaBox && cropOrMediaBox[3] < 0) {\n            var y = cropOrMediaBox[1];\n            var height = cropOrMediaBox[3];\n            cropOrMediaBox[3] = y;\n            cropOrMediaBox[1] = height;\n        }\n        return cropOrMediaBox;\n    };\n    PdfAnnotation.prototype._getDocumentLayer = function () {\n        if (this._dictionary.has('OC')) {\n            var reference = this._dictionary.getRaw('OC');\n            var page = this._page;\n            if (reference && page && this._crossReference._document) {\n                var layerCollection = this._crossReference._document.layers;\n                if (layerCollection) {\n                    this._isMatched(layerCollection, reference, page);\n                }\n            }\n        }\n        return this.layer;\n    };\n    PdfAnnotation.prototype._isMatched = function (layerCollection, expectedReference, page) {\n        for (var i = 0; i < layerCollection.count; i++) {\n            var reference = layerCollection.at(i)._referenceHolder;\n            if (reference && reference === expectedReference) {\n                if (layerCollection.at(i).name) {\n                    this._layer = layerCollection.at(i);\n                    break;\n                }\n            }\n            else if (layerCollection.at(i).layers && layerCollection.at(i).layers.count > 0) {\n                this._isMatched(layerCollection.at(i).layers, expectedReference, page);\n            }\n        }\n    };\n    return PdfAnnotation;\n}());\n\n/**\n * Represents the annotations which have comments and review history.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfComment = page.annotations.at(0) as PdfComment;\n * // Gets the comments of annotation\n * let comment : PdfPopupAnnotationCollection = annotation.comments;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfComment = /** @class */ (function (_super) {\n    __extends(PdfComment, _super);\n    function PdfComment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(PdfComment.prototype, \"comments\", {\n        /**\n         * Gets the comments of the PDF annotation (Read only).\n         *\n         * @returns {PdfPopupAnnotationCollection} Annotation comments\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Access first page\n         * let page: PdfPage = document.getPage(0);\n         * // Access the annotation at index 0\n         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;\n         * // Gets the comments of the PDF annotation\n         * let comments: PdfPopupAnnotationCollection = annotation.comments;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._comments) {\n                return this._comments;\n            }\n            else {\n                return this._comments = new _annotation_collection__WEBPACK_IMPORTED_MODULE_12__.PdfPopupAnnotationCollection(this, false);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfComment.prototype, \"reviewHistory\", {\n        /**\n         * Gets the review history of the PDF annotation (Read only).\n         *\n         * @returns {PdfPopupAnnotationCollection} Annotation review history.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Access first page\n         * let page: PdfPage = document.getPage(0);\n         * // Access the annotation at index 0\n         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;\n         * // Gets the comments of the PDF annotation\n         * let comments: PdfPopupAnnotationCollection = annotation.reviewHistory;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._reviewHistory) {\n                return this._reviewHistory;\n            }\n            else {\n                return this._reviewHistory = new _annotation_collection__WEBPACK_IMPORTED_MODULE_12__.PdfPopupAnnotationCollection(this, true);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfComment;\n}(PdfAnnotation));\n\n/**\n * `PdfLineAnnotation` class represents the line annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new line annotation with line points\n * const annotation: PdfLineAnnotation = new PdfLineAnnotation([10, 50, 250, 50]);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfLineAnnotation = /** @class */ (function (_super) {\n    __extends(PdfLineAnnotation, _super);\n    function PdfLineAnnotation(linePoints) {\n        var _this = _super.call(this) || this;\n        _this._unit = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.centimeter;\n        _this._unitString = '';\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Line'));\n        if (linePoints !== null && typeof linePoints !== 'undefined') {\n            _this.linePoints = linePoints;\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.lineAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfLineAnnotation.prototype, \"linePoints\", {\n        /**\n         * Gets the line points of the line annotation.\n         *\n         * @returns {number[]} Line points.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the line points of the line annotation.\n         * let linePoints : number[] = annotation.linePoints;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._linePoints === 'undefined' && this._dictionary.has('L')) {\n                var points = this._dictionary.getArray('L');\n                if (points) {\n                    this._linePoints = points;\n                }\n            }\n            return this._linePoints;\n        },\n        /**\n         * Sets the line points of the line annotation.\n         *\n         * @param {number[]} value Line points.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the line points of the line annotation.\n         * annotation.linePoints = [10, 50, 250, 50];\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (Array.isArray(value) && (typeof this._linePoints === 'undefined' || (0,_utils__WEBPACK_IMPORTED_MODULE_3__._areNotEqual)(value, this._linePoints))) {\n                if (value.length === 4) {\n                    this._dictionary.update('L', value);\n                    this._linePoints = value;\n                }\n                else {\n                    throw new Error('Line points length should be 4.');\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfLineAnnotation.prototype, \"leaderExt\", {\n        /**\n         * Gets the line extension of the line annotation.\n         *\n         * @returns {number} Leader line extension.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the line extension of the line annotation.\n         * let leaderExt: number = annotation.leaderExt;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._leaderExt === 'undefined' && this._dictionary.has('LLE')) {\n                var leaderExt = this._dictionary.get('LLE');\n                if (typeof leaderExt !== 'undefined') {\n                    this._leaderExt = leaderExt;\n                }\n            }\n            return this._leaderExt;\n        },\n        /**\n         * Sets the line extension of the line annotation.\n         *\n         * @param {number} value Line extension.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the line extension of the line annotation.\n         * annotation.leaderExt = 4;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!Number.isNaN(value)) {\n                this._dictionary.update('LLE', value);\n                this._leaderExt = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfLineAnnotation.prototype, \"leaderLine\", {\n        /**\n         * Gets the leader line of the line annotation.\n         *\n         * @returns {number} Leader line.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the leader line of the line annotation.\n         * let leaderLine: number = annotation.leaderLine;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._leaderLine === 'undefined' && this._dictionary.has('LL')) {\n                var leaderLine = this._dictionary.get('LL');\n                if (typeof leaderLine !== 'undefined') {\n                    this._leaderLine = leaderLine;\n                }\n            }\n            return this._leaderLine;\n        },\n        /**\n         * Sets the leader line of the line annotation.\n         *\n         * @param {number} value Leader line.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the leader line of the line annotation.\n         * annotation.leaderLine = 5;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!Number.isNaN(value) && this.leaderExt !== 0) {\n                this._dictionary.update('LL', value);\n                this._leaderLine = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfLineAnnotation.prototype, \"lineEndingStyle\", {\n        /**\n         * Gets the line ending style of the line annotation.\n         *\n         * @returns {PdfAnnotationLineEndingStyle} Line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the line ending style of the line annotation.\n         * let lineEndingStyle: PdfAnnotationLineEndingStyle = annotation.lineEndingStyle;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._lineEndingStyle === 'undefined') {\n                var value = new PdfAnnotationLineEndingStyle();\n                value._dictionary = this._dictionary;\n                if (this._dictionary.has('LE')) {\n                    var lineStyles = this._dictionary.getArray('LE');\n                    if (lineStyles && Array.isArray(lineStyles)) {\n                        value._begin = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapLineEndingStyle)(lineStyles[0].name);\n                        value._end = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapLineEndingStyle)(lineStyles[1].name);\n                    }\n                }\n                this._lineEndingStyle = value;\n            }\n            return this._lineEndingStyle;\n        },\n        /**\n         * Sets the line ending style of the line annotation.\n         *\n         * @param {PdfAnnotationLineEndingStyle} value Line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the line ending style of the line annotation.\n         * annotation.lineEndingStyle = new PdfAnnotationLineEndingStyle(PdfLineEndingStyle.openArrow, PdfLineEndingStyle.closeArrow);\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            var style = this.lineEndingStyle;\n            if (style.begin !== value.begin || style.end !== value.end) {\n                style.begin = value.begin;\n                style.end = value.end;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfLineAnnotation.prototype, \"leaderOffset\", {\n        /**\n         * Gets the leader offset of the line annotation.\n         *\n         * @returns {number} Leader offset.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the leader offset value of the line annotation\n         * let leaderOffset: number = annotation.leaderOffset;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._leaderOffset === 'undefined' && this._dictionary.has('LLO')) {\n                var leaderOffset = this._dictionary.get('LLO');\n                if (typeof leaderOffset !== 'undefined' && leaderOffset >= 0) {\n                    this._leaderOffset = leaderOffset;\n                }\n            }\n            return this._leaderOffset;\n        },\n        /**\n         * Sets the leader offset of the line annotation.\n         *\n         * @param {number} value Leader line offset.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the leader offset of the line annotation.\n         * annotation.leaderOffset = 1;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!Number.isNaN(value)) {\n                this._dictionary.update('LLO', value);\n                this._leaderOffset = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfLineAnnotation.prototype, \"lineIntent\", {\n        /**\n         * Gets the line intent of the line annotation.\n         *\n         * @returns {PdfLineIntent} Line intent.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the line intent value of the line annotation\n         * let lineIntent: PdfLineIntent = annotation.lineIntent;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._lineIntent === 'undefined' && this._dictionary.has('IT')) {\n                var lineIntent = this._dictionary.get('IT');\n                if (lineIntent) {\n                    this._lineIntent = lineIntent.name === 'LineDimension' ? _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineIntent.lineDimension : _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineIntent.lineArrow;\n                }\n            }\n            return this._lineIntent;\n        },\n        /**\n         * Sets the line intent of the line annotation.\n         *\n         * @param {PdfLineIntent} value Line intent.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the line intent of the line annotation.\n         * annotation.lineIntent = PdfLineIntent.lineDimension;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value !== this.lineIntent) {\n                this._lineIntent = value;\n                this._dictionary.update('IT', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(value === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineIntent.lineDimension ? 'LineDimension' : 'LineArrow'));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfLineAnnotation.prototype, \"measure\", {\n        /**\n         * Gets the flag to have measurement dictionary of the line annotation.\n         *\n         * @returns {boolean} measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the flag to have measurement dictionary of the line annotation.\n         * let measure: boolean = annotation.measure;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._measure === 'undefined') {\n                this._measure = this._dictionary.has('Measure');\n            }\n            return this._measure;\n        },\n        /**\n         * Sets the flag to add measurement dictionary to the line annotation.\n         *\n         * @param {boolean} value Measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the flag to have measurement dictionary of the line annotation.\n         * annotation.measure = true;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value) {\n                if (!this._isLoaded) {\n                    this._measure = value;\n                    this.caption.cap = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfLineAnnotation.prototype, \"unit\", {\n        /**\n         * Gets the measurement unit of the annotation.\n         *\n         * @returns {PdfMeasurementUnit} Measurement unit.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the measurement unit of the annotation.\n         * let unit: PdfMeasurementUnit = annotation.unit;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._unit === 'undefined' || this._isLoaded) {\n                this._unit = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.centimeter;\n                if (this._dictionary.has('Contents')) {\n                    var text = this._dictionary.get('Contents');\n                    this._unitString = text.substring(text.length - 2);\n                    this._unit = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapMeasurementUnit)(this._unitString);\n                }\n            }\n            return this._unit;\n        },\n        /**\n         * Sets the measurement unit of the line annotation.\n         *\n         * @param {PdfMeasurementUnit} value Measurement unit.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the measurement unit of the annotation.\n         * annotation.unit = PdfMeasurementUnit.centimeter;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._measure) {\n                if (!this._isLoaded && typeof value !== 'undefined') {\n                    this._unit = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfLineAnnotation._load = function (page, dictionary) {\n        var annot = new PdfLineAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfLineAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfLineAnnotation.prototype._postProcess = function (flatten) {\n        if (typeof this.linePoints === 'undefined' || this.linePoints === null) {\n            throw new Error('Line points cannot be null or undefined');\n        }\n        else {\n            var cropOrMediaBox = this._getCropOrMediaBox();\n            if (cropOrMediaBox && cropOrMediaBox.length > 3 && this.linePoints.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {\n                this._linePoints[0] += cropOrMediaBox[0];\n                this._linePoints[1] += cropOrMediaBox[1];\n                this._linePoints[2] += cropOrMediaBox[0];\n                this._linePoints[3] += cropOrMediaBox[1];\n                this._dictionary.update('L', this._linePoints);\n            }\n        }\n        if (!this._dictionary.has('Cap')) {\n            this._dictionary.set('Cap', false);\n        }\n        if (!this._dictionary.has('CP')) {\n            this._dictionary.set('CP', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Inline'));\n        }\n        if (!this._dictionary.has('LE')) {\n            this.lineEndingStyle = new PdfAnnotationLineEndingStyle();\n        }\n        if (!this._dictionary.has('LL')) {\n            this.leaderLine = 0;\n        }\n        if (!this._dictionary.has('LLE')) {\n            this.leaderExt = 0;\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (this.border.dash === null || typeof this.border.dash === 'undefined') {\n            this.border.dash = [];\n            if (this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dashed) {\n                this.border.dash = [3, 1];\n            }\n            else if (this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dot) {\n                this.border.dash = [1, 1];\n            }\n        }\n        if (this._measure) {\n            this._appearanceTemplate = this._createLineMeasureAppearance(flatten);\n        }\n        else {\n            var isUpdated = false;\n            if (this._setAppearance) {\n                this._appearanceTemplate = this._createAppearance();\n                if (this._page._isNew && !(this._flatten || flatten)) {\n                    var boundsArray = this._obtainLineBounds();\n                    var bounds = {\n                        x: boundsArray[0],\n                        y: boundsArray[1], width: boundsArray[2], height: boundsArray[3]\n                    };\n                    this._bounds = bounds;\n                    var updatedBounds = [this._bounds.x,\n                        this._bounds.y,\n                        this._bounds.x + this._bounds.width,\n                        this._bounds.y + this._bounds.height];\n                    this._dictionary.update('Rect', updatedBounds);\n                    isUpdated = true;\n                }\n            }\n            else {\n                var bounds = this._obtainLineBounds();\n                var rectangleBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._fromRectangle)({ x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] });\n                if (this._page._isNew && this._page._pageSettings && this._setAppearance && !this.flatten) {\n                    rectangleBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this, bounds);\n                }\n                this.bounds = { x: rectangleBounds[0], y: rectangleBounds[1], width: rectangleBounds[2], height: rectangleBounds[3] };\n                this._dictionary.update('Rect', rectangleBounds);\n                isUpdated = true;\n            }\n            if (this._dictionary.has('Measure') && !isUpdated) {\n                var boundsArray = this._obtainLineBounds();\n                var bounds = { x: boundsArray[0],\n                    y: boundsArray[1], width: boundsArray[2], height: boundsArray[3] };\n                this._bounds = bounds;\n                var updatedBounds = void 0;\n                if (this._page && this._page._isNew && this._page._pageSettings && !this._setAppearance && !this.flatten) {\n                    updatedBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this);\n                }\n                else {\n                    updatedBounds = [this._bounds.x,\n                        this._bounds.y,\n                        this._bounds.x + this._bounds.width,\n                        this._bounds.y + this._bounds.height];\n                }\n                this._dictionary.update('Rect', updatedBounds);\n                if (this.flatten && !this.measure && this._page && this._page.size && Array.isArray(this._page.size) &&\n                    this._page.size.length >= 2) {\n                    this._bounds = { x: boundsArray[0], y: this._page.size[1] - (boundsArray[1] + boundsArray[3]),\n                        width: boundsArray[2], height: boundsArray[3] };\n                }\n            }\n        }\n    };\n    PdfLineAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                if (this._dictionary.has('Measure')) {\n                    this._appearanceTemplate = this._createLineMeasureAppearance(isFlatten);\n                }\n                else {\n                    this._appearanceTemplate = this._createAppearance();\n                }\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    if (appearanceStream) {\n                        var reference = dictionary.getRaw('N');\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate) {\n                if (isFlatten) {\n                    if (!this._dictionary.has('AP')) {\n                        this._appearanceTemplate = this._createAppearance();\n                    }\n                    else {\n                        var dictionary = this._dictionary.get('AP');\n                        if (dictionary !== null && typeof dictionary !== 'undefined' && dictionary.has('N')) {\n                            var appearanceStream = dictionary.get('N');\n                            if (appearanceStream) {\n                                var reference = dictionary.getRaw('N');\n                                if (reference) {\n                                    appearanceStream.reference = reference;\n                                }\n                                this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && isFlatten) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n        var appearance;\n        if (!isFlatten && this._setAppearance && !this.measure) {\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference, appearance);\n                this._dictionary.update('AP', reference);\n            }\n        }\n        else if (this.measure && this._setAppearance && !this._dictionary.has('AP')) {\n            var reference = this._crossReference._getNextReference();\n            appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            this._crossReference._cacheMap.set(reference, appearance);\n            this._dictionary.update('AP', reference);\n        }\n        if (appearance && this._appearanceTemplate && this._appearanceTemplate._content) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    PdfLineAnnotation.prototype._createLineMeasureAppearance = function (_isFlatten) {\n        var nativeRectangle = [0, 0, 0, 0];\n        var area = this._convertToUnit();\n        var linePoints1 = this._obtainLinePoints();\n        var points = [];\n        for (var j = 0; j < linePoints1.length; j = j + 2) {\n            points.push([linePoints1[Number.parseInt(j.toString(), 10)], (linePoints1[j + 1])]);\n        }\n        var graphicsPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        graphicsPath._points = points;\n        graphicsPath._pathTypes = [0, 1];\n        var rectPath = graphicsPath._getBounds();\n        this._bounds = { x: rectPath[0], y: rectPath[1], width: rectPath[2], height: rectPath[3] };\n        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(typeof this.color !== 'undefined' ? this._color : [0, 0, 0], this.border.width);\n        var backBrush;\n        if (this.innerColor) {\n            backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n        }\n        nativeRectangle = this._obtainLineBounds();\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, 0);\n        var parameter = new _PaintParameter();\n        template._writeTransformation = false;\n        var graphics = template.graphics;\n        parameter.borderPen = borderPen;\n        if (this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dashed) {\n            parameter.borderPen._dashStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDashStyle.dash;\n            parameter.borderPen._dashPattern = [3, 1];\n        }\n        else if (this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dot) {\n            parameter.borderPen._dashStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDashStyle.dot;\n            parameter.borderPen._dashPattern = [1, 1];\n        }\n        parameter.backBrush = backBrush;\n        parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.color);\n        var linePoints = this._obtainLinePoints();\n        var font = this._obtainFont();\n        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {\n            font = this._lineCaptionFont;\n            this._pdfFont = font;\n        }\n        if (typeof linePoints !== 'undefined' && linePoints.length === 4) {\n            var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n            var fontSize = font.measureString(area.toFixed(2) + ' ' + this._unitString, [0, 0], format, 0, 0);\n            var angle = this._getAngle(this._linePoints);\n            var leaderLine = 0;\n            var lineAngle = 0;\n            if (this.leaderLine < 0) {\n                leaderLine = -(this.leaderLine);\n                lineAngle = angle + 180;\n            }\n            else {\n                leaderLine = this.leaderLine;\n                lineAngle = angle;\n            }\n            var offset = (typeof this.leaderOffset !== 'undefined') ? (leaderLine + this.leaderOffset) : leaderLine;\n            var startPoint = this._getAxisValue([this._linePoints[0], this._linePoints[1]], (lineAngle + 90), offset);\n            var endPoint = this._getAxisValue([this._linePoints[2], this._linePoints[3]], (lineAngle + 90), offset);\n            var lineDistance = (Math.sqrt(Math.pow((endPoint[0] - startPoint[0]), 2) +\n                Math.pow((endPoint[1] - startPoint[1]), 2)));\n            var centerWidth = lineDistance / 2 - ((fontSize[0] / 2) + this.border.width);\n            var first = this._getAxisValue(startPoint, angle, centerWidth);\n            var second = this._getAxisValue(endPoint, (angle + 180), centerWidth);\n            var start = (this.lineEndingStyle.begin === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.openArrow ||\n                this.lineEndingStyle.begin === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.closedArrow) ?\n                this._getAxisValue(startPoint, angle, this.border.width) :\n                startPoint;\n            var end = (this.lineEndingStyle.end === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.openArrow ||\n                this.lineEndingStyle.end === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.closedArrow) ?\n                this._getAxisValue(endPoint, angle, -this.border.width) :\n                endPoint;\n            var state = void 0;\n            if (this.opacity && this._opacity < 1) {\n                state = graphics.save();\n                graphics.setTransparency(this._opacity);\n            }\n            if (this.caption.type === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.top || (!this.caption.cap && this.caption.type === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.inline)) {\n                graphics.drawLine(borderPen, start[0], -start[1], end[0], -end[1]);\n            }\n            else {\n                graphics.drawLine(borderPen, start[0], -start[1], first[0], -first[1]);\n                graphics.drawLine(borderPen, end[0], -end[1], second[0], -second[1]);\n            }\n            if (this.opacity && this._opacity < 1) {\n                graphics.restore(state);\n            }\n            this._drawLineStyle(startPoint, endPoint, graphics, angle, borderPen, backBrush, this.lineEndingStyle, this.border.width);\n            var leaderExt = (typeof this.leaderExt !== 'undefined' ? this._leaderExt : 0);\n            var beginLineExt = this._getAxisValue(startPoint, (lineAngle + 90), leaderExt);\n            graphics.drawLine(borderPen, startPoint[0], -startPoint[1], beginLineExt[0], -beginLineExt[1]);\n            var endLineExt = this._getAxisValue(endPoint, (lineAngle + 90), leaderExt);\n            graphics.drawLine(borderPen, endPoint[0], -endPoint[1], endLineExt[0], -endLineExt[1]);\n            var beginLeaderLine = this._getAxisValue(startPoint, (lineAngle - 90), leaderLine);\n            graphics.drawLine(borderPen, startPoint[0], -startPoint[1], beginLeaderLine[0], -beginLeaderLine[1]);\n            var endLeaderLine = this._getAxisValue(endPoint, (lineAngle - 90), leaderLine);\n            graphics.drawLine(borderPen, endPoint[0], -endPoint[1], endLeaderLine[0], -endLeaderLine[1]);\n            var midpoint = lineDistance / 2;\n            var centerPoint = this._getAxisValue(startPoint, angle, midpoint);\n            var captionPosition = void 0;\n            var height = font._metrics._getHeight();\n            if (this.caption.type === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.top) {\n                captionPosition = this._getAxisValue(centerPoint, (angle + 90), height);\n            }\n            else {\n                captionPosition = this._getAxisValue(centerPoint, (angle + 90), (height / 2));\n            }\n            graphics.translateTransform(captionPosition[0], -captionPosition[1]);\n            graphics.rotateTransform(-angle);\n            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [(-fontSize[0] / 2), 0, 0, 0], null, parameter.foreBrush);\n            graphics.restore();\n        }\n        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {\n            template._content.dictionary._updated = true;\n            var ref = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(ref, template._content);\n            template._content.reference = ref;\n            var nativeRectangle1 = [this.bounds.x,\n                this.bounds.y + this.bounds.height,\n                this.bounds.width,\n                this.bounds.height];\n            var size = this._page.size;\n            nativeRectangle1[1] = size[1] - (this.bounds.y + this.bounds.height);\n            if (this._isBounds && !this.measure) {\n                nativeRectangle = nativeRectangle1;\n                this._dictionary.update('Rect', [nativeRectangle1[0], nativeRectangle1[1], nativeRectangle1[2], nativeRectangle1[3]]);\n            }\n            else {\n                this._dictionary.update('Rect', [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]]);\n            }\n            var ds = 'font:' +\n                font._metrics._postScriptName +\n                ' ' +\n                font._size +\n                'pt; color:' +\n                this._colorToHex(this.color);\n            this._dictionary.update('DS', ds);\n            if (typeof _isFlatten !== 'undefined' && !_isFlatten) {\n                if (this._dictionary.has('AP')) {\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n                }\n                var dic = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n                dic.set('N', ref);\n                dic._updated = true;\n                this._dictionary.set('AP', dic);\n                var measureDictionary = this._createMeasureDictionary(this._unitString);\n                var reference = this._crossReference._getNextReference();\n                this._crossReference._cacheMap.set(reference, measureDictionary);\n                measureDictionary._updated = true;\n                if (this._dictionary.has('Measure')) {\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary, this._crossReference, 'Measure');\n                }\n                this._dictionary.update('Measure', reference);\n            }\n            var lineStyles = [];\n            lineStyles.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.lineEndingStyle.begin)));\n            lineStyles.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.lineEndingStyle.end)));\n            this._dictionary.update('LE', lineStyles);\n            if (this._linePoints !== null) {\n                this._dictionary.update('L', this._linePoints);\n            }\n            else {\n                throw new Error('LinePoints cannot be null');\n            }\n            this._dictionary.update('C', [Number.parseFloat((this.color[0] / 255).toFixed(3)),\n                Number.parseFloat((this.color[1] / 255).toFixed(3)),\n                Number.parseFloat((this.color[2] / 255).toFixed(3))]);\n            var offset = this._dictionary.has('LLO') ? this.leaderOffset : 0;\n            this._dictionary.update('Subtype', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName('Line'));\n            if (this._text && this._text !== '') {\n                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' ' + this._unitString);\n            }\n            else {\n                this._dictionary.update('Contents', area.toFixed(2) + ' ' + this._unitString);\n            }\n            this._dictionary.update('IT', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName('LineDimension'));\n            this._dictionary.update('LLE', this.leaderExt);\n            this._dictionary.update('LLO', offset);\n            this._dictionary.update('LL', this.leaderLine);\n            this._dictionary.update('CP', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(this.caption.type === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.top ? 'Top' : 'Inline'));\n            this._dictionary.update('Cap', this.caption.cap);\n            var bounds = [nativeRectangle[0],\n                nativeRectangle[1],\n                nativeRectangle[0] + nativeRectangle[2],\n                nativeRectangle[1] + nativeRectangle[3]];\n            this._dictionary.update('Rect', bounds);\n            this._bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };\n        }\n        return template;\n    };\n    PdfLineAnnotation.prototype._calculateAngle = function (startPointX, startPointY, endPointX, endPointY) {\n        return -(Math.atan2((endPointY - startPointY), (endPointX - startPointX)) * (180 / Math.PI));\n    };\n    PdfLineAnnotation.prototype._calculateLineBounds = function (linePoints, leaderLineExt, leaderLine, leaderOffset, lineStyle, borderWidth) {\n        var bounds = { x: 0, y: 0, width: 0, height: 0 };\n        if (linePoints && linePoints.length === 4) {\n            var angle = this._getAngle(linePoints);\n            var leaderLines = 0;\n            var lineAngle = 0;\n            if (leaderLine < 0) {\n                leaderLines = -(leaderLine);\n                lineAngle = angle + 180;\n            }\n            else {\n                leaderLines = leaderLine;\n                lineAngle = angle;\n            }\n            var x1y1 = [linePoints[0], linePoints[1]];\n            var x2y2 = [linePoints[2], linePoints[3]];\n            if (leaderOffset !== 0) {\n                var offsetPoint1 = this._getAxisValue(x1y1, (lineAngle + 90), leaderOffset);\n                var offsetPoint2 = this._getAxisValue(x2y2, (lineAngle + 90), leaderOffset);\n                linePoints[0] = offsetPoint1[0];\n                linePoints[1] = offsetPoint1[1];\n                linePoints[2] = offsetPoint2[0];\n                linePoints[3] = offsetPoint2[1];\n            }\n            var startingPoint = this._getAxisValue(x1y1, (lineAngle + 90), leaderLines + leaderOffset);\n            var endingPoint = this._getAxisValue(x2y2, (lineAngle + 90), leaderLines + leaderOffset);\n            var beginLineLeader = this._getAxisValue(x1y1, (lineAngle + 90), leaderLineExt + leaderLines + leaderOffset);\n            var endLineLeader = this._getAxisValue(x2y2, (lineAngle + 90), leaderLineExt + leaderLines + leaderOffset);\n            var beginLinePoint = this._getLinePoint(lineStyle.begin, borderWidth);\n            var endLinePoint = this._getLinePoint(lineStyle.end, borderWidth);\n            var widthX = [];\n            var heightY = [];\n            if ((lineAngle >= 45 && lineAngle <= 135) || (lineAngle >= 225 && lineAngle <= 315)) {\n                widthX[0] = beginLinePoint.y;\n                heightY[0] = beginLinePoint.x;\n                widthX[1] = endLinePoint.y;\n                heightY[1] = endLinePoint.x;\n            }\n            else {\n                widthX[0] = beginLinePoint.x;\n                heightY[0] = beginLinePoint.y;\n                widthX[1] = endLinePoint.x;\n                heightY[1] = endLinePoint.y;\n            }\n            var width = Math.max(widthX[0], widthX[1]);\n            var height = Math.max(heightY[0], heightY[1]);\n            if (width === 0) {\n                width = 1;\n            }\n            if (height === 0) {\n                height = 1;\n            }\n            if (startingPoint[0] === Math.min(startingPoint[0], endingPoint[0])) {\n                startingPoint[0] -= width * borderWidth;\n                endingPoint[0] += width * borderWidth;\n                startingPoint[0] = Math.min(startingPoint[0], linePoints[0]);\n                startingPoint[0] = Math.min(startingPoint[0], beginLineLeader[0]);\n                endingPoint[0] = Math.max(endingPoint[0], linePoints[2]);\n                endingPoint[0] = Math.max(endingPoint[0], endLineLeader[0]);\n            }\n            else {\n                startingPoint[0] += width * borderWidth;\n                endingPoint[0] -= width * borderWidth;\n                startingPoint[0] = Math.max(startingPoint[0], linePoints[0]);\n                startingPoint[0] = Math.max(startingPoint[0], beginLineLeader[0]);\n                endingPoint[0] = Math.min(endingPoint[0], linePoints[2]);\n                endingPoint[0] = Math.min(endingPoint[0], endLineLeader[0]);\n            }\n            if (startingPoint[1] === Math.min(startingPoint[1], endingPoint[1])) {\n                startingPoint[1] -= height * borderWidth;\n                endingPoint[1] += height * borderWidth;\n                startingPoint[1] = Math.min(startingPoint[1], linePoints[1]);\n                startingPoint[1] = Math.min(startingPoint[1], beginLineLeader[1]);\n                endingPoint[1] = Math.max(endingPoint[1], linePoints[3]);\n                endingPoint[1] = Math.max(endingPoint[1], endLineLeader[1]);\n            }\n            else {\n                startingPoint[1] += height * borderWidth;\n                endingPoint[1] -= height * borderWidth;\n                startingPoint[1] = Math.max(startingPoint[1], linePoints[1]);\n                startingPoint[1] = Math.max(startingPoint[1], beginLineLeader[1]);\n                endingPoint[1] = Math.min(endingPoint[1], linePoints[3]);\n                endingPoint[1] = Math.min(endingPoint[1], endLineLeader[1]);\n            }\n            bounds = this._getBounds([{ x: startingPoint[0], y: startingPoint[1] }, { x: endingPoint[0], y: endingPoint[1] }]);\n        }\n        return bounds;\n    };\n    PdfLineAnnotation.prototype._getLinePoint = function (style, borderWidth) {\n        var point = { x: 0, y: 0 };\n        if (style) {\n            switch (style) {\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.square:\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.circle:\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.diamond:\n                    point.x = 3;\n                    point.y = 3;\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.openArrow:\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.closedArrow:\n                    point.x = 1;\n                    point.y = 5;\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.rOpenArrow:\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.rClosedArrow:\n                    point.x = 9 + (borderWidth / 2);\n                    point.y = 5 + (borderWidth / 2);\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.slash:\n                    point.x = 5;\n                    point.y = 9;\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.butt:\n                    point.x = 1;\n                    point.y = 3;\n                    break;\n                default:\n                    point.x = 0;\n                    point.y = 0;\n                    break;\n            }\n        }\n        return point;\n    };\n    PdfLineAnnotation.prototype._getBounds = function (points) {\n        var bounds = { x: 0, y: 0, width: 0, height: 0 };\n        if (points.length > 0) {\n            var xmin = points[0].x;\n            var xmax = points[0].x;\n            var ymin = points[0].y;\n            var ymax = points[0].y;\n            for (var i = 1; i < points.length; ++i) {\n                var point = points[Number.parseInt(i.toString(), 10)];\n                xmin = Math.min(point.x, xmin);\n                xmax = Math.max(point.x, xmax);\n                ymin = Math.min(point.y, ymin);\n                ymax = Math.max(point.y, ymax);\n            }\n            bounds.x = xmin;\n            bounds.y = ymin;\n            bounds.width = xmax - xmin;\n            bounds.height = ymax - ymin;\n        }\n        return bounds;\n    };\n    PdfLineAnnotation.prototype._obtainLineBounds = function () {\n        var bounds = this.bounds;\n        if (typeof this.linePoints !== 'undefined' && this._linePoints.length === 4) {\n            var leaderOffset = this._dictionary.has('LLO') ? this.leaderOffset : 0;\n            var leaderExt = this._dictionary.has('LLE') ? this.leaderExt : 0;\n            var leaderLine = this._dictionary.has('LL') ? this.leaderLine : 0;\n            bounds = this._calculateLineBounds(this._linePoints, leaderExt, leaderLine, leaderOffset, this.lineEndingStyle, this.border.width);\n            bounds = { x: bounds.x - 8, y: bounds.y - 8, width: (bounds.width + 2 * 8), height: (bounds.height + 2 * 8) };\n        }\n        return [bounds.x, bounds.y, bounds.width, bounds.height];\n    };\n    PdfLineAnnotation.prototype._createAppearance = function () {\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(this._obtainLineBounds(), this._crossReference);\n        var parameter = new _PaintParameter();\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, 0);\n        template._writeTransformation = false;\n        var graphics = template.graphics;\n        var pen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(typeof this.color !== 'undefined' ? this._color : [0, 0, 0], this.border.width);\n        if (this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dashed) {\n            pen._dashStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDashStyle.dash;\n            pen._dashPattern = [3, 1];\n        }\n        else if (this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dot) {\n            pen._dashStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDashStyle.dot;\n            pen._dashPattern = [1, 1];\n        }\n        parameter.borderPen = pen;\n        parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.color);\n        var brush;\n        if (this.innerColor) {\n            brush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n        }\n        var font = this._obtainFont();\n        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {\n            font = this._lineCaptionFont;\n            this._pdfFont = font;\n        }\n        if (!this.text && !this._dictionary.has('Contents')) {\n            this.text = this.subject;\n        }\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n        var lineWidth = 0;\n        if (this.caption.cap) {\n            lineWidth = font.measureString(this.text ? this.text : '', [0, 0], format, 0, 0)[0]; //66.71001;\n        }\n        if (typeof this.linePoints !== 'undefined' && this._linePoints.length === 4) {\n            var angle = this._getAngle(this._linePoints);\n            var leaderLine = 0;\n            var lineAngle = 0;\n            var leaderLineValue = this.leaderLine;\n            if (leaderLineValue === null || typeof leaderLineValue === 'undefined') {\n                this._leaderLine = 0;\n                leaderLineValue = 0;\n            }\n            if (leaderLineValue < 0) {\n                leaderLine = -(leaderLineValue);\n                lineAngle = angle + 180;\n            }\n            else {\n                leaderLine = leaderLineValue;\n                lineAngle = angle;\n            }\n            var offset = (typeof this.leaderOffset !== 'undefined') ? (leaderLine + this.leaderOffset) : leaderLine;\n            var startPoint = this._getAxisValue([this._linePoints[0], this._linePoints[1]], (lineAngle + 90), offset);\n            var endPoint = this._getAxisValue([this._linePoints[2], this._linePoints[3]], (lineAngle + 90), offset);\n            var lineDistance = (Math.sqrt(Math.pow((endPoint[0] - startPoint[0]), 2) +\n                Math.pow((endPoint[1] - startPoint[1]), 2)));\n            var centerWidth = lineDistance / 2 - ((lineWidth / 2) + this.border.width);\n            var first = this._getAxisValue(startPoint, angle, centerWidth);\n            var second = this._getAxisValue(endPoint, (angle + 180), centerWidth);\n            var start = (this.lineEndingStyle.begin === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.openArrow ||\n                this.lineEndingStyle.begin === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.closedArrow) ?\n                this._getAxisValue(startPoint, angle, this.border.width) :\n                startPoint;\n            var end = (this.lineEndingStyle.end === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.openArrow ||\n                this.lineEndingStyle.end === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.closedArrow) ?\n                this._getAxisValue(endPoint, angle, -this.border.width) :\n                endPoint;\n            if (this.opacity && this._opacity < 1) {\n                var state = graphics.save();\n                graphics.setTransparency(this._opacity);\n                this._drawLine(graphics, pen, start, end, first, second);\n                graphics.restore(state);\n            }\n            else {\n                this._drawLine(graphics, pen, start, end, first, second);\n            }\n            this._drawLineStyle(startPoint, endPoint, graphics, angle, pen, brush, this.lineEndingStyle, this.border.width);\n            var leaderExt = (typeof this.leaderExt !== 'undefined' ? this._leaderExt : 0);\n            var beginLineExt = this._getAxisValue(startPoint, (lineAngle + 90), leaderExt);\n            graphics.drawLine(pen, startPoint[0], -startPoint[1], beginLineExt[0], -beginLineExt[1]);\n            var endLineExt = this._getAxisValue(endPoint, (lineAngle + 90), leaderExt);\n            graphics.drawLine(pen, endPoint[0], -endPoint[1], endLineExt[0], -endLineExt[1]);\n            var beginLeaderLine = this._getAxisValue(startPoint, (lineAngle - 90), leaderLine);\n            graphics.drawLine(pen, startPoint[0], -startPoint[1], beginLeaderLine[0], -beginLeaderLine[1]);\n            var endLeaderLine = this._getAxisValue(endPoint, (lineAngle - 90), leaderLine);\n            graphics.drawLine(pen, endPoint[0], -endPoint[1], endLeaderLine[0], -endLeaderLine[1]);\n            var midpoint = lineDistance / 2;\n            var centerPoint = this._getAxisValue(startPoint, angle, midpoint);\n            var captionPosition = void 0;\n            var height = font._metrics._getHeight();\n            if (this.caption.type === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.top) {\n                if (this._measure) {\n                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), 2 * height);\n                }\n                else {\n                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), height);\n                }\n            }\n            else {\n                if (this._measure) {\n                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), 3 * (height / 2));\n                }\n                else {\n                    captionPosition = this._getAxisValue(centerPoint, (angle + 90), (height / 2));\n                }\n            }\n            graphics.translateTransform(captionPosition[0], -captionPosition[1]);\n            graphics.rotateTransform(-angle);\n            if (this.caption.cap) {\n                graphics.drawString(this.text, font, [(-lineWidth / 2), 0, 0, 0], null, parameter.foreBrush);\n            }\n            graphics.restore();\n            var bounds = this._obtainLineBounds();\n            var rectangleBounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._fromRectangle)({ x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] });\n            this.bounds = { x: rectangleBounds[0], y: rectangleBounds[1], width: rectangleBounds[2], height: rectangleBounds[3] };\n            if ((!this.measure) && (!this._dictionary.has('Measure'))) {\n                this._dictionary.update('Rect', [rectangleBounds[0], rectangleBounds[1], rectangleBounds[2], rectangleBounds[3]]);\n            }\n        }\n        return template;\n    };\n    PdfLineAnnotation.prototype._drawLine = function (graphics, pen, start, end, first, second) {\n        if (typeof this.text === 'undefined' ||\n            this._text === '' ||\n            this.caption.type === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.top ||\n            (!this.caption.cap && this.caption.type === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.inline)) {\n            graphics.drawLine(pen, start[0], -start[1], end[0], -end[1]);\n        }\n        else {\n            graphics.drawLine(pen, start[0], -start[1], first[0], -first[1]);\n            graphics.drawLine(pen, end[0], -end[1], second[0], -second[1]);\n        }\n    };\n    PdfLineAnnotation.prototype._convertToUnit = function () {\n        var points = this._obtainLinePoints();\n        var data = new Array(points.length / 2);\n        var count = 0;\n        for (var j = 0; j < points.length; j = j + 2) {\n            data[Number.parseInt(count.toString(), 10)] = [points[Number.parseInt(j.toString(), 10)], (points[j + 1])];\n            count++;\n        }\n        var distance = Math.sqrt(Math.pow((data[1][0] - data[0][0]), 2) + Math.pow((data[1][1] - data[0][1]), 2));\n        var value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);\n        this._unitString = value.unitString;\n        return (new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__._PdfUnitConvertor())._convertUnits(distance, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.point, value.graphicsUnit);\n    };\n    PdfLineAnnotation.prototype._obtainLinePoints = function () {\n        var points = [];\n        if (this.linePoints) {\n            for (var i = 0; i < this._linePoints.length; i++) {\n                points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];\n            }\n        }\n        return points;\n    };\n    return PdfLineAnnotation;\n}(PdfComment));\n\n/**\n * `PdfCircleAnnotation` class represents the circle annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new circle annotation with circle bounds\n * const annotation: PdfCircleAnnotation = new PdfCircleAnnotation(10, 10, 100, 100);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfCircleAnnotation = /** @class */ (function (_super) {\n    __extends(PdfCircleAnnotation, _super);\n    function PdfCircleAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._unit = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.centimeter;\n        _this._measureType = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfCircleMeasurementType.diameter;\n        _this._unitString = '';\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Circle'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.circleAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfCircleAnnotation.prototype, \"measure\", {\n        /**\n         * Gets the flag to have measurement dictionary of the circle annotation.\n         *\n         * @returns {boolean} measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;\n         * // Gets the flag to have measurement dictionary of the circle annotation.\n         * let measure: boolean = annotation.measure;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {\n                this._measure = this._dictionary.get('Measure');\n            }\n            return this._measure;\n        },\n        /**\n         * Sets the flag to add measurement dictionary to the annotation.\n         *\n         * @param {boolean} value Measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;\n         * // Sets the flag to have measurement dictionary of the circle annotation.\n         * annotation.measure = true;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value) {\n                if (!this._isLoaded) {\n                    this._measure = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfCircleAnnotation.prototype, \"unit\", {\n        /**\n         * Gets the measurement unit of the annotation.\n         *\n         * @returns {PdfMeasurementUnit} Measurement unit.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;\n         * // Gets the measurement unit of the annotation.\n         * let unit: PdfMeasurementUnit = annotation.unit;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._unit === 'undefined' || this._isLoaded) {\n                this._unit = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.centimeter;\n                if (this._dictionary.has('Contents')) {\n                    var text = this._dictionary.get('Contents');\n                    this._unitString = text.substring(text.length - 2);\n                    this._unit = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapMeasurementUnit)(this._unitString);\n                }\n            }\n            return this._unit;\n        },\n        /**\n         * Sets the measurement unit of the annotation.\n         *\n         * @param {PdfMeasurementUnit} value Measurement unit.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;\n         * // Sets the measurement unit of the annotation.\n         * annotation.unit = PdfMeasurementUnit.centimeter;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._measure) {\n                if (!this._isLoaded && typeof value !== 'undefined') {\n                    this._unit = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfCircleAnnotation.prototype, \"measureType\", {\n        /**\n         * Gets the measurement type of the annotation.\n         *\n         * @returns {PdfCircleMeasurementType} Measurement type.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;\n         * // Gets the measurement type of the annotation.\n         * let type: PdfCircleMeasurementType = annotation.type;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Contents')) {\n                var text = this._dictionary.get('Contents');\n                this._unitString = text.substring(text.length - 2);\n                this._unit = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapMeasurementUnit)(this._unitString);\n                var value = text.substring(0, text.length - 2);\n                var converter = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__._PdfUnitConvertor();\n                var radius = converter._convertUnits(this.bounds.width / 2, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.point, (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapGraphicsUnit)(this._unitString));\n                if (radius.toString() === value) {\n                    this._measureType = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfCircleMeasurementType.radius;\n                }\n                else {\n                    this._measureType = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfCircleMeasurementType.diameter;\n                }\n            }\n            return this._measureType;\n        },\n        /**\n         * Sets the measurement type of the annotation.\n         *\n         * @param {PdfCircleMeasurementType} value Measurement type.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfCircleAnnotation = page.annotations.at(0) as PdfCircleAnnotation;\n         * // Sets the measurement type of the annotation.\n         * annotation.type = PdfCircleMeasurementType.diameter;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._measure) {\n                if (!this._isLoaded && typeof value !== 'undefined') {\n                    this._measureType = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfCircleAnnotation._load = function (page, dictionary) {\n        var annot = new PdfCircleAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfCircleAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfCircleAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (this._measure) {\n            this._appearanceTemplate = this._createCircleMeasureAppearance(isFlatten);\n        }\n        else {\n            this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createCircleAppearance();\n            }\n        }\n    };\n    PdfCircleAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                if (this._dictionary.has('Measure')) {\n                    this._appearanceTemplate = this._createCircleMeasureAppearance(isFlatten);\n                }\n                else {\n                    this._appearanceTemplate = this._createCircleAppearance();\n                }\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate && isFlatten) {\n                if (!this._dictionary.has('AP')) {\n                    this._appearanceTemplate = this._createCircleAppearance();\n                }\n                else {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary !== null && typeof dictionary !== 'undefined' && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        var reference = dictionary.getRaw('N');\n                        if (appearanceStream) {\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && isFlatten) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n        if (!isFlatten && this._setAppearance && !this.measure) {\n            var appearance = void 0;\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference_1 = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference_1, appearance);\n                this._dictionary.update('AP', reference_1);\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    PdfCircleAnnotation.prototype._createCircleMeasureAppearance = function (_isFlatten) {\n        var borderWidth = this.border.width;\n        var font = this._obtainFont();\n        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {\n            font = this._circleCaptionFont;\n            this._pdfFont = font;\n        }\n        var area = this._convertToUnit();\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n        var str = area.toFixed(2) + ' ' + this._unitString;\n        var fontsize = font.measureString(str, [0, 0], format, 0, 0);\n        var color = this.color ? this.color : [0, 0, 0];\n        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(color, borderWidth);\n        var nativeRectangle = [this.bounds.x,\n            (this.bounds.y + this.bounds.height),\n            this.bounds.width,\n            this.bounds.height];\n        nativeRectangle[1] = nativeRectangle[1] - nativeRectangle[3];\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        var parameter = new _PaintParameter();\n        template._writeTransformation = false;\n        var graphics = template.graphics;\n        var width = borderWidth / 2;\n        parameter.borderPen = borderPen;\n        if (this.innerColor) {\n            parameter.backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n        }\n        parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(color);\n        var rect = [nativeRectangle[0],\n            -nativeRectangle[1] - nativeRectangle[3],\n            nativeRectangle[2],\n            nativeRectangle[3]];\n        graphics.save();\n        graphics.drawEllipse(rect[0] + width, rect[1] + width, rect[2] - borderWidth, rect[3] - borderWidth, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(color, this.border.width));\n        if (this._measureType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfCircleMeasurementType.diameter) {\n            graphics.save();\n            graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);\n            var x = (nativeRectangle[3] / 2) - (fontsize[0] / 2);\n            graphics.drawLine(parameter.borderPen, 0, -nativeRectangle[3] / 2, nativeRectangle[0] + nativeRectangle[2], -nativeRectangle[3] / 2);\n            graphics.translateTransform(x, -(nativeRectangle[3] / 2) - font._metrics._getHeight());\n            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [0, 0, 0, 0], null, parameter.foreBrush);\n            graphics.restore();\n        }\n        else {\n            graphics.save();\n            graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);\n            var x = (nativeRectangle[2] / 2) + ((nativeRectangle[2] / 4) - (fontsize[0] / 2));\n            graphics.drawLine(parameter.borderPen, nativeRectangle[2] / 2, -nativeRectangle[3] / 2, nativeRectangle[0] + nativeRectangle[2], -nativeRectangle[3] / 2);\n            graphics.translateTransform(x, -(nativeRectangle[3] / 2) - font._metrics._getHeight());\n            graphics.drawString(area.toFixed(2) + ' ' + this._unitString, font, [0, 0, 0, 0], null, parameter.foreBrush);\n            graphics.restore();\n        }\n        graphics.restore();\n        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {\n            if (this._dictionary.has('AP')) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n            }\n            var dic = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n            graphics._template._content.dictionary._updated = true;\n            var ref = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(ref, graphics._template._content);\n            graphics._template._content.reference = ref;\n            dic.set('N', ref);\n            dic._updated = true;\n            this._dictionary.set('AP', dic);\n            this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n            if (this._dictionary.has('Measure')) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary, this._crossReference, 'Measure');\n            }\n            var measureDictionary = this._createMeasureDictionary(this._unitString);\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, measureDictionary);\n            measureDictionary._updated = true;\n            this._dictionary.update('Measure', reference);\n            this._dictionary.update('Subtype', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName('Circle'));\n            if (this._text && this._text !== '') {\n                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' ' + this._unitString);\n            }\n            else {\n                this._dictionary.update('Contents', area.toFixed(2) + ' ' + this._unitString);\n            }\n            var ds = 'font:' +\n                font._metrics._postScriptName +\n                ' ' +\n                font._size +\n                'pt; color:' +\n                this._colorToHex(this.color);\n            this._dictionary.update('DS', ds);\n        }\n        return template;\n    };\n    PdfCircleAnnotation.prototype._convertToUnit = function () {\n        var converter = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__._PdfUnitConvertor();\n        var value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);\n        this._unitString = value.unitString;\n        var radius = converter._convertUnits(this.bounds.width / 2, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.point, value.graphicsUnit);\n        if (this._measureType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfCircleMeasurementType.diameter) {\n            radius = 2 * radius;\n        }\n        return radius;\n    };\n    return PdfCircleAnnotation;\n}(PdfComment));\n\n/**\n * `PdfEllipseAnnotation` class represents the ellipse annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new ellipse annotation with bounds\n * const annotation: PdfEllipseAnnotation = new PdfEllipseAnnotation(10, 10, 100, 100);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfEllipseAnnotation = /** @class */ (function (_super) {\n    __extends(PdfEllipseAnnotation, _super);\n    function PdfEllipseAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Circle'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.ellipseAnnotation;\n        return _this;\n    }\n    PdfEllipseAnnotation._load = function (page, dictionary) {\n        var annot = new PdfEllipseAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfEllipseAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfEllipseAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n            this._appearanceTemplate = this._createCircleAppearance();\n        }\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n    };\n    PdfEllipseAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createCircleAppearance();\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate && isFlatten) {\n                if (!this._dictionary.has('AP')) {\n                    this._appearanceTemplate = this._createCircleAppearance();\n                }\n                else {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        var reference = dictionary.getRaw('N');\n                        if (appearanceStream) {\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n        if (!isFlatten && this._setAppearance) {\n            var appearance = void 0;\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference_2 = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference_2, appearance);\n                this._dictionary.update('AP', reference_2);\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    return PdfEllipseAnnotation;\n}(PdfComment));\n\n/**\n * `PdfSquareAnnotation` class represents the square annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new square annotation with bounds\n * const annotation: PdfSquareAnnotation = new PdfSquareAnnotation(10, 10, 100, 100);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfSquareAnnotation = /** @class */ (function (_super) {\n    __extends(PdfSquareAnnotation, _super);\n    function PdfSquareAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._unit = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.centimeter;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Square'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.squareAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfSquareAnnotation.prototype, \"borderEffect\", {\n        /**\n         * Gets the border effect of the square annotation.\n         *\n         * @returns {PdfBorderEffect} Border effect.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Gets the border effect of the square annotation.\n         * let borderEffect : PdfBorderEffect = annotation.borderEffect;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._borderEffect === 'undefined') {\n                var value = new PdfBorderEffect();\n                value._dictionary = this._dictionary;\n                if (this._dictionary.has('BE')) {\n                    var dictionary = this._dictionary.get('BE');\n                    value._intensity = dictionary.get('I');\n                    value._style = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderEffectStyle)(dictionary.get('S').name);\n                }\n                this._borderEffect = value;\n            }\n            return this._borderEffect;\n        },\n        /**\n         * Sets the border effect of the square annotation.\n         *\n         * @param {PdfBorderEffect} value Border effect.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Sets the border effect of the square annotation.\n         * annotation.borderEffect.intensity = 1;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._borderEffect = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfSquareAnnotation.prototype, \"measure\", {\n        /**\n         * Gets the flag to have measurement dictionary of the Square annotation.\n         *\n         * @returns {boolean} measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Gets the flag to have measurement dictionary of the square annotation.\n         * let measure: boolean = annotation.measure;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {\n                this._measure = this._dictionary.get('Measure');\n            }\n            return this._measure;\n        },\n        /**\n         * Sets the flag to add measurement dictionary to the annotation.\n         *\n         * @param {boolean} value Measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Sets the flag to have measurement dictionary of the square annotation.\n         * annotation.measure = true;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                if (!this._isLoaded) {\n                    this._measure = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfSquareAnnotation.prototype, \"unit\", {\n        /**\n         * Gets the measurement unit of the annotation.\n         *\n         * @returns {PdfMeasurementUnit} Measurement unit.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Gets the measurement unit of the annotation.\n         * let unit: PdfMeasurementUnit = annotation.unit;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._unit === 'undefined') {\n                this._unit = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfMeasurementUnit.centimeter;\n                if (this._dictionary.has('Contents')) {\n                    var text = this._dictionary.get('Contents');\n                    this._unitString = text.substring(text.length - 2);\n                    this._unit = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapMeasurementUnit)(this._unitString);\n                }\n            }\n            return this._unit;\n        },\n        /**\n         * Sets the measurement unit of the annotation.\n         *\n         * @param {PdfMeasurementUnit} value Measurement unit.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Sets the measurement unit of the annotation.\n         * annotation.unit = PdfMeasurementUnit.centimeter;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._measure) {\n                if (!this._isLoaded && typeof value !== 'undefined') {\n                    this._unit = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfSquareAnnotation._load = function (page, dictionary) {\n        var annot = new PdfSquareAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfSquareAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfSquareAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (this._measure) {\n            this._appearanceTemplate = this._createSquareMeasureAppearance(isFlatten);\n        }\n        else {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);\n            }\n            this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n            if (typeof this._intensity === 'undefined' &&\n                typeof this._borderEffect !== 'undefined' &&\n                this._borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                dictionary.set('I', this.borderEffect._intensity);\n                if (this.borderEffect._style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                    dictionary.set('S', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('C'));\n                }\n                this._dictionary.update('BE', dictionary);\n            }\n        }\n    };\n    PdfSquareAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                if (this._dictionary.has('Measure')) {\n                    this._appearanceTemplate = this._createSquareMeasureAppearance(isFlatten);\n                }\n                else {\n                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);\n                }\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate && isFlatten) {\n                if (!this._dictionary.has('AP')) {\n                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);\n                }\n                else {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        var reference = dictionary.getRaw('N');\n                        if (appearanceStream) {\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && !this.measure) {\n            if (this._isLoaded && !this._dictionary.has('Measure')) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n        if (!isFlatten && this._setAppearance && !this.measure) {\n            var appearance = void 0;\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference_3 = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference_3, appearance);\n                this._dictionary.update('AP', reference_3);\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    PdfSquareAnnotation.prototype._createSquareMeasureAppearance = function (_isFlatten) {\n        var borderWidth = this.border.width;\n        var font = this._obtainFont();\n        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {\n            font = this._circleCaptionFont;\n            this._pdfFont = font;\n        }\n        var area = this._calculateAreaOfSquare();\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n        var str = area.toFixed(2) + ' sq ' + this._unitString;\n        var fontsize = font.measureString(str, [0, 0], format, 0, 0);\n        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.color, borderWidth);\n        var backBrush;\n        if (this.innerColor) {\n            backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n        }\n        var nativeRectangle = [this.bounds.x,\n            (this.bounds.y + this.bounds.height),\n            this.bounds.width,\n            this.bounds.height];\n        var appearanceBounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];\n        var appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, appearanceBounds);\n        nativeRectangle[1] = nativeRectangle[1] - nativeRectangle[3];\n        appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        var template = appearance.normal;\n        var parameter = new _PaintParameter();\n        template._writeTransformation = false;\n        var graphics = appearance.normal.graphics;\n        var width = borderWidth / 2;\n        parameter.borderPen = borderPen;\n        parameter.backBrush = backBrush;\n        parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.color);\n        var rect = [nativeRectangle[0],\n            -nativeRectangle[1] - nativeRectangle[3],\n            nativeRectangle[2],\n            nativeRectangle[3]];\n        graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - borderWidth, rect[3] - borderWidth, new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.color, this.border.width));\n        graphics.save();\n        graphics.translateTransform(nativeRectangle[0], -nativeRectangle[1]);\n        var x = (nativeRectangle[2] / 2) - (fontsize[0] / 2);\n        var y = (nativeRectangle[3] / 2) - (fontsize[1] / 2);\n        graphics.translateTransform(x, -y - font._metrics._getHeight());\n        graphics.drawString((area.toFixed(2) + ' sq ' + this._unitString), font, [0, 0, 0, 0], null, parameter.foreBrush);\n        graphics.restore();\n        if ((typeof _isFlatten !== 'undefined' && !_isFlatten) || !this._isLoaded) {\n            if (this._dictionary.has('AP')) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n            }\n            var dic = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n            var tem = graphics._template._content;\n            tem.dictionary._updated = true;\n            var ref = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(ref, tem);\n            graphics._template._content.reference = ref;\n            dic.set('N', ref);\n            dic._updated = true;\n            this._dictionary.set('AP', dic);\n            var nativeRectangle1 = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];\n            var size = this._page.size;\n            nativeRectangle1[1] = size[1] - (this.bounds.y + this.bounds.height);\n            nativeRectangle1[2] = (this.bounds.x + this.bounds.width);\n            nativeRectangle1[3] = size[1] - this.bounds.y;\n            if (this._isBounds) {\n                nativeRectangle = nativeRectangle1;\n            }\n            if (this._page._isNew && this._page._pageSettings) {\n                nativeRectangle1 = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this);\n            }\n            this._dictionary.update('Rect', [nativeRectangle1[0], nativeRectangle1[1], nativeRectangle1[2], nativeRectangle1[3]]);\n            if (this._dictionary.has('Measure')) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary, this._crossReference, 'Measure');\n            }\n            var reference = this._crossReference._getNextReference();\n            var measureDictionary = this._createMeasureDictionary(this._unitString);\n            this._crossReference._cacheMap.set(reference, measureDictionary);\n            measureDictionary._updated = true;\n            this._dictionary.update('Measure', reference);\n            var ds = 'font:' +\n                font._metrics._postScriptName +\n                ' ' +\n                font._size +\n                'pt; color:' +\n                this._colorToHex(this.color);\n            this._dictionary.update('DS', ds);\n            if (this._text && this._text !== '') {\n                this._dictionary.update('Contents', this._text + ' ' + area.toFixed(2) + ' sq ' + this._unitString);\n            }\n            else {\n                this._dictionary.update('Contents', area.toFixed(2) + ' sq ' + this._unitString);\n            }\n            this._dictionary.update('Subject', ('Area Measurement'));\n            if (typeof this.subject === 'undefined') {\n                this._dictionary.update('Subject', ('Area Measurement'));\n            }\n            this._dictionary.update('MeasurementTypes', 129);\n            this._dictionary.update('Subtype', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName('Square'));\n            this._dictionary.update('IT', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName('SquareDimension'));\n            var elements = this._dictionary.getArray('Rect');\n            var vertices = new Array(elements.length * 2);\n            vertices[0] = elements[0];\n            vertices[1] = elements[3];\n            vertices[2] = elements[0];\n            vertices[3] = elements[1];\n            vertices[4] = elements[2];\n            vertices[5] = elements[1];\n            vertices[6] = elements[2];\n            vertices[7] = elements[3];\n            this._dictionary.update('Vertices', vertices);\n        }\n        return template;\n    };\n    PdfSquareAnnotation.prototype._calculateAreaOfSquare = function () {\n        var area;\n        var converter = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__._PdfUnitConvertor();\n        var value;\n        if (this.bounds.width === this.bounds.height) {\n            value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);\n            this._unitString = value.unitString;\n            var width = converter._convertUnits(this.bounds.width, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.point, value.graphicsUnit);\n            area = width * width;\n        }\n        else {\n            value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);\n            this._unitString = value.unitString;\n            var width = converter._convertUnits(this.bounds.width, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.point, value.graphicsUnit);\n            value = this._getEqualPdfGraphicsUnit(this.unit, this._unitString);\n            this._unitString = value.unitString;\n            var height = converter._convertUnits(this.bounds.height, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfGraphicsUnit.point, value.graphicsUnit);\n            area = width * height;\n        }\n        return area;\n    };\n    return PdfSquareAnnotation;\n}(PdfComment));\n\n/**\n * `PdfRectangleAnnotation` class represents the rectangle annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new square annotation with bounds\n * const annotation: PdfRectangleAnnotation = new PdfRectangleAnnotation(10, 10, 200, 100);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfRectangleAnnotation = /** @class */ (function (_super) {\n    __extends(PdfRectangleAnnotation, _super);\n    function PdfRectangleAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Square'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.rectangleAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfRectangleAnnotation.prototype, \"borderEffect\", {\n        /**\n         * Gets the border effect of the rectangle annotation.\n         *\n         * @returns {PdfBorderEffect} Border effect.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;\n         * // Gets the border effect of the rectangle annotation.\n         * let borderEffect: PdfBorderEffect = annotation.borderEffect;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._borderEffect === 'undefined') {\n                var value = new PdfBorderEffect();\n                value._dictionary = this._dictionary;\n                if (this._dictionary.has('BE')) {\n                    var dictionary = this._dictionary.get('BE');\n                    value._intensity = dictionary.get('I');\n                    value._style = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderEffectStyle)(dictionary.get('S').name);\n                }\n                this._borderEffect = value;\n            }\n            return this._borderEffect;\n        },\n        /**\n         * Sets the border effect of the rectangle annotation.\n         *\n         * @param {PdfBorderEffect} value Border effect.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRectangleAnnotation = page.annotations.at(0) as PdfRectangleAnnotation;\n         * // Sets the border effect of rectangle annotation.\n         * annotation. borderEffect.style = PdfBorderEffectStyle.cloudy;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._borderEffect = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfRectangleAnnotation._load = function (page, dictionary) {\n        var annot = new PdfRectangleAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfRectangleAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfRectangleAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dic = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dic.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dic);\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n            this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);\n        }\n        if (typeof this._intensity === 'undefined' &&\n            typeof this._borderEffect !== 'undefined' &&\n            this._borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n            var dic = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dic.set('I', this.borderEffect._intensity);\n            if (this.borderEffect._style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                dic.set('S', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('C'));\n            }\n            this._dictionary.update('BE', dic);\n        }\n    };\n    PdfRectangleAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate && isFlatten) {\n                if (!this._dictionary.has('AP')) {\n                    this._appearanceTemplate = this._createRectangleAppearance(this.borderEffect);\n                }\n                else {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        var reference = dictionary.getRaw('N');\n                        if (appearanceStream) {\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            if (isNormalMatrix && this._page && this._page.rotation !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0 ||\n                this._isValidTemplateMatrix(this._appearanceTemplate._content.dictionary, this.bounds, this._appearanceTemplate)) {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n        if (!isFlatten && this._setAppearance) {\n            var appearance = void 0;\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference_4 = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference_4, appearance);\n                this._dictionary.update('AP', reference_4);\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    PdfRectangleAnnotation.prototype._isValidTemplateMatrix = function (dictionary, bounds, appearanceTemplate) {\n        var isValidMatrix = true;\n        var pointF = bounds;\n        if (dictionary && dictionary.has('Matrix')) {\n            var box = dictionary.getArray('BBox');\n            var matrix = dictionary.getArray('Matrix');\n            if (matrix && box && matrix.length > 3 && box.length > 2) {\n                if (typeof matrix[0] !== 'undefined' &&\n                    typeof matrix[1] !== 'undefined' &&\n                    typeof matrix[2] !== 'undefined' &&\n                    typeof matrix[3] !== 'undefined') {\n                    if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {\n                        if (typeof box[0] !== 'undefined' &&\n                            typeof box[1] !== 'undefined' &&\n                            typeof box[2] !== 'undefined' &&\n                            typeof box[3] !== 'undefined') {\n                            if (Math.round(box[0]) !== Math.round(-(matrix[4])) && Math.round(box[1]) !== Math.round(-(matrix[5])) ||\n                                box[0] === 0 && Math.round(-(matrix[4])) === 0) {\n                                var graphics = this._page.graphics;\n                                var state = graphics.save();\n                                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                                    graphics.setTransparency(this._opacity);\n                                }\n                                pointF.x -= box[0];\n                                pointF.y += box[1];\n                                graphics.drawTemplate(appearanceTemplate, pointF);\n                                graphics.restore(state);\n                                this._page.annotations.remove(this);\n                                isValidMatrix = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return isValidMatrix;\n    };\n    return PdfRectangleAnnotation;\n}(PdfComment));\n\n/**\n * `PdfPolygonAnnotation` class represents the polygon annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new polygon annotation with bounds\n * const annotation: PdfPolygonAnnotation = new PdfPolygonAnnotation([100, 300, 150, 200, 300, 200, 350, 300, 300, 400, 150, 400]);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPolygonAnnotation = /** @class */ (function (_super) {\n    __extends(PdfPolygonAnnotation, _super);\n    function PdfPolygonAnnotation(points) {\n        var _this = _super.call(this) || this;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Polygon'));\n        if (typeof points !== 'undefined') {\n            _this._points = points;\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.polygonAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfPolygonAnnotation.prototype, \"borderEffect\", {\n        /**\n         * Gets the border effect of the polygon annotation.\n         *\n         * @returns {PdfBorderEffect} Border effect.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;\n         * // Gets the border effect of the polygon annotation.\n         * let borderEffect: PdfBorderEffect = annotation.borderEffect;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._borderEffect === 'undefined') {\n                var value = new PdfBorderEffect();\n                value._dictionary = this._dictionary;\n                if (this._dictionary.has('BE')) {\n                    var dictionary = this._dictionary.get('BE');\n                    value._intensity = dictionary.get('I');\n                    value._style = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderEffectStyle)(dictionary.get('S').name);\n                }\n                this._borderEffect = value;\n            }\n            return this._borderEffect;\n        },\n        /**\n         * Sets the border effect of the polygon annotation.\n         *\n         * @param {PdfBorderEffect} value Border effect.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;\n         * // Sets the border effect of the polygon annotation\n         * annotation.borderEffect.style = PdfBorderEffectStyle.cloudy ;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._borderEffect = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPolygonAnnotation.prototype, \"lineExtension\", {\n        /**\n         * Gets the line extension of the polygon annotation.\n         *\n         * @returns {number} Line extension.\n         *  ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;\n         * // Gets the line extension of the polygon annotation\n         * let lineExtension: number = annotation.lineExtension;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._lineExtension === 'undefined' && this._dictionary.has('LLE')) {\n                var lineExt = this._dictionary.get('LLE');\n                if (typeof lineExt !== 'undefined' && lineExt >= 0) {\n                    this._lineExtension = lineExt;\n                }\n            }\n            return this._lineExtension;\n        },\n        /**\n         * Sets the line extension of the polygon annotation.\n         *\n         * @param {number} value Line extension.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolygonAnnotation = page.annotations.at(0) as PdfPolygonAnnotation;\n         * // Sets the line extension of the polygon annotation\n         * annotation.lineExtension = 5;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!Number.isNaN(value)) {\n                if (value >= 0) {\n                    this._dictionary.update('LLE', value);\n                    this._lineExtension = value;\n                }\n                else {\n                    throw new Error('LineExtension should be non negative number');\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    //Implementation\n    PdfPolygonAnnotation._load = function (page, dictionary) {\n        var annot = new PdfPolygonAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfPolygonAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfPolygonAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this._points === 'undefined' || this._points === null) {\n            throw new Error('Points cannot be null or undefined');\n        }\n        if (!this._dictionary.has('LLE')) {\n            this.lineExtension = 0;\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dic = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dic.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dic);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        var array = [];\n        for (var i = 0; i < this._points.length; i++) {\n            var value = this._points[Number.parseInt(i.toString(), 10)];\n            array.push(value);\n        }\n        this._points = this._getPoints(this._points);\n        if (array[0] !== array[array.length - 2] || array[1] !== array[array.length - 1]) {\n            this._points.push(this._points[0]);\n            this._points.push(this._points[1]);\n        }\n        var polygonBounds = this._getBoundsValue(this._points);\n        var bounds = [polygonBounds.x,\n            polygonBounds.y,\n            polygonBounds.x + polygonBounds.width,\n            polygonBounds.y + polygonBounds.height];\n        this._dictionary.update('Rect', bounds);\n        this._dictionary.update('LLE', this._lineExtension);\n        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n            this._appearanceTemplate = this._createPolygonAppearance(isFlatten);\n        }\n        this._dictionary.update('Vertices', this._points);\n        if (typeof this._intensity === 'undefined' &&\n            typeof this._borderEffect !== 'undefined' &&\n            this._borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n            var dic = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dic.set('I', this.borderEffect._intensity);\n            if (this.borderEffect._style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                dic.set('S', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('C'));\n            }\n            this._dictionary.update('BE', dic);\n        }\n    };\n    PdfPolygonAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        this._flatten = isFlatten;\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createPolygonAppearance(isFlatten);\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate && isFlatten) {\n                if (this._dictionary.has('AP')) {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        var reference = dictionary.getRaw('N');\n                        if (appearanceStream) {\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n        }\n        if (isFlatten) {\n            if (this._appearanceTemplate) {\n                var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {\n                    var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                    if (box && box.length >= 2) {\n                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                    }\n                }\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n            else {\n                this._page.annotations.remove(this);\n            }\n        }\n        if (!isFlatten && this._setAppearance) {\n            var appearance = void 0;\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference_5 = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference_5, appearance);\n                this._dictionary.update('AP', reference_5);\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    PdfPolygonAnnotation.prototype._createPolygonAppearance = function (flatten) {\n        if (typeof flatten !== 'undefined' && flatten) {\n            var borderPen = void 0;\n            if (this.color && this.border.width > 0) {\n                borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.color, this.border.width);\n            }\n            var backgroundBrush = void 0;\n            if (this.innerColor) {\n                backgroundBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.innerColor);\n            }\n            var graphics = this._page.graphics;\n            if (borderPen || backgroundBrush) {\n                var state = void 0;\n                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                    state = graphics.save();\n                    graphics.setTransparency(this._opacity);\n                }\n                if (this.borderEffect.intensity !== 0 && this.borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                    var radius = this.borderEffect.intensity * 4 + 0.5 * this.border.width;\n                    var graphicsPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                    graphicsPath.addPolygon(this._getLinePoints());\n                    this._drawCloudStyle(graphics, backgroundBrush, borderPen, radius, 0.833, graphicsPath._points, false);\n                }\n                else {\n                    graphics.drawPolygon(this._getLinePoints(), borderPen, backgroundBrush);\n                }\n                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                    graphics.restore(state);\n                }\n            }\n            return graphics._template;\n        }\n        else {\n            var boundsValue = void 0;\n            var rect = { x: 0, y: 0, width: 0, height: 0 };\n            if (typeof this._points === 'undefined' && this._dictionary.has('Vertices')) {\n                this._points = this._dictionary.get('Vertices');\n                boundsValue = this._getBoundsValue(this._points);\n            }\n            else {\n                boundsValue = this._getBoundsValue(this._points);\n            }\n            if (typeof this._borderEffect !== 'undefined' &&\n                typeof this.borderEffect.intensity !== 'undefined' && this.borderEffect.intensity !== 0 &&\n                this._borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                rect.x = boundsValue.x - (this.borderEffect.intensity * 5) - this.border.width;\n                rect.y = boundsValue.y - (this.borderEffect.intensity * 5) - this.border.width;\n                rect.width = boundsValue.width + (this.borderEffect.intensity * 10) + (2 * this.border.width);\n                rect.height = boundsValue.height + (this.borderEffect.intensity * 10) + (2 * this.border.width);\n            }\n            else {\n                rect.x = boundsValue.x - this.border.width;\n                rect.y = boundsValue.y - this.border.width;\n                rect.width = boundsValue.width + (2 * this.border.width);\n                rect.height = boundsValue.height + (2 * this.border.width);\n            }\n            var appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, [rect.x, rect.y, rect.width, rect.height]);\n            appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate([rect.x, rect.y, rect.width, rect.height], this._crossReference);\n            var template = appearance.normal;\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n            template._writeTransformation = false;\n            var graphics = appearance.normal.graphics;\n            var parameter = new _PaintParameter();\n            if (this.innerColor) {\n                parameter.backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n            }\n            if (this.border.width > 0 && this.color) {\n                parameter.borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this._color, this.border.width);\n            }\n            if (this.color) {\n                parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._color);\n            }\n            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                graphics.save();\n                graphics.setTransparency(this._opacity);\n            }\n            else {\n                graphics.save();\n            }\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(this.borderEffect) && (0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(this.borderEffect.intensity) &&\n                this.borderEffect.intensity !== 0 && this.borderEffect.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n                var radius = this.borderEffect.intensity * 4 + 0.5 * this.border.width;\n                var graphicsPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                graphicsPath.addPolygon(this._getLinePoints());\n                this._drawCloudStyle(graphics, parameter.backBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, false);\n            }\n            else {\n                graphics.drawPolygon(this._getLinePoints(), parameter.borderPen, parameter.backBrush);\n            }\n            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                graphics.restore();\n            }\n            graphics.restore();\n            if (this._isBounds) {\n                template._content.dictionary._updated = true;\n                this._dictionary.update('LLE', this.lineExtension);\n                this._dictionary.update('Vertices', this._points);\n            }\n            this._dictionary.update('Rect', [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height]);\n            return template;\n        }\n    };\n    PdfPolygonAnnotation.prototype._getLinePoints = function () {\n        var polygonPoints;\n        var pageSize = this._page.size;\n        var pageHeight = pageSize[1];\n        var pageWidth = pageSize[0];\n        if (this._dictionary.has('Vertices') && !this._isBounds) {\n            var rotation = void 0;\n            if (this._page._pageDictionary.has('Rotate')) {\n                rotation = this._page._pageDictionary.get('Rotate');\n            }\n            if (this._page && this._page.rotation) {\n                if (this._page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90) {\n                    rotation = 90;\n                }\n                else if (this._page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180) {\n                    rotation = 180;\n                }\n                else if (this._page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270) {\n                    rotation = 270;\n                }\n            }\n            var linePoints = this._dictionary.getArray('Vertices');\n            if (linePoints) {\n                var points_1 = [];\n                linePoints.forEach(function (value) {\n                    points_1.push(value);\n                });\n                polygonPoints = [];\n                for (var j = 0; j < points_1.length; j = j + 2) {\n                    if (this.flatten) {\n                        polygonPoints.push([points_1[Number.parseInt(j.toString(), 10)], (pageHeight - points_1[j + 1])]);\n                    }\n                    else {\n                        polygonPoints.push([points_1[Number.parseInt(j.toString(), 10)], -points_1[j + 1]]);\n                    }\n                }\n                if (rotation) {\n                    if (rotation === 270) {\n                        for (var k = 0; k < polygonPoints.length; k++) {\n                            var x = polygonPoints[Number.parseInt(k.toString(), 10)][0];\n                            polygonPoints[Number.parseInt(k.toString(), 10)][0] = polygonPoints[Number.parseInt(k.toString(), 10)][1];\n                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = pageWidth - x;\n                        }\n                    }\n                    else if (rotation === 90) {\n                        for (var k = 0; k < polygonPoints.length; k++) {\n                            var x = polygonPoints[Number.parseInt(k.toString(), 10)][0];\n                            if (this._page._origin[1] !== 0) {\n                                polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageHeight -\n                                    (polygonPoints[Number.parseInt(k.toString(), 10)][1] - pageHeight);\n                            }\n                            else {\n                                polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageHeight -\n                                    polygonPoints[Number.parseInt(k.toString(), 10)][1];\n                            }\n                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = x;\n                        }\n                    }\n                    else if (rotation === 180) {\n                        for (var k = 0; k < polygonPoints.length; k++) {\n                            var x = polygonPoints[Number.parseInt(k.toString(), 10)][0];\n                            polygonPoints[Number.parseInt(k.toString(), 10)][0] = pageWidth - x;\n                            polygonPoints[Number.parseInt(k.toString(), 10)][1] = pageHeight -\n                                polygonPoints[Number.parseInt(k.toString(), 10)][1];\n                        }\n                    }\n                }\n            }\n        }\n        else if (this._points) {\n            var points_2 = [];\n            this._points.forEach(function (value) {\n                points_2.push(value);\n            });\n            polygonPoints = [];\n            for (var j = 0; j < this._points.length; j = j + 2) {\n                if (this.flatten) {\n                    polygonPoints.push([points_2[Number.parseInt(j.toString(), 10)], (pageHeight - points_2[j + 1])]);\n                }\n                else {\n                    polygonPoints.push([points_2[Number.parseInt(j.toString(), 10)], -points_2[j + 1]]);\n                }\n            }\n        }\n        return polygonPoints;\n    };\n    return PdfPolygonAnnotation;\n}(PdfComment));\n\n/**\n * `PdfPolyLineAnnotation` class represents the polyline annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new poly line annotation with bounds\n * const annotation: PdfPolyLineAnnotation = new PdfPolyLineAnnotation ([100, 300, 150, 200, 300, 200, 350, 300, 300, 400, 150, 400]);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPolyLineAnnotation = /** @class */ (function (_super) {\n    __extends(PdfPolyLineAnnotation, _super);\n    function PdfPolyLineAnnotation(points) {\n        var _this = _super.call(this) || this;\n        _this._beginLine = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.none;\n        _this._endLine = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.none;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('PolyLine'));\n        if (typeof points !== 'undefined') {\n            _this._points = points;\n        }\n        else {\n            _this._points = [];\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.polyLineAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfPolyLineAnnotation.prototype, \"beginLineStyle\", {\n        /**\n         * Gets the begin line ending style of the annotation.\n         *\n         * @returns {PdfLineEndingStyle} Begin line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;\n         * // Gets the begin line ending style of the annotation.\n         * let beginLineStyle: PdfLineEndingStyle = annotation.beginLineStyle;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('LE')) {\n                var lineStyles = this._dictionary.getArray('LE');\n                if (lineStyles && Array.isArray(lineStyles)) {\n                    this._beginLine = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapLineEndingStyle)(lineStyles[0].name);\n                }\n            }\n            return this._beginLine;\n        },\n        /**\n         * Sets the begin line ending style of the annotation.\n         *\n         * @param {PdfLineEndingStyle} value Begin line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;\n         * // Sets the begin line ending style of the annotation.\n         * annotation.beginLineStyle = PdfLineEndingStyle.slash;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._beginLine) {\n                this._beginLine = value;\n                if (this._dictionary) {\n                    var lineStyle = [];\n                    lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(value)));\n                    lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.endLineStyle)));\n                    this._dictionary.update('LE', lineStyle);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPolyLineAnnotation.prototype, \"endLineStyle\", {\n        /**\n         * Gets the end line ending style of the annotation.\n         *\n         * @returns {PdfLineEndingStyle} End line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;\n         * // Gets the end line ending style of the annotation.\n         * let endLineStyle: PdfLineEndingStyle = annotation.endLineStyle;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('LE')) {\n                var lineStyles = this._dictionary.getArray('LE');\n                if (lineStyles && Array.isArray(lineStyles)) {\n                    this._endLine = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapLineEndingStyle)(lineStyles[1].name);\n                }\n            }\n            return this._endLine;\n        },\n        /**\n         * Sets the end line ending style of the annotation.\n         *\n         * @param {PdfLineEndingStyle} value End line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;\n         * // Sets the end line ending style of the annotation.\n         * annotation.endLineStyle = PdfLineEndingStyle.square;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._endLine) {\n                this._endLine = value;\n                if (this._dictionary) {\n                    var lineStyle = [];\n                    lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.beginLineStyle)));\n                    lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(value)));\n                    this._dictionary.update('LE', lineStyle);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPolyLineAnnotation.prototype, \"lineExtension\", {\n        /**\n         * Gets the line extension of the square annotation.\n         *\n         * @returns {number} Line extension.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;\n         * // Gets the line extension of annotation.\n         * let lineExtension: number = annotation.lineExtension;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._lineExtension === 'undefined' && this._dictionary.has('LLE')) {\n                var lineExt = this._dictionary.get('LLE');\n                if (typeof lineExt !== 'undefined' && lineExt >= 0) {\n                    this._lineExtension = lineExt;\n                }\n            }\n            return this._lineExtension;\n        },\n        /**\n         * Sets the line extension of the square annotation.\n         *\n         * @param {number} value Line extension.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPolyLineAnnotation = page.annotations.at(0) as PdfPolyLineAnnotation;\n         * // Sets the line extension of the annotation.\n         * annotation.lineExtension = 3;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!Number.isNaN(value)) {\n                if (value >= 0) {\n                    this._dictionary.update('LLE', value);\n                    this._lineExtension = value;\n                }\n                else {\n                    throw new Error('LineExtension should be non negative number');\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfPolyLineAnnotation._load = function (page, dictionary) {\n        var annot = new PdfPolyLineAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfPolyLineAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfPolyLineAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this._points === 'undefined' || this._points === null) {\n            throw new Error('Points cannot be null or undefined');\n        }\n        if (!this._dictionary.has('LLE')) {\n            this.lineExtension = 0;\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        var points = this._getLinePoints();\n        var pathTypes = [];\n        pathTypes.push(0);\n        for (var i = 1; i < points.length; i++) {\n            pathTypes.push(1);\n        }\n        this._polylinePoints = points;\n        this._pathTypes = pathTypes;\n        var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        path._points = points;\n        path._pathTypes = pathTypes;\n        this._dictionary.update('Vertices', this._points);\n        var lineStyle = [];\n        lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.beginLineStyle)));\n        lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.endLineStyle)));\n        this._dictionary.update('LE', lineStyle);\n        this._dictionary.update('LLE', this._lineExtension);\n        var polyLineBounds = this._getBoundsValue(this._points);\n        var rectangle = [polyLineBounds.x,\n            polyLineBounds.y,\n            polyLineBounds.x + polyLineBounds.width,\n            polyLineBounds.y + polyLineBounds.height];\n        this._dictionary.update('Rect', rectangle);\n        if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n            this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);\n        }\n    };\n    PdfPolyLineAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        this._flatten = isFlatten;\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate && isFlatten) {\n                if (!this._dictionary.has('AP')) {\n                    this._appearanceTemplate = this._createPolyLineAppearance(isFlatten);\n                }\n                else {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        var reference = dictionary.getRaw('N');\n                        if (appearanceStream) {\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n        }\n        if (isFlatten) {\n            if (this._appearanceTemplate) {\n                var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {\n                    var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                    if (box) {\n                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                    }\n                }\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n            else {\n                this._page.annotations.remove(this);\n            }\n        }\n        if (!isFlatten && this._setAppearance) {\n            var appearance = void 0;\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference_6 = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference_6, appearance);\n                this._dictionary.update('AP', reference_6);\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    PdfPolyLineAnnotation.prototype._createPolyLineAppearance = function (flatten) {\n        var color = this.color ? this.color : [0, 0, 0];\n        if (typeof flatten !== 'undefined' && flatten) {\n            var borderPen = void 0;\n            if (this.border.width > 0) {\n                borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(color, this.border.width);\n            }\n            var graphics = this._page.graphics;\n            if (borderPen) {\n                var state = void 0;\n                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                    state = graphics.save();\n                    graphics.setTransparency(this._opacity);\n                }\n                var points = this._getLinePoints();\n                var pathTypes = [];\n                pathTypes.push(0);\n                if (points && points.length > 0) {\n                    for (var i = 1; i < points.length; i++) {\n                        pathTypes.push(1);\n                    }\n                    var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                    path._points = points;\n                    path._pathTypes = pathTypes;\n                    graphics.drawPath(path, borderPen);\n                    if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                        graphics.restore(state);\n                    }\n                }\n            }\n            return graphics._template;\n        }\n        else {\n            var boundsValue = void 0;\n            var rect = { x: 0, y: 0, width: 0, height: 0 };\n            if (typeof this._points === 'undefined' && this._dictionary.has('Vertices')) {\n                this._points = this._dictionary.get('Vertices');\n                boundsValue = this._getBoundsValue(this._points);\n            }\n            else {\n                boundsValue = this._getBoundsValue(this._points);\n            }\n            rect.x = boundsValue.x - this.border.width;\n            rect.y = boundsValue.y - this.border.width;\n            rect.width = boundsValue.width + (2 * this.border.width);\n            rect.height = boundsValue.height + (2 * this.border.width);\n            var appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, [rect.x, rect.y, rect.width, rect.height]);\n            appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate([rect.x, rect.y, rect.width, rect.height], this._crossReference);\n            var template = appearance.normal;\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n            template._writeTransformation = false;\n            var graphics = appearance.normal.graphics;\n            var parameter = new _PaintParameter();\n            if (this.innerColor) {\n                parameter.backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n            }\n            if (this.border.width > 0 && color) {\n                parameter.borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(color, this.border.width);\n            }\n            if (color) {\n                parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(color);\n            }\n            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                graphics.save();\n                graphics.setTransparency(this._opacity);\n            }\n            else {\n                graphics.save();\n            }\n            var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            if (typeof this._polylinePoints !== 'undefined' && this._polylinePoints !== null) {\n                path._points = this._polylinePoints;\n            }\n            else {\n                path._points = this._getLinePoints();\n            }\n            if (typeof this._pathTypes !== 'undefined' && this._polylinePoints !== null) {\n                path._pathTypes = this._pathTypes;\n            }\n            else {\n                this._pathTypes = [];\n                this._pathTypes.push(0);\n                for (var i = 1; i < path._points.length; i++) {\n                    this._pathTypes.push(1);\n                }\n                path._pathTypes = this._pathTypes;\n            }\n            graphics.drawPath(path, parameter.borderPen, parameter.backBrush);\n            if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                graphics.restore();\n            }\n            graphics.restore();\n            if (this._isBounds) {\n                template._content.dictionary._updated = true;\n                var lineStyle = [];\n                lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.beginLineStyle)));\n                lineStyle.push(_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this.endLineStyle)));\n                this._dictionary.update('LE', lineStyle);\n                this._dictionary.update('LLE', this.lineExtension);\n                this._dictionary.update('Vertices', this._points);\n            }\n            this._dictionary.update('Rect', [rect.x, rect.y, rect.x + rect.width, rect.y + rect.height]);\n            return template;\n        }\n    };\n    PdfPolyLineAnnotation.prototype._getLinePoints = function () {\n        var pageSize = this._page.size;\n        var pageHeight = pageSize[1];\n        var points;\n        if (this._dictionary.has('Vertices') && !this._isBounds && (!this._setAppearance || (this._setAppearance && this.flatten))) {\n            var linePoints = this._dictionary.getArray('Vertices');\n            if (linePoints) {\n                points = [];\n                for (var j = 0; j < linePoints.length; j = j + 2) {\n                    points.push([linePoints[Number.parseInt(j.toString(), 10)], (pageHeight - linePoints[j + 1])]);\n                }\n            }\n        }\n        else if (this._points) {\n            this._points = this._getPoints(this._points);\n            var polyLinepoints_1 = [];\n            this._points.forEach(function (value) {\n                polyLinepoints_1.push(value);\n            });\n            points = [];\n            for (var j = 0; j < polyLinepoints_1.length; j = j + 2) {\n                if (this.flatten) {\n                    points.push([polyLinepoints_1[Number.parseInt(j.toString(), 10)], (pageHeight - polyLinepoints_1[j + 1])]);\n                }\n                else {\n                    points.push([polyLinepoints_1[Number.parseInt(j.toString(), 10)], -polyLinepoints_1[j + 1]]);\n                }\n            }\n        }\n        return points;\n    };\n    return PdfPolyLineAnnotation;\n}(PdfComment));\n\n/**\n * `PdfAngleMeasurementAnnotation` class represents the angle measurement annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new angle measurement annotation\n * const annotation: PdfAngleMeasurementAnnotation = new PdfAngleMeasurementAnnotation([[100, 700], [150, 650], [100, 600]]);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAngleMeasurementAnnotation = /** @class */ (function (_super) {\n    __extends(PdfAngleMeasurementAnnotation, _super);\n    function PdfAngleMeasurementAnnotation(points) {\n        var _this = _super.call(this) || this;\n        _this._linePoints = [];\n        _this._firstIntersectionPoint = [0, 0];\n        _this._secondIntersectionPoint = [0, 0];\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('PolyLine'));\n        if (typeof points !== 'undefined' && points.length > 0) {\n            if (points.length > 6) {\n                throw new Error('Points length should not be greater than 3');\n            }\n            _this._pointArray = points;\n            for (var i = 0; i < points.length; i++) {\n                _this._linePoints.push(points[Number.parseInt(i.toString(), 10)][0]);\n                _this._linePoints.push(points[Number.parseInt(i.toString(), 10)][1]);\n            }\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.angleMeasurementAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfAngleMeasurementAnnotation.prototype, \"measure\", {\n        /**\n         * Gets the flag to have measurement dictionary of the angle measurement annotation.\n         *\n         * @returns {boolean} measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfAngleMeasurementAnnotation = page.annotations.at(0) as PdfAngleMeasurementAnnotation;\n         * // Gets the flag to have measurement dictionary of the angle annotation.\n         * let measure: boolean = annotation.measure;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._measure === 'undefined' && this._dictionary.has('Measure')) {\n                this._measure = this._dictionary.get('Measure');\n            }\n            return this._measure;\n        },\n        /**\n         * Sets the flag to add measurement dictionary to the annotation.\n         *\n         * @param {boolean} value Measure.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfAngleMeasurementAnnotation = page.annotations.at(0) as PdfAngleMeasurementAnnotation;\n         * // Sets the flag to add measurement dictionary to the annotation.\n         * annotation.measure = true;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value && !this._isLoaded) {\n                this._measure = value;\n                this.caption.cap = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfAngleMeasurementAnnotation._load = function (page, dictionary) {\n        var annot = new PdfAngleMeasurementAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfAngleMeasurementAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfAngleMeasurementAnnotation.prototype._postProcess = function () {\n        if (!this._pointArray) {\n            throw new Error('Points cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        this._appearanceTemplate = this._createAngleMeasureAppearance();\n    };\n    PdfAngleMeasurementAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (!isFlatten && this._setAppearance) {\n                this._appearanceTemplate = this._createAngleMeasureAppearance();\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess();\n            if (!this._appearanceTemplate) {\n                if (isFlatten) {\n                    if (!this._dictionary.has('AP')) {\n                        this._appearanceTemplate = this._createAngleMeasureAppearance();\n                    }\n                    else {\n                        var dictionary = this._dictionary.get('AP');\n                        if (dictionary && dictionary.has('N')) {\n                            var appearanceStream = dictionary.get('N');\n                            var reference = dictionary.getRaw('N');\n                            if (appearanceStream) {\n                                if (reference) {\n                                    appearanceStream.reference = reference;\n                                }\n                                this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {\n                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                if (box) {\n                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                }\n            }\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n    };\n    PdfAngleMeasurementAnnotation.prototype._createAngleMeasureAppearance = function () {\n        var borderWidth = this.border.width;\n        var font = this._obtainFont();\n        if ((typeof font === 'undefined' || font === null) || (!this._isLoaded && font.size === 1)) {\n            font = this._circleCaptionFont;\n            this._pdfFont = font;\n        }\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n        var angle = (this._calculateAngle() * (180.0 / Math.PI));\n        if (angle < 0) {\n            angle = -angle;\n        }\n        if (angle > 180) {\n            angle = 360 - angle;\n        }\n        this._dictionary.update('Vertices', this._linePoints);\n        var ds = 'font:' +\n            font._metrics._postScriptName +\n            ' ' +\n            font._size +\n            'pt; color:' +\n            this._colorToHex(this.color);\n        this._dictionary.update('DS', ds);\n        if (this.text === (' ' + angle.toFixed(2) + '°')) {\n            this._dictionary.update('Contents', this.text);\n        }\n        else if (this.text) {\n            this._dictionary.update('Contents', this.text);\n        }\n        if (typeof this.subject === 'undefined') {\n            this._dictionary.update('Subject', 'Angle Measurement');\n        }\n        this._dictionary.update('MeasurementTypes', 1152);\n        this._dictionary.update('Subtype', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName('PolyLine'));\n        this._dictionary.update('IT', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName('PolyLineAngle'));\n        var measureDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        var d = [];\n        var t = [];\n        var a = [];\n        var x = [];\n        var v = [];\n        measureDictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('measureDictionary'));\n        measureDictionary.set('R', '1 in = 1 in');\n        measureDictionary.set('Subtype', 'RL');\n        measureDictionary.set('TargetUnitConversion', 0.1388889);\n        var dDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        dDictionary.set('U', 'in');\n        dDictionary.set('Type', 'NumberFormat');\n        dDictionary.set('C', 1);\n        dDictionary.set('D', 1);\n        dDictionary.set('SS', '');\n        d.push(dDictionary);\n        var tDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        tDictionary.set('U', '°');\n        tDictionary.set('Type', 'NumberFormat');\n        tDictionary.set('C', 1);\n        tDictionary.set('D', 1);\n        tDictionary.set('FD', true);\n        tDictionary.set('SS', '');\n        t.push(tDictionary);\n        var aDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        aDictionary.set('U', 'sq in');\n        aDictionary.set('Type', 'NumberFormat');\n        aDictionary.set('C', 1);\n        aDictionary.set('D', 1);\n        aDictionary.set('FD', true);\n        aDictionary.set('SS', '');\n        a.push(aDictionary);\n        var vDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        vDictionary.set('U', 'cu in');\n        vDictionary.set('Type', 'NumberFormat');\n        vDictionary.set('C', 1);\n        vDictionary.set('D', 1);\n        vDictionary.set('FD', true);\n        vDictionary.set('SS', '');\n        v.push(vDictionary);\n        var xDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        xDictionary.set('U', 'in');\n        xDictionary.set('Type', 'NumberFormat');\n        xDictionary.set('C', 1);\n        xDictionary.set('D', 1);\n        xDictionary.set('SS', '');\n        x.push(xDictionary);\n        measureDictionary.set('D', d);\n        measureDictionary.set('T', t);\n        measureDictionary.set('A', a);\n        measureDictionary.set('X', x);\n        measureDictionary.set('V', v);\n        if (this._dictionary.has('Measure')) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary, this._crossReference, 'Measure');\n        }\n        var reference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(reference, measureDictionary);\n        measureDictionary._updated = true;\n        this._dictionary.update('Measure', reference);\n        var rectValue = [0, 0, 0, 0];\n        var boundsValue = this._getAngleBoundsValue();\n        var points = this._obtainLinePoints();\n        var pathTypes = [];\n        pathTypes.push(0);\n        for (var i = 1; i < points.length; i++) {\n            pathTypes.push(1);\n        }\n        var graphicspath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        graphicspath.addRectangle(points[1][0] - this._radius, -(points[1][1] + this._radius), 2 * this._radius, 2 * this._radius);\n        var size = font.measureString(angle.toString() + '°', [0, 0], format, 0, 0);\n        var midPoint = [(this._firstIntersectionPoint[0] + this._secondIntersectionPoint[0]) / 2,\n            ((this._firstIntersectionPoint[1] + this._secondIntersectionPoint[1]) / 2)];\n        var center = [points[1][0], -points[1][1]];\n        var x1 = points[1][0] + this._radius * Math.cos((this._startAngle + (this._sweepAngle / 2)) * (Math.PI / 180.0));\n        var y = points[1][1] + this._radius * Math.sin((this._startAngle + (this._sweepAngle / 2)) * (Math.PI / 180.0));\n        var start = [midPoint[0], midPoint[1]];\n        var xDiff = start[0] - center[0];\n        var yDiff = start[1] - center[1];\n        var midpointAngle = ((Math.atan2(yDiff, xDiff)) * (180.0 / Math.PI));\n        var left = false;\n        var right = false;\n        var up = false;\n        var down = false;\n        if (midpointAngle > 0) {\n            if (midpointAngle < 45) {\n                right = true;\n            }\n            else if (midpointAngle >= 45 && midpointAngle < 135) {\n                up = true;\n            }\n            else {\n                left = true;\n            }\n        }\n        else {\n            midpointAngle = -midpointAngle;\n            if (midpointAngle === 0) {\n                (new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath()).addRectangle(boundsValue[0], boundsValue[1], boundsValue[2], boundsValue[3]);\n            }\n            else if (midpointAngle < 45) {\n                right = true;\n            }\n            else if (midpointAngle >= 45 && midpointAngle < 135) {\n                down = true;\n            }\n            else {\n                left = true;\n            }\n        }\n        if (rectValue[0] === 0 && rectValue[1] === 0 && rectValue[2] === 0 && rectValue[3] === 0) {\n            rectValue = boundsValue;\n            this.bounds = { x: boundsValue[0], y: boundsValue[1], width: boundsValue[2], height: boundsValue[3] };\n        }\n        var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        path._pathTypes = pathTypes;\n        path._points = points;\n        this._dictionary.set('Rect', [rectValue[0], rectValue[1], rectValue[0] + rectValue[2], rectValue[1] + rectValue[3]]);\n        var appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, boundsValue);\n        appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(rectValue, this._crossReference);\n        var template = appearance.normal;\n        template._writeTransformation = false;\n        var graphics = appearance.normal.graphics;\n        var width = borderWidth / 2;\n        var pen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this._color, width);\n        if (this.border.style === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.dashed) {\n            pen._dashStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDashStyle.dash;\n        }\n        var brush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._color);\n        graphics.save();\n        graphics.drawPath(path, pen);\n        path.addArc(points[1][0] - this._radius, points[1][1] - this._radius, 2 * this._radius, 2 * this._radius, this._startAngle, this._sweepAngle);\n        if (up) {\n            graphics.drawString(angle.toString() + '°', font, [x1 - (size[0] / 2), -(-y + font._metrics._getHeight() + 2), 0, 0], null, brush);\n        }\n        else if (right) {\n            graphics.drawString(angle.toString() + '°', font, [x1 + 2, -(-y + font._metrics._getHeight() / 2), 0, 0], null, brush);\n        }\n        else if (left) {\n            graphics.drawString(angle.toString() + '°', font, [x1 - size[0] - 2, -(-y + font._metrics._getHeight() / 2), 0, 0], null, brush);\n        }\n        else if (down) {\n            graphics.drawString(angle.toString() + '°', font, [x1 - (size[0] / 2), (y + 2), 0, 0], null, brush);\n        }\n        graphics.restore();\n        graphics._template._content.dictionary._updated = true;\n        var reference1 = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(reference1, graphics._template._content);\n        graphics._template._content.reference = reference1;\n        if (this._dictionary.has('AP')) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n        }\n        var appearanceDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        appearanceDictionary.set('N', reference1);\n        appearanceDictionary._updated = true;\n        this._dictionary.set('AP', appearanceDictionary);\n        return template;\n    };\n    PdfAngleMeasurementAnnotation.prototype._getAngleBoundsValue = function () {\n        var points = this._obtainLinePoints();\n        for (var i = 0; i < points.length; i++) {\n            points[Number.parseInt(i.toString(), 10)][1] = -points[Number.parseInt(i.toString(), 10)][1];\n        }\n        var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        path._points = points;\n        path._pathTypes = [0, 1, 1];\n        return path._getBounds();\n    };\n    PdfAngleMeasurementAnnotation.prototype._obtainLinePoints = function () {\n        var points;\n        var collection;\n        if (this._linePoints) {\n            points = new Array(this._linePoints.length);\n            for (var i = 0; i < this._linePoints.length; i++) {\n                points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];\n            }\n            collection = new Array(points.length / 2);\n            var count = 0;\n            for (var j = 0; j < points.length; j = j + 2) {\n                collection[Number.parseInt(count.toString(), 10)] = [points[Number.parseInt(j.toString(), 10)], -points[j + 1]];\n                count++;\n            }\n        }\n        return collection;\n    };\n    PdfAngleMeasurementAnnotation.prototype._calculateAngle = function () {\n        var points = [0, 0];\n        if (typeof this._linePoints !== 'undefined' && this._linePoints.length === 0 && this._isLoaded) {\n            if (this._dictionary.has('Vertices')) {\n                this._linePoints = this._dictionary.get('Vertices');\n            }\n        }\n        for (var i = 0; i < this._linePoints.length; i++) {\n            points[Number.parseInt(i.toString(), 10)] = this._linePoints[Number.parseInt(i.toString(), 10)];\n        }\n        var collection = [];\n        for (var j = 0; j < points.length; j = j + 2) {\n            collection.push([points[Number.parseInt(j.toString(), 10)], points[j + 1]]);\n        }\n        var point1 = collection[0];\n        var point2 = collection[1];\n        var point3 = collection[2];\n        var firstLineDistance = Math.sqrt(Math.pow((point2[0] - point1[0]), 2) + Math.pow((point2[1] - point1[1]), 2));\n        var secondLineDistance = Math.sqrt(Math.pow((point2[0] - point3[0]), 2) + Math.pow((point2[1] - point3[1]), 2));\n        this._radius = Math.min(firstLineDistance, secondLineDistance) / 4;\n        var graphicsPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        graphicsPath._points = collection;\n        graphicsPath._pathTypes = [0, 1, 1];\n        var intersectionPoint1;\n        var intersectionPoint2;\n        var value = this._findLineCircleIntersectionPoints(point2[0], point2[1], this._radius, point1, point2, intersectionPoint1, intersectionPoint2);\n        intersectionPoint1 = value.first;\n        intersectionPoint2 = value.second;\n        if (this._firstIntersectionPoint[0] === 0 && this._firstIntersectionPoint[1] === 0) {\n            this._firstIntersectionPoint = intersectionPoint2;\n        }\n        intersectionPoint1 = [0, 0];\n        intersectionPoint2 = [0, 0];\n        value = this._findLineCircleIntersectionPoints(point2[0], point2[1], this._radius, point3, point2, intersectionPoint1, intersectionPoint2);\n        intersectionPoint1 = value.first;\n        intersectionPoint2 = value.second;\n        if (this._secondIntersectionPoint[0] === 0 && this._secondIntersectionPoint[1] === 0) {\n            this._secondIntersectionPoint = intersectionPoint2;\n        }\n        var xDiff = this._firstIntersectionPoint[0] - point2[0];\n        var yDiff = this._firstIntersectionPoint[1] - point2[1];\n        var startAngle = (Math.atan2(yDiff, xDiff) * (180.0 / Math.PI));\n        xDiff = this._secondIntersectionPoint[0] - point2[0];\n        yDiff = this._secondIntersectionPoint[1] - point2[1];\n        var sweepAngle = (Math.atan2(yDiff, xDiff) * (180.0 / Math.PI));\n        startAngle = startAngle > 0 ? startAngle = 360 - startAngle : -startAngle;\n        sweepAngle = sweepAngle > 0 ? sweepAngle = 360 - sweepAngle : -sweepAngle;\n        if (startAngle === 180 && sweepAngle === 0) {\n            this._startAngle = startAngle;\n            this._sweepAngle = 180;\n        }\n        else if (startAngle === 0 && sweepAngle === 180) {\n            this._startAngle = sweepAngle;\n            this._sweepAngle = 180;\n        }\n        else if (startAngle < 180) {\n            if (startAngle > sweepAngle) {\n                this._startAngle = sweepAngle;\n                this._sweepAngle = startAngle - sweepAngle;\n            }\n            else if (startAngle + 180 < sweepAngle) {\n                this._startAngle = sweepAngle;\n                this._sweepAngle = (360 - sweepAngle) + startAngle;\n            }\n            else {\n                this._startAngle = startAngle;\n                this._sweepAngle = sweepAngle - startAngle;\n            }\n        }\n        else {\n            if (startAngle < sweepAngle) {\n                this._startAngle = startAngle;\n                this._sweepAngle = sweepAngle - startAngle;\n            }\n            else if (startAngle - 180 > sweepAngle) {\n                this._startAngle = startAngle;\n                this._sweepAngle = (360 - startAngle) + sweepAngle;\n            }\n            else {\n                this._startAngle = sweepAngle;\n                this._sweepAngle = startAngle - sweepAngle;\n            }\n        }\n        return (Math.atan2((point3[0] - point2[0]), (point3[1] - point2[1])) -\n            Math.atan2((point1[0] - point2[0]), (point1[1] - point2[1])));\n    };\n    PdfAngleMeasurementAnnotation.prototype._findLineCircleIntersectionPoints = function (centerX, centerY, radius, point1, point2, intersection1, intersection2) {\n        var dx = point2[0] - point1[0];\n        var dy = point2[1] - point1[1];\n        var a = dx * dx + dy * dy;\n        var b = 2 * (dx * (point1[0] - centerX) + dy * (point1[1] - centerY));\n        var c = (point1[0] - centerX) * (point1[0] - centerX) + (point1[1] - centerY) * (point1[1] - centerY) - radius * radius;\n        var e = b * b - 4 * a * c;\n        if ((a <= 0.0000001) || (e < 0)) {\n            intersection1 = [Number.NaN, Number.NaN];\n            intersection2 = [Number.NaN, Number.NaN];\n        }\n        else if (e === 0) {\n            var t = -b / (2 * a);\n            intersection1 = [point1[0] + t * dx, point1[1] + t * dy];\n            intersection2 = [Number.NaN, Number.NaN];\n        }\n        else {\n            var t = ((-b + Math.sqrt(e)) / (2 * a));\n            intersection1 = [point1[0] + t * dx, point1[1] + t * dy];\n            t = ((-b - Math.sqrt(e)) / (2 * a));\n            intersection2 = [point1[0] + t * dx, point1[1] + t * dy];\n        }\n        return { first: intersection1, second: intersection2 };\n    };\n    return PdfAngleMeasurementAnnotation;\n}(PdfComment));\n\n/**\n * `PdfInkAnnotation` class represents the ink annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new ink annotation with the bounds and ink points\n * const annotation: PdfInkAnnotation = new PdfInkAnnotation([0, 0, 300, 400], [40, 300, 60, 100, 40, 50, 40, 300]);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfInkAnnotation = /** @class */ (function (_super) {\n    __extends(PdfInkAnnotation, _super);\n    function PdfInkAnnotation(points, linePoints) {\n        var _this = _super.call(this) || this;\n        _this._inkPointsCollection = [];\n        _this._previousCollection = [];\n        _this._isModified = false;\n        _this._isEnableControlPoints = true;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Ink'));\n        if (typeof points !== 'undefined') {\n            _this._points = points;\n            _this.bounds = { x: points[0], y: points[1], width: points[2], height: points[3] };\n        }\n        if (typeof linePoints !== 'undefined') {\n            _this._linePoints = linePoints;\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.inkAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfInkAnnotation.prototype, \"inkPointsCollection\", {\n        /**\n         * Gets the ink points collection of the annotation.\n         *\n         * @returns {Array<number[]>} Ink points collection.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfInkAnnotation = page.annotations.at(0) as PdfInkAnnotation;\n         * // Get the ink points collection of the annotation\n         * let inkPointsCollection: Array<number[]> = annotation.inkPointsCollection;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._inkPointsCollection.length === 0 && this._dictionary.has('InkList')) {\n                var inkList = this._dictionary.get('InkList');\n                if (Array.isArray(inkList) && inkList.length > 0) {\n                    this._inkPointsCollection = inkList;\n                }\n            }\n            return this._inkPointsCollection;\n        },\n        /**\n         * Sets the ink points collection of the annotation.\n         *\n         * @param {Array<number[]>} value Ink points collection.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * // Create a new ink annotation\n         * const annotation: PdfInkAnnotation = new PdfInkAnnotation([0, 0, 300, 400], [40, 300, 60, 100, 40, 50, 40, 300]);\n         * // Set the ink points collection of the annotation\n         * annotation.inkPointsCollection = [[422, 690, 412, 708, 408, 715, 403, 720, 400, 725], [420, 725, 420, 715, 415, 705, 400, 690, 405, 695]];\n         * // Add annotation to the page\n         * page.annotations.add(annotation);\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (Array.isArray(value) && value.length > 0 && value !== this._inkPointsCollection) {\n                this._inkPointsCollection = value;\n                this._isModified = true;\n                if (this._isLoaded) {\n                    this._dictionary.update('InkList', value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfInkAnnotation._load = function (page, dictionary) {\n        var annot = new PdfInkAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfInkAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfInkAnnotation.prototype._postProcess = function () {\n        if (typeof this._points === 'undefined' || this._points === null) {\n            throw new Error('Points cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (!this._dictionary.has('C')) {\n            this.color = [0, 0, 0];\n            this._isTransparentColor = true;\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        var nativeRectangle = this._addInkPoints();\n        var bounds = [nativeRectangle[0],\n            nativeRectangle[1],\n            nativeRectangle[0] + nativeRectangle[2],\n            nativeRectangle[1] + nativeRectangle[3]];\n        this._dictionary.update('Rect', bounds);\n        if (this._setAppearance) {\n            var appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, nativeRectangle);\n            appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n            var template = appearance.normal;\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n            template._writeTransformation = false;\n            this._appearanceTemplate = this._createInkAppearance(template);\n            if (this._dictionary.has('AP')) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n            }\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n            this._appearanceTemplate._content.dictionary._updated = true;\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            this._appearanceTemplate._content.reference = reference;\n            dictionary.set('N', reference);\n            dictionary._updated = true;\n            this._dictionary.set('AP', dictionary);\n        }\n    };\n    PdfInkAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        this._isFlatten = isFlatten;\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                if (this._inkPointsCollection.length === 0) {\n                    this._inkPointsCollection = this._obtainInkListCollection();\n                }\n                var rect = this._getInkBoundsValue();\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(rect, this._crossReference);\n                var box = template._content.dictionary.getArray('BBox');\n                var angle = this._getRotationAngle();\n                if (box && angle !== null && typeof angle !== 'undefined') {\n                    template._content.dictionary.set('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                }\n                template._writeTransformation = false;\n                this._appearanceTemplate = this._createInkAppearance(template);\n                this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);\n                if (!isFlatten) {\n                    if (this._dictionary.has('AP')) {\n                        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n                    }\n                    var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n                    this._appearanceTemplate._content.dictionary._updated = true;\n                    var reference = this._crossReference._getNextReference();\n                    this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n                    this._appearanceTemplate._content.reference = reference;\n                    dictionary.set('N', reference);\n                    dictionary._updated = true;\n                    this._dictionary.set('AP', dictionary);\n                }\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess();\n            if (!this._appearanceTemplate) {\n                if (isFlatten) {\n                    if (!this._dictionary.has('AP')) {\n                        if (this._inkPointsCollection.length === 0) {\n                            this._inkPointsCollection = this._obtainInkListCollection();\n                        }\n                        var rect = this._getInkBoundsValue();\n                        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(rect, this._crossReference);\n                        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n                        template._writeTransformation = false;\n                        this._appearanceTemplate = this._createInkAppearance(template);\n                        this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);\n                    }\n                    else {\n                        var dictionary = this._dictionary.get('AP');\n                        if (dictionary && dictionary.has('N')) {\n                            var appearanceStream = dictionary.get('N');\n                            var reference = dictionary.getRaw('N');\n                            if (appearanceStream) {\n                                if (reference) {\n                                    appearanceStream.reference = reference;\n                                }\n                                this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten &&\n            this._appearanceTemplate &&\n            this._appearanceTemplate._size !== null &&\n            typeof this._appearanceTemplate._size !== 'undefined') {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {\n                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                if (box) {\n                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                }\n            }\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n        if (isFlatten && !this.flattenPopups && this._dictionary.has('Popup')) {\n            var reference = this._dictionary.getRaw('Popup');\n            if (this._page._pageDictionary.has('Annots')) {\n                var annots = this._page._pageDictionary.getRaw('Annots'); // eslint-disable-line\n                if (annots && Array.isArray(annots) && annots.length > 0) {\n                    var index = annots.indexOf(reference);\n                    if (index >= 0) {\n                        this._page.annotations.removeAt(index);\n                    }\n                }\n            }\n        }\n    };\n    PdfInkAnnotation.prototype._createInkAppearance = function (template) {\n        var graphics = template.graphics;\n        if (this._inkPointsCollection !== null &&\n            this._inkPointsCollection.length > 0 &&\n            this.color !== null &&\n            typeof this._color !== 'undefined') {\n            for (var l = 0; l < this._inkPointsCollection.length; l++) {\n                var isDot = false;\n                if (this._inkPointsCollection[Number.parseInt(l.toString(), 10)].length % 2 === 0) {\n                    var inkPoints = this._inkPointsCollection[Number.parseInt(l.toString(), 10)];\n                    if (inkPoints.length === 2) {\n                        var locx = inkPoints[0] - 0.5;\n                        var locy = inkPoints[1] - 0.5;\n                        var locw = inkPoints[0] + 0.5;\n                        var loch = inkPoints[1] + 0.5;\n                        inkPoints = [locx, locy, locw, loch];\n                        isDot = true;\n                    }\n                    var point = new Array(inkPoints.length / 2);\n                    var count = 0;\n                    for (var j = 0; j < inkPoints.length; j = j + 2) {\n                        point[Number.parseInt(count.toString(), 10)] = [inkPoints[Number.parseInt(j.toString(), 10)], inkPoints[j + 1]];\n                        count++;\n                    }\n                    var pathPointCont = count + (count * 2) - 2;\n                    var pathPoints = new Array(pathPointCont);\n                    if (this._isEnableControlPoints) {\n                        var p1 = [];\n                        var p2 = [];\n                        var value = this._getControlPoints(point, p1, p2);\n                        p1 = value.controlP1;\n                        p2 = value.controlP2;\n                        var index = 0;\n                        for (var i = 0; i < pathPointCont - 1; i = i + 3) {\n                            pathPoints[Number.parseInt(i.toString(), 10)] = point[Number.parseInt(index.toString(), 10)];\n                            pathPoints[i + 1] = p1[Number.parseInt(index.toString(), 10)];\n                            pathPoints[i + 2] = p2[Number.parseInt(index.toString(), 10)];\n                            index++;\n                        }\n                    }\n                    else {\n                        if (count % 3 === 1) {\n                            pathPointCont = count;\n                            pathPoints = new Array(pathPointCont);\n                            pathPoints = point;\n                        }\n                        else if (count % 3 === 0) {\n                            pathPointCont = count + 1;\n                            pathPoints = new Array(pathPointCont);\n                            for (var i = 0; i < point.length; i++) {\n                                pathPoints[Number.parseInt(i.toString(), 10)] = point[Number.parseInt(i.toString(), 10)];\n                            }\n                        }\n                        else {\n                            pathPointCont = count + 2;\n                            pathPoints = new Array(pathPointCont);\n                            for (var i = 0; i < point.length; i++) {\n                                pathPoints[Number.parseInt(i.toString(), 10)] = point[Number.parseInt(i.toString(), 10)];\n                            }\n                            pathPoints[pathPointCont - 2] = point[point.length - 2];\n                        }\n                    }\n                    pathPoints[pathPointCont - 1] = point[point.length - 1];\n                    if (pathPoints !== null) {\n                        var pointsCollection = pathPoints;\n                        for (var k = 0; k < pointsCollection.length; k++) {\n                            var point_1 = pointsCollection[Number.parseInt(k.toString(), 10)];\n                            pointsCollection[Number.parseInt(k.toString(), 10)] = [point_1[0], (-point_1[1])];\n                        }\n                        var path1 = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                        var path2 = null;\n                        if (isDot) {\n                            var width = point[1][0] - point[0][0];\n                            var height = point[1][1] - point[0][1];\n                            path1.addEllipse(point[0][0] + (0.5), -(point[0][1] + height + (0.5)), width, height);\n                            path2 = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                            path2._pathTypes = path1._pathTypes;\n                            path2._points = path1._points;\n                        }\n                        else if (point.length === 2) {\n                            path1.addLine(point[0][0], -point[0][1], point[1][0], -point[1][1]);\n                            path2 = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                            path2._pathTypes = path1._pathTypes;\n                            path2._points = path1._points;\n                        }\n                        else {\n                            path1._addBezierPoints(pointsCollection);\n                            path2 = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                            path2._pathTypes = path1._pathTypes;\n                            path2._points = pointsCollection;\n                        }\n                        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.color, this.border.width);\n                        if (this._isLoaded) {\n                            borderPen._lineCap = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCap.round;\n                        }\n                        if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                            var state = graphics.save();\n                            graphics.setTransparency(this._opacity);\n                            graphics.drawPath(path2, borderPen);\n                            graphics.restore(state);\n                        }\n                        else {\n                            graphics.drawPath(path2, borderPen);\n                        }\n                    }\n                }\n            }\n            if (this._isFlatten) {\n                this.bounds = { x: this.bounds.x,\n                    y: (this._page.size[1] - (this.bounds.y + this.bounds.height)),\n                    width: this.bounds.width,\n                    height: this.bounds.height };\n            }\n        }\n        return template;\n    };\n    PdfInkAnnotation.prototype._getControlPoints = function (point, p1, p2) {\n        if (point === null) {\n            throw new Error('pointCollection');\n        }\n        var pointCount = point.length - 1;\n        if (pointCount < 1) {\n            throw new Error('At least two knot PointFs required pointCollection');\n        }\n        if (pointCount === 1) {\n            p1 = [[((2 * point[0][0] + point[1][0]) / 3), ((2 * point[0][1] + point[1][1]) / 3)]];\n            p2 = [[(2 * p1[0][0] - point[0][0]), (2 * p1[0][1] - point[0][1])]];\n        }\n        var rightVector = [];\n        for (var i = 1; i < pointCount - 1; ++i) {\n            rightVector[Number.parseInt(i.toString(), 10)] = 4 * point[Number.parseInt(i.toString(), 10)][0] + 2 * point[i + 1][0];\n        }\n        rightVector[0] = point[0][0] + 2 * point[1][0];\n        rightVector[pointCount - 1] = (8 * point[pointCount - 1][0] + point[Number.parseInt(pointCount.toString(), 10)][0]) / 2.0;\n        var xValue = this._getSingleControlPoint(rightVector);\n        for (var i = 1; i < pointCount - 1; ++i) {\n            rightVector[Number.parseInt(i.toString(), 10)] = 4 * point[Number.parseInt(i.toString(), 10)][1] + 2 * point[i + 1][1];\n        }\n        rightVector[0] = point[0][1] + 2 * point[1][1];\n        rightVector[pointCount - 1] = (8 * point[pointCount - 1][1] + point[Number.parseInt(pointCount.toString(), 10)][1]) / 2.0;\n        var yValue = this._getSingleControlPoint(rightVector);\n        p1 = new Array(pointCount);\n        p2 = new Array(pointCount);\n        for (var i = 0; i < pointCount; ++i) {\n            p1[Number.parseInt(i.toString(), 10)] = [xValue[Number.parseInt(i.toString(), 10)], yValue[Number.parseInt(i.toString(), 10)]];\n            if (i < pointCount - 1) {\n                p2[Number.parseInt(i.toString(), 10)] = [2 * point[i + 1][0] - xValue[i + 1], 2 * point[i + 1][1] - yValue[i + 1]];\n            }\n            else {\n                var x = (point[Number.parseInt(pointCount.toString(), 10)][0] + xValue[pointCount - 1]) / 2;\n                var y = (point[Number.parseInt(pointCount.toString(), 10)][1] + yValue[pointCount - 1]) / 2;\n                p2[Number.parseInt(i.toString(), 10)] = [x, y];\n            }\n        }\n        return { controlP1: p1, controlP2: p2 };\n    };\n    PdfInkAnnotation.prototype._getSingleControlPoint = function (rightVector) {\n        var count = rightVector.length;\n        var vector = [];\n        var tmpVector = [];\n        var divisor = 2.0;\n        vector[0] = rightVector[0] / divisor;\n        for (var i = 1; i < count; i++) {\n            tmpVector[Number.parseInt(i.toString(), 10)] = 1 / divisor;\n            divisor = (i < count - 1 ? 4.0 : 3.5) - tmpVector[Number.parseInt(i.toString(), 10)];\n            vector[Number.parseInt(i.toString(), 10)] = (rightVector[Number.parseInt(i.toString(), 10)] - vector[i - 1]) / divisor;\n        }\n        for (var i = 1; i < count; i++) {\n            vector[count - i - 1] -= tmpVector[count - i] * vector[count - i];\n        }\n        return vector;\n    };\n    PdfInkAnnotation.prototype._addInkPoints = function () {\n        var _this = this;\n        var inkCollection = [];\n        if (this._linePoints !== null && (this._previousCollection.length === 0 || this._isModified)) {\n            this._inkPointsCollection.unshift(this._linePoints);\n        }\n        var isEqual = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._checkInkPoints)(this._inkPointsCollection, this._previousCollection);\n        if (this._inkPointsCollection !== null && !isEqual) {\n            for (var i = 0; i < this._inkPointsCollection.length; i++) {\n                var inkList = this._inkPointsCollection[Number.parseInt(i.toString(), 10)].slice();\n                inkCollection.push(inkList);\n            }\n            this._dictionary.update('InkList', inkCollection);\n        }\n        if (this._inkPointsCollection.length > 0 && (!isEqual || this._isModified)) {\n            this._inkPointsCollection.forEach(function (inkList) {\n                _this._previousCollection.push(inkList);\n                _this._isModified = false;\n            });\n        }\n        var cropOrMediaBox = this._getCropOrMediaBox();\n        var containsCropOrMediaBox = false;\n        if (cropOrMediaBox && cropOrMediaBox.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {\n            containsCropOrMediaBox = true;\n            for (var i = 0; i < inkCollection.length; i++) {\n                var inkList = inkCollection[Number.parseInt(i.toString(), 10)];\n                var modifiedInkList = inkList;\n                for (var j = 0; j < inkList.length; j = j + 2) {\n                    var x = inkList[Number.parseInt(j.toString(), 10)];\n                    var y = inkList[j + 1];\n                    x = x + cropOrMediaBox[0];\n                    if (this._page._pageDictionary.has('MediaBox') && !this._page._pageDictionary.has('CropBox') && cropOrMediaBox[3] === 0 && cropOrMediaBox[1] > 0) {\n                        y = y + cropOrMediaBox[3];\n                    }\n                    else {\n                        y = y + cropOrMediaBox[1];\n                    }\n                    modifiedInkList[Number.parseInt(j.toString(), 10)] = x;\n                    modifiedInkList[j + 1] = y;\n                    inkCollection[Number.parseInt(i.toString(), 10)] = modifiedInkList;\n                }\n            }\n            this._dictionary.update('InkList', inkCollection);\n        }\n        if (this._isEnableControlPoints || containsCropOrMediaBox) {\n            return this._getInkBoundsValue(inkCollection);\n        }\n        else {\n            if (!this._isFlatten) {\n                this._updateInkListCollection(inkCollection);\n            }\n            return [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];\n        }\n    };\n    PdfInkAnnotation.prototype._updateInkListCollection = function (inkCollection) {\n        for (var i = 0; i < inkCollection.length; i++) {\n            var inkList = [];\n            for (var j = 0; j < inkCollection[Number.parseInt(i.toString(), 10)].length; j++) {\n                inkList.push(inkCollection[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]);\n            }\n            this._inkPointsCollection[Number.parseInt(i.toString(), 10)] = inkList;\n        }\n    };\n    PdfInkAnnotation.prototype._getInkBoundsValue = function (inkCollection) {\n        var bounds = [0, 0, 0, 0];\n        if (this._points) {\n            this.bounds = { x: this._points[0], y: this._points[1], width: this._points[2], height: this._points[3] };\n        }\n        bounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];\n        var borderWidth = this.border.width;\n        if (this._inkPointsCollection !== null) {\n            if (this._inkPointsCollection.length > 0) {\n                var termsList = [];\n                for (var i = 0; i < this._inkPointsCollection.length; i++) {\n                    var subList = this._inkPointsCollection[Number.parseInt(i.toString(), 10)];\n                    if (subList !== null) {\n                        if (subList.length % 2 === 0) {\n                            for (var j = 0; j < subList.length; j++) {\n                                termsList.push(subList[Number.parseInt(j.toString(), 10)]);\n                            }\n                        }\n                    }\n                }\n                var isTwoPoints = false;\n                if (!this._isLoaded && termsList.length === 2) {\n                    isTwoPoints = true;\n                    termsList.push((termsList[0] + 1));\n                    termsList.push((termsList[1] + 1));\n                }\n                var pointCollection = new Array(termsList.length / 2);\n                var count = 0;\n                for (var j = 0; j < termsList.length; j = j + 2) {\n                    pointCollection[Number.parseInt(count.toString(), 10)] = [termsList[Number.parseInt(j.toString(), 10)],\n                        termsList[j + 1]];\n                    count++;\n                }\n                if (this._isLoaded) {\n                    if (pointCollection.length > 0) {\n                        var xMin = 0;\n                        var yMin = 0;\n                        var xMax = 0;\n                        var yMax = 0;\n                        var first = true;\n                        for (var i = 0; i < pointCollection.length; i++) {\n                            var point = pointCollection[Number.parseInt(i.toString(), 10)];\n                            if (first) {\n                                xMin = point[0];\n                                yMin = point[1];\n                                first = false;\n                            }\n                            else {\n                                if (point[0] < xMin) {\n                                    xMin = point[0];\n                                }\n                                else if (point[0] > xMax) {\n                                    xMax = point[0];\n                                }\n                                if (point[1] < yMin) {\n                                    yMin = point[1];\n                                }\n                                else if (point[1] > yMax) {\n                                    yMax = point[1];\n                                }\n                            }\n                        }\n                        bounds = [xMin, yMin, xMax - xMin, yMax - yMin];\n                        this.bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };\n                        if (this._isFlatten || this._setAppearance) {\n                            bounds[0] = this.bounds.x - borderWidth;\n                            bounds[1] = this.bounds.y - borderWidth;\n                            bounds[2] = this.bounds.width + (2 * borderWidth);\n                            bounds[3] = this.bounds.height + (2 * borderWidth);\n                        }\n                    }\n                    else {\n                        if (this._points) {\n                            bounds = this._points;\n                        }\n                        else if (pointCollection.length > 0) {\n                            bounds = this._dictionary.get('Rect');\n                        }\n                        else {\n                            bounds = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];\n                        }\n                    }\n                }\n                else if (inkCollection) {\n                    bounds = this._calculateInkBounds(pointCollection, bounds, borderWidth, isTwoPoints, inkCollection);\n                }\n                else {\n                    bounds = this._calculateInkBounds(pointCollection, bounds, borderWidth, isTwoPoints);\n                }\n                this.bounds = { x: bounds[0], y: bounds[1], width: bounds[2], height: bounds[3] };\n            }\n        }\n        return bounds;\n    };\n    PdfInkAnnotation.prototype._calculateInkBounds = function (pointCollection, bounds, borderWidth, isTwoPoints, inkCollection) {\n        if (pointCollection.length > 5) {\n            var xMin = 0;\n            var yMin = 0;\n            var xMax = 0;\n            var yMax = 0;\n            var first = true;\n            for (var i = 0; i < pointCollection.length; i++) {\n                var point = pointCollection[Number.parseInt(i.toString(), 10)];\n                if (first) {\n                    xMin = point[0];\n                    yMin = point[1];\n                    xMax = point[0];\n                    yMax = point[1];\n                    first = false;\n                }\n                else {\n                    if (point[0] < xMin) {\n                        xMin = point[0];\n                    }\n                    else if (point[0] > xMax) {\n                        xMax = point[0];\n                    }\n                    if (point[1] < yMin) {\n                        yMin = point[1];\n                    }\n                    else if (point[1] > yMax) {\n                        yMax = point[1];\n                    }\n                }\n            }\n            var cropOrMediaBox = this._getCropOrMediaBox();\n            if (bounds[2] < xMax) {\n                xMax = bounds[2];\n            }\n            else if (cropOrMediaBox) {\n                xMax = xMax - xMin;\n            }\n            if (bounds[3] < yMax) {\n                yMax = bounds[3];\n            }\n            else if (cropOrMediaBox) {\n                yMax = yMax - yMin;\n            }\n            if (cropOrMediaBox) {\n                xMin = xMin + cropOrMediaBox[0];\n                yMin = yMin + cropOrMediaBox[1];\n            }\n            bounds = [xMin, yMin, xMax, yMax];\n            if (this._isFlatten || this._setAppearance) {\n                var factor = isTwoPoints ? 2 : 3;\n                bounds[0] = bounds[0] - borderWidth;\n                bounds[1] = bounds[1] - borderWidth;\n                bounds[2] = bounds[2] + (factor * borderWidth);\n                bounds[3] = bounds[3] + (factor * borderWidth);\n            }\n        }\n        else {\n            if (typeof this._points === 'undefined' && pointCollection.length > 0) {\n                bounds = this._dictionary.get('Rect');\n            }\n            else {\n                bounds = this._points;\n            }\n        }\n        if (!this._isFlatten && inkCollection) {\n            this._updateInkListCollection(inkCollection);\n        }\n        return bounds;\n    };\n    PdfInkAnnotation.prototype._obtainInkListCollection = function () {\n        var path = [];\n        if (this._dictionary.has('InkList')) {\n            var inkList = this._dictionary.getArray('InkList');\n            var list = [];\n            for (var i = 0; i < inkList.length; i++) {\n                var innerList = inkList[Number.parseInt(i.toString(), 10)];\n                for (var j = 0; j < innerList.length; j++) {\n                    list.push(innerList[Number.parseInt(j.toString(), 10)]);\n                }\n                path.push(list);\n                if (list.length === innerList.length) {\n                    list = [];\n                }\n            }\n        }\n        return path;\n    };\n    return PdfInkAnnotation;\n}(PdfComment));\n\n/**\n * `PdfPopupAnnotation` class represents the popup annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new popup annotation\n * const annotation: PdfPopupAnnotation = new PdfPopupAnnotation('Test popup annotation', 10, 40, 30, 30);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfPopupAnnotation = /** @class */ (function (_super) {\n    __extends(PdfPopupAnnotation, _super);\n    function PdfPopupAnnotation(text, x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._icon = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.note;\n        _this._iconString = '';\n        _this._stateModel = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationStateModel.none;\n        _this._state = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationState.none;\n        _this._open = false;\n        _this._isReview = false;\n        _this._isComment = false;\n        _this._comment = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 9 5.0908 cm 7.74 12.616 m -7.74 12.616 l -8.274 12.616 -8.707 12.184 -8.707 11.649 c h f Q 0 G ';\n        _this._commentSecondHalf = '0 i 0.60 w 4 M 1 j 0 J [0 100]1 d  1 0 0 1 9 5.0908 cm 4.1 1.71 m -0.54 -2.29 l  -0.54 1.71 l  -5.5 1.71 l  -5.5 14.42 l  10.5 14.42 l  10.5 1.71 l  4.1 1.71 l -2.33 9.66 m 7.34 9.66 l 7.34 8.83 l -2.33 8.83 l -2.33 9.66 l -2.33 7.28 m 5.88 7.28 l 5.88 6.46 l -2.33 6.46 l -2.33 7.28 l 14.9 23.1235 m -14.9 23.1235 l -14.9 -20.345 l 14.9 -20.345 l 14.9 23.1235 l b ';\n        _this._note = '0 G 0 i 0.61 w 4 M 0 j 0 J []0 d  q 1 0 0 1 16.959 1.3672 cm 0 0 m 0 -0.434 -0.352 -0.785 -0.784 -0.785 c -14.911 -0.785 l -15.345 -0.785 -15.696 -0.434 -15.696 0 c -15.696 17.266 l -15.696 17.699 -15.345 18.051 -14.911 18.051 c -0.784 18.051 l -0.352 18.051 0 17.699 0 17.266 c h b Q q 1 0 0 1 4.4023 13.9243 cm 0 0 m 9.418 0 l S Q q 1 0 0 1 4.4019 11.2207 cm 0 0 m 9.418 0 l S Q q 1 0 0 1 4.4023 8.5176 cm 0 0 m 9.418 0 l S Q q 1 0 0 1 4.4023 5.8135 cm 0 0 m 9.418 0 l S Q ';\n        _this._help = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 12.1465 10.5137 cm -2.146 9.403 m -7.589 9.403 -12.001 4.99 -12.001 -0.453 c -12.001 -5.895 -7.589 -10.309 -2.146 -10.309 c 3.296 -10.309 7.709 -5.895 7.709 -0.453 c 7.709 4.99 3.296 9.403 -2.146 9.403 c h f Q ';\n        _this._helpSecondHalf = ' 0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  1 0 0 1 12.1465 10.5137 cm 0 0 m -0.682 -0.756 -0.958 -1.472 -0.938 -2.302 c -0.938 -2.632 l -3.385 -2.632 l -3.403 -2.154 l -3.459 -1.216 -3.147 -0.259 -2.316 0.716 c -1.729 1.433 -1.251 2.022 -1.251 2.647 c -1.251 3.291 -1.674 3.715 -2.594 3.751 c -3.202 3.751 -3.937 3.531 -4.417 3.2 c -5.041 5.205 l -4.361 5.591 -3.274 5.959 -1.968 5.959 c 0.46 5.959 1.563 4.616 1.563 3.089 c 1.563 1.691 0.699 0.771 0 0 c -2.227 -6.863 m -2.245 -6.863 l -3.202 -6.863 -3.864 -6.146 -3.864 -5.189 c -3.864 -4.196 -3.182 -3.516 -2.227 -3.516 c -1.233 -3.516 -0.589 -4.196 -0.57 -5.189 c -0.57 -6.146 -1.233 -6.863 -2.227 -6.863 c -2.146 9.403 m -7.589 9.403 -12.001 4.99 -12.001 -0.453 c -12.001 -5.895 -7.589 -10.309 -2.146 -10.309 c 3.296 -10.309 7.709 -5.895 7.709 -0.453 c 7.709 4.99 3.296 9.403 -2.146 9.403 c b ';\n        _this._insert = ' 0 i 0.59 w 4 M 0 j 0 J []0 d  1 0 0 1 8.5386 19.8545 cm 0 0 m -8.39 -19.719 l 8.388 -19.719 l h B ';\n        _this._key = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 6.5 12.6729 cm 0.001 5.138 m -2.543 5.138 -4.604 3.077 -4.604 0.534 c -4.604 -1.368 -3.449 -3.001 -1.802 -3.702 c -1.802 -4.712 l -0.795 -5.719 l -1.896 -6.82 l -0.677 -8.039 l -1.595 -8.958 l -0.602 -9.949 l -1.479 -10.829 l -0.085 -12.483 l 1.728 -10.931 l 1.728 -3.732 l 1.737 -3.728 1.75 -3.724 1.76 -3.721 c 3.429 -3.03 4.604 -1.385 4.604 0.534 c 4.604 3.077 2.542 5.138 0.001 5.138 c f Q ';\n        _this._keySecondHalf = ' 0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  q 1 0 0 1 6.4995 20 cm 0 0 m -6.205 -12.713 l 6.205 -12.713 l h b Q q 1 0 0 1 1.1909 6.2949 cm 0 0 m 1.278 0 l 1.353 0 1.362 -0.02 1.391 -0.066 c 2.128 -1.363 3.78 -4.275 3.966 -4.713 c 3.985 -4.713 l 3.976 -4.453 3.957 -3.91 3.957 -3.137 c 3.957 -0.076 l 3.957 -0.02 3.976 0 4.041 0 c 4.956 0 l 5.021 0 5.04 -0.029 5.04 -0.084 c 5.04 -6.049 l 5.04 -6.113 5.021 -6.133 4.947 -6.133 c 3.695 -6.133 l 3.621 -6.133 3.611 -6.113 3.574 -6.066 c 3.052 -4.955 1.353 -2.063 0.971 -1.186 c 0.961 -1.186 l 0.999 -1.68 0.999 -2.146 1.008 -3.025 c 1.008 -6.049 l 1.008 -6.104 0.989 -6.133 0.933 -6.133 c 0.009 -6.133 l -0.046 -6.133 -0.075 -6.123 -0.075 -6.049 c -0.075 -0.066 l -0.075 -0.02 -0.056 0 0 0 c f Q q 1 0 0 1 9.1367 3.0273 cm 0 0 m 0.075 0 0.215 -0.008 0.645 -0.008 c 1.4 -0.008 2.119 0.281 2.119 1.213 c 2.119 1.969 1.633 2.381 0.737 2.381 c 0.354 2.381 0.075 2.371 0 2.361 c h -1.146 3.201 m -1.146 3.238 -1.129 3.268 -1.082 3.268 c -0.709 3.275 0.02 3.285 0.729 3.285 c 2.613 3.285 3.248 2.314 3.258 1.232 c 3.258 -0.27 2.007 -0.914 0.607 -0.914 c 0.327 -0.914 0.057 -0.914 0 -0.904 c 0 -2.789 l 0 -2.836 -0.019 -2.865 -0.074 -2.865 c -1.082 -2.865 l -1.119 -2.865 -1.146 -2.846 -1.146 -2.799 c h f Q ';\n        _this._newParagraph = '1 0.819611 0 rg 0 G 0 i 0.58 w 4 M 0 j 0 J []0 d ';\n        _this._newParagraphSecondHalf = ' 0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  q 1 0 0 1 6.4995 20 cm 0 0 m -6.205 -12.713 l 6.205 -12.713 l h b Q q 1 0 0 1 1.1909 6.2949 cm 0 0 m 1.278 0 l 1.353 0 1.362 -0.02 1.391 -0.066 c 2.128 -1.363 3.78 -4.275 3.966 -4.713 c 3.985 -4.713 l 3.976 -4.453 3.957 -3.91 3.957 -3.137 c 3.957 -0.076 l 3.957 -0.02 3.976 0 4.041 0 c 4.956 0 l 5.021 0 5.04 -0.029 5.04 -0.084 c 5.04 -6.049 l 5.04 -6.113 5.021 -6.133 4.947 -6.133 c 3.695 -6.133 l 3.621 -6.133 3.611 -6.113 3.574 -6.066 c 3.052 -4.955 1.353 -2.063 0.971 -1.186 c 0.961 -1.186 l 0.999 -1.68 0.999 -2.146 1.008 -3.025 c 1.008 -6.049 l 1.008 -6.104 0.989 -6.133 0.933 -6.133 c 0.009 -6.133 l -0.046 -6.133 -0.075 -6.123 -0.075 -6.049 c -0.075 -0.066 l -0.075 -0.02 -0.056 0 0 0 c f Q q 1 0 0 1 9.1367 3.0273 cm 0 0 m 0.075 0 0.215 -0.008 0.645 -0.008 c 1.4 -0.008 2.119 0.281 2.119 1.213 c 2.119 1.969 1.633 2.381 0.737 2.381 c 0.354 2.381 0.075 2.371 0 2.361 c h -1.146 3.201 m -1.146 3.238 -1.129 3.268 -1.082 3.268 c -0.709 3.275 0.02 3.285 0.729 3.285 c 2.613 3.285 3.248 2.314 3.258 1.232 c 3.258 -0.27 2.007 -0.914 0.607 -0.914 c 0.327 -0.914 0.057 -0.914 0 -0.904 c 0 -2.789 l 0 -2.836 -0.019 -2.865 -0.074 -2.865 c -1.082 -2.865 l -1.119 -2.865 -1.146 -2.846 -1.146 -2.799 c h f Q ';\n        _this._paragraph = 'q 1 1 1 rg 0 i 1 w 4 M 1 j 0 J []0 d 1 0 0 1 19.6973 10.0005 cm 0 0 m 0 -5.336 -4.326 -9.662 -9.663 -9.662 c -14.998 -9.662 -19.324 -5.336 -19.324 0 c -19.324 5.335 -14.998 9.662 -9.663 9.662 c -4.326 9.662 0 5.335 0 0 c h f Q ';\n        _this._paragraphSecondHalf = '0 G 0 i 0.59 w 4 M 1 j 0 J []0 d  q 1 0 0 1 19.6973 10.0005 cm 0 0 m 0 -5.336 -4.326 -9.662 -9.663 -9.662 c -14.998 -9.662 -19.324 -5.336 -19.324 0 c -19.324 5.335 -14.998 9.662 -9.663 9.662 c -4.326 9.662 0 5.335 0 0 c h S Q q 1 0 0 1 11.6787 2.6582 cm 0 0 m -1.141 0 l -1.227 0 -1.244 0.052 -1.227 0.139 c -0.656 1.157 -0.52 2.505 -0.52 3.317 c -0.52 3.594 l -2.833 3.783 -5.441 4.838 -5.441 8.309 c -5.441 10.778 -3.714 12.626 -0.57 13.024 c -0.535 13.508 -0.381 14.129 -0.242 14.389 c -0.207 14.44 -0.174 14.475 -0.104 14.475 c 1.088 14.475 l 1.156 14.475 1.191 14.458 1.175 14.372 c 1.105 14.095 0.881 13.127 0.881 12.402 c 0.881 9.431 0.932 7.324 0.95 4.06 c 0.95 2.298 0.708 0.813 0.189 0.07 c 0.155 0.034 0.103 0 0 0 c b Q ';\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Text'));\n        if (typeof text !== 'undefined') {\n            _this.text = text;\n        }\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.popupAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfPopupAnnotation.prototype, \"open\", {\n        /**\n         * Gets the boolean flag indicating whether annotation has open or not.\n         *\n         * @returns {boolean} Caption.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Gets the boolean flag indicating whether annotation has open or not.\n         * let open: boolean =  annotation.open;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Open')) {\n                this._open = this._dictionary.get('Open');\n            }\n            return this._open;\n        },\n        /**\n         * Sets the boolean flag indicating whether annotation has open or not.\n         *\n         * @param {boolean} value Open.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Sets the boolean flag indicating whether annotation has open or not.\n         * annotation.open = true;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._open = value;\n                this._dictionary.update('Open', this._open);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPopupAnnotation.prototype, \"icon\", {\n        /**\n         * Gets the icon type of the popup annotation.\n         *\n         * @returns {PdfPopupIcon} Annotation icon.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Gets the icon type of the popup annotation.\n         * let icon: PdfPopupIcon = annotation.icon;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Name')) {\n                this._icon = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapPopupIcon)(this._dictionary.get('Name').name);\n            }\n            return this._icon;\n        },\n        /**\n         * Sets the icon type of the popup annotation.\n         *\n         * @param {PdfPopupIcon} value Annotation icon.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Sets the icon type of the popup annotation.\n         * annotation.icon = PdfPopupIcon.newParagraph;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._icon = value;\n                this._dictionary.update('Name', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(this._obtainIconName(this._icon)));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPopupAnnotation.prototype, \"stateModel\", {\n        /**\n         * Gets the state model of the popup annotation.\n         *\n         * @returns {PdfAnnotationStateModel} Annotation State Model.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Gets the state model of the popup annotation.\n         * let stateModel: PdfAnnotationStateModel = annotation.stateModel;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('StateModel')) {\n                this._stateModel = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapAnnotationStateModel)(this._dictionary.get('StateModel'));\n            }\n            return this._stateModel;\n        },\n        /**\n         * Sets the state model of the popup annotation.\n         *\n         * @param {PdfAnnotationStateModel} value Annotation State Model.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Sets the state model of the popup annotation.\n         * annotation.stateModel = PdfAnnotationStateModel.marked;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._stateModel = value;\n                this._dictionary.update('StateModel', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapAnnotationStateModel)(this._stateModel));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfPopupAnnotation.prototype, \"state\", {\n        /**\n         * Gets the state of the popup annotation.\n         *\n         * @returns {PdfAnnotationState} Annotation State.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Gets the state of the popup annotation.\n         * let state: PdfAnnotationState = annotation.state;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('State')) {\n                this._state = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapAnnotationState)(this._dictionary.get('State'));\n            }\n            return this._state;\n        },\n        /**\n         * Sets the state of the popup annotation.\n         *\n         * @param {PdfAnnotationState} value Annotation State.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfPopupAnnotation = page.annotations.at(0) as PdfPopupAnnotation;\n         * // Sets the state of the popup annotation.\n         * annotation.state = PdfAnnotationState.completed;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._state = value;\n                this._dictionary.update('State', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapAnnotationState)(this._state));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfPopupAnnotation._load = function (page, dictionary) {\n        var annot = new PdfPopupAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        if (dictionary.has('IRT')) {\n            annot._isReview = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._checkReview)(dictionary);\n            if (!annot._isReview) {\n                annot._isComment = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._checkComment)(dictionary);\n            }\n        }\n        return annot;\n    };\n    PdfPopupAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfPopupAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            this._bounds = { x: 0, y: 0, width: 0, height: 0 };\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        var rectangle = [this.bounds.x, this.bounds.y, (this.bounds.x + this.bounds.width),\n            (this.bounds.y + this.bounds.height)];\n        this._dictionary.update('Rect', rectangle);\n        if (this._setAppearance) {\n            this._appearanceTemplate = this._createPopupAppearance();\n            if (this._appearanceTemplate) {\n                if (this._dictionary.has('AP')) {\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n                }\n                var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n                this._appearanceTemplate._content.dictionary._updated = true;\n                var reference = this._crossReference._getNextReference();\n                this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n                this._appearanceTemplate._content.reference = reference;\n                dictionary.set('N', reference);\n                dictionary._updated = true;\n                this._dictionary.set('AP', dictionary);\n            }\n        }\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n    };\n    PdfPopupAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (!this._appearanceTemplate && this._isFlattenPopups && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (appearanceStream) {\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                    if (this._appearanceTemplate !== null) {\n                        var state = this._page.graphics.save();\n                        if (this.opacity < 1) {\n                            this._page.graphics.setTransparency(this.opacity);\n                        }\n                        this._page.graphics.drawTemplate(this._appearanceTemplate, this.bounds);\n                        this._page.graphics.restore(state);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess();\n            if (!this._appearanceTemplate) {\n                if (isFlatten) {\n                    if (!this._dictionary.has('AP')) {\n                        this._appearanceTemplate = this._createPopupAppearance();\n                    }\n                    else {\n                        var dictionary = this._dictionary.get('AP');\n                        if (dictionary && dictionary.has('N')) {\n                            var appearanceStream = dictionary.get('N');\n                            var reference = dictionary.getRaw('N');\n                            if (appearanceStream) {\n                                if (reference) {\n                                    appearanceStream.reference = reference;\n                                }\n                                this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups && this.flatten) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        if (isFlatten) {\n            this._removeAnnotation(this._page, this);\n        }\n    };\n    PdfPopupAnnotation.prototype._createPopupAppearance = function () {\n        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        var graphics = template.graphics;\n        graphics._sw._clear();\n        if (this.opacity < 1) {\n            graphics.save();\n            graphics.setTransparency(this.opacity);\n        }\n        switch (this.icon) {\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.comment:\n                graphics._sw._write(this._comment);\n                graphics._sw._setColorSpace(this.color, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfColorSpace.rgb, false);\n                graphics._sw._write(this._commentSecondHalf);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.paragraph:\n                graphics._sw._write(this._paragraph);\n                graphics._sw._setColorSpace(this.color, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfColorSpace.rgb, false);\n                graphics._sw._write(this._paragraphSecondHalf);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.help:\n                graphics._sw._write(this._help);\n                graphics._sw._setColorSpace(this.color, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfColorSpace.rgb, false);\n                graphics._sw._write(this._helpSecondHalf);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.note:\n                graphics._sw._setColorSpace(this.color, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfColorSpace.rgb, false);\n                graphics._sw._write(this._note);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.insert:\n                graphics._sw._write('0 G ');\n                graphics._sw._setColorSpace(this.color, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfColorSpace.rgb, false);\n                graphics._sw._write(this._insert);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.key:\n                graphics._sw._write(this._key);\n                graphics._sw._setColorSpace(this.color, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfColorSpace.rgb, false);\n                graphics._sw._write(this._keySecondHalf);\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.newParagraph:\n                graphics._sw._write(this._newParagraph);\n                graphics._sw._setColorSpace(this.color, _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfColorSpace.rgb, false);\n                graphics._sw._write(this._newParagraphSecondHalf);\n                break;\n        }\n        if (this.opacity < 1) {\n            graphics.restore();\n        }\n        return template;\n    };\n    PdfPopupAnnotation.prototype._obtainIconName = function (icon) {\n        switch (icon) {\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.note:\n                this._iconString = 'Note';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.comment:\n                this._iconString = 'Comment';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.help:\n                this._iconString = 'Help';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.insert:\n                this._iconString = 'Insert';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.key:\n                this._iconString = 'Key';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.newParagraph:\n                this._iconString = 'NewParagraph';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfPopupIcon.paragraph:\n                this._iconString = 'Paragraph';\n                break;\n        }\n        return this._iconString;\n    };\n    return PdfPopupAnnotation;\n}(PdfComment));\n\n/**\n * `PdfFileLinkAnnotation` class represents the link annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new file link annotation\n * let annotation: PdfFileLinkAnnotation = new PdfFileLinkAnnotation(10, 40, 30, 30, \"image.png\");\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfFileLinkAnnotation = /** @class */ (function (_super) {\n    __extends(PdfFileLinkAnnotation, _super);\n    function PdfFileLinkAnnotation(x, y, width, height, fileName) {\n        var _this = _super.call(this) || this;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Link'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        if (typeof fileName !== 'undefined' && fileName !== null) {\n            _this._fileName = fileName;\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.fileLinkAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfFileLinkAnnotation.prototype, \"action\", {\n        /**\n         * Gets the action of the annotation.\n         *\n         * @returns {string} Action.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFileLinkAnnotation = page.annotations.at(0) as PdfFileLinkAnnotation;\n         * // Gets the action of the annotation.\n         * let action: string = annotation.action;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._action === 'undefined' && this._dictionary.has('A')) {\n                var dictionary = this._dictionary.get('A');\n                if (dictionary && dictionary.has('Next')) {\n                    var action = dictionary.get('Next');\n                    if (Array.isArray(action)) {\n                        for (var i = 0; i < action.length; i++) {\n                            var reference = action[Number.parseInt(i.toString(), 10)];\n                            if (reference && reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                                var actionDictionary = this._crossReference._fetch(reference);\n                                if (actionDictionary.has('JS')) {\n                                    this._action = actionDictionary.get('JS');\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return this._action;\n        },\n        /**\n         * Sets the action of the annotation.\n         *\n         * @param {string} value Action.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFileLinkAnnotation = page.annotations.at(0) as PdfFileLinkAnnotation;\n         * // Sets the action of the annotation.\n         * annotation.action = ‘syncfusion’;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!this._isLoaded && typeof value === 'string') {\n                this._action = value;\n            }\n            if (this._isLoaded && typeof value === 'string') {\n                if (this.action !== value && this._dictionary.has('A')) {\n                    var dictionary = this._dictionary.get('A');\n                    if (dictionary && dictionary.has('Next')) {\n                        var action = dictionary.get('Next');\n                        if (Array.isArray(action)) {\n                            for (var i = 0; i < action.length; i++) {\n                                var reference = action[Number.parseInt(i.toString(), 10)];\n                                if (reference && reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                                    var actionDictionary = this._crossReference._fetch(reference);\n                                    if (actionDictionary.has('JS')) {\n                                        actionDictionary.update('JS', value);\n                                        this._action = value;\n                                        this._dictionary._updated = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfFileLinkAnnotation._load = function (page, dictionary) {\n        var annot = new PdfFileLinkAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfFileLinkAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfFileLinkAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        this._addAction();\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n    };\n    PdfFileLinkAnnotation.prototype._addAction = function () {\n        var _this = this;\n        if (this._dictionary.has('A')) {\n            var action = this._dictionary.get('A');\n            if (action) {\n                if (typeof this._action !== 'undefined' && this._action !== null && action.has('Next')) {\n                    var nextAction = action.get('Next');\n                    if (Array.isArray(nextAction) && nextAction.length > 0) {\n                        nextAction.forEach(function (reference) {\n                            if (reference && reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference && reference._isNew) {\n                                _this._crossReference._cacheMap.delete(reference);\n                            }\n                        });\n                    }\n                }\n                if (action.has('F')) {\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(action, this._crossReference, 'F');\n                }\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary, this._crossReference, 'A');\n        }\n        var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Action'));\n        dictionary.set('S', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Launch'));\n        var fileDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        fileDictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Filespec'));\n        fileDictionary.set('UF', this._fileName);\n        if (typeof this._action !== 'undefined' && this._action !== null) {\n            var actionDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n            actionDictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Action'));\n            actionDictionary.set('S', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('JavaScript'));\n            actionDictionary.set('JS', this._action);\n            var ref = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(ref, actionDictionary);\n            actionDictionary._updated = true;\n            dictionary.set('Next', [ref]);\n        }\n        var reference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(reference, fileDictionary);\n        fileDictionary._updated = true;\n        dictionary.set('F', reference);\n        dictionary._updated = true;\n        this._dictionary.set('A', dictionary);\n    };\n    PdfFileLinkAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (!this._isLoaded) {\n            this._postProcess();\n        }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    return PdfFileLinkAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfUriAnnotation` class represents the URI annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new URI annotation\n * let annotation: PdfUriAnnotation = new PdfUriAnnotation(100, 150, 200, 100, ‘http://www.google.com’);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfUriAnnotation = /** @class */ (function (_super) {\n    __extends(PdfUriAnnotation, _super);\n    function PdfUriAnnotation(x, y, width, height, uri) {\n        var _this = _super.call(this) || this;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Link'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        if (typeof uri !== 'undefined' && uri !== null) {\n            _this._uri = uri;\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.uriAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfUriAnnotation.prototype, \"uri\", {\n        /**\n         * Gets the uri of the annotation.\n         *\n         * @returns {string} Uri.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfUriAnnotation = page.annotations.at(0) as PdfUriAnnotation;\n         * // Gets the uri of the annotation.\n         * let uri: string = annotation.uri;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._uri === 'undefined' && this._dictionary.has('A')) {\n                var linkDict = this._dictionary.get('A');\n                if (linkDict.has('URI')) {\n                    this._uri = linkDict.get('URI');\n                }\n            }\n            return this._uri;\n        },\n        /**\n         * Sets the uri of the annotation.\n         *\n         * @param {string} value Uri.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Create a new URI annotation\n         * let annotation: PdfUriAnnotation = new PdfUriAnnotation(100, 150, 200, 100);\n         * // Sets the uri of the annotation\n         * annotation.uri = ‘http://www.google.com’;\n         * // Add annotation to the page\n         * page.annotations.add(annotation);\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value === 'string') {\n                if (this._isLoaded && this._dictionary.has('A') && value !== this.uri) {\n                    var linkDict = this._dictionary.get('A');\n                    if (linkDict.has('URI')) {\n                        this._uri = value;\n                        linkDict.update('URI', value);\n                        this._dictionary._updated = true;\n                    }\n                }\n                else {\n                    this._uri = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfUriAnnotation._load = function (page, dictionary) {\n        var annot = new PdfUriAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfUriAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfUriAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        this._addAction();\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n    };\n    PdfUriAnnotation.prototype._addAction = function () {\n        var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Action'));\n        dictionary.set('S', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('URI'));\n        if (typeof this._uri !== 'undefined') {\n            dictionary.set('URI', this._uri);\n        }\n        dictionary._updated = true;\n        this._dictionary.set('A', dictionary);\n        this._dictionary.update('Border', [this.border.hRadius, this.border.vRadius, this.border.width]);\n    };\n    PdfUriAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (!this._isLoaded) {\n            this._postProcess();\n        }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    return PdfUriAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfDocumentLinkAnnotation` class represents the document link annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new document link annotation\n * let annotation: PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(100, 150, 40, 60);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfDocumentLinkAnnotation = /** @class */ (function (_super) {\n    __extends(PdfDocumentLinkAnnotation, _super);\n    function PdfDocumentLinkAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Link'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.documentLinkAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfDocumentLinkAnnotation.prototype, \"destination\", {\n        /**\n         * Gets the destination of the annotation.\n         *\n         * @returns {PdfDestination} Destination.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;\n         * // Gets the destination of the annotation.\n         * let destination: PdfDestination =annotation.destination;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded && !this._destination) {\n                this.destination = this._obtainDestination();\n            }\n            return this._destination;\n        },\n        /**\n         * Sets the destination of the annotation.\n         *\n         * @param {PdfDestination} value Destination.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access first page\n         * let page: PdfPage = document.getPage(0);\n         * // Access the annotation at index 0\n         * let annotation: PdfDocumentLinkAnnotation = page.annotations.at(0) as PdfDocumentLinkAnnotation;\n         * // Initializes a new instance of the `PdfDestination` class.\n         * let destination: PdfDestination = new PdfDestination();\n         * // Sets the zoom factor.\n         * destination.zoom = 20;\n         * // Sets the page where the destination is situated.\n         * destination.page = page;\n         * // Sets the mode of the destination.\n         * destination.mode = PdfDestinationMode.fitToPage;\n         * // Sets the location of the destination.\n         * destination.location = [20, 20];\n         * // Sets the bounds of the destination.\n         * destination.destinationBounds = [20, 20, 100, 50];\n         * // Sets destination to document link annotation.\n         * annotation.destination = destination;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value) {\n                this._destination = value;\n                if (this._isLoaded) {\n                    this._destination._initializePrimitive();\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfDocumentLinkAnnotation._load = function (page, dictionary) {\n        var annot = new PdfDocumentLinkAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfDocumentLinkAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfDocumentLinkAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        this._addDocument();\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n    };\n    PdfDocumentLinkAnnotation.prototype._obtainDestination = function () {\n        if (this._dictionary.has('Dest')) {\n            var array = this._dictionary.get('Dest'); // eslint-disable-line\n            var holder = void 0;\n            if (typeof array === 'string') {\n                array = this._getDestination(array);\n            }\n            if (array && array[0] instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                holder = array[0];\n            }\n            if ((typeof holder === 'undefined' || holder === null) && array && typeof array[0] === 'number') {\n                var pageNumber = array[0];\n                var page = this._crossReference._document.getPage(pageNumber);\n                if (page) {\n                    var mode = array[1];\n                    if (mode.name === 'XYZ') {\n                        var left = array[2];\n                        var top_3 = array[3];\n                        var zoom = array[4];\n                        var topValue = (typeof top_3 !== 'undefined' && top_3 !== null) ? (page.size[1] - top_3) : 0;\n                        var leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;\n                        this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page, [leftValue, topValue]);\n                        if (typeof zoom !== 'undefined' && zoom !== null) {\n                            this._destination.zoom = zoom;\n                        }\n                        if ((typeof left === 'undefined' && left === null) || (typeof top_3 === 'undefined' && top_3 === null)\n                            || (typeof zoom === 'undefined' && zoom === null)) {\n                            this._destination._setValidation(false);\n                        }\n                    }\n                    else {\n                        this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page);\n                        this._destination.mode = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDestinationMode.fitToPage;\n                    }\n                }\n            }\n            if (holder) {\n                var index = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getPageIndex)(this._crossReference._document, this._crossReference._fetch(holder));\n                if (index >= 0) {\n                    var page = this._crossReference._document.getPage(index);\n                    if (page && array[1] instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName) {\n                        var mode = array[1];\n                        if (mode) {\n                            if (mode.name === 'XYZ') {\n                                var left = array[2];\n                                var top_4 = array[3];\n                                var zoom = array[4];\n                                var topValue = (typeof top_4 !== 'undefined' && top_4 !== null) ? (page.size[1] - top_4) : 0;\n                                var leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;\n                                this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page, [leftValue, topValue]);\n                                if (typeof zoom !== 'undefined' && zoom !== null) {\n                                    this._destination.zoom = zoom;\n                                }\n                                if ((typeof left === 'undefined' && left === null) || (typeof top_4 === 'undefined' && top_4 === null)\n                                    || (typeof zoom === 'undefined' && zoom === null)) {\n                                    this._destination._setValidation(false);\n                                }\n                            }\n                            else if (mode.name === 'Fit') {\n                                this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page);\n                                this._destination.mode = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDestinationMode.fitToPage;\n                            }\n                        }\n                    }\n                }\n                else {\n                    this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination();\n                    var zoom = array[4];\n                    var mode = array[1];\n                    if (typeof zoom !== 'undefined' && zoom !== null) {\n                        this._destination.zoom = zoom;\n                    }\n                    if (mode.name === 'Fit') {\n                        this._destination.mode = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDestinationMode.fitToPage;\n                    }\n                    else if (mode.name === 'XYZ') {\n                        var left = array[2];\n                        var topValue = array[3];\n                        if ((typeof left === 'undefined' && left === null) || (typeof topValue === 'undefined' && topValue === null)\n                            || (typeof zoom === 'undefined' && zoom === null)) {\n                            this._destination._setValidation(false);\n                        }\n                    }\n                    this._destination._index = index;\n                }\n            }\n        }\n        else if (this._dictionary.has('A') && !this._destination) {\n            var action = this._dictionary.get('A');\n            if (action.has('D')) {\n                var reference = action.get('D'); // eslint-disable-line\n                if (reference !== null && typeof reference !== 'undefined') {\n                    var referenceArray = void 0; // eslint-disable-line\n                    if (Array.isArray(reference)) {\n                        referenceArray = reference;\n                    }\n                    else if (reference && reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                        var referenceValue = this._crossReference._fetch(reference); // eslint-disable-line\n                        if (Array.isArray(referenceValue)) {\n                            referenceArray = referenceValue;\n                        }\n                    }\n                    else if (typeof reference === 'string') {\n                        referenceArray = this._getDestination(reference);\n                    }\n                    if (referenceArray && (referenceArray[0] instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference || typeof referenceArray[0] === 'number')) {\n                        var document_1 = this._crossReference._document;\n                        var index = void 0;\n                        if (referenceArray[0] instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                            index = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getPageIndex)(document_1, this._crossReference._fetch(referenceArray[0]));\n                        }\n                        else {\n                            index = referenceArray[0];\n                        }\n                        var page = document_1.getPage(index);\n                        if (page) {\n                            var mode = referenceArray[1];\n                            if (mode.name === 'FitBH' || mode.name === 'FitH') {\n                                var top_5 = referenceArray[2];\n                                var topValue = (typeof top_5 !== 'undefined' && top_5 !== null) ? (page.size[1] - top_5) : 0;\n                                this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page, [0, topValue]);\n                                if (typeof top_5 === 'undefined' || top_5 === null) {\n                                    this._destination._setValidation(false);\n                                }\n                            }\n                            else if (mode.name === 'XYZ') {\n                                var left = referenceArray[2];\n                                var top_6 = referenceArray[3];\n                                var zoom = referenceArray[4];\n                                var topValue = (typeof top_6 !== 'undefined' && top_6 !== null) ? (page.size[1] - top_6) : 0;\n                                var leftValue = (typeof left !== 'undefined' && left !== null) ? left : 0;\n                                this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page, [leftValue, topValue]);\n                                if (typeof zoom !== 'undefined' && zoom !== null) {\n                                    this._destination.zoom = zoom;\n                                }\n                                if ((typeof left !== 'undefined' && left !== null) || (typeof top_6 !== 'undefined' && top_6 !== null)\n                                    || (typeof zoom !== 'undefined' && zoom !== null)) {\n                                    this._destination._setValidation(false);\n                                }\n                            }\n                            else if (mode.name === 'FitR') {\n                                if (referenceArray.length === 6) {\n                                    var left = referenceArray[2];\n                                    var bottom = referenceArray[3];\n                                    var right = referenceArray[4];\n                                    var top_7 = referenceArray[5];\n                                    this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page, [left, bottom, right, top_7]);\n                                }\n                            }\n                            else if (mode.name === 'Fit') {\n                                this._destination = new _pdf_page__WEBPACK_IMPORTED_MODULE_0__.PdfDestination(page);\n                                this._destination.mode = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfDestinationMode.fitToPage;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return this._destination;\n    };\n    PdfDocumentLinkAnnotation.prototype._getDestination = function (name) {\n        var document = this._crossReference._document;\n        var destinationArray; // eslint-disable-line\n        if (document) {\n            destinationArray = this._getNamedDestination(document, name);\n        }\n        return destinationArray;\n    };\n    PdfDocumentLinkAnnotation.prototype._getNamedDestination = function (document, result) {\n        var destination; // eslint-disable-line\n        var catalog = document._catalog;\n        if (catalog && catalog._catalogDictionary && catalog._catalogDictionary.has('Names')) {\n            var names = catalog._catalogDictionary.get('Names');\n            if (names && names.has('Dests')) {\n                var kids = names.get('Dests');\n                if (kids) {\n                    var ref = this._getNamedObjectFromTree(kids, result);\n                    destination = this._extractDestination(ref, document);\n                }\n            }\n        }\n        return destination;\n    };\n    PdfDocumentLinkAnnotation.prototype._extractDestination = function (ref, document) {\n        var dict; // eslint-disable-line\n        var destinationArray; // eslint-disable-line\n        if (ref && ref instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n            dict = document._crossReference._fetch(ref);\n        }\n        if (dict) {\n            if (dict instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary && dict.has('D')) {\n                destinationArray = dict.getRaw('D');\n            }\n            else if (Array.isArray(dict)) {\n                destinationArray = dict;\n            }\n        }\n        return destinationArray ? destinationArray : ref;\n    };\n    PdfDocumentLinkAnnotation.prototype._getNamedObjectFromTree = function (kids, name) {\n        var found = false;\n        var currentDictionary = kids;\n        var reference;\n        while (!found && currentDictionary) {\n            if (currentDictionary && currentDictionary.has('Kids')) {\n                currentDictionary = this._getProperKid(currentDictionary, name);\n            }\n            else if (currentDictionary && currentDictionary.has('Names')) {\n                reference = this._findName(currentDictionary, name);\n                found = true;\n            }\n        }\n        return reference;\n    };\n    PdfDocumentLinkAnnotation.prototype._findName = function (current, name) {\n        var names = current.get('Names'); // eslint-disable-line\n        var halfLength = names.length / 2;\n        var lowerIndex = 0;\n        var topIndex = halfLength - 1;\n        var half = 0;\n        var found = false;\n        var destinationReference;\n        while (!found) {\n            half = Math.floor((lowerIndex + topIndex) / 2);\n            if (lowerIndex > topIndex) {\n                break;\n            }\n            var result = names[Number.parseInt(half.toString(), 10) * 2]; // eslint-disable-line\n            if (result && result instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                result = current._crossReference._fetch(result);\n            }\n            var cmp = this._stringCompare(name, result);\n            if (cmp > 0) {\n                lowerIndex = half + 1;\n            }\n            else if (cmp < 0) {\n                topIndex = half - 1;\n            }\n            else {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            destinationReference = names[half * 2 + 1];\n        }\n        return destinationReference;\n    };\n    PdfDocumentLinkAnnotation.prototype._getProperKid = function (kids, name) {\n        var kidsArray; // eslint-disable-line\n        var kid;\n        if (kids && kids.has('Kids')) {\n            kidsArray = kids.getRaw('Kids');\n        }\n        if (kidsArray && Array.isArray(kidsArray) && kidsArray.length !== 0) {\n            kidsArray = kids.getArray('Kids');\n            for (var i = 0; i < kidsArray.length; i++) {\n                kid = kidsArray[Number.parseInt(i.toString(), 10)];\n                if (this._checkLimits(kid, name)) {\n                    break;\n                }\n            }\n        }\n        return kid;\n    };\n    PdfDocumentLinkAnnotation.prototype._checkLimits = function (kid, result) {\n        var found = false;\n        if (kid && kid.has('Limits')) {\n            var limits = kid.get('Limits'); // eslint-disable-line\n            var lowerLimit = limits[0];\n            var higherLimit = limits[1];\n            var lowCompare = this._stringCompare(lowerLimit, result);\n            var highCompare = this._stringCompare(higherLimit, result);\n            if (lowCompare === 0 || highCompare === 0) {\n                found = true;\n            }\n            else if (lowCompare < 0 && highCompare > 0) {\n                found = true;\n            }\n        }\n        return found;\n    };\n    PdfDocumentLinkAnnotation.prototype._stringCompare = function (limits, result) {\n        var byteArray = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._stringToBytes)(limits);\n        var byteArray1 = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._stringToBytes)(result);\n        var commonSize = Math.min(byteArray.length, byteArray1.length);\n        var resultValue = 0;\n        for (var i = 0; i < commonSize; i++) {\n            var byte = byteArray[Number.parseInt(i.toString(), 10)];\n            var byte1 = byteArray1[Number.parseInt(i.toString(), 10)];\n            resultValue = byte - byte1;\n            if (resultValue !== 0) {\n                break;\n            }\n        }\n        if (resultValue === 0) {\n            resultValue = byteArray.length - byteArray1.length;\n        }\n        return resultValue;\n    };\n    PdfDocumentLinkAnnotation.prototype._addDocument = function () {\n        if (this.destination) {\n            this._dictionary.set('Dest', this.destination._array);\n        }\n    };\n    PdfDocumentLinkAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (!this._isLoaded) {\n            this._postProcess();\n        }\n        else if (this._destination) {\n            this._dictionary.update('Dest', this._destination._array);\n        }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    return PdfDocumentLinkAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfTextWebLinkAnnotation` class represents the link annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new PDF string format\n * const format: PdfStringFormat = new PdfStringFormat(PdfTextAlignment.left, PdfVerticalAlignment.top);\n * // Create a new standard font\n * const font: PdfStandardFont = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);\n * // Get the text size\n * let size: number[] = font.measureString(\"Syncfusion Site\", format, [0, 0], 0, 0);\n * // Create a new text web link annotation\n * let annot: PdfTextWebLinkAnnotation = new PdfTextWebLinkAnnotation(50, 40, size[0], size[1], [0, 0, 0], [165, 42, 42], 1);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfTextWebLinkAnnotation = /** @class */ (function (_super) {\n    __extends(PdfTextWebLinkAnnotation, _super);\n    function PdfTextWebLinkAnnotation(x, y, width, height, brushColor, penColor, penWidth, text) {\n        var _this = _super.call(this) || this;\n        _this._isActionAdded = false;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Link'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._textWebLink = typeof text !== 'undefined' && text !== null ? text : '';\n        if (typeof brushColor !== 'undefined' && brushColor !== null) {\n            _this._brush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(brushColor);\n        }\n        if (typeof penColor !== 'undefined' && penColor !== null) {\n            _this._pen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(penColor, penWidth ? penWidth : 1);\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.textWebLinkAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfTextWebLinkAnnotation.prototype, \"font\", {\n        /**\n         * Gets the font of the annotation.\n         *\n         * @returns {PdfFont} font.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;\n         * // Gets the font of the annotation.\n         * let font: PdfFont = annotation.font;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._font;\n        },\n        /**\n         * Sets the font of the annotation.\n         *\n         * @param {PdfFont} value font.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;\n         * // Sets the font of the annotation.\n         * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._font = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfTextWebLinkAnnotation.prototype, \"url\", {\n        /**\n         * Gets the url of the annotation.\n         *\n         * @returns {string} Url.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;\n         * // Gets the URL of the annotation.\n         * let url: string = annotation.url;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._url === 'undefined' && this._dictionary.has('A')) {\n                var linkDict = this._dictionary.get('A');\n                if (linkDict.has('URI')) {\n                    this._url = linkDict.get('URI');\n                }\n            }\n            return this._url;\n        },\n        /**\n         * Sets the url of the annotation.\n         *\n         * @param {string} value Url.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextWebLinkAnnotation = page.annotations.at(0) as PdfTextWebLinkAnnotation;\n         * // Sets the URL of the annotation.\n         * annotation.url = ‘http://www.syncfusion.com’;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value === 'string') {\n                if (this._isLoaded && this._dictionary.has('A')) {\n                    var linkSource = this._dictionary._get('A'); // eslint-disable-line\n                    var linkDict = this._dictionary.get('A');\n                    if (linkDict && linkDict.has('URI')) {\n                        this._url = value;\n                        linkDict.update('URI', value);\n                        if (!(linkSource instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference)) {\n                            this._dictionary._updated = linkDict._updated;\n                        }\n                    }\n                }\n                else {\n                    this._url = value;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfTextWebLinkAnnotation._load = function (page, dictionary) {\n        var annot = new PdfTextWebLinkAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfTextWebLinkAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfTextWebLinkAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        if (!this._isActionAdded) {\n            this._addAction();\n            this._isActionAdded = true;\n        }\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n    };\n    PdfTextWebLinkAnnotation.prototype._addAction = function () {\n        var rect = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];\n        if (typeof this.font === 'undefined' || this.font === null) {\n            this.font = this._lineCaptionFont;\n        }\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.top);\n        this._page.graphics.drawString(this._textWebLink, this.font, rect, this._pen, this._brush, format);\n        var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Action'));\n        dictionary.set('S', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('URI'));\n        if (typeof this._url !== 'undefined') {\n            dictionary.set('URI', this._url);\n        }\n        dictionary._updated = true;\n        this._dictionary.set('A', dictionary);\n        this._dictionary.update('Border', [0, 0, 0]);\n    };\n    PdfTextWebLinkAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (!this._isLoaded) {\n            this._postProcess();\n        }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    return PdfTextWebLinkAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfAttachmentAnnotation` class represents the attachment annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new attachment annotation\n * const annotation: PdfAttachmentAnnotation = new PdfAttachmentAnnotation(300, 200, 30, 30, \"Nature.jpg\", imageData);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAttachmentAnnotation = /** @class */ (function (_super) {\n    __extends(PdfAttachmentAnnotation, _super);\n    function PdfAttachmentAnnotation(x, y, width, height, fileName, data) {\n        var _this = _super.call(this) || this;\n        _this._icon = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAttachmentIcon.pushPin;\n        _this._iconString = '';\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('FileAttachment'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        if (typeof fileName !== 'undefined') {\n            _this._fileName = fileName;\n        }\n        _this._stream = new _base_stream__WEBPACK_IMPORTED_MODULE_10__._PdfStream(typeof data === 'string' ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._decode)(data) : data);\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.fileAttachmentAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfAttachmentAnnotation.prototype, \"icon\", {\n        /**\n         * Gets the icon type of the attachment annotation.\n         *\n         * @returns {PdfAttachmentIcon} Annotation icon.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) as PdfAttachmentAnnotation;\n         * // Gets the icon type of the attachment annotation.\n         * let icon: PdfAttachmentIcon = annotation.icon;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Name')) {\n                this._icon = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapAttachmentIcon)(this._dictionary.get('Name').name);\n            }\n            return this._icon;\n        },\n        /**\n         * Sets the icon type of the attachment annotation.\n         *\n         * @param {PdfAttachmentIcon} value Annotation icon.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as  PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfAttachmentAnnotation = page.annotations.at(0) as PdfAttachmentAnnotation;\n         * // Sets the icon type of the attachment annotation.\n         * annotation.icon = PdfAttachmentIcon.pushPin;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._icon = value;\n                this._dictionary.update('Name', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(this._obtainIconName(this._icon)));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfAttachmentAnnotation._load = function (page, dictionary) {\n        var annot = new PdfAttachmentAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfAttachmentAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfAttachmentAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n        this._addAttachment();\n    };\n    PdfAttachmentAnnotation.prototype._addAttachment = function () {\n        if (this._dictionary.has('FS')) {\n            var fileSpecification = this._dictionary.get('FS');\n            if (fileSpecification && fileSpecification.has('EF')) {\n                var embeddedFile = fileSpecification.get('EF');\n                if (embeddedFile && embeddedFile.has('F')) {\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(embeddedFile, this._crossReference, 'F');\n                }\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary, this._crossReference, 'FS');\n        }\n        var fileSpectDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        fileSpectDictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Filespec'));\n        fileSpectDictionary.set('Desc', this._fileName);\n        fileSpectDictionary.set('F', this._fileName);\n        fileSpectDictionary.set('UF', this._fileName);\n        var fileDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        fileDictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('EmbeddedFile'));\n        var paramsDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        var dateTime = new Date();\n        paramsDictionary.set('CreationDate', dateTime.toTimeString());\n        paramsDictionary.set('ModDate', new Date().toTimeString());\n        paramsDictionary.set('Size', this._stream.length);\n        fileDictionary.set('Params', paramsDictionary);\n        this._stream.dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        this._stream.dictionary = fileDictionary;\n        fileDictionary._crossReference = this._crossReference;\n        var char1 = this._crossReference._newLine.charCodeAt(0);\n        var char2 = this._crossReference._newLine.charCodeAt(1);\n        var buffer = [char1, char2, 37, 80, 68, 70, 45];\n        fileDictionary._crossReference._writeObject(this._stream, buffer);\n        var reference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(reference, this._stream);\n        fileDictionary._updated = true;\n        var efileDictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        efileDictionary.set('F', reference);\n        fileSpectDictionary.set('EF', efileDictionary);\n        var fsReference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(fsReference, fileSpectDictionary);\n        fileSpectDictionary._updated = true;\n        this._dictionary.update('FS', fsReference);\n    };\n    PdfAttachmentAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (!this._isLoaded) {\n            this._postProcess();\n        }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    PdfAttachmentAnnotation.prototype._obtainIconName = function (icon) {\n        switch (icon) {\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAttachmentIcon.pushPin:\n                this._iconString = 'PushPin';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAttachmentIcon.tag:\n                this._iconString = 'Tag';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAttachmentIcon.graph:\n                this._iconString = 'Graph';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAttachmentIcon.paperClip:\n                this._iconString = 'Paperclip';\n                break;\n        }\n        return this._iconString;\n    };\n    return PdfAttachmentAnnotation;\n}(PdfComment));\n\n/**\n * `Pdf3DAnnotation` class represents the 3D annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: Pdf3DAnnotation = page.annotations.at(0) as Pdf3DAnnotation;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar Pdf3DAnnotation = /** @class */ (function (_super) {\n    __extends(Pdf3DAnnotation, _super);\n    /**\n     * Initializes a new instance of the `Pdf3DAnnotation` class.\n     *\n     * @private\n     */\n    function Pdf3DAnnotation() {\n        var _this = _super.call(this) || this;\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.movieAnnotation;\n        return _this;\n    }\n    Pdf3DAnnotation._load = function (page, dictionary) {\n        var annot = new Pdf3DAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    Pdf3DAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    Pdf3DAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    return Pdf3DAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfTextMarkupAnnotation` class represents the text markup annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new text markup annotation\n * let annotation: PdfTextMarkupAnnotation = new PdfTextMarkupAnnotation('Text markup', 50, 100, 100, 50);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfTextMarkupAnnotation = /** @class */ (function (_super) {\n    __extends(PdfTextMarkupAnnotation, _super);\n    function PdfTextMarkupAnnotation(text, x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._textMarkupType = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.highlight;\n        _this._quadPoints = new Array(8);\n        _this._boundsCollection = [];\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        if (typeof text !== 'undefined') {\n            _this._text = text;\n        }\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.textMarkupAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfTextMarkupAnnotation.prototype, \"bounds\", {\n        /**\n         * Gets the bounds of the text markup annotation.\n         *\n         * @returns {{x: number, y: number, width: number, height: number}} Bounds.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Gets the bounds of the annotation.\n         * let bounds: {x: number, y: number, width: number, height: number} = annotation.bounds;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded) {\n                this._bounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._calculateBounds)(this._dictionary, this._page);\n            }\n            return this._bounds;\n        },\n        /**\n         * Sets the bounds of the text markup annotation.\n         *\n         * @param {{x: number, y: number, width: number, height: number}} value bounds.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Sets the bounds of the annotation.\n         * annotation.bounds = {x: 10, y: 10, width: 150, height: 5};\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value) {\n                if (this._isLoaded) {\n                    if ((value.x !== this.bounds.x) || (value.y !== this.bounds.y) ||\n                        (value.width !== this.bounds.width) || (value.height !== this.bounds.height)) {\n                        var size = this._page.size;\n                        if (size) {\n                            var y = size[1] - (value.y + value.height);\n                            var height = y + value.height;\n                            this._dictionary.update('Rect', [value.x, y, value.x + value.width, height]);\n                            this._bounds = value;\n                            this._isChanged = true;\n                        }\n                    }\n                }\n                else {\n                    this._bounds = value;\n                    var nativeRectangle = this._obtainNativeRectangle();\n                    this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._fromRectangle)({ x: nativeRectangle[0], y: nativeRectangle[1], width: nativeRectangle[2], height: nativeRectangle[3] }));\n                    this._isChanged = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfTextMarkupAnnotation.prototype, \"textMarkUpColor\", {\n        /**\n         * Gets the text markup color of the annotation.\n         *\n         * @returns {number[]} Text markup color as R, G, B color array in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Gets the textMarkUp Color type of the attachment annotation.\n         * let textMarkUpColor: number[] = annotation.textMarkUpColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._textMarkUpColor === 'undefined' && this._dictionary.has('C')) {\n                this._textMarkUpColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(this._dictionary.getArray('C'));\n            }\n            return this._textMarkUpColor;\n        },\n        /**\n         * Sets the text markup color of the annotation.\n         *\n         * @param {number[]} value R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Sets the textMarkUp Color type of the attachment annotation.\n         * annotation.textMarkUpColor = [255, 255, 255];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value.length === 3) {\n                var extColor = this.color;\n                if (!this._isLoaded ||\n                    typeof extColor === 'undefined' ||\n                    (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {\n                    this._color = value;\n                    this._textMarkUpColor = value;\n                    this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(3)),\n                        Number.parseFloat((value[1] / 255).toFixed(3)),\n                        Number.parseFloat((value[2] / 255).toFixed(3))]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfTextMarkupAnnotation.prototype, \"textMarkupType\", {\n        /**\n         * Gets the markup type of the annotation.\n         *\n         * @returns {PdfTextMarkupAnnotationType} Markup type.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Gets the markup type of the annotation.\n         * let textMarkupType: PdfTextMarkupAnnotationType = annotation.textMarkupType;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Subtype')) {\n                var text = this._dictionary.get('Subtype');\n                this._textMarkupType = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapMarkupAnnotationType)(text.name);\n            }\n            return this._textMarkupType;\n        },\n        /**\n         * Sets the markup type of the annotation.\n         *\n         * @param {PdfTextMarkupAnnotationType} value Markup type.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Sets the markup type of the annotation.\n         * annotation.textMarkupType = PdfTextMarkupAnnotationType.squiggly;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._textMarkupType = value;\n                this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMarkupAnnotationType)(value)));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfTextMarkupAnnotation.prototype, \"boundsCollection\", {\n        /**\n         * Gets the markup bounds collection of the annotation.\n         *\n         * @returns {Array<number[]>} Markup bounds.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as  PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation =  page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Gets the markup bounds collection of the annotation.\n         * let boundsCollection : Array<number[]> = annotation.boundsCollection;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded) {\n                var collection = [];\n                if (this._dictionary.has('QuadPoints')) {\n                    var points = this._dictionary.getArray('QuadPoints');\n                    if (points && points.length > 0) {\n                        var count = points.length / 8;\n                        for (var i = 0; i < count; i++) {\n                            var x = points[4 + (i * 8)] - points[i * 8];\n                            var y = points[5 + (i * 8)] - points[1 + (i * 8)];\n                            var height = Math.sqrt((x * x) + (y * y));\n                            x = points[6 + (i * 8)] - points[4 + (i * 8)];\n                            y = points[7 + (i * 8)] - points[5 + (i * 8)];\n                            var width = Math.sqrt((x * x) + (y * y));\n                            var rect = [points[i * 8], this._page.size[1] - points[1 + (i * 8)], width, height];\n                            collection.push(rect);\n                        }\n                    }\n                }\n                return collection;\n            }\n            return this._boundsCollection;\n        },\n        /**\n         * Sets the markup bounds collection of the annotation.\n         *\n         * @param {Array<number[]>} value Markup bounds.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfTextMarkupAnnotation = page.annotations.at(0) as PdfTextMarkupAnnotation;\n         * // Sets the markup bounds collection of the  annotation.\n         * annotation.boundsCollection = [[50, 50, 100, 100], [201, 101, 61, 31], [101, 401, 61, 31]];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!this._isLoaded && typeof value !== 'undefined') {\n                if (value.length > 0) {\n                    this._quadPoints = new Array((value.length * 8));\n                    for (var i = 0; i < value.length; i++) {\n                        this._boundsCollection.push(value[Number.parseInt(i.toString(), 10)]);\n                    }\n                }\n                else {\n                    this._quadPoints = new Array(8);\n                    this._boundsCollection = value;\n                }\n                this._isChanged = true;\n            }\n            if (this._isLoaded && typeof value !== 'undefined') {\n                var isChanged = false;\n                if (this.boundsCollection.length === value.length) {\n                    for (var i = 0; i < value.length; i++) {\n                        var values = value[Number.parseInt(i.toString(), 10)];\n                        for (var j = 0; j < values.length; j++) {\n                            if (value[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)] !==\n                                this.boundsCollection[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]) {\n                                isChanged = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                else {\n                    isChanged = true;\n                }\n                if (isChanged) {\n                    this._quadPoints = new Array((value.length * 8));\n                    var pageHeight = this._page.size[1];\n                    for (var i = 0; i < value.length; i++) {\n                        this._quadPoints[0 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0];\n                        this._quadPoints[1 + (Number.parseInt(i.toString(), 10) * 8)] = pageHeight -\n                            value[Number.parseInt(i.toString(), 10)][1];\n                        this._quadPoints[2 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0] +\n                            value[Number.parseInt(i.toString(), 10)][2];\n                        this._quadPoints[3 + (Number.parseInt(i.toString(), 10) * 8)] = pageHeight -\n                            value[Number.parseInt(i.toString(), 10)][1];\n                        this._quadPoints[4 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0];\n                        this._quadPoints[5 + (Number.parseInt(i.toString(), 10) * 8)] = this._quadPoints[1 + (i * 8)] -\n                            value[Number.parseInt(i.toString(), 10)][3];\n                        this._quadPoints[6 + (Number.parseInt(i.toString(), 10) * 8)] = value[Number.parseInt(i.toString(), 10)][0] +\n                            value[Number.parseInt(i.toString(), 10)][2];\n                        this._quadPoints[7 + (Number.parseInt(i.toString(), 10) * 8)] = this._quadPoints[5 +\n                            (Number.parseInt(i.toString(), 10) * 8)];\n                    }\n                    this._dictionary.update('QuadPoints', this._quadPoints);\n                    this._isChanged = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfTextMarkupAnnotation._load = function (page, dictionary) {\n        var annot = new PdfTextMarkupAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfTextMarkupAnnotation.prototype._obtainNativeRectangle = function () {\n        var nativeRectangle = [this._bounds.x, this._bounds.y + this._bounds.height, this._bounds.width, this._bounds.height];\n        var cropOrMediaBox;\n        if (this._page) {\n            var size = this._page.size;\n            nativeRectangle[1] = size[1] - nativeRectangle[1];\n            cropOrMediaBox = this._getCropOrMediaBox();\n        }\n        if (cropOrMediaBox) {\n            if (cropOrMediaBox[3] < 0) {\n                var yCrop = cropOrMediaBox[1];\n                var heightCrop = cropOrMediaBox[3];\n                cropOrMediaBox[1] = heightCrop;\n                cropOrMediaBox[3] = yCrop;\n            }\n            if (cropOrMediaBox.length > 2 && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {\n                nativeRectangle[0] += cropOrMediaBox[0];\n                if (this._page && this._page._pageDictionary.has('MediaBox') && !this._page._pageDictionary.has('CropBox') && cropOrMediaBox[1] > 0 && cropOrMediaBox[3] === 0) {\n                    nativeRectangle[1] += cropOrMediaBox[3];\n                }\n                else {\n                    nativeRectangle[1] += cropOrMediaBox[1];\n                }\n            }\n        }\n        return nativeRectangle;\n    };\n    PdfTextMarkupAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfTextMarkupAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            dictionary.set('W', this.border.width);\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (!this._dictionary.has('C')) {\n            this._isTransparentColor = true;\n        }\n        var size = this._page.size;\n        this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMarkupAnnotationType)(this._textMarkupType)));\n        if (this._isChanged) {\n            this._setQuadPoints(size);\n            this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n        }\n        if (this._setAppearance) {\n            this._appearanceTemplate = this._createMarkupAppearance();\n            if (!this._isLoaded && this._boundsCollection.length > 1 && this._isChanged) {\n                var native = this._obtainNativeRectangle();\n                this._dictionary.update('Rect', [native[0], native[1], native[0] + native[2], native[1] + native[3]]);\n            }\n            if (this._dictionary.has('AP')) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n            }\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n            this._appearanceTemplate._content.dictionary._updated = true;\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            this._appearanceTemplate._content.reference = reference;\n            dictionary.set('N', reference);\n            dictionary._updated = true;\n            this._dictionary.set('AP', dictionary);\n        }\n        if (typeof this._text !== 'undefined' && this._text !== null) {\n            this._dictionary.set('Contents', this._text);\n        }\n        this._isChanged = false;\n    };\n    PdfTextMarkupAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createMarkupAppearance();\n                if (!isFlatten) {\n                    if (this._dictionary.has('AP')) {\n                        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n                    }\n                    var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n                    this._appearanceTemplate._content.dictionary._updated = true;\n                    var reference = this._crossReference._getNextReference();\n                    this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n                    this._appearanceTemplate._content.reference = reference;\n                    dictionary.set('N', reference);\n                    dictionary._updated = true;\n                    this._dictionary.set('AP', dictionary);\n                }\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    if (appearanceStream) {\n                        var reference = dictionary.getRaw('N');\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess();\n            if (!this._appearanceTemplate) {\n                if (isFlatten) {\n                    if (!this._dictionary.has('AP')) {\n                        this._appearanceTemplate = this._createMarkupAppearance();\n                    }\n                    else {\n                        var dictionary = this._dictionary.get('AP');\n                        if (dictionary && dictionary.has('N')) {\n                            var appearanceStream = dictionary.get('N');\n                            if (appearanceStream) {\n                                var reference = dictionary.getRaw('N');\n                                if (reference) {\n                                    appearanceStream.reference = reference;\n                                }\n                                this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            if (!this._appearanceTemplate._content.dictionary.has('Matrix') && !this._isLoaded) {\n                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                if (box) {\n                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                }\n            }\n            if (isNormalMatrix && typeof this._page.rotation !== 'undefined' && this._page.rotation !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0) {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n            else if (isNormalMatrix && this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary, this._appearanceTemplate)) {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n            else if (!this._dictionary.has('AP') && this._appearanceTemplate) {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n    };\n    PdfTextMarkupAnnotation.prototype._createMarkupAppearance = function () {\n        var width = 0;\n        var height = 0;\n        var rectangle;\n        if (this.boundsCollection.length > 1) {\n            var pdfPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            for (var i = 0; i < this.boundsCollection.length; i++) {\n                var bounds = [];\n                bounds[0] = this.boundsCollection[Number.parseInt(i.toString(), 10)][0];\n                bounds[1] = this.boundsCollection[Number.parseInt(i.toString(), 10)][1];\n                bounds[2] = this.boundsCollection[Number.parseInt(i.toString(), 10)][2];\n                bounds[3] = this.boundsCollection[Number.parseInt(i.toString(), 10)][3];\n                pdfPath.addRectangle(bounds[0], bounds[1], bounds[2], bounds[3]);\n            }\n            var rect = pdfPath._getBounds();\n            rectangle = { x: rect[0], y: rect[1], width: rect[2], height: rect[3] };\n            this.bounds = rectangle;\n            width = rectangle.width;\n            height = rectangle.height;\n        }\n        else {\n            if (this._dictionary.has('QuadPoints')) {\n                var quadPoints = this._dictionary.get('QuadPoints');\n                if (this._quadPoints !== null) {\n                    for (var i = 0; i < (quadPoints.length / 8); i++) {\n                        if (this._isLoaded) {\n                            var point = new Array();\n                            var j = 0;\n                            for (var k = 0; k < quadPoints.length;) {\n                                var x1 = quadPoints[Number.parseInt(k.toString(), 10)];\n                                var y1 = quadPoints[k + 1];\n                                point[Number.parseInt(j.toString(), 10)] = [x1, y1];\n                                k = k + 2;\n                                j++;\n                            }\n                            var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n                            path._addLines(point);\n                            var rect = path._getBounds();\n                            rectangle = { x: rect[0], y: rect[1], width: rect[2], height: rect[3] };\n                            width = rectangle.width;\n                            height = rectangle.height;\n                        }\n                        else {\n                            var x = Math.floor(quadPoints[4 + (i * 8)]) - Math.floor(quadPoints[0 + (i * 8)]);\n                            var y = Math.floor(quadPoints[5 + (i * 8)]) - Math.floor(quadPoints[1 + (i * 8)]);\n                            height = Math.sqrt((x * x) + (y * y));\n                            x = Math.floor(quadPoints[6 + (i * 8)]) - Math.floor(quadPoints[4 + (i * 8)]);\n                            y = Math.floor(quadPoints[7 + (i * 8)]) - Math.floor(quadPoints[5 + (i * 8)]);\n                            width = Math.sqrt((x * x) + (y * y));\n                            this.bounds = { x: this.bounds.x, y: this.bounds.y, width: width, height: height };\n                        }\n                    }\n                }\n            }\n        }\n        var nativeRectangle = [0, 0, width, height];\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n        var graphics = template.graphics;\n        if (typeof this.opacity !== 'undefined') {\n            graphics.setTransparency(this.opacity, this.opacity, _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBlendMode.multiply);\n        }\n        if (this.textMarkUpColor) {\n            var pdfPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.textMarkUpColor, this.border.width);\n            var brush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.textMarkUpColor);\n            var x1 = 0;\n            var y1 = 0;\n            var w1 = 0;\n            var h1 = 0;\n            if (this.boundsCollection.length > 1) {\n                for (var i = 0; i < this.boundsCollection.length; i++) {\n                    var bounds = [];\n                    bounds[0] = this.boundsCollection[Number.parseInt(i.toString(), 10)][0];\n                    bounds[1] = this.boundsCollection[Number.parseInt(i.toString(), 10)][1];\n                    bounds[2] = this.boundsCollection[Number.parseInt(i.toString(), 10)][2];\n                    bounds[3] = this.boundsCollection[Number.parseInt(i.toString(), 10)][3];\n                    if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.highlight) {\n                        graphics.drawRectangle(bounds[0] - rectangle.x, bounds[1] - rectangle.y, bounds[2], bounds[3], brush);\n                    }\n                    else if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.underline) {\n                        x1 = bounds[0] - rectangle.x;\n                        y1 = (bounds[1] - rectangle.y) + (bounds[3] - ((bounds[3] / 2) / 3));\n                        w1 = bounds[2] + (bounds[0] - rectangle.x);\n                        h1 = (bounds[1] - rectangle.y) + (bounds[3] - ((bounds[3] / 2) / 3));\n                        graphics.drawLine(pdfPen, x1, y1, w1, h1);\n                    }\n                    else if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.strikeOut) {\n                        x1 = bounds[0] - rectangle.x;\n                        y1 = (bounds[1] - rectangle.y) + (bounds[3] - (bounds[3] / 2));\n                        w1 = bounds[2] + (bounds[0] - rectangle.x);\n                        h1 = (bounds[1] - rectangle.y) + (bounds[3] - (bounds[3] / 2));\n                        graphics.drawLine(pdfPen, x1, y1, w1, h1);\n                    }\n                    else if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.squiggly) {\n                        pdfPen._width = bounds[3] * 0.02;\n                        graphics.save();\n                        graphics.translateTransform(bounds[0] - rectangle.x, (bounds[1] - rectangle.y));\n                        graphics.setClip([0, 0, bounds[2], bounds[3]]);\n                        graphics.drawPath(this._drawSquiggly(bounds[2], bounds[3]), pdfPen);\n                        graphics.restore();\n                    }\n                }\n            }\n            else {\n                if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.highlight) {\n                    graphics.drawRectangle(0, 0, width, height, brush);\n                }\n                else if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.underline) {\n                    graphics.drawLine(pdfPen, 0, height - ((height / 2) / 3), width, height - ((height / 2) / 3));\n                }\n                else if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.strikeOut) {\n                    graphics.drawLine(pdfPen, 0, height / 2, width, height / 2);\n                }\n                else if (this.textMarkupType === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextMarkupAnnotationType.squiggly) {\n                    pdfPen._width = height * 0.02;\n                    graphics.drawPath(this._drawSquiggly(Math.round(width), Math.round(height)), pdfPen);\n                }\n                if (this._isLoaded) {\n                    var defaultRect = [rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height];\n                    var rect = this._setAppearance ? (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this) : defaultRect;\n                    this._dictionary.update('Rect', rect);\n                }\n            }\n        }\n        return template;\n    };\n    PdfTextMarkupAnnotation.prototype._drawSquiggly = function (width, height) {\n        if (Math.floor(width) % 2 !== 0 || Math.round(width) > width) {\n            width = Math.floor(width) + 1;\n        }\n        var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        var pathPoints = new Array();\n        var pathPointsCount = Math.ceil((width / height) * 16);\n        var length = width / (pathPointsCount / 2);\n        var location = parseFloat(((length + length) * 0.6).toFixed(2));\n        var zigZag = location;\n        var x = 0;\n        for (var i = 0; i < pathPointsCount; i++) {\n            var y = ((height - location) + zigZag) - (height * 0.02);\n            var temp = [x, parseFloat(y.toFixed(2))];\n            pathPoints.push(temp);\n            if (zigZag === 0) {\n                zigZag = location;\n            }\n            else {\n                zigZag = 0;\n            }\n            x = x + length;\n        }\n        path._addLines(pathPoints);\n        return path;\n    };\n    PdfTextMarkupAnnotation.prototype._setQuadPoints = function (pageSize) {\n        var textQuadLocation = [];\n        var pageHeight = pageSize[1];\n        var margins;\n        if (this._page && this._page._isNew && this._page._pageSettings && this._page._pageSettings.margins) {\n            var margin = this._page._pageSettings.margins;\n            margins = { left: margin.left, top: margin.top, right: margin.right, bottom: margin.bottom };\n        }\n        else {\n            margins = { left: 0, top: 0, right: 0, bottom: 0 };\n        }\n        if (this.bounds.x !== 0 && this.bounds.y !== 0 && this.bounds.width !== 0 && this.bounds.height !== 0) {\n            this._boundsCollection[0] = [this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height];\n        }\n        var noofRect = this._quadPoints.length / 8;\n        var cropOrMediaBox = this._getMediaOrCropBox(this._page);\n        var isContainscropOrMediaBox = false;\n        if (!this._isLoaded && cropOrMediaBox && cropOrMediaBox.length > 3 && !this.flatten) {\n            var cropOrMediaBoxX = cropOrMediaBox[0];\n            var cropOrMediaBoxY = cropOrMediaBox[1];\n            if (cropOrMediaBoxX !== 0 || cropOrMediaBoxY !== 0) {\n                for (var i = 0; i < noofRect; i++) {\n                    var locationX = this._boundsCollection[Number.parseInt(i.toString(), 10)][0] + margins.left + cropOrMediaBoxX;\n                    var locationY = cropOrMediaBoxY + margins.top;\n                    textQuadLocation[0 + (i * 8)] = locationX + margins.left;\n                    textQuadLocation[1 + (i * 8)] = (pageHeight - (-locationY)) - margins.top -\n                        this._boundsCollection[Number.parseInt(i.toString(), 10)][1];\n                    textQuadLocation[2 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) +\n                        margins.left;\n                    textQuadLocation[3 + (i * 8)] = (pageHeight - (-locationY)) - margins.top -\n                        this._boundsCollection[Number.parseInt(i.toString(), 10)][1];\n                    textQuadLocation[4 + (i * 8)] = locationX + margins.left;\n                    textQuadLocation[5 + (i * 8)] = (textQuadLocation[1 + (i * 8)] -\n                        this._boundsCollection[Number.parseInt(i.toString(), 10)][3]);\n                    textQuadLocation[6 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) +\n                        margins.left;\n                    textQuadLocation[7 + (i * 8)] = textQuadLocation[5 + (i * 8)];\n                }\n                isContainscropOrMediaBox = true;\n            }\n        }\n        if (!isContainscropOrMediaBox) {\n            for (var i = 0; i < noofRect; i++) {\n                var locationX = this._boundsCollection[Number.parseInt(i.toString(), 10)][0];\n                var locationY = this._boundsCollection[Number.parseInt(i.toString(), 10)][1];\n                textQuadLocation[0 + (i * 8)] = locationX + margins.left;\n                textQuadLocation[1 + (i * 8)] = (pageHeight - locationY) - margins.top;\n                textQuadLocation[2 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) + margins.left;\n                textQuadLocation[3 + (i * 8)] = (pageHeight - locationY) - margins.top;\n                textQuadLocation[4 + (i * 8)] = locationX + margins.left;\n                textQuadLocation[5 + (i * 8)] = (textQuadLocation[1 + (i * 8)] -\n                    this._boundsCollection[Number.parseInt(i.toString(), 10)][3]);\n                textQuadLocation[6 + (i * 8)] = (locationX + this._boundsCollection[Number.parseInt(i.toString(), 10)][2]) + margins.left;\n                textQuadLocation[7 + (i * 8)] = textQuadLocation[5 + (i * 8)];\n            }\n        }\n        this._points = textQuadLocation;\n        this._dictionary.set('QuadPoints', this._points);\n    };\n    return PdfTextMarkupAnnotation;\n}(PdfComment));\n\n/**\n * `PdfWatermarkAnnotation` class represents the watermark annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new water mark annotation\n * const annotation: PdfWatermarkAnnotation = new PdfWatermarkAnnotation('Water Mark', 50, 100, 100, 50);\n * // Set the color of the annotation\n * annotation.color = [0, 0, 0];\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfWatermarkAnnotation = /** @class */ (function (_super) {\n    __extends(PdfWatermarkAnnotation, _super);\n    function PdfWatermarkAnnotation(text, x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._watermarkText = '';\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Watermark'));\n        if (typeof text !== 'undefined') {\n            _this._watermarkText = text;\n            _this.text = text;\n        }\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.watermarkAnnotation;\n        return _this;\n    }\n    PdfWatermarkAnnotation._load = function (page, dictionary) {\n        var annot = new PdfWatermarkAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfWatermarkAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfWatermarkAnnotation.prototype._postProcess = function () {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (typeof this.color === 'undefined') {\n            this.color = [0, 0, 0];\n        }\n        this._appearanceTemplate = this._createWatermarkAppearance();\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n        if (typeof this.opacity !== 'undefined' && this._opacity !== 1.0) {\n            this._dictionary.set('CA', this._opacity);\n        }\n    };\n    PdfWatermarkAnnotation.prototype._createWatermarkAppearance = function () {\n        var font = this._obtainFont();\n        if ((typeof font === 'undefined' || font === null) || ((!this._isLoaded || (this._page && this._page._isDuplicate)) && font.size === 1)) {\n            font = this._lineCaptionFont;\n            this._pdfFont = font;\n        }\n        this._rotateAngle = this._getRotationAngle();\n        if (typeof this.rotationAngle !== 'undefined' && this._rotate !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0 || this._rotateAngle !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0) {\n            if (this._rotateAngle === 0) {\n                this._rotateAngle = this.rotationAngle * 90;\n            }\n            this.bounds = this._getRotatedBounds(this.bounds, this._rotateAngle);\n        }\n        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];\n        var appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, nativeRectangle);\n        appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        var template = appearance.normal;\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._rotateAngle);\n        var graphics = appearance.normal.graphics;\n        var width = this.border.width / 2;\n        var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.top);\n        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.color, width);\n        var backBrush;\n        if (this.innerColor) {\n            backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._innerColor);\n        }\n        if (this._isLoaded) {\n            if (this._dictionary.has('Contents')) {\n                this._watermarkText = this._dictionary.get('Contents');\n            }\n            this._dictionary.update('Contents', this._watermarkText);\n        }\n        else {\n            this._dictionary.update('Contents', this._watermarkText);\n        }\n        if (typeof this._watermarkText !== 'undefined') {\n            graphics.drawString(this._watermarkText, font, [0, 0, 0, 0], borderPen, backBrush, format);\n        }\n        if (this._dictionary.has('AP')) {\n            var dictionary_1 = this._dictionary.get('AP'); // eslint-disable-line\n            if (dictionary_1 && dictionary_1 instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(dictionary_1, this._crossReference, 'N');\n            }\n        }\n        var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        graphics._template._content.dictionary._updated = true;\n        var reference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(reference, graphics._template._content);\n        graphics._template._content.reference = reference;\n        dictionary.set('N', reference);\n        dictionary._updated = true;\n        this._dictionary.set('AP', dictionary);\n        return template;\n    };\n    PdfWatermarkAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (!isFlatten) {\n                this._appearanceTemplate = this._createWatermarkAppearance();\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    if (appearanceStream) {\n                        var reference = dictionary.getRaw('N');\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess();\n            if (!this._appearanceTemplate) {\n                if (isFlatten) {\n                    if (!this._dictionary.has('AP')) {\n                        this._appearanceTemplate = this._createWatermarkAppearance();\n                    }\n                    else {\n                        var dictionary = this._dictionary.get('AP');\n                        if (dictionary && dictionary.has('N')) {\n                            var appearanceStream = dictionary.get('N');\n                            if (appearanceStream) {\n                                var reference = dictionary.getRaw('N');\n                                if (reference) {\n                                    appearanceStream.reference = reference;\n                                }\n                                this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {\n                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                if (box) {\n                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                }\n            }\n            this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n    };\n    return PdfWatermarkAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfRubberStampAnnotation` class represents the rubber stamp annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new rubber stamp annotation\n * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation (50, 100, 100, 50);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfRubberStampAnnotation = /** @class */ (function (_super) {\n    __extends(PdfRubberStampAnnotation, _super);\n    function PdfRubberStampAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._icon = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.draft;\n        _this._stampWidth = 0;\n        _this._iconString = '';\n        _this.rotateAngle = 0;\n        _this._alterRotateBounds = true;\n        _this._stampAppearanceFont = new _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfStandardFont(_fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontFamily.helvetica, 20, _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.italic | _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.bold);\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Stamp'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.rubberStampAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfRubberStampAnnotation.prototype, \"icon\", {\n        /**\n         * Gets the icon type of the rubber stamp annotation.\n         *\n         * @returns {PdfRubberStampAnnotationIcon} Annotation icon.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;\n         * // Gets the icon type of the rubber stamp annotation.\n         * let icon: PdfRubberStampAnnotationIcon = annotation.icon;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Name')) {\n                this._icon = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapRubberStampIcon)(this._dictionary.get('Name').name);\n            }\n            return this._icon;\n        },\n        /**\n         * Sets the icon type of the rubber stamp annotation.\n         *\n         * @param {PdfRubberStampAnnotationIcon} value Annotation icon.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;\n         * // Sets the icon type of the rubber stamp annotation.\n         * annotation.icon = PdfRubberStampAnnotationIcon.completed;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._icon = value;\n                this._dictionary.update('Name', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('#' + this._obtainIconName(this._icon)));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRubberStampAnnotation.prototype, \"appearance\", {\n        /**\n         * Get the appearance of the rubber stamp annotation. (Read only)\n         *\n         * @returns {PdfAppearance} Returns the appearance of the annotation.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Create a new rubber stamp annotation\n         * const annotation: PdfRubberStampAnnotation = new PdfRubberStampAnnotation(50, 100, 100, 50);\n         * // Get the appearance of the annotation\n         * let appearance: PdfAppearance = annotation.appearance;\n         * // Access the normal template of the appearance\n         * let template: PdfTemplate = appearance.normal;\n         * // Create new image object by using JPEG image data as Base64 string format\n         * let image: PdfImage = new PdfBitmap('/9j/4AAQSkZJRgABAQEAkACQAAD/4....QB//Z');\n         * // Draw the image as the custom appearance for the annotation\n         * template.graphics.drawImage(image, 0, 0, 100, 50);\n         * // Add annotation to the page\n         * page.annotations.add(annotation);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded) {\n                return null;\n            }\n            if (typeof this._appearance === 'undefined') {\n                var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];\n                this._appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, nativeRectangle);\n                this._appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n            }\n            return this._appearance;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create an appearance template for a rubber stamp annotation.\n     *\n     * @returns {PdfTemplate} Returns the appearance template of the annotation.\n     * ```typescript\n     * // Load an existing PDF document\n     * let document: PdfDocument = new PdfDocument(data, password);\n     * // Get the first page\n     * let page: PdfPage = document.getPage(0) as PdfPage;\n     * // Get the first annotation of the page\n     * let annotation: PdfRubberStampAnnotation = page.annotations.at(0) as PdfRubberStampAnnotation;\n     * // Gets the appearance template of the annotation.\n     * let template: PdfTemplate = annotation.createTemplate();\n     * // Save the document\n     * document.save('output.pdf');\n     * // Destroy the document\n     * document.destroy();\n     * ```\n     */\n    PdfRubberStampAnnotation.prototype.createTemplate = function () {\n        var template;\n        if (this._isLoaded) {\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    if (appearanceStream) {\n                        template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate();\n                        template._isExported = true;\n                        var templateDictionary = appearanceStream.dictionary;\n                        var matrix = templateDictionary.getArray('Matrix');\n                        var bounds = templateDictionary.getArray('BBox');\n                        if (matrix) {\n                            var mMatrix = [];\n                            for (var i = 0; i < matrix.length; i++) {\n                                var value = matrix[Number.parseInt(i.toString(), 10)];\n                                mMatrix[Number.parseInt(i.toString(), 10)] = value;\n                            }\n                            if (bounds && bounds.length > 3) {\n                                var rect = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._toRectangle)(bounds);\n                                var rectangle = this._transformBBox(rect, mMatrix);\n                                template._size = [rectangle[2], rectangle[3]];\n                                template._templateOriginalSize = [rect.width, rect.height];\n                            }\n                        }\n                        else if (bounds) {\n                            templateDictionary.update('Matrix', [1, 0, 0, 1, -bounds[0], -bounds[1]]);\n                            template._size = [bounds[2], bounds[3]];\n                        }\n                        template._exportStream(dictionary, this._crossReference);\n                    }\n                }\n            }\n            else {\n                template = this._createRubberStampAppearance();\n            }\n        }\n        return template;\n    };\n    Object.defineProperty(PdfRubberStampAnnotation.prototype, \"_innerTemplateBounds\", {\n        get: function () {\n            var innerBounds;\n            if (this._isLoaded) {\n                innerBounds = this._obtainInnerBounds();\n                innerBounds.x = this.bounds.x;\n                innerBounds.y = this.bounds.y;\n            }\n            return innerBounds;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfRubberStampAnnotation._load = function (page, dictionary) {\n        var annot = new PdfRubberStampAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfRubberStampAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfRubberStampAnnotation.prototype._postProcess = function () {\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (!this._dictionary.has('C')) {\n            this._isTransparentColor = true;\n        }\n        if (this._dictionary.has('AP') && this._isLoaded && !this._isRotated) {\n            this._parseStampAppearance();\n        }\n        else {\n            this._appearanceTemplate = this._createRubberStampAppearance();\n        }\n    };\n    PdfRubberStampAnnotation.prototype._transformBBox = function (bBoxValue, matrix) {\n        var xCoordinate = [];\n        var yCoordinate = [];\n        var point1 = this._transformPoint(bBoxValue.x, bBoxValue.y + bBoxValue.height, matrix);\n        xCoordinate[0] = point1[0];\n        yCoordinate[0] = point1[1];\n        var point2 = this._transformPoint(bBoxValue.x + bBoxValue.width, bBoxValue.y, matrix);\n        xCoordinate[1] = point2[0];\n        yCoordinate[1] = point2[1];\n        var point3 = this._transformPoint(bBoxValue.x, bBoxValue.y, matrix);\n        xCoordinate[2] = point3[0];\n        yCoordinate[2] = point3[1];\n        var point4 = this._transformPoint(bBoxValue.x + bBoxValue.width, bBoxValue.y + bBoxValue.height, matrix);\n        xCoordinate[3] = point4[0];\n        yCoordinate[3] = point4[1];\n        var rect = [this._minValue(xCoordinate), this._minValue(yCoordinate),\n            this._maxValue(xCoordinate), this._maxValue(yCoordinate)];\n        return rect;\n    };\n    PdfRubberStampAnnotation.prototype._transformPoint = function (x, y, matrix) {\n        var point = [];\n        point[0] = x * matrix[0] + y * matrix[2] + matrix[4];\n        point[1] = x * matrix[1] + y * matrix[3] + matrix[5];\n        return point;\n    };\n    PdfRubberStampAnnotation.prototype._minValue = function (values) {\n        var minimum = values[0];\n        for (var i = 1; i < values.length; i++) {\n            if (values[Number.parseInt(i.toString(), 10)] < minimum) {\n                minimum = values[Number.parseInt(i.toString(), 10)];\n            }\n        }\n        return minimum;\n    };\n    PdfRubberStampAnnotation.prototype._maxValue = function (values) {\n        var maximum = values[0];\n        for (var i = 1; i < values.length; i++) {\n            if (values[Number.parseInt(i.toString(), 10)] > maximum) {\n                maximum = values[Number.parseInt(i.toString(), 10)];\n            }\n        }\n        return maximum;\n    };\n    PdfRubberStampAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        var isTransformBBox = false;\n        if (this._isLoaded && (this._setAppearance || isFlatten || this._isExport)) {\n            if ((!isFlatten && !this._isExport) || this._setAppearance || this._isRotated) {\n                this._appearanceTemplate = this._createRubberStampAppearance();\n            }\n            if (!this._appearanceTemplate && (this._isExport || isFlatten) && this._dictionary.has('AP')) {\n                isTransformBBox = this._parseStampAppearance();\n            }\n        }\n        else {\n            if (!(this._isImported && this._dictionary.has('AP'))) {\n                this._postProcess();\n            }\n            if ((!this._appearanceTemplate) && (isFlatten || this._isImported)) {\n                if (!this._dictionary.has('AP')) {\n                    this._appearanceTemplate = this._createRubberStampAppearance();\n                }\n                else {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        if (appearanceStream) {\n                            var reference = dictionary.getRaw('N');\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {\n                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                if (box) {\n                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                }\n            }\n            if (isTransformBBox) {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isTransformBBox);\n            }\n            else {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n    };\n    PdfRubberStampAnnotation.prototype._parseStampAppearance = function () {\n        var isTransformBBox = false;\n        var dictionary = this._dictionary.get('AP');\n        if (dictionary && dictionary.has('N')) {\n            var appearanceStream = dictionary.get('N');\n            if (appearanceStream) {\n                var reference = dictionary.getRaw('N');\n                if (reference) {\n                    appearanceStream.reference = reference;\n                }\n                var isStamp = false;\n                if (this._type === _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.rubberStampAnnotation) {\n                    var isRotated = false;\n                    var size = void 0;\n                    var rect = void 0;\n                    if (appearanceStream) {\n                        isRotated = (this._page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0 &&\n                            this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0);\n                        if (!isRotated) {\n                            isRotated = (this._page.rotation !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0 &&\n                                this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0);\n                        }\n                    }\n                    this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    isStamp = true;\n                    isTransformBBox = isRotated ? true : false;\n                    if (isTransformBBox) {\n                        var matrix = appearanceStream.dictionary.getArray('Matrix');\n                        if (matrix) {\n                            var mMatrix = [];\n                            for (var i = 0; i < matrix.length; i++) {\n                                var value = matrix[Number.parseInt(i.toString(), 10)];\n                                mMatrix[Number.parseInt(i.toString(), 10)] = value;\n                            }\n                            var bounds = appearanceStream.dictionary.getArray('BBox');\n                            if (bounds && bounds.length > 3) {\n                                rect = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._toRectangle)(bounds);\n                                var rectangle = this._transformBBox(rect, mMatrix);\n                                size = [rectangle[2], rectangle[3]];\n                                this._appearanceTemplate._size = size;\n                            }\n                            else {\n                                size = [rect.width, rect.height];\n                            }\n                        }\n                    }\n                    else if (rect) {\n                        size = [rect.width, rect.height];\n                    }\n                }\n                if (!isStamp) {\n                    this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                }\n            }\n        }\n        return isTransformBBox;\n    };\n    PdfRubberStampAnnotation.prototype._createRubberStampAppearance = function () {\n        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];\n        var appearance;\n        if (this._appearance) {\n            appearance = this._appearance;\n            if (!this._dictionary.has('Name')) {\n                this._dictionary.update('Name', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('#23CustomStamp'));\n            }\n        }\n        else {\n            this._iconString = this._obtainIconName(this.icon);\n            this._dictionary.update('Name', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('#23' + this._iconString));\n            appearance = new _pdf_appearance__WEBPACK_IMPORTED_MODULE_11__.PdfAppearance(this, nativeRectangle);\n            appearance.normal = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        }\n        var template = appearance.normal;\n        if (this._alterRotateBounds && typeof this._rotate !== 'undefined' && (this._rotate !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0 || this._getRotationAngle() !== 0)) {\n            this.rotateAngle = this._getRotationAngle();\n            if (this.rotateAngle === 0) {\n                this.rotateAngle = this.rotationAngle * 90;\n            }\n            this.bounds = this._getRotatedBounds(this.bounds, this.rotateAngle);\n        }\n        else {\n            this.rotateAngle = this._getRotationAngle();\n        }\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this.rotateAngle);\n        if (!this._appearance) {\n            this._drawStampAppearance(template);\n        }\n        if (this._dictionary.has('AP')) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(this._dictionary.get('AP'), this._crossReference, 'N');\n        }\n        var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        template._content.dictionary._updated = true;\n        var reference = this._crossReference._getNextReference();\n        this._crossReference._cacheMap.set(reference, template._content);\n        template._content.reference = reference;\n        dictionary.set('N', reference);\n        dictionary._updated = true;\n        this._dictionary.set('AP', dictionary);\n        this._dictionary.set('Border', [this.border.hRadius, this.border.vRadius, this.border.width]);\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n        return template;\n    };\n    PdfRubberStampAnnotation.prototype._drawStampAppearance = function (template) {\n        var stringFormat = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat();\n        stringFormat.alignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center;\n        stringFormat.lineAlignment = _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle;\n        var backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._obtainBackGroundColor());\n        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this._obtainBorderColor(), this.border.width);\n        var graphics = template.graphics;\n        graphics.save();\n        graphics.scaleTransform(template._size[0] / (this._stampWidth + 4), (template._size[1] / 28));\n        var rubberFont = this._stampAppearanceFont;\n        this._drawRubberStamp(graphics, borderPen, backBrush, rubberFont, stringFormat);\n        graphics.restore();\n    };\n    PdfRubberStampAnnotation.prototype._obtainIconName = function (icon) {\n        switch (icon) {\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.approved:\n                this._iconString = 'Approved';\n                this._stampWidth = 126;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.asIs:\n                this._iconString = 'AsIs';\n                this._stampWidth = 75;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.confidential:\n                this._iconString = 'Confidential';\n                this._stampWidth = 166;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.departmental:\n                this._iconString = 'Departmental';\n                this._stampWidth = 186;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.draft:\n                this._iconString = 'Draft';\n                this._stampWidth = 90;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.experimental:\n                this._iconString = 'Experimental';\n                this._stampWidth = 176;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.expired:\n                this._iconString = 'Expired';\n                this._stampWidth = 116;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.final:\n                this._iconString = 'Final';\n                this._stampWidth = 90;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.forComment:\n                this._iconString = 'ForComment';\n                this._stampWidth = 166;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.forPublicRelease:\n                this._iconString = 'ForPublicRelease';\n                this._stampWidth = 240;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.notApproved:\n                this._iconString = 'NotApproved';\n                this._stampWidth = 186;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.notForPublicRelease:\n                this._iconString = 'NotForPublicRelease';\n                this._stampWidth = 290;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.sold:\n                this._iconString = 'Sold';\n                this._stampWidth = 75;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.topSecret:\n                this._iconString = 'TopSecret';\n                this._stampWidth = 146;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.completed:\n                this._iconString = 'Completed';\n                this._stampWidth = 136;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.void:\n                this._iconString = 'Void';\n                this._stampWidth = 75;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.informationOnly:\n                this._iconString = 'InformationOnly';\n                this._stampWidth = 230;\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.preliminaryResults:\n                this._iconString = 'PreliminaryResults';\n                this._stampWidth = 260;\n                break;\n        }\n        return this._iconString;\n    };\n    PdfRubberStampAnnotation.prototype._obtainBackGroundColor = function () {\n        var color = [];\n        var red;\n        var green;\n        var blue;\n        if (this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.notApproved ||\n            this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.void) {\n            red = 251;\n            green = 222;\n            blue = 221;\n            color = [red, green, blue];\n        }\n        else if (this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.approved ||\n            this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.final ||\n            this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.completed) {\n            red = 229;\n            green = 238;\n            blue = 222;\n            color = [red, green, blue];\n        }\n        else {\n            red = 219;\n            green = 227;\n            blue = 240;\n            color = [red, green, blue];\n        }\n        return color;\n    };\n    PdfRubberStampAnnotation.prototype._obtainBorderColor = function () {\n        var color = [];\n        var red;\n        var green;\n        var blue;\n        if (this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.notApproved ||\n            this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.void) {\n            red = 151;\n            green = 23;\n            blue = 15;\n            color = [red, green, blue];\n        }\n        else if (this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.approved ||\n            this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.final ||\n            this._icon === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRubberStampAnnotationIcon.completed) {\n            red = 73;\n            green = 110;\n            blue = 38;\n            color = [red, green, blue];\n        }\n        else {\n            red = 24;\n            green = 37;\n            blue = 100;\n            color = [red, green, blue];\n        }\n        return color;\n    };\n    PdfRubberStampAnnotation.prototype._drawRubberStamp = function (graphics, pen, brush, font, format) {\n        graphics.drawRoundedRectangle(2, 1, this._stampWidth, 26, 3, pen, brush);\n        var pdfBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._obtainBorderColor());\n        graphics.drawString(this._iconString.toUpperCase(), font, [(this._stampWidth / 2) + 1, 15, 0, 0], null, pdfBrush, format);\n    };\n    PdfRubberStampAnnotation.prototype._obtainInnerBounds = function () {\n        var bounds = { x: 0, y: 0, width: 0, height: 0 };\n        if (this._dictionary && this._dictionary.has('AP')) {\n            var appearanceDictionary = this._dictionary.get('AP');\n            if (appearanceDictionary && appearanceDictionary.has('N')) {\n                var normalAppearance = appearanceDictionary.get('N');\n                if (normalAppearance && typeof normalAppearance.dictionary !== 'undefined') {\n                    var normalAppearanceDictionary = normalAppearance.dictionary;\n                    if (normalAppearanceDictionary.has('BBox')) {\n                        var values = normalAppearanceDictionary.getArray('BBox');\n                        if (values && values.length === 4) {\n                            bounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._toRectangle)(values);\n                        }\n                    }\n                }\n            }\n        }\n        return bounds;\n    };\n    return PdfRubberStampAnnotation;\n}(PdfComment));\n\n/**\n * `PdfSoundAnnotation` class represents the sound annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfSoundAnnotation = page.annotations.at(0) as PdfSoundAnnotation;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfSoundAnnotation = /** @class */ (function (_super) {\n    __extends(PdfSoundAnnotation, _super);\n    /**\n     * Initializes a new instance of the `PdfSoundAnnotation` class.\n     *\n     * @private\n     */\n    function PdfSoundAnnotation() {\n        var _this = _super.call(this) || this;\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.soundAnnotation;\n        return _this;\n    }\n    PdfSoundAnnotation._load = function (page, dictionary) {\n        var annot = new PdfSoundAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfSoundAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfSoundAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    return PdfSoundAnnotation;\n}(PdfComment));\n\n/**\n * `PdfFreeTextAnnotation` class represents the free text annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new free text annotation\n * const annotation: PdfFreeTextAnnotation = new PdfFreeTextAnnotation(50, 100, 100, 50);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfFreeTextAnnotation = /** @class */ (function (_super) {\n    __extends(PdfFreeTextAnnotation, _super);\n    function PdfFreeTextAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._intentString = '';\n        _this._markUpFont = new _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfStandardFont(_fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontFamily.helvetica, 7, _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular);\n        _this._textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n        _this._cropBoxValueX = 0;\n        _this._cropBoxValueY = 0;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('FreeText'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._isContentUpdated = false;\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.freeTextAnnotation;\n        _this._parsedXMLData = [];\n        return _this;\n    }\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"calloutLines\", {\n        /**\n         * Gets the callout lines of the free text annotation.\n         *\n         * @returns {Array<number[]>} Callout lines.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation= page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Gets the callout lines of the free text annotation.\n         * let calloutLines: Array<number[]> = annotation.calloutLines;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._calloutLines === 'undefined') {\n                this._calloutLines = this._getCalloutLinePoints();\n            }\n            return this._calloutLines;\n        },\n        /**\n         * Sets the callout lines of the free text annotation.\n         *\n         * @param {Array<number[]>} value Callout lines.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Sets the callout lines of the free text annotation.\n         * annotation.calloutLines = [[100, 450], [100, 200], [100, 150]];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (!this._isLoaded) {\n                this._calloutLines = value;\n            }\n            var isChanged = false;\n            if (this._isLoaded && value.length >= 2) {\n                if (this._calloutLines.length === value.length) {\n                    for (var i = 0; i < value.length; i++) {\n                        var values = value[Number.parseInt(i.toString(), 10)];\n                        for (var j = 0; j < values.length; j++) {\n                            if (value[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)] !==\n                                this._calloutLines[Number.parseInt(i.toString(), 10)][Number.parseInt(j.toString(), 10)]) {\n                                isChanged = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                else {\n                    isChanged = true;\n                }\n            }\n            if (isChanged) {\n                var pageHeight = this._page.size[1];\n                var lines = [];\n                for (var i = 0; i < value.length; i++) {\n                    if (i < value.length) {\n                        lines.push(value[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX);\n                        lines.push((pageHeight + this._cropBoxValueY) - value[Number.parseInt(i.toString(), 10)][1]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                this._calloutLines = value;\n                this._dictionary.update('CL', lines);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"lineEndingStyle\", {\n        /**\n         * Gets the line ending style of the annotation.\n         *\n         * @returns {PdfLineEndingStyle} Line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Gets the Line ending style of the annotation.\n         * let lineEndingStyle: PdfLineEndingStyle = annotation.lineEndingStyle;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded) {\n                this._lineEndingStyle = this._obtainLineEndingStyle();\n            }\n            else if (typeof this._lineEndingStyle === 'undefined') {\n                this._lineEndingStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.none;\n            }\n            return this._lineEndingStyle;\n        },\n        /**\n         * Sets the line ending style of the line annotation.\n         *\n         * @param {PdfLineEndingStyle} value Line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Sets the line ending style of the line annotation.\n         * annotation.lineEndingStyle = PdfLineEndingStyle.closedArrow;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._dictionary.update('LE', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(value)));\n            }\n            this._lineEndingStyle = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"textMarkUpColor\", {\n        /**\n         * Gets the text markup color of the annotation.\n         *\n         * @returns {number[]} Text markup color as R, G, B color array in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Gets the text markup color of the annotation.\n         * let textMarkUpColor: number[] = annotation.textMarkUpColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._textMarkUpColor === 'undefined') {\n                var color = void 0;\n                if (this._dictionary.has('TextColor')) {\n                    this._textMarkUpColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(this._dictionary.getArray('TextColor'));\n                    return this._textMarkUpColor;\n                }\n                if (this._dictionary.has('DS')) {\n                    var collections = this._dictionary.get('DS').split(';');\n                    for (var i = 0; i < collections.length; i++) {\n                        if (collections[Number.parseInt(i.toString(), 10)].indexOf('color') !== -1) {\n                            color = collections[Number.parseInt(i.toString(), 10)].split(':')[1];\n                            if (color.startsWith('#')) {\n                                color = color.substring(1);\n                            }\n                            this._textMarkUpColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._convertToColor)(color);\n                            return this._textMarkUpColor;\n                        }\n                    }\n                }\n                if (!this._textMarkUpColor && this._dictionary.has('RC')) {\n                    var rcBrush = void 0;\n                    var rcColor = [];\n                    if (this._parsedXMLData.length > 0 && this._parsedXMLData[3]) {\n                        rcBrush = this._parsedXMLData[3];\n                        rcColor = rcBrush._color;\n                        this._textMarkUpColor = rcColor;\n                    }\n                }\n            }\n            return this._textMarkUpColor;\n        },\n        /**\n         * Sets the text markup color of the annotation.\n         *\n         * @param {number[]} value R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Sets the text markup color of the annotation.\n         * annotation.textMarkUpColor = [200, 200, 200];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value.length === 3) {\n                this._textMarkUpColor = value;\n                this._updateStyle(this.font, value, this.textAlignment);\n            }\n            this._isContentUpdated = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"textAlignment\", {\n        /**\n         * Gets the text alignment of the annotation.\n         *\n         * @returns {PdfTextAlignment} Text alignment.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Gets the text alignment of the annotation.\n         * let textAlignment: PdfTextAlignment = annotation.textAlignment;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Q')) {\n                this._textAlignment = this._dictionary.get('Q');\n            }\n            else if (this._dictionary.has('RC')) {\n                var rcAlignment = void 0;\n                if (this._parsedXMLData.length > 0 && this._parsedXMLData[1]) {\n                    rcAlignment = this._parsedXMLData[1];\n                    this._textAlignment = rcAlignment;\n                }\n            }\n            return this._textAlignment;\n        },\n        /**\n         * Sets the text alignment of the annotation.\n         *\n         * @param {PdfTextAlignment} value Text alignment.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Sets the text alignment of the annotation.\n         * annotation.textAlignment = PdfTextAlignment.justify;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._textAlignment !== value) {\n                this._dictionary.update('Q', value);\n            }\n            this._textAlignment = value;\n            this._isContentUpdated = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"font\", {\n        /**\n         * Gets the font of the annotation.\n         *\n         * @returns {PdfFont} font.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Gets the font of the annotation.\n         * let font: PdfFont = annotation.font;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (!this._font) {\n                this._font = this._obtainFont();\n                if ((this._font === null || typeof this._font === 'undefined') || (!this._isLoaded && this._font.size === 1)) {\n                    this._font = this._markUpFont;\n                }\n            }\n            return this._font;\n        },\n        /**\n         * Sets the font of the annotation.\n         *\n         * @param {PdfFont} value font.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Sets the font of the annotation.\n         * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._font = value;\n            this._isContentUpdated = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"borderColor\", {\n        /**\n         * Gets the border color of the annotation.\n         *\n         * @returns {number[]} R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Gets the border color of the annotation.\n         * let borderColor: number[] = annotation.borderColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._borderColor === 'undefined' && this._dictionary.has('DA')) {\n                this._borderColor = this._obtainColor();\n            }\n            return this._borderColor;\n        },\n        /**\n         * Sets the border color of the annotation.\n         *\n         * @param {number[]} value R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Sets the border color of the annotation.\n         * annotation.borderColor = [150, 150, 150];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value.length === 3) {\n                this._borderColor = value;\n                this._dictionary.update('DA', this._getBorderColorString(this.borderColor));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"annotationIntent\", {\n        /**\n         * Gets the intent of the annotation.\n         *\n         * @returns {PdfAnnotationIntent} Annotation intent.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Gets the intent of the annotation.\n         * let annotationIntent: PdfAnnotationIntent = annotation.annotationIntent;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('IT')) {\n                this._annotationIntent = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapAnnotationIntent)(this._dictionary.get('IT').name);\n            }\n            else {\n                this._annotationIntent = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationIntent.none;\n            }\n            return this._annotationIntent;\n        },\n        /**\n         * Sets the intent of the annotation.\n         *\n         * @param {PdfAnnotationIntent} value Annotation intent.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfFreeTextAnnotation = page.annotations.at(0) as PdfFreeTextAnnotation;\n         * // Sets the intent of the annotation.\n         * annotation.annotationIntent = PdfAnnotationIntent.freeTextTypeWriter;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined') {\n                this._annotationIntent = value;\n                if (value === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationIntent.none) {\n                    this._dictionary.update('Subj', 'Text Box');\n                }\n                else {\n                    this._dictionary.update('IT', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(this._obtainAnnotationIntent(this._annotationIntent)));\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfFreeTextAnnotation.prototype, \"_mkDictionary\", {\n        get: function () {\n            var value;\n            if (this._dictionary.has('MK')) {\n                value = this._dictionary.get('MK');\n            }\n            return value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfFreeTextAnnotation._load = function (page, dictionary) {\n        var annot = new PdfFreeTextAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        if (dictionary.has('RC')) {\n            annot._parsedXMLData = annot._parseMarkupLanguageData(dictionary.get('RC'));\n        }\n        return annot;\n    };\n    PdfFreeTextAnnotation.prototype._setPaddings = function (paddings) {\n        this._paddings = paddings;\n    };\n    PdfFreeTextAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfFreeTextAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (!this._dictionary.has('C')) {\n            this._isTransparentColor = true;\n        }\n        var cropOrMediaBox = this._getCropOrMediaBox();\n        if (cropOrMediaBox && cropOrMediaBox.length > 3 && typeof cropOrMediaBox[0] === 'number' && typeof cropOrMediaBox[1] === 'number' && (cropOrMediaBox[0] !== 0 || cropOrMediaBox[1] !== 0)) {\n            this._cropBoxValueX = cropOrMediaBox[0];\n            this._cropBoxValueY = cropOrMediaBox[1];\n        }\n        if (isFlatten || this._setAppearance) {\n            this._appearanceTemplate = this._createAppearance();\n        }\n        if (!isFlatten) {\n            this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n            this._saveFreeTextDictionary();\n        }\n    };\n    PdfFreeTextAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (this._isLoaded) {\n            if (this._setAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                this._appearanceTemplate = this._createAppearance();\n            }\n            if (!this._appearanceTemplate && isFlatten && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    var appearanceStream = dictionary.get('N');\n                    if (appearanceStream) {\n                        var reference = dictionary.getRaw('N');\n                        if (reference) {\n                            appearanceStream.reference = reference;\n                        }\n                        this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    }\n                }\n            }\n        }\n        else {\n            this._postProcess(isFlatten);\n            if (!this._appearanceTemplate && isFlatten) {\n                if (!this._dictionary.has('AP')) {\n                    this._appearanceTemplate = this._createAppearance();\n                }\n                else {\n                    var dictionary = this._dictionary.get('AP');\n                    if (dictionary && dictionary.has('N')) {\n                        var appearanceStream = dictionary.get('N');\n                        if (appearanceStream) {\n                            var reference = dictionary.getRaw('N');\n                            if (reference) {\n                                appearanceStream.reference = reference;\n                            }\n                            this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            if (this._isLoaded) {\n                this._flattenLoadedPopUp();\n            }\n            else {\n                this._flattenPopUp();\n            }\n        }\n        if (isFlatten && this._appearanceTemplate) {\n            var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n            if (!this._appearanceTemplate._content.dictionary.has('Matrix') && !this._isLoaded) {\n                var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                if (box) {\n                    this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                }\n            }\n            if (isNormalMatrix && typeof this._page.rotation !== 'undefined' && this._page.rotation !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0) {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n            else if (this._appearanceTemplate && !this._dictionary.has('AP')) {\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n            else if (this._dictionary.has('AP')) {\n                if (this._isValidTemplateMatrix(this._appearanceTemplate._content.dictionary, this.bounds, this._appearanceTemplate)) {\n                    this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n                }\n            }\n        }\n        else if (isFlatten) {\n            this._page.annotations.remove(this);\n        }\n        if (this._dictionary.has('RC') && this._isContentUpdated) {\n            this._updateStyle(this.font, this._textMarkUpColor, this.textAlignment);\n        }\n        if (!isFlatten && this._setAppearance) {\n            var appearance = void 0;\n            if (this._dictionary.has('AP')) {\n                appearance = this._dictionary.get('AP');\n            }\n            else {\n                var reference_7 = this._crossReference._getNextReference();\n                appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                this._crossReference._cacheMap.set(reference_7, appearance);\n                this._dictionary.update('AP', reference_7);\n            }\n            (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._appearanceTemplate._content);\n            appearance.update('N', reference);\n        }\n    };\n    PdfFreeTextAnnotation.prototype._isValidTemplateMatrix = function (dictionary, bounds, appearanceTemplate) {\n        var isValidMatrix = true;\n        var pointF = bounds;\n        if (dictionary && dictionary.has('Matrix')) {\n            var box = dictionary.getArray('BBox');\n            var matrix = dictionary.getArray('Matrix');\n            if (matrix && box && matrix.length > 3 && box.length > 2) {\n                if (typeof matrix[0] !== 'undefined' &&\n                    typeof matrix[1] !== 'undefined' &&\n                    typeof matrix[2] !== 'undefined' &&\n                    typeof matrix[3] !== 'undefined') {\n                    if (matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 1) {\n                        if (typeof box[0] !== 'undefined' &&\n                            typeof box[1] !== 'undefined' &&\n                            typeof box[2] !== 'undefined' &&\n                            typeof box[3] !== 'undefined') {\n                            if (Math.round(box[0]) !== Math.round(-(matrix[4])) && Math.round(box[1]) !== Math.round(-(matrix[5])) ||\n                                box[0] === 0 && Math.round(-(matrix[4])) === 0) {\n                                var graphics = this._page.graphics;\n                                var state = graphics.save();\n                                if (typeof this.opacity !== 'undefined' && this._opacity < 1) {\n                                    graphics.setTransparency(this._opacity);\n                                }\n                                pointF.x -= box[0];\n                                pointF.y += box[1];\n                                graphics.drawTemplate(appearanceTemplate, pointF);\n                                graphics.restore(state);\n                                this._page.annotations.remove(this);\n                                isValidMatrix = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return isValidMatrix;\n    };\n    PdfFreeTextAnnotation.prototype._createAppearance = function () {\n        var template;\n        var borderWidth = this.border.width / 2;\n        var nativeRectangle = this._obtainAppearanceBounds();\n        var rotationAngle = this.rotate;\n        if (rotationAngle === 0 || rotationAngle === 90 || rotationAngle === 180 || rotationAngle === 270) {\n            this._isAllRotation = false;\n        }\n        if (rotationAngle > 0 && this._isAllRotation) {\n            template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate([0, 0, nativeRectangle[2], nativeRectangle[3]], this._crossReference);\n        }\n        else {\n            template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        }\n        var box = template._content.dictionary.getArray('BBox');\n        var angle = this._getRotationAngle();\n        if (box && angle !== null && typeof angle !== 'undefined') {\n            template._content.dictionary.set('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n        }\n        var parameter = new _PaintParameter();\n        var text = this._obtainText();\n        template._writeTransformation = false;\n        var graphics = template.graphics;\n        var alignment = this._obtainTextAlignment();\n        var borderColor = this._obtainColor();\n        var borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(borderColor, this.border.width);\n        if (this.border.width > 0) {\n            parameter.borderPen = borderPen;\n        }\n        var rectangle = this._obtainStyle(borderPen, nativeRectangle, borderWidth, parameter);\n        if (this.color) {\n            parameter.foreBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._color);\n        }\n        if (this.textMarkUpColor) {\n            parameter.backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this._textMarkUpColor);\n        }\n        parameter.borderWidth = this.border.width;\n        if (this.calloutLines && this._calloutLines.length >= 2) {\n            this._drawCallOuts(graphics, borderPen);\n            if (this._isLoaded && typeof this._lineEndingStyle === 'undefined') {\n                this._lineEndingStyle = this.lineEndingStyle;\n            }\n            if (this._lineEndingStyle !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.none) {\n                var linePoints = this._obtainLinePoints();\n                var angle_1 = this._getAngle(linePoints);\n                var endPoint = this._getAxisValue([linePoints[2], linePoints[3]], 90, 0);\n                this._drawLineEndStyle(endPoint, graphics, angle_1, borderPen, parameter.foreBrush, this.lineEndingStyle, this.border.width, false);\n            }\n            if (!this._dictionary.has('RD')) {\n                rectangle = [this.bounds.x,\n                    -((this._page.size[1] - (this.bounds.y + this.bounds.height))),\n                    this.bounds.width,\n                    -this.bounds.height];\n            }\n            else {\n                rectangle = [rectangle[0], -rectangle[1], rectangle[2], -rectangle[3]];\n            }\n            rectangle[0] = rectangle[0] + this._cropBoxValueX;\n            rectangle[1] = rectangle[1] - this._cropBoxValueY;\n            this._calculateRectangle(rectangle);\n            parameter.bounds = rectangle;\n        }\n        else {\n            rectangle = [rectangle[0], -rectangle[1], rectangle[2], -rectangle[3]];\n            parameter.bounds = rectangle;\n        }\n        var outerRectangle = this._obtainAppearanceBounds();\n        var value = [rectangle[0] - outerRectangle[0], (-(rectangle[1])) - outerRectangle[1], rectangle[2] - outerRectangle[2],\n            (((-rectangle[1]) - outerRectangle[1]) + (-rectangle[3])) - outerRectangle[3]];\n        for (var i = 0; i < value.length; i++) {\n            if (value[Number.parseInt(i.toString(), 10)] < 0) {\n                value[Number.parseInt(i.toString(), 10)] = -value[Number.parseInt(i.toString(), 10)];\n            }\n        }\n        this._dictionary.update('RD', value);\n        if (this.opacity && this._opacity < 1) {\n            graphics.save();\n            graphics.setTransparency(this._opacity);\n        }\n        if (this.rotationAngle && this._rotate !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0) {\n            graphics.save();\n        }\n        this._drawFreeTextRectangle(graphics, parameter, rectangle, alignment);\n        if (text) {\n            this._drawFreeMarkUpText(graphics, parameter, rectangle, text, alignment);\n        }\n        if (this.opacity && this._opacity < 1) {\n            graphics.restore();\n        }\n        if (this.rotationAngle && this._rotate !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle0) {\n            graphics.restore();\n        }\n        var bounds = this._obtainAppearanceBounds();\n        if (this.flatten) {\n            this._bounds = { x: bounds[0], y: (this._page.size[1] - (bounds[1] + bounds[3])), width: bounds[2], height: bounds[3] };\n        }\n        this._dictionary.set('Rect', [bounds[0], bounds[1], bounds[0] + bounds[2], bounds[1] + bounds[3]]);\n        return template;\n    };\n    PdfFreeTextAnnotation.prototype._calculateRectangle = function (innerRectangle) {\n        var outerRectangle = this._obtainAppearanceBounds();\n        var value = [innerRectangle[0] - outerRectangle[0],\n            (-(innerRectangle[1])) - outerRectangle[1], innerRectangle[2] - outerRectangle[2],\n            (((-innerRectangle[1]) - outerRectangle[1]) + (-innerRectangle[3])) - outerRectangle[3]];\n        for (var i = 0; i < 4; i++) {\n            if (value[Number.parseInt(i.toString(), 10)] < 0) {\n                value[Number.parseInt(i.toString(), 10)] = -value[Number.parseInt(i.toString(), 10)];\n            }\n        }\n        this._dictionary.set('RD', value);\n    };\n    PdfFreeTextAnnotation.prototype._obtainAnnotationIntent = function (_annotationIntent) {\n        switch (_annotationIntent) {\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationIntent.freeTextCallout:\n                this._intentString = 'FreeTextCallout';\n                break;\n            case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationIntent.freeTextTypeWriter:\n                this._intentString = 'FreeTextTypeWriter';\n                break;\n        }\n        return this._intentString;\n    };\n    PdfFreeTextAnnotation.prototype._obtainFont = function () {\n        var fontData = this._obtainFontDetails();\n        if (!fontData.size && this._dictionary.has('RC')) {\n            var rcFont = void 0;\n            if (this._parsedXMLData.length > 0 && this._parsedXMLData[0]) {\n                rcFont = this._parsedXMLData[0];\n            }\n            if (rcFont instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfStandardFont) {\n                var font = rcFont;\n                fontData.size = font.size;\n                fontData.style = font.style;\n                fontData.name = font._fontFamily.toString();\n            }\n            else if (rcFont instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfCjkStandardFont) {\n                var font = rcFont;\n                fontData.size = font.size;\n                fontData.style = font.style;\n                fontData.name = font._fontFamily.toString();\n            }\n        }\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapFont)(fontData.name, fontData.size, fontData.style, this);\n    };\n    PdfFreeTextAnnotation.prototype._updateStyle = function (font, color, alignment) {\n        var ds = 'font:' +\n            font._metrics._name +\n            ' ' +\n            font.size +\n            'pt;style:' + (0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapPdfFontStyle)(font.style) +\n            ';color:' +\n            this._colorToHex(color);\n        this._dictionary.update('DS', ds);\n        var body = '<?xml version=\"1.0\"?><body xmlns=\"http://www.w3.org/1999/xhtml\" style=\"font:'\n            + font._metrics._name + ' ' + font.size + 'pt;font-weight:'\n            + (font.isBold ? 'bold' : 'normal') + ';color:' + this._colorToHex(color) + '\"><p dir=\"ltr\">';\n        var textAlignment;\n        var alignmentText;\n        if (alignment !== null && typeof alignment !== 'undefined') {\n            switch (alignment) {\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left:\n                    alignmentText = 'left';\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center:\n                    alignmentText = 'center';\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.right:\n                    alignmentText = 'right';\n                    break;\n                case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.justify:\n                    alignmentText = 'justify';\n                    break;\n            }\n            if (alignmentText) {\n                textAlignment = 'text-align:' + alignmentText + ';';\n            }\n        }\n        var decorationText = '';\n        var textDecoration;\n        var italic = 'font-style:italic';\n        var bold = 'font-style:bold';\n        if (font.isUnderline) {\n            decorationText = font.isStrikeout ? 'text-decoration:word line-through' : 'text-decoration:word';\n            if (font.isItalic) {\n                decorationText += ';' + italic;\n            }\n            else if (font.isBold) {\n                decorationText += ';' + bold;\n            }\n        }\n        else if (font.isStrikeout) {\n            decorationText = 'text-decoration:line-through';\n            if (font.isItalic) {\n                decorationText += ';' + italic;\n            }\n            else if (font.isBold) {\n                decorationText += ';' + bold;\n            }\n        }\n        else {\n            if (font.isItalic) {\n                decorationText += italic;\n            }\n            else if (font.isBold) {\n                decorationText += bold;\n            }\n        }\n        if (decorationText !== '') {\n            textDecoration = '<span style = \"' + textAlignment + decorationText + '\">' + (this.text ? this._getXmlFormattedString(this.text) : '') + '</span>';\n        }\n        else {\n            textDecoration = '<span style = \"' + textAlignment + '\">' + (this.text ? this._getXmlFormattedString(this.text) : '') + '</span>';\n        }\n        this._dictionary.update('RC', body + textDecoration + '</p></body>');\n    };\n    PdfFreeTextAnnotation.prototype._drawFreeMarkUpText = function (graphics, parameter, rectangle, text, alignment) {\n        var isRotation = false;\n        var angle = this.rotate;\n        if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90 && !this._isAllRotation) {\n            rectangle = [-rectangle[1], rectangle[0], -rectangle[3], rectangle[2]];\n        }\n        else if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180 && !this._isAllRotation) {\n            rectangle = [-(rectangle[2] + rectangle[0]), -rectangle[1], rectangle[2], -rectangle[3]];\n        }\n        else if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270 && !this._isAllRotation) {\n            rectangle = [(rectangle[1] + rectangle[3]), -(rectangle[0] + rectangle[2]), -rectangle[3], rectangle[2]];\n        }\n        else if (angle === 0 && !this._isAllRotation) {\n            rectangle = [rectangle[0], (rectangle[1] + rectangle[3]), rectangle[2], rectangle[3]];\n        }\n        if ((typeof this._font === 'undefined' || this._font === null) || (!this._isLoaded && this._font.size === 1)) {\n            this._font = this._markUpFont;\n        }\n        if (angle > 0 && this._isAllRotation) {\n            isRotation = true;\n            var bounds_1 = this.bounds;\n            var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(_enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n            var textSize = this._font.measureString(text, [0, 0], format, 0, 0);\n            if (angle > 0 && angle <= 91) {\n                graphics.translateTransform(textSize[1], -bounds_1.height);\n            }\n            else if (angle > 91 && angle <= 181) {\n                graphics.translateTransform(bounds_1.width - textSize[1], -(bounds_1.height - textSize[1]));\n            }\n            else if (angle > 181 && angle <= 271) {\n                graphics.translateTransform(bounds_1.width - textSize[1], -textSize[1]);\n            }\n            else if (angle > 271 && angle < 360) {\n                graphics.translateTransform(textSize[1], -textSize[1]);\n            }\n            graphics.rotateTransform(angle);\n            parameter.bounds = [0, 0, parameter.bounds[2], parameter.bounds[3]];\n        }\n        var bounds = [rectangle[0], rectangle[1], rectangle[2], rectangle[3]];\n        if (this._paddings && !this._isLoaded) {\n            var left = this._paddings._left;\n            var top_8 = this._paddings._top;\n            var right = this._paddings._right + this._paddings._left;\n            var bottom = this._paddings._top + this._paddings._bottom;\n            if (parameter.borderWidth > 0) {\n                var first_1 = rectangle[0] + (parameter.borderWidth + left);\n                var second_1 = rectangle[1] + (parameter.borderWidth + top_8);\n                var third = rectangle[2] - ((parameter.borderWidth * 2) + right);\n                var forth = void 0;\n                if (rectangle[3] > 0) {\n                    forth = rectangle[3] - ((parameter.borderWidth * 2) + bottom);\n                }\n                else {\n                    forth = -rectangle[3] - ((parameter.borderWidth * 2) + bottom);\n                }\n                rectangle = [first_1, second_1, third, forth];\n            }\n            else {\n                var first_2 = rectangle[0] + left;\n                var second_2 = rectangle[1] + top_8;\n                var third = rectangle[2] - right;\n                var forth = void 0;\n                if (rectangle[3] > 0) {\n                    forth = rectangle[3] - bottom;\n                }\n                else {\n                    forth = -rectangle[3] - bottom;\n                }\n                rectangle = [first_2, second_2, third, forth];\n            }\n        }\n        else if (parameter.borderWidth > 0) {\n            rectangle = [rectangle[0] + (parameter.borderWidth * 1.5),\n                rectangle[1] + (parameter.borderWidth * 1.5),\n                rectangle[2] - (parameter.borderWidth * 3),\n                (rectangle[3] > 0) ? (rectangle[3] - (parameter.borderWidth * 3)) : (-rectangle[3] - (parameter.borderWidth * 3))];\n        }\n        var first = this._font._metrics._getHeight() > ((rectangle[3] > 0) ? rectangle[3] : -rectangle[3]);\n        var second = this._font._metrics._getHeight() <= ((bounds[3] > 0) ? bounds[3] : -bounds[3]);\n        var checkPaddingWithFontHeight = first && second;\n        this._drawFreeTextAnnotation(graphics, parameter, text, this._font, checkPaddingWithFontHeight ? bounds : rectangle, true, alignment, isRotation);\n    };\n    PdfFreeTextAnnotation.prototype._drawFreeTextRectangle = function (graphics, parameter, rectangle, alignment) {\n        var isRotation = false;\n        if (this._dictionary.has('BE')) {\n            for (var i = 0; i < rectangle.length; i++) {\n                if (rectangle[Number.parseInt(i.toString(), 10)] < 0) {\n                    rectangle[Number.parseInt(i.toString(), 10)] = -rectangle[Number.parseInt(i.toString(), 10)];\n                }\n            }\n            this._drawAppearance(graphics, parameter, rectangle);\n            if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90 && !this._isAllRotation) {\n                graphics.rotateTransform(-90);\n            }\n            else if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180 && !this._isAllRotation) {\n                graphics.rotateTransform(-180);\n            }\n            else if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270 && !this._isAllRotation) {\n                graphics.rotateTransform(-270);\n            }\n        }\n        else {\n            if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90 && !this._isAllRotation) {\n                graphics.rotateTransform(-90);\n                parameter.bounds = [-rectangle[1], rectangle[2] + rectangle[0], -rectangle[3], -rectangle[2]];\n            }\n            else if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180 && !this._isAllRotation) {\n                graphics.rotateTransform(-180);\n                parameter.bounds = [-(rectangle[2] + rectangle[0]), -(rectangle[3] + rectangle[1]), rectangle[2], rectangle[3]];\n            }\n            else if (this.rotationAngle === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270 && !this._isAllRotation) {\n                graphics.rotateTransform(-270);\n                parameter.bounds = [rectangle[1] + rectangle[3], -rectangle[0], -rectangle[3], -rectangle[2]];\n            }\n            if (parameter.borderWidth > 0 && !this._isAllRotation) {\n                rectangle = parameter.bounds;\n            }\n            this._drawFreeTextAnnotation(graphics, parameter, '', this._font, rectangle, false, alignment, isRotation);\n        }\n    };\n    PdfFreeTextAnnotation.prototype._drawAppearance = function (graphics, parameter, rectangle) {\n        var graphicsPath = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        graphicsPath.addRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3]);\n        if (this._dictionary.has('BE')) {\n            var dictionary = this._dictionary.get('BE');\n            if (dictionary && dictionary.has('I')) {\n                var value = dictionary.get('I');\n                var radius = value === 1 ? 4 : 9;\n                this._drawCloudStyle(graphics, parameter.foreBrush, parameter.borderPen, radius, 0.833, graphicsPath._points, true);\n            }\n        }\n    };\n    PdfFreeTextAnnotation.prototype._drawFreeTextAnnotation = function (g, parameter, text, font, rectangle, isSkipDrawRectangle, alignment, isRotation) {\n        if (!isSkipDrawRectangle) {\n            g.drawRectangle(rectangle[0], rectangle[1], rectangle[2], rectangle[3], parameter.borderPen, parameter.foreBrush);\n        }\n        else {\n            var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat();\n            format.lineAlignment = _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.top;\n            format.alignment = alignment;\n            format.lineSpacing = 0;\n            if (isRotation) {\n                g.drawString(text, font, parameter.bounds, null, parameter.backBrush, format);\n            }\n            else {\n                g.drawString(text, font, rectangle, null, parameter.backBrush, format);\n            }\n        }\n    };\n    PdfFreeTextAnnotation.prototype._getCalloutLinePoints = function () {\n        if (this._dictionary.has('CL')) {\n            var calloutLinepoints = this._dictionary.getArray('CL');\n            if (calloutLinepoints) {\n                this._calloutLines = [];\n                for (var i = 0; i < calloutLinepoints.length; i = i + 2) {\n                    var points = [calloutLinepoints[Number.parseInt(i.toString(), 10)],\n                        this._page.size[1] - calloutLinepoints[i + 1]];\n                    this._calloutLines.push(points);\n                }\n            }\n        }\n        return this._calloutLines;\n    };\n    PdfFreeTextAnnotation.prototype._obtainAppearanceBounds = function () {\n        var bounds = [0, 0, 0, 0];\n        if (this.calloutLines && this._calloutLines.length > 0) {\n            var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n            var pointArray = [];\n            var length_2 = this._calloutLines.length === 2 ? 2 : 3;\n            for (var i = 0; i < length_2; i++) {\n                pointArray.push([0, 0]);\n            }\n            if (this._calloutLines.length >= 2) {\n                this._obtainCallOutsNative();\n                for (var i = 0; i < this._calloutLines.length; i++) {\n                    if (i < 3) {\n                        pointArray[Number.parseInt(i.toString(), 10)] = [this._calloutsClone[Number.parseInt(i.toString(), 10)][0],\n                            this._calloutsClone[Number.parseInt(i.toString(), 10)][1]];\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            if (pointArray.length > 0) {\n                if (this.lineEndingStyle !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.none) {\n                    this._expandAppearance(pointArray);\n                }\n                path._addLines(pointArray);\n            }\n            path.addRectangle((this.bounds.x + this._cropBoxValueX) - 2, ((this._page.size[1] + this._cropBoxValueY) - (this.bounds.y + this.bounds.height)) - 2, this.bounds.width + (2 * 2), this.bounds.height + (2 * 2));\n            bounds = path._getBounds();\n        }\n        else {\n            bounds = [this.bounds.x + this._cropBoxValueX,\n                ((this._page.size[1] + this._cropBoxValueY) - (this.bounds.y + this.bounds.height)),\n                this.bounds.width,\n                this.bounds.height];\n        }\n        return bounds;\n    };\n    PdfFreeTextAnnotation.prototype._obtainCallOutsNative = function () {\n        if (this.calloutLines && this._calloutLines.length > 0) {\n            var size = this._page.size;\n            this._calloutsClone = [];\n            for (var i = 0; i < this._calloutLines.length; i++) {\n                this._calloutsClone.push([this._calloutLines[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX,\n                    (size[1] + this._cropBoxValueY) - this._calloutLines[Number.parseInt(i.toString(), 10)][1]]);\n            }\n        }\n    };\n    PdfFreeTextAnnotation.prototype._obtainLinePoints = function () {\n        var pageHeight = this._page.size[1];\n        return [this.calloutLines[1][0] + this._cropBoxValueX,\n            (pageHeight + this._cropBoxValueY) - this.calloutLines[1][1],\n            this.calloutLines[0][0] + this._cropBoxValueX,\n            (pageHeight + this._cropBoxValueY) - this.calloutLines[0][1]];\n    };\n    PdfFreeTextAnnotation.prototype._obtainLineEndingStyle = function () {\n        var lineEndingStyle = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.square;\n        if (this._dictionary.has('LE')) {\n            lineEndingStyle = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapLineEndingStyle)(this._dictionary.get('LE').name, lineEndingStyle);\n        }\n        return lineEndingStyle;\n    };\n    PdfFreeTextAnnotation.prototype._obtainText = function () {\n        var text = '';\n        var isContent = this._dictionary.has('Contents');\n        if (isContent) {\n            var markUpText = this._dictionary.get('Contents');\n            if (markUpText) {\n                text = markUpText;\n            }\n            if (text && text !== '') {\n                this._text = text;\n            }\n            return text;\n        }\n        else if (this._dictionary.has('RC') && !isContent && text === null) {\n            text = this._rcText;\n            return text;\n        }\n        return text;\n    };\n    PdfFreeTextAnnotation.prototype._obtainTextAlignment = function () {\n        var textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n        var hasAlignment;\n        if (this._dictionary.has('Q')) {\n            var value = this._dictionary.get('Q');\n            if (typeof value !== 'undefined') {\n                textAlignment = value;\n                hasAlignment = true;\n            }\n        }\n        else if (this._dictionary.has('RC')) {\n            if (this._parsedXMLData.length > 0 && this._parsedXMLData[1]) {\n                var rcAlignment = this._parsedXMLData[1];\n                textAlignment = rcAlignment;\n                hasAlignment = true;\n            }\n        }\n        if (!hasAlignment && this._dictionary.has('DS')) {\n            var value = this._dictionary.get('DS');\n            var collections = value.split(';');\n            for (var i = 0; i < collections.length; i++) {\n                if (collections[Number.parseInt(i.toString(), 10)].indexOf('text-align') !== -1) {\n                    switch (collections[Number.parseInt(i.toString(), 10)]) {\n                        case 'left':\n                            textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n                            break;\n                        case 'right':\n                            textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.right;\n                            break;\n                        case 'center':\n                            textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center;\n                            break;\n                        case 'justify':\n                            textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.justify;\n                            break;\n                    }\n                }\n            }\n        }\n        return textAlignment;\n    };\n    PdfFreeTextAnnotation.prototype._obtainColor = function () {\n        var color;\n        if (this._isLoaded) {\n            if (this._dictionary.has('DA')) {\n                var entry = this._dictionary.get('DA');\n                if (Array.isArray(entry) && entry.length > 0) {\n                    color = [entry[0], entry[1], entry[2]];\n                }\n                else if (typeof entry === 'string') {\n                    this._da = new _form_field__WEBPACK_IMPORTED_MODULE_4__._PdfDefaultAppearance(entry);\n                    color = this._da.color;\n                }\n            }\n            else if (this._dictionary.has('MK')) {\n                var mkDict = this._mkDictionary;\n                if (mkDict && mkDict.has('BC')) {\n                    color = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(mkDict.getArray('BC'));\n                }\n            }\n            else {\n                color = [0, 0, 0];\n            }\n        }\n        else {\n            color = this._borderColor ? this._borderColor : [0, 0, 0];\n        }\n        return color;\n    };\n    PdfFreeTextAnnotation.prototype._expandAppearance = function (pointArray) {\n        var pointY = pointArray[0][1];\n        var pointX = pointArray[0][0];\n        if (!this._isLoaded) {\n            pointY = this._page.size[1] - pointY;\n        }\n        if (pointY > this.bounds.y) {\n            if (this.lineEndingStyle !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.openArrow) {\n                pointArray[0][1] -= (this.border.width * 11);\n            }\n        }\n        else {\n            pointArray[0][1] += (this.border.width * 11);\n        }\n        if (pointX <= this.bounds.x) {\n            pointArray[0][0] -= (this.border.width * 11);\n        }\n        else {\n            pointArray[0][0] += (this.border.width * 11);\n        }\n    };\n    PdfFreeTextAnnotation.prototype._drawCallOuts = function (graphics, borderPen) {\n        var path = new _graphics_pdf_path__WEBPACK_IMPORTED_MODULE_7__.PdfPath();\n        var pointArray = [];\n        var length = this._calloutLines.length === 2 ? 2 : 3;\n        for (var i = 0; i < length; i++) {\n            pointArray.push([0, 0]);\n        }\n        if (this._calloutLines.length >= 2) {\n            this._obtainCallOutsNative();\n            for (var i = 0; i < this._calloutLines.length && i < 3; i++) {\n                pointArray[Number.parseInt(i.toString(), 10)] = [this._calloutsClone[Number.parseInt(i.toString(), 10)][0],\n                    -this._calloutsClone[Number.parseInt(i.toString(), 10)][1]];\n            }\n        }\n        if (pointArray.length > 0) {\n            path._addLines(pointArray);\n        }\n        graphics.drawPath(path, borderPen);\n    };\n    PdfFreeTextAnnotation.prototype._saveFreeTextDictionary = function () {\n        if ((typeof this.font === 'undefined' || this.font === null) || (!this._isLoaded && this.font.size === 1)) {\n            this.font = this._markUpFont;\n        }\n        if (typeof this.text === 'string' && this.text !== null) {\n            this._dictionary.update('Contents', this.text);\n        }\n        if (this._isLoaded) {\n            this._textAlignment = this.textAlignment;\n        }\n        this._dictionary.update('Q', this._textAlignment);\n        if (this.annotationIntent === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationIntent.none) {\n            this._dictionary.update('Subj', 'Text Box');\n        }\n        else {\n            this._dictionary.update('IT', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(this._obtainAnnotationIntent(this._annotationIntent)));\n        }\n        this._updateStyle(this.font, this.textMarkUpColor, this._textAlignment);\n        this._dictionary.update('DA', this._getBorderColorString(this.borderColor ? this._borderColor : [0, 0, 0]));\n        if (this._calloutLines && this._calloutLines.length >= 2) {\n            var pageHeight = this._page.size[1];\n            var lines = [];\n            for (var i = 0; i < this._calloutLines.length && i < 3; i++) {\n                lines.push(this._calloutLines[Number.parseInt(i.toString(), 10)][0] + this._cropBoxValueX);\n                lines.push((pageHeight + this._cropBoxValueY) - this._calloutLines[Number.parseInt(i.toString(), 10)][1]);\n            }\n            this._dictionary.update('CL', lines);\n        }\n        if (this._setAppearance) {\n            var rect = this._obtainAppearanceBounds();\n            this._dictionary.update('Rect', [rect[0], rect[1], rect[0] + rect[2], rect[1] + rect[3]]);\n        }\n    };\n    PdfFreeTextAnnotation.prototype._getXmlFormattedString = function (markupText) {\n        markupText = markupText.replace('&', '&amp;');\n        markupText = markupText.replace('<', '&lt;');\n        markupText = markupText.replace('>', '&gt;');\n        return markupText;\n    };\n    PdfFreeTextAnnotation.prototype._parseMarkupLanguageData = function (rcContent) {\n        var _this = this;\n        var fontStyle = _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n        var fontCollection = []; // eslint-disable-line\n        var brush = null;\n        var fontName = '';\n        var content = rcContent;\n        var contentText = this._dictionary.has('Contents') ? this._dictionary.get('Contents') : '';\n        var hasSymbol = false;\n        var xdocument; // eslint-disable-line\n        hasSymbol = contentText.split('').some(function (char) { return _this._isSymbol(char); });\n        if (!hasSymbol) {\n            if (content !== null && typeof content !== 'undefined') {\n                xdocument = (new DOMParser()).parseFromString(content, 'text/xml');\n                var root = xdocument.documentElement;\n                var nameSpaceURI = (root && root.namespaceURI) || '';\n                if (root) {\n                    var styleMap = this._collectStyles(root);\n                    if (styleMap.size > 0) {\n                        var input = this._extractStylesToInput(styleMap);\n                        var fontDetails = this._getFontDetails(input, this.font.size, this.textAlignment, fontStyle, brush); // eslint-disable-line\n                        var _a = this._updateFontProperties(fontDetails, fontName, fontStyle, brush), updatedFontName = _a.fontName, updatedFontStyle = _a.fontStyle, updatedBrush = _a.brush;\n                        var obtainFont = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapFont)(updatedFontName, this.font._size, updatedFontStyle, this);\n                        fontCollection = this._fontCollection(fontCollection, obtainFont, nameSpaceURI, this._textAlignment, updatedBrush);\n                    }\n                }\n            }\n        }\n        this._parsedXMLData = fontCollection;\n        return fontCollection;\n    };\n    PdfFreeTextAnnotation.prototype._collectStyles = function (root, styleMap) {\n        if (styleMap === void 0) { styleMap = new Map(); }\n        if (!root) {\n            return styleMap;\n        }\n        var nodeStyle = null;\n        try {\n            nodeStyle = window.getComputedStyle(root);\n        }\n        catch (error) {\n            return styleMap;\n        }\n        styleMap.set(root.tagName.toLowerCase(), nodeStyle);\n        var childNode = root.firstElementChild;\n        while (childNode) {\n            this._collectStyles(childNode, styleMap);\n            childNode = childNode.nextElementSibling;\n        }\n        return styleMap;\n    };\n    PdfFreeTextAnnotation.prototype._extractStylesToInput = function (styleMap) {\n        var input = [];\n        styleMap.forEach(function (styleValue) {\n            if (styleValue && styleValue.length > 0) { // Check if styleValue is valid\n                for (var i = 0; i < styleValue.length; i++) {\n                    var propertyName = styleValue.item(Number.parseInt(i.toString(), 10));\n                    if (propertyName !== null && propertyName !== undefined) {\n                        var propertyValue = styleValue.getPropertyValue(propertyName);\n                        input.push(propertyName + \": \" + propertyValue);\n                    }\n                }\n            }\n        });\n        return input;\n    };\n    PdfFreeTextAnnotation.prototype._isSymbol = function (char) {\n        var code = char.charCodeAt(0);\n        if (char === '_' || char === '+' || char === '-' || char === '*' || char === '=') {\n            return false;\n        }\n        return ((code >= 0x20A0 && code <= 0x20CF) ||\n            (code >= 0x2200 && code <= 0x22FF) ||\n            (code >= 0x2A00 && code <= 0x2AFF) ||\n            (code >= 0x2100 && code <= 0x214F) ||\n            (code >= 0x2300 && code <= 0x23FF) ||\n            (code === 0x2B50));\n    };\n    PdfFreeTextAnnotation.prototype._updateFontProperties = function (fontDetails, fontName, fontStyle, brush) {\n        var _this = this;\n        fontDetails.forEach(function (value, property) {\n            switch (property) {\n                case 'font-family':\n                    fontName = value;\n                    break;\n                case 'font-size':\n                    _this.font._size = parseFloat(value);\n                    break;\n                case 'font-style':\n                case 'font-weight':\n                case 'text-decoration':\n                    fontStyle = _this._obtainFontStyle(value, property);\n                    break;\n                case 'text-align':\n                    _this._textAlignment = _this._parseTextAlignment(value);\n                    break;\n                case 'color':\n                    brush = value;\n                    break;\n                case 'xfa-spacerun':\n                    _this._rcText = value;\n                    break;\n            }\n        });\n        return { fontName: fontName, fontStyle: fontStyle, brush: brush };\n    };\n    PdfFreeTextAnnotation.prototype._obtainFontStyle = function (value, property) {\n        var styleValue = parseFloat(value);\n        switch (property) {\n            case 'font-style':\n                return styleValue === 0 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular :\n                    styleValue === 1 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.bold :\n                        styleValue === 2 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.italic :\n                            styleValue === 8 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.strikeout :\n                                styleValue === 4 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.underline : _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n            case 'font-weight':\n                return styleValue === 1 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.bold : _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n            case 'text-decoration':\n                return styleValue === 8 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.strikeout :\n                    styleValue === 4 ? _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.underline : _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n            default:\n                return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n        }\n    };\n    PdfFreeTextAnnotation.prototype._parseTextAlignment = function (value) {\n        var alignmentValue = parseFloat(value);\n        switch (alignmentValue) {\n            case 0: return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n            case 1: return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center;\n            case 2: return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.right;\n            case 3: return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.justify;\n            default: return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n        }\n    };\n    PdfFreeTextAnnotation.prototype._getFontDetails = function (input, fontSize, textAlignment, fontStyle, brush) {\n        var _this = this;\n        var fontDetails = new Map(); // eslint-disable-line\n        input.forEach(function (element) {\n            var _a = element.split(':').map(function (item) { return item.trim(); }), property = _a[0], value = _a[1];\n            if (property && value) {\n                switch (property.toLowerCase()) {\n                    case 'font':\n                        _this._parseFont(value, fontDetails);\n                        break;\n                    case 'font-size':\n                        fontSize = _this._parseFontSize(value);\n                        fontDetails.set('font-size', fontSize);\n                        break;\n                    case 'font-weight':\n                        fontStyle = _this._parseFontWeight(value, fontStyle);\n                        fontDetails.set('font-weight', fontStyle);\n                        break;\n                    case 'font-family':\n                        fontDetails.set('font-family', _this._parseFontFamily(value));\n                        break;\n                    case 'color':\n                        brush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(_this._rgbStringToArray(value));\n                        fontDetails.set('color', brush);\n                        break;\n                    case 'font-style':\n                        fontStyle = _this._parseFontStyle(value, fontStyle);\n                        fontDetails.set('font-style', fontStyle);\n                        break;\n                    case 'text-decoration':\n                        fontStyle = _this._parseTextDecoration(value, fontStyle);\n                        fontDetails.set('text-decoration', fontStyle);\n                        break;\n                    case 'text-align':\n                        textAlignment = _this._parseTextAlign(value);\n                        fontDetails.set('text-align', textAlignment);\n                        break;\n                    case 'xfa-spacerun':\n                        _this._rcText = value.length > 1 && value.includes('yes') ? _this._rcText + ' ' : _this._rcText;\n                        fontDetails.set('xfa-spacerun', _this._rcText);\n                        break;\n                }\n            }\n        });\n        return fontDetails;\n    };\n    PdfFreeTextAnnotation.prototype._parseFont = function (value, fontDetails) {\n        var fontParts = value.split(' ').map(function (item) { return item.trim(); });\n        var fontName = '';\n        fontParts.forEach(function (part) {\n            if (part && !part.endsWith('pt')) {\n                fontName += part + ' ';\n            }\n            else if (part.endsWith('pt')) {\n                fontDetails.set('font-size', parseFloat(part.replace('pt', '').replace(',', '.').trim()));\n            }\n        });\n        fontDetails.set('font-family', fontName.trim().replace(/['\",]/g, ''));\n    };\n    PdfFreeTextAnnotation.prototype._parseFontSize = function (value) {\n        if (value.endsWith('pt')) {\n            return parseFloat(value.replace('pt', '').replace(',', '.').trim());\n        }\n        return 0;\n    };\n    PdfFreeTextAnnotation.prototype._parseFontWeight = function (value, fontStyle) {\n        if (value.includes('bold')) {\n            fontStyle |= _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.bold;\n        }\n        return fontStyle;\n    };\n    PdfFreeTextAnnotation.prototype._parseFontFamily = function (value) {\n        return value.replace(/^'+|'+$/g, '').trim();\n    };\n    PdfFreeTextAnnotation.prototype._parseFontStyle = function (value, fontStyle) {\n        if (value.includes('normal') || value.includes('regular')) {\n            return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n        }\n        if (value.includes('underline')) {\n            return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.underline;\n        }\n        if (value.includes('strikeout')) {\n            return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.strikeout;\n        }\n        if (value.includes('italic')) {\n            return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.italic;\n        }\n        if (value.includes('bold')) {\n            return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.bold;\n        }\n        return fontStyle;\n    };\n    PdfFreeTextAnnotation.prototype._parseTextDecoration = function (value, fontStyle) {\n        if (value.includes('word')) {\n            return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.underline;\n        }\n        if (value.includes('line-through')) {\n            return _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.strikeout;\n        }\n        return fontStyle;\n    };\n    PdfFreeTextAnnotation.prototype._parseTextAlign = function (value) {\n        switch (value.trim().toLowerCase()) {\n            case 'left': return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n            case 'right': return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.right;\n            case 'center': return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center;\n            case 'justify': return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.justify;\n            default: return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n        }\n    };\n    PdfFreeTextAnnotation.prototype._rgbStringToArray = function (rgbString) {\n        var regex = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/;\n        var match = rgbString.match(regex);\n        if (match) {\n            var r = parseInt(match[1], 10);\n            var g = parseInt(match[2], 10);\n            var b = parseInt(match[3], 10);\n            return [r, g, b];\n        }\n        else {\n            throw new Error('Invalid RGB string format');\n        }\n    };\n    PdfFreeTextAnnotation.prototype._fontCollection = function (fontCollection, font, nameSpaceUri, alignment, brush) {\n        return fontCollection.concat([font, alignment, nameSpaceUri, brush]);\n    };\n    return PdfFreeTextAnnotation;\n}(PdfComment));\n\n/**\n * `PdfRedactionAnnotation` class represents the redaction annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Create a new redaction annotation\n * const annotation: PdfRedactionAnnotation = new PdfRedactionAnnotation (50, 100, 100, 50);\n * // Add annotation to the page\n * page.annotations.add(annotation);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfRedactionAnnotation = /** @class */ (function (_super) {\n    __extends(PdfRedactionAnnotation, _super);\n    function PdfRedactionAnnotation(x, y, width, height) {\n        var _this = _super.call(this) || this;\n        _this._textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n        _this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n        _this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        _this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Redact'));\n        if (typeof x !== 'undefined' && typeof y !== 'undefined' && typeof width !== 'undefined' && typeof height !== 'undefined') {\n            _this.bounds = { x: x, y: y, width: width, height: height };\n        }\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.redactionAnnotation;\n        return _this;\n    }\n    Object.defineProperty(PdfRedactionAnnotation.prototype, \"repeatText\", {\n        /**\n         * Gets the boolean flag indicating whether annotation has repeat text or not.\n         *\n         * @returns {boolean} repeat text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Gets the boolean flag indicating whether annotation has repeat text or not.\n         * let repeatText: boolean = annotation. repeatText;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._repeat === 'undefined' && this._dictionary.has('Repeat')) {\n                this._repeat = this._dictionary.get('Repeat');\n            }\n            return this._repeat;\n        },\n        /**\n         * Sets the boolean flag indicating whether annotation has repeat text or not.\n         *\n         * @param {boolean} value repeat text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Sets the boolean flag indicating whether annotation has repeat text or not.\n         * annotation.repeatText = false;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._repeat) {\n                this._repeat = value;\n                if (this._dictionary) {\n                    this._dictionary.update('Repeat', value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRedactionAnnotation.prototype, \"textAlignment\", {\n        /**\n         * Gets the text alignment of the annotation.\n         *\n         * @returns {PdfTextAlignment} Text alignment.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Gets the text alignment of the annotation.\n         * let textAlignment: PdfTextAlignment = annotation.textAlignment;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._dictionary.has('Q')) {\n                this._textAlignment = this._dictionary.get('Q');\n            }\n            return this._textAlignment;\n        },\n        /**\n         * Sets the text alignment of the annotation.\n         *\n         * @param {PdfTextAlignment} value Text alignment.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Sets the text alignment of the annotation.\n         * annotation.textAlignment = PdfTextAlignment.justify;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._textAlignment !== value) {\n                this._dictionary.update('Q', value);\n            }\n            this._textAlignment = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRedactionAnnotation.prototype, \"textColor\", {\n        /**\n         * Gets the text color of the annotation.\n         *\n         * @returns {number[]} R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Gets the text color of the annotation.\n         * let textColor : number[] = annotation.textColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._textColor === 'undefined' && this._dictionary.has('C')) {\n                this._textColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(this._dictionary.getArray('C'));\n            }\n            return this._textColor;\n        },\n        /**\n         * Sets the text color of the annotation.\n         *\n         * @param {number[]} value R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Sets the text color of the annotation.\n         * annotation.textColor = [255, 255, 255];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value.length === 3) {\n                var extColor = this.textColor;\n                if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {\n                    this._textColor = value;\n                    this._dictionary.update('C', [Number.parseFloat((value[0] / 255).toFixed(3)),\n                        Number.parseFloat((value[1] / 255).toFixed(3)),\n                        Number.parseFloat((value[2] / 255).toFixed(3))]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRedactionAnnotation.prototype, \"borderColor\", {\n        /**\n         * Gets the border color of the annotation.\n         *\n         * @returns {number[]} R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Gets the border color of the annotation.\n         * let borderColor: number[] = annotation.borderColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._borderColor === 'undefined' && this._dictionary.has('OC')) {\n                this._borderColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(this._dictionary.getArray('OC'));\n            }\n            return this._borderColor;\n        },\n        /**\n         * Sets the border color of the annotation.\n         *\n         * @param {number[]} value R, G, B color values in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Sets the border color of the annotation.\n         * annotation.borderColor = [255, 255, 255];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value !== 'undefined' && value.length === 3) {\n                var extColor = this.borderColor;\n                if (!this._isLoaded || typeof extColor === 'undefined' || (extColor[0] !== value[0] || extColor[1] !== value[1] || extColor[2] !== value[2])) {\n                    this._borderColor = value;\n                    this._dictionary.update('OC', [Number.parseFloat((value[0] / 255).toFixed(3)),\n                        Number.parseFloat((value[1] / 255).toFixed(3)),\n                        Number.parseFloat((value[2] / 255).toFixed(3))]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRedactionAnnotation.prototype, \"overlayText\", {\n        /**\n         * Gets the overlay text of the annotation.\n         *\n         * @returns {string} overlay text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Gets the overlay text of the annotation.\n         * let overlayText: string =annotation.overlayText;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._overlayText === 'undefined' && this._dictionary.has('OverlayText')) {\n                this._overlayText = this._dictionary.get('OverlayText');\n            }\n            return this._overlayText;\n        },\n        /**\n         * Sets the overlay text of the annotation.\n         *\n         * @param {string} value overlay text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Sets the overlay text of the annotation.\n         * annotation.overlayText = ‘syncfusion’;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value === 'string') {\n                this._dictionary.update('OverlayText', value);\n                this._overlayText = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRedactionAnnotation.prototype, \"font\", {\n        /**\n         * Gets the font of the annotation.\n         *\n         * @returns {PdfFont} font.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Gets the font of the annotation.\n         * let font: PdfFont = annotation.font;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._font;\n        },\n        /**\n         * Sets the font of the annotation.\n         *\n         * @param {PdfFont} value font.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfRedactionAnnotation = page.annotations.at(0) as PdfRedactionAnnotation;\n         * // Sets the font of the annotation.\n         * annotation.font = new PdfStandardFont(PdfFontFamily.helvetica, 10, PdfFontStyle.regular);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._font = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfRedactionAnnotation._load = function (page, dictionary) {\n        var annot = new PdfRedactionAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfRedactionAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfRedactionAnnotation.prototype._postProcess = function (isFlatten) {\n        if (typeof this.bounds === 'undefined' || this.bounds === null) {\n            throw new Error('Bounds cannot be null or undefined');\n        }\n        var borderWidth;\n        if (this._dictionary.has('BS')) {\n            borderWidth = this.border.width;\n        }\n        else {\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            dictionary.set('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n            this._dictionary.set('BS', dictionary);\n        }\n        if (typeof borderWidth === 'undefined') {\n            borderWidth = 1;\n        }\n        if (this._setAppearance) {\n            this._appearanceTemplate = this._createRedactionAppearance(isFlatten);\n        }\n        this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n    };\n    PdfRedactionAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (!this._isImported) {\n            if (this._isLoaded) {\n                this._appearanceTemplate = this._createRedactionAppearance(isFlatten);\n            }\n            else {\n                this._postProcess(isFlatten);\n                if (!this._appearanceTemplate) {\n                    if (isFlatten) {\n                        if (!this._dictionary.has('AP')) {\n                            this._appearanceTemplate = this._createRedactionAppearance(isFlatten);\n                        }\n                        else {\n                            var dictionary = this._dictionary.get('AP');\n                            if (dictionary && dictionary.has('N')) {\n                                var appearanceStream = dictionary.get('N');\n                                if (appearanceStream) {\n                                    var reference = dictionary.getRaw('N');\n                                    if (reference) {\n                                        appearanceStream.reference = reference;\n                                    }\n                                    this._appearanceTemplate = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (isFlatten && this._appearanceTemplate) {\n                var isNormalMatrix = this._validateTemplateMatrix(this._appearanceTemplate._content.dictionary);\n                if (!this._appearanceTemplate._content.dictionary.has('Matrix')) {\n                    var box = this._appearanceTemplate._content.dictionary.getArray('BBox');\n                    if (box) {\n                        this._appearanceTemplate._content.dictionary.update('Matrix', [1, 0, 0, 1, -box[0], -box[1]]);\n                    }\n                }\n                this._flattenAnnotationTemplate(this._appearanceTemplate, isNormalMatrix);\n            }\n            else if (isFlatten) {\n                this._page.annotations.remove(this);\n            }\n        }\n    };\n    PdfRedactionAnnotation.prototype._createRedactionAppearance = function (isFlatten) {\n        var normalTemplate = this._createNormalAppearance();\n        if (isFlatten) {\n            if (this._isLoaded && this._page !== null) {\n                this._page.annotations.remove(this);\n            }\n        }\n        else {\n            var borderTemplate = this._createBorderAppearance();\n            if (this._dictionary.has('AP')) {\n                var appearance = this._dictionary.get('AP');\n                if (appearance && appearance instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'R');\n                }\n            }\n            var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n            borderTemplate._content.dictionary._updated = true;\n            var reference1 = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference1, borderTemplate._content);\n            borderTemplate._content.reference = reference1;\n            dictionary.set('N', reference1);\n            normalTemplate._content.dictionary._updated = true;\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, normalTemplate._content);\n            normalTemplate._content.reference = reference;\n            dictionary.set('R', reference);\n            dictionary._updated = true;\n            this._dictionary.set('AP', dictionary);\n        }\n        return normalTemplate;\n    };\n    PdfRedactionAnnotation.prototype._createBorderAppearance = function () {\n        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        var width = this.border.width / 2;\n        var graphics = template.graphics;\n        var actualWidth = this.border.width;\n        var pen;\n        if (this.border.width > 0 && this.borderColor) {\n            pen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.borderColor, actualWidth);\n        }\n        var rect = [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]];\n        if (this.opacity < 1) {\n            var state = graphics.save();\n            graphics.setTransparency(this.opacity);\n            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - actualWidth, rect[3] - actualWidth, pen, null);\n            graphics.restore(state);\n        }\n        else {\n            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - actualWidth, rect[3] - actualWidth, pen, null);\n        }\n        return template;\n    };\n    PdfRedactionAnnotation.prototype._createNormalAppearance = function () {\n        var nativeRectangle = [0, 0, this.bounds.width, this.bounds.height];\n        var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(nativeRectangle, this._crossReference);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__._setMatrix)(template, this._getRotationAngle());\n        var width = this.border.width / 2;\n        var graphics = template.graphics;\n        var parameter = new _PaintParameter();\n        var borderPen;\n        if (this.textColor && this.border.width > 0) {\n            borderPen = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfPen(this.textColor, this.border.width);\n        }\n        var backBrush;\n        var textcolor;\n        if (this.innerColor) {\n            backBrush = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.innerColor);\n        }\n        if (this.textColor) {\n            textcolor = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush(this.textColor);\n        }\n        else {\n            textcolor = new _graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__.PdfBrush([128, 128, 128]);\n        }\n        parameter.backBrush = backBrush;\n        parameter.borderWidth = width;\n        var widths = this.border.width;\n        var rect = [nativeRectangle[0], nativeRectangle[1], nativeRectangle[2], nativeRectangle[3]];\n        if (this.opacity < 1) {\n            var state = graphics.save();\n            graphics.setTransparency(this.opacity);\n            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - widths, rect[3] - widths, borderPen, backBrush);\n            graphics.restore(state);\n        }\n        else {\n            graphics.drawRectangle(rect[0] + width, rect[1] + width, rect[2] - widths, rect[3] - widths, borderPen, backBrush);\n        }\n        graphics.restore();\n        if (this.overlayText && (0,_utils__WEBPACK_IMPORTED_MODULE_3__._isNullOrUndefined)(this.overlayText) && this._overlayText !== '') {\n            var col = 0;\n            var row = 0;\n            if (typeof this.font === 'undefined' || this.font === null) {\n                this.font = this._lineCaptionFont;\n            }\n            var y = 0;\n            var x = 0;\n            var diff = 0;\n            var rectangle = void 0;\n            if (this._isLoaded) {\n                this._textAlignment = this.textAlignment;\n            }\n            var format = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(this._textAlignment, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.top);\n            var textsize = this.font.measureString(this.overlayText, [0, 0], format, 0, 0);\n            if (this._isLoaded && typeof this._repeat === 'undefined') {\n                this._repeat = this.repeatText;\n            }\n            if (this._repeat) {\n                if (textsize[0] <= 0) {\n                    textsize[0] = 1;\n                }\n                col = this.bounds.width / textsize[0];\n                row = Math.floor(this.bounds.height / this.font._size);\n                diff = Math.abs(this.bounds.width - (Math.floor(col) * textsize[0]));\n                if (this._textAlignment === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center) {\n                    x = diff / 2;\n                }\n                if (this._textAlignment === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.right) {\n                    x = diff;\n                }\n                for (var i = 1; i < col; i++) {\n                    for (var j = 0; j < row; j++) {\n                        rectangle = [x, y, 0, 0];\n                        graphics.drawString(this.overlayText, this.font, rectangle, null, textcolor, null);\n                        y = y + this.font._size;\n                    }\n                    x = x + textsize[0];\n                    y = 0;\n                }\n            }\n            else {\n                diff = Math.abs(this.bounds.width - textsize[0]);\n                if (this._textAlignment === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.center) {\n                    x = diff / 2;\n                }\n                if (this._textAlignment === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.right) {\n                    x = diff;\n                }\n                rectangle = [x, 0, this.bounds.width - this.border.width, this.bounds.height - this.border.width];\n                graphics.drawString(this.overlayText, this.font, rectangle, null, textcolor, format);\n            }\n        }\n        return template;\n    };\n    return PdfRedactionAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfRichMediaAnnotation` class represents the rich media annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfRichMediaAnnotation = page.annotations.at(0) as PdfRichMediaAnnotation;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfRichMediaAnnotation = /** @class */ (function (_super) {\n    __extends(PdfRichMediaAnnotation, _super);\n    /**\n     * Initializes a new instance of the `PdfRichMediaAnnotation` class.\n     *\n     * @private\n     */\n    function PdfRichMediaAnnotation() {\n        var _this = _super.call(this) || this;\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.richMediaAnnotation;\n        return _this;\n    }\n    PdfRichMediaAnnotation._load = function (page, dictionary) {\n        var annot = new PdfRichMediaAnnotation();\n        annot._isLoaded = true;\n        annot._initialize(page, dictionary);\n        return annot;\n    };\n    PdfRichMediaAnnotation.prototype._initialize = function (page, dictionary) {\n        _super.prototype._initialize.call(this, page, dictionary);\n    };\n    PdfRichMediaAnnotation.prototype._doPostProcess = function (isFlatten) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (typeof this.flattenPopups !== 'undefined' && this.flattenPopups) {\n            this._flattenPopUp();\n        }\n        if (isFlatten) {\n            var appearanceStream = void 0;\n            if (this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                var isNormalMatrix = this._validateTemplateMatrix(template._content.dictionary);\n                this._flattenAnnotationTemplate(template, isNormalMatrix);\n            }\n            else {\n                this._removeAnnotation(this._page, this);\n            }\n        }\n    };\n    return PdfRichMediaAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfWidgetAnnotation` class represents the widget annotation objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access first page\n * let page: PdfPage = document.getPage(0);\n * // Access the annotation at index 0\n * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfWidgetAnnotation = /** @class */ (function (_super) {\n    __extends(PdfWidgetAnnotation, _super);\n    /**\n     * Initializes a new instance of the `PdfWidgetAnnotation` class.\n     *\n     * @private\n     */\n    function PdfWidgetAnnotation() {\n        var _this = _super.call(this) || this;\n        _this._isAutoResize = false;\n        _this._visibility = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.visible;\n        _this._isFont = false;\n        _this._isTransparentBackColor = false;\n        _this._isTransparentBorderColor = false;\n        _this._isWidget = true;\n        _this._type = _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfAnnotationType.widgetAnnotation;\n        return _this;\n    }\n    /**\n     * Parse an existing widget annotation.\n     *\n     * @private\n     * @param {_PdfDictionary} dictionary Widget dictionary.\n     * @param {_PdfCrossReference} crossReference PDF cross reference.\n     * @returns {PdfWidgetAnnotation} Widget.\n     */\n    PdfWidgetAnnotation._load = function (dictionary, crossReference) {\n        var widget = new PdfWidgetAnnotation();\n        widget._isLoaded = true;\n        widget._dictionary = dictionary;\n        widget._crossReference = crossReference;\n        return widget;\n    };\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"page\", {\n        /**\n         * Gets the page object (Read only).\n         *\n         * @returns {PdfPage} page object.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access check box field\n         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;\n         * // Access first item of check box field\n         * let item: PdfWidgetAnnotation = field.itemAt(0);\n         * // Gets the page object.\n         * let page: PdfPage = item.page;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._getPage();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"color\", {\n        /**\n         * Gets the fore color of the annotation.\n         *\n         * @returns {number[]} Color as R, G, B color array in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Gets the fore color of the annotation.\n         * let color: number[] = annotation.color;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._color === 'undefined' && this._defaultAppearance) {\n                this._color = this._da.color;\n            }\n            return this._color;\n        },\n        /**\n         * Sets the fore color of the annotation.\n         *\n         * @param {number[]} value Color as R, G, B color array in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Sets the fore color of the annotation.\n         * annotation.color = [255,255,255];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof this.color === 'undefined' || this._color !== value) {\n                this._color = value;\n            }\n            var isNew = false;\n            if (!this._defaultAppearance) {\n                this._da = new _form_field__WEBPACK_IMPORTED_MODULE_4__._PdfDefaultAppearance('');\n                isNew = true;\n            }\n            if (isNew || this._da.color !== value) {\n                this._da.color = value;\n                this._dictionary.update('DA', this._da.toString());\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"backColor\", {\n        /**\n         * Gets the back color of the annotation.\n         *\n         * @returns {number[]} Color as R, G, B color array in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the text box field at index 0\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Gets the back color of the annotation\n         * let backColor: number[] = field.itemAt(0).backColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._parseBackColor();\n        },\n        /**\n         * Sets the back color of the annotation.\n         *\n         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the text box field at index 0\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Sets the background color of the field item\n         * field.itemAt(0).backColor = [255, 0, 0];\n         * // Sets the background color of the field item to transparent\n         * field.itemAt(1).backColor = [0, 0, 0, 0];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._updateBackColor(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"_hasBackColor\", {\n        get: function () {\n            if (this._isLoaded) {\n                var mkDictionary = this._mkDictionary;\n                return (mkDictionary && mkDictionary.has('BG'));\n            }\n            else {\n                return !this._isTransparentBackColor;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"_hasBorderColor\", {\n        get: function () {\n            if (this._isLoaded) {\n                var mkDictionary = this._mkDictionary;\n                return (mkDictionary && mkDictionary.has('BC'));\n            }\n            else {\n                return !this._isTransparentBorderColor;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"borderColor\", {\n        /**\n         * Gets the border color of the annotation.\n         *\n         * @returns {number[]} Color as R, G, B color array in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Gets the border color of the annotation.\n         * let borderColor: number[] = annotation.borderColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._parseBorderColor();\n        },\n        /**\n         * Sets the border color of the annotation.\n         *\n         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Sets the border color of the annotation.\n         * annotation.borderColor = [255,255,255];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._updateBorderColor(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"rotate\", {\n        /**\n         * Gets the rotation angle of the annotation.\n         *\n         * @returns {number} Rotation angle as number.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Gets the rotation angle of the annotation.\n         * let rotate: number = annotation.rotate;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._rotationAngle === 'undefined') {\n                if (this._mkDictionary && this._mkDictionary.has('R')) {\n                    this._rotationAngle = this._mkDictionary.get('R');\n                }\n                else if (this._dictionary.has('R')) {\n                    this._rotationAngle = this._dictionary.get('R');\n                }\n            }\n            return this._rotationAngle;\n        },\n        /**\n         * Sets the rotation angle of the annotation.\n         *\n         * @param {number} value Rotation angle as number.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Sets the rotation angle of the annotation.\n         * annotation.rotate = 90;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof this.rotate === 'undefined' || this._rotationAngle !== value) {\n                if (typeof this._mkDictionary === 'undefined') {\n                    this._dictionary.update('MK', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference));\n                }\n                this._mkDictionary.update('R', value);\n                this._rotationAngle = value;\n                this._dictionary._updated = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"highlightMode\", {\n        /**\n         * Gets the highlight mode of the annotation.\n         *\n         * @returns {PdfHighlightMode} Highlight mode.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Gets the highlight mode of the annotation.\n         * let highlightMode: PdfHighlightMode = annotation.highlightMode;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._highlightMode === 'undefined' && this._dictionary.has('H')) {\n                var mode = this._dictionary.get('H');\n                this._highlightMode = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapHighlightMode)(mode.name);\n            }\n            return this._highlightMode;\n        },\n        /**\n         * Sets the highlight mode of the annotation.\n         *\n         * @param {PdfHighlightMode} value Highlight mode.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Sets the highlight mode of the annotation.\n         * annotation.highlightMode = PdfHighlightMode.noHighlighting;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._highlightMode !== value) {\n                this._dictionary.update('H', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapHighlightMode)(value));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"bounds\", {\n        /**\n         * Gets the bounds of the annotation.\n         *\n         * @returns {{x: number, y: number, width: number, height: number}} Bounds.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Gets the bounds of the annotation.\n         * let bounds : {x: number, y: number, width: number, height: number} = annotation.bounds;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded && typeof this._bounds === 'undefined') {\n                this._bounds = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._calculateBounds)(this._dictionary, this._getPage());\n            }\n            if (typeof this._bounds === 'undefined' || this._bounds === null) {\n                this._bounds = { x: 0, y: 0, width: 0, height: 0 };\n            }\n            return this._bounds;\n        },\n        /**\n         * Sets the bounds of the annotation.\n         *\n         * @param {{x: number, y: number, width: number, height: number}} value Bounds\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Sets the bounds of the annotation.\n         * annotation.bounds = {0, 0, 50, 50};\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value.x === 0 && value.y === 0 && value.width === 0 && value.height === 0) {\n                throw new Error('Cannot set empty bounds');\n            }\n            this._bounds = value;\n            if (this._page && this._page._isNew && this._page._pageSettings) {\n                this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateBounds)(this));\n            }\n            else {\n                this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getUpdatedBounds)([value.x, value.y, value.width, value.height], this._getPage()));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"textAlignment\", {\n        /**\n         * Gets the text alignment of the annotation.\n         *\n         * @returns {PdfTextAlignment} Text alignment.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Gets the text alignment of the annotation.\n         * let textAlignment: PdfTextAlignment = annotation.textAlignment;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._textAlignment === 'undefined' && this._dictionary.has('Q')) {\n                this._textAlignment = this._dictionary.get('Q');\n            }\n            return this._textAlignment;\n        },\n        /**\n         * Sets the text alignment of the annotation.\n         *\n         * @param {PdfTextAlignment} value Text alignment.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Sets the text alignment of the annotation.\n         * annotation.textAlignment = PdfTextAlignment.left;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof this._textAlignment === 'undefined' || this._textAlignment !== value) {\n                this._dictionary.update('Q', value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"visibility\", {\n        /**\n         * Gets the visibility.\n         *\n         * @returns {PdfFormFieldVisibility} Field visibility option.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the form field at index 0\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Gets the visibility.\n         * let visibility: PdfFormFieldVisibility = field.itemAt(0).visibility;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            var value;\n            if (this._isLoaded) {\n                value = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.visible;\n                var flag = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.default;\n                if (this._hasFlags) {\n                    flag = this.flags;\n                    var flagValue = 3;\n                    if ((flag & _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.hidden) === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.hidden) {\n                        flagValue = 0;\n                    }\n                    if ((flag & _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.noView) === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.noView) {\n                        flagValue = 1;\n                    }\n                    if ((flag & _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.print) !== _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.print) {\n                        flagValue &= 2;\n                    }\n                    switch (flagValue) {\n                        case 0:\n                            value = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.hidden;\n                            break;\n                        case 1:\n                            value = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.hiddenPrintable;\n                            break;\n                        case 2:\n                            value = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.visibleNotPrintable;\n                            break;\n                        case 3:\n                            value = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.visible;\n                            break;\n                    }\n                }\n                else {\n                    value = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.visibleNotPrintable;\n                }\n            }\n            else {\n                return this._visibility;\n            }\n            return value;\n        },\n        /**\n         * Sets the visibility.\n         *\n         * @param {PdfFormFieldVisibility} value Visibility option.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access the form field at index 0\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Sets the visibility.\n         * let field.itemAt(0).visibility = PdfFormFieldVisibility.hiddenPrintable;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this._isLoaded) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_3__._updateVisibility)(this._dictionary, value);\n                this._dictionary._updated = true;\n            }\n            else {\n                switch (value) {\n                    case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.hidden:\n                        this.flags = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.hidden;\n                        break;\n                    case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.hiddenPrintable:\n                        this.flags = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.noView | _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.print;\n                        break;\n                    case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.visible:\n                        this.flags = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.print;\n                        break;\n                    case _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfFormFieldVisibility.visibleNotPrintable:\n                        this.flags = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.default;\n                        break;\n                }\n                this._visibility = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"font\", {\n        /**\n         * Gets the font of the item.\n         *\n         * @returns {PdfFont} font.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the form field at index 0\n         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;\n         * // Get the first item of the field\n         * let item: PdfWidgetAnnotation = field.itemAt(0);\n         * // Gets the font of the item.\n         * let font: PdfFont = item.font;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (!this._pdfFont) {\n                var fontName = void 0;\n                if (this._crossReference) {\n                    var form = this._crossReference._document.form;\n                    var fontData = this._obtainFontDetails();\n                    if (form && form._dictionary.has('DR')) {\n                        var resources = form._dictionary.get('DR');\n                        if (resources.has('Font')) {\n                            var fonts = resources.get('Font');\n                            if (fonts.has(fontData.name)) {\n                                var fontDictionary = fonts.get(fontData.name);\n                                if (fontDictionary && fontData.name && fontDictionary.has('BaseFont')) {\n                                    var baseFont = fontDictionary.get('BaseFont');\n                                    var textFontStyle = _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFontStyle.regular;\n                                    if (baseFont) {\n                                        fontName = baseFont.name;\n                                        textFontStyle = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getFontStyle)(baseFont.name);\n                                        if (fontName.includes('-')) {\n                                            fontName = fontName.substring(0, fontName.indexOf('-'));\n                                        }\n                                        this._pdfFont = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapFont)(fontName, fontData.size, textFontStyle, this);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if ((this._pdfFont === null || typeof this._pdfFont === 'undefined') || (!this._isLoaded && this._pdfFont.size === 1)) {\n                this._pdfFont = this._circleCaptionFont;\n            }\n            return this._pdfFont;\n        },\n        /**\n         * Sets the font of the item.\n         *\n         * @param {PdfFont} value font.\n         *\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the form field at index 0\n         * let field: PdfTextBoxField = document.form.fieldAt(0) as PdfTextBoxField;\n         * // Get the first item of the field\n         * let item: PdfWidgetAnnotation = field.itemAt(0);\n         * // Set the font of the item.\n         * item.font = new PdfStandardFont(PdfFontFamily.helvetica, 12, PdfFontStyle.bold);\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value && value instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfFont) {\n                this._pdfFont = value;\n                this._initializeFont(value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"_defaultAppearance\", {\n        get: function () {\n            if (typeof this._da === 'undefined' && this._dictionary.has('DA')) {\n                var da = this._dictionary.get('DA');\n                if (da && da !== '') {\n                    this._da = new _form_field__WEBPACK_IMPORTED_MODULE_4__._PdfDefaultAppearance(da);\n                }\n            }\n            return this._da;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfWidgetAnnotation.prototype, \"_mkDictionary\", {\n        get: function () {\n            var value;\n            if (this._dictionary.has('MK')) {\n                value = this._dictionary.get('MK');\n            }\n            return value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfWidgetAnnotation.prototype._create = function (page, bounds, field) {\n        this._page = page;\n        this._crossReference = page._crossReference;\n        this._ref = this._crossReference._getNextReference();\n        this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n        this._crossReference._cacheMap.set(this._ref, this._dictionary);\n        this._dictionary._currentObj = this;\n        this._dictionary.objId = this._ref.toString();\n        this._dictionary.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Annot'));\n        this._dictionary.update('Subtype', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Widget'));\n        this.flags |= _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfAnnotationFlag.print;\n        this._dictionary.update('P', page._ref);\n        page._addWidget(this._ref);\n        this.border = new PdfAnnotationBorder();\n        this.bounds = bounds;\n        if (field) {\n            this._field = field;\n            this._dictionary.update('Parent', this._field._ref);\n        }\n        return this._dictionary;\n    };\n    PdfWidgetAnnotation.prototype._doPostProcess = function (isFlatten, recreateAppearance) {\n        if (isFlatten === void 0) { isFlatten = false; }\n        if (recreateAppearance === void 0) { recreateAppearance = false; }\n        if (isFlatten || recreateAppearance) {\n            var appearanceStream = void 0;\n            if (recreateAppearance || (isFlatten && !this._dictionary.has('AP'))) {\n                //appearanceStream = this._createAppearance();\n            }\n            if (!appearanceStream && this._dictionary.has('AP')) {\n                var dictionary = this._dictionary.get('AP');\n                if (dictionary && dictionary.has('N')) {\n                    appearanceStream = dictionary.get('N');\n                    var reference = dictionary.getRaw('N');\n                    if (reference && appearanceStream) {\n                        appearanceStream.reference = reference;\n                    }\n                }\n            }\n            if (appearanceStream) {\n                var bounds = void 0;\n                if (isFlatten) {\n                    var template = new _graphics_pdf_template__WEBPACK_IMPORTED_MODULE_5__.PdfTemplate(appearanceStream, this._crossReference);\n                    var page = this._getPage();\n                    if (page) {\n                        var graphics = page.graphics;\n                        graphics.save();\n                        if (page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90) {\n                            graphics.translateTransform(graphics._size[0], graphics._size[1]);\n                            graphics.rotateTransform(90);\n                        }\n                        else if (page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180) {\n                            graphics.translateTransform(graphics._size[0], graphics._size[1]);\n                            graphics.rotateTransform(-180);\n                        }\n                        else if (page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270) {\n                            graphics.translateTransform(graphics._size[0], graphics._size[1]);\n                            graphics.rotateTransform(270);\n                        }\n                        bounds = { x: this.bounds.x, y: this.bounds.y, width: template._size[0], height: template._size[1] };\n                        graphics.drawTemplate(template, bounds);\n                        graphics.restore();\n                    }\n                }\n                else {\n                    var appearance = void 0;\n                    if (this._dictionary.has('AP')) {\n                        appearance = this._dictionary.get('AP');\n                    }\n                    else {\n                        var reference_8 = this._crossReference._getNextReference();\n                        appearance = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                        this._crossReference._cacheMap.set(reference_8, appearance);\n                        this._dictionary.update('AP', reference_8);\n                    }\n                    (0,_utils__WEBPACK_IMPORTED_MODULE_3__._removeDuplicateReference)(appearance, this._crossReference, 'N');\n                    var reference = this._crossReference._getNextReference();\n                    this._crossReference._cacheMap.set(reference, appearanceStream);\n                    appearance.update('N', reference);\n                }\n            }\n            this._dictionary._updated = false;\n        }\n    };\n    PdfWidgetAnnotation.prototype._initializeFont = function (font) {\n        this._pdfFont = font;\n        var document;\n        if (this._crossReference) {\n            document = this._crossReference._document;\n            var resource = void 0;\n            if (document) {\n                if (document.form._dictionary.has('DR')) {\n                    resource = document.form._dictionary.get('DR');\n                }\n                else {\n                    resource = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                }\n            }\n            var fontDict = void 0;\n            var isReference = false;\n            if (resource.has('Font')) {\n                var obj = resource.getRaw('Font'); // eslint-disable-line\n                if (obj && obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfReference) {\n                    isReference = true;\n                    fontDict = this._crossReference._fetch(obj);\n                }\n                else if (obj instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary) {\n                    fontDict = obj;\n                }\n            }\n            if (!fontDict) {\n                fontDict = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                resource.update('Font', fontDict);\n            }\n            var keyName = _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._getNewGuidString)());\n            var reference = this._crossReference._getNextReference();\n            this._crossReference._cacheMap.set(reference, this._pdfFont._dictionary);\n            if (font instanceof _fonts_pdf_standard_font__WEBPACK_IMPORTED_MODULE_8__.PdfTrueTypeFont) {\n                if (this._pdfFont._pdfFontInternals) {\n                    this._crossReference._cacheMap.set(reference, this._pdfFont._pdfFontInternals);\n                }\n            }\n            else if (this._pdfFont._dictionary) {\n                this._crossReference._cacheMap.set(reference, this._pdfFont._dictionary);\n            }\n            fontDict.update(keyName.name, reference);\n            resource._updated = true;\n            document.form._dictionary.update('DR', resource);\n            document.form._dictionary._updated = true;\n            this._fontName = keyName.name;\n            var defaultAppearance = new _form_field__WEBPACK_IMPORTED_MODULE_4__._PdfDefaultAppearance();\n            defaultAppearance.fontName = this._fontName;\n            defaultAppearance.fontSize = this._pdfFont._size;\n            defaultAppearance.color = this.color ? this.color : [0, 0, 0];\n            this._dictionary.update('DA', defaultAppearance.toString());\n            if (isReference) {\n                resource._updated = true;\n            }\n            this._isFont = true;\n        }\n    };\n    PdfWidgetAnnotation.prototype._getPage = function () {\n        if (!this._page) {\n            var document_2;\n            if (this._crossReference) {\n                document_2 = this._crossReference._document;\n            }\n            var page = void 0;\n            if (this._dictionary.has('P')) {\n                var ref = this._dictionary.getRaw('P');\n                if (ref && document_2) {\n                    for (var i = 0; i < document_2.pageCount; i++) {\n                        var entry = document_2.getPage(i);\n                        if (entry && entry._ref === ref) {\n                            page = entry;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!page && document_2 && this._ref) {\n                page = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._findPage)(document_2, this._ref);\n            }\n            this._page = page;\n        }\n        return this._page;\n    };\n    PdfWidgetAnnotation.prototype._beginSave = function () {\n        if (!this._isLoaded && !this._page._isNew) {\n            var value = this._bounds;\n            this._dictionary.update('Rect', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getUpdatedBounds)([value.x, value.y, value.width, value.height], this._page));\n        }\n    };\n    PdfWidgetAnnotation.prototype._parseBackColor = function () {\n        var value;\n        if ((this._isLoaded && this._hasBackColor) || (!this._isLoaded && !this._isTransparentBackColor)) {\n            if (typeof this._backColor === 'undefined') {\n                var dictionary = this._mkDictionary;\n                if (dictionary && dictionary.has('BG')) {\n                    var colorArray = dictionary.getArray('BG');\n                    if (colorArray) {\n                        this._backColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(colorArray);\n                    }\n                }\n            }\n            if (typeof this._backColor === 'undefined' || this._backColor === null) {\n                this._backColor = [255, 255, 255];\n            }\n            value = this._backColor;\n        }\n        return value;\n    };\n    PdfWidgetAnnotation.prototype._parseBorderColor = function () {\n        var value;\n        if ((this._isLoaded && this._hasBorderColor) || (!this._isLoaded && !this._isTransparentBorderColor)) {\n            if (typeof this._borderColor === 'undefined') {\n                var dictionary = this._mkDictionary;\n                if (dictionary && dictionary.has('BC')) {\n                    var colorArray = dictionary.getArray('BC');\n                    if (colorArray) {\n                        this._borderColor = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._parseColor)(colorArray);\n                    }\n                }\n            }\n            if (typeof this._borderColor === 'undefined' || this._borderColor === null) {\n                this._borderColor = [0, 0, 0];\n            }\n            value = this._borderColor;\n        }\n        return value;\n    };\n    PdfWidgetAnnotation.prototype._updateBackColor = function (value, setAppearance) {\n        if (setAppearance === void 0) { setAppearance = false; }\n        var isChanged = false;\n        if (value.length === 4 && value[3] !== 255) {\n            this._isTransparentBackColor = true;\n            if (this._dictionary.has('BG')) {\n                delete this._dictionary._map.BG;\n                isChanged = true;\n            }\n            var mkDictionary = this._mkDictionary;\n            if (mkDictionary && mkDictionary.has('BG')) {\n                delete mkDictionary._map.BG;\n                this._dictionary._updated = true;\n                isChanged = true;\n            }\n        }\n        else {\n            this._isTransparentBackColor = false;\n            if (typeof this.backColor === 'undefined' || this._backColor !== value) {\n                if (typeof this._mkDictionary === 'undefined') {\n                    this._dictionary.update('MK', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference));\n                }\n                this._mkDictionary.update('BG', [Number.parseFloat((value[0] / 255).toFixed(3)),\n                    Number.parseFloat((value[1] / 255).toFixed(3)),\n                    Number.parseFloat((value[2] / 255).toFixed(3))]);\n                this._backColor = [value[0], value[1], value[2]];\n                this._dictionary._updated = true;\n                isChanged = true;\n            }\n        }\n        if (setAppearance && isChanged && this._field) {\n            this._field._setAppearance = true;\n        }\n    };\n    PdfWidgetAnnotation.prototype._updateBorderColor = function (value) {\n        if (value.length === 4 && value[3] !== 255) {\n            this._isTransparentBorderColor = true;\n            if (this._dictionary.has('BC')) {\n                delete this._dictionary._map.BC;\n            }\n            var mkDictionary = this._mkDictionary;\n            if (mkDictionary && mkDictionary.has('BC')) {\n                delete mkDictionary._map.BC;\n                if (this._dictionary.has('BS')) {\n                    var bsDictionary = this._dictionary.get('BS');\n                    if (bsDictionary && bsDictionary.has('W')) {\n                        delete bsDictionary._map.W;\n                    }\n                }\n                this._dictionary._updated = true;\n            }\n        }\n        else {\n            this._isTransparentBorderColor = false;\n            if (typeof this.borderColor === 'undefined' || this.borderColor !== value) {\n                if (typeof this._mkDictionary === 'undefined') {\n                    this._dictionary.update('MK', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference));\n                }\n                this._mkDictionary.update('BC', [Number.parseFloat((value[0] / 255).toFixed(3)),\n                    Number.parseFloat((value[1] / 255).toFixed(3)),\n                    Number.parseFloat((value[2] / 255).toFixed(3))]);\n                this._borderColor = [value[0], value[1], value[2]];\n                this._dictionary._updated = true;\n            }\n        }\n    };\n    return PdfWidgetAnnotation;\n}(PdfAnnotation));\n\n/**\n * `PdfStateItem` class represents the check box field item objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Access check box field\n * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;\n * // Access first item of check box field\n * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;\n * // Sets the check box style as check\n * item.style = PdfCheckBoxStyle.check;\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfStateItem = /** @class */ (function (_super) {\n    __extends(PdfStateItem, _super);\n    /**\n     * Initializes a new instance of the `PdfStateItem` class.\n     *\n     * @private\n     */\n    function PdfStateItem() {\n        return _super.call(this) || this;\n    }\n    /**\n     * Parse an existing item of the field.\n     *\n     * @private\n     * @param {_PdfDictionary} dictionary Widget dictionary.\n     * @param {_PdfCrossReference} crossReference PDF cross reference.\n     * @param {PdfField} field Field object.\n     * @returns {PdfStateItem} Widget.\n     */\n    PdfStateItem._load = function (dictionary, crossReference, field) {\n        var widget = new PdfStateItem();\n        widget._isLoaded = true;\n        widget._dictionary = dictionary;\n        widget._crossReference = crossReference;\n        widget._field = field;\n        return widget;\n    };\n    Object.defineProperty(PdfStateItem.prototype, \"checked\", {\n        /**\n         * Gets the flag to indicate whether the field item is checked or not.\n         *\n         * @returns {boolean} Checked or not.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access check box field\n         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;\n         * // Access first item of check box field\n         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;\n         * // Gets the flag to indicate whether the field item is checked or not.\n         * let checked: boolean = item.checked;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return (0,_utils__WEBPACK_IMPORTED_MODULE_3__._checkField)(this._dictionary);\n        },\n        /**\n         * Sets the flag to indicate whether the field item is checked or not.\n         *\n         * @param {boolean} value Checked or not.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access check box field\n         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;\n         * // Access first item of check box field\n         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;\n         * // Sets the style of the annotation\n         * item.checked = true;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this.checked !== value) {\n                if (this._field) {\n                    this._setCheckedStatus(value);\n                    this._field._setAppearance = true;\n                }\n                this._dictionary.update('AS', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(value ? 'Yes' : 'Off'));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfStateItem.prototype, \"style\", {\n        /**\n         * Gets the style of annotation.\n         *\n         * @returns {PdfCheckBoxStyle} Style of annotation.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access check box field\n         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;\n         * // Access first item of check box field\n         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;\n         * // Gets the style of the annotation\n         * let style: PdfCheckBoxStyle = item.style;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded) {\n                var dictionary = this._mkDictionary;\n                if (dictionary && dictionary.has('CA')) {\n                    this._style = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._stringToStyle)(dictionary.get('CA'));\n                }\n                else {\n                    this._style = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfCheckBoxStyle.check;\n                }\n            }\n            return this._style;\n        },\n        /**\n         * Sets the style of annotation.\n         *\n         * @param {PdfCheckBoxStyle} value Style of annotation.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Access check box field\n         * let field: PdfCheckBoxField = document.form.fieldAt(0) as PdfCheckBoxField;\n         * // Access first item of check box field\n         * let item: PdfStateItem = field.itemAt(0) as PdfStateItem;\n         * // Sets the style of the annotation\n         * item.style = PdfCheckBoxStyle.check;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (this.style !== value) {\n                this._style = value;\n                var dictionary = this._mkDictionary;\n                if (!dictionary) {\n                    dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                    this._dictionary.update('MK', dictionary);\n                }\n                dictionary.update('CA', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._styleToString)(value));\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfStateItem.prototype._setCheckedStatus = function (value) {\n        var check = value;\n        var fieldValue = this._getItemValue(this._dictionary);\n        this._unCheckOthers(this, fieldValue, value);\n        if (check) {\n            if (!fieldValue) {\n                fieldValue = 'Yes';\n            }\n            this._field._dictionary.update('V', fieldValue);\n            this._dictionary.update('AS', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(fieldValue));\n            this._dictionary.update('V', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(fieldValue));\n        }\n        else if (this._field._dictionary) {\n            if (this._field._dictionary.has('V')) {\n                var v = this._field._dictionary.get('V');\n                if (v && v.name === fieldValue) {\n                    delete this._field._dictionary._map.V;\n                }\n            }\n            this._field._dictionary.update('AS', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Off'));\n        }\n    };\n    PdfStateItem.prototype._unCheckOthers = function (child, value, isChecked) {\n        if (!this._field._isUpdating) {\n            this._field._isUpdating = true;\n            var count = this._field.itemsCount;\n            for (var i = 0; i < count; ++i) {\n                var item = this._field.itemAt(i);\n                if (item) {\n                    if (item !== child) {\n                        item.checked = ((this._getItemValue(item._dictionary) === value) && isChecked);\n                    }\n                    else if (!item.checked) {\n                        item.checked = true;\n                    }\n                }\n            }\n        }\n    };\n    PdfStateItem.prototype._getItemValue = function (dictionary) {\n        var itemValue = '';\n        if (dictionary && dictionary.has('AS')) {\n            var asValue = dictionary.get('AS');\n            if (asValue && asValue.name !== 'Off') {\n                itemValue = 'Off';\n            }\n        }\n        if (itemValue === '') {\n            if (dictionary && dictionary.has('AP')) {\n                var apDictionary = dictionary.get('AP');\n                if (apDictionary && apDictionary.has('N')) {\n                    var normalAppearance = apDictionary.get('N');\n                    var keyList_1 = [];\n                    normalAppearance.forEach(function (key, value) {\n                        keyList_1.push(key);\n                    });\n                    if (keyList_1.length > 0) {\n                        for (var i = 0; i < keyList_1.length; i++) {\n                            var key = keyList_1[Number.parseInt(i.toString(), 10)];\n                            if (key && key !== 'Off') {\n                                itemValue = key;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return itemValue;\n    };\n    PdfStateItem.prototype._doPostProcess = function () {\n        var style = this.checked ? _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfCheckFieldState.checked : _enumerator__WEBPACK_IMPORTED_MODULE_2__._PdfCheckFieldState.unchecked;\n        var template = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getStateTemplate)(style, this);\n        if (template) {\n            var page = this._getPage();\n            if (page) {\n                var graphics = page.graphics;\n                graphics.save();\n                if (page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle90) {\n                    graphics.translateTransform(graphics._size[0], graphics._size[1]);\n                    graphics.rotateTransform(90);\n                }\n                else if (page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle180) {\n                    graphics.translateTransform(graphics._size[0], graphics._size[1]);\n                    graphics.rotateTransform(-180);\n                }\n                else if (page.rotation === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfRotationAngle.angle270) {\n                    graphics.translateTransform(graphics._size[0], graphics._size[1]);\n                    graphics.rotateTransform(270);\n                }\n                graphics._sw._setTextRenderingMode(_graphics_pdf_graphics__WEBPACK_IMPORTED_MODULE_6__._TextRenderingMode.fill);\n                graphics.drawTemplate(template, this.bounds);\n                graphics.restore();\n            }\n        }\n        this._dictionary._updated = false;\n    };\n    PdfStateItem.prototype._postProcess = function (value) {\n        var field = this._field;\n        if (!value) {\n            value = (field && field.checked) ? 'Yes' : 'Off';\n        }\n        this._dictionary.update('AS', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(value));\n    };\n    PdfStateItem.prototype._setField = function (field) {\n        this._field = field;\n        this._field._stringFormat = new _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfStringFormat(this.textAlignment, _fonts_pdf_string_format__WEBPACK_IMPORTED_MODULE_9__.PdfVerticalAlignment.middle);\n        this._field._addToKid(this);\n    };\n    return PdfStateItem;\n}(PdfWidgetAnnotation));\n\n/**\n * `PdfRadioButtonListItem` class represents the radio button field item objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Gets the first page of the document\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Access the PDF form\n * let form: PdfForm = document.form;\n * // Create a new radio button list field\n * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');\n * // Create and add first item\n * let first: PdfRadioButtonListItem = field.add('1-9', {x: 100, y: 140, width: 20, height: 20});\n * // Create and add second item\n * let second: PdfRadioButtonListItem = new PdfRadioButtonListItem('10-49', {x: 100, y: 170, width: 20, height: 20}, page);\n * field.add(second);\n * // Create and add third item\n * let third: PdfRadioButtonListItem = new PdfRadioButtonListItem('50-59', {x: 100, y: 200, width: 20, height: 20}, field);\n * field.add(third);\n * // Sets selected index of the radio button list field\n * field.selectedIndex = 0;\n * // Add the field into PDF form\n * form.add(field);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfRadioButtonListItem = /** @class */ (function (_super) {\n    __extends(PdfRadioButtonListItem, _super);\n    function PdfRadioButtonListItem(value, bounds, item) {\n        var _this = _super.call(this) || this;\n        if (item && value && bounds) {\n            if (item instanceof _form_field__WEBPACK_IMPORTED_MODULE_4__.PdfField) {\n                _this._initializeItem(value, bounds, item.page, item);\n            }\n            else {\n                _this._initializeItem(value, bounds, item);\n            }\n        }\n        return _this;\n    }\n    /**\n     * Parse an existing item of the field.\n     *\n     * @private\n     * @param {_PdfDictionary} dictionary Widget dictionary.\n     * @param {_PdfCrossReference} crossReference PDF cross reference.\n     * @param {PdfField} field Field object.\n     * @returns {PdfRadioButtonListItem} Widget.\n     */\n    PdfRadioButtonListItem._load = function (dictionary, crossReference, field) {\n        var widget = new PdfRadioButtonListItem();\n        widget._isLoaded = true;\n        widget._dictionary = dictionary;\n        widget._crossReference = crossReference;\n        widget._field = field;\n        return widget;\n    };\n    Object.defineProperty(PdfRadioButtonListItem.prototype, \"selected\", {\n        /**\n         * Gets the flag to indicate whether the field item is selected or not.\n         *\n         * @returns {boolean} Selected or not.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Gets the first page of the document\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the PDF form\n         * let form: PdfForm = document.form;\n         * // Create a new radio button list field\n         * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');\n         * // Access first list field item\n         * let item: PdfRadioButtonListItem = field.itemAt(0);\n         * // Gets the flag to indicate whether the field item is selected or not.\n         * let selected: boolean = item.selected;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._index === this._field.selectedIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRadioButtonListItem.prototype, \"value\", {\n        /**\n         * Gets the value of the radio button list field item\n         *\n         * @returns {string} Value of the radio button list field item.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Gets the first page of the document\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the PDF form\n         * let form: PdfForm = document.form;\n         * // Create a new radio button list field\n         * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');\n         * // Access first list field item\n         * let item: PdfRadioButtonListItem = field.itemAt(0);\n         * // Gets the value of the radio button list field item\n         * let value: string = item.value;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (this._isLoaded && !this._optionValue) {\n                this._optionValue = (0,_utils__WEBPACK_IMPORTED_MODULE_3__._getItemValue)(this._dictionary);\n            }\n            return this._optionValue;\n        },\n        /**\n         * Sets the value of the radio button list field item\n         *\n         * @param {string} option Value of the radio button list field item.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Gets the first page of the document\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the PDF form\n         * let form: PdfForm = document.form;\n         * // Create a new radio button list field\n         * let field: PdfRadioButtonListField = new PdfRadioButtonListField(page, 'Age');\n         * // Access first list field item\n         * let item: PdfRadioButtonListItem = field.itemAt(0);\n         * // Sets the value of the radio button list field item\n         * item.value = '1-9';\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (option) {\n            this._optionValue = option;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfRadioButtonListItem.prototype, \"backColor\", {\n        /**\n         * Gets the back color of the annotation.\n         *\n         * @returns {number[]} Color as R, G, B color array in between 0 to 255.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfWidgetAnnotation = page.annotations.at(0) as PdfWidgetAnnotation;\n         * // Gets the back color of the annotation\n         * let backColor: number[] = annotation.backColor;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._parseBackColor();\n        },\n        /**\n         * Sets the back color of the annotation.\n         *\n         * @param {number[]} value Array with R, G, B, A color values in between 0 to 255. For optional A (0-254), it signifies transparency.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Gets the first page of the document\n         * let page: PdfPage = document.getPage(0);\n         * // Access the PDF form\n         * let form: PdfForm = document.form;\n         * // Access the radio button list field\n         * let field: PdfRadioButtonListField = form.fieldAt(0) as PdfRadioButtonListField;\n         * // Sets the back color of the radio button list item\n         * field.itemAt(0).backColor = [255, 255, 255];\n         * // Sets the background color of the field item to transparent\n         * field.itemAt(1).backColor = [0, 0, 0, 0];\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            this._updateBackColor(value, true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfRadioButtonListItem.prototype._initializeItem = function (value, bounds, page, field) {\n        this._optionValue = value;\n        this._page = page;\n        this._create(this._page, bounds, this._field);\n        this.textAlignment = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfTextAlignment.left;\n        this._dictionary.update('MK', new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference));\n        this._mkDictionary.update('BC', [0, 0, 0]);\n        this._mkDictionary.update('BG', [1, 1, 1]);\n        this.style = _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfCheckBoxStyle.circle;\n        this._dictionary.update('DA', '/TiRo 0 Tf 0 0 0 rg');\n        if (field) {\n            this._setField(field);\n            this._dictionary.update('Parent', field._ref);\n        }\n    };\n    PdfRadioButtonListItem.prototype._postProcess = function (value) {\n        var field = this._field;\n        if (!value && field && field.selectedIndex !== -1) {\n            value = field.itemAt(field.selectedIndex).value;\n        }\n        if (this.value === value) {\n            this._dictionary.update('AS', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(this.value));\n        }\n        else {\n            this._dictionary.update('AS', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Off'));\n        }\n    };\n    return PdfRadioButtonListItem;\n}(PdfStateItem));\n\n/**\n * `PdfListBoxItem` class represents the list and combo box field item objects.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data);\n * // Gets the first page of the document\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Access the PDF form\n * let form: PdfForm = document.form;\n * // Create a new list box field\n * let field: PdfListBoxField = new PdfListBoxField(page, 'list1', {x: 100, y: 60, width: 100, height: 50});\n * // Add list items to the field.\n * field.addItem(new PdfListFieldItem('English', 'English'));\n * field.addItem(new PdfListFieldItem('French', 'French'));\n * field.addItem(new PdfListFieldItem('German', 'German'));\n * // Sets the selected index\n * field.selectedIndex = 2;\n * // Sets the flag indicates whether the list box allows multiple selections.\n * field.multiSelect = true;\n * // Add the field into PDF form\n * form.add(field);\n * // Save the document\n * document.save('output.pdf');\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfListFieldItem = /** @class */ (function (_super) {\n    __extends(PdfListFieldItem, _super);\n    function PdfListFieldItem(text, value, field) {\n        var _this = _super.call(this) || this;\n        if (text && value) {\n            _this._initializeItem(text, value, field);\n        }\n        return _this;\n    }\n    /**\n     * Parse an existing item of the field.\n     *\n     * @private\n     * @param {_PdfDictionary} dictionary Widget dictionary.\n     * @param {_PdfCrossReference} crossReference PDF cross reference.\n     * @param {PdfField} field Field object.\n     * @returns {PdfListFieldItem} Widget.\n     */\n    PdfListFieldItem._load = function (dictionary, crossReference, field) {\n        var widget = new PdfListFieldItem();\n        widget._isLoaded = true;\n        widget._dictionary = dictionary;\n        widget._crossReference = crossReference;\n        widget._field = field;\n        return widget;\n    };\n    Object.defineProperty(PdfListFieldItem.prototype, \"text\", {\n        /**\n         * Gets the text of the annotation.\n         *\n         * @returns {string} Text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Gets the first page of the document\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the PDF form\n         * let form: PdfForm = document.form;\n         * // Create a new radio button list field\n         * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;\n         * // Access first list field item\n         * let item: PdfListFieldItem = field.itemAt(0);\n         * // Gets the text of the list field item\n         * let text: string = item.text;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            if (typeof this._text === 'undefined' &&\n                typeof this._field !== 'undefined' &&\n                (this._field instanceof _form_field__WEBPACK_IMPORTED_MODULE_4__.PdfListBoxField || this._field instanceof _form_field__WEBPACK_IMPORTED_MODULE_4__.PdfComboBoxField)) {\n                this._text = this._field._options[Number.parseInt(this._index.toString(), 10)][1];\n            }\n            return this._text;\n        },\n        /**\n         * Sets the text of the annotation.\n         *\n         * @param {string} value Text.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Gets the first page of the document\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the PDF form\n         * let form: PdfForm = document.form;\n         * // Create a new radio button list field\n         * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;\n         * // Access first list field item\n         * let item: PdfListFieldItem = field.itemAt(0);\n         * // Sets the text of the list field item\n         * item.text = '1-9';\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof value === 'string' &&\n                typeof this._field !== 'undefined' &&\n                (this._field instanceof _form_field__WEBPACK_IMPORTED_MODULE_4__.PdfListBoxField || this._field instanceof _form_field__WEBPACK_IMPORTED_MODULE_4__.PdfComboBoxField)) {\n                if (value !== this._field._options[Number.parseInt(this._index.toString(), 10)][1]) {\n                    this._field._options[Number.parseInt(this._index.toString(), 10)][1] = value;\n                    this._text = value;\n                    this._field._dictionary._updated = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfListFieldItem.prototype, \"selected\", {\n        /**\n         * Gets the flag to indicate whether the field item is selected or not (Read only).\n         *\n         * @returns {boolean} Selected or not.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data);\n         * // Gets the first page of the document\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Access the PDF form\n         * let form: PdfForm = document.form;\n         * // Create a new radio button list field\n         * let field: PdfListBoxField = form.fieldAt(0) as PdfListBoxField;\n         * // Access first list field item\n         * let item: PdfListFieldItem = field.itemAt(0);\n         * // Gets the flag to indicate whether the field item is selected or not.\n         * let selected: boolean = item.selected;\n         * // Save the document\n         * document.save('output.pdf');\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._index === this._field.selectedIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfListFieldItem.prototype._initializeItem = function (text, value, field) {\n        this._text = text;\n        this._value = value;\n        if (field && field instanceof _form_field__WEBPACK_IMPORTED_MODULE_4__.PdfListBoxField) {\n            field._addToOptions(this, field);\n        }\n    };\n    return PdfListFieldItem;\n}(PdfStateItem));\n\n/**\n * `PdfAnnotationCaption` class represents the caption text and properties of annotations.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Get the first annotation of the page\n * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n * // Create and set annotation caption values\n * annotation.caption = new PdfAnnotationCaption(true, PdfLineCaptionType.inline, [10, 10]);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationCaption = /** @class */ (function () {\n    function PdfAnnotationCaption(cap, type, offset) {\n        this._cap = typeof cap !== 'undefined' ? cap : false;\n        this._type = typeof type !== 'undefined' ? type : _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.inline;\n        this._offset = typeof offset !== 'undefined' ? offset : [0, 0];\n    }\n    Object.defineProperty(PdfAnnotationCaption.prototype, \"cap\", {\n        /**\n         * Gets the boolean flag indicating whether annotation has caption or not.\n         *\n         * @returns {boolean} Caption.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the boolean flag indicating whether annotation has caption or not.\n         * let cap: boolean = annotation.caption.cap;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._cap;\n        },\n        /**\n         * Sets the boolean flag indicating whether annotation has caption or not.\n         *\n         * @param {boolean} value Caption.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the boolean flag indicating whether annotation has caption or not.\n         * annotation.caption.cap = true;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._cap) {\n                this._cap = value;\n                if (this._dictionary) {\n                    this._dictionary.update('Cap', value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotationCaption.prototype, \"type\", {\n        /**\n         * Gets the caption type of the annotation.\n         *\n         * @returns {PdfLineCaptionType} Caption type.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the caption type of the annotation.\n         * let type: PdfLineCaptionType = annotation.caption.type;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._type;\n        },\n        /**\n         * Sets the caption type of the annotation.\n         *\n         * @param {PdfLineCaptionType} value Caption type.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the caption type of the annotation.\n         * annotation.caption.type = PdfLineCaptionType.inline;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._type) {\n                this._type = value;\n                if (this._dictionary) {\n                    this._dictionary.update('CP', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get(value === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineCaptionType.top ? 'Top' : 'Inline'));\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotationCaption.prototype, \"offset\", {\n        /**\n         * Gets the offset position of the annotation.\n         *\n         * @returns {Array<number>} Caption offset.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the offset position of the annotation.\n         * let offset: Array<number> = annotation.caption.offset;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._offset;\n        },\n        /**\n         * Sets the offset position of the annotation.\n         *\n         * @param {Array<number>} value Caption offset.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Sets the offset position of the annotation.\n         * annotation.caption.offset = [10, 10];\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__._areNotEqual)(value, this._offset)) {\n                this._offset = value;\n                if (this._dictionary) {\n                    this._dictionary.update('CO', value);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfAnnotationCaption;\n}());\n\n/**\n * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Get the first annotation of the page\n * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.\n * annotation.lineEndingStyle = new PdfAnnotationLineEndingStyle(PdfLineEndingStyle.openArrow, PdfLineEndingStyle.closeArrow);\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationLineEndingStyle = /** @class */ (function () {\n    function PdfAnnotationLineEndingStyle(begin, end) {\n        this._begin = typeof begin !== 'undefined' ? begin : _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.none;\n        this._end = typeof end !== 'undefined' ? end : _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfLineEndingStyle.none;\n    }\n    Object.defineProperty(PdfAnnotationLineEndingStyle.prototype, \"begin\", {\n        /**\n         * Gets the begin line ending style of the annotation.\n         *\n         * @returns {PdfLineEndingStyle} Begin line ending style.\n         * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the begin line ending style of the annotation.\n         * let begin: PdfLineEndingStyle = annotation.lineEndingStyle.begin;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._begin;\n        },\n        /**\n         * Sets the begin line ending style of the annotation.\n         *\n         * @param {PdfLineEndingStyle} value Begin line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.\n         * let lineEndingStyle = new PdfAnnotationLineEndingStyle();\n         * // Sets the begin line ending style of the annotation.\n         * lineEndingStyle.begin = PdfLineEndingStyle.openArrow;\n         * // Sets the end line ending style of the annotation.\n         * lineEndingStyle.end = PdfLineEndingStyle.closeArrow;\n         * // Sets the line ending style to the annotation\n         * annotation.lineEndingStyle = lineEndingStyle;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._begin) {\n                this._begin = value;\n                if (this._dictionary) {\n                    this._dictionary.update('LE', [_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(value)), _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this._end))]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotationLineEndingStyle.prototype, \"end\", {\n        /**\n         * Gets the begin line ending style of the annotation.\n         *\n         * @returns {PdfLineEndingStyle} End line ending style.\n         * `PdfAnnotationLineEndingStyle` class represents the line ending styles of annotations.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the end line ending style of the annotation.\n         * let end: PdfLineEndingStyle = annotation.lineEndingStyle.end;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._end;\n        },\n        /**\n         * Sets the begin line ending style of the annotation.\n         *\n         * @param {PdfLineEndingStyle} value End line ending style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Initializes a new instance of the `PdfAnnotationLineEndingStyle` class.\n         * let lineEndingStyle = new PdfAnnotationLineEndingStyle();\n         * // Sets the begin line ending style of the annotation.\n         * lineEndingStyle.begin = PdfLineEndingStyle.openArrow;\n         * // Sets the end line ending style of the annotation.\n         * lineEndingStyle.end = PdfLineEndingStyle.closeArrow;\n         * // Sets the line ending style to the annotation\n         * annotation.lineEndingStyle = lineEndingStyle;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._end) {\n                this._end = value;\n                if (this._dictionary) {\n                    this._dictionary.update('LE', [_pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(this._begin)), _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get((0,_utils__WEBPACK_IMPORTED_MODULE_3__._reverseMapEndingStyle)(value))]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfAnnotationLineEndingStyle;\n}());\n\n/**\n * `PdfInteractiveBorder` class represents the border of the field.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the PDF form field\n * let field: PdfField = document.form.fieldAt(0);\n * // Gets the width of the field border.\n * let width: number = field.border.width;\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfInteractiveBorder = /** @class */ (function () {\n    function PdfInteractiveBorder(width, style, dash) {\n        this._width = typeof width !== 'undefined' ? width : 1;\n        this._style = typeof style !== 'undefined' ? style : _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderStyle.solid;\n        if (typeof dash !== 'undefined' && Array.isArray(dash)) {\n            this._dash = dash;\n        }\n    }\n    Object.defineProperty(PdfInteractiveBorder.prototype, \"width\", {\n        /**\n         * Gets the width of the field border.\n         *\n         * @returns {number} border width.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the PDF form field\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Gets the width of the annotation border.\n         * let width: number = field.border.width;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._width;\n        },\n        /**\n         * Sets the width of the field border.\n         *\n         * @param {number} value width.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the PDF form field\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Initializes a new instance of the `PdfInteractiveBorder` class.\n         * let border: PdfInteractiveBorder = new PdfInteractiveBorder();\n         * //Sets the width of the annotation border.\n         * border.width = 10;\n         * //Sets the style of the annotation border.\n         * border.style = PdfBorderStyle.dashed;\n         * //Sets the dash pattern of the annotation border.\n         * border.dash = [1, 2, 1];\n         * // Sets the border to the PDF form field\n         * field.border = border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._width) {\n                this._width = value;\n                if (this._dictionary) {\n                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                    bs.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n                    bs.update('W', this._width);\n                    bs.update('S', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderStyle)(this._style));\n                    if (this._dash) {\n                        bs.update('D', this._dash);\n                    }\n                    this._dictionary.update('BS', bs);\n                    this._dictionary._updated = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfInteractiveBorder.prototype, \"style\", {\n        /**\n         * Gets the border line style of the field border.\n         *\n         * @returns {PdfBorderStyle} Border style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the PDF form field\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Gets the border line style of the annotation border.\n         * let style: PdfBorderStyle = field.border.style;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._style;\n        },\n        /**\n         * Sets the border line style of the field border.\n         *\n         * @param {PdfBorderStyle} value Border style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the PDF form field\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Initializes a new instance of the `PdfInteractiveBorder` class.\n         * let border: PdfInteractiveBorder = new PdfInteractiveBorder();\n         * //Sets the width of the annotation border.\n         * border.width = 10;\n         * //Sets the style of the annotation border.\n         * border.style = PdfBorderStyle.dashed;\n         * //Sets the dash pattern of the annotation border.\n         * border.dash = [1, 2, 1];\n         * // Sets the border to the PDF form field\n         * field.border = border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._style) {\n                this._style = value;\n                if (this._dictionary) {\n                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                    bs.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n                    bs.update('W', this._width);\n                    bs.update('S', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderStyle)(this._style));\n                    if (this._dash) {\n                        bs.update('D', this._dash);\n                    }\n                    this._dictionary.update('BS', bs);\n                    this._dictionary._updated = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfInteractiveBorder.prototype, \"dash\", {\n        /**\n         * Gets the dash pattern of the field border.\n         *\n         * @returns {Array<number>} Dash pattern.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the PDF form field\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Gets the dash pattern of the field border.\n         * let dash: Array<number> = field.border.dash;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._dash;\n        },\n        /**\n         * Sets the dash pattern of the field border.\n         *\n         * @param {Array<number>} value Dash pattern.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the PDF form field\n         * let field: PdfField = document.form.fieldAt(0);\n         * // Initializes a new instance of the `PdfInteractiveBorder` class.\n         * let border: PdfInteractiveBorder = new PdfInteractiveBorder();\n         * //Sets the width of the annotation border.\n         * border.width = 10;\n         * //Sets the style of the annotation border.\n         * border.style = PdfBorderStyle.dashed;\n         * //Sets the dash pattern of the annotation border.\n         * border.dash = [1, 2, 1];\n         * // Sets the border to the PDF form field\n         * field.border = border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (typeof this._dash === 'undefined' || (0,_utils__WEBPACK_IMPORTED_MODULE_3__._areNotEqual)(value, this._dash)) {\n                this._dash = value;\n                if (this._dictionary) {\n                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                    bs.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n                    bs.update('W', this._width);\n                    bs.update('S', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderStyle)(this._style));\n                    bs.update('D', this._dash);\n                    this._dictionary.update('BS', bs);\n                    this._dictionary._updated = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfInteractiveBorder;\n}());\n\n/**\n * `PdfAnnotationBorder` class represents the border properties of annotations.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Get the first annotation of the page\n * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n * // Initializes a new instance of the ` PdfAnnotationBorder ` class.\n * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();\n * //Sets the width of the annotation border.\n * border.width = 10;\n * //Sets the style of the annotation border.\n * border.style = PdfBorderStyle.dashed;\n * //Sets the dash pattern of the annotation border.\n * border.dash = [1, 2, 1];\n * // Sets the border to the PDF form field\n * annotation.border = border;\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfAnnotationBorder = /** @class */ (function (_super) {\n    __extends(PdfAnnotationBorder, _super);\n    function PdfAnnotationBorder(width, hRadius, vRadius, style, dash) {\n        var _this = _super.call(this, width, style, dash) || this;\n        _this._hRadius = typeof hRadius !== 'undefined' ? hRadius : 0;\n        _this._vRadius = typeof vRadius !== 'undefined' ? vRadius : 0;\n        return _this;\n    }\n    Object.defineProperty(PdfAnnotationBorder.prototype, \"width\", {\n        /**\n         * Gets the width of the annotation border.\n         *\n         * @returns {number} border width.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the width of the annotation border.\n         * let width: number = annotation.border.width;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._width;\n        },\n        /**\n         * Sets the width of the annotation border.\n         *\n         * @param {number} value width.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.\n         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();\n         * //Sets the width of the annotation border.\n         * border.width = 10;\n         * //Sets the style of the annotation border.\n         * border.style = PdfBorderStyle.dashed;\n         * //Sets the dash pattern of the annotation border.\n         * border.dash = [1, 2, 1];\n         * // Sets the border to the PDF form field\n         * annotation.border = border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._width) {\n                this._width = value;\n                if (this._dictionary) {\n                    this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);\n                    var bs = this._dictionary.has('BS') ? this._dictionary.get('BS') : new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                    bs.update('Type', _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfName.get('Border'));\n                    bs.update('W', this._width);\n                    bs.update('S', (0,_utils__WEBPACK_IMPORTED_MODULE_3__._mapBorderStyle)(this._style));\n                    if (this._dash) {\n                        bs.update('D', this._dash);\n                    }\n                    this._dictionary.update('BS', bs);\n                    this._dictionary._updated = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotationBorder.prototype, \"hRadius\", {\n        /**\n         * Gets the horizontal radius of the annotation border.\n         *\n         * @returns {number} horizontal radius.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the horizontal radius of the annotation border.\n         * let hRadius: number = annotation.border.hRadius;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._hRadius;\n        },\n        /**\n         * Sets the horizontal radius of the annotation border.\n         *\n         * @param {number} value horizontal radius.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.\n         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();\n         * //Sets the width of the annotation border.\n         * border.width = 10;\n         * // Sets the horizontal radius of the annotation border.\n         * border.hRadius = 2;\n         * //Sets the style of the annotation border.\n         * border.style = PdfBorderStyle.dashed;\n         * //Sets the dash pattern of the annotation border.\n         * border.dash = [1, 2, 1];\n         * // Sets the border to the PDF form field\n         * annotation.border = border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._hRadius) {\n                this._hRadius = value;\n                if (this._dictionary) {\n                    this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfAnnotationBorder.prototype, \"vRadius\", {\n        /**\n         * Gets the vertical radius of the annotation border.\n         *\n         * @returns {number} vertical radius.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Gets the vertical radius of the annotation border.\n         * let vRadius: number = annotation.border.vRadius;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._vRadius;\n        },\n        /**\n         * Sets the vertical radius of the annotation border.\n         *\n         * @param {number} value vertical radius.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfLineAnnotation = page.annotations.at(0) as PdfLineAnnotation;\n         * // Initializes a new instance of the ` PdfAnnotationBorder ` class.\n         * let border: PdfAnnotationBorder = new PdfAnnotationBorder ();\n         * //Sets the width of the annotation border.\n         * border.width = 10;\n         * // Sets the vertical radius of the annotation border.\n         * border.vRadius = 2;\n         * //Sets the style of the annotation border.\n         * border.style = PdfBorderStyle.dashed;\n         * //Sets the dash pattern of the annotation border.\n         * border.dash = [1, 2, 1];\n         * // Sets the border to the PDF form field\n         * annotation.border = border;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._vRadius) {\n                this._vRadius = value;\n                if (this._dictionary) {\n                    this._dictionary.update('Border', [this._hRadius, this._vRadius, this._width]);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PdfAnnotationBorder;\n}(PdfInteractiveBorder));\n\n/**\n * `PdfBorderEffect` class represents the border effects of annotations.\n * ```typescript\n * // Load an existing PDF document\n * let document: PdfDocument = new PdfDocument(data, password);\n * // Get the first page\n * let page: PdfPage = document.getPage(0) as PdfPage;\n * // Get the first annotation of the page\n * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n * // Initializes a new instance of the `PdfBorderEffect` class.\n * let borderEffect: PdfBorderEffect = new PdfBorderEffect();\n * // Sets the intensity of the annotation border.\n * borderEffect.intensity = 2;\n * // Sets the effect style of the annotation border.\n * borderEffect.style = PdfBorderEffectStyle.cloudy;\n * // Sets border effect to the annotation.\n * annotation.borderEffect = borderEffect;\n * // Destroy the document\n * document.destroy();\n * ```\n */\nvar PdfBorderEffect = /** @class */ (function () {\n    function PdfBorderEffect(dictionary) {\n        this._intensity = 0;\n        if (typeof dictionary !== 'undefined' && dictionary !== null) {\n            if (dictionary.has('BE')) {\n                var borderEffect = this._dictionary.get('BE');\n                if (borderEffect) {\n                    if (borderEffect.has('I')) {\n                        this._intensity = borderEffect.get('I');\n                    }\n                    if (borderEffect.has('S')) {\n                        this._style = this._getBorderEffect(borderEffect.get('S'));\n                    }\n                }\n            }\n        }\n        else {\n            this._dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary();\n            this._dictionary.set('I', this._intensity);\n            this._dictionary.set('S', this._styleToEffect(this._style));\n        }\n    }\n    Object.defineProperty(PdfBorderEffect.prototype, \"intensity\", {\n        /**\n         * Gets the intensity of the annotation border.\n         *\n         * @returns {number} intensity.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Gets the intensity of the annotation border.\n         * let intensity: number = annotation.borderEffect.intensity;\n         * // Gets the effect style of the annotation border.\n         * let style: PdfBorderEffectStyle = annotation.borderEffect.style;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._intensity;\n        },\n        /**\n         * Sets the intensity of the annotation border.\n         *\n         * @param {number} value intensity.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Initializes a new instance of the `PdfBorderEffect` class.\n         * let borderEffect: PdfBorderEffect = new PdfBorderEffect();\n         * // Sets the intensity of the annotation border.\n         * borderEffect.intensity = 2;\n         * // Sets the effect style of the annotation border.\n         * borderEffect.style = PdfBorderEffectStyle.cloudy;\n         * // Sets border effect to the annotation.\n         * annotation.borderEffect = borderEffect;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._intensity) {\n                this._intensity = value;\n                if (this._dictionary) {\n                    var bs = this._dictionary.has('BE') ? this._dictionary.get('BE') : new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                    bs.update('I', this._intensity);\n                    bs.update('S', this._styleToEffect(this._style));\n                    this._dictionary.update('BE', bs);\n                    this._dictionary._updated = true;\n                }\n                this._dictionary._updated = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PdfBorderEffect.prototype, \"style\", {\n        /**\n         * Gets the effect style of the annotation border.\n         *\n         * @returns {PdfBorderEffectStyle} effect style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Gets the intensity of the annotation border.\n         * let intensity: number = annotation.borderEffect.intensity;\n         * // Gets the effect style of the annotation border.\n         * let style: PdfBorderEffectStyle = annotation.borderEffect.style;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        get: function () {\n            return this._style;\n        },\n        /**\n         * Sets the effect style of the annotation border.\n         *\n         * @param {PdfBorderEffectStyle} value effect style.\n         * ```typescript\n         * // Load an existing PDF document\n         * let document: PdfDocument = new PdfDocument(data, password);\n         * // Get the first page\n         * let page: PdfPage = document.getPage(0) as PdfPage;\n         * // Get the first annotation of the page\n         * let annotation: PdfSquareAnnotation = page.annotations.at(0) as PdfSquareAnnotation;\n         * // Initializes a new instance of the `PdfBorderEffect` class.\n         * let borderEffect: PdfBorderEffect = new PdfBorderEffect();\n         * // Sets the intensity of the annotation border.\n         * borderEffect.intensity = 2;\n         * // Sets the effect style of the annotation border.\n         * borderEffect.style = PdfBorderEffectStyle.cloudy;\n         * // Sets border effect to the annotation.\n         * annotation.borderEffect = borderEffect;\n         * // Destroy the document\n         * document.destroy();\n         * ```\n         */\n        set: function (value) {\n            if (value !== this._style) {\n                this._style = value;\n                if (this._dictionary) {\n                    var bs = this._dictionary.has('BE') ?\n                        this._dictionary.get('BE') :\n                        new _pdf_primitives__WEBPACK_IMPORTED_MODULE_1__._PdfDictionary(this._crossReference);\n                    bs.update('I', this._intensity);\n                    bs.update('S', this._styleToEffect(this._style));\n                    this._dictionary.update('BE', bs);\n                    this._dictionary._updated = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PdfBorderEffect.prototype._getBorderEffect = function (value) {\n        if (value === '/C') {\n            return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy;\n        }\n        else {\n            return _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.solid;\n        }\n    };\n    PdfBorderEffect.prototype._styleToEffect = function (value) {\n        if (value === _enumerator__WEBPACK_IMPORTED_MODULE_2__.PdfBorderEffectStyle.cloudy) {\n            return 'C';\n        }\n        else {\n            return 'S';\n        }\n    };\n    return PdfBorderEffect;\n}());\n\nvar _PaintParameter = /** @class */ (function () {\n    function _PaintParameter() {\n        this.borderWidth = 1;\n    }\n    return _PaintParameter;\n}());\n\nvar _CloudStyleArc = /** @class */ (function () {\n    function _CloudStyleArc() {\n        this.startAngle = 0;\n        this.endAngle = 0;\n    }\n    return _CloudStyleArc;\n}());\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/annotations/annotation.js?");

/***/ })

}]);