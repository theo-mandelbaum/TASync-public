"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdf_src_pdf_core_pdf-parser_js-8345ee30"],{

/***/ "./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-parser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-parser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _Linearization: () => (/* binding */ _Linearization),\n/* harmony export */   _PdfLexicalOperator: () => (/* binding */ _PdfLexicalOperator),\n/* harmony export */   _PdfParser: () => (/* binding */ _PdfParser)\n/* harmony export */ });\n/* harmony import */ var _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pdf-primitives */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-primitives.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/utils.js\");\n/* harmony import */ var _base_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-stream */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/base-stream.js\");\n/* harmony import */ var _predictor_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./predictor-stream */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/predictor-stream.js\");\n/* harmony import */ var _flate_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flate-stream */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/flate-stream.js\");\n/* harmony import */ var _security_encryptor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./security/encryptor */ \"./node_modules/@syncfusion/ej2-pdf/src/pdf/core/security/encryptor.js\");\n\n\n\n\n\n\nvar maxCacheLength = 1000;\nvar maxNumberLength = 5552;\nvar endOfFile = 'EOF';\nvar specialChars = [\n    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n];\nvar _PdfLexicalOperator = /** @class */ (function () {\n    function _PdfLexicalOperator(stream) {\n        this.stream = stream;\n        this.nextChar();\n        this.stringBuffer = [];\n        this._hexStringNumber = 0;\n        this.beginInlineImagePosition = -1;\n    }\n    _PdfLexicalOperator.prototype.nextChar = function () {\n        return (this.currentChar = this.stream.getByte());\n    };\n    _PdfLexicalOperator.prototype.peekChar = function () {\n        return this.stream.peekByte();\n    };\n    _PdfLexicalOperator.prototype.getNumber = function () {\n        var ch = this.currentChar;\n        var eNotation = false;\n        var divideBy = 0;\n        var sign = 0;\n        if (ch === 0x2d) {\n            sign = -1;\n            ch = this.nextChar();\n            if (ch === 0x2d) {\n                ch = this.nextChar();\n            }\n        }\n        else if (ch === 0x2b) {\n            sign = 1;\n            ch = this.nextChar();\n        }\n        if (ch === 0x0a || ch === 0x0d) {\n            do {\n                ch = this.nextChar();\n            } while (ch === 0x0a || ch === 0x0d);\n        }\n        if (ch === 0x2e) {\n            divideBy = 10;\n            ch = this.nextChar();\n        }\n        if (ch < 0x30 || ch > 0x39) {\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__._isWhiteSpace)(ch) || ch === -1) {\n                if (divideBy === 10 && sign === 0) {\n                    return 0;\n                }\n                if (divideBy === 0 && sign === -1) {\n                    return 0;\n                }\n            }\n            throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError(\"Invalid number: \" + String.fromCharCode(ch) + \" (charCode \" + ch + \")\");\n        }\n        sign = sign || 1;\n        var baseValue = ch - 0x30;\n        var powerValue = 0;\n        var powerValueSign = 1;\n        ch = this.nextChar();\n        while (ch >= 0) {\n            if (ch >= 0x30 && ch <= 0x39) {\n                var currentDigit = ch - 0x30;\n                if (eNotation) {\n                    powerValue = powerValue * 10 + currentDigit;\n                }\n                else {\n                    if (divideBy !== 0) {\n                        divideBy *= 10;\n                    }\n                    baseValue = baseValue * 10 + currentDigit;\n                }\n            }\n            else if (ch === 0x2e) {\n                if (divideBy === 0) {\n                    divideBy = 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (ch === 0x2d) {\n                ch = this.nextChar();\n                continue;\n            }\n            else if (ch === 0x45 || ch === 0x65) {\n                ch = this.peekChar();\n                if (ch === 0x2b || ch === 0x2d) {\n                    powerValueSign = ch === 0x2d ? -1 : 1;\n                    this.nextChar();\n                }\n                else if (ch < 0x30 || ch > 0x39) {\n                    break;\n                }\n                eNotation = true;\n            }\n            else {\n                break;\n            }\n            ch = this.nextChar();\n        }\n        if (divideBy !== 0) {\n            baseValue /= divideBy;\n        }\n        if (eNotation) {\n            baseValue *= Math.pow(10, (powerValueSign * powerValue));\n        }\n        return sign * baseValue;\n    };\n    _PdfLexicalOperator.prototype.getString = function () {\n        var numParen = 1;\n        var done = false;\n        var stringBuffer = this.stringBuffer;\n        stringBuffer.length = 0;\n        var ch = this.nextChar();\n        while (true) { // eslint-disable-line\n            var charBuffered = false;\n            switch (ch | 0) {\n                case -1:\n                    done = true;\n                    break;\n                case 0x28:\n                    ++numParen;\n                    stringBuffer.push('(');\n                    break;\n                case 0x29:\n                    if (--numParen === 0) {\n                        this.nextChar();\n                        done = true;\n                    }\n                    else {\n                        stringBuffer.push(')');\n                    }\n                    break;\n                case 0x5c:\n                    ch = this.nextChar();\n                    switch (ch) {\n                        case -1:\n                            done = true;\n                            break;\n                        case 0x6e:\n                            stringBuffer.push('\\n');\n                            break;\n                        case 0x72:\n                            stringBuffer.push('\\r');\n                            break;\n                        case 0x74:\n                            stringBuffer.push('\\t');\n                            break;\n                        case 0x62:\n                            stringBuffer.push('\\b');\n                            break;\n                        case 0x66:\n                            stringBuffer.push('\\f');\n                            break;\n                        case 0x5c:\n                        case 0x28:\n                        case 0x29:\n                            stringBuffer.push(String.fromCharCode(ch));\n                            break;\n                        case 0x30:\n                        case 0x31:\n                        case 0x32:\n                        case 0x33:\n                        case 0x34:\n                        case 0x35:\n                        case 0x36:\n                        case 0x37:\n                            var x = ch & 0x0f; // eslint-disable-line\n                            ch = this.nextChar();\n                            charBuffered = true;\n                            if (ch >= 0x30 && ch <= 0x37) {\n                                x = (x << 3) + (ch & 0x0f);\n                                ch = this.nextChar();\n                                if (ch >= 0x30 && ch <= 0x37) {\n                                    charBuffered = false;\n                                    x = (x << 3) + (ch & 0x0f);\n                                }\n                            }\n                            stringBuffer.push(String.fromCharCode(x));\n                            break;\n                        case 0x0d:\n                            if (this.peekChar() === 0x0a) {\n                                this.nextChar();\n                            }\n                            break;\n                        case 0x0a:\n                            break;\n                        default:\n                            stringBuffer.push(String.fromCharCode(ch));\n                            break;\n                    }\n                    break;\n                default:\n                    stringBuffer.push(String.fromCharCode(ch));\n                    break;\n            }\n            if (done) {\n                break;\n            }\n            if (!charBuffered) {\n                ch = this.nextChar();\n            }\n        }\n        return stringBuffer.join('');\n    };\n    _PdfLexicalOperator.prototype.getName = function () {\n        var ch;\n        var previousCh;\n        var stringBuffer = this.stringBuffer;\n        stringBuffer.length = 0;\n        ch = this.nextChar();\n        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line\n            if (ch === 0x23) {\n                ch = this.nextChar();\n                if (specialChars[ch]) { // eslint-disable-line\n                    stringBuffer.push('#');\n                    break;\n                }\n                var x = this._toHexDigit(ch);\n                if (x !== -1) {\n                    previousCh = ch;\n                    ch = this.nextChar();\n                    var x2 = this._toHexDigit(ch);\n                    if (x2 === -1) {\n                        stringBuffer.push('#', String.fromCharCode(previousCh));\n                        if (specialChars[ch]) { // eslint-disable-line\n                            break;\n                        }\n                        stringBuffer.push(String.fromCharCode(ch));\n                        ch = this.nextChar();\n                        continue;\n                    }\n                    stringBuffer.push(String.fromCharCode((x << 4) | x2));\n                }\n                else {\n                    stringBuffer.push('#', String.fromCharCode(ch));\n                }\n            }\n            else {\n                stringBuffer.push(String.fromCharCode(ch));\n            }\n            ch = this.nextChar();\n        }\n        return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfName.get(stringBuffer.join(''));\n    };\n    _PdfLexicalOperator.prototype.getHexString = function () {\n        var stringBuffer = this.stringBuffer;\n        stringBuffer.length = 0;\n        var ch = this.currentChar;\n        var isFirstHex = true;\n        var firstDigit;\n        var secondDigit;\n        this._hexStringNumber = 0;\n        while (true) { // eslint-disable-line\n            if (ch < 0) {\n                break;\n            }\n            else if (ch === 0x3e) {\n                this.nextChar();\n                break;\n            }\n            else if (specialChars[ch] === 1) { // eslint-disable-line\n                ch = this.nextChar();\n                continue;\n            }\n            else {\n                if (isFirstHex) {\n                    firstDigit = this._toHexDigit(ch);\n                    if (firstDigit === -1) {\n                        ch = this.nextChar();\n                        continue;\n                    }\n                }\n                else {\n                    secondDigit = this._toHexDigit(ch);\n                    if (secondDigit === -1) {\n                        ch = this.nextChar();\n                        continue;\n                    }\n                    stringBuffer.push(String.fromCharCode((firstDigit << 4) | secondDigit));\n                }\n                isFirstHex = !isFirstHex;\n                ch = this.nextChar();\n            }\n        }\n        return stringBuffer.join('');\n    };\n    _PdfLexicalOperator.prototype.getObject = function () {\n        var comment = false;\n        var ch = this.currentChar;\n        while (true) { // eslint-disable-line\n            if (ch < 0) {\n                return endOfFile;\n            }\n            if (comment) {\n                if (ch === 0x0a || ch === 0x0d) {\n                    comment = false;\n                }\n            }\n            else if (ch === 0x25) {\n                comment = true;\n            }\n            else if (specialChars[ch] !== 1) { // eslint-disable-line\n                break;\n            }\n            ch = this.nextChar();\n        }\n        switch (ch | 0) {\n            case 0x30:\n            case 0x31:\n            case 0x32:\n            case 0x33:\n            case 0x34:\n            case 0x35:\n            case 0x36:\n            case 0x37:\n            case 0x38:\n            case 0x39:\n            case 0x2b:\n            case 0x2d:\n            case 0x2e:\n                return this.getNumber();\n            case 0x28:\n                return this.getString();\n            case 0x2f:\n                return this.getName();\n            case 0x5b:\n                this.nextChar();\n                return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('[');\n            case 0x5d:\n                this.nextChar();\n                return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get(']');\n            case 0x3c:\n                ch = this.nextChar();\n                if (ch === 0x3c) {\n                    this.nextChar();\n                    return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('<<');\n                }\n                return this.getHexString();\n            case 0x3e:\n                ch = this.nextChar();\n                if (ch === 0x3e) {\n                    this.nextChar();\n                    return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('>>');\n                }\n                return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('>');\n            case 0x7b:\n                this.nextChar();\n                return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('{');\n            case 0x7d:\n                this.nextChar();\n                return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('}');\n            case 0x29:\n                this.nextChar();\n                throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError(\"Illegal character: \" + ch);\n        }\n        var str = String.fromCharCode(ch);\n        if (ch < 0x20 || ch > 0x7f) {\n            var nextCh = this.peekChar();\n            if (nextCh >= 0x20 && nextCh <= 0x7f) {\n                this.nextChar();\n                return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get(str);\n            }\n        }\n        ch = this.nextChar();\n        while (ch >= 0 && !specialChars[ch]) { // eslint-disable-line\n            var possibleCommand = str + String.fromCharCode(ch);\n            if (str.length === 128) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError(\"Command token too long: \" + str.length);\n            }\n            str = possibleCommand;\n            ch = this.nextChar();\n        }\n        if (str === 'true') {\n            return true;\n        }\n        if (str === 'false') {\n            return false;\n        }\n        if (str === 'null') {\n            return null;\n        }\n        if (str === 'BI') {\n            this.beginInlineImagePosition = this.stream.position;\n        }\n        return _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get(str);\n    };\n    _PdfLexicalOperator.prototype.peekObj = function () {\n        var streamPos = this.stream.position;\n        var currentChar = this.currentChar;\n        var beginInlineImagePosition = this.beginInlineImagePosition;\n        var nextObj; // eslint-disable-line\n        try {\n            nextObj = this.getObject();\n        }\n        catch (ex) { } // eslint-disable-line\n        this.stream.position = streamPos;\n        this.currentChar = currentChar;\n        this.beginInlineImagePosition = beginInlineImagePosition;\n        return nextObj;\n    };\n    _PdfLexicalOperator.prototype.skipToNextLine = function () {\n        var ch = this.currentChar;\n        while (ch >= 0) {\n            if (ch === 0x0d) {\n                ch = this.nextChar();\n                if (ch === 0x0a) {\n                    this.nextChar();\n                }\n                break;\n            }\n            else if (ch === 0x0a) {\n                this.nextChar();\n                break;\n            }\n            ch = this.nextChar();\n        }\n    };\n    _PdfLexicalOperator.prototype._toHexDigit = function (ch) {\n        if (ch >= 0x30 && ch <= 0x39) {\n            return ch & 0x0f;\n        }\n        if ((ch >= 0x41 && ch <= 0x46) || (ch >= 0x61 && ch <= 0x66)) {\n            return (ch & 0x0f) + 9;\n        }\n        return -1;\n    };\n    return _PdfLexicalOperator;\n}());\n\nvar _PdfParser = /** @class */ (function () {\n    function _PdfParser(lexicalOperator, xref, allowStreams, recoveryMode, encryptor) {\n        if (allowStreams === void 0) { allowStreams = false; }\n        if (recoveryMode === void 0) { recoveryMode = false; }\n        this._isColorSpace = false;\n        this._isPassword = false;\n        this.lexicalOperator = lexicalOperator;\n        this.xref = xref;\n        this.allowStreams = allowStreams;\n        this.recoveryMode = recoveryMode;\n        this.imageCache = new Map();\n        this._encryptor = encryptor;\n        this.refill();\n    }\n    _PdfParser.prototype.refill = function () {\n        this.first = this.lexicalOperator.getObject();\n        this.second = this.lexicalOperator.getObject();\n    };\n    _PdfParser.prototype.shift = function () {\n        if (this.second instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand && this.second.command === 'ID') {\n            this.first = this.second;\n            this.second = null;\n        }\n        else {\n            this.first = this.second;\n            this.second = this.lexicalOperator.getObject();\n        }\n    };\n    _PdfParser.prototype.tryShift = function () {\n        try {\n            this.shift();\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    };\n    _PdfParser.prototype.getObject = function (arguement1, arguement2, arguement3) {\n        var cipherTransform;\n        var first = this.first; // eslint-disable-line\n        this.shift();\n        if (first instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand) {\n            switch (first.command) {\n                case 'BI':\n                    if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {\n                        return this.makeInlineImage(arguement1, arguement2, arguement3);\n                    }\n                    else if (arguement1 instanceof _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._CipherTransform) {\n                        return this.makeInlineImage(arguement1);\n                    }\n                    else {\n                        return this.makeInlineImage();\n                    }\n                case '[':\n                    var array = []; // eslint-disable-line\n                    while (!(0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isCommand)(this.first, ']') && this.first !== endOfFile) {\n                        var entry = void 0; // eslint-disable-line\n                        if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {\n                            cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);\n                            entry = this.getObject(arguement1, arguement2, arguement3);\n                        }\n                        else if (arguement1 instanceof _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._CipherTransform) {\n                            cipherTransform = arguement1;\n                            entry = this.getObject(arguement1);\n                        }\n                        else {\n                            entry = this.getObject(arguement1);\n                        }\n                        if (array.length === 0 && (0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isName)(entry, 'Indexed')) {\n                            this._isColorSpace = true;\n                        }\n                        entry = (0,_utils__WEBPACK_IMPORTED_MODULE_1__._decodeText)(entry, this._isColorSpace, this._isPassword);\n                        array.push(entry);\n                    }\n                    if (this.first === endOfFile) {\n                        if (this.recoveryMode) {\n                            return array;\n                        }\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_1__.ParserEndOfFileException('End of file inside array.');\n                    }\n                    this._isColorSpace = false;\n                    this.shift();\n                    return array;\n                case '<<':\n                    var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfDictionary(this.xref); // eslint-disable-line\n                    while (!(0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isCommand)(this.first, '>>') && this.first !== endOfFile) {\n                        if (!(this.first instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfName)) {\n                            this.shift();\n                            continue;\n                        }\n                        var key = this.first.name;\n                        if (key === 'U' || key === 'O' || key === 'ID') {\n                            this._isPassword = true;\n                        }\n                        this.shift();\n                        var isEnd = this._checkEnd();\n                        if (isEnd) {\n                            break;\n                        }\n                        if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {\n                            cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);\n                        }\n                        var value = void 0; // eslint-disable-line\n                        if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {\n                            value = this.getObject(arguement1, arguement2, arguement3);\n                        }\n                        else if (arguement1 instanceof _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._CipherTransform) {\n                            value = this.getObject(arguement1);\n                        }\n                        else {\n                            value = this.getObject();\n                        }\n                        value = (0,_utils__WEBPACK_IMPORTED_MODULE_1__._decodeText)(value, this._isColorSpace, this._isPassword);\n                        this._isPassword = false;\n                        dictionary.set(key, value);\n                    }\n                    if (this.first === endOfFile) {\n                        if (this.recoveryMode) {\n                            return dictionary;\n                        }\n                        throw new _utils__WEBPACK_IMPORTED_MODULE_1__.ParserEndOfFileException('End of file inside dictionary.');\n                    }\n                    if ((0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isCommand)(this.second, 'stream')) {\n                        if (this.allowStreams === true) {\n                            if (arguement1 instanceof _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._CipherTransform) {\n                                cipherTransform = arguement1;\n                            }\n                            else if (arguement3 && typeof arguement2 === 'number') {\n                                cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);\n                            }\n                            if (typeof arguement2 === 'boolean' && arguement2) {\n                                return this.makeStream(dictionary, cipherTransform, arguement2);\n                            }\n                            else {\n                                return this.makeStream(dictionary, cipherTransform);\n                            }\n                        }\n                        else {\n                            return dictionary;\n                        }\n                    }\n                    this.shift();\n                    return dictionary;\n                default:\n                    return first;\n            }\n        }\n        if (Number.isInteger(first)) {\n            if (Number.isInteger(this.first) && (0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isCommand)(this.second, 'R')) {\n                var ref = _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference.get(first, this.first);\n                this.shift();\n                this.shift();\n                return ref;\n            }\n            return first;\n        }\n        if (typeof first === 'string') {\n            if (arguement1 instanceof _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._CipherTransform) {\n                cipherTransform = arguement1;\n            }\n            else if (typeof arguement1 === 'number' && typeof arguement2 === 'number') {\n                cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);\n            }\n            if (cipherTransform) {\n                return cipherTransform.decryptString(first);\n            }\n            return first;\n        }\n        return first;\n    };\n    _PdfParser.prototype.findDiscreteDecodeInlineStreamEnd = function (stream) {\n        var startPos = stream.position;\n        var foundEnd = false;\n        var b;\n        var markerLength;\n        b = stream.getByte();\n        while (b !== -1) {\n            if (b !== 0xff) {\n                b = stream.getByte();\n                continue;\n            }\n            switch (stream.getByte()) {\n                case 0x00:\n                    break;\n                case 0xff:\n                    stream.skip(-1);\n                    break;\n                case 0xd9:\n                    foundEnd = true;\n                    break;\n                case 0xc0:\n                case 0xc1:\n                case 0xc2:\n                case 0xc3:\n                case 0xc5:\n                case 0xc6:\n                case 0xc7:\n                case 0xc9:\n                case 0xca:\n                case 0xcb:\n                case 0xcd:\n                case 0xce:\n                case 0xcf:\n                case 0xc4:\n                case 0xcc:\n                case 0xda:\n                case 0xdb:\n                case 0xdc:\n                case 0xdd:\n                case 0xde:\n                case 0xdf:\n                case 0xe0:\n                case 0xe1:\n                case 0xe2:\n                case 0xe3:\n                case 0xe4:\n                case 0xe5:\n                case 0xe6:\n                case 0xe7:\n                case 0xe8:\n                case 0xe9:\n                case 0xea:\n                case 0xeb:\n                case 0xec:\n                case 0xed:\n                case 0xee:\n                case 0xef:\n                case 0xfe:\n                    markerLength = stream.getUnsignedInteger16();\n                    if (markerLength > 2) {\n                        stream.skip(markerLength - 2);\n                    }\n                    else {\n                        stream.skip(-2);\n                    }\n                    break;\n            }\n            if (foundEnd) {\n                break;\n            }\n            b = stream.getByte();\n        }\n        var length = stream.position - startPos;\n        if (b === -1) {\n            stream.skip(-length);\n            return this.findDefaultInlineStreamEnd(stream);\n        }\n        this.inlineStreamSkipEI(stream);\n        return length;\n    };\n    _PdfParser.prototype.findDecodeInlineStreamEnd = function (stream) {\n        var startPos = stream.position;\n        var ch;\n        while ((ch = stream.getByte()) !== -1) { // eslint-disable-line\n            if (ch === 0x7e) {\n                var tildePos = stream.position;\n                ch = stream.peekByte();\n                while ((0,_utils__WEBPACK_IMPORTED_MODULE_1__._isWhiteSpace)(ch)) {\n                    stream.skip();\n                    ch = stream.peekByte();\n                }\n                if (ch === 0x3e) {\n                    stream.skip();\n                    break;\n                }\n                if (stream.position > tildePos) {\n                    var maybeEI = stream.peekBytes(2);\n                    if (maybeEI[0] === 0x45 && maybeEI[1] === 0x49) {\n                        break;\n                    }\n                }\n            }\n        }\n        var length = stream.position - startPos;\n        if (ch === -1) {\n            stream.skip(-length);\n            return this.findDefaultInlineStreamEnd(stream);\n        }\n        this.inlineStreamSkipEI(stream);\n        return length;\n    };\n    _PdfParser.prototype.findHexDecodeInlineStreamEnd = function (stream) {\n        var startPos = stream.position;\n        var ch;\n        ch = stream.getByte();\n        while (ch !== -1) {\n            if (ch === 0x3e) {\n                break;\n            }\n            ch = stream.getByte();\n        }\n        var length = stream.position - startPos;\n        if (ch === -1) {\n            stream.skip(-length);\n            return this.findDefaultInlineStreamEnd(stream);\n        }\n        this.inlineStreamSkipEI(stream);\n        return length;\n    };\n    _PdfParser.prototype.inlineStreamSkipEI = function (stream) {\n        var state = 0;\n        var ch;\n        ch = stream.getByte();\n        while (ch !== -1) {\n            if (state === 0) {\n                state = ch === 0x45 ? 1 : 0;\n            }\n            else if (state === 1) {\n                state = ch === 0x49 ? 2 : 0;\n            }\n            else if (state === 2) {\n                break;\n            }\n            ch = stream.getByte();\n        }\n    };\n    _PdfParser.prototype.makeInlineImage = function (arguement1, arguement2, arguement3) {\n        var lexicalOperator = this.lexicalOperator;\n        var stream = lexicalOperator.stream;\n        var dictionary = new _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfDictionary(this.xref);\n        var dictLength;\n        var cipherTransform;\n        if (arguement3) {\n            if (arguement1 instanceof _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._CipherTransform) {\n                cipherTransform = arguement1;\n            }\n            else {\n                cipherTransform = this._encryptor._createCipherTransform(arguement1, arguement2);\n            }\n        }\n        while (!(0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isCommand)(this.first, 'ID') && this.first !== endOfFile) {\n            if (!(this.first instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfName)) {\n                throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError('Dictionary key must be a name object');\n            }\n            var key = this.first.name;\n            this.shift();\n            if (this.first.name === endOfFile) {\n                break;\n            }\n            if (arguement1 instanceof _security_encryptor__WEBPACK_IMPORTED_MODULE_5__._CipherTransform) {\n                dictionary.set(key, this.getObject(arguement1));\n            }\n            else {\n                dictionary.set(key, this.getObject(arguement1, arguement2, arguement3));\n            }\n        }\n        if (lexicalOperator.beginInlineImagePosition !== -1) {\n            dictLength = stream.position - lexicalOperator.beginInlineImagePosition;\n        }\n        var filter = dictionary.get('F', 'Filter'); // eslint-disable-line\n        var filterName;\n        if (filter instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfName) {\n            filterName = filter.name;\n        }\n        else if (Array.isArray(filter)) {\n            var reference = filter[0]; // eslint-disable-line\n            var filterZero = (reference !== null && typeof reference !== 'undefined' && reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference) ?\n                this.xref._fetch(reference) :\n                reference;\n            if (filterZero) {\n                filterName = filterZero.name;\n            }\n        }\n        var startPos = stream.position;\n        var length;\n        switch (filterName) {\n            case 'DCT':\n            case 'DCTDecode':\n                length = this.findDiscreteDecodeInlineStreamEnd(stream);\n                break;\n            case 'A85':\n            case 'ASCII85Decode':\n                length = this.findDecodeInlineStreamEnd(stream);\n                break;\n            case 'AHx':\n            case 'ASCIIHexDecode':\n                length = this.findHexDecodeInlineStreamEnd(stream);\n                break;\n            default:\n                length = this.findDefaultInlineStreamEnd(stream);\n        }\n        var imageStream = stream.makeSubStream(startPos, length, dictionary); // eslint-disable-line\n        var cacheKey;\n        if (length < maxCacheLength && dictLength < maxNumberLength) {\n            var imageBytes = imageStream.getBytes();\n            imageStream.reset();\n            var initialStreamPos = stream.position;\n            stream.position = lexicalOperator.beginInlineImagePosition;\n            var dictBytes = stream.getBytes(dictLength);\n            stream.position = initialStreamPos;\n            cacheKey = this._computeMaxNumber(imageBytes) + '_' + this._computeMaxNumber(dictBytes);\n            var cacheEntry = this.imageCache.get(cacheKey);\n            if (cacheEntry !== undefined) {\n                this.second = _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('EI');\n                this.shift();\n                cacheEntry.reset();\n                return cacheEntry;\n            }\n        }\n        if (cipherTransform) {\n            imageStream = cipherTransform.createStream(imageStream, length);\n        }\n        imageStream = this.filter(imageStream, dictionary, length);\n        imageStream.dictionary = dictionary;\n        if (cacheKey !== undefined) {\n            this.imageCache.set(cacheKey, imageStream);\n        }\n        this.second = _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfCommand.get('EI');\n        this.shift();\n        return imageStream;\n    };\n    _PdfParser.prototype._computeMaxNumber = function (bytes) {\n        var bytesLength = bytes.length;\n        var a = 1;\n        var b = 0;\n        for (var i = 0; i < bytesLength; ++i) {\n            a += bytes[i] & 0xff; // eslint-disable-line\n            b += a;\n        }\n        return (b % 65521 << 16) | a % 65521;\n    };\n    _PdfParser.prototype.makeStream = function (dictionary, cipherTransform, makeFilter) {\n        if (makeFilter === void 0) { makeFilter = false; }\n        var lexicalOperator = this.lexicalOperator;\n        var stream = lexicalOperator.stream; // eslint-disable-line\n        lexicalOperator.skipToNextLine();\n        var startPosition = stream.position - 1;\n        var length = dictionary.get('Length');\n        if (!Number.isInteger(length)) {\n            length = 0;\n        }\n        stream.position = startPosition + length;\n        lexicalOperator.nextChar();\n        if (this.tryShift() && (0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isCommand)(this.second, 'endstream')) {\n            this.shift();\n        }\n        else {\n            var endStreamSignature = new Uint8Array([0x65, 0x6e, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d]);\n            var actualLength = this._findStreamLength(startPosition, endStreamSignature);\n            if (actualLength < 0) {\n                var end = endStreamSignature.length - 1;\n                var truncatedSignature = endStreamSignature.slice(0, end);\n                var maybeLength = this._findStreamLength(startPosition, truncatedSignature);\n                if (maybeLength >= 0) {\n                    var lastByte = stream.peekBytes(end + 1)[end]; // eslint-disable-line\n                    if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__._isWhiteSpace)(lastByte)) {\n                        actualLength = maybeLength;\n                    }\n                }\n                if (actualLength < 0) {\n                    throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError('Missing endstream command.');\n                }\n            }\n            length = actualLength;\n            lexicalOperator.nextChar();\n            this.shift();\n            this.shift();\n        }\n        this.shift();\n        stream = stream.makeSubStream(startPosition, length, dictionary);\n        if (!makeFilter) {\n            if (cipherTransform) {\n                stream = cipherTransform.createStream(stream, length);\n            }\n            stream = this.filter(stream, dictionary, length);\n        }\n        stream.dictionary = dictionary;\n        return stream;\n    };\n    _PdfParser.prototype.filter = function (stream, dictionary, length) {\n        var filter = dictionary.get('F', 'Filter'); // eslint-disable-line\n        var params = dictionary.get('DP', 'DecodeParms'); // eslint-disable-line\n        if (filter instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfName) {\n            return this.makeFilter(stream, filter.name, length, params);\n        }\n        var maybeLength = length;\n        if (Array.isArray(filter)) {\n            var filterArray = filter; // eslint-disable-line\n            var paramsArray = params; // eslint-disable-line\n            for (var i = 0; i < filterArray.length; ++i) {\n                var reference = filterArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n                filter = reference instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference ? this.xref._fetch(reference) : reference;\n                if (!(filter instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfName)) {\n                    throw new _utils__WEBPACK_IMPORTED_MODULE_1__.FormatError(\"Bad filter name '\" + filter + \"'\");\n                }\n                params = null;\n                if (Array.isArray(paramsArray) && i in paramsArray) {\n                    var ref = paramsArray[Number.parseInt(i.toString(), 10)]; // eslint-disable-line\n                    params = ref instanceof _pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._PdfReference ? this.xref._fetch(ref) : ref;\n                }\n                stream = this.makeFilter(stream, filter.name, maybeLength, params);\n                maybeLength = null;\n            }\n        }\n        return stream;\n    };\n    _PdfParser.prototype.makeFilter = function (stream, name, maybeLength, params) {\n        if (maybeLength === 0) {\n            return new _base_stream__WEBPACK_IMPORTED_MODULE_2__._PdfNullStream();\n        }\n        try {\n            if (name === 'Fl' || name === 'FlateDecode') {\n                if (params) {\n                    return new _predictor_stream__WEBPACK_IMPORTED_MODULE_3__.PdfPredictorStream(new _flate_stream__WEBPACK_IMPORTED_MODULE_4__._PdfFlateStream(stream, maybeLength), maybeLength, params);\n                }\n                return new _flate_stream__WEBPACK_IMPORTED_MODULE_4__._PdfFlateStream(stream, maybeLength);\n            }\n            return stream;\n        }\n        catch (ex) {\n            return new _base_stream__WEBPACK_IMPORTED_MODULE_2__._PdfNullStream();\n        }\n    };\n    _PdfParser.prototype._findStreamLength = function (startPosition, signature) {\n        var stream = this.lexicalOperator.stream;\n        stream.position = startPosition;\n        var length = 2048;\n        var signatureLength = signature.length;\n        while (stream.position < stream.end) {\n            var scanBytes = stream.peekBytes(length);\n            var scanLength = scanBytes.length - signatureLength;\n            if (scanLength <= 0) {\n                break;\n            }\n            var position = 0;\n            while (position < scanLength) {\n                var j = 0;\n                while (j < signatureLength && scanBytes[position + j] === signature[j]) { // eslint-disable-line\n                    j++;\n                }\n                if (j >= signatureLength) {\n                    stream.position += position;\n                    return stream.position - startPosition;\n                }\n                position++;\n            }\n            stream.position += scanLength;\n        }\n        return -1;\n    };\n    _PdfParser.prototype.findDefaultInlineStreamEnd = function (stream) {\n        var startPosition = stream.position;\n        var n = 10;\n        var state = 0;\n        var ch;\n        var endImagePosition;\n        ch = stream.getByte();\n        while (ch !== -1) {\n            if (state === 0) {\n                state = ch === 0x45 ? 1 : 0;\n            }\n            else if (state === 1) {\n                state = ch === 0x49 ? 2 : 0;\n            }\n            else {\n                if (state !== 2) {\n                    throw new Error('findDefaultInlineStreamEnd - invalid state.');\n                }\n                if (ch === 0x20 || ch === 0xa || ch === 0xd) {\n                    endImagePosition = stream.position;\n                    var followingBytes = stream.peekBytes(n);\n                    for (var i = 0, ii = followingBytes.length; i < ii; i++) {\n                        ch = followingBytes[i]; // eslint-disable-line\n                        if (ch === 0x0 && followingBytes[i + 1] !== 0x0) {\n                            continue;\n                        }\n                        if (ch !== 0xa && ch !== 0xd && (ch < 0x20 || ch > 0x7f)) {\n                            state = 0;\n                            break;\n                        }\n                    }\n                    if (state !== 2) {\n                        ch = stream.getByte();\n                        continue;\n                    }\n                    if (state === 2) {\n                        break;\n                    }\n                }\n                else {\n                    state = 0;\n                }\n            }\n            ch = stream.getByte();\n        }\n        if (ch === -1) {\n            if (typeof endImagePosition !== 'undefined') {\n                stream.skip(-(stream.position - endImagePosition));\n            }\n        }\n        var endOffset = 4;\n        stream.skip(-endOffset);\n        ch = stream.peekByte();\n        stream.skip(endOffset);\n        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_1__._isWhiteSpace)(ch)) {\n            endOffset--;\n        }\n        return stream.position - endOffset - startPosition;\n    };\n    _PdfParser.prototype._checkEnd = function () {\n        if (this.first === endOfFile) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    return _PdfParser;\n}());\n\n/* eslint-disable */\nvar _Linearization = /** @class */ (function () {\n    function _Linearization(stream) {\n        this.isValid = false;\n        var parser = new _PdfParser(new _PdfLexicalOperator(stream), null);\n        var obj1 = parser.getObject();\n        var obj2 = parser.getObject();\n        var obj3 = parser.getObject();\n        var dictionary = parser.getObject();\n        this.isValid = Number.isInteger(obj1) && Number.isInteger(obj2) && (0,_pdf_primitives__WEBPACK_IMPORTED_MODULE_0__._isCommand)(obj3, 'obj') && typeof dictionary !== 'undefined';\n        if (this.isValid) {\n            var obj = dictionary.get('Linearized');\n            this.isValid = typeof obj !== 'undefined' && obj > 0;\n        }\n        if (this.isValid) {\n            var length_1 = this.getInt(dictionary, 'L');\n            if (length_1 !== stream.length) {\n                throw new Error('The L parameter in the linearization dictionary ' + 'does not equal the stream length.');\n            }\n            this.length = length_1;\n            this.hints = this.getHints(dictionary);\n            this.objectNumberFirst = this.getInt(dictionary, 'O');\n            this.endFirst = this.getInt(dictionary, 'E');\n            this.pageCount = this.getInt(dictionary, 'N');\n            this.mainXRefEntriesOffset = this.getInt(dictionary, 'T');\n            this.pageFirst = dictionary.has('P') ? this.getInt(dictionary, 'P', true) : 0;\n        }\n    }\n    _Linearization.prototype.getInt = function (dictionary, name, allowZeroValue) {\n        if (allowZeroValue === void 0) { allowZeroValue = false; }\n        var obj = dictionary.get(name);\n        if (typeof obj !== 'undefined' && Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {\n            return obj;\n        }\n        throw new Error(\"The '\" + name + \"' parameter in the linearization \" + 'dictionary is invalid.');\n    };\n    _Linearization.prototype.getHints = function (dictionary) {\n        var hints = dictionary.getArray('H');\n        var hintsLength = hints.length;\n        if (hints && (hintsLength === 2 || hintsLength === 4)) {\n            for (var index = 0; index < hintsLength; index++) {\n                var hint = hints[index];\n                if (!(Number.isInteger(hint) && hint > 0)) {\n                    throw new Error(\"Hint (\" + index + \") in the linearization dictionary is invalid.\");\n                }\n            }\n            return hints;\n        }\n        throw new Error('Hint array in the linearization dictionary is invalid.');\n    };\n    return _Linearization;\n}());\n\n/* eslint-enable */\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdf/src/pdf/core/pdf-parser.js?");

/***/ })

}]);