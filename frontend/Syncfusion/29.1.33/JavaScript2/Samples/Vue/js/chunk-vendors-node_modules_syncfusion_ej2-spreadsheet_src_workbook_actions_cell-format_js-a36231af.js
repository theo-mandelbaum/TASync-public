"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-spreadsheet_src_workbook_actions_cell-format_js-a36231af"],{

/***/ "./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/actions/cell-format.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/actions/cell-format.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WorkbookCellFormat: () => (/* binding */ WorkbookCellFormat)\n/* harmony export */ });\n/* harmony import */ var _common_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/index */ \"./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/common/index.js\");\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ \"./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/index.js\");\n\n\n\n\n\n\n\n/**\n * Workbook Cell format.\n */\nvar WorkbookCellFormat = /** @class */ (function () {\n    function WorkbookCellFormat(parent) {\n        this.parent = parent;\n        this.addEventListener();\n    }\n    WorkbookCellFormat.prototype.format = function (args) {\n        var _this = this;\n        var sheet;\n        var rng = args.range;\n        if (rng && typeof rng === 'string' && rng.indexOf('!') > -1) {\n            var lastIndex = rng.lastIndexOf('!');\n            rng = rng.substring(lastIndex + 1);\n            sheet = this.parent.sheets[(0,_index__WEBPACK_IMPORTED_MODULE_1__.getSheetIndex)(this.parent, args.range.substring(0, lastIndex))];\n        }\n        else {\n            sheet = this.parent.getActiveSheet();\n        }\n        if (rng === undefined) {\n            rng = sheet.selectedRange;\n        }\n        var triggerEvt = typeof (rng) !== 'object' && args.onActionUpdate && !args.isUndoRedo;\n        var eventArgs = {\n            range: rng, style: Object.assign({}, args.style), requestType: 'CellFormat'\n        };\n        if (args.borderType) {\n            eventArgs.borderType = args.borderType;\n        }\n        var style = {};\n        var indexes = typeof (eventArgs.range) === 'object' ? eventArgs.range :\n            (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.getSwapRange)((0,_common_index__WEBPACK_IMPORTED_MODULE_0__.getRangeIndexes)(eventArgs.range));\n        var mergeBorderRows = [];\n        var hasReadOnlyCells = (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.isReadOnlyCells)(this.parent, indexes);\n        if (hasReadOnlyCells) {\n            if (args.onActionUpdate) {\n                this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.workbookReadonlyAlert, null);\n            }\n            return;\n        }\n        Object.assign(style, eventArgs.style, null, true);\n        if (triggerEvt) {\n            this.parent.trigger('beforeCellFormat', eventArgs);\n            this.parent.notify('actionBegin', { eventArgs: eventArgs, action: 'format' });\n            if (eventArgs.cancel) {\n                args.cancel = true;\n                return;\n            }\n        }\n        if (args.borderType) {\n            this.setTypedBorder(sheet, args.style.border, indexes, args.borderType, args.onActionUpdate, mergeBorderRows);\n            delete args.style.border;\n            delete eventArgs.style.border;\n        }\n        var i;\n        var j;\n        var props = { cell: null, rowIdx: 0, colIdx: 0, eventOnly: true, preventEvt: !triggerEvt };\n        var triggerBeforeEvent = function (cellStyle) {\n            props.cell = { style: cellStyle };\n            props.rowIdx = i;\n            props.colIdx = j;\n            return (0,_index__WEBPACK_IMPORTED_MODULE_1__.updateCell)(_this.parent, sheet, props);\n        };\n        if (eventArgs.style.borderTop !== undefined) {\n            for (j = indexes[1]; j <= indexes[3]; j++) {\n                i = indexes[0];\n                if (!triggerBeforeEvent({ borderTop: eventArgs.style.borderTop })) {\n                    if (!args.isUndoRedo) {\n                        this.checkAdjacentBorder(sheet, 'borderBottom', i - 1, j);\n                        this.checkFullBorder(sheet, 'borderBottom', i - 1, j);\n                    }\n                    this.checkFullBorder(sheet, 'borderTop', i, j);\n                    this.setCellBorder(sheet, props.cell.style, i, j, args.onActionUpdate, j === indexes[3], null, null, args.isUndoRedo, mergeBorderRows);\n                }\n            }\n            delete eventArgs.style.borderTop;\n        }\n        if (eventArgs.style.borderBottom !== undefined) {\n            var firstCell = void 0;\n            var lastCell = void 0;\n            for (j = indexes[1]; j <= indexes[3]; j++) {\n                i = indexes[0];\n                firstCell = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCell)(i, j, sheet, false, true);\n                if (firstCell.rowSpan > 0) {\n                    lastCell = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCell)(indexes[2], indexes[1], sheet, false, true);\n                }\n                else {\n                    lastCell = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCell)(indexes[2], indexes[3], sheet, false, true);\n                }\n                if (!(firstCell.rowSpan > 1 && lastCell.rowSpan < 0)) {\n                    i = indexes[2];\n                }\n                var mergeArgs = { range: [i, j, i, j] };\n                this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.activeCellMergedRange, mergeArgs);\n                i = mergeArgs.range[0];\n                if (!triggerBeforeEvent({ borderBottom: eventArgs.style.borderBottom })) {\n                    if (!args.isUndoRedo) {\n                        this.checkAdjacentBorder(sheet, 'borderTop', indexes[2] + 1, j);\n                        this.checkFullBorder(sheet, 'borderTop', indexes[2] + 1, j);\n                    }\n                    this.checkFullBorder(sheet, 'borderBottom', indexes[2], j);\n                    this.setCellBorder(sheet, props.cell.style, i, j, args.onActionUpdate, j === indexes[3], null, null, args.isUndoRedo);\n                    this.setBottomBorderPriority(sheet, indexes[2], j);\n                }\n            }\n            delete eventArgs.style.borderBottom;\n        }\n        if (eventArgs.style.borderLeft !== undefined) {\n            for (var i_1 = indexes[0]; i_1 <= indexes[2]; i_1++) {\n                j = indexes[1];\n                if (!triggerBeforeEvent({ borderLeft: eventArgs.style.borderLeft })) {\n                    if (!args.isUndoRedo) {\n                        this.checkAdjacentBorder(sheet, 'borderRight', i_1, j - 1);\n                        this.checkFullBorder(sheet, 'borderRight', i_1, j - 1);\n                    }\n                    this.checkFullBorder(sheet, 'borderLeft', i_1, j);\n                    this.setCellBorder(sheet, props.cell.style, i_1, j, args.onActionUpdate, null, null, null, args.isUndoRedo);\n                }\n            }\n            delete eventArgs.style.borderLeft;\n        }\n        if (eventArgs.style.borderRight !== undefined) {\n            for (var i_2 = indexes[0]; i_2 <= indexes[2]; i_2++) {\n                j = indexes[3];\n                var mergeArgs = { range: [i_2, j, i_2, j] };\n                this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.activeCellMergedRange, mergeArgs);\n                j = mergeArgs.range[1];\n                if (!triggerBeforeEvent({ borderRight: eventArgs.style.borderRight })) {\n                    if (!args.isUndoRedo) {\n                        this.checkAdjacentBorder(sheet, 'borderLeft', i_2, j + 1);\n                        this.checkFullBorder(sheet, 'borderLeft', i_2, j + 1);\n                    }\n                    this.checkFullBorder(sheet, 'borderRight', i_2, j);\n                    this.setCellBorder(sheet, props.cell.style, i_2, j, args.onActionUpdate, null, null, null, args.isUndoRedo);\n                }\n            }\n            delete eventArgs.style.borderRight;\n        }\n        var border;\n        var isFullBorder;\n        var styleKeys = Object.keys(eventArgs.style);\n        if (styleKeys.length) {\n            var cell = void 0;\n            var validation = void 0;\n            var col = void 0;\n            var parent_1 = this.parent;\n            var activeSheet = parent_1.viewport && this.parent.getActiveSheet().id === sheet.id;\n            var frozenRow = this.parent.frozenRowCount(sheet);\n            var frozenCol = this.parent.frozenColCount(sheet);\n            var viewport = [frozenRow + parent_1.viewport.topIndex, frozenCol + parent_1.viewport.leftIndex,\n                parent_1.viewport.bottomIndex, parent_1.viewport.rightIndex];\n            var uiRefresh = void 0;\n            var row = void 0;\n            var checkHeight = void 0;\n            var formatColor = void 0;\n            var isFontColorApplied = styleKeys.indexOf('color') > -1;\n            var isColorApplied = isFontColorApplied || styleKeys.indexOf('backgroundColor') > -1;\n            for (i = indexes[0]; i <= indexes[2]; i++) {\n                row = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRow)(sheet, i) || {};\n                if (row.isFiltered) {\n                    continue;\n                }\n                uiRefresh = (i >= viewport[0] && i <= viewport[2]) || i < frozenRow;\n                checkHeight = false;\n                for (j = indexes[1]; j <= indexes[3]; j++) {\n                    if (triggerBeforeEvent(eventArgs.style)) {\n                        continue;\n                    }\n                    if (isFullBorder === undefined) {\n                        if (eventArgs.style.border !== undefined) {\n                            border = eventArgs.style.border;\n                            delete eventArgs.style.border;\n                            isFullBorder = true;\n                        }\n                        else {\n                            isFullBorder = false;\n                        }\n                    }\n                    cell = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCell)(i, j, sheet, false, true);\n                    col = sheet.columns[j];\n                    if (cell.rowSpan > 1 || cell.colSpan > 1) {\n                        for (var k = i, rowSpanLen = cell.rowSpan > 1 ? i + (cell.rowSpan - 1) : i; k <= rowSpanLen; k++) {\n                            for (var l = j, colSpanLen = cell.colSpan > 1 ? j + (cell.colSpan - 1) : j; l <= colSpanLen; l++) {\n                                if (isFullBorder) {\n                                    this.setFullBorder(sheet, border, indexes, k, l, args.onActionUpdate, true);\n                                }\n                                this.setCellStyle(sheet, k, l, eventArgs.style);\n                            }\n                        }\n                    }\n                    if (isFullBorder) {\n                        this.setFullBorder(sheet, border, indexes, i, j, args.onActionUpdate, undefined, mergeBorderRows);\n                    }\n                    this.setCellStyle(sheet, i, j, eventArgs.style);\n                    if (!activeSheet) {\n                        continue;\n                    }\n                    if (uiRefresh && ((j >= viewport[1] && j <= viewport[3]) || j < frozenCol)) {\n                        formatColor = null;\n                        if (isFontColorApplied && cell.format && cell.format.includes('[')) {\n                            var colorCode = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getColorCode)(cell.format);\n                            if (colorCode) {\n                                formatColor = colorCode.toLowerCase();\n                            }\n                        }\n                        this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.applyCellFormat, { style: eventArgs.style, rowIdx: i, colIdx: j,\n                            lastCell: j === indexes[3], isHeightCheckNeeded: true, manualUpdate: true, onActionUpdate: args.onActionUpdate,\n                            formatColor: formatColor });\n                        if (isColorApplied) {\n                            validation = cell.validation || ((0,_index__WEBPACK_IMPORTED_MODULE_1__.checkColumnValidation)(col, i, j) && col.validation);\n                            if (validation && validation.isHighlighted) {\n                                this.parent.notify(_index__WEBPACK_IMPORTED_MODULE_1__.updateHighlight, {\n                                    rowIdx: i, colIdx: j, cell: cell, validation: validation, col: cell.validation && col\n                                });\n                            }\n                        }\n                    }\n                    else if (!row.customHeight) {\n                        checkHeight = checkHeight || (0,_index__WEBPACK_IMPORTED_MODULE_1__.isHeightCheckNeeded)(eventArgs.style, args.onActionUpdate);\n                        if (checkHeight) {\n                            this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.applyCellFormat, { rowIdx: i, colIdx: j, lastCell: j === indexes[3], checkHeight: true,\n                                outsideViewport: !uiRefresh, onActionUpdate: args.onActionUpdate });\n                        }\n                    }\n                }\n            }\n        }\n        if (isFullBorder) {\n            eventArgs.style.border = border;\n        }\n        (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.updateMergeBorder)(this.parent, mergeBorderRows, [indexes[1], indexes[3]]);\n        this.parent.setUsedRange(indexes[2], indexes[3]);\n        if (args.refreshRibbon) {\n            this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.activeCellChanged, null);\n        }\n        if (sheet.conditionalFormats && sheet.conditionalFormats.length) {\n            this.parent.notify(_index__WEBPACK_IMPORTED_MODULE_1__.applyCF, { indexes: indexes });\n        }\n        if (triggerEvt) {\n            eventArgs.style = style;\n            eventArgs.range = sheet.name + \"!\" + rng;\n            this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'format' });\n        }\n    };\n    WorkbookCellFormat.prototype.setBottomBorderPriority = function (sheet, rowIdx, colIdx) {\n        if ((0,_index__WEBPACK_IMPORTED_MODULE_1__.isHiddenRow)(sheet, rowIdx + 1)) {\n            var pIdx = this.skipHiddenRows(sheet, rowIdx + 1);\n            var pCellStyle = this.parent.getCellStyleValue(['borderTop'], [pIdx, colIdx]).borderTop;\n            if (pCellStyle !== '') {\n                sheet.rows[rowIdx].cells[colIdx].style.bottomPriority = true;\n            }\n        }\n    };\n    WorkbookCellFormat.prototype.setFullBorder = function (sheet, border, indexes, i, j, actionUpdate, modelUpdate, mergeBorderRows) {\n        var style = {};\n        if (i === indexes[0]) {\n            this.checkAdjacentBorder(sheet, 'borderBottom', i - 1, j);\n            this.checkFullBorder(sheet, 'borderBottom', i - 1, j);\n        }\n        if (j === indexes[1]) {\n            this.checkAdjacentBorder(sheet, 'borderRight', i, j - 1);\n            this.checkFullBorder(sheet, 'borderRight', i, j - 1);\n        }\n        if (j === indexes[3]) {\n            this.checkAdjacentBorder(sheet, 'borderLeft', i, j + 1);\n            this.checkFullBorder(sheet, 'borderLeft', i, j + 1);\n        }\n        else {\n            this.checkAdjacentBorder(sheet, 'border', i, j + 1);\n        }\n        style.borderRight = border;\n        style.borderTop = border;\n        style.borderLeft = border;\n        style.borderBottom = border;\n        this.setCellBorder(sheet, style, i, j, actionUpdate, j === indexes[3], null, modelUpdate, undefined, mergeBorderRows);\n        if (i === indexes[2]) {\n            this.checkAdjacentBorder(sheet, 'borderTop', i + 1, j);\n            this.checkFullBorder(sheet, 'borderTop', i + 1, j);\n            this.setBottomBorderPriority(sheet, i, j);\n        }\n        else {\n            this.checkAdjacentBorder(sheet, 'border', i + 1, j);\n        }\n    };\n    WorkbookCellFormat.prototype.checkAdjacentBorder = function (sheet, prop, rowIdx, colIdx) {\n        var style = {};\n        if (this.parent.getCellStyleValue([prop], [rowIdx, colIdx])[\"\" + prop] !== '') {\n            style[\"\" + prop] = undefined;\n            this.setCellStyle(sheet, rowIdx, colIdx, style);\n        }\n    };\n    WorkbookCellFormat.prototype.checkFullBorder = function (sheet, prop, rowIdx, colIdx) {\n        var border = this.parent.getCellStyleValue(['border'], [rowIdx, colIdx]).border;\n        if (border !== '') {\n            var style_1 = { border: undefined };\n            ['borderBottom', 'borderTop', 'borderLeft', 'borderRight'].forEach(function (value) {\n                if (value !== prop) {\n                    style_1[\"\" + value] = border;\n                }\n            });\n            this.setCellStyle(sheet, rowIdx, colIdx, style_1);\n        }\n    };\n    WorkbookCellFormat.prototype.textDecorationActionUpdate = function (args) {\n        var sheet = this.parent.getActiveSheet();\n        var eventArgs = { range: sheet.selectedRange, style: args.style, requestType: 'CellFormat' };\n        var indexes = (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.getSwapRange)((0,_common_index__WEBPACK_IMPORTED_MODULE_0__.getRangeIndexes)(sheet.selectedRange));\n        var hasReadOnlyCells = (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.isReadOnlyCells)(this.parent, indexes);\n        if (hasReadOnlyCells) {\n            this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.workbookReadonlyAlert, null);\n            return;\n        }\n        this.parent.trigger('beforeCellFormat', eventArgs);\n        this.parent.notify('actionBegin', { eventArgs: eventArgs, action: 'format' });\n        if (eventArgs.cancel) {\n            args.cancel = true;\n            return;\n        }\n        var value = args.style.textDecoration.toLowerCase();\n        var changedValue = value;\n        var activeCellIndexes = (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.getRangeIndexes)(sheet.activeCell);\n        var cellValue = this.parent.getCellStyleValue(['textDecoration'], activeCellIndexes).textDecoration.toLowerCase();\n        var removeProp = false;\n        if (cellValue === 'underline') {\n            changedValue = value === 'underline' ? 'none' : 'underline line-through';\n        }\n        else if (cellValue === 'line-through') {\n            changedValue = value === 'line-through' ? 'none' : 'underline line-through';\n        }\n        else if (cellValue === 'underline line-through') {\n            changedValue = value === 'underline' ? 'line-through' : 'underline';\n            removeProp = true;\n        }\n        if (changedValue === 'none') {\n            removeProp = true;\n        }\n        var changedStyle = { textDecoration: changedValue };\n        this.format({ style: changedStyle, range: activeCellIndexes, refreshRibbon: args.refreshRibbon, onActionUpdate: true });\n        for (var i = indexes[0]; i <= indexes[2]; i++) {\n            for (var j = indexes[1]; j <= indexes[3]; j++) {\n                if (i === activeCellIndexes[0] && j === activeCellIndexes[1]) {\n                    continue;\n                }\n                changedStyle = {};\n                cellValue = this.parent.getCellStyleValue(['textDecoration'], [i, j]).textDecoration.toLowerCase();\n                if (cellValue === 'none') {\n                    if (removeProp) {\n                        continue;\n                    }\n                    changedStyle.textDecoration = value;\n                }\n                else if (cellValue === 'underline' || cellValue === 'line-through') {\n                    if (removeProp) {\n                        if (value === cellValue) {\n                            changedStyle.textDecoration = 'none';\n                        }\n                        else {\n                            continue;\n                        }\n                    }\n                    else {\n                        changedStyle.textDecoration = value !== cellValue ? 'underline line-through' : value;\n                    }\n                }\n                else if (cellValue === 'underline line-through') {\n                    if (removeProp) {\n                        changedStyle.textDecoration = value === 'underline' ? 'line-through' : 'underline';\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                this.format({ style: changedStyle, range: [i, j, i, j], refreshRibbon: args.refreshRibbon, onActionUpdate: true });\n            }\n        }\n        eventArgs.range = sheet.name + '!' + eventArgs.range;\n        eventArgs.style.textDecoration = changedValue;\n        this.parent.notify('actionComplete', { eventArgs: eventArgs, action: 'format' });\n    };\n    WorkbookCellFormat.prototype.setTypedBorder = function (sheet, border, range, type, actionUpdate, mergeBorderRows) {\n        var prevBorder;\n        if (type === 'Outer') {\n            for (var colIdx = range[1]; colIdx <= range[3]; colIdx++) {\n                this.checkAdjacentBorder(sheet, 'borderBottom', range[0] - 1, colIdx);\n                this.checkFullBorder(sheet, 'borderBottom', range[0] - 1, colIdx);\n                this.setCellBorder(sheet, { borderTop: border }, range[0], colIdx, actionUpdate, colIdx === range[3], undefined, undefined, undefined, mergeBorderRows);\n                this.checkAdjacentBorder(sheet, 'borderTop', range[2] + 1, colIdx);\n                this.checkFullBorder(sheet, 'borderTop', range[2] + 1, colIdx);\n                this.setCellBorder(sheet, { borderBottom: border }, range[2], colIdx, actionUpdate, colIdx === range[3], type);\n                this.setBottomBorderPriority(sheet, range[2], colIdx);\n            }\n            for (var rowIdx = range[0]; rowIdx <= range[2]; rowIdx++) {\n                this.checkAdjacentBorder(sheet, 'borderRight', rowIdx, range[1] - 1);\n                this.checkFullBorder(sheet, 'borderRight', rowIdx, range[1] - 1);\n                this.setCellBorder(sheet, { borderLeft: border }, rowIdx, range[1], actionUpdate);\n                this.checkAdjacentBorder(sheet, 'borderLeft', rowIdx, range[3] + 1);\n                this.checkFullBorder(sheet, 'borderLeft', rowIdx, range[3] + 1);\n                this.setCellBorder(sheet, { borderRight: border }, rowIdx, range[3], actionUpdate, null, type);\n            }\n        }\n        else if (type === 'Inner') {\n            var mergeArgs = { range: [range[0], range[1], range[0], range[1]] };\n            this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.mergedRange, mergeArgs);\n            if (mergeArgs.range[0] === range[0] && mergeArgs.range[1] === range[1] &&\n                mergeArgs.range[2] === range[2] && mergeArgs.range[3] === range[3]) {\n                return;\n            }\n            for (var i = range[0]; i <= range[2]; i++) {\n                for (var j = range[1]; j <= range[3]; j++) {\n                    var style = {};\n                    prevBorder = this.parent.getCellStyleValue(['border'], [i, j]).border;\n                    if (prevBorder !== '') {\n                        style.border = undefined;\n                        if (j === range[3] || j === range[1] || i === range[0] || i === range[2]) {\n                            if (i === range[0]) {\n                                style.borderTop = prevBorder;\n                            }\n                            if (i === range[2]) {\n                                style.borderBottom = prevBorder;\n                            }\n                            if (j === range[3]) {\n                                style.borderRight = prevBorder;\n                            }\n                            if (j === range[1]) {\n                                style.borderLeft = prevBorder;\n                            }\n                        }\n                    }\n                    if (j !== range[3]) {\n                        style.borderRight = border;\n                    }\n                    if (i !== range[0]) {\n                        style.borderTop = border;\n                    }\n                    if (i !== range[2]) {\n                        style.borderBottom = border;\n                    }\n                    if (j !== range[1]) {\n                        style.borderLeft = border;\n                    }\n                    this.setCellBorder(sheet, style, i, j, actionUpdate, j === range[3], undefined, undefined, undefined, mergeBorderRows);\n                }\n            }\n        }\n        else if (type === 'Vertical') {\n            for (var i = range[0]; i <= range[2]; i++) {\n                for (var j = range[1]; j <= range[3]; j++) {\n                    var style = { borderRight: border, borderLeft: border };\n                    if (j === range[1]) {\n                        this.checkAdjacentBorder(sheet, 'borderRight', i, j - 1);\n                        this.checkFullBorder(sheet, 'borderRight', i, j - 1);\n                    }\n                    if (j === range[3]) {\n                        this.checkAdjacentBorder(sheet, 'borderLeft', i, j + 1);\n                        this.checkFullBorder(sheet, 'borderLeft', i, j + 1);\n                    }\n                    this.setCellBorder(sheet, style, i, j, actionUpdate);\n                }\n            }\n        }\n        else {\n            for (var i = range[0]; i <= range[2]; i++) {\n                for (var j = range[1]; j <= range[3]; j++) {\n                    var style = { borderTop: border, borderBottom: border };\n                    if (i === range[0]) {\n                        this.checkAdjacentBorder(sheet, 'borderBottom', i - 1, j);\n                        this.checkFullBorder(sheet, 'borderBottom', i - 1, j);\n                    }\n                    this.setCellBorder(sheet, style, i, j, actionUpdate, j === range[3]);\n                    if (i === range[2]) {\n                        this.checkAdjacentBorder(sheet, 'borderTop', i + 1, j);\n                        this.checkFullBorder(sheet, 'borderTop', i + 1, j);\n                        this.setBottomBorderPriority(sheet, i, j);\n                    }\n                }\n            }\n        }\n    };\n    WorkbookCellFormat.prototype.setCellBorder = function (sheet, style, rowIdx, colIdx, actionUpdate, lastCell, type, modelUpdate, isUndoRedo, mergeBorderRows) {\n        var cell = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCell)(rowIdx, colIdx, sheet);\n        var column = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getColumn)(sheet, colIdx);\n        var row = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRow)(sheet, rowIdx);\n        if ((cell && cell.isReadOnly) || (column && column.isReadOnly) || (row && row.isReadOnly)) {\n            return;\n        }\n        this.setCellStyle(sheet, rowIdx, colIdx, style);\n        if (!modelUpdate && this.parent.getActiveSheet().id === sheet.id) {\n            if (type === 'Outer' && (style.borderBottom || style.borderRight)) {\n                var mergeArgs = { range: [rowIdx, colIdx, rowIdx, colIdx] };\n                this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.activeCellMergedRange, mergeArgs);\n                rowIdx = mergeArgs.range[0];\n                colIdx = mergeArgs.range[1];\n            }\n            if (isUndoRedo) {\n                if (style.borderTop === '' && this.parent.getCellStyleValue(['borderBottom'], [rowIdx - 1, colIdx]).borderBottom !== '') {\n                    style.borderTop = this.parent.getCellStyleValue(['borderBottom'], [rowIdx - 1, colIdx]).borderBottom;\n                }\n                if (style.borderLeft === '' && this.parent.getCellStyleValue(['borderRight'], [rowIdx, colIdx - 1]).borderRight !== '') {\n                    style.borderLeft = this.parent.getCellStyleValue(['borderRight'], [rowIdx, colIdx - 1]).borderRight;\n                }\n                if (style.borderRight === '' && this.parent.getCellStyleValue(['borderLeft'], [rowIdx, colIdx + 1]).borderLeft !== '') {\n                    style.borderRight = this.parent.getCellStyleValue(['borderLeft'], [rowIdx, colIdx + 1]).borderLeft;\n                }\n            }\n            this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.applyCellFormat, {\n                style: style, rowIdx: rowIdx, colIdx: colIdx, onActionUpdate: actionUpdate, first: '', lastCell: lastCell,\n                isHeightCheckNeeded: true, manualUpdate: true, mergeBorderRows: mergeBorderRows\n            });\n        }\n    };\n    WorkbookCellFormat.prototype.setCellStyle = function (sheet, rowIdx, colIdx, style) {\n        if (!sheet.rows[rowIdx]) {\n            sheet.rows[rowIdx] = { cells: [] };\n        }\n        else if (!sheet.rows[rowIdx].cells) {\n            sheet.rows[rowIdx].cells = [];\n        }\n        if (!sheet.rows[rowIdx].cells[colIdx]) {\n            sheet.rows[rowIdx].cells[colIdx] = {};\n        }\n        if (!sheet.rows[rowIdx].cells[colIdx].style) {\n            sheet.rows[rowIdx].cells[colIdx].style = {};\n        }\n        Object.assign(sheet.rows[rowIdx].cells[colIdx].style, style, null, true);\n    };\n    WorkbookCellFormat.prototype.skipHiddenRows = function (sheet, startIdx) {\n        startIdx++;\n        if ((0,_index__WEBPACK_IMPORTED_MODULE_1__.isHiddenRow)(sheet, startIdx)) {\n            startIdx = this.skipHiddenRows(sheet, startIdx);\n        }\n        return startIdx;\n    };\n    WorkbookCellFormat.prototype.addEventListener = function () {\n        this.parent.on(_common_index__WEBPACK_IMPORTED_MODULE_0__.setCellFormat, this.format, this);\n        this.parent.on(_common_index__WEBPACK_IMPORTED_MODULE_0__.textDecorationUpdate, this.textDecorationActionUpdate, this);\n        this.parent.on(_common_index__WEBPACK_IMPORTED_MODULE_0__.clear, this.clearCellObj, this);\n    };\n    WorkbookCellFormat.prototype.removeEventListener = function () {\n        if (!this.parent.isDestroyed) {\n            this.parent.off(_common_index__WEBPACK_IMPORTED_MODULE_0__.setCellFormat, this.format);\n            this.parent.off(_common_index__WEBPACK_IMPORTED_MODULE_0__.textDecorationUpdate, this.textDecorationActionUpdate);\n            this.parent.off(_common_index__WEBPACK_IMPORTED_MODULE_0__.clear, this.clearCellObj);\n        }\n    };\n    WorkbookCellFormat.prototype.clearCellObj = function (options) {\n        var lastIndex = options.range ? options.range.lastIndexOf('!') : 0;\n        var clrRange = options.range ? (lastIndex > 0) ? options.range.substring(lastIndex + 1) : options.range\n            : this.parent.getActiveSheet().selectedRange;\n        var sheetIdx = (options.range && lastIndex > 0) ?\n            (0,_index__WEBPACK_IMPORTED_MODULE_1__.getSheetIndex)(this.parent, options.range.substring(0, lastIndex)) : this.parent.activeSheetIndex;\n        var sheet = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getSheet)(this.parent, sheetIdx);\n        var range = (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.getSwapRange)((0,_common_index__WEBPACK_IMPORTED_MODULE_0__.getIndexesFromAddress)(clrRange));\n        var sRowIdx = range[0];\n        var eRowIdx = range[2];\n        var cf = sheet.conditionalFormats && sheet.conditionalFormats.length &&\n            [].slice.call(sheet.conditionalFormats);\n        var cfRule = [];\n        var cfRefreshAll;\n        var evtArgs;\n        var sColIdx;\n        var eColIdx;\n        var isValExist;\n        for (sRowIdx; sRowIdx <= eRowIdx; sRowIdx++) {\n            sColIdx = range[1];\n            eColIdx = range[3];\n            for (sColIdx; sColIdx <= eColIdx; sColIdx++) {\n                var cell = (0,_index__WEBPACK_IMPORTED_MODULE_1__.getCell)(sRowIdx, sColIdx, sheet);\n                var isReadonlyCell = (0,_common_index__WEBPACK_IMPORTED_MODULE_0__.isReadOnly)(cell, (0,_index__WEBPACK_IMPORTED_MODULE_1__.getColumn)(sheet, sColIdx), (0,_index__WEBPACK_IMPORTED_MODULE_1__.getRow)(sheet, sRowIdx));\n                if (cell && (options.type === 'Clear All' || options.type === 'Clear Formats')) {\n                    if (cell.rowSpan > 1 || cell.colSpan > 1) {\n                        var mergeArgs = { range: [sRowIdx, sColIdx, sRowIdx, sColIdx] };\n                        this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.mergedRange, mergeArgs);\n                        var mergedRanges = mergeArgs.range;\n                        if (range[0] <= mergedRanges[0] && range[1] <= mergedRanges[1] && range[2] >= mergedRanges[2] &&\n                            range[3] >= mergedRanges[3]) {\n                            this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.setMerge, { merge: false, range: mergedRanges, type: 'All', sheetIndex: sheetIdx,\n                                preventRefresh: sheetIdx !== this.parent.activeSheetIndex });\n                        }\n                    }\n                    if (!!cell.rowSpan && cell.rowSpan !== 1 || !!cell.colSpan && cell.colSpan !== 1) {\n                        continue;\n                    }\n                }\n                if (cell && !isReadonlyCell) {\n                    switch (options.type) {\n                        case 'Clear Formats':\n                            delete cell.format;\n                            delete cell.rowSpan;\n                            delete cell.style;\n                            delete cell.wrap;\n                            delete cell.colSpan;\n                            delete cell.formattedText;\n                            if (cell.hyperlink) {\n                                cell.style = { textDecoration: 'none', color: 'inherit' };\n                            }\n                            break;\n                        case 'Clear Contents':\n                            if (cell.hyperlink) {\n                                this.parent.notify(_common_index__WEBPACK_IMPORTED_MODULE_0__.deleteHyperlink, { sheet: sheet, rowIdx: sRowIdx, colIdx: sColIdx, preventRefresh: true });\n                                cell.style = { textDecoration: 'underline', color: '#00e' };\n                            }\n                            isValExist = !!(cell.value || cell.formula);\n                            delete cell.value;\n                            delete cell.formula;\n                            delete cell.formattedText;\n                            if (isValExist) {\n                                evtArgs = { action: 'refreshCalculate', rowIndex: sRowIdx, colIndex: sColIdx, sheetIndex: sheetIdx };\n                                this.parent.notify(_index__WEBPACK_IMPORTED_MODULE_1__.workbookFormulaOperation, evtArgs);\n                                if (cf && !cfRefreshAll) {\n                                    cfRefreshAll = evtArgs.isFormulaDependent;\n                                    if (!cfRefreshAll) {\n                                        (0,_index__WEBPACK_IMPORTED_MODULE_1__.updateCFModel)(cf, cfRule, sRowIdx, sColIdx);\n                                    }\n                                }\n                            }\n                            break;\n                        case 'Clear Hyperlinks':\n                            delete cell.hyperlink;\n                            break;\n                        case 'Clear All':\n                            isValExist = !!(cell.value || cell.formula);\n                            (0,_index__WEBPACK_IMPORTED_MODULE_1__.setCell)(sRowIdx, sColIdx, sheet, {}, false);\n                            if (isValExist) {\n                                evtArgs = { action: 'refreshCalculate', rowIndex: sRowIdx, colIndex: sColIdx, sheetIndex: sheetIdx };\n                                this.parent.notify(_index__WEBPACK_IMPORTED_MODULE_1__.workbookFormulaOperation, evtArgs);\n                                if (cf && !cfRefreshAll) {\n                                    cfRefreshAll = evtArgs.isFormulaDependent;\n                                }\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n        if ((cfRule.length || cfRefreshAll) && sheetIdx === this.parent.activeSheetIndex) {\n            this.parent.notify(_index__WEBPACK_IMPORTED_MODULE_1__.applyCF, { cfModel: !cfRefreshAll && cfRule, refreshAll: cfRefreshAll, isAction: true });\n        }\n    };\n    /**\n     * To destroy workbook cell format.\n     *\n     * @returns {void} - To destroy workbook cell format.\n     */\n    WorkbookCellFormat.prototype.destroy = function () {\n        this.removeEventListener();\n        this.parent = null;\n    };\n    /**\n     * Get the workbook cell format module name.\n     *\n     *  @returns {void}\n     */\n    WorkbookCellFormat.prototype.getModuleName = function () {\n        return 'workbookcellformat';\n    };\n    return WorkbookCellFormat;\n}());\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-spreadsheet/src/workbook/actions/cell-format.js?");

/***/ })

}]);