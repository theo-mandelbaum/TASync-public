"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-pdfviewer_src_pdfviewer_drawing_tools_js-4ec3e751"],{

/***/ "./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/tools.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/tools.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectTool: () => (/* binding */ ConnectTool),\n/* harmony export */   InkDrawingTool: () => (/* binding */ InkDrawingTool),\n/* harmony export */   LineTool: () => (/* binding */ LineTool),\n/* harmony export */   MoveTool: () => (/* binding */ MoveTool),\n/* harmony export */   NodeDrawingTool: () => (/* binding */ NodeDrawingTool),\n/* harmony export */   PolygonDrawingTool: () => (/* binding */ PolygonDrawingTool),\n/* harmony export */   ResizeTool: () => (/* binding */ ResizeTool),\n/* harmony export */   RotateTool: () => (/* binding */ RotateTool),\n/* harmony export */   SelectTool: () => (/* binding */ SelectTool),\n/* harmony export */   StampTool: () => (/* binding */ StampTool),\n/* harmony export */   ToolBase: () => (/* binding */ ToolBase)\n/* harmony export */ });\n/* harmony import */ var _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @syncfusion/ej2-drawings */ \"./node_modules/@syncfusion/ej2-drawings/index.js\");\n/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/selector.js\");\n/* harmony import */ var _action__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./action */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/action.js\");\n/* harmony import */ var _drawing_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawing-util */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/drawing-util.js\");\n/* harmony import */ var _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @syncfusion/ej2-base */ \"./node_modules/@syncfusion/ej2-base/index.js\");\n/* harmony import */ var _connector_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./connector-util */ \"./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/connector-util.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Defines the interactive tools\n *\n * @hidden\n */\nvar ToolBase = /** @class */ (function () {\n    /**\n     * Initializes the tool\n     *\n     * @param {PdfViewer} pdfViewer - Specified the pdfviewer component.\n     * @param {PdfViewerBase} pdfViewerBase - Specified the pdfViewer base component.\n     * @param {boolean} protectChange - Set the default value as false.\n     */\n    function ToolBase(pdfViewer, pdfViewerBase, protectChange) {\n        if (protectChange === void 0) { protectChange = false; }\n        /**\n         * Command that is corresponding to the current action\n         */\n        this.commandHandler = null;\n        /**\n         * Sets/Gets whether the interaction is being done\n         */\n        this.inAction = false;\n        /**\n         * Sets/Gets the protect change\n         */\n        this.pdfViewerBase = null;\n        /**\n         * Sets/Gets the current element that is under mouse\n         */\n        /**   @private  */\n        this.currentElement = null;\n        /**   @private  */\n        this.blocked = false;\n        this.isTooltipVisible = false;\n        /** @private */\n        this.childTable = {};\n        /** @private */\n        this.helper = undefined;\n        /**\n         * Sets/Gets the previous object when mouse down\n         */\n        this.undoElement = { annotations: [] };\n        this.undoParentElement = { annotations: [] };\n        this.commandHandler = pdfViewer;\n        this.pdfViewerBase = pdfViewerBase;\n    }\n    /**\n     * @param {IElement} currentElement - Specified the current element.\n     * @returns {void}\n     */\n    ToolBase.prototype.startAction = function (currentElement) {\n        this.currentElement = currentElement;\n        this.inAction = true;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse up event arguments.\n     * @returns {void}\n     */\n    ToolBase.prototype.mouseDown = function (args) {\n        this.currentElement = args.source;\n        this.startPosition = this.currentPosition = this.prevPosition = args.position;\n        this.isTooltipVisible = true;\n        this.startAction(args.source);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse up event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    ToolBase.prototype.mouseMove = function (args) {\n        this.currentPosition = args.position;\n        //this.currentElement = currentElement;\n        this.prevPageId = this.pdfViewerBase.activeElements.activePageID;\n        return !this.blocked;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse up event arguments.\n     * @returns {void}\n     */\n    ToolBase.prototype.mouseUp = function (args) {\n        this.currentPosition = args.position;\n        // this.currentElement = currentElement;\n        this.isTooltipVisible = false;\n        //At the end\n        this.endAction();\n        this.helper = null;\n    };\n    ToolBase.prototype.endAction = function () {\n        //remove helper\n        if (this.commandHandler) {\n            this.commandHandler.tool = '';\n            if (this.helper) {\n                this.commandHandler.remove(this.helper);\n            }\n        }\n        this.commandHandler = null;\n        this.currentElement = null;\n        this.currentPosition = null;\n        this.inAction = false;\n        this.blocked = false;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse wheel event arguments.\n     * @returns {void}\n     */\n    ToolBase.prototype.mouseWheel = function (args) {\n        this.currentPosition = args.position;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse leave event arguments.\n     * @returns {void}\n     */\n    ToolBase.prototype.mouseLeave = function (args) {\n        this.mouseUp(args);\n    };\n    ToolBase.prototype.updateSize = function (shape, startPoint, endPoint, corner, initialBounds, angle, isMouseUp) {\n        var zoom = this.commandHandler.viewerBase.getZoomFactor();\n        var difx = this.currentPosition.x / zoom - this.startPosition.x / zoom;\n        var dify = this.currentPosition.y / zoom - this.startPosition.y / zoom;\n        var rotateAngle = (shape instanceof _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.TextElement) ? angle : shape.rotateAngle;\n        var matrix = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.identityMatrix)();\n        (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.rotateMatrix)(matrix, -rotateAngle, 0, 0);\n        var deltaWidth = 0;\n        var deltaHeight = 0;\n        var diff;\n        var width = (shape instanceof _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.TextElement) ? shape.actualSize.width : shape.wrapper.bounds.width;\n        var height = (shape instanceof _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.TextElement) ? shape.actualSize.height : shape.wrapper.bounds.height;\n        var obj = shape;\n        if (!shape.formFieldAnnotationType) {\n            if (!shape.annotName && !shape.shapeAnnotationType) {\n                if (shape) {\n                    obj = shape.annotations[0];\n                }\n            }\n        }\n        var annotationSettings = this.commandHandler.annotationModule ?\n            this.commandHandler.annotationModule.findAnnotationSettings(obj) : {};\n        var annotationMaxHeight = 0;\n        var annotationMaxWidth = 0;\n        var annotationMinHeight = 0;\n        var annotationMinWidth = 0;\n        if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {\n            annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;\n            annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;\n            annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;\n            annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;\n        }\n        var isAnnotationSet = false;\n        if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {\n            isAnnotationSet = true;\n        }\n        if (isAnnotationSet && isMouseUp) {\n            var size = this.getPositions(corner, difx, dify);\n            var newWidth = width + size.x;\n            var newHeight = height + size.y;\n            if (newHeight < annotationMinHeight) {\n                dify = annotationMinHeight - height;\n            }\n            else if (newHeight > annotationMaxHeight) {\n                dify = annotationMaxHeight - height;\n            }\n            if (newWidth < annotationMinWidth) {\n                difx = annotationMinWidth - width;\n            }\n            else if (newWidth > annotationMaxWidth) {\n                difx = annotationMaxWidth - width;\n            }\n        }\n        switch (corner) {\n            case 'ResizeWest':\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                deltaHeight = 1;\n                dify = 0;\n                if (isAnnotationSet) {\n                    if (initialBounds.width - difx > annotationMaxWidth) {\n                        difx = annotationMaxWidth - initialBounds.width;\n                    }\n                }\n                deltaWidth = (initialBounds.width - difx) / width;\n                break;\n            case 'ResizeEast':\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                dify = 0;\n                if (isAnnotationSet) {\n                    if (initialBounds.width + difx > annotationMaxWidth) {\n                        difx = annotationMaxWidth - initialBounds.width;\n                    }\n                }\n                deltaWidth = (initialBounds.width + difx) / width;\n                deltaHeight = 1;\n                break;\n            case 'ResizeNorth':\n                deltaWidth = 1;\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                if (isAnnotationSet) {\n                    if (initialBounds.height - dify > annotationMaxHeight) {\n                        dify = annotationMaxHeight - initialBounds.height;\n                    }\n                }\n                deltaHeight = (initialBounds.height - dify) / height;\n                break;\n            case 'ResizeSouth':\n                deltaWidth = 1;\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                if (isAnnotationSet) {\n                    if (initialBounds.height + dify > annotationMaxHeight) {\n                        dify = annotationMaxHeight - initialBounds.height;\n                    }\n                }\n                deltaHeight = (initialBounds.height + dify) / height;\n                break;\n            case 'ResizeNorthEast':\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                if (isAnnotationSet) {\n                    if (initialBounds.width + difx > annotationMaxWidth) {\n                        difx = annotationMaxWidth - initialBounds.width;\n                    }\n                    if (initialBounds.height - dify > annotationMaxHeight) {\n                        dify = annotationMaxHeight - initialBounds.height;\n                    }\n                }\n                deltaWidth = (initialBounds.width + difx) / width;\n                deltaHeight = (initialBounds.height - dify) / height;\n                break;\n            case 'ResizeNorthWest':\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                if (isAnnotationSet) {\n                    if (initialBounds.width - difx > annotationMaxWidth) {\n                        difx = annotationMaxWidth - initialBounds.width;\n                    }\n                    if (initialBounds.height - dify > annotationMaxHeight) {\n                        dify = annotationMaxHeight - initialBounds.height;\n                    }\n                }\n                deltaWidth = (initialBounds.width - difx) / width;\n                deltaHeight = (initialBounds.height - dify) / height;\n                break;\n            case 'ResizeSouthEast':\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                if (isAnnotationSet) {\n                    if (initialBounds.width + difx > annotationMaxWidth) {\n                        difx = annotationMaxWidth - initialBounds.width;\n                    }\n                    if (initialBounds.height + dify > annotationMaxHeight) {\n                        dify = annotationMaxHeight - initialBounds.height;\n                    }\n                }\n                deltaHeight = (initialBounds.height + dify) / height;\n                deltaWidth = (initialBounds.width + difx) / width;\n                break;\n            case 'ResizeSouthWest':\n                diff = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, ({ x: difx, y: dify }));\n                difx = diff.x;\n                dify = diff.y;\n                if (isAnnotationSet) {\n                    if (initialBounds.width - difx > annotationMaxWidth) {\n                        difx = annotationMaxWidth - initialBounds.width;\n                    }\n                    if (initialBounds.height + dify > annotationMaxHeight) {\n                        dify = annotationMaxHeight - initialBounds.height;\n                    }\n                }\n                deltaWidth = (initialBounds.width - difx) / width;\n                deltaHeight = (initialBounds.height + dify) / height;\n                break;\n        }\n        return { width: deltaWidth, height: deltaHeight };\n    };\n    ToolBase.prototype.getPivot = function (corner) {\n        switch (corner) {\n            case 'ResizeWest':\n                return { x: 1, y: 0.5 };\n            case 'ResizeEast':\n                return { x: 0, y: 0.5 };\n            case 'ResizeNorth':\n                return { x: 0.5, y: 1 };\n            case 'ResizeSouth':\n                return { x: 0.5, y: 0 };\n            case 'ResizeNorthEast':\n                return { x: 0, y: 1 };\n            case 'ResizeNorthWest':\n                return { x: 1, y: 1 };\n            case 'ResizeSouthEast':\n                return { x: 0, y: 0 };\n            case 'ResizeSouthWest':\n                return { x: 1, y: 0 };\n        }\n        return { x: 0.5, y: 0.5 };\n    };\n    ToolBase.prototype.getPositions = function (corner, x, y) {\n        switch (corner) {\n            case 'ResizeEast':\n                return { x: x, y: 0 };\n            case 'ResizeSouthEast':\n                return { x: x, y: y };\n            case 'ResizeSouth':\n                return { x: 0, y: y };\n            case 'ResizeNorth':\n                return { x: 0, y: -y };\n            case 'ResizeNorthEast':\n                return { x: x, y: -y };\n            case 'ResizeNorthWest':\n                return { x: -x, y: -y };\n            case 'ResizeWest':\n                return { x: -x, y: 0 };\n            case 'ResizeSouthWest':\n                return { x: -x, y: y };\n        }\n        return { x: x, y: y };\n    };\n    return ToolBase;\n}());\n\n/**\n * Helps to select the objects\n *\n * @hidden\n */\nvar SelectTool = /** @class */ (function (_super) {\n    __extends(SelectTool, _super);\n    function SelectTool(commandHandler, base) {\n        return _super.call(this, commandHandler, base, true) || this;\n        //     this.action = action;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse down event arguments.\n     * @returns {void}\n     */\n    SelectTool.prototype.mouseDown = function (args) {\n        this.inAction = true;\n        this.mouseEventHelper(args);\n        _super.prototype.mouseDown.call(this, args);\n    };\n    SelectTool.prototype.mouseEventHelper = function (args) {\n        if (this.commandHandler && this.commandHandler.annotationModule) {\n            this.commandHandler.annotationModule.overlappedCollections =\n                (0,_action__WEBPACK_IMPORTED_MODULE_2__.findActiveElement)(args, this.pdfViewerBase, this.commandHandler, true);\n        }\n        var object = (0,_action__WEBPACK_IMPORTED_MODULE_2__.findActiveElement)(args, this.pdfViewerBase, this.commandHandler);\n        // if (!isNullOrUndefined(object) && (object as any).shapeAnnotationType !== 'Path'){\n        var isLock = false;\n        if (object && object.shapeAnnotationType === 'StickyNotes') {\n            if (object.annotationSettings && object.annotationSettings.isLock) {\n                if (this.commandHandler.annotationModule.checkAllowedInteractions('Select', object)) {\n                    isLock = false;\n                }\n                else {\n                    isLock = true;\n                }\n            }\n        }\n        if (!isLock) {\n            var currentSelctor = void 0;\n            if (args.source && args.annotationSelectorSettings !== null) {\n                currentSelctor = args.source.annotationSelectorSettings;\n            }\n            else {\n                currentSelctor = '';\n            }\n            if (this.commandHandler) {\n                var selectedObject = this.commandHandler.selectedItems;\n                if (selectedObject) {\n                    var annotation = selectedObject.annotations[0];\n                    var formField = selectedObject.formFields[0];\n                    var currentAnnot = this.commandHandler.selectedItems.annotations[0];\n                    var currentSource = args.source;\n                    if ((selectedObject.annotations.length) && args.info && !args.info.ctrlKey\n                        && this.commandHandler.annotationModule &&\n                        this.commandHandler.annotationModule.freeTextAnnotationModule.isInuptBoxInFocus === false) {\n                        this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    }\n                    else if (args.info && args.info.ctrlKey && ((currentSource && currentSource.shapeAnnotationType === 'FreeText') || (currentAnnot && currentAnnot.shapeAnnotationType === 'FreeText'))) {\n                        this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    }\n                    else if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(object) && (this.commandHandler.annotationModule && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(this.commandHandler.annotation.textMarkupAnnotationModule) && (0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(this.commandHandler.annotation.textMarkupAnnotationModule.currentTextMarkupAnnotation)) && this.commandHandler.formDesignerModule && !((currentSource && currentSource.shapeAnnotationType === 'FreeText') || (currentAnnot && (currentAnnot.shapeAnnotationType === 'FreeText' || currentAnnot.shapeAnnotationType === 'Image' || currentAnnot.shapeAnnotationType === 'StickyNotes')))) {\n                        this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    }\n                    if (object) {\n                        if (((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(formField) || (formField &&\n                            formField.id !== object.id)) &&\n                            !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(this.pdfViewerBase.isFreeTextSelected) && !this.pdfViewerBase.isFreeTextSelected) {\n                            this.commandHandler.select([object.id], currentSelctor);\n                            this.commandHandler.viewerBase.isAnnotationMouseDown = true;\n                        }\n                        this.pdfViewerBase.isFreeTextSelected = false;\n                        this.commandHandler.viewerBase.isFormFieldMouseDown = true;\n                    }\n                    if (selectedObject.annotations.length === 0 && annotation && annotation.shapeAnnotationType !== 'HandWrittenSignature' && annotation.shapeAnnotationType !== 'SignatureText' && annotation.shapeAnnotationType !== 'SignatureImage' && annotation.shapeAnnotationType !== 'Path' && !annotation.formFieldAnnotationType) {\n                        if (this.commandHandler.enableToolbar && _syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.Browser.isDevice && !this.commandHandler.enableDesktopMode) {\n                            this.commandHandler.toolbarModule.showToolbar(true);\n                        }\n                        this.commandHandler.fireAnnotationUnSelect(annotation.annotName, annotation.pageIndex, annotation);\n                    }\n                    if (selectedObject.annotations.length === 0 && annotation && (annotation.shapeAnnotationType === 'HandWrittenSignature' || annotation.shapeAnnotationType === 'SignatureText' || annotation.shapeAnnotationType === 'SignatureImage' || annotation.shapeAnnotationType === 'Path' || annotation.signatureType)) {\n                        this.commandHandler.fireSignatureUnselect(annotation.signatureName, annotation.pageIndex, annotation);\n                    }\n                    if (selectedObject.formFields.length === 0 && this.commandHandler.formDesignerModule &&\n                        formField && formField.formFieldAnnotationType) {\n                        var field = { name: formField.name, id: formField.id,\n                            value: formField.value, fontFamily: formField.fontFamily, fontSize: formField.fontSize,\n                            fontStyle: formField.fontStyle,\n                            color: formField.color,\n                            backgroundColor: formField.backgroundColor,\n                            alignment: formField.alignment, isReadonly: formField.isReadOnly,\n                            visibility: formField.visibility,\n                            maxLength: formField.maxLength, isRequired: formField.isRequired,\n                            isPrint: formField.isPrint, rotation: formField.rotation, tooltip: formField.tooltip,\n                            options: formField.options, isChecked: formField.isChecked,\n                            isSelected: formField.isSelected };\n                        this.commandHandler.fireFormFieldUnselectEvent('formFieldUnselect', field, formField.pageIndex);\n                    }\n                    else if (this.pdfViewerBase.currentTarget && this.pdfViewerBase.currentTarget.id && this.commandHandler.formFields && event.type === 'mousedown') {\n                        for (var i = 0; i < this.commandHandler.formFields.length; i++) {\n                            var formField_1 = this.commandHandler.formFields[parseInt(i.toString(), 10)];\n                            if (this.pdfViewerBase.currentTarget && this.pdfViewerBase.currentTarget.id === formField_1.id) {\n                                var field = {\n                                    value: formField_1.value, fontFamily: formField_1.fontFamily, fontSize: formField_1.fontSize,\n                                    fontStyle: formField_1.fontStyle, color: formField_1.color,\n                                    backgroundColor: formField_1.backgroundColor, alignment: formField_1.alignment,\n                                    isReadonly: formField_1.isReadonly, visibility: formField_1.visibility,\n                                    maxLength: formField_1.maxLength, isRequired: formField_1.isRequired,\n                                    isPrint: formField_1.isPrint, rotation: formField_1.rotateAngle,\n                                    tooltip: formField_1.tooltip,\n                                    options: formField_1.options, isChecked: formField_1.isChecked,\n                                    isSelected: formField_1.isSelected, id: formField_1.id, name: formField_1.name\n                                };\n                                if (!object) {\n                                    this.commandHandler.fireFocusOutFormField(field, formField_1.pageIndex);\n                                    this.pdfViewerBase.currentTarget = null;\n                                }\n                                else {\n                                    if (this.pdfViewerBase.currentTarget.id !== event.target.id && event.target.className !== 'e-pv-text-layer') {\n                                        this.commandHandler.fireFocusOutFormField(field, formField_1.pageIndex);\n                                        this.pdfViewerBase.currentTarget = null;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // } else {\n        //     if (!isNullOrUndefined(this.commandHandler))\n        //         this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n        // }\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse move event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    SelectTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        //draw selected region\n        return !this.blocked;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse up event arguments.\n     * @returns {void}\n     */\n    SelectTool.prototype.mouseUp = function (args) {\n        this.mouseEventHelper(args);\n        this.inAction = false;\n        _super.prototype.mouseUp.call(this, args);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse leave event arguments.\n     * @returns {void}\n     */\n    SelectTool.prototype.mouseLeave = function (args) {\n        if (this.inAction) {\n            this.mouseUp(args);\n        }\n    };\n    return SelectTool;\n}(ToolBase));\n\n/** @hidden */\nvar MoveTool = /** @class */ (function (_super) {\n    __extends(MoveTool, _super);\n    function MoveTool(commandHandler, base) {\n        var _this = _super.call(this, commandHandler, base) || this;\n        /**   @private  */\n        _this.currentTarget = null;\n        /**   @private  */\n        _this.prevNode = null;\n        return _this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Mouse down event arguments.\n     * @returns {void}\n     */\n    MoveTool.prototype.mouseDown = function (args) {\n        _super.prototype.mouseDown.call(this, args);\n        this.offset = { x: args.source.wrapper.offsetX, y: args.source.wrapper.offsetY };\n        this.startPosition = args.position;\n        var nodeMouseDown = (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(args.source);\n        this.redoElement = {\n            bounds: {\n                x: nodeMouseDown.wrapper.offsetX, y: nodeMouseDown.wrapper.offsetY,\n                width: nodeMouseDown.wrapper.actualSize.width, height: nodeMouseDown.wrapper.actualSize.height\n            }\n        };\n        if ((0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.isLineShapes)(nodeMouseDown)) {\n            this.redoElement.vertexPoints = nodeMouseDown.vertexPoints;\n            this.redoElement.leaderHeight = nodeMouseDown.leaderHeight;\n        }\n        this.inAction = true;\n    };\n    /**\n     * @private\n     * @param {any} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    MoveTool.prototype.mouseUp = function (args) {\n        if (this.commandHandler && args.source) {\n            this.checkisAnnotationMove(args);\n            var isDragged = false;\n            var currentSelctor = args.source.annotationSelectorSettings;\n            this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n            this.commandHandler.select([args.source.id], currentSelctor);\n            if (this.pdfViewerBase.activeElements.activePageID === args.source.pageIndex && this.pdfViewerBase.action === 'Drag') {\n                this.commandHandler.dragSelectedObjects(this.calculateMouseActionXDiff(args), this.calculateMouseActionYDiff(args), this.pdfViewerBase.activeElements.activePageID, currentSelctor, null);\n            }\n            if (args.source && (args.source.formFieldAnnotationType === 'Textbox' || args.source.formFieldAnnotationType === 'Checkbox'\n                || args.source.formFieldAnnotationType === 'RadioButton' || args.source.formFieldAnnotationType === 'ListBox'\n                || args.source.formFieldAnnotationType === 'SignatureField' || args.source.formFieldAnnotationType === 'InitialField' || args.source.formFieldAnnotationType === 'DropdownList'\n                || args.source.formFieldAnnotationType === 'PasswordField')) {\n                this.commandHandler.formDesignerModule.updateHTMLElement(args.source);\n            }\n            this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelctor);\n            this.commandHandler.viewerBase.isAnnotationMouseMove = false;\n            this.commandHandler.viewerBase.isFormFieldMouseMove = false;\n            var newShapeObject = {\n                bounds: {\n                    x: args.source.wrapper.offsetX, y: args.source.wrapper.offsetY,\n                    width: args.source.wrapper.actualSize.width, height: args.source.wrapper.actualSize.height\n                }, modifiedDate: args.source.modifiedDate\n            };\n            if ((0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.isLineShapes)(args.source)) {\n                newShapeObject.vertexPoints = args.source.vertexPoints;\n                newShapeObject.leaderHeight = args.source.leaderHeight;\n            }\n            if (args.target && args.target.formFieldAnnotationType) {\n                var node = args.target;\n                var field = {\n                    value: node.value, fontFamily: node.fontFamily, fontSize: node.fontSize, fontStyle: node.fontStyle,\n                    color: node.color, backgroundColor: node.backgroundColor,\n                    borderColor: node.borderColor,\n                    thickness: node.thickness, alignment: node.alignment,\n                    isReadonly: node.isReadonly, visibility: node.visibility,\n                    maxLength: node.maxLength, isRequired: node.isRequired, isPrint: node.isPrint,\n                    rotation: node.rotateAngle, tooltip: node.tooltip, options: node.options,\n                    isChecked: node.isChecked, isSelected: node.isSelected\n                };\n                var currentPosition = { X: args.source.wrapper.offsetX, Y: args.source.wrapper.offsetY,\n                    Width: args.source.wrapper.actualSize.width, Height: args.source.wrapper.actualSize.height };\n                var previousPosition = { X: this.offset.x, Y: this.offset.y,\n                    Width: args.source.wrapper.actualSize.width, Height: args.source.wrapper.actualSize.height };\n                this.commandHandler.fireFormFieldMoveEvent('formFieldMove', field, node.pageIndex, previousPosition, currentPosition);\n            }\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(this.redoElement) && (this.redoElement.bounds.height !== newShapeObject.bounds.height ||\n                this.redoElement.bounds.width !== newShapeObject.bounds.width || this.redoElement.bounds.x !==\n                newShapeObject.bounds.x || this.redoElement.bounds.y !== newShapeObject.bounds.y)) {\n                isDragged = true;\n            }\n            if (this.commandHandler.annotation && isDragged) {\n                this.commandHandler.annotation.addAction(this.pageIndex, null, args.source, 'Drag', '', this.redoElement, newShapeObject);\n                this.commandHandler.annotation.stampAnnotationModule.updateSessionStorage(args.source, null, 'Drag');\n                this.commandHandler.annotation.stickyNotesAnnotationModule.updateStickyNotes(args.source, null);\n            }\n        }\n        var shapeAnnotationType = this.commandHandler && this.commandHandler.selectedItems &&\n            this.commandHandler.selectedItems.annotations && this.commandHandler.selectedItems.annotations.length > 0 ?\n            this.commandHandler.selectedItems.annotations[0].shapeAnnotationType : null;\n        if (shapeAnnotationType && shapeAnnotationType !== 'Image' && shapeAnnotationType !== 'SignatureImage') {\n            _super.prototype.mouseUp.call(this, args);\n        }\n        else if (shapeAnnotationType === 'Image' || shapeAnnotationType === 'SignatureImage') {\n            this.inAction = false;\n        }\n        else if (this.commandHandler && this.commandHandler.selectedItems && this.commandHandler.selectedItems.formFields &&\n            this.commandHandler.selectedItems.formFields.length > 0) {\n            _super.prototype.mouseUp.call(this, args);\n        }\n    };\n    MoveTool.prototype.calculateMouseXDiff = function () {\n        if (this.currentPosition && this.startPosition) {\n            return this.currentPosition.x - this.startPosition.x;\n        }\n        else {\n            return 0;\n        }\n    };\n    MoveTool.prototype.calculateMouseYDiff = function () {\n        if (this.currentPosition && this.startPosition) {\n            return this.currentPosition.y - this.startPosition.y;\n        }\n        else {\n            return 0;\n        }\n    };\n    MoveTool.prototype.calculateMouseActionXDiff = function (args) {\n        var x = this.calculateMouseXDiff() / this.commandHandler.viewerBase.getZoomFactor();\n        // let y: number = this.calculateMouseYDiff() / this.commandHandler.magnification.zoomFactor;\n        if (this.offset) {\n            var requiredX = this.offset.x + x;\n            // let requiredY: number = this.offset.y + y;\n            return requiredX - args.source.wrapper.offsetX;\n            //let diffY: number = requiredY - args.source.wrapper.offsetY;\n        }\n        else {\n            return 0;\n        }\n    };\n    MoveTool.prototype.calculateMouseActionYDiff = function (args) {\n        // let x: number = this.calculateMouseXDiff() / this.commandHandler.magnification.zoomFactor;\n        var y = this.calculateMouseYDiff() / this.commandHandler.viewerBase.getZoomFactor();\n        if (this.offset) {\n            // let requiredX: number = this.offset.x + x;\n            var requiredY = this.offset.y + y;\n            // let diffX: number = requiredX - args.source.wrapper.offsetX;\n            return requiredY - args.source.wrapper.offsetY;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @param {boolean} isStamp - Specified the stamp annotation or not.\n     * @param {boolean} isSkip - Specified the annotation skip or not.\n     * @returns {boolean} - Returns the true or false.\n     */\n    MoveTool.prototype.mouseMove = function (args, isStamp, isSkip) {\n        _super.prototype.mouseMove.call(this, args);\n        if (this.inAction) {\n            this.currentPosition = args.position;\n            this.currentTarget = args.target;\n            var currentSelctor = args.source.annotationSelectorSettings;\n            var x = this.calculateMouseXDiff() / this.commandHandler.viewerBase.getZoomFactor();\n            var y = this.calculateMouseYDiff() / this.commandHandler.viewerBase.getZoomFactor();\n            var requiredX = this.offset.x + x;\n            var requiredY = this.offset.y + y;\n            var diffX = this.calculateMouseActionXDiff(args);\n            var diffY = this.calculateMouseActionYDiff(args);\n            var selectedItem = this.commandHandler.selectedItems.annotations[0];\n            var cobject = void 0;\n            if (!this.helper) {\n                cobject = this.commandHandler.selectedItems.annotations.length > 0 ?\n                    (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.commandHandler.selectedItems.annotations[0]) :\n                    (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.commandHandler.selectedItems.formFields[0]);\n                if (cobject.wrapper) {\n                    diffX = requiredX - cobject.wrapper.offsetX;\n                    diffY = requiredY - cobject.wrapper.offsetY;\n                    cobject.bounds = this.commandHandler.selectedItems.annotations.length > 0 ?\n                        this.commandHandler.selectedItems.annotations[0].wrapper.bounds :\n                        this.commandHandler.selectedItems.formFields[0].wrapper.bounds;\n                }\n                cobject.wrapper = undefined;\n                cobject.id = 'diagram_helper';\n                if (cobject.shapeAnnotationType === 'Stamp') {\n                    cobject.strokeColor = '';\n                    cobject.borderDashArray = '';\n                    cobject.fillColor = 'transparent';\n                    cobject.stampFillColor = 'transparent';\n                    cobject.data = '';\n                }\n                else if (cobject.shapeAnnotationType === 'FreeText') {\n                    cobject.strokeColor = 'blue';\n                    cobject.fillColor = 'transparent';\n                    cobject.thickness = 1;\n                    cobject.opacity = 1;\n                    cobject.dynamicText = '';\n                }\n                else if (cobject.shapeAnnotationType === 'SignatureText') {\n                    cobject.strokeColor = 'red';\n                    cobject.borderDashArray = '5,5';\n                    cobject.fillColor = 'transparent';\n                    cobject.thickness = 2;\n                    cobject.opacity = 1;\n                    cobject.data = '';\n                }\n                else {\n                    cobject.strokeColor = 'red';\n                    cobject.borderDashArray = '5,5';\n                    cobject.fillColor = 'transparent';\n                    cobject.thickness = 2;\n                    cobject.opacity = 1;\n                }\n                if (cobject.enableShapeLabel === true) {\n                    cobject.labelContent = '';\n                }\n                var shapeAnnotationType = cobject.shapeAnnotationType;\n                if (!isStamp && shapeAnnotationType !== 'Image' && shapeAnnotationType !== 'SignatureImage') {\n                    this.helper = cobject = this.commandHandler.add(cobject);\n                }\n                else {\n                    cobject = this.helper = args.source;\n                }\n                if (this.commandHandler.selectedItems.annotations.length > 0) {\n                    this.commandHandler.selectedItems.annotations = [cobject];\n                }\n                else {\n                    this.commandHandler.selectedItems.formFields = [cobject];\n                }\n            }\n            else {\n                diffX = requiredX - this.helper.wrapper.offsetX;\n                diffY = requiredY - this.helper.wrapper.offsetY;\n            }\n            if (this.helper && this.helper.shapeAnnotationType === 'Stamp') {\n                isStamp = true;\n            }\n            if (this.commandHandler.checkBoundaryConstraints(diffX, diffY, this.pdfViewerBase.activeElements.activePageID, this.helper.wrapper.bounds, isStamp, isSkip)) {\n                var shapeAnnotationType = this.helper.shapeAnnotationType;\n                if (this.helper && (shapeAnnotationType === 'Image' || shapeAnnotationType === 'SignatureImage')) {\n                    this.checkisAnnotationMove(args);\n                    var currentSelctor_1 = args.source.annotationSelectorSettings;\n                    this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                    this.commandHandler.select([args.source.id], currentSelctor_1);\n                    this.commandHandler.dragSelectedObjects(diffX, diffY, this.pdfViewerBase.activeElements.activePageID, currentSelctor_1, this.helper);\n                    this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelctor_1);\n                }\n                else {\n                    this.commandHandler.dragSelectedObjects(diffX, diffY, this.pdfViewerBase.activeElements.activePageID, currentSelctor, this.helper);\n                }\n                this.prevNode = this.helper;\n                this.prevPosition = this.currentPosition;\n            }\n            else {\n                this.currentPosition = this.prevPosition;\n            }\n            if (selectedItem && selectedItem.annotName) {\n                this.commandHandler.annotation.triggerAnnotationMove(selectedItem, true);\n            }\n        }\n        return true;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    MoveTool.prototype.mouseLeave = function (args) {\n        var currentSelctor = args.source.annotationSelectorSettings;\n        var requiredX = this.offset.x + this.calculateMouseXDiff();\n        var requiredY = this.offset.y + this.calculateMouseYDiff();\n        var diffX = requiredX - args.source.wrapper.offsetX;\n        var diffY = requiredY - args.source.wrapper.offsetY;\n        this.commandHandler.dragSelectedObjects(diffX, diffY, this.prevPageId, currentSelctor, null);\n        this.commandHandler.renderSelector(this.prevPageId, currentSelctor);\n        _super.prototype.mouseLeave.call(this, args);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    MoveTool.prototype.endAction = function () {\n        _super.prototype.endAction.call(this);\n        this.currentTarget = null;\n        this.prevPosition = null;\n    };\n    MoveTool.prototype.checkisAnnotationMove = function (args) {\n        if (this.commandHandler.selectedItems && this.commandHandler.selectedItems.annotations &&\n            this.commandHandler.selectedItems.annotations.length > 0) {\n            if (this.commandHandler.selectedItems.annotations[0].annotName === args.source.annotName) {\n                this.commandHandler.viewerBase.isAnnotationMouseMove = true;\n            }\n        }\n        else {\n            this.commandHandler.viewerBase.isAnnotationMouseMove = false;\n        }\n        if (this.commandHandler.selectedItems && this.commandHandler.selectedItems.formFields &&\n            this.commandHandler.selectedItems.formFields.length > 0) {\n            if (this.commandHandler.selectedItems.formFields[0].name === args.source.name) {\n                this.commandHandler.viewerBase.isFormFieldMouseMove = true;\n            }\n        }\n        else {\n            this.commandHandler.viewerBase.isFormFieldMouseMove = false;\n        }\n    };\n    return MoveTool;\n}(ToolBase));\n\n/** @hidden */\nvar StampTool = /** @class */ (function (_super) {\n    __extends(StampTool, _super);\n    function StampTool() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    StampTool.prototype.mouseDown = function (args) {\n        _super.prototype.mouseUp.call(this, args);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns the true or false.\n     */\n    StampTool.prototype.mouseMove = function (args) {\n        var newObject;\n        if (!this.inAction) {\n            var pageIndex = this.pdfViewerBase.activeElements.activePageID;\n            this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n            var nodeElement = this.commandHandler.annotation.stampAnnotationModule.moveStampElement(args.position.x, args.position.y, pageIndex);\n            if (nodeElement.shapeAnnotationType === 'SignatureText') {\n                var textWidth = this.getTextWidth(nodeElement.data, nodeElement.fontSize, nodeElement.fontFamily);\n                var widthRatio = 1;\n                if (textWidth > nodeElement.bounds.width) {\n                    widthRatio = nodeElement.bounds.width / textWidth;\n                }\n                nodeElement.fontSize = this.getFontSize(Math.floor((nodeElement.fontSize * widthRatio)));\n                var defaultFontSize = 32; // default font size.\n                nodeElement.bounds.height = nodeElement.fontSize < defaultFontSize ? nodeElement.fontSize * 2 : nodeElement.bounds.height;\n                nodeElement.thickness = 0;\n            }\n            newObject = this.commandHandler.add(nodeElement);\n            args.source = this.commandHandler.annotations[this.commandHandler.annotations.length - 1];\n            args.sourceWrapper = args.source.wrapper;\n            this.inAction = true;\n            var currentSource = args.source;\n            if (currentSource && (currentSource.shapeAnnotationType === 'HandWrittenSignature' || currentSource.shapeAnnotationType === 'SignatureText' || currentSource.shapeAnnotationType === 'SignatureImage')) {\n                this['offset'] = { x: args.source.wrapper.offsetX - (args.source.wrapper.bounds.width / 2), y: args.source.wrapper.offsetY - (args.source.wrapper.bounds.height / 2) };\n            }\n            else {\n                this['offset'] = { x: args.source.wrapper.offsetX, y: args.source.wrapper.offsetY };\n            }\n            this.startPosition = args.position;\n            this.commandHandler.select([newObject.id]);\n        }\n        var currentSelctor = args.source.annotationSelectorSettings;\n        _super.prototype.mouseMove.call(this, args, true, true);\n        this.commandHandler.renderSelector(args.source.pageIndex, currentSelctor);\n        return this.inAction;\n    };\n    StampTool.prototype.getTextWidth = function (text, font, fontFamily) {\n        var canvas = document.createElement('canvas');\n        var context = canvas.getContext('2d');\n        var fontName;\n        if (font) {\n            fontName = font + 'px' + ' ' + fontFamily;\n        }\n        context.font = fontName || getComputedStyle(document.body).font;\n        var textWidth = context.measureText(text).width;\n        this.pdfViewerBase.releaseCanvas(canvas);\n        return textWidth;\n    };\n    /**\n     * @param {number} fontSize - Font size.\n     * @returns {number} - Returns the font size.\n     */\n    StampTool.prototype.getFontSize = function (fontSize) {\n        return (fontSize % 2 === 0) ? fontSize : --fontSize;\n    };\n    return StampTool;\n}(MoveTool));\n\n/**\n * Draws a node that is defined by the user\n *\n * @hidden\n */\nvar InkDrawingTool = /** @class */ (function (_super) {\n    __extends(InkDrawingTool, _super);\n    function InkDrawingTool(commandHandler, base, sourceObject) {\n        var _this = _super.call(this, commandHandler, base) || this;\n        _this.sourceObject = sourceObject;\n        return _this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    InkDrawingTool.prototype.mouseDown = function (args) {\n        this.pdfViewerBase.disableTextSelectionMode();\n        _super.prototype.mouseDown.call(this, args);\n        this.inAction = true;\n        var node = { currentPosition: this.currentPosition, prevPosition: this.prevPosition };\n        this.commandHandler.annotation.inkAnnotationModule.drawInkInCanvas(node, this.pdfViewerBase.activeElements.activePageID);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    InkDrawingTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        if (this.inAction) {\n            var node = { currentPosition: this.currentPosition, prevPosition: this.pdfViewerBase.prevPosition };\n            this.commandHandler.annotation.inkAnnotationModule.drawInkInCanvas(node, this.pdfViewerBase.activeElements.activePageID);\n        }\n        return this.inAction;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true.\n     */\n    InkDrawingTool.prototype.mouseUp = function (args) {\n        this.commandHandler.annotation.inkAnnotationModule.storePathData();\n        return true;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    InkDrawingTool.prototype.mouseLeave = function (args) {\n        //this.mouseUp(args);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    InkDrawingTool.prototype.endAction = function () {\n        _super.prototype.endAction.call(this);\n    };\n    return InkDrawingTool;\n}(ToolBase));\n\n/**\n * Helps to edit the selected connectors\n *\n * @hidden\n */\nvar ConnectTool = /** @class */ (function (_super) {\n    __extends(ConnectTool, _super);\n    function ConnectTool(commandHandler, base, endPoint) {\n        var _this = _super.call(this, commandHandler, base, true) || this;\n        _this.endPoint = endPoint;\n        return _this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    ConnectTool.prototype.mouseDown = function (args) {\n        this.inAction = true;\n        this.undoElement = undefined;\n        _super.prototype.mouseDown.call(this, args);\n        var oldValue;\n        var connectors;\n        if (args.source && args.source.annotations) {\n            oldValue = { x: this.prevPosition.x, y: this.prevPosition.y };\n            connectors = args.source.annotations[0];\n        }\n        this.initialPosition = args.position;\n        this.prevSource = this.commandHandler.selectedItems.annotations[0];\n        var nodeElement = (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(args.source);\n        this.redoElement = {\n            bounds: {\n                x: nodeElement.wrapper.offsetX, y: nodeElement.wrapper.offsetY,\n                width: nodeElement.wrapper.actualSize.width, height: nodeElement.wrapper.actualSize.height\n            }\n        };\n        if ((0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.isLineShapes)(nodeElement)) {\n            this.redoElement.vertexPoints = nodeElement.vertexPoints;\n            this.redoElement.leaderHeight = nodeElement.leaderHeight;\n            if (nodeElement.measureType === 'Distance' || nodeElement.measureType === 'Perimeter' || nodeElement.measureType === 'Area' || nodeElement.measureType === 'Volume') {\n                this.redoElement.notes = nodeElement.notes;\n            }\n        }\n        this.currentPosition = args.position;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    ConnectTool.prototype.mouseUp = function (args) {\n        if (this.commandHandler) {\n            var node = this.commandHandler.selectedItems.annotations[0];\n            var isResized = false;\n            if (node) {\n                var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(node);\n                var annotationMaxHeight = 0;\n                var annotationMaxWidth = 0;\n                var annotationMinHeight = 0;\n                var annotationMinWidth = 0;\n                if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight ||\n                    annotationSettings.maxHeight) {\n                    annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;\n                    annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;\n                    annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;\n                    annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;\n                }\n                if (node.vertexPoints.length > 3) {\n                    var sizeObject = this.commandHandler.viewerBase.checkAnnotationWidth(node.vertexPoints);\n                    var width = sizeObject.width;\n                    var height = sizeObject.height;\n                    if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {\n                        if ((height > annotationMinHeight && height < annotationMaxHeight) ||\n                            (width > annotationMinWidth && width < annotationMaxWidth)) {\n                            this.commandHandler.nodePropertyChange(this.prevSource, { vertexPoints: node.vertexPoints, leaderHeight: node.leaderHeight });\n                        }\n                    }\n                    else {\n                        this.commandHandler.nodePropertyChange(this.prevSource, { vertexPoints: node.vertexPoints, leaderHeight: node.leaderHeight });\n                    }\n                }\n                else {\n                    if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {\n                        if (node.shapeAnnotationType === 'Line' || node.shapeAnnotationType === 'Distance' || node.shapeAnnotationType === 'LineWidthArrowHead') {\n                            var x = 0;\n                            var y = 0;\n                            if (node.vertexPoints[0].x > node.vertexPoints[1].x) {\n                                x = node.vertexPoints[0].x - node.vertexPoints[1].x;\n                            }\n                            else {\n                                x = node.vertexPoints[1].x - node.vertexPoints[0].x;\n                            }\n                            if (node.vertexPoints[0].y > node.vertexPoints[1].y) {\n                                y = node.vertexPoints[0].y - node.vertexPoints[1].y;\n                            }\n                            else {\n                                y = node.vertexPoints[1].y - node.vertexPoints[0].y;\n                            }\n                            var diff = (x > y) ? x : y;\n                            if (diff < (annotationMaxHeight || annotationMaxWidth) && diff > (annotationMinHeight || annotationMinWidth)) {\n                                this.commandHandler.nodePropertyChange(this.prevSource, { vertexPoints: node.vertexPoints,\n                                    leaderHeight: node.leaderHeight });\n                            }\n                        }\n                        else {\n                            this.commandHandler.nodePropertyChange(this.prevSource, { vertexPoints: node.vertexPoints, leaderHeight: node.leaderHeight });\n                        }\n                    }\n                    else {\n                        this.commandHandler.nodePropertyChange(this.prevSource, { vertexPoints: node.vertexPoints, leaderHeight: node.leaderHeight });\n                    }\n                }\n                var currentSelctor = args.source.annotationSelectorSettings;\n                this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                this.commandHandler.select([this.prevSource.id], currentSelctor);\n                this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelctor);\n                var newShapeElementObject = {\n                    bounds: {\n                        x: args.source.wrapper.offsetX, y: args.source.wrapper.offsetY,\n                        width: args.source.wrapper.actualSize.width, height: args.source.wrapper.actualSize.height\n                    }\n                };\n                if (node.measureType === 'Distance' || node.measureType === 'Perimeter' || node.measureType === 'Area' || node.measureType === 'Volume') {\n                    this.commandHandler.annotation.updateCalibrateValues(this.commandHandler.selectedItems.annotations[0]);\n                    newShapeElementObject.notes = args.source.notes;\n                }\n                if ((0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.isLineShapes)(args.source)) {\n                    newShapeElementObject.vertexPoints = args.source.vertexPoints;\n                    newShapeElementObject.leaderHeight = args.source.leaderHeight;\n                }\n                if (this.redoElement.bounds.height !== newShapeElementObject.bounds.height ||\n                    this.redoElement.bounds.width !== newShapeElementObject.bounds.width ||\n                    this.redoElement.bounds.x !== newShapeElementObject.bounds.x || this.redoElement.bounds.y !==\n                    newShapeElementObject.bounds.y) {\n                    isResized = true;\n                }\n                if (isResized) {\n                    this.commandHandler.annotation.addAction(this.pageIndex, null, this.prevSource, 'Resize', '', this.redoElement, newShapeElementObject);\n                }\n            }\n        }\n        _super.prototype.mouseUp.call(this, args);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    ConnectTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        var connector;\n        this.currentPosition = args.position;\n        if (this.currentPosition && this.prevPosition) {\n            var diffX = this.currentPosition.x - this.prevPosition.x;\n            var diffY = this.currentPosition.y - this.prevPosition.y;\n            var newValue = void 0;\n            var oldValue = void 0;\n            if (args.source && args.source.annotations) {\n                newValue = {\n                    x: this.currentPosition.x, y: this.currentPosition.y\n                };\n                oldValue = {\n                    x: this.prevPosition.x, y: this.prevPosition.y\n                };\n                connector = args.source.annotations[0];\n            }\n            if (this.inAction && this.endPoint !== undefined && diffX !== 0 || diffY !== 0) {\n                if (!this.helper) {\n                    var cloneShapebject = (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.commandHandler.selectedItems.annotations[0]);\n                    cloneShapebject.id = 'diagram_helper';\n                    cloneShapebject.strokeColor = 'red';\n                    cloneShapebject.borderDashArray = '5,5';\n                    cloneShapebject.fillColor = 'transparent';\n                    cloneShapebject.thickness = 2;\n                    cloneShapebject.opacity = 1;\n                    if (cloneShapebject.enableShapeLabel === true) {\n                        cloneShapebject.labelContent = '';\n                    }\n                    this.helper = cloneShapebject = this.commandHandler.add(cloneShapebject);\n                    this.commandHandler.selectedItems.annotations = [cloneShapebject];\n                }\n                var currentSelctor = args.source.annotationSelectorSettings;\n                this.blocked = !this.commandHandler.dragConnectorEnds(this.endPoint, this.helper, this.currentPosition, this.selectedSegment, args.target, null, currentSelctor);\n                this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelctor);\n            }\n        }\n        this.prevPosition = this.currentPosition;\n        return !this.blocked;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    ConnectTool.prototype.mouseLeave = function (args) {\n        this.mouseUp(args);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    ConnectTool.prototype.endAction = function () {\n        _super.prototype.endAction.call(this);\n        this.prevPosition = null;\n        this.endPoint = null;\n    };\n    return ConnectTool;\n}(ToolBase));\n\n/**\n * Scales the selected objects\n *\n * @hidden\n */\nvar ResizeTool = /** @class */ (function (_super) {\n    __extends(ResizeTool, _super);\n    function ResizeTool(commandHandler, base, corner) {\n        var _this = _super.call(this, commandHandler, base, true) || this;\n        /**   @private  */\n        _this.initialBounds = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Rect();\n        _this.corner = corner;\n        return _this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void} - Returns true or false.\n     */\n    ResizeTool.prototype.mouseDown = function (args) {\n        _super.prototype.mouseDown.call(this, args);\n        this.initialBounds.x = args.source.wrapper.offsetX;\n        this.initialBounds.y = args.source.wrapper.offsetY;\n        this.initialBounds.height = args.source.wrapper.actualSize.height;\n        this.initialBounds.width = args.source.wrapper.actualSize.width;\n        this.initialPosition = args.position;\n        var node = (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(args.source);\n        this.redoElement = {\n            bounds: {\n                x: node.wrapper.offsetX, y: node.wrapper.offsetY,\n                width: node.wrapper.actualSize.width, height: node.wrapper.actualSize.height\n            }\n        };\n        if ((0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.isLineShapes)(node)) {\n            this.redoElement.vertexPoints = node.vertexPoints;\n            this.redoElement.leaderHeight = node.leaderHeight;\n        }\n        if (node.measureType === 'Radius') {\n            this.redoElement.notes = node.notes;\n        }\n        this.prevSource = this.commandHandler.selectedItems.annotations.length > 0 ?\n            this.commandHandler.selectedItems.annotations[0] : this.commandHandler.selectedItems.formFields[0];\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @param {boolean} isPreventHistory - Specified the prevent history value.\n     * @returns {boolean} - Returns true or false.\n     */\n    ResizeTool.prototype.mouseUp = function (args, isPreventHistory) {\n        var object = args.source;\n        var oldObject = (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(args.source);\n        var isResized = false;\n        if (this.commandHandler && this.prevSource) {\n            this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n            this.commandHandler.viewerBase.isAnnotationSelect = true;\n            this.commandHandler.viewerBase.isFormFieldSelect = true;\n            this.commandHandler.select([this.prevSource.id], this.prevSource.annotationSelectorSettings);\n            var deltaValues = this.updateSize(this.prevSource, this.currentPosition, this.initialPosition, this.corner, this.initialBounds, null, true);\n            this.blocked = this.scaleObjects(deltaValues.width, deltaValues.height, this.corner, this.currentPosition, this.initialPosition, this.prevSource, args.info.ctrlKey);\n            if (this.commandHandler.selectedItems && this.commandHandler.selectedItems.annotations &&\n                this.commandHandler.selectedItems.annotations[0] && this.commandHandler.selectedItems.annotations[0].shapeAnnotationType === 'Stamp') {\n                if (this.commandHandler.stampSettings.minHeight || this.commandHandler.stampSettings.minWidth) {\n                    this.commandHandler.select([this.prevSource.id], this.prevSource.annotationSelectorSettings);\n                }\n            }\n            if (this.commandHandler.selectedItems.formFields.length > 0 && (this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'Textbox' || this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'Checkbox'\n                || this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'RadioButton' || this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'InitialField' || this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'SignatureField'\n                || this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'DropdownList' || this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'ListBox' || this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'PasswordField')) {\n                if (this.commandHandler.selectedItems.formFields[0].formFieldAnnotationType === 'SignatureField') {\n                    this.commandHandler.selectedItems.formFields[0].signatureIndicatorSettings = this.commandHandler.selectedItems.formFields[0].signatureIndicatorSettings ? this.commandHandler.selectedItems.formFields[0].signatureIndicatorSettings : { opacity: 1, backgroundColor: 'rgba(255, 228, 133, 0.35)', width: 19, height: 10, fontSize: 10, text: null, color: 'black' };\n                }\n                this.commandHandler.formDesignerModule.updateHTMLElement(this.commandHandler.selectedItems.formFields[0]);\n            }\n            this.commandHandler.renderSelector(this.prevPageId, this.prevSource.annotationSelectorSettings);\n            if (this.commandHandler.annotation && args.source.wrapper) {\n                var newObject = {\n                    bounds: {\n                        x: args.source.wrapper.offsetX, y: args.source.wrapper.offsetY,\n                        width: args.source.wrapper.actualSize.width, height: args.source.wrapper.actualSize.height\n                    }\n                };\n                if ((0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.isLineShapes)(args.source)) {\n                    newObject.vertexPoints = args.source.vertexPoints;\n                    newObject.leaderHeight = args.source.leaderHeight;\n                }\n                if (this.redoElement.bounds.height !== newObject.bounds.height ||\n                    this.redoElement.bounds.width !== newObject.bounds.width || this.redoElement.bounds.x !==\n                    newObject.bounds.x || this.redoElement.bounds.y !== newObject.bounds.y) {\n                    isResized = true;\n                }\n                if (this.prevSource.measureType === 'Radius' && isResized) {\n                    newObject.notes = args.source.notes;\n                    this.commandHandler.annotation.updateCalibrateValues(this.prevSource);\n                }\n                if (this.prevSource.shapeAnnotationType === 'SignatureText') {\n                    var oldObjectWidth = (oldObject.bounds && oldObject.bounds.width) ? oldObject.bounds.width : oldObject.width;\n                    var boundsRatio = newObject.bounds.width / oldObjectWidth;\n                    newObject.fontSize = this.prevSource.wrapper.children[1].style.fontSize * boundsRatio;\n                    if (args.target != null) {\n                        args.target.fontSize = newObject.fontSize;\n                        args.target.wrapper.children[1].style.fontSize = newObject.fontSize;\n                        args.target.wrapper.children[1].horizontalAlignment = 'Center';\n                        args.target.wrapper.children[1].verticalAlignment = 'Center';\n                        args.target.wrapper.children[1].setOffsetWithRespectToBounds(0, 0, 'Absolute');\n                        this.commandHandler.selectedItems.annotations[0].wrapper.children[1].style.fontSize = newObject.fontSize;\n                        this.commandHandler.selectedItems.annotations[0].wrapper.children[1].horizontalAlignment = 'Center';\n                        this.commandHandler.selectedItems.annotations[0].wrapper.children[1].verticalAlignment = 'Center';\n                        this.commandHandler.selectedItems.annotations[0].wrapper.children[1].setOffsetWithRespectToBounds(0, 0, 'Absolute');\n                        this.commandHandler.selectedItems.annotations[0].fontSize = newObject.fontSize;\n                    }\n                }\n                if ((this.prevSource.shapeAnnotationType === 'SignatureText') && this.commandHandler.selectedItems.annotations && this.commandHandler.selectedItems.annotations.length > 0) {\n                    this.commandHandler.nodePropertyChange(this.commandHandler.selectedItems.annotations[0], { fontSize: newObject.fontSize });\n                }\n                if (isResized) {\n                    this.commandHandler.annotation.addAction(this.pageIndex, null, this.prevSource, 'Resize', '', this.redoElement, newObject);\n                }\n            }\n            if (args.target && args.target.formFieldAnnotationType) {\n                var node = args.target;\n                var field = { id: args.source.id, value: node.value, fontFamily: node.fontFamily,\n                    fontSize: node.fontSize, fontStyle: node.fontStyle,\n                    color: node.color, backgroundColor: node.backgroundColor,\n                    alignment: node.alignment, isReadonly: node.isReadonly,\n                    visibility: node.visibility,\n                    maxLength: node.maxLength, isRequired: node.isRequired, isPrint: node.isPrint,\n                    rotation: node.rotateAngle, tooltip: node.tooltip,\n                    options: node.options, isChecked: node.isChecked, isSelected: node.isSelected };\n                var currentPosition = { X: args.source.wrapper.offsetX, Y: args.source.wrapper.offsetY,\n                    Width: args.source.wrapper.actualSize.width, Height: args.source.wrapper.actualSize.height };\n                var previousPosition = { X: this.initialBounds.x, Y: this.initialBounds.y,\n                    Width: this.initialBounds.width, Height: this.initialBounds.height };\n                this.commandHandler.fireFormFieldResizeEvent('formFieldResize', field, node.pageIndex, previousPosition, currentPosition);\n            }\n            if (this.commandHandler.annotation && this.commandHandler.annotation.stampAnnotationModule) {\n                this.commandHandler.annotation.stampAnnotationModule.updateSessionStorage(args.source, this.prevSource.id, 'Resize');\n            }\n        }\n        _super.prototype.mouseUp.call(this, args);\n        return !this.blocked;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    ResizeTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        var object = args.source;\n        this.currentPosition = args.position;\n        var x = this.currentPosition.x - this.startPosition.x;\n        var y = this.currentPosition.y - this.startPosition.y;\n        x = x / this.commandHandler.viewerBase.getZoomFactor();\n        y = y / this.commandHandler.viewerBase.getZoomFactor();\n        var annotationElement = args.source;\n        var size = this.getPoints(x, y);\n        var width = annotationElement.width + size.x;\n        var height = annotationElement.height + size.y;\n        var obj = object;\n        if (object && object.annotations) {\n            obj = object.annotations[0];\n        }\n        var annotationSettings = this.commandHandler.annotationModule ?\n            this.commandHandler.annotationModule.findAnnotationSettings(obj) : {};\n        var annotationMaxHeight = 0;\n        var annotationMaxWidth = 0;\n        var annotationMinHeight = 0;\n        var annotationMinWidth = 0;\n        if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {\n            annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;\n            annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;\n            annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;\n            annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;\n        }\n        if (annotationMinHeight || annotationMinWidth || annotationMaxHeight || annotationMaxWidth) {\n            if (height < annotationMinHeight) {\n                y = annotationMinHeight - annotationElement.height;\n            }\n            else if (height > annotationMaxHeight) {\n                y = annotationMaxHeight - annotationElement.height;\n            }\n            if (width < annotationMinWidth) {\n                x = annotationMinWidth - annotationElement.width;\n            }\n            else if (width > annotationMaxWidth) {\n                x = annotationMaxWidth - annotationElement.width;\n            }\n        }\n        var changes = { x: x, y: y };\n        if (this.currentElement.wrapper) {\n            changes = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.rotatePoint)(-this.currentElement.wrapper.rotateAngle, undefined, undefined, changes);\n        }\n        changes = this.getChanges(changes);\n        this.commandHandler.renderSelector(this.prevPageId, this.prevSource.annotationSelectorSettings);\n        if (!this.helper) {\n            var cobject = this.commandHandler.selectedItems.annotations.length > 0 ?\n                (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.commandHandler.selectedItems.annotations[0]) :\n                (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.commandHandler.selectedItems.formFields[0]);\n            cobject.id = 'diagram_helper';\n            if (cobject.shapeAnnotationType === 'Stamp') {\n                cobject.strokeColor = '';\n                cobject.borderDashArray = '';\n                cobject.fillColor = 'transparent';\n                cobject.stampFillColor = 'transparent';\n                cobject.data = '';\n            }\n            else if (cobject.shapeAnnotationType === 'FreeText') {\n                cobject.strokeColor = 'blue';\n                cobject.fillColor = 'transparent';\n                cobject.thickness = 1;\n                cobject.opacity = 1;\n                cobject.dynamicText = '';\n            }\n            else {\n                cobject.bounds = this.commandHandler.selectedItems.annotations.length > 0 ?\n                    this.commandHandler.selectedItems.annotations[0].wrapper.bounds :\n                    this.commandHandler.selectedItems.formFields[0].wrapper.bounds;\n                cobject.strokeColor = 'red';\n                cobject.borderDashArray = '5,5';\n                cobject.fillColor = 'transparent';\n                cobject.thickness = 2;\n                cobject.opacity = 1;\n            }\n            if (cobject.enableShapeLabel === true) {\n                cobject.labelContent = '';\n            }\n            if (cobject.shapeAnnotationType === 'SignatureText') {\n                cobject.fillColor = 'transparent';\n                cobject.thickness = 1;\n                cobject.opacity = 1;\n                cobject.data = '';\n            }\n            this.helper = cobject = this.commandHandler.add(cobject);\n            if (this.commandHandler.selectedItems.annotations.length > 0) {\n                this.commandHandler.selectedItems.annotations = [cobject];\n            }\n            else {\n                this.commandHandler.selectedItems.formFields = [cobject];\n            }\n        }\n        var deltaValues = this.updateSize(this.helper, this.startPosition, this.currentPosition, this.corner, this.initialBounds);\n        this.blocked = !(this.scaleObjects(deltaValues.width, deltaValues.height, this.corner, this.startPosition, this.currentPosition, this.helper, args.info.ctrlKey));\n        this.prevPosition = this.currentPosition;\n        return !this.blocked;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    ResizeTool.prototype.mouseLeave = function (args) {\n        this.mouseUp(args);\n    };\n    ResizeTool.prototype.getTooltipContent = function (pdfAnnotationBaseModel) {\n        return 'W:' + Math.round(pdfAnnotationBaseModel.wrapper.bounds.width) + ' ' + 'H:' + Math.round(pdfAnnotationBaseModel.wrapper.bounds.height);\n    };\n    ResizeTool.prototype.getChanges = function (change) {\n        switch (this.corner) {\n            case 'ResizeEast':\n                return { x: change.x, y: 0 };\n            case 'ResizeSouthEast':\n                return change;\n            case 'ResizeSouth':\n                return { x: 0, y: change.y };\n            case 'ResizeNorth':\n                return { x: 0, y: -change.y };\n            case 'ResizeNorthEast':\n                return { x: change.x, y: -change.y };\n            case 'ResizeNorthWest':\n                return { x: -change.x, y: -change.y };\n            case 'ResizeWest':\n                return { x: -change.x, y: 0 };\n            case 'ResizeSouthWest':\n                return { x: -change.x, y: change.y };\n        }\n        return change;\n    };\n    ResizeTool.prototype.getPoints = function (x, y) {\n        switch (this.corner) {\n            case 'ResizeEast':\n                return { x: x, y: 0 };\n            case 'ResizeSouthEast':\n                return { x: x, y: y };\n            case 'ResizeSouth':\n                return { x: 0, y: y };\n            case 'ResizeNorth':\n                return { x: 0, y: -y };\n            case 'ResizeNorthEast':\n                return { x: x, y: -y };\n            case 'ResizeNorthWest':\n                return { x: -x, y: -y };\n            case 'ResizeWest':\n                return { x: -x, y: 0 };\n            case 'ResizeSouthWest':\n                return { x: -x, y: y };\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Updates the size with delta width and delta height using scaling.\n     * Aspect ratio used to resize the width or height based on resizing the height or width.\n     *\n     * @param {number} deltaWidth - Specified the delta width.\n     * @param {number} deltaHeight - Specified the delta height.\n     * @param {string} corner - Specified the corner value.\n     * @param {PointModel} startPoint - Specified the start point of the annotation.\n     * @param {PointModel} endPoint - Specified the end point of the annotation.\n     * @param {SelectorModel | PdfAnnotationBaseModel} source - Specified the annotation object.\n     * @param {boolean} isCtrlKeyPressed - becomes true when ctrl Key is pressed.\n     * @returns {boolean} - Returns true or false.\n     */\n    ResizeTool.prototype.scaleObjects = function (deltaWidth, deltaHeight, corner, startPoint, endPoint, source, isCtrlKeyPressed) {\n        var annotationSettings = this.commandHandler.annotationModule ?\n            this.commandHandler.annotationModule.findAnnotationSettings(source) : {};\n        var annotationMaxHeight = 0;\n        var annotationMaxWidth = 0;\n        var annotationMinHeight = 0;\n        var annotationMinWidth = 0;\n        var x = this.currentPosition.x - this.startPosition.x;\n        var y = this.currentPosition.y - this.startPosition.y;\n        x = x / this.commandHandler.viewerBase.getZoomFactor();\n        y = y / this.commandHandler.viewerBase.getZoomFactor();\n        var annotationElement = source;\n        var size = this.getPoints(x, y);\n        var width = annotationElement.bounds.width + size.x;\n        var height = annotationElement.bounds.height + size.y;\n        if (annotationSettings.minWidth || annotationSettings.maxWidth || annotationSettings.minHeight || annotationSettings.maxHeight) {\n            annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;\n            annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;\n            annotationMinHeight = annotationSettings.minHeight ? annotationSettings.minHeight : 0;\n            annotationMinWidth = annotationSettings.minWidth ? annotationSettings.minWidth : 0;\n        }\n        if (source instanceof _selector__WEBPACK_IMPORTED_MODULE_1__.Selector && source.annotations.length === 1 &&\n            (source.annotations[0].shapeAnnotationType === 'Perimeter' || source.annotations[0].shapeAnnotationType === 'Radius' || source.shapeAnnotationType === 'Stamp')) {\n            if (!(deltaHeight === 1 && deltaWidth === 1)) {\n                deltaHeight = deltaWidth = Math.max(deltaHeight === 1 ? 0 : deltaHeight, deltaWidth === 1 ? 0 : deltaWidth);\n            }\n            else if (startPoint !== endPoint) {\n                deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);\n            }\n            else {\n                deltaHeight = deltaWidth = 0;\n            }\n        }\n        else if (source.shapeAnnotationType === 'Image' || (source.shapeAnnotationType === 'HandWrittenSignature' || source.shapeAnnotationType === 'SignatureText' || source.shapeAnnotationType === 'SignatureImage')) {\n            if (!(deltaHeight === 1 && deltaWidth === 1)) {\n                if (isCtrlKeyPressed) {\n                    if (width >= annotationMaxWidth && height < annotationMaxHeight) {\n                        deltaHeight = Math.max(deltaHeight, deltaWidth);\n                    }\n                    if (height >= annotationMaxHeight && width < annotationMaxWidth) {\n                        deltaWidth = Math.max(deltaHeight, deltaWidth);\n                    }\n                    if (width < annotationMaxWidth && height < annotationMaxHeight) {\n                        deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);\n                    }\n                }\n            }\n            if (!isCtrlKeyPressed) {\n                deltaHeight = deltaWidth = Math.max(deltaHeight, deltaWidth);\n            }\n        }\n        else {\n            if (source.shapeAnnotationType === 'Perimeter' || source.shapeAnnotationType === 'Radius'\n                || source.shapeAnnotationType === 'Stamp') {\n                if (source.shapeAnnotationType === 'Stamp') {\n                    if (!annotationMaxHeight && !deltaHeight) {\n                        deltaHeight = Math.max(deltaHeight === 1 ? 0 : deltaHeight);\n                    }\n                    if (!annotationMaxWidth && !deltaWidth) {\n                        deltaWidth = Math.max(deltaWidth === 1 ? 0 : deltaWidth);\n                    }\n                }\n                else {\n                    if (!annotationMaxHeight || !annotationMaxWidth) {\n                        if (!(deltaHeight === 1 && deltaWidth === 1)) {\n                            deltaHeight = deltaWidth = Math.max(deltaHeight === 1 ? 0 : deltaHeight, deltaWidth === 1 ? 0 : deltaWidth);\n                        }\n                    }\n                }\n            }\n        }\n        this.blocked = this.commandHandler.scaleSelectedItems(deltaWidth, deltaHeight, this.getPivot(this.corner));\n        return this.blocked;\n    };\n    return ResizeTool;\n}(ToolBase));\n\n/**\n * Draws a node that is defined by the user\n *\n * @hidden\n */\nvar NodeDrawingTool = /** @class */ (function (_super) {\n    __extends(NodeDrawingTool, _super);\n    function NodeDrawingTool(commandHandler, base, sourceObject) {\n        var _this = _super.call(this, commandHandler, base) || this;\n        _this.sourceObject = sourceObject;\n        return _this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    NodeDrawingTool.prototype.mouseDown = function (args) {\n        if (!isNaN(this.pdfViewerBase.activeElements.activePageID) && event.target.className !== 'e-pv-page-container') {\n            _super.prototype.mouseDown.call(this, args);\n            this.inAction = true;\n            var node = { bounds: { x: 100, y: 300, width: 100, height: 100 }, pageIndex: 0, strokeColor: 'red', thickness: 3 };\n            node.id = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.randomId)();\n            this.sourceObject.pageIndex = node.pageIndex = this.pdfViewerBase.activeElements.activePageID || 0;\n            this.sourceObject.enableShapeLabel = this.commandHandler.enableShapeLabel;\n            this.pdfViewerBase.updateFreeTextProperties(this.sourceObject);\n            this.isFormDesign = false;\n            var formFieldElement = document.getElementById('FormField_helper_html_element');\n            if (formFieldElement) {\n                formFieldElement.remove();\n            }\n            this.commandHandler.drawingObject = this.drawingObject =\n                this.commandHandler.add(this.sourceObject || node);\n            if (this.drawingObject.formFieldAnnotationType === 'Textbox' || this.drawingObject.formFieldAnnotationType === 'SignatureField' || this.drawingObject.formFieldAnnotationType === 'InitialField' ||\n                this.drawingObject.formFieldAnnotationType === 'Checkbox' || this.drawingObject.formFieldAnnotationType === 'ListBox' || this.drawingObject.formFieldAnnotationType === 'RadioButton' ||\n                this.drawingObject.formFieldAnnotationType === 'DropdownList' || this.drawingObject.formFieldAnnotationType === 'PasswordField') {\n                this.inAction = false;\n                this.drawingObject.pageNumber = this.pdfViewerBase.getActivePage(true);\n                var bounds = this.commandHandler.formDesignerModule.\n                    updateFormFieldInitialSize(this.drawingObject.wrapper.children[0], this.drawingObject.formFieldAnnotationType);\n                var pageIndex = this.drawingObject.pageIndex;\n                var page = this.pdfViewerBase.getElement('_pageDiv_' + pageIndex);\n                var pageWidth = page.clientWidth - bounds.width;\n                var pageHeight = page.clientHeight - bounds.height;\n                var left = page.offsetLeft;\n                var offsetX = void 0;\n                if (this.currentPosition.y >= pageHeight && event.target && event.target.parentElement && event.target.parentElement.classList.contains('foreign-object') && event.path) {\n                    var targetParentRect = event.path[3].getBoundingClientRect();\n                    offsetX = event.clientX - targetParentRect.left;\n                }\n                else if ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(event.path) && (this.drawingObject.formFieldAnnotationType === 'SignatureField' || this.drawingObject.formFieldAnnotationType === 'InitialField')) {\n                    offsetX = this.currentPosition.x;\n                }\n                else {\n                    offsetX = this.currentPosition.x - left;\n                }\n                var rect = void 0;\n                if (this.currentPosition.x >= pageWidth && this.currentPosition.y >= pageHeight) {\n                    rect = { x: pageWidth, y: pageHeight, width: this.drawingObject.wrapper.children[0].width,\n                        height: this.drawingObject.wrapper.children[0].height };\n                }\n                else if (this.currentPosition.x >= pageWidth) {\n                    rect = { x: pageWidth, y: this.currentPosition.y, width: this.drawingObject.wrapper.children[0].width,\n                        height: this.drawingObject.wrapper.children[0].height };\n                }\n                else if (this.currentPosition.y >= pageHeight) {\n                    rect = { x: offsetX, y: pageHeight, width: this.drawingObject.wrapper.children[0].width,\n                        height: this.drawingObject.wrapper.children[0].height };\n                }\n                else {\n                    rect = { x: this.currentPosition.x, y: this.currentPosition.y, width: this.drawingObject.wrapper.children[0].width,\n                        height: this.drawingObject.wrapper.children[0].height };\n                }\n                this.updateNodeDimension(this.drawingObject, rect);\n                this.drawingObject.bounds.x = this.drawingObject.bounds.x - (this.drawingObject.bounds.width / 2);\n                this.drawingObject.bounds.y = this.drawingObject.bounds.y - (this.drawingObject.bounds.height / 2);\n                this.commandHandler.formFieldCollection.push(this.drawingObject);\n                var drawingObject = this.drawingObject;\n                var formField = {\n                    id: drawingObject.id, name: drawingObject.name, value: drawingObject.value,\n                    type: drawingObject.formFieldAnnotationType, isReadOnly: drawingObject.isReadonly,\n                    fontFamily: drawingObject.fontFamily,\n                    fontSize: drawingObject.fontSize, fontStyle: drawingObject.fontStyle,\n                    color: drawingObject.color, backgroundColor: drawingObject.backgroundColor,\n                    alignment: drawingObject.alignment, visibility: drawingObject.visibility,\n                    maxLength: drawingObject.maxLength, isRequired: drawingObject.isRequired,\n                    isPrint: drawingObject.isPrint, isSelected: drawingObject.isSelected, isChecked: drawingObject.isChecked,\n                    tooltip: drawingObject.tooltip, bounds: drawingObject.bounds,\n                    thickness: drawingObject.thickness, borderColor: drawingObject.borderColor,\n                    signatureIndicatorSettings: drawingObject.signatureIndicatorSettings, pageIndex: drawingObject.pageIndex,\n                    pageNumber: drawingObject.pageNumber, isMultiline: drawingObject.isMultiline,\n                    insertSpaces: drawingObject.insertSpaces, isTransparent: drawingObject.isTransparent,\n                    rotateAngle: drawingObject.rotateAngle,\n                    selectedIndex: drawingObject.selectedIndex, options: drawingObject.options ? drawingObject.options : [],\n                    signatureType: drawingObject.signatureType, zIndex: drawingObject.zIndex, customData: drawingObject.customData ? drawingObject.customData : ''\n                };\n                this.commandHandler.formFieldCollections.push(formField);\n                this.commandHandler.formDesignerModule.drawHTMLContent(this.drawingObject.formFieldAnnotationType, this.drawingObject.wrapper.children[0], this.drawingObject, this.drawingObject.pageIndex, this.commandHandler);\n                this.commandHandler.select([this.commandHandler.drawingObject.id], this.commandHandler.annotationSelectorSettings);\n                if (this.commandHandler.annotation) {\n                    this.commandHandler.annotation.addAction(this.pdfViewerBase.getActivePage(true), null, this.drawingObject, 'Addition', '', this.drawingObject, this.drawingObject);\n                }\n                this.endAction();\n                this.pdfViewerBase.tool = null;\n                this.pdfViewerBase.action = 'Select';\n                this.drawingObject = null;\n                this.pdfViewerBase.isMouseDown = false;\n                this.pdfViewerBase.pdfViewer.drawingObject = null;\n                this.isFormDesign = true;\n            }\n        }\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    NodeDrawingTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        if (this.inAction && _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.equals(this.currentPosition, this.prevPosition) === false) {\n            this.dragging = true;\n            var rect = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Rect.toBounds([this.prevPosition, this.currentPosition]);\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(this.drawingObject)) {\n                this.updateNodeDimension(this.drawingObject, rect);\n                if (this.drawingObject.shapeAnnotationType === 'Radius') {\n                    this.updateRadiusLinePosition(this.drawingObject.wrapper.children[1], this.drawingObject);\n                }\n            }\n        }\n        return true;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    NodeDrawingTool.prototype.mouseUp = function (args) {\n        if (this.drawingObject && this.dragging) {\n            this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(args.source) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(args.source.annotationSelectorSettings)) {\n                this.commandHandler.select([this.drawingObject.id], args.source.annotationSelectorSettings);\n            }\n            var drawnAnnotation = this.commandHandler.selectedItems.annotations[0];\n            if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(drawnAnnotation) && !(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(drawnAnnotation.wrapper)) {\n                this.commandHandler.nodePropertyChange(drawnAnnotation, { bounds: { x: drawnAnnotation.wrapper.offsetX,\n                        y: drawnAnnotation.wrapper.offsetY } });\n                this.commandHandler.annotation.updateCalibrateValues(this.drawingObject, true);\n                if (this.commandHandler && !this.isFormDesign) {\n                    this.commandHandler.annotation.addAction(this.pageIndex, null, this.drawingObject, 'Addition', '', this.drawingObject, this.drawingObject);\n                }\n                this.dragging = false;\n                _super.prototype.mouseUp.call(this, args);\n                this.inAction = false;\n            }\n        }\n        else {\n            _super.prototype.mouseUp.call(this, args);\n        }\n        this.drawingObject = null;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    NodeDrawingTool.prototype.endAction = function () {\n        _super.prototype.endAction.call(this);\n    };\n    /**\n     * @private\n     * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n     * @param {Rect} rect - Specified the annotation rect element.\n     * @returns {void}\n     */\n    NodeDrawingTool.prototype.updateNodeDimension = function (obj, rect) {\n        var zoom = this.commandHandler.viewerBase.getZoomFactor();\n        if (!(0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(obj)) {\n            obj.bounds.x = (rect.x / zoom) + rect.width / zoom;\n            obj.bounds.y = (rect.y / zoom) + rect.height / zoom;\n            obj.bounds.width = rect.width / zoom;\n            obj.bounds.height = rect.height / zoom;\n            var annotationSettings = this.commandHandler.annotationModule ?\n                this.commandHandler.annotationModule.findAnnotationSettings(obj) : {};\n            var annotationMaxHeight = 0;\n            var annotationMaxWidth = 0;\n            if (annotationSettings.maxWidth || annotationSettings.maxHeight) {\n                annotationMaxHeight = annotationSettings.maxHeight ? annotationSettings.maxHeight : 2000;\n                annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;\n                if (obj.bounds.width > annotationMaxWidth) {\n                    obj.bounds.width = annotationMaxWidth;\n                }\n                if (obj.bounds.height > annotationMaxHeight) {\n                    obj.bounds.height = annotationMaxHeight;\n                }\n                if (obj.bounds.height <= annotationMaxHeight && obj.bounds.width <= annotationMaxWidth) {\n                    this.commandHandler.nodePropertyChange(obj, { bounds: obj.bounds });\n                }\n            }\n            else {\n                this.commandHandler.nodePropertyChange(obj, { bounds: obj.bounds });\n            }\n        }\n    };\n    /**\n     * @private\n     * @param {DrawingElement} obj - Specified the drawing element.\n     * @param {PdfAnnotationBaseModel} node - Specified the annotation object.\n     * @returns {void}\n     */\n    NodeDrawingTool.prototype.updateRadiusLinePosition = function (obj, node) {\n        var trasPoint = { x: node.bounds.x + (node.bounds.width / 4), y: node.bounds.y };\n        var center = { x: (node.bounds.x + (node.bounds.width / 2)), y: (node.bounds.y + (node.bounds.height / 2)) };\n        var matrix = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.identityMatrix)();\n        (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.rotateMatrix)(matrix, node.rotateAngle, center.x, center.y);\n        var rotatedPoint = (0,_syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.transformPointByMatrix)(matrix, trasPoint);\n        var newPoint1 = { x: rotatedPoint.x, y: rotatedPoint.y };\n        obj.offsetX = newPoint1.x;\n        obj.offsetY = newPoint1.y;\n        obj.width = node.bounds.width / 2;\n        var annotationSettings = this.commandHandler.annotationModule.findAnnotationSettings(node);\n        var annotationMaxWidth = 0;\n        if (annotationSettings.maxWidth) {\n            annotationMaxWidth = annotationSettings.maxWidth ? annotationSettings.maxWidth : 2000;\n            if (node.bounds.width > annotationMaxWidth) {\n                node.bounds.width = annotationMaxWidth;\n                obj.width = node.bounds.width / 2;\n            }\n        }\n        this.commandHandler.renderDrawing(undefined, node.pageIndex);\n    };\n    return NodeDrawingTool;\n}(ToolBase));\n\n/**\n * Draws a Polygon shape node dynamically using polygon Tool\n *\n * @hidden\n */\nvar PolygonDrawingTool = /** @class */ (function (_super) {\n    __extends(PolygonDrawingTool, _super);\n    function PolygonDrawingTool(commandHandler, base, action) {\n        var _this = _super.call(this, commandHandler, base) || this;\n        _this.action = action;\n        return _this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    PolygonDrawingTool.prototype.mouseDown = function (args) {\n        _super.prototype.mouseDown.call(this, args);\n        this.inAction = true;\n        if (!this.drawingObject) {\n            this.startPoint = { x: this.startPosition.x, y: this.startPosition.y };\n            var nodeAnnotElement = {\n                bounds: { x: this.currentPosition.x, y: this.currentPosition.y, width: 5, height: 5 },\n                vertexPoints: [{ x: this.startPoint.x / this.pdfViewerBase.getZoomFactor(),\n                        y: this.startPoint.y / this.pdfViewerBase.getZoomFactor() },\n                    { x: this.currentPosition.x / this.pdfViewerBase.getZoomFactor(),\n                        y: this.currentPosition.y / this.pdfViewerBase.getZoomFactor() }],\n                shapeAnnotationType: 'Line', fillColor: this.commandHandler.drawingObject.fillColor,\n                strokeColor: this.commandHandler.drawingObject.strokeColor, pageIndex: this.pdfViewerBase.activeElements.activePageID,\n                notes: this.commandHandler.drawingObject.notes, thickness: this.commandHandler.drawingObject.thickness,\n                author: this.commandHandler.drawingObject.author,\n                subject: this.commandHandler.drawingObject.subject, borderDashArray: this.commandHandler.drawingObject.borderDashArray,\n                modifiedDate: this.commandHandler.drawingObject.modifiedDate, borderStyle: this.commandHandler.drawingObject.borderStyle,\n                measureType: this.commandHandler.drawingObject.measureType, enableShapeLabel: this.commandHandler.enableShapeLabel,\n                opacity: this.commandHandler.drawingObject.opacity\n            };\n            this.pdfViewerBase.updateFreeTextProperties(nodeAnnotElement);\n            this.drawingObject = this.commandHandler.add(nodeAnnotElement);\n        }\n        else {\n            var pt = void 0;\n            var obj = (this.drawingObject);\n            pt = obj.vertexPoints[obj.vertexPoints.length - 1];\n            pt = { x: pt.x, y: pt.y };\n            var lastPoint = this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1];\n            if (!(lastPoint.x === pt.x && lastPoint.x === pt.y)) {\n                this.drawingObject.vertexPoints.push(pt);\n            }\n            this.commandHandler.nodePropertyChange(obj, { vertexPoints: obj.vertexPoints });\n        }\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    PolygonDrawingTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        if (this.inAction && _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.equals(this.currentPosition, this.prevPosition) === false) {\n            this.dragging = true;\n            var obj = (this.drawingObject);\n            if (this.drawingObject && this.currentPosition) {\n                obj.vertexPoints[obj.vertexPoints.length - 1].x = this.currentPosition.x / this.pdfViewerBase.getZoomFactor();\n                obj.vertexPoints[obj.vertexPoints.length - 1].y = this.currentPosition.y / this.pdfViewerBase.getZoomFactor();\n                this.commandHandler.nodePropertyChange(obj, { vertexPoints: obj.vertexPoints });\n            }\n            if (obj.measureType === 'Perimeter') {\n                (0,_connector_util__WEBPACK_IMPORTED_MODULE_5__.updatePerimeterLabel)(obj, obj.vertexPoints, this.commandHandler.annotation.measureAnnotationModule);\n            }\n        }\n        return true;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @param {boolean} isDoubleClineck - Specified the double click event or not.\n     * @param {boolean} isMouseLeave - Specified the mouse leave event or not.\n     * @returns {void}\n     */\n    PolygonDrawingTool.prototype.mouseUp = function (args, isDoubleClineck, isMouseLeave) {\n        var needToDrawPolygon = false;\n        _super.prototype.mouseMove.call(this, args);\n        var currentSelector;\n        if (args.source && args.annotationSelectorSettings !== null) {\n            currentSelector = args.source.annotationSelectorSettings;\n        }\n        else {\n            currentSelector = '';\n        }\n        if (this.drawingObject && this.drawingObject.vertexPoints.length === 2 && isDoubleClineck && isMouseLeave) {\n            this.commandHandler.remove(this.drawingObject);\n            needToDrawPolygon = true;\n            this.endAction();\n        }\n        if (this.drawingObject && !needToDrawPolygon) {\n            var bounds = new _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Rect(this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1].x - 20, this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1].y - 20, 40, 40);\n            var point = { x: this.drawingObject.vertexPoints[0].x, y: this.drawingObject.vertexPoints[0].y };\n            if ((bounds.containsPoint(point) || isDoubleClineck) && this.dragging) {\n                if (this.inAction) {\n                    this.inAction = false;\n                    if (this.drawingObject) {\n                        if (!isMouseLeave) {\n                            if (this.drawingObject.vertexPoints.length > 2 && !args.isTouchMode) {\n                                this.drawingObject.vertexPoints.splice(this.drawingObject.vertexPoints.length - 1, 1);\n                            }\n                        }\n                        if (this.action === 'Polygon') {\n                            if (!isMouseLeave) {\n                                this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length - 1] =\n                                    this.drawingObject.vertexPoints[0];\n                            }\n                            else {\n                                this.drawingObject.vertexPoints[this.drawingObject.vertexPoints.length] =\n                                    this.drawingObject.vertexPoints[0];\n                            }\n                            this.commandHandler.nodePropertyChange(this.drawingObject, { vertexPoints: this.drawingObject.vertexPoints });\n                            var cobject = (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(this.drawingObject);\n                            cobject.shapeAnnotationType = 'Polygon';\n                            cobject.bounds.width = cobject.wrapper.actualSize.width;\n                            cobject.bounds.height = cobject.wrapper.actualSize.height;\n                            cobject.bounds.x = this.drawingObject.wrapper.bounds.x;\n                            cobject.bounds.y = this.drawingObject.wrapper.bounds.y;\n                            this.commandHandler.add(cobject);\n                            this.commandHandler.remove(this.drawingObject);\n                            this.commandHandler.select([cobject.id], currentSelector);\n                            var drawingObject = this.commandHandler.selectedItems.annotations[0];\n                            if (drawingObject) {\n                                if (this.commandHandler.enableShapeAnnotation && ((0,_syncfusion_ej2_base__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(drawingObject.measureType) || drawingObject.measureType === '')) {\n                                    this.commandHandler.annotation.shapeAnnotationModule.\n                                        renderShapeAnnotations(drawingObject, drawingObject.pageIndex);\n                                }\n                                if (this.commandHandler.enableMeasureAnnotation && (drawingObject.measureType === 'Area' || drawingObject.measureType === 'Volume')) {\n                                    if (drawingObject.measureType === 'Area') {\n                                        drawingObject.notes = this.commandHandler.annotation.measureAnnotationModule.\n                                            calculateArea(drawingObject.vertexPoints);\n                                        this.commandHandler.annotation.stickyNotesAnnotationModule.\n                                            addTextToComments(drawingObject.annotName, drawingObject.notes);\n                                    }\n                                    else if (drawingObject.measureType === 'Volume') {\n                                        drawingObject.notes = this.commandHandler.annotation.measureAnnotationModule.\n                                            calculateVolume(drawingObject.vertexPoints);\n                                        this.commandHandler.annotation.stickyNotesAnnotationModule.\n                                            addTextToComments(drawingObject.annotName, drawingObject.notes);\n                                    }\n                                    if (drawingObject.enableShapeLabel) {\n                                        drawingObject.labelContent = drawingObject.notes;\n                                        this.commandHandler.nodePropertyChange(drawingObject, { vertexPoints: drawingObject.vertexPoints,\n                                            notes: drawingObject.notes });\n                                    }\n                                    this.commandHandler.annotation.measureAnnotationModule.\n                                        renderMeasureShapeAnnotations(drawingObject, drawingObject.pageIndex);\n                                }\n                            }\n                        }\n                        else {\n                            if (!isMouseLeave) {\n                                if (isDoubleClineck) {\n                                    this.drawingObject.vertexPoints.splice(this.drawingObject.vertexPoints.length - 1, 1);\n                                }\n                            }\n                            this.commandHandler.nodePropertyChange(this.drawingObject, {\n                                vertexPoints: this.drawingObject.vertexPoints,\n                                sourceDecoraterShapes: this.commandHandler.drawingObject.sourceDecoraterShapes,\n                                taregetDecoraterShapes: this.commandHandler.drawingObject.taregetDecoraterShapes\n                            });\n                            this.commandHandler.select([this.drawingObject.id], currentSelector);\n                            if (this.commandHandler.enableMeasureAnnotation && this.drawingObject.measureType === 'Perimeter') {\n                                this.commandHandler.renderDrawing(null, this.drawingObject.pageIndex);\n                                this.drawingObject.notes =\n                                    this.commandHandler.annotation.measureAnnotationModule.calculatePerimeter(this.drawingObject);\n                                if (this.drawingObject.enableShapeLabel) {\n                                    this.drawingObject.labelContent = this.drawingObject.notes;\n                                    this.commandHandler.nodePropertyChange(this.drawingObject, { vertexPoints: this.drawingObject.vertexPoints,\n                                        notes: this.drawingObject.notes });\n                                }\n                                this.commandHandler.annotation.stickyNotesAnnotationModule.\n                                    addTextToComments(this.drawingObject.annotName, this.drawingObject.notes);\n                                this.commandHandler.annotation.measureAnnotationModule.\n                                    renderMeasureShapeAnnotations(this.drawingObject, this.drawingObject.pageIndex);\n                            }\n                        }\n                        var annotationObject = this.commandHandler.selectedItems.annotations[0];\n                        this.commandHandler.annotation.addAction(this.pageIndex, null, annotationObject, 'Addition', '', annotationObject, annotationObject);\n                        this.drawingObject = null;\n                    }\n                }\n                this.endAction();\n            }\n            else if (this.inAction && !this.dragging) {\n                this.commandHandler.remove(this.drawingObject);\n            }\n        }\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    PolygonDrawingTool.prototype.mouseLeave = function (args) {\n        this.mouseUp(args, true, true);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    PolygonDrawingTool.prototype.mouseWheel = function (args) {\n        _super.prototype.mouseWheel.call(this, args);\n        this.mouseMove(args);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    PolygonDrawingTool.prototype.endAction = function () {\n        this.inAction = false;\n        this.drawingObject = null;\n        this.commandHandler.tool = '';\n    };\n    return PolygonDrawingTool;\n}(ToolBase));\n\n/**\n * Helps to edit the selected connectors\n *\n * @hidden\n */\nvar LineTool = /** @class */ (function (_super) {\n    __extends(LineTool, _super);\n    function LineTool(commandHandler, base, endPoint, drawingObject) {\n        var _this = _super.call(this, commandHandler, base, true) || this;\n        _this.endPoint = endPoint;\n        _this.drawingObject = drawingObject;\n        return _this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    LineTool.prototype.mouseDown = function (args) {\n        this.inAction = true;\n        this.undoElement = undefined;\n        _super.prototype.mouseDown.call(this, args);\n        var oldPointValue;\n        var connectorsShape;\n        if (args.source && args.source.annotations) {\n            oldPointValue = { x: this.prevPosition.x, y: this.prevPosition.y };\n            connectorsShape = this.drawingObject;\n        }\n        this.initialPosition = args.position;\n        this.prevSource = this.drawingObject;\n        this.currentPosition = args.position;\n        if (!this.drawingObject) {\n            var measureModule = this.commandHandler.annotation.measureAnnotationModule;\n            var annotationNode = {\n                vertexPoints: [{ x: this.startPosition.x / this.pdfViewerBase.getZoomFactor(),\n                        y: this.startPosition.y / this.pdfViewerBase.getZoomFactor() },\n                    { x: this.currentPosition.x / this.pdfViewerBase.getZoomFactor(),\n                        y: this.currentPosition.y / this.pdfViewerBase.getZoomFactor() }],\n                bounds: { x: this.currentPosition.x, y: this.currentPosition.y, width: 5, height: 5 },\n                sourceDecoraterShapes: this.commandHandler.drawingObject.sourceDecoraterShapes,\n                taregetDecoraterShapes: this.commandHandler.drawingObject.taregetDecoraterShapes, measureType: 'Distance',\n                fillColor: this.commandHandler.drawingObject.fillColor, notes: this.commandHandler.drawingObject.notes,\n                strokeColor: this.commandHandler.drawingObject.strokeColor,\n                opacity: this.commandHandler.drawingObject.opacity, thickness: this.commandHandler.drawingObject.thickness,\n                borderDashArray: this.commandHandler.drawingObject.borderDashArray,\n                shapeAnnotationType: 'Distance', pageIndex: this.pdfViewerBase.activeElements.activePageID,\n                author: this.commandHandler.drawingObject.author, subject: this.commandHandler.drawingObject.subject,\n                enableShapeLabel: this.commandHandler.enableShapeLabel, leaderHeight: measureModule.leaderLength\n            };\n            this.pdfViewerBase.updateFreeTextProperties(annotationNode);\n            this.drawingObject = this.commandHandler.add(annotationNode);\n        }\n        else if (!this.dragging) {\n            var nodeAnnot = {\n                bounds: { x: this.currentPosition.x, y: this.currentPosition.y, width: 5, height: 5 },\n                vertexPoints: [{ x: this.startPosition.x / this.pdfViewerBase.getZoomFactor(),\n                        y: this.startPosition.y / this.pdfViewerBase.getZoomFactor() },\n                    { x: this.currentPosition.x / this.pdfViewerBase.getZoomFactor(),\n                        y: this.currentPosition.y / this.pdfViewerBase.getZoomFactor() }],\n                shapeAnnotationType: this.drawingObject.shapeAnnotationType,\n                sourceDecoraterShapes: this.drawingObject.sourceDecoraterShapes,\n                taregetDecoraterShapes: this.drawingObject.taregetDecoraterShapes, fillColor: this.drawingObject.fillColor,\n                strokeColor: this.drawingObject.strokeColor, pageIndex: this.pdfViewerBase.activeElements.activePageID,\n                opacity: this.drawingObject.opacity || 1, borderDashArray: this.drawingObject.borderDashArray,\n                thickness: this.drawingObject.thickness,\n                modifiedDate: this.drawingObject.modifiedDate, author: this.drawingObject.author, subject: this.drawingObject.subject,\n                lineHeadEnd: this.drawingObject.lineHeadEnd, lineHeadStart: this.drawingObject.lineHeadStart,\n                measureType: this.commandHandler.drawingObject.measureType, enableShapeLabel: this.commandHandler.enableShapeLabel\n            };\n            this.pdfViewerBase.updateFreeTextProperties(nodeAnnot);\n            this.drawingObject = this.commandHandler.add(nodeAnnot);\n        }\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    LineTool.prototype.mouseUp = function (args) {\n        if (this.dragging) {\n            _super.prototype.mouseMove.call(this, args);\n            if (this.commandHandler) {\n                var currentSelector = void 0;\n                if (args.source && args.annotationSelectorSettings !== null) {\n                    currentSelector = args.source.annotationSelectorSettings;\n                }\n                else {\n                    currentSelector = '';\n                }\n                var node = this.drawingObject;\n                this.commandHandler.nodePropertyChange(node, { vertexPoints: node.vertexPoints, leaderHeight: node.leaderHeight });\n                this.commandHandler.clearSelection(this.pdfViewerBase.activeElements.activePageID);\n                this.commandHandler.select([node.id], currentSelector);\n                this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelector);\n            }\n            if (this.endPoint && this.endPoint.indexOf('ConnectorSegmentPoint') > -1 && this.dragging) {\n                this.commandHandler.annotation.updateCalibrateValues(this.drawingObject);\n                this.commandHandler.annotation.addAction(this.pageIndex, null, this.drawingObject, 'Addition', '', this.drawingObject, this.drawingObject);\n                this.drawingObject = null;\n                this.dragging = false;\n                _super.prototype.mouseUp.call(this, args);\n            }\n            if (this.drawingObject) {\n                this.endPoint = 'ConnectorSegmentPoint_1';\n            }\n        }\n        else {\n            if (this.drawingObject) {\n                this.commandHandler.remove(this.drawingObject);\n            }\n        }\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    LineTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        if (this.inAction && _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.equals(this.currentPosition, this.prevPosition) === false) {\n            this.currentPosition = args.position;\n            this.dragging = true;\n            if (this.currentPosition && this.prevPosition) {\n                var diffX = this.currentPosition.x - this.prevPosition.x;\n                var diffY = this.currentPosition.y - this.prevPosition.y;\n                var currentSelector = void 0;\n                if (args.source && args.annotationSelectorSettings !== null) {\n                    currentSelector = args.source.annotationSelectorSettings;\n                }\n                else {\n                    currentSelector = '';\n                }\n                if (this.inAction && this.commandHandler && this.drawingObject &&\n                    this.endPoint !== undefined && diffX !== 0 || diffY !== 0) {\n                    this.blocked = !this.commandHandler.dragConnectorEnds(this.endPoint, this.drawingObject, this.currentPosition, this.selectedSegment, args.target, null, currentSelector);\n                    this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelector);\n                }\n            }\n            this.prevPosition = this.currentPosition;\n        }\n        return !this.blocked;\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    LineTool.prototype.mouseLeave = function (args) {\n        this.mouseUp(args);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    LineTool.prototype.endAction = function () {\n        _super.prototype.endAction.call(this);\n        this.prevPosition = null;\n        this.endPoint = null;\n    };\n    return LineTool;\n}(ToolBase));\n\n/**\n * Rotates the selected objects\n *\n * @hidden\n */\nvar RotateTool = /** @class */ (function (_super) {\n    __extends(RotateTool, _super);\n    function RotateTool(commandHandler, base) {\n        return _super.call(this, commandHandler, base, true) || this;\n    }\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    RotateTool.prototype.mouseDown = function (args) {\n        var nodeMouseDown = (0,_drawing_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(args.source);\n        this.undoElement = {\n            bounds: {\n                x: nodeMouseDown.wrapper.offsetX, y: nodeMouseDown.wrapper.offsetY,\n                width: nodeMouseDown.wrapper.actualSize.width, height: nodeMouseDown.wrapper.actualSize.height\n            }, rotateAngle: nodeMouseDown.rotateAngle\n        };\n        _super.prototype.mouseDown.call(this, args);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    RotateTool.prototype.mouseUp = function (args) {\n        var object = args.source;\n        var newShapeObject;\n        if (this.undoElement.rotateAngle !== object.wrapper.rotateAngle) {\n            var currentSelector = args.source.annotations[0].annotationSelectorSettings;\n            this.commandHandler.renderSelector(this.pdfViewerBase.activeElements.activePageID, currentSelector);\n            newShapeObject = {\n                bounds: {\n                    x: args.source.wrapper.offsetX, y: args.source.wrapper.offsetY,\n                    width: args.source.wrapper.actualSize.width, height: args.source.wrapper.actualSize.height\n                }, rotateAngle: args.source.wrapper.rotateAngle\n            };\n        }\n        this.commandHandler.annotation.addAction(this.pageIndex, null, args.source, 'Rotate', '', this.undoElement, newShapeObject);\n        this.commandHandler.annotation.stampAnnotationModule.updateSessionStorage(args.source, null, 'Rotate');\n        this.commandHandler.annotation.stickyNotesAnnotationModule.updateStickyNotes(args.source, null);\n        _super.prototype.mouseUp.call(this, args);\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {boolean} - Returns true or false.\n     */\n    RotateTool.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        var object = args.source;\n        var currentSelector = args.source.annotations[0].annotationSelectorSettings;\n        this.currentPosition = args.position;\n        if (object.wrapper) {\n            var refPoint = { x: object.wrapper.offsetX, y: object.wrapper.offsetY };\n            var angle = _syncfusion_ej2_drawings__WEBPACK_IMPORTED_MODULE_0__.Point.findAngle(refPoint, this.currentPosition) + 90;\n            angle = (angle + 360) % 360;\n            this.blocked = !(this.commandHandler.rotate(angle - object.wrapper.rotateAngle, currentSelector));\n        }\n        return !this.blocked;\n    };\n    RotateTool.prototype.getTooltipContent = function (node) {\n        return Math.round((node.rotateAngle % 360)).toString() + '\\xB0';\n    };\n    /**\n     * @private\n     * @param {MouseEventArgs} args - Specified the mouse event arguments.\n     * @returns {void}\n     */\n    RotateTool.prototype.mouseLeave = function (args) {\n        this.mouseUp(args);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    RotateTool.prototype.endAction = function () {\n        _super.prototype.endAction.call(this);\n    };\n    return RotateTool;\n}(ToolBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/tools.js?");

/***/ })

}]);