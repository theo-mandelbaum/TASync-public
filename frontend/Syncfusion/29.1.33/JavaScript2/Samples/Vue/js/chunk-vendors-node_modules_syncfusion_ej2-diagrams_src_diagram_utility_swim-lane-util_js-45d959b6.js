"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-diagrams_src_diagram_utility_swim-lane-util_js-45d959b6"],{

/***/ "./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChangeLaneIndex: () => (/* binding */ ChangeLaneIndex),\n/* harmony export */   addHorizontalPhase: () => (/* binding */ addHorizontalPhase),\n/* harmony export */   addLane: () => (/* binding */ addLane),\n/* harmony export */   addLastPhase: () => (/* binding */ addLastPhase),\n/* harmony export */   addObjectToGrid: () => (/* binding */ addObjectToGrid),\n/* harmony export */   addPhase: () => (/* binding */ addPhase),\n/* harmony export */   addVerticalPhase: () => (/* binding */ addVerticalPhase),\n/* harmony export */   arrangeChildInGrid: () => (/* binding */ arrangeChildInGrid),\n/* harmony export */   arrangeChildNodesInSwimLane: () => (/* binding */ arrangeChildNodesInSwimLane),\n/* harmony export */   canLaneInterchange: () => (/* binding */ canLaneInterchange),\n/* harmony export */   checkLaneChildrenOffset: () => (/* binding */ checkLaneChildrenOffset),\n/* harmony export */   checkLaneSize: () => (/* binding */ checkLaneSize),\n/* harmony export */   checkPhaseOffset: () => (/* binding */ checkPhaseOffset),\n/* harmony export */   checkSameLaneNodes: () => (/* binding */ checkSameLaneNodes),\n/* harmony export */   considerSwimLanePadding: () => (/* binding */ considerSwimLanePadding),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   findLane: () => (/* binding */ findLane),\n/* harmony export */   findLaneIndex: () => (/* binding */ findLaneIndex),\n/* harmony export */   findPhaseIndex: () => (/* binding */ findPhaseIndex),\n/* harmony export */   findStartLaneIndex: () => (/* binding */ findStartLaneIndex),\n/* harmony export */   getConnectors: () => (/* binding */ getConnectors),\n/* harmony export */   getGridChildren: () => (/* binding */ getGridChildren),\n/* harmony export */   gridSelection: () => (/* binding */ gridSelection),\n/* harmony export */   headerDefine: () => (/* binding */ headerDefine),\n/* harmony export */   initGridColumns: () => (/* binding */ initGridColumns),\n/* harmony export */   initGridRow: () => (/* binding */ initGridRow),\n/* harmony export */   initSwimLane: () => (/* binding */ initSwimLane),\n/* harmony export */   isParentNodeSelected: () => (/* binding */ isParentNodeSelected),\n/* harmony export */   laneCollection: () => (/* binding */ laneCollection),\n/* harmony export */   laneInterChanged: () => (/* binding */ laneInterChanged),\n/* harmony export */   pasteSwimLane: () => (/* binding */ pasteSwimLane),\n/* harmony export */   phaseDefine: () => (/* binding */ phaseDefine),\n/* harmony export */   removeChildren: () => (/* binding */ removeChildren),\n/* harmony export */   removeHorizontalPhase: () => (/* binding */ removeHorizontalPhase),\n/* harmony export */   removeLane: () => (/* binding */ removeLane),\n/* harmony export */   removeLaneChildNode: () => (/* binding */ removeLaneChildNode),\n/* harmony export */   removeLaneGridFromPhase: () => (/* binding */ removeLaneGridFromPhase),\n/* harmony export */   removePhase: () => (/* binding */ removePhase),\n/* harmony export */   removeSwimLane: () => (/* binding */ removeSwimLane),\n/* harmony export */   removeVerticalPhase: () => (/* binding */ removeVerticalPhase),\n/* harmony export */   swimLaneMeasureAndArrange: () => (/* binding */ swimLaneMeasureAndArrange),\n/* harmony export */   swimLaneSelection: () => (/* binding */ swimLaneSelection),\n/* harmony export */   updateChildOuterBounds: () => (/* binding */ updateChildOuterBounds),\n/* harmony export */   updateConnectorsProperties: () => (/* binding */ updateConnectorsProperties),\n/* harmony export */   updateHeaderMaxWidth: () => (/* binding */ updateHeaderMaxWidth),\n/* harmony export */   updatePhaseLaneGrids: () => (/* binding */ updatePhaseLaneGrids),\n/* harmony export */   updatePhaseMaxWidth: () => (/* binding */ updatePhaseMaxWidth),\n/* harmony export */   updateSwimLaneChildPosition: () => (/* binding */ updateSwimLaneChildPosition),\n/* harmony export */   updateSwimLaneObject: () => (/* binding */ updateSwimLaneObject)\n/* harmony export */ });\n/* harmony import */ var _objects_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objects/node */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/node.js\");\n/* harmony import */ var _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/containers/grid */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/grid.js\");\n/* harmony import */ var _enum_enum__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enum/enum */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/enum/enum.js\");\n/* harmony import */ var _utility_base_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utility/base-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/base-util.js\");\n/* harmony import */ var _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/elements/diagram-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/diagram-element.js\");\n/* harmony import */ var _core_elements_text_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/elements/text-element */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/text-element.js\");\n/* harmony import */ var _primitives_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../primitives/size */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/size.js\");\n/* harmony import */ var _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/containers/canvas */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/core/containers/canvas.js\");\n/* harmony import */ var _primitives_rect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../primitives/rect */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/rect.js\");\n/* harmony import */ var _interaction_container_interaction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../interaction/container-interaction */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js\");\n/* harmony import */ var _constraints_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./constraints-util */ \"./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/constraints-util.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * SwimLane modules are used to rendering and interaction.\n */\n/** @private */\n/**\n * initSwimLane method \\\n *\n * @returns {void} initSwimLane method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param { Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @private\n */\nfunction initSwimLane(grid, diagram, node) {\n    if (!node.width && node.shape.phases.length === 0) {\n        node.width = 100;\n    }\n    var row = [];\n    var columns = [];\n    var index = 0;\n    var shape = node.shape;\n    var orientation = shape.orientation === 'Horizontal' ? true : false;\n    if (shape.header && shape.hasHeader) {\n        createRow(row, shape.header.height);\n    }\n    initGridRow(row, orientation, node);\n    initGridColumns(columns, orientation, node);\n    grid.setDefinitions(row, columns);\n    if (shape.header && shape.hasHeader) {\n        headerDefine(grid, diagram, node);\n        index++;\n    }\n    if (shape.phases.length > 0 && shape.phaseSize) {\n        for (var k = 0; k < shape.phases.length; k++) {\n            if (shape.phases[parseInt(k.toString(), 10)].id === '') {\n                shape.phases[parseInt(k.toString(), 10)].id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)();\n            }\n            phaseDefine(grid, diagram, node, index, orientation, k);\n        }\n        index++;\n    }\n    if (shape.lanes.length > 0) {\n        for (var k = 0; k < shape.lanes.length; k++) {\n            if (shape.lanes[parseInt(k.toString(), 10)].id === '') {\n                shape.lanes[parseInt(k.toString(), 10)].id = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)();\n            }\n            laneCollection(grid, diagram, node, index, k, orientation);\n            index++;\n        }\n    }\n}\n/**\n * addObjectToGrid method \\\n *\n * @returns {Container} addObjectToGrid method .\\\n * @param { Diagram} diagram - provide the diagram  value.\n * @param { GridPanel} grid - provide the grid  value.\n * @param {NodeModel} parent - provide the parent  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {boolean} isHeader - provide the isHeader  value.\n * @param {boolean} isPhase - provide the isPhase  value.\n * @param {boolean} isLane - provide the isLane  value.\n * @param {string} canvas - provide the canvas  value.\n * @private\n */\nfunction addObjectToGrid(diagram, grid, parent, object, isHeader, isPhase, isLane, canvas) {\n    var node = new _objects_node__WEBPACK_IMPORTED_MODULE_0__.Node(diagram, 'nodes', object, true);\n    node.parentId = parent.id;\n    node.isHeader = (isHeader) ? true : false;\n    node.isPhase = (isPhase) ? true : false;\n    node.isLane = (isLane) ? true : false;\n    var id = (isPhase) ? 'PhaseHeaderParent' : 'LaneHeaderParent';\n    if (canvas) {\n        node[\"\" + id] = canvas;\n    }\n    node.constraints &= ~(_enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.InConnect | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.OutConnect);\n    node.constraints |= _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.HideThumbs;\n    diagram.initObject(node);\n    diagram.nodes.push(node);\n    if (node.wrapper.children.length > 0) {\n        for (var i = 0; i < node.wrapper.children.length; i++) {\n            var child = node.wrapper.children[parseInt(i.toString(), 10)];\n            if (child instanceof _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_4__.DiagramElement) {\n                child.isCalculateDesiredSize = false;\n            }\n            if (child instanceof _core_elements_text_element__WEBPACK_IMPORTED_MODULE_5__.TextElement) {\n                child.canConsiderBounds = false;\n                if (!isHeader && (parent.shape.orientation === 'Vertical' && isPhase) ||\n                    (parent.shape.orientation !== 'Vertical' && isLane)) {\n                    child.isLaneOrientation = true;\n                    child.refreshTextElement();\n                }\n            }\n        }\n        node.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(undefined, undefined));\n        node.wrapper.arrange(node.wrapper.desiredSize);\n    }\n    return node.wrapper;\n}\n/**\n * headerDefine method \\\n *\n * @returns {void} headerDefine method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @private\n */\nfunction headerDefine(grid, diagram, object) {\n    var maxWidth = 0;\n    var columns = grid.columnDefinitions();\n    var shape = object.shape;\n    for (var i = 0; i < columns.length; i++) {\n        maxWidth += columns[parseInt(i.toString(), 10)].width;\n    }\n    shape.header.id = shape.header.id || (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)();\n    var node = {\n        id: object.id + shape.header.id,\n        annotations: [(0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(shape.header.annotation)],\n        style: shape.header.style ? shape.header.style : undefined,\n        offsetX: object.offsetX, offsetY: object.offsetY,\n        rowIndex: 0, columnIndex: 0,\n        maxWidth: maxWidth,\n        container: { type: 'Canvas', orientation: 'Horizontal' }\n    };\n    if (!(0,_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canSelect)(object)) {\n        node.constraints &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.Select;\n    }\n    var wrapper = addObjectToGrid(diagram, grid, object, node, true);\n    grid.addObject(wrapper, 0, 0, 1, grid.columnDefinitions().length);\n}\n/**\n * phaseDefine method \\\n *\n * @returns {void} phaseDefine method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {number} indexValue - provide the indexValue  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {number} phaseIndex - provide the phaseIndex  value.\n * @private\n */\nfunction phaseDefine(grid, diagram, object, indexValue, orientation, phaseIndex) {\n    var rowValue = 0;\n    var colValue = 0;\n    var maxWidth;\n    var shape = object.shape;\n    if (orientation) {\n        colValue = phaseIndex;\n        rowValue = indexValue;\n        maxWidth = grid.columnDefinitions()[parseInt(phaseIndex.toString(), 10)].width;\n    }\n    else {\n        rowValue = shape.header && shape.hasHeader ? phaseIndex + 1 : phaseIndex;\n    }\n    var phaseObject = {\n        annotations: [(0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(shape.phases[parseInt(phaseIndex.toString(), 10)].header.annotation)],\n        maxWidth: maxWidth,\n        id: object.id + shape.phases[parseInt(phaseIndex.toString(), 10)].id + '_header',\n        addInfo: shape.phases[parseInt(phaseIndex.toString(), 10)].addInfo,\n        offsetX: object.offsetX, offsetY: object.offsetY,\n        style: shape.phases[parseInt(phaseIndex.toString(), 10)].style,\n        rowIndex: rowValue, columnIndex: colValue,\n        container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n    };\n    phaseObject.annotations[0].rotateAngle = orientation ? 0 : 270;\n    if (!(0,_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canSelect)(object)) {\n        phaseObject.constraints &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.Select;\n    }\n    shape.phases[parseInt(phaseIndex.toString(), 10)].header.id = phaseObject.id;\n    var wrapper = addObjectToGrid(diagram, grid, object, phaseObject, false, true, false, shape.phases[parseInt(phaseIndex.toString(), 10)].id);\n    grid.addObject(wrapper, rowValue, colValue);\n}\n/**\n * laneCollection method \\\n *\n * @returns {void} laneCollection method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {number} indexValue - provide the indexValue  value.\n * @param {number} laneIndex - provide the laneIndex  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @private\n */\nfunction laneCollection(grid, diagram, object, indexValue, laneIndex, orientation) {\n    var laneNode;\n    var parentWrapper;\n    var gridCell;\n    var canvas;\n    var childWrapper;\n    var shape = object.shape;\n    var value = shape.phases.length || 1;\n    var isHeader = (shape.header && shape.hasHeader) ? 1 : 0;\n    var rowValue = orientation ? indexValue : isHeader;\n    var phaseCount = (shape.phaseSize && shape.phases.length > 0) ? 1 : 0;\n    for (var l = 0; l < value; l++) {\n        var colValue = orientation ? l : laneIndex + phaseCount;\n        gridCell = grid.rows[parseInt(rowValue.toString(), 10)].cells[parseInt(colValue.toString(), 10)];\n        canvas = {\n            id: object.id + shape.lanes[parseInt(laneIndex.toString(), 10)].id + l,\n            rowIndex: rowValue, columnIndex: colValue,\n            width: gridCell.minWidth, height: gridCell.minHeight,\n            offsetX: object.offsetX, offsetY: object.offsetY,\n            style: shape.lanes[parseInt(laneIndex.toString(), 10)].style,\n            addInfo: shape.lanes[parseInt(laneIndex.toString(), 10)].addInfo,\n            constraints: _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.Default | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.ReadOnly | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.AllowDrop,\n            container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n        };\n        if (!(0,_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canSelect)(object)) {\n            canvas.constraints &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.Select;\n        }\n        parentWrapper = addObjectToGrid(diagram, grid, object, canvas, false, false, true);\n        if (shape.phases && shape.phases.length > 0 && shape.phases[parseInt(l.toString(), 10)]) {\n            var phase = diagram.nameTable[shape.phases[parseInt(l.toString(), 10)].header.id];\n            if (phase) {\n                phase.laneGrids.splice(laneIndex, 0, canvas.id);\n            }\n        }\n        parentWrapper.children[0].isCalculateDesiredSize = false;\n        if (l === 0) {\n            laneNode = {\n                id: object.id + shape.lanes[parseInt(laneIndex.toString(), 10)].id + '_' + l + '_header',\n                style: shape.lanes[parseInt(laneIndex.toString(), 10)].header.style,\n                annotations: [(0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(shape.lanes[parseInt(laneIndex.toString(), 10)].header.annotation)],\n                offsetX: object.offsetX, offsetY: object.offsetY,\n                rowIndex: rowValue, columnIndex: colValue,\n                container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n            };\n            laneNode.annotations[0].rotateAngle = orientation ? 270 : 0;\n            shape.lanes[parseInt(laneIndex.toString(), 10)].header.id = laneNode.id;\n            // eslint-disable-next-line\n            (orientation) ? laneNode.width = shape.lanes[laneIndex].header.width :\n                laneNode.height = shape.lanes[parseInt(laneIndex.toString(), 10)].header.height;\n            if (!(0,_constraints_util__WEBPACK_IMPORTED_MODULE_10__.canSelect)(object)) {\n                laneNode.constraints &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.Select;\n            }\n            childWrapper = addObjectToGrid(diagram, grid, object, laneNode, false, false, true, shape.lanes[parseInt(laneIndex.toString(), 10)].id);\n            if (orientation) {\n                childWrapper.children[0].elementActions = childWrapper.children[0].elementActions | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.ElementAction.HorizontalLaneHeader;\n            }\n            parentWrapper.children.push(childWrapper);\n        }\n        grid.addObject(parentWrapper, rowValue, colValue);\n        if (!orientation) {\n            rowValue++;\n        }\n        colValue = orientation ? l : laneIndex + 1;\n    }\n}\n/**\n * createRow method \\\n *\n * @returns {void} createRow method .\\\n * @param { RowDefinition[]} row - provide the row  value.\n * @param {number} height - provide the height  value.\n * @private\n */\nfunction createRow(row, height) {\n    var rows = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.RowDefinition();\n    rows.height = height;\n    row.push(rows);\n}\n/**\n * createColumn method \\\n *\n * @returns {void} createColumn method .\\\n * @param {number} width - provide the width  value.\n * @private\n */\nfunction createColumn(width) {\n    var cols = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.ColumnDefinition();\n    cols.width = width;\n    return cols;\n}\n/**\n * initGridRow method \\\n *\n * @returns {void} initGridRow method .\\\n * @param {RowDefinition[]} row - provide the row  value.\n * @param {boolean} orientation - provide the row  value.\n * @param {NodeModel} object - provide the row  value.\n * @private\n */\nfunction initGridRow(row, orientation, object) {\n    var totalHeight = 0;\n    var height;\n    var shape = object.shape;\n    if (row.length > 0) {\n        for (var i = 0; i < row.length; i++) {\n            totalHeight += row[parseInt(i.toString(), 10)].height;\n        }\n    }\n    if (orientation) {\n        if (shape.phases.length > 0 && shape.phaseSize) {\n            totalHeight += shape.phaseSize;\n            createRow(row, shape.phaseSize);\n        }\n        if (shape.lanes.length > 0) {\n            for (var i = 0; i < shape.lanes.length; i++) {\n                height = shape.lanes[parseInt(i.toString(), 10)].height;\n                totalHeight += height;\n                if (i === shape.lanes.length - 1 && totalHeight < object.height) {\n                    height += object.height - totalHeight;\n                }\n                createRow(row, height);\n            }\n        }\n    }\n    else {\n        if (shape.phases.length > 0) {\n            var phaseHeight = 0;\n            for (var i = 0; i < shape.phases.length; i++) {\n                var phaseOffset = shape.phases[parseInt(i.toString(), 10)].offset;\n                if (i === 0) {\n                    phaseHeight += phaseOffset;\n                }\n                else {\n                    phaseOffset -= phaseHeight;\n                    phaseHeight += phaseOffset;\n                }\n                height = phaseOffset;\n                totalHeight += height;\n                if (i === shape.phases.length - 1 && totalHeight < object.height) {\n                    height += object.height - totalHeight;\n                }\n                createRow(row, height);\n            }\n        }\n        else {\n            createRow(row, object.height);\n        }\n    }\n}\n/**\n * initGridColumns method \\\n *\n * @returns {void} initGridRow method .\\\n * @param {ColumnDefinition[]} columns - provide the row  value.\n * @param {boolean} orientation - provide the row  value.\n * @param {NodeModel} object - provide the row  value.\n * @private\n */\nfunction initGridColumns(columns, orientation, object) {\n    var totalWidth = 0;\n    var shape = object.shape;\n    var phaseOffset;\n    var cols;\n    var k;\n    var j;\n    var value;\n    if (shape.phases.length > 0 && shape.orientation === 'Horizontal') {\n        for (j = 0; j < shape.phases.length; j++) {\n            phaseOffset = shape.phases[parseInt(j.toString(), 10)].offset;\n            if (j === 0) {\n                totalWidth += phaseOffset;\n            }\n            else {\n                phaseOffset -= totalWidth;\n                totalWidth += phaseOffset;\n            }\n            cols = createColumn(phaseOffset);\n            if (j === shape.phases.length - 1 && totalWidth < object.width) {\n                cols.width += object.width - totalWidth;\n            }\n            columns.push(cols);\n        }\n    }\n    else if (!orientation) {\n        value = (shape.phaseSize && shape.phases.length > 0) ? shape.lanes.length\n            + 1 : shape.lanes.length;\n        if (shape.phaseSize && shape.phases.length > 0) {\n            totalWidth += shape.phaseSize;\n            cols = createColumn(shape.phaseSize);\n            columns.push(cols);\n        }\n        for (k = 0; k < shape.lanes.length; k++) {\n            totalWidth += shape.lanes[parseInt(k.toString(), 10)].width;\n            cols = createColumn(shape.lanes[parseInt(k.toString(), 10)].width);\n            if (k === shape.lanes.length - 1 && totalWidth < object.width) {\n                cols.width += object.width - totalWidth;\n            }\n            columns.push(cols);\n        }\n        if ((shape.phases.length === 0 && shape.lanes.length === 0)) {\n            cols = createColumn(object.width);\n            columns.push(cols);\n        }\n    }\n    else {\n        cols = createColumn(object.width);\n        columns.push(cols);\n    }\n}\n/**\n * getConnectors method \\\n *\n * @returns {void} getConnectors method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {GridPanel} grid - provide the row  value.\n * @param {number} rowIndex - provide the row  value.\n * @param {boolean} isRowUpdate - provide the row  value.\n * @private\n */\nfunction getConnectors(diagram, grid, rowIndex, isRowUpdate) {\n    var connectors = [];\n    var conn = 0;\n    var childNode;\n    var node;\n    var k;\n    var i;\n    var j;\n    var canvas;\n    var row;\n    var length = grid.rowDefinitions().length;\n    var edges;\n    for (var i_1 = 0; i_1 < length; i_1++) {\n        row = grid.rows[parseInt(i_1.toString(), 10)];\n        for (j = 0; j < row.cells.length; j++) {\n            canvas = row.cells[parseInt(j.toString(), 10)].children[0];\n            if (canvas && canvas.children && canvas.children.length) {\n                for (k = 1; k < canvas.children.length; k++) {\n                    childNode = canvas.children[parseInt(k.toString(), 10)];\n                    node = diagram.getObject(childNode.id);\n                    if (node && (node.inEdges.length > 0 || node.outEdges.length > 0)) {\n                        edges = node.inEdges.concat(node.outEdges);\n                        for (conn = 0; conn < edges.length; conn++) {\n                            if (connectors.indexOf(edges[parseInt(conn.toString(), 10)]) === -1) {\n                                connectors.push(edges[parseInt(conn.toString(), 10)]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return connectors;\n}\n/**\n * swimLaneMeasureAndArrange method \\\n *\n * @returns {void} swimLaneMeasureAndArrange method .\\\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nfunction swimLaneMeasureAndArrange(obj) {\n    var canvas = obj.wrapper;\n    canvas.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(obj.width, obj.height));\n    if (canvas.children[0] instanceof _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.GridPanel) {\n        var grid = canvas.children[0];\n        var isMeasure = false;\n        if (grid.width && grid.width < grid.desiredSize.width) {\n            isMeasure = true;\n            grid.width = grid.desiredSize.width;\n        }\n        if (grid.height && grid.height < grid.desiredSize.height) {\n            isMeasure = true;\n            grid.height = grid.desiredSize.height;\n        }\n        if (isMeasure) {\n            grid.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(grid.width, grid.height));\n        }\n    }\n    canvas.arrange(canvas.desiredSize);\n}\n/**\n * ChangeLaneIndex method \\\n *\n * @returns {void} ChangeLaneIndex method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @param {number} startRowIndex - provide the row  value.\n * @private\n */\nfunction ChangeLaneIndex(diagram, obj, startRowIndex) {\n    var container = obj.wrapper.children[0];\n    var i;\n    var j;\n    var k;\n    var l;\n    var object;\n    var subChild;\n    var row;\n    var cell;\n    var child;\n    for (i = startRowIndex; i < container.rows.length; i++) {\n        row = container.rows[parseInt(i.toString(), 10)];\n        for (j = 0; j < row.cells.length; j++) {\n            cell = row.cells[parseInt(j.toString(), 10)];\n            if (cell.children && cell.children.length > 0) {\n                for (k = 0; k < cell.children.length; k++) {\n                    child = cell.children[parseInt(k.toString(), 10)];\n                    object = diagram.nameTable[child.id];\n                    if (object.isLane && child.children.length > 1) {\n                        // 912905: Multi-selecting and deleting swimlane objects causes the diagram to break\n                        for (l = 1; l < child.children.length; l++) {\n                            subChild = diagram.nameTable[child.children[parseInt(l.toString(), 10)].id];\n                            if (subChild && subChild.isLane) {\n                                subChild.rowIndex = i;\n                                subChild.columnIndex = j;\n                            }\n                        }\n                    }\n                    object.rowIndex = i;\n                    object.columnIndex = j;\n                }\n            }\n        }\n    }\n}\n/**\n * arrangeChildNodesInSwimLane method \\\n *\n * @returns {void} arrangeChildNodesInSwimLane method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nfunction arrangeChildNodesInSwimLane(diagram, obj) {\n    var grid = obj.wrapper.children[0];\n    var shape = obj.shape;\n    var padding = shape.padding;\n    var lanes = shape.lanes;\n    var top = grid.bounds.y;\n    var rowvalue;\n    var columnValue;\n    var phaseCount = (shape.phaseSize > 0) ? shape.phases.length : 0;\n    var node;\n    var canvas;\n    var cell;\n    var i;\n    var j;\n    var k;\n    var orientation = shape.orientation === 'Horizontal' ? true : false;\n    var col = orientation ? shape.phases.length || 1 : lanes.length + 1;\n    var row = orientation ? ((shape.header && shape.hasHeader) ? 1 : 0) +\n        (shape.phases.length > 0 ? 1 : 0) + (shape.lanes.length)\n        : (shape.header && shape.hasHeader ? 1 : 0) + shape.phases.length;\n    if (phaseCount === 0 && !orientation && shape.lanes.length) {\n        row += 1;\n    }\n    if (orientation) {\n        rowvalue = (shape.header && shape.hasHeader ? 1 : 0) + (phaseCount > 0 ? 1 : 0);\n        columnValue = 0;\n    }\n    else {\n        rowvalue = (shape.header && shape.hasHeader ? 1 : 0);\n        columnValue = phaseCount > 0 ? 1 : 0;\n    }\n    if (lanes.length > 0) {\n        top += (shape.header && shape.hasHeader) ? shape.header.height : 0;\n        for (i = 0; i < lanes.length; i++) {\n            for (j = 0; j < lanes[parseInt(i.toString(), 10)].children.length; j++) {\n                node = lanes[parseInt(i.toString(), 10)].children[parseInt(j.toString(), 10)];\n                node.offsetX = lanes[parseInt(i.toString(), 10)].width;\n                node.offsetY = lanes[parseInt(i.toString(), 10)].height;\n                diagram.initObject(node);\n                diagram.nodes.push(node);\n                canvas = node.wrapper;\n                if (orientation) {\n                    for (k = columnValue; k < col; k++) {\n                        cell = grid.rows[parseInt(rowvalue.toString(), 10)].cells[parseInt(k.toString(), 10)];\n                        if (canvas.margin.left < (cell.bounds.right - grid.bounds.x)) {\n                            node.parentId = cell.children[0].id;\n                            if (k > columnValue) {\n                                canvas.margin.left = canvas.margin.left - (cell.bounds.left - grid.bounds.left);\n                            }\n                            else {\n                                if ((cell.children[0].children[1].actualSize.width + padding) >= canvas.margin.left) {\n                                    canvas.margin.left = cell.children[0].children[1].actualSize.width + padding;\n                                }\n                            }\n                            if (canvas.margin.left < padding) {\n                                canvas.margin.left = padding;\n                            }\n                            if (canvas.margin.top < padding) {\n                                canvas.margin.top = padding;\n                            }\n                            addChildToLane(canvas, node, diagram);\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (var k_1 = rowvalue; k_1 < row; k_1++) {\n                        cell = grid.rows[parseInt(k_1.toString(), 10)].cells[parseInt(columnValue.toString(), 10)];\n                        if (canvas.margin.top < (cell.bounds.bottom - top)) {\n                            node.parentId = cell.children[0].id;\n                            if (k_1 > rowvalue) {\n                                canvas.margin.top = canvas.margin.top - (cell.bounds.top - top);\n                            }\n                            else {\n                                if ((cell.children[0].children[1].actualSize.height + padding) >= canvas.margin.top) {\n                                    canvas.margin.top = cell.children[0].children[1].actualSize.height + padding;\n                                }\n                            }\n                            if (canvas.margin.left < padding) {\n                                canvas.margin.left = padding;\n                            }\n                            if (canvas.margin.top < padding) {\n                                canvas.margin.top = padding;\n                            }\n                            addChildToLane(canvas, node, diagram);\n                            break;\n                        }\n                    }\n                }\n            }\n            // eslint-disable-next-line\n            orientation ? rowvalue++ : columnValue++;\n        }\n    }\n    grid.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(obj.width, obj.height));\n    grid.arrange(grid.desiredSize);\n    updateChildOuterBounds(grid, obj);\n    obj.width = obj.wrapper.width = grid.width;\n    obj.height = obj.wrapper.height = grid.height;\n    updateHeaderMaxWidth(diagram, obj);\n    obj.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(obj.width, obj.height));\n    obj.wrapper.arrange(grid.desiredSize);\n    checkLaneChildrenOffset(obj);\n    checkPhaseOffset(obj, diagram);\n    checkLaneSize(obj);\n}\n/**\n * addChildToLane method \\\n *\n * @returns {void} addChildToLane method .\\\n * @param {Container} canvas - provide the row  value.\n * @param {NodeModel} node - provide the row  value.\n * @param {Diagram} diagram - provide the row  value.\n * @private\n */\nfunction addChildToLane(canvas, node, diagram) {\n    canvas.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(node.width, node.height));\n    canvas.arrange(canvas.desiredSize);\n    var parent = diagram.getObject(node.parentId);\n    diagram.addChild(parent, node.id);\n}\n/**\n * updateChildOuterBounds method \\\n *\n * @returns {void} updateChildOuterBounds method .\\\n * @param {GridPanel} grid - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nfunction updateChildOuterBounds(grid, obj) {\n    var columnDefinitions = grid.columnDefinitions();\n    var rowDefinitions = grid.rowDefinitions();\n    var i;\n    var k;\n    var j;\n    var cell;\n    var child;\n    var row;\n    var rowIndex = findStartLaneIndex(obj);\n    if (obj.shape.orientation === 'Vertical') {\n        if (rowIndex === 0) {\n            rowIndex = (obj.shape.header && obj.shape.hasHeader) ? 1 : 0;\n        }\n    }\n    var padding = obj.shape.padding;\n    for (i = 0; i < columnDefinitions.length; i++) {\n        grid.updateColumnWidth(i, columnDefinitions[parseInt(i.toString(), 10)].width, true, padding);\n    }\n    for (i = rowIndex; i < rowDefinitions.length; i++) {\n        grid.updateRowHeight(i, rowDefinitions[parseInt(i.toString(), 10)].height, true, padding);\n    }\n    for (k = 0; k < rowDefinitions.length; k++) {\n        row = grid.rows[parseInt(k.toString(), 10)];\n        for (i = 0; i < columnDefinitions.length; i++) {\n            cell = row.cells[parseInt(i.toString(), 10)];\n            if (cell.children && cell.children.length > 0) {\n                for (j = 0; j < cell.children.length; j++) {\n                    child = cell.children[parseInt(j.toString(), 10)];\n                    if (child.maxWidth) {\n                        child.maxWidth = cell.actualSize.width;\n                    }\n                    if (child.maxHeight) {\n                        child.maxHeight = cell.actualSize.height;\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * checkLaneSize method \\\n *\n * @returns {void} checkLaneSize method .\\\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nfunction checkLaneSize(obj) {\n    if (obj.shape.type === 'SwimLane' && !obj.shape.isLane && !obj.shape.isPhase) {\n        // 910832 - Lane height updating to negative values wrongly during resizing\n        var lane = void 0;\n        var i = void 0;\n        var j = void 0;\n        var k = void 0;\n        var size = void 0; //let laneCount: number = 0;\n        var lanes = obj.shape.lanes;\n        var laneIndex = findStartLaneIndex(obj);\n        var rows = obj.wrapper.children[0].rowDefinitions();\n        var columns = obj.wrapper.children[0].columnDefinitions();\n        var widthSize = void 0;\n        var heightSize = void 0;\n        for (i = 0; i < lanes.length; i++, laneIndex++) {\n            lane = lanes[parseInt(i.toString(), 10)];\n            if (obj.shape.orientation === 'Horizontal') {\n                size = rows[parseInt(laneIndex.toString(), 10)].height;\n                if (lane.height !== size) {\n                    lane.height = size;\n                }\n                for (j = 0; j < columns.length; j++) {\n                    widthSize = columns[parseInt(j.toString(), 10)].width;\n                    if (lane.width !== widthSize) {\n                        lane.width = widthSize;\n                    }\n                }\n            }\n            else {\n                size = columns[parseInt(laneIndex.toString(), 10)].width;\n                if (lane.width !== size) {\n                    lane.width = size;\n                }\n                for (k = 0; k < rows.length; k++) {\n                    heightSize = rows[parseInt(k.toString(), 10)].height;\n                    if (lane.height !== heightSize) {\n                        lane.height = heightSize;\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * checkPhaseOffset method \\\n *\n * @returns {void} checkPhaseOffset method .\\\n * @param {NodeModel} obj - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @private\n */\nfunction checkPhaseOffset(obj, diagram) {\n    var shape = obj.shape;\n    var phases = shape.phases;\n    var i;\n    var offset;\n    var phaseRow;\n    var phase;\n    var gridRowIndex = (shape.header && shape.hasHeader) ? 1 : 0;\n    var grid = obj.wrapper.children[0];\n    var top = grid.bounds.y + ((shape.header && shape.hasHeader) ? shape.header.height : 0);\n    if (obj.shape.type === 'SwimLane') {\n        obj = diagram.getObject(obj.id) || obj;\n        if (phases.length > 0) {\n            grid = obj.wrapper.children[0];\n            if (shape.orientation === 'Horizontal') {\n                phaseRow = (shape.header && shape.hasHeader) ? grid.rows[1] : grid.rows[0];\n                for (i = 0; i < phases.length; i++) {\n                    phase = phaseRow.cells[parseInt(i.toString(), 10)].children[0];\n                    offset = phase.bounds.right - grid.bounds.x;\n                    if (phases[parseInt(i.toString(), 10)].offset !== offset) {\n                        phases[parseInt(i.toString(), 10)].offset = offset;\n                    }\n                    diagram.nameTable[phase.id].maxWidth = phase.maxWidth;\n                }\n            }\n            else {\n                for (i = 0; i < phases.length; i++) {\n                    phase = grid.rows[gridRowIndex + i].cells[0].children[0];\n                    offset = phase.bounds.bottom - top;\n                    if (phases[parseInt(i.toString(), 10)].offset !== offset) {\n                        phases[parseInt(i.toString(), 10)].offset = offset;\n                    }\n                    diagram.nameTable[phase.id].maxWidth = phase.maxWidth;\n                }\n            }\n        }\n    }\n}\n/**\n * updateConnectorsProperties method \\\n *\n * @returns {void} checkPhaseOffset method .\\\n * @param {string[]} connectors - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @private\n */\nfunction updateConnectorsProperties(connectors, diagram) {\n    if (connectors && connectors.length > 0) {\n        var edges = void 0;\n        if (diagram.lineRoutingModule && (diagram.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramConstraints.LineRouting)) {\n            if (diagram.avoidLineOverlappingModule) {\n                diagram.avoidLineOverlappingModule.removeConnectors(connectors);\n            }\n            diagram.lineRoutingModule.renderVirtualRegion(diagram, true);\n        }\n        for (var i = 0; i < connectors.length; i++) {\n            edges = diagram.getObject(connectors[parseInt(i.toString(), 10)]);\n            if (diagram.lineRoutingModule && (diagram.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramConstraints.LineRouting) && edges.type === 'Orthogonal') {\n                diagram.lineRoutingModule.refreshConnectorSegments(diagram, edges, true);\n            }\n            else {\n                diagram.connectorPropertyChange(edges, {}, {\n                    sourceID: edges.sourceID, targetID: edges.targetID\n                });\n            }\n        }\n    }\n}\n/**\n * laneInterChanged method \\\n *\n * @returns {void} laneInterChanged method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} obj - provide the obj  value.\n * @param {NodeModel} target - provide the target  value.\n * @param {PointModel} position - provide the position  value.\n * @private\n */\nfunction laneInterChanged(diagram, obj, target, position) {\n    var index;\n    var undoElement;\n    var entry;\n    var redoElement;\n    var sourceIndex;\n    var targetIndex;\n    var temp;\n    var sourceLaneIndex;\n    var targetLaneIndex;\n    var rowIndex;\n    var swimLane = (diagram.getObject(obj.parentId));\n    var shape = swimLane.shape;\n    var grid = swimLane.wrapper.children[0];\n    var lanes = shape.lanes;\n    var connectors = getConnectors(diagram, grid, obj.rowIndex, true);\n    if ((shape.orientation === 'Horizontal' && obj.rowIndex !== target.rowIndex) ||\n        (shape.orientation === 'Vertical' && obj.columnIndex !== target.columnIndex)) {\n        if (shape.orientation === 'Horizontal') {\n            sourceIndex = obj.rowIndex;\n            targetIndex = target.rowIndex;\n            index = ((shape.header && shape.hasHeader) ? 1 : 0) + (shape.phases.length && shape.phaseSize ? 1 : 0);\n            sourceLaneIndex = obj.rowIndex - index;\n            targetLaneIndex = target.rowIndex - index;\n            if (lanes[parseInt(sourceLaneIndex.toString(), 10)].canMove) {\n                if (sourceLaneIndex < targetLaneIndex) {\n                    if (position && target.wrapper.offsetY > position.y) {\n                        targetIndex += (targetLaneIndex > 0) ? -1 : 1;\n                        targetLaneIndex += (targetLaneIndex > 0) ? -1 : 1;\n                    }\n                }\n                else {\n                    if (position && target.wrapper.offsetY < position.y) {\n                        targetIndex += 1;\n                        targetLaneIndex += 1;\n                    }\n                }\n                if (sourceIndex !== targetIndex) {\n                    grid.updateRowIndex(sourceIndex, targetIndex);\n                    //To update the laneGrids arrangement after swaping lanes\n                    updatePhaseLaneGrids(sourceLaneIndex, targetLaneIndex, swimLane, diagram);\n                }\n            }\n        }\n        else {\n            sourceIndex = obj.columnIndex;\n            targetIndex = target.columnIndex;\n            index = (shape.phases.length && shape.phaseSize) ? 1 : 0;\n            sourceLaneIndex = obj.columnIndex - index;\n            targetLaneIndex = target.columnIndex - index;\n            rowIndex = (shape.header && shape.hasHeader) ? 1 : 0;\n            if (lanes[parseInt(sourceLaneIndex.toString(), 10)].canMove) {\n                if (sourceLaneIndex < targetLaneIndex) {\n                    if (position && target.wrapper.offsetX > position.x) {\n                        targetIndex += (targetLaneIndex > 0) ? -1 : 1;\n                        targetLaneIndex += (targetLaneIndex > 0) ? -1 : 1;\n                    }\n                }\n                else {\n                    if (position && target.wrapper.offsetX < position.x) {\n                        targetIndex += 1;\n                        targetLaneIndex += 1;\n                    }\n                }\n                if (sourceIndex !== targetIndex) {\n                    if ((shape.phaseSize === 0 || shape.phases.length === 0) && (targetIndex === 0 || sourceIndex === 0)) {\n                        if (shape.header && shape.hasHeader) {\n                            var changeHeaderIndex = (targetIndex === 0) ? sourceIndex : targetIndex;\n                            grid.rows[0].cells[parseInt(changeHeaderIndex.toString(), 10)].children = grid.rows[0].cells[0].children;\n                            grid.rows[0].cells[parseInt(changeHeaderIndex.toString(), 10)].columnSpan = grid.rows[0].cells[0].columnSpan;\n                            grid.rows[0].cells[0].children = [];\n                        }\n                    }\n                    grid.updateColumnIndex(0, sourceIndex, targetIndex);\n                    //To update the laneGrids arrangement after swaping lanes\n                    updatePhaseLaneGrids(sourceLaneIndex, targetLaneIndex, swimLane, diagram);\n                }\n            }\n        }\n        if (sourceIndex !== targetIndex) {\n            temp = lanes[parseInt(sourceLaneIndex.toString(), 10)];\n            if (temp.canMove) {\n                undoElement = {\n                    target: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(target), source: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(obj)\n                };\n                temp = lanes[parseInt(sourceLaneIndex.toString(), 10)];\n                lanes.splice(sourceLaneIndex, 1);\n                lanes.splice(targetLaneIndex, 0, temp);\n                redoElement = {\n                    target: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(undoElement.source), source: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(undoElement.target)\n                };\n                entry = {\n                    type: 'LanePositionChanged', redoObject: redoElement,\n                    undoObject: undoElement, category: 'Internal'\n                };\n                if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n                    diagram.commandHandler.addHistoryEntry(entry);\n                }\n                ChangeLaneIndex(diagram, swimLane, 0);\n                updateConnectorsProperties(connectors, diagram);\n                updateSwimLaneChildPosition(lanes, diagram);\n                swimLane.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(swimLane.width, swimLane.height));\n                swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);\n                diagram.updateDiagramObject(swimLane);\n            }\n        }\n    }\n    diagram.updateDiagramElementQuad();\n}\n/**\n * Swaps the positions of two lane grid entries within each phase of a swimlane.\n *\n * @param {number} sourceIndex - The index of the lane grid to be moved.\n * @param {number} targetIndex - The index where the lane grid should be moved to.\n * @param {NodeModel} swimlane - The swimlane node containing the phases.\n * @param {Diagram} diagram - The diagram instance containing the node data.\n * @returns {void}\n * @private\n */\nfunction updatePhaseLaneGrids(sourceIndex, targetIndex, swimlane, diagram) {\n    var phases = swimlane.shape.phases;\n    if (phases && phases.length > 0) {\n        for (var i = 0; i < phases.length; i++) {\n            var phaseId = swimlane.id + phases[parseInt(i.toString(), 10)].id + '_header';\n            var phaseObj = diagram.nameTable[\"\" + phaseId];\n            if (phaseObj && phaseObj.laneGrids && sourceIndex >= 0 && targetIndex >= 0 &&\n                sourceIndex < phaseObj.laneGrids.length && targetIndex < phaseObj.laneGrids.length) {\n                // Remove the element at sourceIndex\n                var removed = phaseObj.laneGrids.splice(sourceIndex, 1)[0];\n                // Insert it at targetIndex\n                phaseObj.laneGrids.splice(targetIndex, 0, removed);\n            }\n        }\n    }\n}\n/**\n * updateSwimLaneObject method \\\n *\n * @returns {void} updateSwimLaneObject method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {Node} obj - provide the obj  value.\n * @param {NodeModel} swimLane - provide the target  value.\n * @param {NodeModel} helperObject - provide the position  value.\n * @param {number} widthDiff - provide the difference in colum width.\n * @param {number} heightDiff - provide the difference in row height.\n * @private\n */\nfunction updateSwimLaneObject(diagram, obj, swimLane, helperObject, widthDiff, heightDiff) {\n    var parentNode = diagram.getObject(swimLane.id);\n    var shape = parentNode.shape;\n    var index = (shape.header && shape.hasHeader) ? 1 : 0;\n    var lanes = shape.lanes;\n    var phases = shape.phases;\n    var helperWidth = helperObject.wrapper.actualSize.width;\n    var helperHeight = helperObject.wrapper.actualSize.height;\n    var objWidth = obj.wrapper.actualSize.width;\n    var objHeight = obj.wrapper.actualSize.height;\n    var i;\n    var j;\n    var isUndoRedo = false;\n    if (diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo) {\n        isUndoRedo = true;\n    }\n    var grid = parentNode.wrapper.children[0];\n    // 910832 - Lane height updating to negative values wrongly during resizing\n    if (parentNode.shape.type === 'SwimLane') {\n        if (shape.orientation === 'Horizontal') {\n            if (obj.isPhase) {\n                // phases[obj.columnIndex].offset = obj.wrapper.width;\n                for (var p = obj.columnIndex; p < phases.length; p++) {\n                    phases[parseInt(p.toString(), 10)].offset += widthDiff;\n                    //929543: To get the minWidth of phase and if the updated size less than min width then we set minWindth.\n                    var curPhase = diagram.nameTable[phases[parseInt(p.toString(), 10)].header.id];\n                    if (curPhase) {\n                        var gridPhase = grid.rows[curPhase.rowIndex].cells[curPhase.columnIndex];\n                        var gridPhaseMinWidth = gridPhase.minWidth;\n                        if (phases[parseInt(p.toString(), 10)].offset < gridPhaseMinWidth) {\n                            phases[parseInt(p.toString(), 10)].offset = gridPhaseMinWidth;\n                        }\n                    }\n                }\n                for (i = 0; i < lanes.length; i++) {\n                    lanes[parseInt(i.toString(), 10)].width = (!isUndoRedo ? obj.wrapper.width : helperWidth);\n                }\n            }\n            else {\n                index = (shape.phaseSize && shape.phases.length > 0) ? index + 1 : index;\n                lanes[(obj.rowIndex - index)].height = (!isUndoRedo ? obj.wrapper.height : helperHeight);\n            }\n        }\n        else {\n            if (obj.isPhase) {\n                // phases[(obj.rowIndex - index)].offset = obj.wrapper.height;\n                for (var p = obj.rowIndex - index; p < phases.length; p++) {\n                    phases[parseInt(p.toString(), 10)].offset += heightDiff;\n                    //929543: To get the minHeight of phase and if the updated size less than min height then we set minHeight\n                    var curPhase = diagram.nameTable[phases[parseInt(p.toString(), 10)].header.id];\n                    if (curPhase) {\n                        var gridPhase = grid.rows[curPhase.rowIndex].cells[curPhase.columnIndex];\n                        var gridPhaseMinHeight = gridPhase.minHeight;\n                        if (phases[parseInt(p.toString(), 10)].offset < gridPhaseMinHeight) {\n                            phases[parseInt(p.toString(), 10)].offset = gridPhaseMinHeight;\n                        }\n                    }\n                }\n                for (j = 0; j < lanes.length; j++) {\n                    lanes[parseInt(j.toString(), 10)].height = obj.wrapper.height;\n                }\n            }\n            else {\n                index = (shape.phaseSize && shape.phases.length > 0) ? 1 : 0;\n                lanes[(obj.columnIndex - index)].width = obj.wrapper.width;\n            }\n        }\n    }\n}\n/**\n * findLaneIndex method \\\n *\n * @returns {number} findLaneIndex method .\\\n * @param {NodeModel} swimLane - provide the diagram  value.\n * @param {NodeModel} laneObj - provide the obj  value.\n * @private\n */\nfunction findLaneIndex(swimLane, laneObj) {\n    var laneIndex;\n    var shape = swimLane.shape;\n    var index = (shape.header && shape.hasHeader) ? 1 : 0;\n    if (shape.orientation === 'Horizontal') {\n        index += shape.phases.length > 0 ? 1 : 0;\n        laneIndex = laneObj.rowIndex - index;\n    }\n    else {\n        laneIndex = laneObj.columnIndex - (shape.phaseSize && shape.phases.length > 0 ? 1 : 0);\n    }\n    return laneIndex;\n}\n/**\n * findPhaseIndex method \\\n *\n * @returns {number} findPhaseIndex method .\\\n * @param {NodeModel} phase - provide the diagram  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\nfunction findPhaseIndex(phase, swimLane) {\n    var shape = swimLane.shape;\n    var index = (shape.header && shape.hasHeader) ? 1 : 0;\n    var phaseIndex = (shape.orientation === 'Horizontal') ? phase.columnIndex : phase.rowIndex - index;\n    return phaseIndex;\n}\n/**\n * findStartLaneIndex method \\\n *\n * @returns {number} findStartLaneIndex method .\\\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\nfunction findStartLaneIndex(swimLane) {\n    var index = 0;\n    var shape = swimLane.shape;\n    if (shape.orientation === 'Horizontal') {\n        index = (shape.header && shape.hasHeader) ? 1 : 0;\n    }\n    if (shape.phases.length > 0 && shape.phaseSize) {\n        index += 1;\n    }\n    return index;\n}\n/**\n * updatePhaseMaxWidth method \\\n *\n * @returns {void} updatePhaseMaxWidth method .\\\n * @param {NodeModel} parent - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @param {Canvas} wrapper - provide the obj  value.\n * @param {number} columnIndex - provide the obj  value.\n * @private\n */\nfunction updatePhaseMaxWidth(parent, diagram, wrapper, columnIndex) {\n    var shape = parent.shape;\n    if (shape.phases.length > 0) {\n        var node = diagram.nameTable[shape.phases[parseInt(columnIndex.toString(), 10)].header.id];\n        if (node && node.maxWidth < wrapper.outerBounds.width) {\n            node.maxWidth = wrapper.outerBounds.width;\n            node.wrapper.maxWidth = wrapper.outerBounds.width;\n        }\n    }\n}\n/**\n * updateHeaderMaxWidth method \\\n *\n * @returns {void} updateHeaderMaxWidth method .\\\n * @param {NodeModel} diagram - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\nfunction updateHeaderMaxWidth(diagram, swimLane) {\n    if (swimLane.shape.header && swimLane.shape.hasHeader) {\n        var grid = swimLane.wrapper.children[0];\n        var id = grid.rows[0].cells[0].children[0].id;\n        var headerNode = diagram.nameTable[\"\" + id];\n        if (headerNode && headerNode.isHeader && (headerNode.maxWidth < swimLane.width || headerNode.wrapper.maxWidth < swimLane.width)) {\n            headerNode.maxWidth = swimLane.width;\n            headerNode.wrapper.maxWidth = swimLane.width;\n        }\n    }\n}\n/**\n * addLane method \\\n *\n * @returns {void} addLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} parent - provide the obj  value.\n * @param {LaneModel} lane - provide the obj  value.\n * @param {number} count - provide the obj  value.\n * @private\n */\nfunction addLane(diagram, parent, lane, count) {\n    var args;\n    var swimLane = diagram.nameTable[parent.id];\n    if (swimLane.shape.type === 'SwimLane') {\n        diagram.protectPropertyChange(true);\n        var grid = swimLane.wrapper.children[0];\n        var bounds = grid.bounds;\n        var shape = swimLane.shape;\n        var redoObj = void 0;\n        var orientation_1 = false;\n        var entry = void 0;\n        var index = void 0;\n        var children = void 0;\n        var j = void 0;\n        var i = void 0;\n        var c = void 0;\n        var cell = void 0;\n        var child = void 0;\n        var point = void 0;\n        var laneObj = new _objects_node__WEBPACK_IMPORTED_MODULE_0__.Lane(shape, 'lanes', lane, true);\n        //To set default height and width incase of undefined height or width.\n        lane.height = lane.height || laneObj.height;\n        lane.width = lane.width || laneObj.width;\n        //913805-perform undo/redo for headerless swimlane,the change won't be properly reverted.\n        index = (shape.orientation === 'Vertical') ? 1 : (shape.header && shape.hasHeader) ? 1 : 0;\n        if (shape.orientation === 'Horizontal') {\n            orientation_1 = true;\n            index = shape.phases.length > 0 ? index + 1 : index;\n        }\n        var connectors = getConnectors(diagram, grid, 0, true);\n        var laneIndex = (count !== undefined) ? count : shape.lanes.length;\n        index += laneIndex;\n        args = {\n            element: laneObj, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changing', type: 'Addition', cancel: false, laneIndex: laneIndex\n        };\n        diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramEvent.collectionChange, args);\n        if (!args.cancel) {\n            if (orientation_1) {\n                var rowDef = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.RowDefinition();\n                rowDef.height = lane.height;\n                grid.addRow(index, rowDef, false);\n                swimLane.height = (swimLane.height !== undefined) ? swimLane.height + lane.height : swimLane.height;\n                swimLane.wrapper.height = grid.height = swimLane.height;\n            }\n            else {\n                var colDef = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.ColumnDefinition();\n                colDef.width = lane.width;\n                grid.addColumn(laneIndex + 1, colDef, false);\n                if (swimLane.width) {\n                    swimLane.width += lane.width;\n                    swimLane.wrapper.width = grid.width = swimLane.width;\n                }\n                //913805-Headerless vertical swimlane phase header get vanished.\n                if (shape.hasHeader) {\n                    grid.rows[0].cells[0].columnSpan += 1;\n                }\n            }\n            if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n                laneObj.id = (laneObj.id === '') ? (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)() : laneObj.id;\n            }\n            if (count !== undefined) {\n                shape.lanes.splice(count, 0, laneObj);\n            }\n            else {\n                shape.lanes.push(laneObj);\n            }\n            args = {\n                element: laneObj, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changed', type: 'Addition', cancel: false, laneIndex: laneIndex\n            };\n            diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramEvent.collectionChange, args);\n            laneCollection(grid, diagram, swimLane, index, laneIndex, orientation_1);\n            redoObj = (shape.orientation === 'Horizontal') ?\n                diagram.nameTable[grid.rows[parseInt(index.toString(), 10)].cells[0].children[0].id] :\n                ((shape.header && shape.hasHeader) ?\n                    diagram.nameTable[grid.rows[1].cells[parseInt(index.toString(), 10)].children[0].id] :\n                    diagram.nameTable[grid.rows[0].cells[parseInt(index.toString(), 10)].children[0].id]);\n            if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n                entry = {\n                    type: 'LaneCollectionChanged', changeType: 'Insert', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(laneObj),\n                    redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(redoObj), category: 'Internal'\n                };\n                diagram.addHistoryEntry(entry);\n            }\n            var startRowIndex = (shape.orientation === 'Horizontal') ?\n                index : ((shape.header && shape.hasHeader) ? 1 : 0);\n            ChangeLaneIndex(diagram, swimLane, startRowIndex);\n            swimLaneMeasureAndArrange(swimLane);\n            updateHeaderMaxWidth(diagram, swimLane);\n            children = lane.children;\n            var childAdded = false;\n            if (children && children.length > 0) {\n                for (j = 0; j < children.length; j++) {\n                    childAdded = false;\n                    child = children[parseInt(j.toString(), 10)];\n                    point = { x: child.wrapper.offsetX, y: child.wrapper.offsetY };\n                    var padding = { left: 0, right: 0, top: 0, bottom: 0 };\n                    if (shape.orientation === 'Horizontal') {\n                        padding.bottom = bounds.y - grid.bounds.y;\n                        //839579 - swimlane delete Lane and perform undo redo issue\n                        cell = grid.rows[parseInt(index.toString(), 10)].cells[parseInt(j.toString(), 10)];\n                        for (i = 0; i < grid.rows[parseInt(index.toString(), 10)].cells.length; i++) {\n                            addChildNodeToNewLane(diagram, grid.rows[parseInt(index.toString(), 10)].cells[parseInt(i.toString(), 10)], point, child, padding);\n                        }\n                    }\n                    else {\n                        //Bug 876330: After performing cut operations followed by an undo, lanes and nodes in the swimlane are not rendered properly.\n                        // To iterate the lane and check whether the child node is inside the vertical lane. If so then we cut the loop.\n                        // eslint-disable-next-line no-labels\n                        childAddBreak: for (var r = 0; r <= grid.rows.length; r++) {\n                            for (c = 0; c < grid.rows[parseInt(r.toString(), 10)].cells.length; c++) {\n                                //Padding to compensate the original position of swimlane before drag.\n                                padding.right = bounds.x - grid.bounds.x;\n                                cell = grid.rows[parseInt(r.toString(), 10)].cells[parseInt(c.toString(), 10)];\n                                childAdded = addChildNodeToNewLane(diagram, cell, point, child, padding);\n                                if (childAdded) {\n                                    // eslint-disable-next-line no-labels\n                                    break childAddBreak;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            updateConnectorsProperties(connectors, diagram);\n            diagram.drag(swimLane, bounds.x - grid.bounds.x, bounds.y - grid.bounds.y);\n        }\n        diagram.protectPropertyChange(false);\n    }\n}\n/**\n * addChildNodeToNewLane method \\\n *\n * @returns {void} addChildNodeToNewLane method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridCell} cell - provide the cell  value.\n * @param {PointModel} point - provide the point  value.\n * @param {NodeModel} child - provide the child  value.\n * @param {MarginModel | number} padding - provide the padding value.\n * @private\n */\nfunction addChildNodeToNewLane(diagram, cell, point, child, padding) {\n    var childAdded = false;\n    if (cell.children && cell.children.length > 0) {\n        var canvas = cell.children[0];\n        var parent_1 = diagram.nameTable[canvas.id];\n        if (containsChildPoint(canvas.bounds, point, padding)) {\n            diagram.addChild(parent_1, child);\n            childAdded = true;\n        }\n    }\n    return childAdded;\n}\n/**\n * containsChildPoint method \\\n *\n * @returns {boolean} containsChildPoint method .\\\n * @param {Rect} bounds - provide the bounds  value.\n * @param {PointModel} point - provide the point  value.\n * @param {MarginModel} padding - provide the padding  value.\n * @private\n */\nfunction containsChildPoint(bounds, point, padding) {\n    var leftPadding = padding.left || 0;\n    var rightPadding = padding.right || 0;\n    var topPadding = padding.top || 0;\n    var bottomPadding = padding.bottom || 0;\n    return bounds.left - leftPadding <= point.x && bounds.right + rightPadding >= point.x\n        && bounds.top - topPadding <= point.y && bounds.bottom + bottomPadding >= point.y;\n}\n/**\n * addPhase method \\\n *\n * @returns {void} addPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} parent - provide the cell  value.\n * @param {PhaseModel} newPhase - provide the point  value.\n * @private\n */\nfunction addPhase(diagram, parent, newPhase) {\n    if (parent.shape.type === 'SwimLane') {\n        var gridRowIndex = void 0;\n        var gridColIndex = void 0;\n        var phaseNode = void 0;\n        var phase = void 0;\n        var previousPhase = void 0;\n        var nextPhase = void 0;\n        var phaseIndex = void 0;\n        var i = void 0;\n        var x = parent.wrapper.bounds.x;\n        var y = parent.wrapper.bounds.y;\n        var shape = parent.shape;\n        var padding = shape.padding;\n        var phasesCollection = shape.phases;\n        var width = void 0;\n        var grid = parent.wrapper.children[0];\n        var orientation_2 = shape.orientation === 'Horizontal' ? true : false;\n        gridRowIndex = (shape.header && shape.hasHeader) ? 0 : -1;\n        if (shape.phases.length > 0) {\n            gridRowIndex += 1;\n            gridColIndex = 0;\n        }\n        var laneHeaderSize = (orientation_2) ? shape.lanes[0].header.width : shape.lanes[0].header.height;\n        if (newPhase.offset > laneHeaderSize) {\n            for (i = 0; i < phasesCollection.length; i++) {\n                phase = phasesCollection[parseInt(i.toString(), 10)];\n                previousPhase = (i > 0) ? phasesCollection[i - 1] : phase;\n                if (phase.offset > newPhase.offset) {\n                    width = (i > 0) ? newPhase.offset - previousPhase.offset : newPhase.offset;\n                    if (orientation_2) {\n                        var nextCol = grid.columnDefinitions()[parseInt(i.toString(), 10)];\n                        nextCol.width -= width;\n                        nextPhase = diagram.nameTable[shape.phases[parseInt(i.toString(), 10)].header.id];\n                        nextPhase.maxWidth = nextPhase.wrapper.maxWidth = nextCol.width;\n                        grid.updateColumnWidth(i, nextCol.width, false);\n                        var addPhase_1 = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.ColumnDefinition();\n                        addPhase_1.width = width;\n                        phaseIndex = i;\n                        grid.addColumn(i, addPhase_1, false);\n                        break;\n                    }\n                    else {\n                        var nextRow = grid.rowDefinitions()[i + gridRowIndex];\n                        nextRow.height -= width;\n                        nextPhase = diagram.nameTable[shape.phases[parseInt(i.toString(), 10)].header.id];\n                        grid.updateRowHeight(i + gridRowIndex, nextRow.height, false);\n                        var addPhase_2 = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.RowDefinition();\n                        addPhase_2.height = width;\n                        phaseIndex = i;\n                        grid.addRow(i + gridRowIndex, addPhase_2, false);\n                        break;\n                    }\n                }\n            }\n            if (diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo && phaseIndex === undefined) {\n                var entry = diagram.historyManager.currentEntry.next;\n                if (entry.isLastPhase) {\n                    phaseIndex = phasesCollection.length;\n                    addLastPhase(phaseIndex, parent, entry, grid, orientation_2, newPhase);\n                }\n            }\n            //897967: Exception throws while perform addPhase with offset higher than existing phases offset\n            if (phaseIndex >= 0) {\n                var phaseObj = new _objects_node__WEBPACK_IMPORTED_MODULE_0__.Phase((parent.shape), 'phases', newPhase, true);\n                if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n                    phaseObj.id += (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)();\n                }\n                shape.phases.splice(phaseIndex, 0, phaseObj);\n                phaseDefine(grid, diagram, parent, gridRowIndex, orientation_2, phaseIndex);\n                if (orientation_2) {\n                    phaseNode = diagram.nameTable[grid.rows[parseInt(gridRowIndex.toString(), 10)].cells[parseInt(phaseIndex.toString(), 10)].children[0].id];\n                    if (phaseIndex === 0 && shape.header && shape.hasHeader) {\n                        grid.rows[0].cells[0].children = grid.rows[0].cells[1].children;\n                        grid.rows[0].cells[1].children = [];\n                        var fristRow = grid.rows[0];\n                        for (var i_2 = 0; i_2 < fristRow.cells.length; i_2++) {\n                            fristRow.cells[parseInt(i_2.toString(), 10)].minWidth = undefined;\n                            if (i_2 === 0) {\n                                fristRow.cells[parseInt(i_2.toString(), 10)].columnSpan = grid.rows[0].cells.length;\n                            }\n                            else {\n                                fristRow.cells[parseInt(i_2.toString(), 10)].columnSpan = 1;\n                            }\n                        }\n                    }\n                    addHorizontalPhase(diagram, parent, grid, phaseIndex, orientation_2, newPhase);\n                    var col = grid.columnDefinitions();\n                    grid.updateColumnWidth(phaseIndex, col[parseInt(phaseIndex.toString(), 10)].width, true, padding);\n                    phaseNode.maxWidth = phaseNode.wrapper.maxWidth = col[parseInt(phaseIndex.toString(), 10)].width;\n                    if (col.length > phaseIndex + 1) {\n                        var nextPhaseNode = diagram.nameTable[grid.rows[parseInt(gridRowIndex.toString(), 10)].cells[phaseIndex + 1].children[0].id];\n                        grid.updateColumnWidth(phaseIndex + 1, col[phaseIndex + 1].width, true, padding);\n                        nextPhaseNode.maxWidth = nextPhaseNode.wrapper.maxWidth = col[phaseIndex + 1].width;\n                    }\n                    parent.width = parent.wrapper.width = parent.wrapper.children[0].width = grid.width;\n                }\n                else {\n                    phaseNode = diagram.nameTable[grid.rows[gridRowIndex + phaseIndex].cells[0].children[0].id];\n                    var row = grid.rowDefinitions();\n                    var size = row[gridRowIndex + phaseIndex].height;\n                    addVerticalPhase(diagram, parent, grid, gridRowIndex + phaseIndex, orientation_2, newPhase);\n                    grid.updateRowHeight(gridRowIndex + phaseIndex, size, true, padding);\n                    if (row.length > gridRowIndex + phaseIndex + 1) {\n                        size = row[gridRowIndex + phaseIndex + 1].height;\n                        grid.updateRowHeight(gridRowIndex + phaseIndex + 1, size, true, padding);\n                    }\n                    parent.height = parent.wrapper.height = parent.wrapper.children[0].height = grid.actualSize.height;\n                }\n                swimLaneMeasureAndArrange(parent);\n                parent.width = parent.wrapper.actualSize.width;\n                updateHeaderMaxWidth(diagram, parent);\n                diagram.drag(parent, x - parent.wrapper.bounds.x, y - parent.wrapper.bounds.y);\n                checkPhaseOffset(parent, diagram);\n                //911372-Lane Selector not updated after adding new phase at runtime\n                diagram.commandHandler.select(phaseNode);\n                if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n                    var entry = {\n                        type: 'PhaseCollectionChanged', changeType: 'Insert', undoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(phaseObj),\n                        redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(phaseNode), category: 'Internal'\n                    };\n                    diagram.addHistoryEntry(entry);\n                }\n                diagram.updateDiagramObject(parent);\n            }\n        }\n    }\n}\n/**\n * addLastPhase method \\\n *\n * @returns {void} addLastPhase method .\\\n * @param {number} phaseIndex - provide the diagram  value.\n * @param {NodeModel} parent - provide the cell  value.\n * @param {HistoryEntry} entry - provide the point  value.\n * @param {GridPanel} grid - provide the grid  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {PhaseModel} newPhase - provide the newPhase  value.\n * @private\n */\nfunction addLastPhase(phaseIndex, parent, entry, grid, orientation, newPhase) {\n    var shape = parent.shape;\n    var prevPhase = shape.phases[phaseIndex - 2];\n    var prevOffset = entry.previousPhase.offset;\n    if (orientation) {\n        var nextCol = grid.columnDefinitions()[phaseIndex - 1];\n        var addPhase_3 = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.ColumnDefinition();\n        if (phaseIndex > 1) {\n            addPhase_3.width = (nextCol.width) - (prevOffset - prevPhase.offset);\n            nextCol.width = prevOffset - prevPhase.offset;\n        }\n        else {\n            addPhase_3.width = nextCol.width - prevOffset;\n            nextCol.width = prevOffset;\n        }\n        grid.updateColumnWidth(phaseIndex - 1, nextCol.width, false);\n        grid.addColumn(phaseIndex, addPhase_3, false);\n    }\n    else {\n        var nextCol = grid.rowDefinitions()[parseInt(phaseIndex.toString(), 10)];\n        var addPhase_4 = new _core_containers_grid__WEBPACK_IMPORTED_MODULE_1__.RowDefinition();\n        if (phaseIndex > 1) {\n            addPhase_4.height = entry.undoObject.offset - prevOffset;\n            nextCol.height = prevOffset - prevPhase.offset;\n        }\n        else {\n            addPhase_4.height = nextCol.height - prevOffset;\n            nextCol.height = prevOffset;\n        }\n        grid.updateRowHeight(phaseIndex, nextCol.height, false);\n        grid.addRow(1 + phaseIndex, addPhase_4, false);\n    }\n}\n/**\n * addHorizontalPhase method \\\n *\n * @returns {void} addHorizontalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the cell  value.\n * @param {GridPanel} grid - provide the point  value.\n * @param {number} index - provide the point  value.\n * @param {boolean} orientation - provide the point  value.\n * @param {PhaseModel} newPhase - provide the phase value.\n * @private\n */\nfunction addHorizontalPhase(diagram, node, grid, index, orientation, newPhase) {\n    var shape = node.shape;\n    var nextCell;\n    var i;\n    var prevCell;\n    var gridCell;\n    var row;\n    var laneIndex = findStartLaneIndex(node);\n    if (shape.header && shape.hasHeader) {\n        grid.rows[0].cells[0].columnSpan = grid.rows[0].cells.length;\n    }\n    for (i = laneIndex; i < grid.rows.length; i++) {\n        row = grid.rows[parseInt(i.toString(), 10)];\n        prevCell = row.cells[index - 1];\n        gridCell = row.cells[parseInt(index.toString(), 10)];\n        nextCell = row.cells[index + 1];\n        addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, i, index, newPhase);\n    }\n    ChangeLaneIndex(diagram, node, 1);\n}\n/**\n * addVerticalPhase method \\\n *\n * @returns {void} addVerticalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the cell  value.\n * @param {GridPanel} grid - provide the point  value.\n * @param {number} rowIndex - provide the point  value.\n * @param {boolean} orientation - provide the point  value.\n * @param {PhaseModel} newPhase - provide the phase value.\n * @private\n */\nfunction addVerticalPhase(diagram, node, grid, rowIndex, orientation, newPhase) {\n    var prevCell;\n    var gridCell;\n    var nextCell;\n    var row = grid.rows[parseInt(rowIndex.toString(), 10)];\n    var nextRow = grid.rows[rowIndex + 1];\n    var prevRow = grid.rows[rowIndex - 1];\n    for (var i = 1; i < row.cells.length; i++) {\n        gridCell = row.cells[parseInt(i.toString(), 10)];\n        nextCell = (nextRow) ? nextRow.cells[parseInt(i.toString(), 10)] : undefined;\n        prevCell = (prevRow) ? prevRow.cells[parseInt(i.toString(), 10)] : undefined;\n        addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, i, newPhase);\n    }\n    ChangeLaneIndex(diagram, node, 1);\n}\n/**\n * addSwimlanePhases method \\\n *\n * @returns {void} addSwimlanePhases method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {GridPanel} prevCell - provide the prevCell  value.\n * @param {number} gridCell - provide the gridCell  value.\n * @param {boolean} nextCell - provide the nextCell  value.\n * @param {boolean} rowIndex - provide the rowIndex  value.\n * @param {boolean} columnIndex - provide the columnIndex  value.\n * @param {PhaseModel} newPhase - provide the phase value.\n * @private\n */\nfunction addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, columnIndex, newPhase) {\n    var x;\n    var y;\n    var shape = node.shape;\n    var orientation = shape.orientation === 'Horizontal' ? true : false;\n    var grid = node.wrapper.children[0];\n    var width = gridCell.desiredCellWidth;\n    var height = gridCell.desiredCellHeight;\n    //const col: number = (orientation) ? rowIndex : columnIndex;\n    //let parentWrapper: Container;\n    var j;\n    var i = (orientation) ? node.shape.hasHeader ? rowIndex : rowIndex + 1 : columnIndex;\n    if (prevCell) {\n        x = orientation ? prevCell.bounds.x + prevCell.bounds.width : prevCell.bounds.x;\n        y = orientation ? prevCell.bounds.y : prevCell.bounds.y + prevCell.bounds.height;\n    }\n    else {\n        x = grid.bounds.x;\n        y = nextCell.bounds.y;\n    }\n    var rect = new _primitives_rect__WEBPACK_IMPORTED_MODULE_8__.Rect(x, y, width, height);\n    // Bug-908135: Redoing the undoed phase collection followed by node collection threw exception.\n    var tempRowIndex = node.shape.hasHeader ? rowIndex - 1 : rowIndex;\n    var laneId = node.id + ((orientation) ? shape.lanes[i - 2] : shape.lanes[i - 1]).id;\n    var tempID = (orientation ? (columnIndex - 1) : (tempRowIndex - 1)).toString() +\n        (orientation ? columnIndex : tempRowIndex).toString();\n    var canvasID = laneId + tempID;\n    while (Object.prototype.hasOwnProperty.call(diagram.nameTable, canvasID)) {\n        tempID = (orientation ? (columnIndex - 1) : (tempRowIndex - 1)).toString() + tempID;\n        canvasID = laneId + tempID;\n    }\n    var canvas = {\n        id: canvasID,\n        rowIndex: rowIndex, columnIndex: columnIndex,\n        width: gridCell.minWidth, height: gridCell.minHeight,\n        style: ((orientation) ? shape.lanes[i - 2] : shape.lanes[i - 1]).style,\n        constraints: _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.Default | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.AllowDrop,\n        container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n    };\n    var headerIndex = shape.hasHeader ? 0 : -1;\n    //To set the old lane id while creating lanes in undo-redo\n    if (newPhase.laneGrids && newPhase.laneGrids.length > 0) {\n        var index = orientation ? (rowIndex - (2 + headerIndex)) : columnIndex - 1;\n        if (!diagram.nameTable[newPhase.laneGrids[parseInt(index.toString(), 10)]]) {\n            canvas.id = newPhase.laneGrids[parseInt(index.toString(), 10)];\n        }\n    }\n    //To store the lane ids in a collection while creating phase lanes\n    var phaseIndex = orientation ? columnIndex : rowIndex - 1;\n    if (shape.phases[parseInt(phaseIndex.toString(), 10)]) {\n        var phase = diagram.nameTable[shape.phases[parseInt(phaseIndex.toString(), 10)].header.id];\n        if (phase) {\n            phase.laneGrids.push(canvas.id);\n        }\n    }\n    var parentWrapper = addObjectToGrid(diagram, grid, node, canvas, false, false, true);\n    parentWrapper.children[0].isCalculateDesiredSize = false;\n    grid.addObject(parentWrapper, rowIndex, columnIndex);\n    if (nextCell && nextCell.children && nextCell.children.length) {\n        for (j = 0; j < nextCell.children.length; j++) {\n            if (orientation) {\n                diagram.nameTable[nextCell.children[parseInt(j.toString(), 10)].id].columnIndex += 1;\n            }\n            else {\n                diagram.nameTable[nextCell.children[parseInt(j.toString(), 10)].id].rowIndex += 1;\n            }\n        }\n    }\n    arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell);\n}\n/**\n * arrangeChildInGrid method \\\n *\n * @returns {void} arrangeChildInGrid method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridCell} nextCell - provide the nextCell  value.\n * @param {GridPanel} gridCell - provide the gridCell  value.\n * @param {Rect} rect - provide the rect  value.\n * @param {Container} parentWrapper - provide the parentWrapper  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {GridCell} prevCell - provide the prevCell  value.\n * @private\n */\nfunction arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell) {\n    var child;\n    var point;\n    var childNode;\n    var parent = diagram.nameTable[parentWrapper.id];\n    var changeCell = (!nextCell) ? prevCell : nextCell;\n    var swimLane = diagram.nameTable[parent.parentId];\n    var padding = swimLane.shape.padding;\n    if (changeCell.children && changeCell.children[0].children.length > 1) {\n        for (var j = 1; j < changeCell.children[0].children.length; j++) {\n            child = changeCell.children[0].children[parseInt(j.toString(), 10)];\n            childNode = diagram.nameTable[child.id];\n            point = (orientation) ? { x: child.bounds.x, y: child.bounds.center.y } :\n                { x: child.bounds.center.x, y: child.bounds.top };\n            if (rect.containsPoint(point)) {\n                gridCell.children[0].children.push(child);\n                changeCell.children[0].children.splice(j, 1);\n                j--;\n                diagram.deleteChild(childNode, undefined, true);\n                if (!childNode.isLane) {\n                    childNode.parentId = parentWrapper.id;\n                }\n                if (!parent.children) {\n                    parent.children = [];\n                }\n                if (!nextCell) {\n                    if (orientation) {\n                        childNode.margin.left = childNode.wrapper.bounds.x - changeCell.children[0].bounds.right;\n                    }\n                    else {\n                        childNode.margin.top = childNode.wrapper.bounds.y - changeCell.children[0].bounds.bottom;\n                    }\n                }\n                parent.children.push(child.id);\n                childNode.zIndex = parent.zIndex + 1;\n                diagram.removeElements(childNode);\n            }\n            else if (nextCell) {\n                if (orientation) {\n                    childNode.margin.left -= gridCell.desiredCellWidth;\n                    if (padding > childNode.margin.left) {\n                        childNode.margin.left = padding;\n                    }\n                }\n                else {\n                    childNode.margin.top -= gridCell.desiredCellHeight;\n                    if (padding > childNode.margin.top) {\n                        childNode.margin.top = padding;\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * swimLaneSelection method \\\n *\n * @returns {void} swimLaneSelection method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {string} corner - provide the corner  value.\n * @private\n */\nfunction swimLaneSelection(diagram, node, corner) {\n    if (node.shape.type === 'SwimLane' && (corner === 'ResizeSouth' || corner === 'ResizeEast')) {\n        var shape = node.shape;\n        var wrapper = node.wrapper.children[0];\n        var child = void 0;\n        var index = void 0;\n        if (corner === 'ResizeSouth') {\n            if (shape.orientation === 'Vertical') {\n                child = wrapper.rows[wrapper.rows.length - 1].cells[0];\n            }\n            else {\n                index = wrapper.rows.length - 1;\n                child = wrapper.rows[parseInt(index.toString(), 10)].cells[wrapper.rows[parseInt(index.toString(), 10)].cells.length - 1];\n            }\n        }\n        else {\n            index = (shape.header && shape.hasHeader) ? 1 : 0;\n            child = wrapper.rows[parseInt(index.toString(), 10)].cells[wrapper.rows[parseInt(index.toString(), 10)].cells.length - 1];\n        }\n        diagram.commandHandler.select(diagram.nameTable[child.children[0].id]);\n    }\n}\n/**\n * pasteSwimLane method \\\n *\n * @returns {void} pasteSwimLane method .\\\n * @param {Diagram} swimLane - provide the diagram  value.\n * @param {NodeModel} diagram - provide the diagram  value.\n * @param {string} clipboardData - provide the clipboardData  value.\n * @param {string} laneNode - provide the laneNode  value.\n * @param {string} isLane - provide the isLane  value.\n * @param {string} isUndo - provide the isUndo  value.\n * @private\n */\nfunction pasteSwimLane(swimLane, diagram, clipboardData, laneNode, isLane, isUndo) {\n    var i;\n    var j;\n    var lane;\n    var phase;\n    var node;\n    var ranId = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.randomId)();\n    var cloneLane;\n    var childX;\n    var childY;\n    var shape = swimLane.shape; //let lanes: LaneModel[];\n    var phases = shape.phases;\n    var nodeX = swimLane.offsetX - swimLane.wrapper.actualSize.width / 2;\n    var nodeY = swimLane.offsetY - swimLane.wrapper.actualSize.height / 2;\n    var childNodeIds = [];\n    if (shape.orientation === 'Vertical') {\n        nodeY += (shape.header && shape.hasHeader) ? shape.header.height : 0;\n    }\n    if (!isUndo) {\n        if (!isLane) {\n            swimLane.id += ranId;\n            if (shape && shape.header && shape.hasHeader) {\n                shape.header.id += ranId;\n            }\n            else {\n                shape.header = undefined;\n            }\n        }\n        for (i = 0; phases && i < phases.length; i++) {\n            phase = phases[parseInt(i.toString(), 10)];\n            phase.id += ranId;\n        }\n    }\n    var lanes = (isLane) ? [clipboardData.childTable[laneNode.id]] : shape.lanes;\n    for (i = 0; lanes && i < lanes.length; i++) {\n        lane = lanes[parseInt(i.toString(), 10)];\n        if (!isUndo) {\n            lane.id += ranId;\n        }\n        for (j = 0; lane.children && j < lane.children.length; j++) {\n            node = lane.children[parseInt(j.toString(), 10)];\n            childNodeIds.push(node.id);\n            childX = node.wrapper.offsetX - node.width / 2;\n            childY = node.wrapper.offsetY - node.height / 2;\n            node.zIndex = Number.MIN_VALUE;\n            node.inEdges = node.outEdges = [];\n            if (isUndo || (clipboardData && (clipboardData.pasteIndex === 1 || clipboardData.pasteIndex === 0))) {\n                if (shape.orientation === 'Vertical') {\n                    node.margin.top = childY - nodeY;\n                }\n                else {\n                    node.margin.left = childX - nodeX;\n                }\n            }\n            if (!isUndo) {\n                node.id += ranId;\n            }\n        }\n    }\n    if (!isUndo) {\n        if (isLane) {\n            var newShape = {\n                lanes: lanes,\n                phases: phases, phaseSize: shape.phaseSize,\n                type: 'SwimLane', orientation: shape.orientation,\n                header: { annotation: { content: 'Title' }, height: 50 }\n            };\n            cloneLane = { shape: newShape };\n            if (shape.orientation === 'Horizontal') {\n                //Facing issues with headerless horizontal swimlane paste.\n                var headerHeight = 0;\n                if (shape.hasHeader) {\n                    headerHeight = shape.header.height;\n                }\n                cloneLane.width = swimLane.wrapper.actualSize.width;\n                cloneLane.height = laneNode.wrapper.actualSize.height + headerHeight + shape.phaseSize;\n                cloneLane.offsetX = swimLane.wrapper.offsetX + (clipboardData.pasteIndex * 10);\n                cloneLane.offsetY = laneNode.wrapper.offsetY + (clipboardData.pasteIndex * 10);\n            }\n            else {\n                cloneLane.width = laneNode.wrapper.actualSize.width;\n                cloneLane.height = swimLane.wrapper.actualSize.height;\n                cloneLane.offsetX = laneNode.wrapper.offsetX + (clipboardData.pasteIndex * 10);\n                cloneLane.offsetY = swimLane.wrapper.offsetY + (clipboardData.pasteIndex * 10);\n            }\n            swimLane = cloneLane;\n        }\n        if (clipboardData.pasteIndex !== 0) {\n            swimLane.offsetX += 10;\n            swimLane.offsetY += 10;\n        }\n        swimLane.zIndex = Number.MIN_VALUE;\n        swimLane = diagram.add(swimLane);\n        if (!isLane) {\n            for (var _i = 0, _a = Object.keys(clipboardData.childTable); _i < _a.length; _i++) {\n                var i_3 = _a[_i];\n                var connector = clipboardData.childTable[\"\" + i_3];\n                //Internal Bug 909158: Connector disconnects inside swimlane.\n                //Added below code to avoid duplicate addition of connector when copy paste multiple swimlanes.\n                //Also to properly connect between child nodes of two swimlanes.\n                if (connector.parentSwimlaneId && connector.parentSwimlaneId + ranId === swimLane.id) {\n                    connector.id += ranId;\n                    if (childNodeIds.indexOf(connector.sourceID) !== -1) {\n                        connector.sourceID += ranId;\n                    }\n                    if (childNodeIds.indexOf(connector.targetID) !== -1) {\n                        connector.targetID += ranId;\n                    }\n                    connector.zIndex = Number.MIN_VALUE;\n                    diagram.add(connector);\n                }\n                else if (childNodeIds.indexOf(connector.sourceID) !== -1) {\n                    connector.sourceID += ranId;\n                }\n                else if (childNodeIds.indexOf(connector.targetID) !== -1) {\n                    connector.targetID += ranId;\n                }\n            }\n        }\n        if (diagram.mode !== 'SVG') {\n            diagram.refreshDiagramLayer();\n        }\n        diagram.select([swimLane]);\n    }\n    return swimLane;\n}\n/**\n * gridSelection method \\\n *\n * @returns {void} gridSelection method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {SelectorModel} selectorModel - provide the selectorModel  value.\n * @param {string} id - provide the id  value.\n * @param {boolean} isSymbolDrag - provide the isSymbolDrag  value.\n * @private\n */\nfunction gridSelection(diagram, selectorModel, id, isSymbolDrag) {\n    var canvas;\n    var node = selectorModel.nodes[0];\n    if (isSymbolDrag || (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_9__.checkParentAsContainer)(diagram, node, true)) {\n        var targetnode = void 0;\n        var bounds = void 0;\n        var swimLaneId = void 0;\n        var element = new _core_elements_diagram_element__WEBPACK_IMPORTED_MODULE_4__.DiagramElement();\n        if (id) {\n            swimLaneId = (diagram.nameTable[\"\" + id].parentId);\n            targetnode = node = diagram.nameTable[\"\" + id];\n        }\n        var wrapper = !id ? node.wrapper : targetnode.wrapper;\n        var parentNode = diagram.nameTable[swimLaneId || node.parentId];\n        if (parentNode && parentNode.container.type === 'Grid') {\n            canvas = new _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas();\n            canvas.children = [];\n            if (isSymbolDrag || !(node.isHeader)) {\n                if ((parentNode.container.orientation === 'Horizontal' && node.isPhase) ||\n                    (parentNode.container.orientation === 'Vertical' &&\n                        (node.rowIndex > 0 && node.columnIndex > 0 || node.isLane))) {\n                    bounds = (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_9__.findBounds)(parentNode, (targetnode) ? targetnode.columnIndex : node.columnIndex, (parentNode.shape.header && parentNode.shape.hasHeader) ? true : false);\n                    canvas.offsetX = bounds.center.x;\n                    canvas.offsetY = bounds.center.y;\n                    element.width = bounds.width;\n                    element.height = bounds.height;\n                }\n                else {\n                    canvas.offsetX = parentNode.offsetX;\n                    canvas.offsetY = wrapper.offsetY;\n                    element.width = parentNode.wrapper.actualSize.width;\n                    element.height = wrapper.actualSize.height;\n                }\n            }\n            canvas.children.push(element);\n            canvas.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size());\n            canvas.arrange(canvas.desiredSize);\n        }\n    }\n    return canvas;\n}\n/**\n * removeLaneChildNode method \\\n *\n * @returns {void} removeLaneChildNode method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} swimLaneNode - provide the diagram  value.\n * @param {NodeModel} currentObj - provide the currentObj  value.\n * @param {NodeModel} isChildNode - provide the isChildNode  value.\n * @param {number} laneIndex - provide the laneIndex  value.\n * @private\n */\nfunction removeLaneChildNode(diagram, swimLaneNode, currentObj, isChildNode, laneIndex) {\n    laneIndex = (laneIndex !== undefined) ? laneIndex : findLaneIndex(swimLaneNode, currentObj);\n    var preventHistory = false;\n    var lanenode = swimLaneNode.shape.lanes[parseInt(laneIndex.toString(), 10)];\n    for (var j = lanenode.children.length - 1; j >= 0; j--) {\n        if (isChildNode) {\n            if (isChildNode.id === lanenode.children[parseInt(j.toString(), 10)].id) {\n                lanenode.children.splice(j, 1);\n            }\n        }\n        else {\n            diagram.removeDependentConnector(lanenode.children[parseInt(j.toString(), 10)]);\n            if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n                diagram.diagramActions = diagram.diagramActions | _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n                preventHistory = true;\n            }\n            diagram.remove(lanenode.children[parseInt(j.toString(), 10)]);\n            lanenode.children.splice(j, 1);\n            if (preventHistory) {\n                diagram.diagramActions = diagram.diagramActions & ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo;\n            }\n        }\n    }\n}\n/**\n * getGridChildren method \\\n *\n * @returns {DiagramElement} getGridChildren method .\\\n * @param {Diagram} obj - provide the obj  value.\n * @private\n */\nfunction getGridChildren(obj) {\n    var children = obj.children[0];\n    return children;\n}\n/**\n * removeSwimLane method \\\n *\n * @returns {void} removeSwimLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} obj - provide the obj  value.\n * @private\n */\nfunction removeSwimLane(diagram, obj) {\n    var rows = obj.wrapper.children[0].rows;\n    //let preventHistory: boolean = false;\n    var node;\n    var i;\n    var j;\n    var k;\n    var child;\n    var removeNode;\n    for (i = 0; i < rows.length; i++) {\n        for (j = 0; j < rows[parseInt(i.toString(), 10)].cells.length; j++) {\n            child = getGridChildren(rows[parseInt(i.toString(), 10)].cells[parseInt(j.toString(), 10)]);\n            if (child && child.children) {\n                for (k = child.children.length - 1; k >= 0; k--) {\n                    if (child.children[parseInt(k.toString(), 10)].children) {\n                        removeNode = diagram.nameTable[child.children[parseInt(k.toString(), 10)].id];\n                        if (removeNode) {\n                            if (removeNode.isLane) {\n                                deleteNode(diagram, removeNode);\n                            }\n                            else {\n                                diagram.removeDependentConnector(removeNode);\n                                diagram.diagramActions |= _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.PreventHistory;\n                                if ((removeNode.constraints & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.NodeConstraints.Delete)) {\n                                    diagram.remove(removeNode);\n                                }\n                                else {\n                                    (0,_interaction_container_interaction__WEBPACK_IMPORTED_MODULE_9__.removeChildInContainer)(diagram, removeNode, {}, false);\n                                }\n                                diagram.diagramActions &= ~_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.PreventHistory;\n                            }\n                        }\n                    }\n                }\n            }\n            if (child) {\n                node = diagram.nameTable[child.id];\n                if (node) {\n                    deleteNode(diagram, node);\n                }\n            }\n        }\n    }\n}\n/**\n * deleteNode method \\\n *\n * @returns {void} deleteNode method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} node - provide the obj  value.\n * @private\n */\nfunction deleteNode(diagram, node) {\n    if (node) {\n        diagram.nodes.splice(diagram.nodes.indexOf(node), 1);\n        diagram.removeFromAQuad(node);\n        diagram.removeObjectsFromLayer(node);\n        delete diagram.nameTable[node.id];\n        diagram.removeElements(node);\n    }\n}\n/**\n * removeLane method \\\n *\n * @returns {void} removeLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} lane - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @param {LaneModel} lanes - provide the obj  value.\n * @private\n */\nfunction removeLane(diagram, lane, swimLane, lanes) {\n    var args;\n    if (swimLane.shape.type === 'SwimLane') {\n        var shape = swimLane.shape;\n        var laneIndex = void 0;\n        if (shape.lanes.length === 1) {\n            diagram.remove(swimLane);\n        }\n        else {\n            var x = swimLane.wrapper.bounds.x;\n            var y = swimLane.wrapper.bounds.y;\n            var row = void 0;\n            var i = void 0;\n            var cell = void 0;\n            var j = void 0;\n            var child = void 0;\n            var grid = swimLane.wrapper.children[0];\n            laneIndex = (lanes) ? (shape.lanes.indexOf(lanes)) : findLaneIndex(swimLane, lane);\n            args = {\n                element: lane, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changing', type: 'Removal', cancel: false, laneIndex: laneIndex\n            };\n            diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramEvent.collectionChange, args);\n            if (!args.cancel) {\n                var removableLane = shape.lanes[parseInt(laneIndex.toString(), 10)];\n                //Bug 876330: After performing cut operations followed by an undo, lanes and nodes in the swimlane are not rendered properly.\n                //Here we are removing the children from lane and re-adding it to the lane after getting it from diagram nodes collection.\n                //Because the wrapper of nodes are not updated properly after undo operation.\n                var removableLaneChild = removableLane.children;\n                removableLane.children = [];\n                for (var i_4 = 0; i_4 < removableLaneChild.length; i_4++) {\n                    var child_1 = diagram.getObject(removableLaneChild[parseInt(i_4.toString(), 10)].id);\n                    if (child_1) {\n                        removableLane.children.push(child_1);\n                    }\n                }\n                var undoObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(shape.lanes[parseInt(laneIndex.toString(), 10)]);\n                removeLaneChildNode(diagram, swimLane, lane, undefined, laneIndex);\n                if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n                    var entry = {\n                        type: 'LaneCollectionChanged', changeType: 'Remove', undoObject: undoObj,\n                        redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(lane), category: 'Internal'\n                    };\n                    diagram.addHistoryEntry(entry);\n                }\n                shape.lanes.splice(laneIndex, 1);\n                var index = (lane) ? (shape.orientation === 'Horizontal' ? lane.rowIndex : lane.columnIndex) :\n                    (findStartLaneIndex(swimLane) + laneIndex);\n                if (shape.orientation === 'Horizontal') {\n                    row = grid.rows[parseInt(index.toString(), 10)];\n                    for (i = 0; i < row.cells.length; i++) {\n                        cell = row.cells[parseInt(i.toString(), 10)];\n                        if (cell && cell.children.length > 0) {\n                            for (j = 0; j < cell.children.length; j++) {\n                                child = cell.children[parseInt(j.toString(), 10)];\n                                removeChildren(diagram, child);\n                                //To remove the lane Id from the laneGrid collection of phase\n                                removeLaneGridFromPhase(child, swimLane, diagram);\n                            }\n                        }\n                    }\n                    grid.removeRow(index);\n                }\n                else {\n                    swimLane.width = (swimLane.width !== undefined) ?\n                        swimLane.width - grid.rows[0].cells[parseInt(index.toString(), 10)].actualSize.width : swimLane.width;\n                    for (i = 0; i < grid.rows.length; i++) {\n                        cell = grid.rows[parseInt(i.toString(), 10)].cells[parseInt(index.toString(), 10)];\n                        if (cell && cell.children.length > 0) {\n                            for (j = 0; j < cell.children.length; j++) {\n                                child = cell.children[parseInt(j.toString(), 10)];\n                                removeChildren(diagram, child);\n                                //To remove the lane Id from the laneGrid collection of phase\n                                removeLaneGridFromPhase(child, swimLane, diagram);\n                            }\n                        }\n                    }\n                    grid.removeColumn(index);\n                }\n                args = {\n                    element: lane, cause: diagram.diagramActions, diagramAction: diagram.getDiagramAction(diagram.diagramActions), state: 'Changed', type: 'Removal', cancel: false, laneIndex: laneIndex\n                };\n                diagram.triggerEvent(_enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramEvent.collectionChange, args);\n                swimLane.width = swimLane.wrapper.width = grid.width;\n                swimLane.height = swimLane.wrapper.height = grid.height;\n                swimLaneMeasureAndArrange(swimLane);\n                if (swimLane.shape.orientation === 'Vertical') {\n                    index = 0;\n                }\n                ChangeLaneIndex(diagram, swimLane, index);\n                diagram.drag(swimLane, x - swimLane.wrapper.bounds.x, y - swimLane.wrapper.bounds.y);\n                diagram.updateDiagramObject(swimLane);\n            }\n        }\n    }\n}\n/**\n * removeLaneGridFromPhase method \\\n *\n * @returns {void} removeLaneGridFromPhase method .\\\n * @param {Canvas} child - provide the child lane value.\n * @param {Swimlane} swimlane - provide the swimlane value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nfunction removeLaneGridFromPhase(child, swimlane, diagram) {\n    var id = child.id;\n    var phases = swimlane.shape.phases;\n    if (phases && phases.length > 0) {\n        for (var i = 0; i < phases.length; i++) {\n            var phaseId = swimlane.id + phases[parseInt(i.toString(), 10)].id + '_header';\n            var phase = diagram.nameTable[\"\" + phaseId];\n            var index = phase.laneGrids.indexOf(id);\n            if (index !== -1) {\n                phase.laneGrids.splice(index, 1);\n            }\n        }\n    }\n}\n/**\n * removeChildren method \\\n *\n * @returns {void} removeChildren method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {Canvas} canvas - provide the obj  value.\n * @private\n */\nfunction removeChildren(diagram, canvas) {\n    var i;\n    var node;\n    if (canvas instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas) {\n        if (canvas.children.length > 0) {\n            for (i = 0; i < canvas.children.length; i++) {\n                if (canvas.children[parseInt(i.toString(), 10)] instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas) {\n                    removeChildren(diagram, canvas.children[parseInt(i.toString(), 10)]);\n                }\n            }\n        }\n        node = diagram.getObject(canvas.id);\n        deleteNode(diagram, node);\n    }\n}\n/**\n * removePhase method \\\n *\n * @returns {void} removePhase method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} phase - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @param {PhaseModel} swimLanePhases - provide the obj  value.\n * @private\n */\nfunction removePhase(diagram, phase, swimLane, swimLanePhases) {\n    diagram.protectPropertyChange(true);\n    var x = swimLane.wrapper.bounds.x;\n    var y = swimLane.wrapper.bounds.y;\n    var isLastPhase = false;\n    var previousPhase;\n    var shape = swimLane.shape;\n    var grid = swimLane.wrapper.children[0];\n    var phaseIndex = swimLanePhases ? shape.phases.indexOf(swimLanePhases) : findPhaseIndex(phase, swimLane);\n    var phaseLength = shape.phases.length;\n    if (shape.phases.length > 1) {\n        if (phaseIndex === phaseLength - 1) {\n            isLastPhase = true;\n            previousPhase = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(shape.phases[phaseIndex - 1]);\n        }\n        var undoObj = (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(shape.phases[parseInt(phaseIndex.toString(), 10)]);\n        shape.phases.splice(phaseIndex, 1);\n        if (!(diagram.diagramActions & _enum_enum__WEBPACK_IMPORTED_MODULE_2__.DiagramAction.UndoRedo)) {\n            var entry = {\n                type: 'PhaseCollectionChanged', changeType: 'Remove', undoObject: undoObj, previousPhase: previousPhase,\n                redoObject: (0,_utility_base_util__WEBPACK_IMPORTED_MODULE_3__.cloneObject)(phase), category: 'Internal', isLastPhase: isLastPhase\n            };\n            //Adding laneGrid colelction values to the undo and redo object to use it for creating the lane ids in undo-redo.\n            entry.undoObject.laneGrids = phase.laneGrids;\n            entry.redoObject.laneGrids = phase.laneGrids;\n            diagram.addHistoryEntry(entry);\n        }\n        if (shape.orientation === 'Horizontal') {\n            removeHorizontalPhase(diagram, grid, phase, phaseIndex);\n        }\n        else {\n            removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane);\n        }\n        updateHeaderMaxWidth(diagram, swimLane);\n        //878835- selecting swimlane phase after deleting first phase wihtout header throws error\n        ChangeLaneIndex(diagram, swimLane, swimLane.isHeader ? 1 : 0);\n        checkPhaseOffset(swimLane, diagram);\n        diagram.protectPropertyChange(false);\n        diagram.updateDiagramObject(swimLane);\n    }\n}\n/**\n * removeHorizontalPhase method \\\n *\n * @returns {void} removeHorizontalPhase method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {GridPanel} grid - provide the obj  value.\n * @param {NodeModel} phase - provide the obj  value.\n * @param {number} phaseIndex - provide the obj  value.\n * @private\n */\nfunction removeHorizontalPhase(diagram, grid, phase, phaseIndex) {\n    var row;\n    var cell;\n    var prevCell;\n    var actualChild; //let prevChild: Canvas;\n    var prevCanvas;\n    var width;\n    phaseIndex = (phaseIndex !== undefined) ? phaseIndex : phase.columnIndex;\n    var i;\n    var j;\n    var k;\n    var child;\n    var node;\n    var object;\n    for (i = 0; i < grid.rows.length; i++) {\n        row = grid.rows[parseInt(i.toString(), 10)];\n        if (row.cells.length > 1) {\n            cell = row.cells[parseInt(phaseIndex.toString(), 10)];\n            prevCell = (row.cells.length - 1 === phaseIndex) ? row.cells[phaseIndex - 1] :\n                row.cells[phaseIndex + 1];\n            prevCanvas = prevCell.children[0];\n            if (cell.children.length > 0) {\n                actualChild = cell.children[0];\n                node = diagram.nameTable[actualChild.id];\n                if (prevCell.children.length === 0 && cell.children.length > 0) {\n                    prevCell.children = cell.children;\n                    prevCell.columnSpan = cell.columnSpan - 1;\n                }\n                else {\n                    for (j = 0; j < actualChild.children.length; j++) {\n                        child = actualChild.children[parseInt(j.toString(), 10)];\n                        if (child instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas) {\n                            object = diagram.nameTable[child.id];\n                            if (!object.isLane) {\n                                object.parentId = prevCanvas.id;\n                            }\n                            if ((row.cells.length - 1 === phaseIndex)) {\n                                object.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;\n                                child.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;\n                            }\n                            prevCanvas.children.push(child);\n                            if (diagram.nameTable[prevCanvas.id]) {\n                                var parentNode = diagram.nameTable[prevCanvas.id];\n                                if (!parentNode.children) {\n                                    parentNode.children = [];\n                                }\n                                parentNode.children.push(child.id);\n                            }\n                            actualChild.children.splice(j, 1);\n                            j--;\n                            if (node && node.children && node.children.indexOf(object.id) !== -1) {\n                                node.children.splice(node.children.indexOf(object.id), 1);\n                            }\n                        }\n                        if ((row.cells.length - 1 !== phaseIndex)) {\n                            for (k = 0; k < prevCanvas.children.length; k++) {\n                                var prevChild = prevCanvas.children[parseInt(k.toString(), 10)];\n                                if (prevChild instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas) {\n                                    var prevNode = diagram.nameTable[prevChild.id];\n                                    prevNode.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;\n                                    prevChild.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;\n                                }\n                            }\n                        }\n                    }\n                    if (node && node.isPhase) {\n                        var object_1 = diagram.nameTable[prevCanvas.id];\n                        if (object_1) {\n                            prevCanvas.maxWidth = object_1.wrapper.maxWidth = object_1.wrapper.maxWidth += node.wrapper.maxWidth;\n                        }\n                    }\n                    deleteNode(diagram, node);\n                }\n            }\n        }\n    }\n    var prevWidth = grid.columnDefinitions()[parseInt(phaseIndex.toString(), 10)].width;\n    grid.removeColumn(phaseIndex);\n    if ((phaseIndex < grid.columnDefinitions().length)) {\n        width = grid.columnDefinitions()[parseInt(phaseIndex.toString(), 10)].width;\n        width += prevWidth;\n        grid.updateColumnWidth(phaseIndex, width, true);\n    }\n    else {\n        width = grid.columnDefinitions()[phaseIndex - 1].width;\n        width += prevWidth;\n        grid.updateColumnWidth(phaseIndex - 1, width, true);\n    }\n}\n/**\n * removeVerticalPhase method \\\n *\n * @returns {void} removeVerticalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridPanel} grid - provide the grid  value.\n * @param {NodeModel} phase - provide the phase  value.\n * @param {number} phaseIndex - provide the phaseIndex  value.\n * @param {number} swimLane - provide the swimLane  value.\n * @private\n */\nfunction removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane) {\n    var cell;\n    var height;\n    var i;\n    var j;\n    var k;\n    var prevCell;\n    var prevChild;\n    var shape = swimLane.shape;\n    var child;\n    var object;\n    var phaseRowIndex = (phaseIndex !== undefined) ? ((shape.header) ? phaseIndex + 1 : phaseIndex) : phase.rowIndex;\n    var row = grid.rows[parseInt(phaseRowIndex.toString(), 10)];\n    var top = swimLane.wrapper.bounds.y;\n    var phaseCount = shape.phases.length;\n    if (shape.header !== undefined && shape.hasHeader) {\n        top += grid.rowDefinitions()[0].height;\n    }\n    var prevRow = (phaseIndex === phaseCount) ? grid.rows[phaseRowIndex - 1] : grid.rows[phaseRowIndex + 1];\n    for (i = 0; i < row.cells.length; i++) {\n        cell = row.cells[parseInt(i.toString(), 10)];\n        prevCell = prevRow.cells[parseInt(i.toString(), 10)];\n        prevChild = prevCell.children[0];\n        if (cell.children.length > 0) {\n            var children = cell.children[0];\n            var node = diagram.nameTable[children.id];\n            if (phaseIndex < phaseCount) {\n                for (k = 0; k < prevChild.children.length; k++) {\n                    child = prevChild.children[parseInt(k.toString(), 10)];\n                    if (child instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas) {\n                        object = diagram.nameTable[child.id];\n                        object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);\n                        child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);\n                    }\n                }\n            }\n            for (j = 0; j < children.children.length; j++) {\n                child = children.children[parseInt(j.toString(), 10)];\n                if (child instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas) {\n                    object = diagram.nameTable[child.id];\n                    object.parentId = prevChild.id;\n                    if (phaseIndex === phaseCount) {\n                        object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);\n                        child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);\n                    }\n                    prevChild.children.push(child);\n                    children.children.splice(j, 1);\n                    j--;\n                    if (node.children && node.children.indexOf(object.id) !== -1) {\n                        node.children.splice(node.children.indexOf(object.id), 1);\n                    }\n                }\n            }\n            deleteNode(diagram, node);\n        }\n    }\n    var prevHeight = grid.rowDefinitions()[parseInt(phaseRowIndex.toString(), 10)].height;\n    grid.removeRow(phaseRowIndex);\n    if ((phaseRowIndex < grid.rowDefinitions().length)) {\n        height = grid.rowDefinitions()[parseInt(phaseRowIndex.toString(), 10)].height;\n        height += prevHeight;\n        grid.updateRowHeight(phaseRowIndex, height, true);\n    }\n    else {\n        height = grid.rowDefinitions()[phaseRowIndex - 1].height;\n        height += prevHeight;\n        grid.updateRowHeight(phaseRowIndex - 1, height, true);\n    }\n}\n/**\n * considerSwimLanePadding method \\\n *\n * @returns {void} considerSwimLanePadding method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the grid  value.\n * @param {number} padding - provide the phase  value.\n * @private\n */\nfunction considerSwimLanePadding(diagram, node, padding) {\n    var lane = diagram.nameTable[node.parentId];\n    if (lane && lane.isLane) {\n        var swimLane = diagram.nameTable[lane.parentId];\n        var grid = swimLane.wrapper.children[0];\n        //let x: number = swimLane.wrapper.bounds.x; let y: number = swimLane.wrapper.bounds.y;\n        if (!diagram.multiselect) {\n            grid.updateColumnWidth(lane.columnIndex, grid.columnDefinitions()[lane.columnIndex].width, true, padding);\n            grid.updateRowHeight(lane.rowIndex, grid.rowDefinitions()[lane.rowIndex].height, true, padding);\n        }\n        var canvas = lane.wrapper;\n        var laneHeader = void 0;\n        var isConsiderHeader = false;\n        //For Multi-selected nodes\n        node.diffX = node.diffX || 0;\n        node.diffY = node.diffY || 0;\n        if (node.diffX > 0) {\n            node.margin.left += (node.diffX + padding);\n        }\n        if (node.diffY > 0) {\n            node.margin.top += (node.diffY + padding);\n        }\n        if (node.margin.left < padding) {\n            node.margin.left = padding;\n        }\n        if (node.margin.top < padding) {\n            node.margin.top = padding;\n        }\n        for (var i = 0; i < canvas.children.length; i++) {\n            var child = canvas.children[parseInt(i.toString(), 10)];\n            if (child instanceof _core_containers_canvas__WEBPACK_IMPORTED_MODULE_7__.Canvas) {\n                var childNode = diagram.nameTable[child.id];\n                if (childNode.isLane) {\n                    laneHeader = childNode.wrapper;\n                    isConsiderHeader = true;\n                    break;\n                }\n            }\n        }\n        if (laneHeader) {\n            if (swimLane.shape.orientation === 'Horizontal') {\n                if (node.margin.left < padding + laneHeader.actualSize.width) {\n                    node.margin.left = padding + laneHeader.actualSize.width;\n                }\n            }\n            else {\n                if (node.margin.top < padding + laneHeader.actualSize.height) {\n                    node.margin.top = padding + laneHeader.actualSize.height;\n                }\n            }\n        }\n        swimLane.wrapper.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(swimLane.width, swimLane.height));\n        swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);\n        node.offsetX = node.wrapper.offsetX;\n        node.offsetY = node.wrapper.offsetY;\n        diagram.nodePropertyChange(node, {}, { margin: { left: node.margin.left, top: node.margin.top } });\n        node.isResized = false;\n        //EJ2-68372- Text-Annotation in event node is not positioned properly while drag the swimlane\n        // if (diagram.bpmnModule && node.shape.type === 'Bpmn' && (node.shape as BpmnShapeModel).annotations &&  (node.shape as BpmnShapeModel).annotations.length > 0) {\n        //     diagram.nodePropertyChange(node as Node, {} as Node, { margin: { left: node.margin.left, top: node.margin.top } } as Node);\n        // }\n        grid.measure(new _primitives_size__WEBPACK_IMPORTED_MODULE_6__.Size(grid.width, grid.height));\n        grid.arrange(grid.desiredSize);\n        swimLane.width = swimLane.wrapper.width = swimLane.wrapper.children[0].actualSize.width;\n        swimLane.height = swimLane.wrapper.height = swimLane.wrapper.children[0].actualSize.height;\n    }\n}\n/**\n * checkLaneChildrenOffset method \\\n *\n * @returns {void} checkLaneChildrenOffset method .\\\n * @param {NodeModel} swimLane - provide the diagram  value.\n * @private\n */\nfunction checkLaneChildrenOffset(swimLane) {\n    if (swimLane.shape.type === 'SwimLane') {\n        var lanes = swimLane.shape.lanes;\n        var lane = void 0;\n        var child = void 0;\n        for (var i = 0; i < lanes.length; i++) {\n            lane = lanes[parseInt(i.toString(), 10)];\n            for (var j = 0; j < lane.children.length; j++) {\n                child = lane.children[parseInt(j.toString(), 10)];\n                child.offsetX = child.wrapper.offsetX;\n                child.offsetY = child.wrapper.offsetY;\n            }\n        }\n    }\n}\n/**\n * findLane method \\\n *\n * @returns {LaneModel} findLane method .\\\n * @param {Node} laneNode - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nfunction findLane(laneNode, diagram) {\n    var lane;\n    if (laneNode.isLane) {\n        var swimLane = diagram.getObject(laneNode.parentId);\n        if (swimLane && swimLane.shape.type === 'SwimLane' && laneNode.isLane) {\n            var laneIndex = findLaneIndex(swimLane, laneNode);\n            lane = swimLane.shape.lanes[parseInt(laneIndex.toString(), 10)];\n        }\n    }\n    return lane;\n}\n/**\n * Checks if node and its parent got selected\n *\n * @param {Node} node - node to check, if its parent got selected with it.\n * @param {Diagram} diagram - provide the diagram value.\n * @returns {boolean} whether node and its parent got selected or not.\n * @private\n */\nfunction isParentNodeSelected(node, diagram) {\n    return node.parentId && diagram.selectedItems.nodes.indexOf(diagram.nameTable[node.parentId]) !== -1;\n}\n/**\n * Checks two different sub lane nodes are a representation of the same lane.\n *\n * @param {Node} node1 - Provide the node to compare to.\n * @param {Node} node2 - Provide the node to compare with.\n * @param {Diagram} diagram - Provide the diagram value.\n * @returns {boolean} Whether two nodes are representation of the same lane.\n * @private\n */\nfunction checkSameLaneNodes(node1, node2, diagram) {\n    if ((node1.isLane && node2.isLane) && node1.id !== node2.id && node1.parentId === node2.parentId) {\n        if (findLane(node1, diagram) === findLane(node2, diagram)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * canLaneInterchange method \\\n *\n * @returns {boolean} canLaneInterchange method .\\\n * @param {Node} laneNode - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nfunction canLaneInterchange(laneNode, diagram) {\n    if (laneNode.isLane) {\n        var lane = findLane(laneNode, diagram);\n        var eventHandler = 'eventHandler';\n        var resize = diagram[\"\" + eventHandler].action;\n        var canResize = resize.includes('Resize');\n        if (canResize || lane.canMove) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * updateSwimLaneChildPosition method \\\n *\n * @returns {void} updateSwimLaneChildPosition method .\\\n * @param {Lane[]} lanes - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nfunction updateSwimLaneChildPosition(lanes, diagram) {\n    var lane;\n    var node;\n    for (var i = 0; i < lanes.length; i++) {\n        lane = lanes[parseInt(i.toString(), 10)];\n        for (var j = 0; j < lane.children.length; j++) {\n            node = diagram.nameTable[lane.children[parseInt(j.toString(), 10)].id];\n            node.offsetX = node.wrapper.offsetX;\n            node.offsetY = node.wrapper.offsetY;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js?");

/***/ })

}]);