"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_chart_series_range-a"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/range-area-series.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/range-area-series.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RangeAreaSeries: () => (/* binding */ RangeAreaSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _line_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `RangeAreaSeries` module is used to render the range area series.\n */\nvar RangeAreaSeries = /** @class */ (function (_super) {\n    __extends(RangeAreaSeries, _super);\n    function RangeAreaSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.borderDirection = '';\n        return _this;\n    }\n    /**\n     * Renders the provided Range Area series on the chart based on the given x-axis, y-axis, and inversion status.\n     *\n     * @param {Series} series - The series to render.\n     * @param {Axis} xAxis - The x-axis of the chart.\n     * @param {Axis} yAxis - The y-axis of the chart.\n     * @param {boolean} inverted - A flag indicating whether the chart is inverted or not.\n     * @param {boolean} pointAnimate - A flag indicating whether the points should be animated.\n     * @param {boolean} pointUpdate - A flag indicating whether the points should be updated.\n     * @returns {void}\n     * @private\n     */\n    RangeAreaSeries.prototype.render = function (series, xAxis, yAxis, inverted, pointAnimate, pointUpdate) {\n        var point;\n        var direction = '';\n        var command = 'M';\n        var closed = undefined;\n        var borderWidth = series.border.width ? series.border.width : 0;\n        var borderColor = series.border.color ? series.border.color : series.interior;\n        var visiblePoints = this.enableComplexProperty(series);\n        for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {\n            point = visiblePoints[i];\n            point.symbolLocations = [];\n            point.regions = [];\n            var low = Math.min(point.low, point.high);\n            var high = Math.max(point.low, point.high);\n            if (yAxis.isAxisInverse) {\n                var temp = low;\n                low = high;\n                high = temp;\n            }\n            var lowPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, low, xAxis, yAxis, inverted);\n            var highPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, high, xAxis, yAxis, inverted);\n            point.symbolLocations.push(highPoint);\n            point.symbolLocations.push(lowPoint);\n            var rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));\n            if (!inverted) {\n                rect.x -= series.marker.width / 2;\n            }\n            else {\n                rect.y -= series.marker.width / 2;\n            }\n            point.regions.push(rect);\n            //Path to connect the high points\n            if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n                direction = direction.concat(command + ' ' + (lowPoint.x) + ' ' + (lowPoint.y) + ' ');\n                this.borderDirection += (command + ' ' + (lowPoint.x) + ' ' + (lowPoint.y) + ' ');\n                closed = false;\n                if ((i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible)\n                    || i === visiblePoints.length - 1) {\n                    // Path to connect the low points\n                    direction = this.closeRangeAreaPath(visiblePoints, point, series, direction, i);\n                    command = 'M';\n                    direction = direction.concat(' ' + 'Z');\n                    closed = true;\n                }\n                command = 'L';\n            }\n            else {\n                if (closed === false && i !== 0) {\n                    direction = this.closeRangeAreaPath(visiblePoints, point, series, direction, i);\n                    closed = true;\n                }\n                command = 'M';\n                point.symbolLocations = [];\n            }\n        }\n        var name = series.category === 'Indicator' ? series.chart.element.id + '_Indicator_' + series.index + '_' + series.name :\n            series.chart.element.id + '_Series_' + series.index;\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(name, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);\n        this[pointAnimate ? 'addPath' : 'appendLinePath'](options, series, '');\n        /**\n         * To draw border for the path directions of area\n         */\n        if (series.border.width !== 0) {\n            this[pointAnimate ? 'addPath' : 'appendLinePath'](new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.border.dashArray, this.borderDirection), series, '');\n            this.borderDirection = '';\n        }\n        if (!pointUpdate) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * path for rendering the low points\n     *\n     * @returns {void}.\n     * @private\n     */\n    RangeAreaSeries.prototype.closeRangeAreaPath = function (visiblePoints, point, series, direction, i) {\n        for (var j = i; j >= 0; j--) {\n            if (visiblePoints[j].visible && visiblePoints[j].symbolLocations[0]) {\n                point = visiblePoints[j];\n                direction += 'L' + ' ' + (point.symbolLocations[0].x) + ' ' + ((point.symbolLocations[0].y)) + ' ';\n                this.borderDirection += (j === i ? 'M' : 'L') + ' ' + (point.symbolLocations[0].x) + ' ' + ((point.symbolLocations[0].y)) + ' ';\n            }\n            else {\n                break;\n            }\n        }\n        return direction;\n    };\n    /**\n     * To animate point for range area series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    RangeAreaSeries.prototype.updateDirection = function (series, point) {\n        this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n        var _loop_1 = function (i) {\n            if (series.marker && series.marker.visible) {\n                series.points[point[i]].symbolLocations.map(function (location, index) {\n                    series.chart.markerRender.renderMarker(series, series.points[point[i]], location, index, true);\n                });\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        };\n        for (var i = 0; i < point.length; i++) {\n            _loop_1(i);\n        }\n    };\n    RangeAreaSeries.prototype.addPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = startPathCommands.length; i < endPathCommands.length; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.splice((startPathCommands.length - 1) / 2, 0, startPathCommands.slice(0, (startPathCommands.length - 1) / 2).pop(), startPathCommands.slice(0, ((startPathCommands.length - 1) / 2) + 1).pop());\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        endPathCommands.splice(1, 0, endPathCommands[0]);\n                        endPathCommands.splice(endPathCommands.length - 2, 0, endPathCommands[endPathCommands.length - 2]);\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    RangeAreaSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    RangeAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'RangeAreaSeries';\n    };\n    /**\n     * To destroy the line series.\n     *\n     * @returns {void}\n     * @private\n     */\n    RangeAreaSeries.prototype.destroy = function () {\n        /**\n         * Destroys range area series.\n         */\n    };\n    return RangeAreaSeries;\n}(_line_base__WEBPACK_IMPORTED_MODULE_2__.LineBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/range-area-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/range-column-series.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/range-column-series.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RangeColumnSeries: () => (/* binding */ RangeColumnSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _column_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./column-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/column-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n/**\n * The `RangeColumnSeries` module is used to render the range column series.\n */\nvar RangeColumnSeries = /** @class */ (function (_super) {\n    __extends(RangeColumnSeries, _super);\n    function RangeColumnSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sideBySideInfo = [];\n        return _this;\n    }\n    /**\n     * Renders the Range Column series.\n     *\n     * @param {Series} series - The series to render.\n     * @returns {void}\n     * @private\n     */\n    RangeColumnSeries.prototype.render = function (series) {\n        this.sideBySideInfo[series.index] = this.getSideBySideInfo(series);\n        //let origin: number = Math.max(<number>series.yAxis.visibleRange.min, 0);\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var rangePoint = _a[_i];\n            this.renderPoint(series, rangePoint, this.sideBySideInfo[series.index]);\n        }\n        this.renderMarker(series);\n    };\n    RangeColumnSeries.prototype.renderPoint = function (series, rangePoint, sideBySideInfo) {\n        var rect;\n        rangePoint.symbolLocations = [];\n        rangePoint.regions = [];\n        if (rangePoint.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(series.points[rangePoint.index - 1], rangePoint, series.points[rangePoint.index + 1], series)) {\n            rect = this.getRectangle(rangePoint.xValue + sideBySideInfo.start, rangePoint.high, rangePoint.xValue + sideBySideInfo.end, rangePoint.low, series);\n            rect.width = series.columnWidthInPixel ? series.columnWidthInPixel : rect.width;\n            rect.x = series.columnWidthInPixel ? rect.x - (((series.columnWidthInPixel / 2) * series.rectCount) -\n                (series.columnWidthInPixel * series.index)) : rect.x;\n            var argsData = this.triggerEvent(series, rangePoint, series.interior, { width: series.border.width, color: series.border.color });\n            if (!argsData.cancel) {\n                this.updateSymbolLocation(rangePoint, rect, series);\n                this.drawRectangle(series, rangePoint, rect, argsData);\n            }\n        }\n    };\n    RangeColumnSeries.prototype.updateDirection = function (series, point) {\n        var _loop_1 = function (i) {\n            this_1.renderPoint(series, series.points[point[i]], this_1.sideBySideInfo[series.index]);\n            if (series.marker && series.marker.visible) {\n                series.points[point[i]].symbolLocations.map(function (location, index) {\n                    series.chart.markerRender.renderMarker(series, series.points[point[i]], location, index, true);\n                });\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        };\n        var this_1 = this;\n        for (var i = 0; i < point.length; i++) {\n            _loop_1(i);\n        }\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    RangeColumnSeries.prototype.getModuleName = function () {\n        return 'RangeColumnSeries';\n        /**\n         * return the module name.\n         */\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    RangeColumnSeries.prototype.doAnimation = function (series) {\n        this.animate(series);\n    };\n    /**\n     * To destroy the range column series.\n     *\n     * @returns {void}\n     * @private\n     */\n    RangeColumnSeries.prototype.destroy = function () {\n        /**\n         * Destroy method performed here.\n         */\n    };\n    return RangeColumnSeries;\n}(_column_base__WEBPACK_IMPORTED_MODULE_1__.ColumnBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/range-column-series.js?");

/***/ }),

/***/ "./node_modules/@syncfusion/ej2-charts/src/chart/series/range-step-area-series.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/chart/series/range-step-area-series.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RangeStepAreaSeries: () => (/* binding */ RangeStepAreaSeries)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _line_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-base */ \"./node_modules/@syncfusion/ej2-charts/src/chart/series/line-base.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/**\n * The `RangeStepAreaSeries` module is used to render the range step area series.\n */\nvar RangeStepAreaSeries = /** @class */ (function (_super) {\n    __extends(RangeStepAreaSeries, _super);\n    function RangeStepAreaSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.borderDirection = '';\n        _this.prevPoint = null;\n        return _this;\n    }\n    /**\n     * Renders the Range Step Area series on the chart.\n     *\n     * @param {Series} series - The series to be rendered.\n     * @param {Axis} xAxis - The x-axis associated with the series.\n     * @param {Axis} yAxis - The y-axis associated with the series.\n     * @param {boolean} isInverted - Specifies whether the series is inverted.\n     * @param {boolean} pointAnimate - Specifies whether to animate the series point.\n     * @param {boolean} pointUpdate - Specifies whether to update the previous point.\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.render = function (series, xAxis, yAxis, isInverted, pointAnimate, pointUpdate) {\n        this.prevPoint = null;\n        var point;\n        var currentPoint;\n        var secondPoint;\n        var start = null;\n        var direction = '';\n        var lineLength = 0;\n        var command = 'M';\n        var closed = undefined;\n        var low;\n        var high;\n        var borderWidth = series.border.width ? series.border.width : 0;\n        var borderColor = series.border.color ? series.border.color : series.interior;\n        var origin = Math.max(series.yAxis.visibleRange.min, 0);\n        var visiblePoints = this.enableComplexProperty(series);\n        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n            lineLength = 0.5;\n        }\n        for (var i = 0, length_1 = visiblePoints.length; i < length_1; i++) {\n            point = visiblePoints[i];\n            point.symbolLocations = [];\n            point.regions = [];\n            low = Math.min(point.low, point.high);\n            high = Math.max(point.low, point.high);\n            if (yAxis.isAxisInverse) {\n                var temp = low;\n                low = high;\n                high = temp;\n            }\n            var lowPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, low, xAxis, yAxis, isInverted);\n            var highPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, high, xAxis, yAxis, isInverted);\n            point.symbolLocations.push(highPoint);\n            point.symbolLocations.push(lowPoint);\n            var rect = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(Math.min(lowPoint.x, highPoint.x), Math.min(lowPoint.y, highPoint.y), Math.max(Math.abs(highPoint.x - lowPoint.x), series.marker.width), Math.max(Math.abs(highPoint.y - lowPoint.y), series.marker.width));\n            point.regions.push(rect);\n            //Path to connect the high points.\n            if (point.visible && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withInRange)(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n                if (start === null) {\n                    start = new _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.ChartLocation(point.xValue, 0);\n                    // Start point for the current path.\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue - lineLength, origin, xAxis, yAxis, isInverted);\n                    direction += (command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue - lineLength, point.high > point.low ? point.high\n                        : point.low, xAxis, yAxis, isInverted);\n                    direction += ('L' + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                    this.borderDirection += (command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ');\n                }\n                // First Point to draw the RangeStepArea path.\n                if (this.prevPoint != null) {\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.high > point.low ? point.high\n                        : point.low, xAxis, yAxis, isInverted);\n                    secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(this.prevPoint.xValue, this.prevPoint.high > this.prevPoint.low ? this.prevPoint.high\n                        : this.prevPoint.low, xAxis, yAxis, isInverted);\n                    direction += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, false));\n                    this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step, command, series, true));\n                }\n                else if (series.emptyPointSettings.mode === 'Gap') {\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.high > point.low ? point.high\n                        : point.low, xAxis, yAxis, isInverted);\n                    direction += command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';\n                    this.borderDirection += command + ' ' + (currentPoint.x) + ' ' + (currentPoint.y) + ' ';\n                }\n                closed = false;\n                command = ' L';\n                this.prevPoint = point;\n                if ((i + 1 < visiblePoints.length && !visiblePoints[i + 1].visible)\n                    || i === visiblePoints.length - 1) {\n                    // Path to connect the low points.\n                    direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);\n                    command = 'M';\n                    direction = direction.concat(' ' + 'Z ');\n                    closed = true;\n                    this.prevPoint = null;\n                    start = null;\n                }\n            }\n            else {\n                if (closed === false && i !== 0) {\n                    direction = this.closeRangeStepAreaPath(visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted);\n                    closed = true;\n                }\n                command = 'M';\n                point.symbolLocations = [];\n            }\n        }\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_' + series.index, series.interior, 0, 'transparent', series.opacity, series.dashArray, direction);\n        this[pointAnimate ? 'addPath' : 'appendLinePath'](options, series, '');\n        /**\n         * To draw border for the range step area chart.\n         */\n        if (series.border.width !== 0) {\n            this[pointAnimate ? 'addPath' : 'appendLinePath'](new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(series.chart.element.id + '_Series_border_' + series.index, 'transparent', borderWidth, borderColor, 1, series.border.dashArray, this.borderDirection), series, '');\n            this.borderDirection = '';\n        }\n        if (!pointUpdate) {\n            this.renderMarker(series);\n        }\n    };\n    /**\n     * Calculating path direction for rendering the low points.\n     *\n     * @param {Points[]} visiblePoints - The visible data points.\n     * @param {Points} point - The current data point.\n     * @param {Series} series - The series to which the data point belongs.\n     * @param {string} direction - The direction of the series.\n     * @param {number} i - The index of the current data point.\n     * @param {Axis} xAxis - The x-axis associated with the series.\n     * @param {Axis} yAxis - The y-axis associated with the series.\n     * @param {boolean} isInverted - Specifies whether the series is inverted.\n     * @returns {string} - Returns the path direction for low direction.\n     * @private\n     */\n    RangeStepAreaSeries.prototype.closeRangeStepAreaPath = function (visiblePoints, point, series, direction, i, xAxis, yAxis, isInverted) {\n        var currentPoint;\n        var secondPoint;\n        var low;\n        var high;\n        for (var j = i; j >= 0; j--) {\n            if (visiblePoints[j].visible) {\n                point = visiblePoints[j];\n                low = Math.min(point.low, point.high);\n                high = Math.max(point.low, point.high);\n                if (yAxis.isAxisInverse) {\n                    var temp = low;\n                    low = high;\n                    high = temp;\n                }\n                // Lowpoint for RangeStepArea path.\n                if (this.prevPoint != null) {\n                    currentPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(point.xValue, point.low < point.high ? point.low\n                        : point.high, xAxis, yAxis, isInverted);\n                    secondPoint = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.getPoint)(this.prevPoint.xValue, this.prevPoint.low < this.prevPoint.high ? this.prevPoint.low\n                        : this.prevPoint.high, xAxis, yAxis, isInverted);\n                    direction += (this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : (series.step === 'Left' ? 'Right' : series.step), 'L', series, false));\n                    if (j === i) {\n                        this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : (series.step === 'Left' ? 'Right' : series.step), 'M', series, true));\n                    }\n                    else {\n                        this.borderDirection += (this.GetStepLineDirection(currentPoint, secondPoint, series.step === 'Right' ? 'Left' : (series.step === 'Left' ? 'Right' : series.step), 'L', series, true));\n                    }\n                }\n            }\n            else {\n                break;\n            }\n            this.prevPoint = point;\n        }\n        return direction;\n    };\n    /**\n     * To animate point for range step area series.\n     *\n     * @param {Series} series - Specifies the series.\n     * @param {number} point - Specifies the point.\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.updateDirection = function (series, point) {\n        this.render(series, series.xAxis, series.yAxis, series.chart.requireInvertedAxis, false, true);\n        var _loop_1 = function (i) {\n            if (series.marker && series.marker.visible) {\n                series.points[point[i]].symbolLocations.map(function (location, index) {\n                    series.chart.markerRender.renderMarker(series, series.points[point[i]], location, index, true);\n                });\n            }\n            if (series.marker.dataLabel.visible && series.chart.dataLabelModule) {\n                series.chart.dataLabelModule.commonId = series.chart.element.id + '_Series_' + series.index + '_Point_';\n                series.chart.dataLabelModule.renderDataLabel(series, series.points[point[i]], null, series.marker.dataLabel);\n            }\n        };\n        for (var i = 0; i < point.length; i++) {\n            _loop_1(i);\n        }\n    };\n    RangeStepAreaSeries.prototype.addPath = function (options, series, clipRect) {\n        var points = this.appendPathElement(options, series, clipRect);\n        if (points.previousDirection !== '' && options.d !== '') {\n            var startPathCommands = points.previousDirection.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var endPathCommands = (options.d).match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n            var minLength = Math.min(startPathCommands.length, endPathCommands.length);\n            if (startPathCommands.length < endPathCommands.length) {\n                for (var i = startPathCommands.length; i < endPathCommands.length; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        startPathCommands.splice((Math.floor((startPathCommands.length / 2)) - 1), 0, startPathCommands[Math.floor((startPathCommands.length / 2)) - 1], startPathCommands[Math.floor((startPathCommands.length / 2)) - 1]);\n                        startPathCommands.splice((Math.floor((startPathCommands.length / 2)) + 2), 0, startPathCommands[Math.floor((startPathCommands.length / 2)) + 2], startPathCommands[Math.floor((startPathCommands.length / 2)) + 2]);\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, startPathCommands.join(' '), this.chart.duration);\n            }\n            else if (startPathCommands.length > endPathCommands.length) {\n                for (var i = minLength; i < maxLength; i++) {\n                    if (endPathCommands.length !== startPathCommands.length) {\n                        endPathCommands.splice(2, 0, endPathCommands[2]);\n                        endPathCommands.splice(endPathCommands.length - 3, 0, endPathCommands[endPathCommands.length - 3]);\n                    }\n                }\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, endPathCommands.join(''), series.chart.redraw, points.previousDirection, this.chart.duration, options.d);\n            }\n            else {\n                (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.animateAddPoints)(points.element, options.d, series.chart.redraw, points.previousDirection, this.chart.duration);\n            }\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    /**\n     * Get module name.\n     *\n     * @returns {string} - Returns the module name.\n     */\n    RangeStepAreaSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series.\n         */\n        return 'RangeStepAreaSeries';\n    };\n    /**\n     * To destroy the range step area series.\n     *\n     * @returns {void}\n     * @private\n     */\n    RangeStepAreaSeries.prototype.destroy = function () {\n        /**\n         * Destroys range step area series.\n         */\n    };\n    return RangeStepAreaSeries;\n}(_line_base__WEBPACK_IMPORTED_MODULE_2__.LineBase));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/chart/series/range-step-area-series.js?");

/***/ })

}]);