"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkej2_vue_samples"] = self["webpackChunkej2_vue_samples"] || []).push([["chunk-vendors-node_modules_syncfusion_ej2-charts_src_range-navigator_renderer_range-axis_js-12b50670"],{

/***/ "./node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/range-axis.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/range-axis.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RangeNavigatorAxis: () => (/* binding */ RangeNavigatorAxis)\n/* harmony export */ });\n/* harmony import */ var _common_utils_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/utils/helper */ \"./node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js\");\n/* harmony import */ var _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @syncfusion/ej2-svg-base */ \"./node_modules/@syncfusion/ej2-svg-base/index.js\");\n/* harmony import */ var _chart_axis_date_time_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../chart/axis/date-time-axis */ \"./node_modules/@syncfusion/ej2-charts/src/chart/axis/date-time-axis.js\");\n/* harmony import */ var _chart_axis_axis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chart/axis/axis */ \"./node_modules/@syncfusion/ej2-charts/src/chart/axis/axis.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * class for axis\n */\nvar RangeNavigatorAxis = /** @class */ (function (_super) {\n    __extends(RangeNavigatorAxis, _super);\n    function RangeNavigatorAxis(range) {\n        var _this = _super.call(this) || this;\n        _this.firstLevelLabels = [];\n        _this.secondLevelLabels = [];\n        _this.rangeNavigator = range;\n        return _this;\n    }\n    /**\n     * To render grid lines of axis.\n     *\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.renderGridLines = function () {\n        var pointX = 0;\n        var control = this.rangeNavigator;\n        var majorGridLines = control.majorGridLines;\n        var majorTickLines = control.majorTickLines;\n        var majorGrid = '';\n        var majorTick = '';\n        var rect = control.bounds;\n        var chartAxis = control.chartSeries.xAxis;\n        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;\n        this.gridLines = control.renderer.createGroup({ id: control.element.id + '_GridLines' });\n        var tick = (control.tickPosition === 'Outside' || control.series.length === 0) ?\n            rect.y + rect.height + majorTickLines.height : rect.y + rect.height - majorTickLines.height;\n        //Gridlines\n        this.firstLevelLabels = [];\n        chartAxis.labelStyle = control.labelStyle;\n        chartAxis.skeleton = control.skeleton;\n        chartAxis.skeletonType = control.skeletonType;\n        chartAxis.isChart = false;\n        if (control.valueType.indexOf('DateTime') > -1) {\n            var interval = this.calculateDateTimeNiceInterval(chartAxis, rect, chartAxis.doubleRange.start, chartAxis.doubleRange.end, chartAxis.isChart);\n            if (control.valueType === 'DateTime') {\n                this.findAxisLabels(chartAxis, interval);\n            }\n            this.actualIntervalType = chartAxis.actualIntervalType;\n            if (control.valueType === 'DateTimeCategory' && (this.actualIntervalType === 'Quarter' || this.actualIntervalType === 'Weeks')) {\n                this.findSecondaryAxisLabels(chartAxis);\n            }\n        }\n        this.firstLevelLabels = chartAxis.visibleLabels;\n        this.lowerValues = [];\n        var labelLength = chartAxis.visibleLabels.length;\n        for (var i = 0; i < labelLength; i++) {\n            this.lowerValues.push(this.firstLevelLabels[i].value);\n            pointX = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)(this.firstLevelLabels[i].value, chartAxis) * rect.width) + rect.x;\n            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\n                majorGrid = majorGrid.concat('M ' + pointX + ' ' + (control.bounds.y + control.bounds.height) +\n                    ' L ' + pointX + ' ' + control.bounds.y + ' ');\n                majorTick = majorTick.concat('M ' + (pointX) + ' ' + (rect.y + rect.height) +\n                    ' L ' + (pointX) + ' ' + tick + ' ');\n            }\n        }\n        var options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(control.element.id + '_MajorGridLine', 'transparent', majorGridLines.width, control.series.length ? disabledColor || majorGridLines.color || control.themeStyle.gridLineColor : 'transparent', 1, majorGridLines.dashArray, majorGrid);\n        this.gridLines.appendChild(control.renderer.drawPath(options));\n        options = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(control.element.id + '_MajorTickLine', 'transparent', majorTickLines.width, disabledColor || majorTickLines.color || control.themeStyle.gridLineColor, 1, majorGridLines.dashArray, majorTick);\n        this.gridLines.appendChild(control.renderer.drawPath(options));\n    };\n    /**\n     * To render of axis labels.\n     *\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.renderAxisLabels = function () {\n        var axis = this.rangeNavigator.chartSeries.xAxis;\n        var control = this.rangeNavigator;\n        var pointY;\n        var labelElement = control.renderer.createGroup({ id: control.element.id + '_AxisLabels' });\n        var firstLevelElement = control.renderer.createGroup({ id: control.element.id + '_FirstLevelAxisLabels' });\n        var secondLevelElement = control.renderer.createGroup({ id: control.element.id + '_SecondLevelAxisLabels' });\n        var secondaryAxis = axis;\n        pointY = this.findLabelY(control, false);\n        this.placeAxisLabels(axis, pointY, '_AxisLabel_', control, firstLevelElement);\n        secondaryAxis.intervalType = secondaryAxis.actualIntervalType = (control.groupBy ||\n            this.getSecondaryLabelType(axis.actualIntervalType));\n        secondaryAxis.labelFormat = '';\n        if (control.enableGrouping && control.valueType.indexOf('DateTime') > -1 && this.actualIntervalType !== 'Years') {\n            secondaryAxis.visibleRange.interval = 1;\n            secondaryAxis.visibleLabels = [];\n            var interval = this.calculateDateTimeNiceInterval(secondaryAxis, control.bounds, secondaryAxis.doubleRange.start, secondaryAxis.doubleRange.end, secondaryAxis.isChart);\n            if (control.valueType === 'DateTime') {\n                this.findAxisLabels(secondaryAxis, interval);\n            }\n            else {\n                this.findSecondaryAxisLabels(secondaryAxis);\n            }\n            this.secondLevelLabels = secondaryAxis.visibleLabels;\n            pointY = this.findLabelY(control, true);\n            var border = this.placeAxisLabels(secondaryAxis, pointY, '_SecondaryLabel_', control, secondLevelElement);\n            var path = new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.PathOption(control.element.id + '_SecondaryMajorLines', 'transparent', control.majorTickLines.width, control.majorTickLines.color || control.themeStyle.gridLineColor, 1, control.majorGridLines.dashArray, border);\n            this.gridLines.appendChild(control.renderer.drawPath(path));\n        }\n        control.chartSeries.xAxis.visibleLabels = control.chartSeries.xAxis.visibleLabels.concat(secondaryAxis.visibleLabels);\n        labelElement.style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';\n        labelElement.appendChild(firstLevelElement);\n        labelElement.appendChild(secondLevelElement);\n        //gridlines and axis label append to element\n        control.svgObject.appendChild(this.gridLines);\n        control.svgObject.appendChild(labelElement);\n    };\n    /**\n     * To find the secondary level label type.\n     *\n     * @param {RangeIntervalType} type - The type of range interval.\n     * @returns {RangeIntervalType} - The secondary level label type.\n     */\n    RangeNavigatorAxis.prototype.getSecondaryLabelType = function (type) {\n        var types = ['Years', 'Quarter', 'Months', 'Weeks', 'Days', 'Hours', 'Minutes', 'Seconds'];\n        return (type === 'Years' ? 'Years' : types[types.indexOf(type) - 1]);\n    };\n    /**\n     * To find labels for date time category axis.\n     *\n     * @param {Axis} axis - Range axis.\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.findSecondaryAxisLabels = function (axis) {\n        axis.visibleLabels = [];\n        axis.visibleRange.interval = Math.max(axis.visibleRange.interval, 1);\n        var previousIndex;\n        this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\n            format: axis.labelFormat || '',\n            type: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.firstToLowerCase)(axis.skeleton), skeleton: this.getSkeleton(axis, null, null)\n        });\n        for (var i = Math.ceil(axis.visibleRange.min); i <= axis.visibleRange.max; i += axis.visibleRange.interval) {\n            if ((!this.rangeNavigator.dateTimeCategoryModule.sameInterval(axis.labels.map(Number)[i], axis.labels.map(Number)[i - axis.visibleRange.interval], axis.actualIntervalType, i) || axis.isIndexed)\n                && (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.withIn)(i, axis.visibleRange)\n                && this.rangeNavigator.dateTimeCategoryModule.isMaximum(i, previousIndex, axis)) {\n                var currentLabel = new Date(axis.labels.map(Number)[i]);\n                if (axis.actualIntervalType === 'Quarter') {\n                    var quarterMonths = [0, 3, 6, 9];\n                    var quarterIndex = Math.floor(currentLabel.getMonth() / 3);\n                    currentLabel.setMonth(quarterMonths[quarterIndex]);\n                }\n                axis.visibleLabels.push(new _chart_axis_axis__WEBPACK_IMPORTED_MODULE_3__.VisibleLabels(this.dateFormats(this.rangeNavigator.format(currentLabel), axis, axis.visibleLabels.length), i, this.rangeNavigator.labelStyle, this.rangeNavigator.format(currentLabel)));\n                previousIndex = i;\n            }\n        }\n    };\n    /**\n     * To find labels for date time axis.\n     *\n     * @param {Axis} axis - Range axis.\n     * @param {number} interval - Interval for the date time axis.\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.findAxisLabels = function (axis, interval) {\n        axis.visibleLabels = [];\n        var start = new Date(axis.visibleRange.min);\n        var nextInterval;\n        var text;\n        interval = this.rangeNavigator.interval ? this.rangeNavigator.interval : interval;\n        switch (axis.actualIntervalType) {\n            case 'Years':\n                start = new Date(start.getFullYear(), 0, 1);\n                break;\n            case 'Quarter':\n                if (start.getMonth() <= 2) {\n                    start = new Date(start.getFullYear(), 0, 1);\n                }\n                else if (start.getMonth() <= 5) {\n                    start = new Date(start.getFullYear(), 3, 1);\n                }\n                else if (start.getMonth() <= 8) {\n                    start = new Date(start.getFullYear(), 6, 1);\n                }\n                else {\n                    start = new Date(start.getFullYear(), 9, 1);\n                }\n                break;\n            case 'Months':\n                start = new Date(start.getFullYear(), start.getMonth());\n                break;\n            case 'Weeks':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate() - start.getDay());\n                break;\n            case 'Days':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate());\n                break;\n            case 'Hours':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours());\n                break;\n            case 'Minutes':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes());\n                break;\n            case 'Seconds':\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());\n                break;\n        }\n        nextInterval = start.getTime();\n        this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\n            format: axis.labelFormat || '',\n            type: (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.firstToLowerCase)(axis.skeletonType), skeleton: this.getSkeleton(axis, null, null)\n        });\n        while (nextInterval <= axis.visibleRange.max) {\n            text = this.dateFormats(this.rangeNavigator.format(new Date(nextInterval)), axis, axis.visibleLabels.length);\n            axis.visibleLabels.push(new _chart_axis_axis__WEBPACK_IMPORTED_MODULE_3__.VisibleLabels(text, nextInterval, this.rangeNavigator.labelStyle, text));\n            nextInterval = this.increaseDateTimeInterval(axis, nextInterval, interval).getTime();\n        }\n    };\n    /**\n     * To find date time formats for Quarter and week interval type.\n     *\n     * @param {string} text - The text.\n     * @param {Axis} axis - The axis.\n     * @param {number} index - The index.\n     * @returns {string} - The modified text.\n     */\n    RangeNavigatorAxis.prototype.dateFormats = function (text, axis, index) {\n        var changedText = text;\n        var isFirstLevel = this.rangeNavigator.enableGrouping && this.firstLevelLabels.length === 0;\n        switch (axis.actualIntervalType) {\n            case 'Quarter':\n                if (text.indexOf('Jan') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Jan', 'Quarter1') : 'Quarter1';\n                }\n                else if (text.indexOf('Apr') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Apr', 'Quarter2') : 'Quarter2';\n                }\n                else if (text.indexOf('Jul') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Jul', 'Quarter3') : 'Quarter3';\n                }\n                else if (text.indexOf('Oct') > -1) {\n                    changedText = !isFirstLevel ? text.replace('Oct', 'Quarter4') : 'Quarter4';\n                }\n                break;\n            case 'Weeks':\n                changedText = 'Week' + ++index;\n                break;\n            default:\n                changedText = text;\n                break;\n        }\n        return changedText;\n    };\n    /**\n     * To find the y co-ordinate for axis labels.\n     *\n     * @param {RangeNavigator} control - The RangeNavigator control.\n     * @param {boolean} isSecondary - If sets to true, indicates that the axis is a secondary axis.\n     * @returns {number} - The y-coordinate for the labels.\n     */\n    RangeNavigatorAxis.prototype.findLabelY = function (control, isSecondary) {\n        var pointY;\n        var reference = control.bounds.y + control.bounds.height;\n        var tickHeight = control.majorTickLines.height;\n        var textHeight = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)('Quarter1 2011', control.labelStyle, control.themeStyle.axisLabelFont).height;\n        var padding = control.labelPosition === 'Inside' ? 3 : 8;\n        if ((control.labelPosition === 'Outside' && control.tickPosition === 'Outside') || control.series.length === 0) {\n            pointY = reference + tickHeight + padding + textHeight * 0.75;\n        }\n        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Inside') {\n            pointY = reference - tickHeight - padding;\n        }\n        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Outside') {\n            pointY = reference - padding;\n        }\n        else {\n            pointY = reference + padding + (textHeight * 0.75);\n        }\n        if (isSecondary) {\n            padding = 15;\n            if (control.labelPosition === 'Outside' || control.series.length === 0) {\n                pointY += padding + textHeight * 0.75;\n            }\n            else {\n                pointY = (control.tickPosition === 'Outside' || control.series.length === 0) ?\n                    reference + tickHeight + padding + textHeight * 0.75 : reference + padding + textHeight * 0.75;\n            }\n        }\n        return pointY;\n    };\n    /**\n     * It places the axis labels and returns border for secondary axis labels.\n     *\n     * @param {Axis} axis - Axis for the lables placed.\n     * @param {number} pointY - The y co-ordinate for axis labels.\n     * @param {string} id - The id for the axis elements.\n     * @param {RangeNavigator} control - The range navigator control.\n     * @param {Element} labelElement - The parent element in which the axis labels are appended.\n     * @returns {string} - The border for the secondary axis labels.\n     */\n    RangeNavigatorAxis.prototype.placeAxisLabels = function (axis, pointY, id, control, labelElement) {\n        var maxLabels = axis.visibleLabels.length;\n        var label;\n        var prevLabel;\n        var pointX;\n        var padding = 2;\n        var rect = control.bounds;\n        var border = '';\n        var pointXGrid;\n        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;\n        var prevX = control.enableRtl ? (rect.x + rect.width) : rect.x;\n        var intervalType = axis.actualIntervalType;\n        var intervalInTime = ((control.labelPlacement === 'Auto' && control.valueType === 'DateTime') || control.labelPlacement === 'BetweenTicks') ?\n            maxLabels > 1 ? (axis.visibleLabels[1].value - axis.visibleLabels[0].value) :\n                (axis.visibleRange.max - axis.visibleLabels[0].value) / 2 : 0;\n        if (control.valueType.indexOf('DateTime') > -1 && (intervalType === 'Quarter' || intervalType === 'Weeks')) {\n            this.findSuitableFormat(axis, control);\n        }\n        for (var i = 0, len = maxLabels; i < len; i++) {\n            label = axis.visibleLabels[i];\n            label.size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)(label.text, axis.labelStyle, control.themeStyle.axisLabelFont);\n            if ((control.secondaryLabelAlignment === 'Middle' || id.indexOf('_AxisLabel_') > -1) && (control.labelPlacement === 'Auto' || control.labelPlacement === 'BetweenTicks')) {\n                pointX = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)((label.value + intervalInTime / 2), axis) * rect.width) + rect.x;\n            }\n            else if ((id.indexOf('Secondary') > -1)) {\n                pointX = this.findAlignment(axis, i);\n            }\n            if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Inside') {\n                pointX = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)(label.value, axis) * rect.width) + rect.x + label.size.width / 2 + padding;\n            }\n            else if (control.labelPlacement === 'OnTicks' && control.labelPosition === 'Outside') {\n                pointX = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)(label.value, axis) * rect.width) + rect.x;\n            }\n            pointXGrid = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)((label.value), axis) * rect.width) + rect.x;\n            //edgelabelPlacements\n            if ((i === 0 || (i === axis.visibleLabels.length - 1 && control.enableRtl)) && pointX < rect.x) {\n                pointX = rect.x + label.size.width / 2;\n            }\n            if ((i === axis.visibleLabels.length - 1 || (i === 0 && control.enableRtl)) &&\n                ((pointX + label.size.width) > (rect.x + rect.width))) {\n                pointX = rect.x + rect.width - label.size.width / 2;\n            }\n            //secondary axis grid lines\n            if (id.indexOf('_SecondaryLabel_') > -1) {\n                if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\n                    border = border.concat('M ' + pointXGrid + ' ' + pointY +\n                        ' L ' + pointXGrid + ' ' + (pointY - label.size.height));\n                }\n            }\n            //smart axis label position,\n            if (control.labelIntersectAction === 'Hide' &&\n                i !== 0 && this.isIntersect(axis, pointX, label.size.width, prevX, prevLabel.size.width)) {\n                continue;\n            }\n            //label alignment for single visible label\n            if (control.secondaryLabelAlignment === 'Middle' && axis.visibleLabels.length === 1) {\n                pointX = (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)(label.value, axis) + (rect.x + (rect.width / 2));\n            }\n            //labelrender event\n            var labelStyle = control.labelStyle;\n            var style = {\n                size: labelStyle.size, color: disabledColor || labelStyle.color || control.themeStyle.axisLabelFont.color,\n                fontFamily: labelStyle.fontFamily,\n                fontStyle: labelStyle.fontStyle || control.labelStyle.fontStyle,\n                fontWeight: labelStyle.fontWeight || control.labelStyle.fontWeight,\n                opacity: labelStyle.opacity || control.labelStyle.opacity,\n                textAlignment: labelStyle.textAlignment || control.labelStyle.textAlignment,\n                textOverflow: labelStyle.textOverflow || control.labelStyle.textOverflow\n            };\n            var argsData = {\n                cancel: false, name: 'labelRender',\n                text: label.text, value: label.value, labelStyle: style,\n                region: new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.Rect(pointX, pointY, label.size.width, label.size.height)\n            };\n            control.trigger('labelRender', argsData);\n            if (!argsData.cancel) {\n                control.labels.push(argsData);\n            }\n            else {\n                continue;\n            }\n            (0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.textElement)(this.rangeNavigator.renderer, new _syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.TextOption(this.rangeNavigator.element.id + id + i, pointX, pointY, 'middle', argsData.text), argsData.labelStyle, argsData.labelStyle.color || control.themeStyle.labelFontColor, labelElement, null, null, null, null, null, null, null, null, null, null, control.themeStyle.axisLabelFont).style.cursor = axis.valueType.indexOf('DateTime') > -1 ? 'cursor: pointer' : 'cursor: default';\n            prevX = pointX;\n            prevLabel = label;\n        }\n        return border;\n    };\n    /**\n     * To check label is intersected with successive label or not.\n     *\n     * @param {Axis} axis - The axis for which the labels are placed.\n     * @param {number} currentX - The x-coordinate for the current label.\n     * @param {number} currentWidth - The width of the current label.\n     * @param {number} prevX - The x-coordinate for the previous label.\n     * @param {number} prevWidth - The width of the previous label.\n     * @returns {boolean} - True if the labels intersect; otherwise, false.\n     */\n    RangeNavigatorAxis.prototype.isIntersect = function (axis, currentX, currentWidth, prevX, prevWidth) {\n        return (axis.isInversed) ? (currentX + currentWidth / 2 > prevX - prevWidth / 2) :\n            (currentX - currentWidth / 2 < prevX + prevWidth / 2);\n    };\n    /**\n     * To find suitable label format for Quarter and week Interval types.\n     *\n     * @param {Axis} axis - RangeNavigator axis.\n     * @param {RangeNavigator} control - RangeNavigator instance.\n     * @returns {void}\n     */\n    RangeNavigatorAxis.prototype.findSuitableFormat = function (axis, control) {\n        var labels = axis.visibleLabels;\n        var labelLength = labels.length;\n        var bounds = control.bounds;\n        var prevX;\n        var currentX;\n        var interval = control.valueType === 'DateTime' ?\n            labelLength > 1 ? (labels[1].value - labels[0].value) : axis.visibleRange.interval\n            : 0;\n        for (var i = 0; i < labelLength; i++) {\n            currentX = ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)((labels[i].value + interval / 2), axis) * bounds.width) + bounds.x;\n            labels[i].size = (0,_syncfusion_ej2_svg_base__WEBPACK_IMPORTED_MODULE_1__.measureText)(labels[i].text, axis.labelStyle, control.themeStyle.axisLabelFont);\n            //edgelabelPlacements\n            if (i === 0 && currentX < bounds.x) {\n                currentX = bounds.x + labels[i].size.width / 2;\n            }\n            if (axis.actualIntervalType === 'Quarter') {\n                if (i !== 0) {\n                    if ((labels[i].text.indexOf('Quarter') > -1) &&\n                        (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width))) {\n                        labels.every(function (label) {\n                            label.text = label.text.toString().replace('Quarter', 'QTR');\n                            return true;\n                        });\n                        axis.visibleLabels = labels;\n                        this.findSuitableFormat(axis, control);\n                    }\n                    else {\n                        if (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n                            labels.every(function (label) {\n                                label.text = label.text.toString().replace('QTR', 'Q');\n                                return true;\n                            });\n                            axis.visibleLabels = labels;\n                        }\n                    }\n                }\n            }\n            else if (axis.actualIntervalType === 'Weeks') {\n                if ((i !== 0) && ((labels[i].text.indexOf('Week') > -1) &&\n                    (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)))) {\n                    labels.every(function (label) {\n                        label.text = label.text.toString().replace('Week', 'W');\n                        return true;\n                    });\n                    axis.visibleLabels = labels;\n                }\n            }\n            prevX = currentX;\n        }\n    };\n    /**\n     * Alignment position for secondary level labels in date time axis.\n     *\n     * @param {Axis} axis - The axis.\n     * @param {number} index - The index of the label.\n     * @returns {number} - The alignment position for the secondary axis labels.\n     */\n    RangeNavigatorAxis.prototype.findAlignment = function (axis, index) {\n        var label = axis.visibleLabels[index];\n        var nextLabel = axis.visibleLabels[index + 1];\n        var bounds = this.rangeNavigator.bounds;\n        return (this.rangeNavigator.secondaryLabelAlignment === 'Near' ?\n            ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)((label.value), axis) * bounds.width) + bounds.x + label.size.width / 2 :\n            ((0,_common_utils_helper__WEBPACK_IMPORTED_MODULE_0__.valueToCoefficient)((nextLabel ? nextLabel.value : axis.visibleRange.max), axis) * bounds.width) + bounds.x - label.size.width);\n    };\n    return RangeNavigatorAxis;\n}(_chart_axis_date_time_axis__WEBPACK_IMPORTED_MODULE_2__.DateTime));\n\n\n\n//# sourceURL=webpack://ej2-vue-samples/./node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/range-axis.js?");

/***/ })

}]);